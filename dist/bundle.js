(()=>{var __webpack_modules__={108:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(540);\n// EXTERNAL MODULE: ./node_modules/react-dom/client.js\nvar client = __webpack_require__(338);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(961);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(72);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js\nvar styleDomAPI = __webpack_require__(825);\nvar styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js\nvar insertBySelector = __webpack_require__(659);\nvar insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\nvar setAttributesWithoutAttributes = __webpack_require__(56);\nvar setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js\nvar insertStyleElement = __webpack_require__(159);\nvar insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js\nvar styleTagTransform = __webpack_require__(113);\nvar styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/styles.css\nvar styles = __webpack_require__(408);\n;// ./src/styles.css\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (styleTagTransform_default());\noptions.setAttributes = (setAttributesWithoutAttributes_default());\noptions.insert = insertBySelector_default().bind(null, "head");\noptions.domAPI = (styleDomAPI_default());\noptions.insertStyleElement = (insertStyleElement_default());\n\nvar update = injectStylesIntoStyleTag_default()(styles/* default */.A, options);\n\n\n\n\n       /* harmony default export */ const src_styles = (styles/* default */.A && styles/* default */.A.locals ? styles/* default */.A.locals : undefined);\n\n;// ./node_modules/framer-motion/dist/es/render/components/create-proxy.mjs\n\n\nfunction createDOMMotionComponentProxy(componentFactory) {\n    if (typeof Proxy === "undefined") {\n        return componentFactory;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    const componentCache = new Map();\n    const deprecatedFactoryFunction = (...args) => {\n        if (false) {}\n        return componentFactory(...args);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: (_target, key) => {\n            if (key === "create")\n                return componentFactory;\n            /**\n             * If this element doesn\'t exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, componentFactory(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === "object" &&\n        typeof v.start === "function");\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nconst isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === "string" || Array.isArray(v);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === "function") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === "string") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we\'ve resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === "function") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\n\n\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/variant-props.mjs\nconst variantPriorityOrder = [\n    "animate",\n    "whileInView",\n    "whileFocus",\n    "whileHover",\n    "whileTap",\n    "whileDrag",\n    "exit",\n];\nconst variantProps = ["initial", ...variantPriorityOrder];\n\n\n\n;// ./node_modules/motion-utils/dist/es/memo.mjs\n/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs\n\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs\n\n\nclass BaseGroup_BaseGroupPlaybackControls {\n    constructor(animations) {\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = () => this.runAll("stop");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        // Support for new finished Promise and legacy thennable API\n        return Promise.all(this.animations.map((animation) => "finished" in animation ? animation.finished : animation));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline, fallback) {\n        const subscriptions = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                return animation.attachTimeline(timeline);\n            }\n            else if (typeof fallback === "function") {\n                return fallback(animation);\n            }\n        });\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll("time");\n    }\n    set time(time) {\n        this.setAll("time", time);\n    }\n    get speed() {\n        return this.getAll("speed");\n    }\n    set speed(speed) {\n        this.setAll("speed", speed);\n    }\n    get startTime() {\n        return this.getAll("startTime");\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    flatten() {\n        this.runAll("flatten");\n    }\n    play() {\n        this.runAll("play");\n    }\n    pause() {\n        this.runAll("pause");\n    }\n    cancel() {\n        this.runAll("cancel");\n    }\n    complete() {\n        this.runAll("complete");\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/controls/Group.mjs\n\n\n/**\n * TODO: This is a temporary class to support the legacy\n * thennable API\n */\nclass GroupPlaybackControls extends BaseGroup_BaseGroupPlaybackControls {\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs\nfunction get_value_transition_getValueTransition(transition, key) {\n    return transition\n        ? transition[key] ||\n            transition["default"] ||\n            transition\n        : undefined;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs\nfunction isGenerator(type) {\n    return typeof type === "function";\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs\nfunction attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/flags.mjs\n/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {\n    linearEasing: undefined,\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/memo.mjs\n\n\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs\n\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement("div")\n            .animate({ opacity: 0 }, { easing: "linear(0, 1)" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, "linearEasing");\n\n\n\n;// ./node_modules/motion-utils/dist/es/progress.mjs\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs\n\n\nconst generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = "";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + ", ";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs\n\n\n\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean((typeof easing === "function" && supportsLinearEasing()) ||\n        !easing ||\n        (typeof easing === "string" &&\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: "linear",\n    ease: "ease",\n    easeIn: "ease-in",\n    easeOut: "ease-out",\n    easeInOut: "ease-in-out",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction easing_mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === "function" && supportsLinearEasing()) {\n        return generateLinearEasing(easing, duration);\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => easing_mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs\nconst isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/resolve-elements.mjs\nfunction resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof Element) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === "string") {\n        let root = document;\n        if (scope) {\n            // TODO: Refactor to utils package\n            // invariant(\n            //     Boolean(scope.current),\n            //     "Scope provided, but no element detected."\n            // )\n            root = scope.current;\n        }\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/utils/setup.mjs\n\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/hover.mjs\n\n\n\nfunction isValidHover(event) {\n    return !(event.pointerType === "touch" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener("pointerenter")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the "pointerennd" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = (enterEvent) => {\n        if (!isValidHover(enterEvent))\n            return;\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(target, enterEvent);\n        if (typeof onHoverEnd !== "function" || !target)\n            return;\n        const onPointerLeave = (leaveEvent) => {\n            if (!isValidHover(leaveEvent))\n                return;\n            onHoverEnd(leaveEvent);\n            target.removeEventListener("pointerleave", onPointerLeave);\n        };\n        target.addEventListener("pointerleave", onPointerLeave, eventOptions);\n    };\n    elements.forEach((element) => {\n        element.addEventListener("pointerenter", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs\nconst isPrimaryPointer = (event) => {\n    if (event.pointerType === "mouse") {\n        return typeof event.button !== "number" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs\nconst focusableElements = new Set([\n    "BUTTON",\n    "INPUT",\n    "SELECT",\n    "TEXTAREA",\n    "A",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs\nconst isPressing = new WeakSet();\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs\n\n\n/**\n * Filter out events that are not "Enter" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== "Enter")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, "down");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, "up");\n        });\n        const handleBlur = () => firePointerEvent(element, "cancel");\n        element.addEventListener("keyup", handleKeyup, eventOptions);\n        element.addEventListener("blur", handleBlur, eventOptions);\n    });\n    element.addEventListener("keydown", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/index.mjs\n\n\n\n\n\n\n\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `"pointerdown"`, `"pointerup"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `"keydown"` and `"keyup"` events.\n *\n * This is different to a browser\'s `"click"` event, which does\n * respond to keyboards but only for the `"click"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart, options = {}) {\n    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n    const startPress = (startEvent) => {\n        const element = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent) || isPressing.has(element))\n            return;\n        isPressing.add(element);\n        const onPressEnd = onPressStart(element, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener("pointerup", onPointerUp);\n            window.removeEventListener("pointercancel", onPointerCancel);\n            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n                return;\n            }\n            isPressing.delete(element);\n            if (typeof onPressEnd === "function") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, options.useGlobalTarget ||\n                isNodeOrChild(element, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener("pointerup", onPointerUp, eventOptions);\n        window.addEventListener("pointercancel", onPointerCancel, eventOptions);\n    };\n    elements.forEach((element) => {\n        if (!isElementKeyboardAccessible(element) &&\n            element.getAttribute("tabindex") === null) {\n            element.tabIndex = 0;\n        }\n        const target = options.useGlobalTarget ? window : element;\n        target.addEventListener("pointerdown", startPress, eventOptions);\n        element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n    });\n    return cancelEvents;\n}\n\n\n\n;// ./node_modules/motion-utils/dist/es/time-conversion.mjs\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst time_conversion_secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\n\n\n;// ./node_modules/motion-utils/dist/es/noop.mjs\n/*#__NO_SIDE_EFFECTS__*/\nconst noop_noop = (any) => any;\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/NativeAnimationControls.mjs\n\n\n\nclass NativeAnimationControls_NativeAnimationControls {\n    constructor(animation) {\n        this.animation = animation;\n    }\n    get duration() {\n        var _a, _b, _c;\n        const durationInMs = ((_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.effect) === null || _b === void 0 ? void 0 : _b.getComputedTiming().duration) ||\n            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.duration) ||\n            300;\n        return millisecondsToSeconds(Number(durationInMs));\n    }\n    get time() {\n        var _a;\n        if (this.animation) {\n            return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n        }\n        return 0;\n    }\n    set time(newTime) {\n        if (this.animation) {\n            this.animation.currentTime = time_conversion_secondsToMilliseconds(newTime);\n        }\n    }\n    get speed() {\n        return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n        if (this.animation) {\n            this.animation.playbackRate = newSpeed;\n        }\n    }\n    get state() {\n        return this.animation ? this.animation.playState : "finished";\n    }\n    get startTime() {\n        return this.animation ? this.animation.startTime : null;\n    }\n    get finished() {\n        return this.animation ? this.animation.finished : Promise.resolve();\n    }\n    play() {\n        this.animation && this.animation.play();\n    }\n    pause() {\n        this.animation && this.animation.pause();\n    }\n    stop() {\n        if (!this.animation ||\n            this.state === "idle" ||\n            this.state === "finished") {\n            return;\n        }\n        if (this.animation.commitStyles) {\n            this.animation.commitStyles();\n        }\n        this.cancel();\n    }\n    flatten() {\n        var _a;\n        if (!this.animation)\n            return;\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });\n    }\n    attachTimeline(timeline) {\n        if (this.animation)\n            attachTimeline(this.animation, timeline);\n        return noop_noop;\n    }\n    complete() {\n        this.animation && this.animation.finish();\n    }\n    cancel() {\n        try {\n            this.animation && this.animation.cancel();\n        }\n        catch (e) { }\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs\n\n\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: "keyframes",\n        ease: (progress) => {\n            return generator.next(duration * progress).value / scale;\n        },\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/convert-options.mjs\n\n\n\n\n\n\nconst defaultEasing = "easeOut";\nfunction convert_options_applyGeneratorOptions(options) {\n    var _a;\n    if (isGenerator(options.type)) {\n        const generatorOptions = createGeneratorEasing(options, 100, options.type);\n        options.ease = supportsLinearEasing()\n            ? generatorOptions.ease\n            : defaultEasing;\n        options.duration = time_conversion_secondsToMilliseconds(generatorOptions.duration);\n        options.type = "keyframes";\n    }\n    else {\n        options.duration = time_conversion_secondsToMilliseconds((_a = options.duration) !== null && _a !== void 0 ? _a : 0.3);\n        options.ease = options.ease || defaultEasing;\n    }\n}\n// TODO: Reuse for NativeAnimation\nfunction convertMotionOptionsToNative(valueName, keyframes, options) {\n    var _a;\n    const nativeKeyframes = {};\n    const nativeOptions = {\n        fill: "both",\n        easing: "linear",\n        composite: "replace",\n    };\n    nativeOptions.delay = time_conversion_secondsToMilliseconds((_a = options.delay) !== null && _a !== void 0 ? _a : 0);\n    convert_options_applyGeneratorOptions(options);\n    nativeOptions.duration = options.duration;\n    const { ease, times } = options;\n    if (times)\n        nativeKeyframes.offset = times;\n    nativeKeyframes[valueName] = keyframes;\n    const easing = easing_mapEasingToNativeEasing(ease, options.duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing)) {\n        nativeKeyframes.easing = easing;\n    }\n    else {\n        nativeOptions.easing = easing;\n    }\n    return {\n        keyframes: nativeKeyframes,\n        options: nativeOptions,\n    };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/PseudoAnimation.mjs\n\n\n\nclass PseudoAnimation_PseudoAnimation extends NativeAnimationControls_NativeAnimationControls {\n    constructor(target, pseudoElement, valueName, keyframes, options) {\n        const animationOptions = convertMotionOptionsToNative(valueName, keyframes, options);\n        const animation = target.animate(animationOptions.keyframes, {\n            pseudoElement,\n            ...animationOptions.options,\n        });\n        super(animation);\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/view/utils/css.mjs\nlet pendingRules = {};\nlet style = null;\nconst css_css = {\n    set: (selector, values) => {\n        pendingRules[selector] = values;\n    },\n    commit: () => {\n        if (!style) {\n            style = document.createElement("style");\n            style.id = "motion-view";\n        }\n        let cssText = "";\n        for (const selector in pendingRules) {\n            const rule = pendingRules[selector];\n            cssText += `${selector} {\\n`;\n            for (const [property, value] of Object.entries(rule)) {\n                cssText += `  ${property}: ${value};\\n`;\n            }\n            cssText += "}\\n";\n        }\n        style.textContent = cssText;\n        document.head.appendChild(style);\n        pendingRules = {};\n    },\n    remove: () => {\n        if (style && style.parentElement) {\n            style.parentElement.removeChild(style);\n        }\n    },\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/view/start.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst definitionNames = (/* unused pure expression or super */ null && (["layout", "enter", "exit", "new", "old"]));\nfunction start_startViewAnimation(update, defaultOptions, targets) {\n    if (!document.startViewTransition) {\n        return new Promise(async (resolve) => {\n            await update();\n            resolve(new BaseGroupPlaybackControls([]));\n        });\n    }\n    // TODO: Go over existing targets and ensure they all have ids\n    /**\n     * If we don\'t have any animations defined for the root target,\n     * remove it from being captured.\n     */\n    if (!hasTarget("root", targets)) {\n        css.set(":root", {\n            "view-transition-name": "none",\n        });\n    }\n    /**\n     * Set the timing curve to linear for all view transition layers.\n     * This gets baked into the keyframes, which can\'t be changed\n     * without breaking the generated animation.\n     *\n     * This allows us to set easing via updateTiming - which can be changed.\n     */\n    css.set("::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)", { "animation-timing-function": "linear !important" });\n    css.commit(); // Write\n    const transition = document.startViewTransition(async () => {\n        await update();\n        // TODO: Go over new targets and ensure they all have ids\n    });\n    transition.finished.finally(() => {\n        css.remove(); // Write\n    });\n    return new Promise((resolve) => {\n        transition.ready.then(() => {\n            var _a;\n            const generatedViewAnimations = getViewAnimations();\n            const animations = [];\n            /**\n             * Create animations for our definitions\n             */\n            targets.forEach((definition, target) => {\n                // TODO: If target is not "root", resolve elements\n                // and iterate over each\n                for (const key of definitionNames) {\n                    if (!definition[key])\n                        continue;\n                    const { keyframes, options } = definition[key];\n                    for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\n                        if (!valueKeyframes)\n                            continue;\n                        const valueOptions = {\n                            ...getValueTransition(defaultOptions, valueName),\n                            ...getValueTransition(options, valueName),\n                        };\n                        const type = chooseLayerType(key);\n                        /**\n                         * If this is an opacity animation, and keyframes are not an array,\n                         * we need to convert them into an array and set an initial value.\n                         */\n                        if (valueName === "opacity" &&\n                            !Array.isArray(valueKeyframes)) {\n                            const initialValue = type === "new" ? 0 : 1;\n                            valueKeyframes = [initialValue, valueKeyframes];\n                        }\n                        /**\n                         * Resolve stagger function if provided.\n                         */\n                        if (typeof valueOptions.delay === "function") {\n                            valueOptions.delay = valueOptions.delay(0, 1);\n                        }\n                        const animation = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);\n                        animations.push(animation);\n                    }\n                }\n            });\n            /**\n             * Handle browser generated animations\n             */\n            for (const animation of generatedViewAnimations) {\n                if (animation.playState === "finished")\n                    continue;\n                const { effect } = animation;\n                if (!effect || !(effect instanceof KeyframeEffect))\n                    continue;\n                const { pseudoElement } = effect;\n                if (!pseudoElement)\n                    continue;\n                const name = getLayerName(pseudoElement);\n                if (!name)\n                    continue;\n                const targetDefinition = targets.get(name.layer);\n                if (!targetDefinition) {\n                    /**\n                     * If transition name is group then update the timing of the animation\n                     * whereas if it\'s old or new then we could possibly replace it using\n                     * the above method.\n                     */\n                    const transitionName = name.type === "group" ? "layout" : "";\n                    const animationTransition = {\n                        ...getValueTransition(defaultOptions, transitionName),\n                    };\n                    applyGeneratorOptions(animationTransition);\n                    const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);\n                    effect.updateTiming({\n                        delay: secondsToMilliseconds((_a = animationTransition.delay) !== null && _a !== void 0 ? _a : 0),\n                        duration: animationTransition.duration,\n                        easing,\n                    });\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else if (hasOpacity(targetDefinition, "enter") &&\n                    hasOpacity(targetDefinition, "exit") &&\n                    effect\n                        .getKeyframes()\n                        .some((keyframe) => keyframe.mixBlendMode)) {\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else {\n                    animation.cancel();\n                }\n            }\n            resolve(new BaseGroupPlaybackControls(animations));\n        });\n    });\n}\nfunction hasOpacity(target, key) {\n    var _a;\n    return (_a = target === null || target === void 0 ? void 0 : target[key]) === null || _a === void 0 ? void 0 : _a.keyframes.opacity;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/view/index.mjs\n\n\n\n/**\n * TODO:\n * - Create view transition on next tick\n * - Replace animations with Motion animations\n * - Return GroupAnimation on next tick\n */\nclass ViewTransitionBuilder {\n    constructor(update, options = {}) {\n        this.currentTarget = "root";\n        this.targets = new Map();\n        this.notifyReady = noop;\n        this.readyPromise = new Promise((resolve) => {\n            this.notifyReady = resolve;\n        });\n        queueMicrotask(() => {\n            startViewAnimation(update, options, this.targets).then((animation) => this.notifyReady(animation));\n        });\n    }\n    get(selector) {\n        this.currentTarget = selector;\n        return this;\n    }\n    layout(keyframes, options) {\n        this.updateTarget("layout", keyframes, options);\n        return this;\n    }\n    new(keyframes, options) {\n        this.updateTarget("new", keyframes, options);\n        return this;\n    }\n    old(keyframes, options) {\n        this.updateTarget("old", keyframes, options);\n        return this;\n    }\n    enter(keyframes, options) {\n        this.updateTarget("enter", keyframes, options);\n        return this;\n    }\n    exit(keyframes, options) {\n        this.updateTarget("exit", keyframes, options);\n        return this;\n    }\n    crossfade(options) {\n        this.updateTarget("enter", { opacity: 1 }, options);\n        this.updateTarget("exit", { opacity: 0 }, options);\n        return this;\n    }\n    updateTarget(target, keyframes, options = {}) {\n        const { currentTarget, targets } = this;\n        if (!targets.has(currentTarget)) {\n            targets.set(currentTarget, {});\n        }\n        const targetData = targets.get(currentTarget);\n        targetData[target] = { keyframes, options };\n    }\n    then(resolve, reject) {\n        return this.readyPromise.then(resolve, reject);\n    }\n}\nfunction view(update, defaultOptions = {}) {\n    return new ViewTransitionBuilder(update, defaultOptions);\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs\n\n\nfunction setDragLock(axis) {\n    if (axis === "x" || axis === "y") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    "transformPerspective",\n    "x",\n    "y",\n    "z",\n    "translateX",\n    "translateY",\n    "translateZ",\n    "scale",\n    "scaleX",\n    "scaleY",\n    "rotate",\n    "rotateX",\n    "rotateY",\n    "rotateZ",\n    "skew",\n    "skewX",\n    "skewY",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs\n\n\nconst positionalKeys = new Set([\n    "width",\n    "height",\n    "top",\n    "left",\n    "right",\n    "bottom",\n    ...transformPropOrder,\n]);\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/resolve-value.mjs\n\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === "object" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs\nconst MotionGlobalConfig = {\n    skipAnimations: false,\n    useManualTiming: false,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/render-step.mjs\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we\'re currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we\'re already processing we\'ve probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/batcher.mjs\n\n\n\nconst stepsOrder = [\n    "read", // Read\n    "resolveKeyframes", // Write/Read/Write/Read\n    "update", // Compute\n    "preRender", // Compute\n    "render", // Write\n    "postRender", // Compute\n];\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame);\n        return acc;\n    }, {});\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        read.process(state);\n        resolveKeyframes.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/frame.mjs\n\n\n\nconst { schedule: frame_frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop_noop, true);\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/sync-time.mjs\n\n\n\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn\'t useful for animations when we\'re usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n    now: () => {\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\n                ? frameData.timestamp\n                : performance.now());\n        }\n        return now;\n    },\n    set: (newTime) => {\n        now = newTime;\n        queueMicrotask(clearTime);\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\n\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there\'s only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it\'s possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/index.mjs\n\n\n\n\n\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = "12.0.6";\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = null;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            const currentTime = time.now();\n            /**\n             * If we\'re updating the value during another frame or eventloop\n             * than the previous frame, then the we set the previous frame value\n             * to current.\n             */\n            if (this.updatedAt !== currentTime) {\n                this.setPrevFrameValue();\n            }\n            this.prev = this.current;\n            this.setCurrent(v);\n            // Update update subscribers\n            if (this.current !== this.prev && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        this.hasAnimated = false;\n        this.setCurrent(init);\n        this.owner = options.owner;\n    }\n    setCurrent(current) {\n        this.current = current;\n        this.updatedAt = time.now();\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current);\n        }\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n        this.prevFrameValue = prevFrameValue;\n        this.prevUpdatedAt = this.updatedAt;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don\'t add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on("change", updateOpacity)\n     *     const unsubscribeY = y.on("change", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (false) {}\n        return this.on("change", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === "change") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame_frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = undefined;\n        this.prevFrameValue = prev;\n        this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v, endAnimation = true) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\n        endAnimation && this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now();\n        if (!this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n            return 0;\n        }\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n        // Casts because of parseFloat\'s poor typing\n        return velocityPerSecond(parseFloat(this.current) -\n            parseFloat(this.prevFrameValue), delta);\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you\'ve manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/setters.mjs\n\n\n\n\n/**\n * Set VisualElement\'s MotionValue, creating a new MotionValue for it if\n * it doesn\'t exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\n\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs\n\n\nfunction addValueToWillChange(visualElement, key) {\n    const willChange = visualElement.getValue("willChange");\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can\'t add the value to it.\n     */\n    if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs\n\n\nconst optimizedAppearDataId = "framerAppearId";\nconst optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs\n\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nconst instantAnimationState = {\n    current: false,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs\n\n\n/*\n  Bezier function generator\n  This has been modified from Gatan Renaudeau\'s BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I\'ve removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn\'t noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we\'re\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop_noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/back.mjs\n\n\n\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/anticipate.mjs\n\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/circ.mjs\n\n\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\n/**\n * Check if the value is a zero value string like "0px" or "0%"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-none.mjs\n\n\nfunction isNone(value) {\n    if (typeof value === "number") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === "none" || value === "0" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/clamp.mjs\nconst clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/numbers/index.mjs\n\n\nconst number = {\n    test: (v) => typeof v === "number",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/sanitize.mjs\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/float-regex.mjs\nconst floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/is-nullish.mjs\nfunction isNullish(v) {\n    return v == null;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/single-color-regex.mjs\nconst singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/utils.mjs\n\n\n\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === "string" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== "string")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/rgba.mjs\n\n\n\n\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString("rgb", "red"),\n    parse: /*@__PURE__*/ splitColor("red", "green", "blue"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" +\n        rgbUnit.transform(red) +\n        ", " +\n        rgbUnit.transform(green) +\n        ", " +\n        rgbUnit.transform(blue) +\n        ", " +\n        sanitize(alpha.transform(alpha$1)) +\n        ")",\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/hex.mjs\n\n\n\nfunction parseHex(v) {\n    let r = "";\n    let g = "";\n    let b = "";\n    let a = "";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString("#"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/numbers/units.mjs\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType("deg");\nconst percent = /*@__PURE__*/ createUnitType("%");\nconst px = /*@__PURE__*/ createUnitType("px");\nconst vh = /*@__PURE__*/ createUnitType("vh");\nconst vw = /*@__PURE__*/ createUnitType("vw");\nconst progressPercentage = {\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/hsla.mjs\n\n\n\n\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString("hsl", "hue"),\n    parse: /*@__PURE__*/ splitColor("hue", "saturation", "lightness"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return ("hsla(" +\n            Math.round(hue) +\n            ", " +\n            percent.transform(sanitize(saturation)) +\n            ", " +\n            percent.transform(sanitize(lightness)) +\n            ", " +\n            sanitize(alpha.transform(alpha$1)) +\n            ")");\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/index.mjs\n\n\n\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === "string"\n            ? v\n            : v.hasOwnProperty("red")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/color-regex.mjs\nconst colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/complex/index.mjs\n\n\n\n\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        typeof v === "string" &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst NUMBER_TOKEN = "number";\nconst COLOR_TOKEN = "color";\nconst VAR_TOKEN = "var";\nconst VAR_FUNCTION_TOKEN = "var(";\nconst SPLIT_TOKEN = "${}";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = "";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/complex/filter.mjs\n\n\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split("(");\n    if (name === "drop-shadow")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, "");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + "(" + defaultValue + unit + ")";\n}\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(" ") : v;\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs\n\n\nconst browserNumberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs\n\n\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\n\n\nconst type_int_int = {\n    ...number,\n    transform: Math.round,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\n\n\n\n\n\n\nconst numberValueTypes = {\n    ...browserNumberValueTypes,\n    ...transformValueTypes,\n    zIndex: type_int_int,\n    size: px,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: type_int_int,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\n\n\n\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color: color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter: filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\n\n\n\n\nfunction animatable_none_getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs\n\n\n\n/**\n * If we encounter keyframes like "none" or "0" and we also have keyframes like\n * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for\n * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into\n * zero equivalents, i.e. "#fff0" or "0px 0px".\n */\nconst invalidTemplates = new Set(["auto", "none", "0"]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === "string" &&\n            !invalidTemplates.has(keyframe) &&\n            analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = animatable_none_getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\n\n\n\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === "none" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set(["x", "y", "z"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith("scale") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs\n\n\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we\'re measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it\'ll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren\'t going\n         * to trigger read/write thrashing don\'t need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame_frame.read(readAllKeyframes);\n                frame_frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */\n                if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    }\n                    else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                }\n                else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\n\n\n;// ./node_modules/motion-utils/dist/es/errors.mjs\n\n\nlet warning = noop_noop;\nlet invariant = noop_noop;\nif (false) {}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nconst checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith("--");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith("var(--");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split("/*")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\n\n\n\n\n/**\n * Parse Framer\'s special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, \'#fff\']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = \n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token1, token2, fallback] = match;\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback)\n        ? getVariableValue(fallback, element, depth + 1)\n        : fallback;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\n/**\n * ValueType for "auto"\n */\nconst auto = {\n    test: (v) => v === "auto",\n    parse: (v) => v,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\n\n\n\n\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs\n\n\n\n\n\n\n\n\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === "string") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it\'s a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn\'t a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don\'t recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === "string") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === "height") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\n\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, "100px", "#fff"\n * : "block", "url(2.jpg)"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (name === "zIndex")\n        return false;\n    // If it\'s a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === "number" || Array.isArray(value))\n        return true;\n    if (typeof value === "string" && // It\'s animatable if we have a string\n        (complex.test(value) || value === "0") && // And it contains numbers and/or colors\n        !value.startsWith("url(") // Unless it starts with "url("\n    ) {\n        return true;\n    }\n    return false;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs\n\n\n\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we\'re able to animate between the start and end keyframes,\n     * and throw a warning if we\'re attempting to animate between one that\'s\n     * animatable and another that isn\'t.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren\'t traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === "display" || name === "visibility")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === "spring" || isGenerator(type)) && velocity));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs\nconst isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== "loop" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs\n\n\n\n\n\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to "start" an animation as soon\n * as it\'s triggered, we also want to avoid a visual jump if there\'s a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won\'t restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there\'s a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can\'t animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate &&\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = "keyframes";\n        this.options.ease = "linear";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/number.mjs\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/immediate.mjs\nfunction mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/color.mjs\n\n\n\n\n\n\n\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `\'${color}\' is not an animatable color. Use the equivalent color code instead.`);\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion\'s stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/pipe.mjs\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/visibility.mjs\nconst invisibleValues = new Set(["none", "hidden"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the "none" or "hidden" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/complex.mjs\n\n\n\n\n\n\n\n\n\n\nfunction complex_mixNumber(a, b) {\n    return (p) => mixNumber(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === "number") {\n        return complex_mixNumber;\n    }\n    else if (typeof a === "string") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === "object") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values \'${origin}\' and \'${target}\' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/index.mjs\n\n\n\nfunction mix(from, to, p) {\n    if (typeof from === "number" &&\n        typeof to === "number" &&\n        typeof p === "number") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs\n\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs\nconst springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs\n\n\n\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= time_conversion_secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = time_conversion_secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs\n\n\n\n\n\n\n\nconst durationKeys = ["duration", "bounce"];\nconst physicsKeys = ["stiffness", "damping", "mass"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== "object"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it\'s mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we\'re working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can\'t overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? time_conversion_secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + "ms " + easing;\n        },\n    };\n    return generator;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/inertia.mjs\n\n\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don\'t want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/ease.mjs\n\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== "number";\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/utils/map.mjs\n\n\n\n\n\n\n\n\nconst easingLookup = {\n    linear: noop_noop,\n    easeIn: easeIn,\n    easeInOut: easeInOut,\n    easeOut: easeOut,\n    circIn: circIn,\n    circInOut: circInOut,\n    circOut: circOut,\n    backIn: backIn,\n    backInOut: backInOut,\n    backOut: backOut,\n    anticipate: anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === "string") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type \'${definition}\'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/interpolate.mjs\n\n\n\n\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop_noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], [\'#fff\', \'#000\'])\n *\n * mixColor(0.5) // \'rgba(128, 128, 128, 1)\'\n * ```\n *\n * TODO Revist this approach once we\'ve moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, "Both input and output ranges must be the same length");\n    /**\n     * If we\'re only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/offsets/fill.mjs\n\n\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/offsets/default.mjs\n\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/offsets/time.mjs\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs\n\n\n\n\n\n\n\nfunction keyframes_defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "easeInOut", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it\'s mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they\'re the correct length\n    // TODO Maybe we should warn here if there\'s a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : keyframes_defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs\n\n\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame_frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we\'re processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst generators = {\n    decay: inertia,\n    inertia: inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring: spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = "running";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = "idle";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === "idle")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we\'ve already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = isGenerator(type)\n            ? type\n            : generators[type] || keyframes;\n        /**\n         * If our generator doesn\'t support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== "number") {\n            if (false) {}\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === "mirror") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === "paused" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === "finished" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we\'ll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we\'re not running in "normal" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === "reverse") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === "mirror") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we\'re in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === "finished" || (this.state === "running" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = time_conversion_secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = "running";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === "finished") {\n            this.startTime = now;\n        }\n        if (this.state === "finished") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we\'ve used it in\n         * the previous logic.\n         */\n        this.state = "running";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = "paused";\n            return;\n        }\n        this.state = "paused";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== "running") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = "finished";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = "finished";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = "idle";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    "opacity",\n    "clipPath",\n    "filter",\n    "transform",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // "background-color"\n]);\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs\n\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = easing_mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : "linear",\n        fill: "both",\n        iterations: repeat + 1,\n        direction: repeatType === "reverse" ? "alternate" : "normal",\n    });\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs\n\n\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn\'t support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === "spring" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it\'s likely\n     * we\'re heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: "linear",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate: anticipate,\n    backInOut: backInOut,\n    circInOut: circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!motionValue.owner || !motionValue.owner.current) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn\'t supported\n         * by WAAPI (like "anticipate"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === "string" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can\'t animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = "keyframes";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it\'s more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn\'t, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = time_conversion_secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return "idle";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop_noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop_noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === "finished") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === "idle")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === "idle" ||\n            animation.playState === "finished") {\n            return;\n        }\n        /**\n         * WAAPI doesn\'t natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, "previous" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = time_conversion_secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        if (!motionValue ||\n            !motionValue.owner ||\n            !(motionValue.owner.current instanceof HTMLElement)) {\n            return false;\n        }\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            /**\n             * If we\'re outputting values to onUpdate then we can\'t use WAAPI as there\'s\n             * no way to read the value from WAAPI every frame.\n             */\n            !onUpdate &&\n            !transformTemplate &&\n            !repeatDelay &&\n            repeatType !== "mirror" &&\n            damping !== 0 &&\n            type !== "inertia");\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\n\n\nconst underDampedSpring = {\n    type: "spring",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: "spring",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: "keyframes",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: "keyframes",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith("scale")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs\n\n\n\n\n\n\n\n\n\n\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = get_value_transition_getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it\'d be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn\'t a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - time_conversion_secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: "easeOut",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there\'s no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = time_conversion_secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = time_conversion_secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame_frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs\n\n\n\n\n\n\n\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...get_value_transition_getValueTransition(transition || {}, key),\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we\'re handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame_frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame_frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs\n\n\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === "exit"\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a "when" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === "beforeChildren"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify("AnimationStart", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify("AnimationComplete", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs\n\n\n\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify("AnimationStart", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === "string") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === "function"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify("AnimationComplete", definition);\n    });\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs\n\n\n\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement)\n        return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent\n            ? getVariantContext(visualElement.parent) || {}\n            : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\n\n\n\n\n\n\n\n\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === "exit"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being "handled" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we\'ll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it\'s handling and whether or not they\'ve changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn\'t active and hasn\'t *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn\'t and don\'t have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn\'t define an animation\n                isAnimationControls(prop) ||\n                typeof prop === "boolean") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we\'re making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn\'t one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We\'ll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn\'t been removed in a higher priority but hasn\'t changed, and\n             *    needs adding to the type\'s protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we\'ve already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn\'t equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it\'s undefined, it\'s been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn\'t changed and it isn\'t undefined, we want to check if it\'s\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn\'t changed, we add it to the list of protected values\n                     * to ensure it doesn\'t get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven\'t changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven\'t been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn\'t changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === "string") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/Feature.mjs\nclass Feature {\n    constructor(node) {\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/animation/index.mjs\n\n\n\n\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node) {\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component\'s VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        var _a;\n        this.node.animationState.reset();\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs\n\n\nlet id = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.id = id++;\n    }\n    update() {\n        if (!this.node.presenceContext)\n            return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive("exit", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => onExitComplete(this.id));\n        }\n    }\n    mount() {\n        const { register } = this.node.presenceContext || {};\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/animations.mjs\n\n\n\nconst animations = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/events/add-dom-event.mjs\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/events/event-info.mjs\n\n\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    };\n}\nconst addPointerInfo = (handler) => {\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/events/add-pointer-event.mjs\n\n\n\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/distance.mjs\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we\'ll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame_frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === "pointercancel"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don\'t start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            time_conversion_secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n    return (ref &&\n        typeof ref === "object" &&\n        Object.prototype.hasOwnProperty.call(ref, "current"));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\n\n\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate =\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\n        isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if ((delta.translate >= TRANSLATE_MIN &&\n        delta.translate <= TRANSLATE_MAX) ||\n        isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\n\n\n\n\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, "left", "right"),\n        y: resolveAxisElastic(dragElastic, "top", "bottom"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === "number"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nconst createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n    return [callback("x"), callback("y")];\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it\'s easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY ||\n        values.skewX ||\n        values.skewY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== "0%";\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\n\n\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === "contents") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor\'s scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor\'s calculated delta into this component\'s recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it\'s within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/utils/measure.mjs\n\n\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/get-context-window.mjs\n// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = ({ current }) => {\n    return current ? current.ownerDocument.defaultView : null;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: PointerEvent\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false } = {}) {\n        /**\n         * Don\'t start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = setDragLock(drag);\n                // If we don \'t have the lock, don\'t start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame_frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, "transform");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive("whileDrag", true);\n        };\n        const onMove = (event, info) => {\n            // latestPointerEvent = event\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn\'t successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we\'ve successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis("x", info.point, offset);\n            this.updateAxis("y", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don\'t fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => this.stop(event, info);\n        const resumeAnimation = () => eachAxis((axis) => {\n            var _a;\n            return this.getAnimationState(axis) === "paused" &&\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\n        });\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            contextWindow: getContextWindow(this.visualElement),\n        });\n    }\n    stop(event, info) {\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        const { velocity } = info;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame_frame.postRender(() => onDragEnd(event, info));\n        }\n    }\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive("whileDrag", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we\'re not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        var _a;\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we\'re outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component\'s `ref` prop.");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there\'s an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There\'s still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: "inertia",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we\'re not animating on an externally-provided `MotionValue` we can use the\n            // component\'s animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\n    }\n    getAnimationState(axis) {\n        var _a;\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we\'re not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, "")\n            : "none";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame_frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element\'s layout changes, calculate the delta and apply that to\n         * the drag gesture\'s origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis\' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = "y";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = "x";\n    }\n    return direction;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/drag/index.mjs\n\n\n\n\nclass DragGesture extends Feature {\n    constructor(node) {\n        super(node);\n        this.removeGroupControls = noop_noop;\n        this.removeListeners = noop_noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we\'ve been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || noop_noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/pan/index.mjs\n\n\n\n\n\n\n\nconst asyncHandler = (handler) => (event, info) => {\n    if (handler) {\n        frame_frame.postRender(() => handler(event, info));\n    }\n};\nclass PanGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.removePointerDownListener = noop_noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n            contextWindow: getContextWindow(this.node),\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info) => {\n                delete this.session;\n                if (onPanEnd) {\n                    frame_frame.postRender(() => onPanEnd(event, info));\n                }\n            },\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(848);\n;// ./node_modules/framer-motion/dist/es/context/PresenceContext.mjs\n"use client";\n\n\n/**\n * @public\n */\nconst PresenceContext_PresenceContext = (0,react.createContext)(null);\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\n\n\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it\'s still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from "framer-motion"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won\'t really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = (0,react.useContext)(PresenceContext_PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It\'s safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = (0,react.useId)();\n    (0,react.useEffect)(() => {\n        if (subscribe)\n            register(id);\n    }, [subscribe]);\n    const safeToRemove = (0,react.useCallback)(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from "framer-motion"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log("I\'ve been removed!")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\n"use client";\n\n\nconst LayoutGroupContext = (0,react.createContext)({});\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\n"use client";\n\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = (0,react.createContext)({});\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/state.mjs\n/**\n * This should only ever be modified on the client otherwise it\'ll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nconst globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\n\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we\'ll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it\'s a percentage we can return immediately as it\'s\n         * going to be stretched appropriately. Otherwise, if it\'s a pixel, convert it to a number.\n         */\n        if (typeof latest === "string") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it\'s a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\n\n\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn\'t support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== "number" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we\'d correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === "number")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === "number")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\n\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key];\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true;\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/microtask.mjs\n\n\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\n"use client";\n\n\n\n\n\n\n\n\n\n\n\n\nclass MeasureLayoutWithContext extends react.Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener("animationComplete", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There\'s no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there\'s another stack member taking over from this one,\n                 * it\'s in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame_frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = (0,react.useContext)(LayoutGroupContext);\n    return ((0,jsx_runtime.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: (0,react.useContext)(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            "borderTopLeftRadius",\n            "borderTopRightRadius",\n            "borderBottomLeftRadius",\n            "borderBottomRightRadius",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animate/single-value.mjs\n\n\n\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== "svg";\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nconst compareByDepth = (a, b) => a.depth - b.depth;\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\n\n\n\nclass FlatTree {\n    constructor() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/delay.mjs\n\n\n\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame_frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\nfunction delayInSeconds(callback, timeout) {\n    return delay(callback, secondsToMilliseconds(timeout));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\n\n\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    const unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\n\n\n\n\n\nconst borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === "number" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, \n        // TODO Reinstate this if only child\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += "%";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there\'s a follow element\n//  * that we\'re not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn\'t ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop_noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\n\n\n\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== "number")\n        return;\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = ["x", "scaleX", "originX"];\nconst yKeys = ["y", "scaleY", "originY"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\n\n\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return (Math.round(a.min) === Math.round(b.min) &&\n        Math.round(a.max) === Math.round(b.max));\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return (a.translate === b.translate &&\n        a.scale === b.scale &&\n        a.originPoint === b.originPoint);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/shared/stack.mjs\n\n\nclass NodeStack {\n    constructor() {\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member) => node === member);\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        let prevLead;\n        for (let i = indexOfNode; i >= 0; i--) {\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node) => {\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete &&\n                    resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node) => {\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = "";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || "none";\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst metrics = {\n    type: "projectionFrame",\n    totalNodes: 0,\n    resolvedTargetDeltas: 0,\n    recalculatedProjection: 0,\n};\nconst isDebug = typeof window !== "undefined" && window.MotionDebug !== undefined;\nconst transformAxes = ["", "X", "Y", "Z"];\nconst hiddenVisibility = { visibility: "hidden" };\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nconst animationTarget = 1000;\nlet create_projection_node_id = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode)\n        return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement)\n        return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, "transform", frame_frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n            /**\n             * A unique ID generated for every projection node.\n             */\n            this.id = create_projection_node_id++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */\n            this.animationId = 0;\n            /**\n             * A Set containing all this component\'s children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can\'t always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */\n            this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */\n            this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */\n            this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */\n            this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = () => this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = () => {\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */\n            this.updateProjection = () => {\n                this.projectionUpdateScheduled = false;\n                /**\n                 * Reset debug counts. Manually resetting rather than creating a new\n                 * object each frame.\n                 */\n                if (isDebug) {\n                    metrics.totalNodes =\n                        metrics.resolvedTargetDeltas =\n                            metrics.recalculatedProjection =\n                                0;\n                }\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n                if (isDebug) {\n                    window.MotionDebug.record(metrics);\n                }\n            };\n            /**\n             * Frame calculations\n             */\n            this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [...parent.path, parent] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for (let i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n            if (this.instance)\n                return;\n            this.isSVG = isSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\n                attachResizeListener(instance, () => {\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) => {\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition ||\n                        visualElement.getDefaultTransition() ||\n                        defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    const hasTargetChanged = !this.targetLayout ||\n                        !boxEqualsRounded(this.targetLayout, newLayout);\n                    /*\n                     * Note: Disabled to fix relative animations always triggering new\n                     * layout animations. If this causes further issues, we can try\n                     * a different approach to detecting relative target changes.\n                     */\n                    // || hasRelativeLayoutChanged\n                    /**\n                     * If the layout hasn\'t seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\n                    if (this.options.layoutRoot ||\n                        this.resumeFrom ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (hasTargetChanged || !this.currentAnimation))) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        const animationOptions = {\n                            ...get_value_transition_getValueTransition(layoutTransition, "layout"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete,\n                        };\n                        if (visualElement.shouldReduceMotion ||\n                            this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn\'t changed and we have an animation that hasn\'t started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return (this.isAnimationBlocked ||\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\n                false);\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we\'re running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don\'t yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */\n            if (window.MotionCancelOptimisedAnimation &&\n                !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll("snapshot");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout)\n                return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, "")\n                : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners("willUpdate");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            this.isUpdating = false;\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */\n            const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame_frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            frame_frame.postRender(() => {\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                }\n                else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */\n        updateSnapshot() {\n            if (this.snapshot || !this.instance)\n                return;\n            this.snapshot = this.measure();\n            if (this.snapshot &&\n                !calcLength(this.snapshot.measuredBox.x) &&\n                !calcLength(this.snapshot.measuredBox.y)) {\n                this.snapshot = undefined;\n            }\n        }\n        updateLayout() {\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead\'s\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (let i = 0; i < this.path.length; i++) {\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners("measure", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement &&\n                visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = "measure") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll &&\n                this.scroll.animationId === this.root.animationId &&\n                this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform)\n                return;\n            const isResetRequested = this.isLayoutDirty ||\n                this.shouldResetTransform ||\n                this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, "")\n                : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */\n            if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id,\n            };\n        }\n        measurePageBox() {\n            var _a;\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            var _a;\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent)\n                return;\n            /**\n             * If the parent target isn\'t up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */\n            if (this.relativeParent.resolvedRelativeTargetAt !==\n                frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            var _a;\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */\n            const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don\'t use transform for this step of processing so we don\'t\n             * need to check whether any nodes have changed transform.\n             */\n            const canSkip = !(forceRecalculation ||\n                (isShared && this.isSharedProjectionDirty) ||\n                this.isProjectionDirty ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\n                this.attemptToResolveRelativeTarget ||\n                this.root.updateBlockedByResize);\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can\'t perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don\'t have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    relativeParent.layout &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn\'t valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we\'ve got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                this.relativeParent &&\n                this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we\'ve only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we\'ve been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    Boolean(relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !relativeParent.options.layoutScroll &&\n                    relativeParent.target &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * Increase debug counter for resolved target deltas\n             */\n            if (isDebug) {\n                metrics.resolvedTargetDeltas++;\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent ||\n                hasScale(this.parent.latestValues) ||\n                has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget ||\n                this.targetDelta ||\n                this.options.layoutRoot) &&\n                this.layout);\n        }\n        calcProjection() {\n            var _a;\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can\'t skip.\n             */\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node\'s shared projection is dirty then\n             * we can\'t skip.\n             */\n            if (isShared &&\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn\'t animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * Reset the corrected box with the latest values from box, as we\'re then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */\n            const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn\'t have a target,\n             * use the layout as the target.\n             */\n            if (lead.layout &&\n                !lead.target &&\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don\'t have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */\n                if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            }\n            else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn\'t have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY ||\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners("projectionUpdate", target);\n            }\n            /**\n             * Increase debug counter for recalculated projections\n             */\n            if (isDebug) {\n                metrics.recalculatedProjection++;\n            }\n        }\n        hide() {\n            this.isVisible = false;\n            // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n            // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            var _a;\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot\n                ? snapshot.latestValues\n                : {};\n            const mixedValues = { ...this.latestValues };\n            const targetDelta = createDelta();\n            if (!this.relativeParent ||\n                !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest) => {\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget &&\n                    this.relativeTargetOrigin &&\n                    this.layout &&\n                    this.relativeParent &&\n                    this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */\n                    if (prevRelativeTarget &&\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget)\n                        prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners("animationStart");\n            this.currentAnimation && this.currentAnimation.stop();\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\n                this.resumingFrom.currentAnimation.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = frame_frame.update(() => {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\n                    ...options,\n                    onUpdate: (latest) => {\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onComplete: () => {\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    },\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners("animationComplete");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            /**\n             * If we\'re only animating position, and this element isn\'t the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */\n            if (this !== lead &&\n                this.layout &&\n                layout &&\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\n                    ? config.shouldPreserveFollowOpacity(node)\n                    : undefined,\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        }\n        getPrevLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\n            const stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return;\n            // If there\'s no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don\'t have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */\n            const { latestValues } = visualElement;\n            if (latestValues.z ||\n                latestValues.rotate ||\n                latestValues.rotateX ||\n                latestValues.rotateY ||\n                latestValues.rotateZ ||\n                latestValues.skewX ||\n                latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there\'s no distorting values, we don\'t need to do any more.\n            if (!hasDistortingTransform)\n                return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform("z", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for (let i = 0; i < transformAxes.length; i++) {\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for (const key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won\'t visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        getProjectionStyles(styleProp) {\n            var _a, _b;\n            if (!this.instance || this.isSVG)\n                return undefined;\n            if (!this.isVisible) {\n                return hiddenVisibility;\n            }\n            const styles = {\n                visibility: "",\n            };\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = "";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, "")\n                    : "none";\n                return styles;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                const emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity =\n                        this.latestValues.opacity !== undefined\n                            ? this.latestValues.opacity\n                            : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, "")\n                        : "none";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            const { x, y } = this.projectionDelta;\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we\'re not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? valuesToRender.opacity !== undefined\n                            ? valuesToRender.opacity\n                            : ""\n                        : valuesToRender.opacityExit !== undefined\n                            ? valuesToRender.opacityExit\n                            : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (const key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */\n                const corrected = styles.transform === "none"\n                    ? valuesToRender[key]\n                    : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for (let i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    // If this is a CSS variable, set it directly on the instance.\n                    // Replacing this function from creating styles to setting them\n                    // would be a good place to remove per frame object creation\n                    if (isCSSVariable) {\n                        this.options.visualElement.renderState.vars[key] = corrected;\n                    }\n                    else {\n                        styles[key] = corrected;\n                    }\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn\'t block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || ""\n                        : "none";\n            }\n            return styles;\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a;\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners("didUpdate")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don\'t trigger\n        // animations for instance if layout="size" and an element has only changed position\n        if (animationType === "size") {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */\n                if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max =\n                        node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeLayoutChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeLayoutChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners("didUpdate", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeLayoutChanged,\n        });\n    }\n    else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    /**\n     * Increase debug counter for nodes encountered this frame\n     */\n    if (isDebug) {\n        metrics.totalNodes++;\n    }\n    if (!node.parent)\n        return;\n    /**\n     * If this node isn\'t projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn\'t* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */\n    if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\n        node.parent.isProjectionDirty ||\n        node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty =\n        node.isSharedProjectionDirty =\n            node.isTransformDirty =\n                false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify("BeforeLayoutMeasure");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber(delta.translate, 0, p);\n    output.scale = mixNumber(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber(from.min, to.min, p);\n    output.max = mixNumber(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nconst userAgentContains = (string) => typeof navigator !== "undefined" &&\n    navigator.userAgent &&\n    navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */\nconst roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/")\n    ? Math.round\n    : noop_noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return (animationType === "position" ||\n        (animationType === "preserve-aspect" &&\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\n}\nfunction checkNodeWasScrollRoot(node) {\n    var _a;\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\n\n\n\nconst DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),\n    measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }),\n    checkIsScrollRoot: () => true,\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\n\n\n\nconst rootProjectionNode = {\n    current: undefined,\n};\nconst HTMLProjectionNode = createProjectionNode({\n    measureScroll: (instance) => ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }),\n    defaultParent: () => {\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value) => {\n        instance.style.transform = value !== undefined ? value : "none";\n    },\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed"),\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/drag.mjs\n\n\n\n\n\nconst drag = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout: MeasureLayout,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/hover.mjs\n\n\n\n\n\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive("whileHover", lifecycle === "Start");\n    }\n    const eventName = ("onHover" + lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame_frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = hover(current, (_element, startEvent) => {\n            handleHoverEvent(this.node, startEvent, "Start");\n            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");\n        });\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/focus.mjs\n\n\n\n\nclass FocusGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn\'t match focus-visible then don\'t\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current.matches(":focus-visible");\n        }\n        catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState)\n            return;\n        this.node.animationState.setActive("whileFocus", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState)\n            return;\n        this.node.animationState.setActive("whileFocus", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/press.mjs\n\n\n\n\n\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive("whileTap", lifecycle === "Start");\n    }\n    const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));\n    const callback = props[eventName];\n    if (callback) {\n        frame_frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = press(current, (_element, startEvent) => {\n            handlePressEvent(this.node, startEvent, "Start");\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don\'t have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don\'t have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs\n\n\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = "some", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === "number" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there\'s been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn\'t visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive("whileInView", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === "undefined")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/gestures.mjs\n\n\n\n\n\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/layout.mjs\n\n\n\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout: MeasureLayout,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/LazyContext.mjs\n"use client";\n\n\nconst LazyContext = (0,react.createContext)({ strict: false });\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\n"use client";\n\n\n/**\n * @public\n */\nconst MotionConfigContext = (0,react.createContext)({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: "never",\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\n"use client";\n\n\nconst MotionContext = (0,react.createContext)({});\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\n\n\n\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\n\n\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\n\n\n\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, (0,react.useContext)(MotionContext));\n    return (0,react.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(" ") : prop;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-browser.mjs\nconst isBrowser = typeof window !== "undefined";\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nconst featureProps = {\n    animation: [\n        "animate",\n        "variants",\n        "whileHover",\n        "whileTap",\n        "exit",\n        "whileInView",\n        "whileFocus",\n        "whileDrag",\n    ],\n    exit: ["exit"],\n    drag: ["drag", "dragControls"],\n    focus: ["whileFocus"],\n    hover: ["whileHover", "onHoverStart", "onHoverEnd"],\n    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],\n    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],\n    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],\n    layout: ["layout", "layoutId"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/load-features.mjs\n\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nconst motionComponentSymbol = Symbol.for("motionComponentSymbol");\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\n\n\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return (0,react.useCallback)((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === "function") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we\'ve received a visual element\n     * factory. Otherwise we\'ll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\n\n\n\nconst useIsomorphicLayoutEffect = isBrowser ? react.useLayoutEffect : react.useEffect;\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\n\n\n\n\n\n\n\n\n\n\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = (0,react.useContext)(MotionContext);\n    const lazyContext = (0,react.useContext)(LazyContext);\n    const presenceContext = (0,react.useContext)(PresenceContext_PresenceContext);\n    const reducedMotionConfig = (0,react.useContext)(MotionConfigContext).reducedMotion;\n    const visualElementRef = (0,react.useRef)(null);\n    /**\n     * If we haven\'t preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = (0,react.useContext)(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === "html" || visualElement.type === "svg")) {\n        use_visual_element_createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = (0,react.useRef)(false);\n    (0,react.useInsertionEffect)(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = (0,react.useRef)(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there\'s no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    (0,react.useEffect)(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction use_visual_element_createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it\'ll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there\'s no potential layout animations.\n         *\n         */\n        animationType: typeof layout === "string" ? layout : "both",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/index.mjs\n"use client";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie "div"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component "offline", or outside the React render cycle.\n */\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\n    var _a, _b;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...(0,react.useContext)(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return ((0,jsx_runtime.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? ((0,jsx_runtime.jsx)(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\n    }\n    MotionComponent.displayName = `motion.${typeof Component === "string"\n        ? Component\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : ""})`}`;\n    const ForwardRefMotionComponent = (0,react.forwardRef)(MotionComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = (0,react.useContext)(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + "-" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = (0,react.useContext)(LazyContext).strict;\n    /**\n     * If we\'re in development mode, check to make sure we\'re not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (false) {}\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\n/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    "animate",\n    "circle",\n    "defs",\n    "desc",\n    "ellipse",\n    "g",\n    "image",\n    "line",\n    "filter",\n    "marker",\n    "mask",\n    "metadata",\n    "path",\n    "pattern",\n    "polygon",\n    "polyline",\n    "rect",\n    "stop",\n    "switch",\n    "symbol",\n    "svg",\n    "text",\n    "tspan",\n    "use",\n    "view",\n];\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\n\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it\'s not a string, it\'s a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== "string" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes("-")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it\'s in our list of lowercase SVG tags, it\'s an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it\'s an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/use-constant.mjs\n\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn\'t offer\n * a guarantee that it won\'t re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don\'t execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = (0,react.useRef)(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\n\n\n\n\n\n\n\n\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onUpdate) {\n        /**\n         * onMount works without the VisualElement because it could be\n         * called before the VisualElement payload has been hydrated.\n         * (e.g. if someone is using m components <m.circle />)\n         */\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\n    }\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = (0,react.useContext)(MotionContext);\n    const presenceContext = (0,react.useContext)(PresenceContext_PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== "boolean" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === "number"\n        ? type.transform(value)\n        : value;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\n\n\n\n\nconst translateAlias = {\n    x: "translateX",\n    y: "translateY",\n    z: "translateZ",\n    transformPerspective: "perspective",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we\'re going to build into.\n    let transformString = "";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === "number") {\n            valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = "none";\n    }\n    return transformString;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\n\n\n\n\n\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> "0px"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith("origin")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don\'t have any,\n             * reset transform style to none.\n             */\n            style.transform = "none";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = "50%", originY = "50%", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\n\n\nconst dashKeys = {\n    offset: "stroke-dashoffset",\n    array: "stroke-dasharray",\n};\nconst camelKeys = {\n    offset: "strokeDashoffset",\n    array: "strokeDasharray",\n};\n/**\n * Build SVG path properties. Uses the path\'s measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\n\n\nfunction transform_origin_calcOrigin(origin, offset, size) {\n    return typeof origin === "string"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = transform_origin_calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = transform_origin_calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\n\n\n\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nconst createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\n\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs\nconst isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    "baseFrequency",\n    "diffuseConstant",\n    "kernelMatrix",\n    "kernelUnitLength",\n    "keySplines",\n    "keyTimes",\n    "limitingConeAngle",\n    "markerHeight",\n    "markerWidth",\n    "numOctaves",\n    "targetX",\n    "targetY",\n    "surfaceScale",\n    "specularConstant",\n    "specularExponent",\n    "stdDeviation",\n    "tableValues",\n    "viewBox",\n    "gradientTransform",\n    "pathLength",\n    "startOffset",\n    "textLength",\n    "lengthAdjust",\n]);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\n\n\n\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\n\n\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith("origin") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === "opacity")));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\n\n\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    var _a;\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\n\n\n\n\nfunction scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? "attr" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\n\n\n\n\n\n\n\n\n\nfunction updateSVGDimensions(instance, renderState) {\n    try {\n        renderState.dimensions =\n            typeof instance.getBBox === "function"\n                ? instance.getBBox()\n                : instance.getBoundingClientRect();\n    }\n    catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n    }\n}\nconst layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\n            if (!current)\n                return;\n            let hasTransform = !!props.drag;\n            if (!hasTransform) {\n                for (const key in latestValues) {\n                    if (transformProps.has(key)) {\n                        hasTransform = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasTransform)\n                return;\n            let needsMeasure = !prevProps;\n            if (prevProps) {\n                /**\n                 * Check the layout props for changes, if any are found we need to\n                 * measure the element again.\n                 */\n                for (let i = 0; i < layoutProps.length; i++) {\n                    const key = layoutProps[i];\n                    if (props[key] !==\n                        prevProps[key]) {\n                        needsMeasure = true;\n                    }\n                }\n            }\n            if (!needsMeasure)\n                return;\n            frame_frame.read(() => {\n                updateSVGDimensions(current, renderState);\n                frame_frame.render(() => {\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\n                    renderSVG(current, renderState);\n                });\n            });\n        },\n    }),\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/config-motion.mjs\n\n\n\n\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/use-props.mjs\n\n\n\n\n\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return (0,react.useMemo)(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn\'t ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    "none";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? "none"\n                : `pan-${props.drag === "x" ? "y" : "x"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn\'t throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    "animate",\n    "exit",\n    "variants",\n    "initial",\n    "style",\n    "values",\n    "variants",\n    "transition",\n    "transformTemplate",\n    "custom",\n    "inherit",\n    "onBeforeLayoutMeasure",\n    "onAnimationStart",\n    "onAnimationComplete",\n    "onUpdate",\n    "onDragStart",\n    "onDrag",\n    "onDragEnd",\n    "onMeasureDragConstraints",\n    "onDirectionLock",\n    "onDragTransitionEnd",\n    "_dragX",\n    "_dragY",\n    "onHoverStart",\n    "onHoverEnd",\n    "onViewportEnter",\n    "onViewportLeave",\n    "globalTapTarget",\n    "ignoreStrict",\n    "viewport",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith("while") ||\n        (key.startsWith("drag") && key !== "draggable") ||\n        key.startsWith("layout") ||\n        key.startsWith("onTap") ||\n        key.startsWith("onPan") ||\n        key.startsWith("onLayout") ||\n        validMotionProps.has(key));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\n\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp)\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it\'s seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn\'t *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it\'s\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won\'t be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);\n}\ncatch (_a) {\n    // We don\'t need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it\'s present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === "values" && typeof props.values === "object")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props["draggable"] &&\n                key.startsWith("onDrag"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/use-props.mjs\n\n\n\n\n\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = (0,react.useMemo)(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/use-render.mjs\n\n\n\n\n\n\n\nfunction createUseRender(forwardMotionProps = false) {\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\n        const useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);\n        const elementProps = Component !== react.Fragment\n            ? { ...filteredProps, ...visualProps, ref }\n            : {};\n        /**\n         * If component has been handed a motion value as its child,\n         * memoise its initial value and render that. Subsequent updates\n         * will be handled by the onChange handler\n         */\n        const { children } = props;\n        const renderedChildren = (0,react.useMemo)(() => (isMotionValue(children) ? children.get() : children), [children]);\n        return (0,react.createElement)(Component, {\n            ...elementProps,\n            children: renderedChildren,\n        });\n    };\n    return useRender;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/components/create-factory.mjs\n\n\n\n\n\n\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\n        const baseConfig = isSVGComponent(Component)\n            ? svgMotionConfig\n            : htmlMotionConfig;\n        const config = {\n            ...baseConfig,\n            preloadedFeatures,\n            useRender: createUseRender(forwardMotionProps),\n            createVisualElement,\n            Component,\n        };\n        return createRendererMotionComponent(config);\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\n\n\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\n\n\n\n\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/store.mjs\nconst visualElementStore = new WeakMap();\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\n\n\n\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element\'s motion value map.\n             */\n            element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (false) {}\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we\'re swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn\'t exist. We only want to do this if we\'re\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/VisualElement.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst propEventHandlers = [\n    "AnimationStart",\n    "AnimationComplete",\n    "Update",\n    "BeforeLayoutMeasure",\n    "LayoutMeasure",\n    "LayoutAnimationStart",\n    "LayoutAnimationComplete",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn\'t an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement\'s children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every "Update" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify("Update", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame_frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState, onUpdate } = visualState;\n        this.onUpdate = onUpdate;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren\'t yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn\'t necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === "never"\n                ? false\n                : this.reducedMotionConfig === "always"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (false) {}\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on("change", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame_frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren\'t even of the same type we can\'t compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = "animation";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = ("on" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n        this.onUpdate && this.onUpdate(this);\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we\'re trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        var _a;\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === "string" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie "0" or "200", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = animatable_none_getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === "string" || typeof initial === "object") {\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn\'t any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\n\n\n\n\nclass DOMVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we\'re returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style\n            ? props.style[key]\n            : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on("change", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\n\n\n\n\n\n\n\n\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = "html";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === "string" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\n\n\n\n\n\n\n\n\n\n\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = "svg";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\n\n\n\n\n\nconst createDomVisualElement = (Component, options) => {\n    return isSVGComponent(Component)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n            allowProjection: Component !== react.Fragment,\n        });\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/components/motion/create.mjs\n\n\n\n\n\n\n\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n}, createDomVisualElement);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\n\n\n\nconst motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs\n"use client";\n\n\n\n\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends react.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = parent instanceof HTMLElement ? parent.offsetWidth || 0 : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX }) {\n    const id = (0,react.useId)();\n    const ref = (0,react.useRef)(null);\n    const size = (0,react.useRef)({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = (0,react.useContext)(MotionConfigContext);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can\'t apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    (0,react.useInsertionEffect)(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement("style");\n        if (nonce)\n            style.nonce = nonce;\n        document.head.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id="${id}"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            document.head.removeChild(style);\n        };\n    }, [isPresent]);\n    return ((0,jsx_runtime.jsx)(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: react.cloneElement(children, { ref }) }));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs\n"use client";\n\n\n\n\n\n\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = (0,react.useId)();\n    const memoizedOnExitComplete = (0,react.useCallback)((childId) => {\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()) {\n            if (!isComplete)\n                return; // can stop searching when any is incomplete\n        }\n        onExitComplete && onExitComplete();\n    }, [presenceChildren, onExitComplete]);\n    const context = (0,react.useMemo)(() => ({\n        id,\n        initial,\n        isPresent,\n        custom,\n        onExitComplete: memoizedOnExitComplete,\n        register: (childId) => {\n            presenceChildren.set(childId, false);\n            return () => presenceChildren.delete(childId);\n        },\n    }), \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout\n        ? [Math.random(), memoizedOnExitComplete]\n        : [isPresent, memoizedOnExitComplete]);\n    (0,react.useMemo)(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there\'s no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    react.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === "popLayout") {\n        children = ((0,jsx_runtime.jsx)(PopChild, { isPresent: isPresent, anchorX: anchorX, children: children }));\n    }\n    return ((0,jsx_runtime.jsx)(PresenceContext_PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs\n\n\nconst getChildKey = (child) => child.key || "";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    react.Children.forEach(children, (child) => {\n        if ((0,react.isValidElement)(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\n"use client";\n\n\n\n\n\n\n\n\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from \'framer-motion\'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren\'t ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = (0,react.useMemo)(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = (0,react.useRef)(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = (0,react.useRef)(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = (0,react.useState)(presentChildren);\n    const [renderedChildren, setRenderedChildren] = (0,react.useState)(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we\'re in "wait" mode, and we have exiting children, we want to\n         * only render these until they\'ve all exited.\n         */\n        if (mode === "wait" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we\'ve set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return;\n    }\n    if (false) {}\n    /**\n     * If we\'ve been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = (0,react.useContext)(LayoutGroupContext);\n    return ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return ((0,jsx_runtime.jsx)(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\n\n\n;// ./src/context/FileUploadContext.tsx\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nvar FileUploadContext = /*#__PURE__*/(0,react.createContext)(undefined);\nfunction useFileUpload() {\n  var context = (0,react.useContext)(FileUploadContext);\n  if (context === undefined) {\n    throw new Error("useFileUpload must be used within a FileUploadProvider");\n  }\n  return context;\n}\nfunction FileUploadProvider(_ref) {\n  var children = _ref.children,\n    _ref$maxSize = _ref.maxSize,\n    maxSize = _ref$maxSize === void 0 ? 45 * 1024 : _ref$maxSize;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    file = _useState2[0],\n    setFile = _useState2[1];\n  var _useState3 = (0,react.useState)(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    error = _useState4[0],\n    setError = _useState4[1];\n  var validateFile = (0,react.useCallback)(function (file) {\n    var validTypes = ["image/jpeg", "image/png", "image/pdg", "video/mp4"];\n    if (!validTypes.includes(file.type)) {\n      setError("File type not supported");\n      return false;\n    }\n    if (file.size > maxSize) {\n      setError("File size exceeds 45KB limit");\n      return false;\n    }\n    return true;\n  }, [maxSize]);\n  var addFile = (0,react.useCallback)(function (newFiles) {\n    setError(null);\n    // Se toma solo el primer archivo\n    var fileToAdd = Array.from(newFiles)[0];\n    if (!validateFile(fileToAdd)) return;\n    var fileWithPreview = fileToAdd;\n    if (fileToAdd.type.startsWith("image/")) {\n      fileWithPreview = Object.assign(fileToAdd, {\n        preview: URL.createObjectURL(fileToAdd)\n      });\n    }\n    // Si ya existe un archivo, se revoca su URL de preview\n    if (file && file.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n    setFile(fileWithPreview);\n  }, [validateFile, file]);\n  var removeFile = (0,react.useCallback)(function () {\n    if (file && file.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n    setFile(null);\n  }, [file]);\n  var clearFile = (0,react.useCallback)(function () {\n    if (file && file.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n    setFile(null);\n  }, [file]);\n  return /*#__PURE__*/react.createElement(FileUploadContext.Provider, {\n    value: {\n      file: file,\n      error: error,\n      addFile: addFile,\n      removeFile: removeFile,\n      clearFile: clearFile\n    }\n  }, children);\n}\n;// ./src/icons/UploadIcon.tsx\n\nvar UploadIcon = function UploadIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    width: "46",\n    height: "47",\n    viewBox: "0 0 46 47",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M14.2991 37.5685H10.619C4.984 37.166 2.4541 32.8343 2.4541 28.9818C2.4541 25.1293 4.98403 20.7785 10.5232 20.3951C11.309 20.3185 11.999 20.9318 12.0565 21.7368C12.114 22.5226 11.5199 23.2126 10.7149 23.2701C6.9966 23.5385 5.3291 26.3368 5.3291 29.001C5.3291 31.6651 6.9966 34.4635 10.7149 34.7318H14.2991C15.0849 34.7318 15.7366 35.3835 15.7366 36.1693C15.7366 36.9551 15.0849 37.5685 14.2991 37.5685Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M31.9507 37.5682C31.9124 37.5682 31.8932 37.5682 31.8549 37.5682C31.0691 37.5682 30.3408 36.9166 30.3408 36.1307C30.3408 35.3066 30.9541 34.6932 31.7591 34.6932C34.1166 34.6932 36.2249 33.8691 37.8733 32.3933C40.8633 29.7866 41.0549 26.0299 40.2499 23.3849C39.4449 20.7591 37.2024 17.7499 33.2924 17.2708C32.6599 17.1941 32.1615 16.7149 32.0465 16.0824C31.2799 11.4824 28.8074 8.30076 25.0508 7.15076C21.1791 5.94326 16.6557 7.13159 13.8382 10.0833C11.0974 12.9391 10.4649 16.9449 12.0557 21.3533C12.324 22.1008 11.9408 22.9249 11.1933 23.1932C10.4458 23.4616 9.62159 23.0783 9.35326 22.3308C7.41743 16.9258 8.29911 11.7508 11.7683 8.10909C15.3141 4.39076 21.0066 2.91491 25.8941 4.40991C30.3791 5.78991 33.5415 9.48908 34.6915 14.6257C38.6015 15.5074 41.7449 18.4783 42.9907 22.5799C44.3516 27.0458 43.1249 31.6458 39.7707 34.5591C37.6432 36.4758 34.864 37.5682 31.9507 37.5682Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M22.9998 43.2033C19.1473 43.2033 15.544 41.1524 13.5699 37.8366C13.359 37.5108 13.1482 37.1275 12.9757 36.7058C12.324 35.345 11.979 33.7925 11.979 32.1825C11.979 26.1066 16.924 21.1616 22.9998 21.1616C29.0757 21.1616 34.0207 26.1066 34.0207 32.1825C34.0207 33.8116 33.6757 35.345 32.9857 36.7633C32.8324 37.1275 32.6216 37.5108 32.3916 37.875C30.4557 41.1525 26.8523 43.2033 22.9998 43.2033ZM22.9998 24.0366C18.5148 24.0366 14.854 27.6975 14.854 32.1825C14.854 33.3708 15.1032 34.4824 15.5823 35.4983C15.7357 35.8241 15.8698 36.0925 16.0231 36.3416C17.4798 38.8141 20.144 40.3283 22.9807 40.3283C25.8173 40.3283 28.4815 38.8141 29.919 36.38C30.0915 36.0925 30.2449 35.8241 30.3599 35.5558C30.8774 34.5016 31.1265 33.3899 31.1265 32.2016C31.1457 27.6974 27.4848 24.0366 22.9998 24.0366Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M21.9074 35.5175C21.5432 35.5175 21.1791 35.3834 20.8916 35.0959L18.994 33.1984C18.4382 32.6425 18.4382 31.7225 18.994 31.1667C19.5499 30.6109 20.4699 30.6109 21.0257 31.1667L21.9458 32.0867L25.0124 29.25C25.6066 28.7134 26.5074 28.7517 27.044 29.3267C27.5807 29.9017 27.5424 30.8217 26.9674 31.3584L22.8849 35.1342C22.5974 35.3834 22.2524 35.5175 21.9074 35.5175Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/context/TxStatusContext.tsx\n// TxStatusContext.tsx\n"use client";\n\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }\nfunction _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction TxStatusContext_slicedToArray(r, e) { return TxStatusContext_arrayWithHoles(r) || TxStatusContext_iterableToArrayLimit(r, e) || TxStatusContext_unsupportedIterableToArray(r, e) || TxStatusContext_nonIterableRest(); }\nfunction TxStatusContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction TxStatusContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TxStatusContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TxStatusContext_arrayLikeToArray(r, a) : void 0; } }\nfunction TxStatusContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TxStatusContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction TxStatusContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nvar TxStatusContext = /*#__PURE__*/(0,react.createContext)(undefined);\nvar TxStatusProvider = function TxStatusProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)({\n      isProcessing: false,\n      currentStep: "prepare/construct",\n      nextStep: "prepare/retrieve"\n    }),\n    _useState2 = TxStatusContext_slicedToArray(_useState, 2),\n    preparation = _useState2[0],\n    setPreparation = _useState2[1];\n  var _useState3 = (0,react.useState)({\n      isProcessing: false,\n      currentStep: "inscription/construct",\n      nextStep: "inscription/retrieve"\n    }),\n    _useState4 = TxStatusContext_slicedToArray(_useState3, 2),\n    inscription = _useState4[0],\n    setInscription = _useState4[1];\n  var setPreparationStatus = (0,react.useCallback)(function (status) {\n    setPreparation(function (prev) {\n      return _objectSpread(_objectSpread({}, prev), status);\n    });\n  }, []);\n  var setInscriptionStatus = (0,react.useCallback)(function (status) {\n    setInscription(function (prev) {\n      return _objectSpread(_objectSpread({}, prev), status);\n    });\n  }, []);\n  var moveToNextStep = function moveToNextStep(flow) {\n    if (flow === "preparation" && preparation.nextStep) {\n      var nextStepMap = {\n        "prepare/construct": "prepare/retrieve",\n        "prepare/retrieve": "prepare/submit",\n        "prepare/submit": "prepare/retrieve-submission",\n        "prepare/retrieve-submission": null\n      };\n      var currentStep = preparation.nextStep;\n      var nextStep = nextStepMap[currentStep];\n      setPreparationStatus({\n        currentStep: currentStep,\n        nextStep: nextStep\n      });\n    } else if (flow === "inscription" && inscription.nextStep) {\n      var _nextStepMap = {\n        "inscription/construct": "inscription/retrieve",\n        "inscription/retrieve": "inscription/submit",\n        "inscription/submit": "inscription/retrieve-submission",\n        "inscription/retrieve-submission": null\n      };\n      var _currentStep = inscription.nextStep;\n      var _nextStep = _nextStepMap[_currentStep];\n      setInscriptionStatus({\n        currentStep: _currentStep,\n        nextStep: _nextStep\n      });\n    } else if (flow === "end") {\n      // Al llegar al final, reiniciamos los estados\n      setPreparation({\n        isProcessing: false,\n        currentStep: "prepare/construct",\n        nextStep: "prepare/retrieve"\n      });\n      setInscription({\n        isProcessing: false,\n        currentStep: "inscription/construct",\n        nextStep: "inscription/retrieve"\n      });\n    }\n  };\n  var resetStatus = function resetStatus(flow) {\n    if (flow === "preparation") {\n      setPreparation({\n        isProcessing: false,\n        currentStep: "prepare/construct",\n        nextStep: "prepare/retrieve"\n      });\n    } else {\n      setInscription({\n        isProcessing: false,\n        currentStep: "inscription/construct",\n        nextStep: "inscription/retrieve"\n      });\n    }\n  };\n  return /*#__PURE__*/react.createElement(TxStatusContext.Provider, {\n    value: {\n      preparation: preparation,\n      inscription: inscription,\n      setPreparationStatus: setPreparationStatus,\n      setInscriptionStatus: setInscriptionStatus,\n      moveToNextStep: moveToNextStep,\n      resetStatus: resetStatus\n    }\n  }, children);\n};\nvar useTxStatus = function useTxStatus() {\n  var context = (0,react.useContext)(TxStatusContext);\n  if (!context) {\n    throw new Error("useTxStatus must be used within a TxStatusProvider");\n  }\n  return context;\n};\n;// ./src/components/uploader/upload-box.tsx\n"use client";\n\nfunction upload_box_slicedToArray(r, e) { return upload_box_arrayWithHoles(r) || upload_box_iterableToArrayLimit(r, e) || upload_box_unsupportedIterableToArray(r, e) || upload_box_nonIterableRest(); }\nfunction upload_box_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction upload_box_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return upload_box_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? upload_box_arrayLikeToArray(r, a) : void 0; } }\nfunction upload_box_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction upload_box_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction upload_box_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\nfunction UploadBox() {\n  var _useFileUpload = useFileUpload(),\n    addFile = _useFileUpload.addFile,\n    error = _useFileUpload.error;\n  var _useState = (0,react.useState)(false),\n    _useState2 = upload_box_slicedToArray(_useState, 2),\n    isDragging = _useState2[0],\n    setIsDragging = _useState2[1];\n  var _useState3 = (0,react.useState)(0),\n    _useState4 = upload_box_slicedToArray(_useState3, 2),\n    dragCounter = _useState4[0],\n    setDragCounter = _useState4[1];\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation;\n  var handleDragEnter = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragCounter(function (prev) {\n      return prev + 1;\n    });\n    setIsDragging(true);\n  }, []);\n  var handleDragLeave = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragCounter(function (prev) {\n      return prev - 1;\n    });\n    if (dragCounter === 0) {\n      setIsDragging(false);\n    }\n  }, [dragCounter]);\n  var handleDragOver = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }, []);\n  var handleDrop = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(false);\n    setDragCounter(0);\n    var files = e.dataTransfer.files;\n    if (files && files.length > 0) {\n      var file = files[0];\n      if (file.size > 45 * 1024) {\n        // 45KB in bytes\n        alert("File too big");\n        return;\n      }\n      addFile(files);\n    }\n  }, [addFile]);\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "relative border-2 border-dashed border-white rounded-3xl p-12 text-center transition-all ".concat(isDragging ? "bg-white/20" : ""),\n    onDragEnter: handleDragEnter,\n    onDragLeave: handleDragLeave,\n    onDragOver: handleDragOver,\n    onDrop: handleDrop,\n    initial: {\n      opacity: 0,\n      y: 20\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement("input", {\n    type: "file",\n    id: "file-upload",\n    className: "absolute inset-0 w-full h-full opacity-0 ".concat(preparation.currentStep == "prepare/construct" ? "cursor-pointer" : "cursor-not-allowed", " "),\n    onChange: function onChange(e) {\n      if (e.target.files) {\n        var file = e.target.files[0];\n        if (file && file.size > 45 * 1024) {\n          // 45KB in bytes\n\n          return;\n        }\n        addFile(e.target.files);\n      }\n    },\n    accept: ".jpg,.jpeg,.png,.pdg,.mp4",\n    disabled: preparation.currentStep != "prepare/construct"\n  }), /*#__PURE__*/react.createElement(motion.div, {\n    className: "flex flex-col items-center gap-6",\n    whileHover: {\n      scale: 1.05\n    },\n    transition: {\n      type: "spring",\n      stiffness: 300\n    }\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-[2.875rem] h-[2.875rem] rounded-full flex items-center justify-center",\n    whileHover: {\n      rotate: 360\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement(UploadIcon, {\n    className: "w-full h-full text-white"\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4"\n  }, /*#__PURE__*/react.createElement(AnimatePresence, {\n    mode: "wait"\n  }, isDragging ? /*#__PURE__*/react.createElement(motion.p, {\n    key: "dragging",\n    className: "text-2xl font-medium !text-white",\n    initial: {\n      opacity: 0,\n      y: 10\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    exit: {\n      opacity: 0,\n      y: -10\n    },\n    transition: {\n      duration: 0.2\n    }\n  }, "Drop here your file") : /*#__PURE__*/react.createElement(motion.p, {\n    key: "not-dragging",\n    className: "text-2xl !text-white font-medium",\n    initial: {\n      opacity: 0,\n      y: 10\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    exit: {\n      opacity: 0,\n      y: -10\n    },\n    transition: {\n      duration: 0.2\n    }\n  }, "Choose a file or drag & drop it here")), /*#__PURE__*/react.createElement("p", {\n    className: "text-base text-light"\n  }, "JPEG, PNG, PDG, and MP4 formats, up to 45KB")), error && /*#__PURE__*/react.createElement(motion.p, {\n    className: "text-red-500 text-sm",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    transition: {\n      duration: 0.3\n    }\n  }, error)));\n}\n;// ./src/context/WalletContext.tsx\nfunction WalletContext_typeof(o) { "@babel/helpers - typeof"; return WalletContext_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, WalletContext_typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || WalletContext_unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return WalletContext_arrayLikeToArray(r); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == WalletContext_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(WalletContext_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction WalletContext_slicedToArray(r, e) { return WalletContext_arrayWithHoles(r) || WalletContext_iterableToArrayLimit(r, e) || WalletContext_unsupportedIterableToArray(r, e) || WalletContext_nonIterableRest(); }\nfunction WalletContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction WalletContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return WalletContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? WalletContext_arrayLikeToArray(r, a) : void 0; } }\nfunction WalletContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction WalletContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction WalletContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\nvar allSupportedWallets = {\n  /*   yoroi: {\n    name: "Yoroi",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efbed9abdf9cf7e01d4_YoroiWallet.png",\n    url: "https://yoroi-wallet.com/",\n  }, */\n  /*   flint: {\n      name: "Flint",\n      icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95d7c5fb03f2d4b32b3ed_FlintWallet.svg",\n      url: "https://flint-wallet.com/",\n    },\n  \n    eternl: {\n      name: "Eternl",\n      icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efca0ebecfedfca8599_EternlWallet.png",\n      url: "https://eternl.io/",\n    }, */\n  gero: {\n    name: "Gero",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efb91d542e643bf5ed4_GeroWallet.png",\n    url: "https://gerowallet.io/"\n  },\n  nufi: {\n    name: "Nufi",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efbbee1abc10aea26ad_NufiWallet.png",\n    url: "https://nu.fi/"\n  },\n  begin: {\n    name: "Begin",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efb08b6a125a4af479b_BeginWallet.png",\n    url: "https://begin.is/"\n  },\n  lace: {\n    name: "Lace",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efbf25ef16633cdd528_LaceWallet.png",\n    url: "https://www.lace.io/"\n  }\n};\nvar WalletContext = /*#__PURE__*/(0,react.createContext)(undefined);\nfunction useWallet() {\n  var context = (0,react.useContext)(WalletContext);\n  if (context === undefined) {\n    throw new Error("useWallet must be used within a WalletProvider");\n  }\n  return context;\n}\nfunction WalletProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)(false),\n    _useState2 = WalletContext_slicedToArray(_useState, 2),\n    isMenuOpen = _useState2[0],\n    setIsMenuOpen = _useState2[1];\n  var _useState3 = (0,react.useState)([]),\n    _useState4 = WalletContext_slicedToArray(_useState3, 2),\n    connectedWallets = _useState4[0],\n    setConnectedWallets = _useState4[1];\n  var _useState5 = (0,react.useState)(localStorage.getItem("defaultWallet")),\n    _useState6 = WalletContext_slicedToArray(_useState5, 2),\n    defaultWallet = _useState6[0],\n    setDefaultWallet = _useState6[1];\n  var _useState7 = (0,react.useState)([]),\n    _useState8 = WalletContext_slicedToArray(_useState7, 2),\n    installedWallets = _useState8[0],\n    setInstalledWallets = _useState8[1];\n  var detectConnectedWallets = (0,react.useCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var cardano, connected, _i, _Object$entries, _Object$entries$_i, key, wallet, isEnabled, api;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          cardano = window.cardano;\n          if (cardano) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt("return");\n        case 3:\n          connected = [];\n          _i = 0, _Object$entries = Object.entries(allSupportedWallets);\n        case 5:\n          if (!(_i < _Object$entries.length)) {\n            _context.next = 25;\n            break;\n          }\n          _Object$entries$_i = WalletContext_slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], wallet = _Object$entries$_i[1];\n          if (!cardano[key]) {\n            _context.next = 22;\n            break;\n          }\n          _context.prev = 8;\n          _context.next = 11;\n          return cardano[key].isEnabled();\n        case 11:\n          isEnabled = _context.sent;\n          if (!isEnabled) {\n            _context.next = 17;\n            break;\n          }\n          _context.next = 15;\n          return cardano[key].enable();\n        case 15:\n          api = _context.sent;\n          connected.push({\n            name: wallet.name,\n            api: api\n          });\n        case 17:\n          _context.next = 22;\n          break;\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context["catch"](8);\n          console.error("Error detecting ".concat(wallet.name, " connection:"), _context.t0);\n        case 22:\n          _i++;\n          _context.next = 5;\n          break;\n        case 25:\n          setConnectedWallets(connected);\n        case 26:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[8, 19]]);\n  })), []);\n  var connectWallet = (0,react.useCallback)(/*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(walletName) {\n      var cardano, wallet, api;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            cardano = window.cardano;\n            if (cardano) {\n              _context2.next = 3;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 3:\n            wallet = cardano[walletName.toLowerCase()];\n            if (wallet) {\n              _context2.next = 6;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 6:\n            _context2.prev = 6;\n            _context2.next = 9;\n            return wallet.enable();\n          case 9:\n            api = _context2.sent;\n            console.log("Connected wallet:", walletName, api);\n            setConnectedWallets(function (prev) {\n              return [].concat(_toConsumableArray(prev), [{\n                name: walletName,\n                api: api\n              }]);\n            });\n            if (!defaultWallet) {\n              setDefaultWallet(walletName);\n              localStorage.setItem("defaultWallet", walletName);\n            }\n            _context2.next = 18;\n            break;\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2["catch"](6);\n            console.error("Error connecting wallet:", _context2.t0);\n          case 18:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[6, 15]]);\n    }));\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [defaultWallet]);\n  (0,react.useEffect)(function () {\n    if (!defaultWallet && connectedWallets.length > 0) {\n      setDefaultWallet(connectedWallets[0].name);\n    }\n  }, [defaultWallet, connectedWallets]);\n  var disconnectWallet = (0,react.useCallback)(function (walletName) {\n    setConnectedWallets(function (prev) {\n      return prev.filter(function (wallet) {\n        return wallet.name !== walletName;\n      });\n    });\n    if (defaultWallet === walletName) {\n      setDefaultWallet(null);\n      localStorage.removeItem("defaultWallet");\n    }\n  }, [defaultWallet]);\n  (0,react.useEffect)(function () {\n    console.log("defaultWallet", defaultWallet);\n  }, [defaultWallet]);\n  var handleSetDefaultWallet = (0,react.useCallback)(function (walletName) {\n    setDefaultWallet(walletName);\n    localStorage.setItem("defaultWallet", walletName);\n  }, []);\n  var openMenu = (0,react.useCallback)(function () {\n    return setIsMenuOpen(true);\n  }, []);\n  var closeMenu = (0,react.useCallback)(function () {\n    return setIsMenuOpen(false);\n  }, []);\n  var detectInstalledWallets = (0,react.useCallback)(function () {\n    var installed = Object.keys(allSupportedWallets).filter(function (key) {\n      return window.cardano && window.cardano[key];\n    });\n    setInstalledWallets(installed);\n  }, []);\n  var getWalletApi = (0,react.useCallback)(function (walletName) {\n    var wallet = connectedWallets.find(function (w) {\n      return w.name.toLowerCase() === walletName.toLowerCase();\n    });\n    return wallet ? wallet.api : null;\n  }, [connectedWallets]);\n  (0,react.useEffect)(function () {\n    detectInstalledWallets();\n    detectConnectedWallets();\n    window.addEventListener("cardano", detectInstalledWallets);\n    return function () {\n      return window.removeEventListener("cardano", detectInstalledWallets);\n    };\n  }, [detectInstalledWallets, detectConnectedWallets]);\n  return /*#__PURE__*/react.createElement(WalletContext.Provider, {\n    value: {\n      isMenuOpen: isMenuOpen,\n      openMenu: openMenu,\n      closeMenu: closeMenu,\n      wallets: allSupportedWallets,\n      connectedWallets: connectedWallets,\n      defaultWallet: defaultWallet,\n      connectWallet: connectWallet,\n      disconnectWallet: disconnectWallet,\n      setDefaultWallet: handleSetDefaultWallet,\n      installedWallets: installedWallets,\n      getWalletApi: getWalletApi\n    }\n  }, children);\n}\n;// ./src/utils/apiConsumption.ts\n/**\n * @author: Erick Hernndez Silva (erick@yungle.com.mx)\n * @created: 01/01/2025\n * @updated: 01/01/2025       \n * @file fileUpload.ts\n */\n\n// Main path for the API\nvar API_PATH = "https://1rozp64iaj.execute-api.us-east-1.amazonaws.com/preproduction";\nfunction buildApiUrl(path) {\n  return "".concat(API_PATH).concat(path);\n}\nvar API_KEY = "ZfQ7BY7pbwAQGGq5FAON6AxLWfwMl729Qp3W5Fq6";\nfunction toHex(input) {\n  console.log(input);\n  var encoder = new TextEncoder();\n  var encodeToHex = function encodeToHex(str) {\n    return Array.from(encoder.encode(str)).map(function (_byte) {\n      return _byte.toString(16).padStart(2, \'0\');\n    }).join(\'\');\n  };\n  if (typeof input === \'string\') {\n    return encodeToHex(input);\n  } else {\n    return input.map(encodeToHex);\n  }\n}\nfunction base64ToHex(str) {\n  var raw = atob(str);\n  var result = \'\';\n  for (var i = 0; i < raw.length; i++) {\n    var hex = raw.charCodeAt(i).toString(16);\n    result += hex.length === 2 ? hex : \'0\' + hex;\n  }\n  return result.toUpperCase();\n}\nvar ENVIRONMENT =  false || \'preproduction\';\n;// ./src/context/TxPreparationContext.tsx\n"use client";\n\nfunction TxPreparationContext_typeof(o) { "@babel/helpers - typeof"; return TxPreparationContext_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, TxPreparationContext_typeof(o); }\nfunction TxPreparationContext_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ TxPreparationContext_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == TxPreparationContext_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(TxPreparationContext_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction TxPreparationContext_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction TxPreparationContext_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { TxPreparationContext_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { TxPreparationContext_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction TxPreparationContext_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction TxPreparationContext_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TxPreparationContext_ownKeys(Object(t), !0).forEach(function (r) { TxPreparationContext_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TxPreparationContext_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction TxPreparationContext_defineProperty(e, r, t) { return (r = TxPreparationContext_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction TxPreparationContext_toPropertyKey(t) { var i = TxPreparationContext_toPrimitive(t, "string"); return "symbol" == TxPreparationContext_typeof(i) ? i : i + ""; }\nfunction TxPreparationContext_toPrimitive(t, r) { if ("object" != TxPreparationContext_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != TxPreparationContext_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction TxPreparationContext_slicedToArray(r, e) { return TxPreparationContext_arrayWithHoles(r) || TxPreparationContext_iterableToArrayLimit(r, e) || TxPreparationContext_unsupportedIterableToArray(r, e) || TxPreparationContext_nonIterableRest(); }\nfunction TxPreparationContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction TxPreparationContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TxPreparationContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TxPreparationContext_arrayLikeToArray(r, a) : void 0; } }\nfunction TxPreparationContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TxPreparationContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction TxPreparationContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\nvar TxPreparationContext = /*#__PURE__*/(0,react.createContext)(undefined);\nfunction useTxPreparation() {\n  var context = (0,react.useContext)(TxPreparationContext);\n  if (!context) {\n    throw new Error("useTxPreparation must be used within a TxPreparationProvider");\n  }\n  return context;\n}\nfunction TxPreparationProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)([]),\n    _useState2 = TxPreparationContext_slicedToArray(_useState, 2),\n    fileProgress = _useState2[0],\n    setFileProgress = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = TxPreparationContext_slicedToArray(_useState3, 2),\n    isProcessing = _useState4[0],\n    setIsProcessing = _useState4[1];\n  var _useState5 = (0,react.useState)(null),\n    _useState6 = TxPreparationContext_slicedToArray(_useState5, 2),\n    error = _useState6[0],\n    setError = _useState6[1];\n  var _useWallet = useWallet(),\n    getWalletApi = _useWallet.getWalletApi,\n    defaultWallet = _useWallet.defaultWallet;\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation,\n    moveToNextStep = _useTxStatus.moveToNextStep;\n  var _useState7 = (0,react.useState)(),\n    _useState8 = TxPreparationContext_slicedToArray(_useState7, 2),\n    submissionStatus = _useState8[0],\n    setSubmissionStatus = _useState8[1];\n  var _useState9 = (0,react.useState)(null),\n    _useState10 = TxPreparationContext_slicedToArray(_useState9, 2),\n    unsignedTxId = _useState10[0],\n    setUnsignedTxId = _useState10[1];\n  var updateFileProgress = (0,react.useCallback)(function (index, updates) {\n    setFileProgress(function (prev) {\n      return prev.map(function (item, i) {\n        return i === index ? TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, item), updates) : item;\n      });\n    });\n  }, []);\n  var clearError = (0,react.useCallback)(function () {\n    setError(null);\n  }, []);\n  var constructTx = /*#__PURE__*/function () {\n    var _ref2 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee(api, data, dataType) {\n      var rewardAddresses, utxos, targetAddress, body, response, errorData, errorResponse;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return api.getRewardAddresses();\n          case 2:\n            rewardAddresses = _context.sent;\n            _context.next = 5;\n            return api.getUtxos();\n          case 5:\n            _context.t0 = _context.sent;\n            if (_context.t0) {\n              _context.next = 8;\n              break;\n            }\n            _context.t0 = [];\n          case 8:\n            utxos = _context.t0;\n            console.log("UTXOs:", utxos);\n            _context.next = 12;\n            return api.getUsedAddresses();\n          case 12:\n            targetAddress = _context.sent[0];\n            if (!(!utxos || utxos.length === 0)) {\n              _context.next = 16;\n              break;\n            }\n            setError("No hay UTXOs disponibles");\n            throw new Error("No UTXOs available");\n          case 16:\n            body = {\n              data: data,\n              dataType: dataType,\n              rewardAddresses: rewardAddresses,\n              targetAddress: targetAddress,\n              utxos: utxos\n            };\n            console.log("Body:", body);\n            _context.next = 20;\n            return fetch(buildApiUrl("/prepare-utxos/construct-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(body)\n            });\n          case 20:\n            response = _context.sent;\n            if (response.ok) {\n              _context.next = 35;\n              break;\n            }\n            _context.prev = 22;\n            errorResponse = response.clone();\n            _context.next = 26;\n            return errorResponse.json();\n          case 26:\n            errorData = _context.sent;\n            _context.next = 34;\n            break;\n          case 29:\n            _context.prev = 29;\n            _context.t1 = _context["catch"](22);\n            _context.next = 33;\n            return response.text();\n          case 33:\n            errorData = _context.sent;\n          case 34:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/prepare-utxos/construct-tx"\n            }));\n          case 35:\n            // Se avanza al siguiente paso en el flujo de preparacin\n            moveToNextStep("preparation");\n            _context.next = 38;\n            return response.json();\n          case 38:\n            return _context.abrupt("return", _context.sent);\n          case 39:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee, null, [[22, 29]]);\n    }));\n    return function constructTx(_x, _x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var prepareFiles = /*#__PURE__*/function () {\n    var _ref3 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee2(files) {\n      var api, _loop, i;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee2$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (defaultWallet) {\n              _context3.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context3.prev = 4;\n            setFileProgress(files.map(function (file) {\n              return {\n                file: file,\n                status: "pending",\n                progress: 0\n              };\n            }));\n            _loop = /*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _loop(i) {\n              var reader, fileAsBase64, base64Content, constructedTx;\n              return TxPreparationContext_regeneratorRuntime().wrap(function _loop$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    updateFileProgress(i, {\n                      status: "constructing",\n                      progress: 25\n                    });\n                    reader = new FileReader();\n                    _context2.next = 4;\n                    return new Promise(function (resolve, reject) {\n                      reader.onload = function () {\n                        return resolve(reader.result);\n                      };\n                      reader.onerror = reject;\n                      reader.readAsDataURL(files[i]);\n                    });\n                  case 4:\n                    fileAsBase64 = _context2.sent;\n                    base64Content = fileAsBase64.split(",")[1];\n                    _context2.next = 8;\n                    return constructTx(api, base64Content, files[i].type);\n                  case 8:\n                    constructedTx = _context2.sent;\n                    updateFileProgress(0, {\n                      status: "unsigned",\n                      progress: 50,\n                      txInfo: {\n                        constructedTx: constructedTx\n                      }\n                    });\n                  case 10:\n                  case "end":\n                    return _context2.stop();\n                }\n              }, _loop);\n            });\n            i = 0;\n          case 8:\n            if (!(i < files.length)) {\n              _context3.next = 13;\n              break;\n            }\n            return _context3.delegateYield(_loop(i), "t0", 10);\n          case 10:\n            i++;\n            _context3.next = 8;\n            break;\n          case 13:\n            moveToNextStep("preparation");\n            _context3.next = 20;\n            break;\n          case 16:\n            _context3.prev = 16;\n            _context3.t1 = _context3["catch"](4);\n            console.error("Error preparing files:", _context3.t1);\n            setError(_context3.t1 instanceof Error ? _context3.t1.message : JSON.stringify(_context3.t1));\n          case 20:\n            _context3.prev = 20;\n            setIsProcessing(false);\n            return _context3.finish(20);\n          case 23:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee2, null, [[4, 16, 20, 23]]);\n    }));\n    return function prepareFiles(_x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var prepareText = /*#__PURE__*/function () {\n    var _ref4 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee3(text) {\n      var api, textFile, base64Content, constructedTx;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee3$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (defaultWallet) {\n              _context4.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context4.prev = 4;\n            textFile = new File([text], "delegate.txt", {\n              type: "text/plain"\n            });\n            setFileProgress([{\n              file: textFile,\n              status: "pending",\n              progress: 0\n            }]);\n            updateFileProgress(0, {\n              status: "constructing",\n              progress: 25\n            });\n            console.log("text", text);\n            base64Content = btoa(unescape(encodeURIComponent(text)));\n            console.log("base64Content", base64Content);\n            _context4.next = 13;\n            return constructTx(api, base64Content, "text/plain");\n          case 13:\n            constructedTx = _context4.sent;\n            console.log("constructedTx", constructedTx);\n            updateFileProgress(0, {\n              status: "unsigned",\n              progress: 50,\n              txInfo: {\n                constructedTx: constructedTx\n              }\n            });\n            moveToNextStep("preparation");\n            _context4.next = 23;\n            break;\n          case 19:\n            _context4.prev = 19;\n            _context4.t0 = _context4["catch"](4);\n            console.error("Error preparing text:", _context4.t0);\n            setError(_context4.t0 instanceof Error ? _context4.t0.message : JSON.stringify(_context4.t0));\n          case 23:\n            _context4.prev = 23;\n            setIsProcessing(false);\n            return _context4.finish(23);\n          case 26:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee3, null, [[4, 19, 23, 26]]);\n    }));\n    return function prepareText(_x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var pollForConfirmation = /*#__PURE__*/function () {\n    var _ref5 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee4(preparedTx) {\n      var retryInterval, response, errorData, errorResponse, status;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee4$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            retryInterval = 9000;\n          case 1:\n            if (false) {}\n            _context5.prev = 2;\n            _context5.next = 5;\n            return fetch(buildApiUrl("/prepare-utxos/retrieve-submission-status"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(preparedTx.executionArn)\n            });\n          case 5:\n            response = _context5.sent;\n            if (response.ok) {\n              _context5.next = 21;\n              break;\n            }\n            errorData = void 0;\n            _context5.prev = 8;\n            errorResponse = response.clone();\n            _context5.next = 12;\n            return errorResponse.json();\n          case 12:\n            errorData = _context5.sent;\n            _context5.next = 20;\n            break;\n          case 15:\n            _context5.prev = 15;\n            _context5.t0 = _context5["catch"](8);\n            _context5.next = 19;\n            return response.text();\n          case 19:\n            errorData = _context5.sent;\n          case 20:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/prepare-utxos/retrieve-submission-status"\n            }));\n          case 21:\n            _context5.next = 23;\n            return response.json();\n          case 23:\n            status = _context5.sent;\n            if (!(status.success && status.success.onchain === "on-chain")) {\n              _context5.next = 30;\n              break;\n            }\n            setSubmissionStatus(status);\n            setIsProcessing(false);\n            moveToNextStep("preparation");\n            clearError();\n            return _context5.abrupt("return", true);\n          case 30:\n            _context5.next = 32;\n            return new Promise(function (res) {\n              return setTimeout(res, retryInterval);\n            });\n          case 32:\n            _context5.next = 39;\n            break;\n          case 34:\n            _context5.prev = 34;\n            _context5.t1 = _context5["catch"](2);\n            console.error("Polling attempt failed:", _context5.t1);\n            setError(_context5.t1 instanceof Error ? _context5.t1.message : JSON.stringify(_context5.t1));\n            throw _context5.t1;\n          case 39:\n            _context5.next = 1;\n            break;\n          case 41:\n          case "end":\n            return _context5.stop();\n        }\n      }, _callee4, null, [[2, 34], [8, 15]]);\n    }));\n    return function pollForConfirmation(_x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitError = function handleSignAndSubmitError(error) {\n    console.error("Error in sign and submit:", error);\n\n    // Format the error message based on the error type\n    var errorMessage;\n\n    // Handle TxSignError from wallet\n    if (error && error.name === "TxSignError") {\n      errorMessage = "Wallet signing error: ".concat(error.info || error.message || "Failed to sign transaction");\n    }\n    // Handle Error objects\n    else if (error instanceof Error) {\n      try {\n        var _parsedError$error;\n        // Try to parse the error message as JSON\n        var parsedError = JSON.parse(error.message);\n        errorMessage = ((_parsedError$error = parsedError.error) === null || _parsedError$error === void 0 ? void 0 : _parsedError$error.message) || parsedError.message || error.message;\n      } catch (e) {\n        // If parsing fails, use the original error message\n        errorMessage = error.message || "Unknown error occurred";\n      }\n    }\n    // Handle other error types\n    else {\n      try {\n        errorMessage = JSON.stringify(error);\n      } catch (e) {\n        errorMessage = "Unknown error occurred";\n      }\n    }\n    setError(errorMessage);\n    setFileProgress(function (prev) {\n      return prev.map(function (file) {\n        return TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file), {}, {\n          status: "failed",\n          progress: 0\n        });\n      });\n    });\n    // Don\'t reset the step to the beginning for wallet signing errors\n    // This allows users to retry from the current step\n    if (error && error.name === "TxSignError") {\n      console.log("Wallet signing error detected, keeping current step");\n      // Just set processing to false but don\'t change the step\n      setIsProcessing(false);\n    } else {\n      // For other errors, we can reset processing state\n      setIsProcessing(false);\n    }\n  };\n  var signAndSubmit = /*#__PURE__*/function () {\n    var _ref6 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee5() {\n      var i, _file$txInfo, file, executionArn, unsignedTxResponse, errorData, errorResponse, unsignedTx, retryResponse, _errorData, _errorResponse, hexTx, signedTx, api, submitResponse, _errorData2, _errorResponse2, submittedTx, confirmed;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee5$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            if (defaultWallet) {\n              _context6.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            setIsProcessing(true);\n            _context6.prev = 3;\n            i = 0;\n          case 5:\n            if (!(i < fileProgress.length)) {\n              _context6.next = 118;\n              break;\n            }\n            file = fileProgress[i];\n            console.log("file", file);\n            if ((_file$txInfo = file.txInfo) !== null && _file$txInfo !== void 0 && _file$txInfo.constructedTx) {\n              _context6.next = 10;\n              break;\n            }\n            return _context6.abrupt("continue", 115);\n          case 10:\n            executionArn = file.txInfo.constructedTx.executionArn;\n            console.log("executionArn", executionArn);\n            _context6.next = 14;\n            return fetch(buildApiUrl("/prepare-utxos/retrieve-unsigned-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(executionArn)\n            });\n          case 14:\n            unsignedTxResponse = _context6.sent;\n            if (unsignedTxResponse.ok) {\n              _context6.next = 30;\n              break;\n            }\n            errorData = void 0;\n            _context6.prev = 17;\n            errorResponse = unsignedTxResponse.clone();\n            _context6.next = 21;\n            return errorResponse.json();\n          case 21:\n            errorData = _context6.sent;\n            _context6.next = 29;\n            break;\n          case 24:\n            _context6.prev = 24;\n            _context6.t0 = _context6["catch"](17);\n            _context6.next = 28;\n            return unsignedTxResponse.text();\n          case 28:\n            errorData = _context6.sent;\n          case 29:\n            throw new Error(JSON.stringify({\n              status: unsignedTxResponse.status,\n              statusText: unsignedTxResponse.statusText,\n              error: errorData,\n              endpoint: "/prepare-utxos/retrieve-unsigned-tx"\n            }));\n          case 30:\n            _context6.next = 32;\n            return unsignedTxResponse.json();\n          case 32:\n            unsignedTx = _context6.sent;\n            console.log("Unsigned TX:", unsignedTx);\n\n            // Guardar el txid cuando est disponible\n            if (unsignedTx.success && unsignedTx.success.txid) {\n              setUnsignedTxId(unsignedTx.success.txid);\n            }\n            if (!unsignedTx.inProgress) {\n              _context6.next = 64;\n              break;\n            }\n          case 36:\n            if (!unsignedTx.inProgress) {\n              _context6.next = 64;\n              break;\n            }\n            console.log("Unsigned transaction still in progress...");\n            _context6.next = 40;\n            return new Promise(function (res) {\n              return setTimeout(res, 5000);\n            });\n          case 40:\n            _context6.next = 42;\n            return fetch(buildApiUrl("/prepare-utxos/retrieve-unsigned-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(executionArn)\n            });\n          case 42:\n            retryResponse = _context6.sent;\n            if (retryResponse.ok) {\n              _context6.next = 58;\n              break;\n            }\n            _errorData = void 0;\n            _context6.prev = 45;\n            _errorResponse = retryResponse.clone();\n            _context6.next = 49;\n            return _errorResponse.json();\n          case 49:\n            _errorData = _context6.sent;\n            _context6.next = 57;\n            break;\n          case 52:\n            _context6.prev = 52;\n            _context6.t1 = _context6["catch"](45);\n            _context6.next = 56;\n            return retryResponse.text();\n          case 56:\n            _errorData = _context6.sent;\n          case 57:\n            throw new Error(JSON.stringify({\n              status: retryResponse.status,\n              statusText: retryResponse.statusText,\n              error: _errorData,\n              endpoint: "/prepare-utxos/retrieve-unsigned-tx"\n            }));\n          case 58:\n            _context6.next = 60;\n            return retryResponse.json();\n          case 60:\n            unsignedTx = _context6.sent;\n            console.log("Retry Unsigned TX:", unsignedTx);\n            _context6.next = 36;\n            break;\n          case 64:\n            updateFileProgress(i, {\n              progress: 75,\n              txInfo: TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file.txInfo), {}, {\n                unsignedTx: unsignedTx\n              })\n            });\n            hexTx = base64ToHex(unsignedTx.success.tx);\n            console.log("Hex TX:", hexTx);\n            signedTx = void 0;\n            _context6.prev = 68;\n            // Clear any previous error state before attempting to sign again\n            clearError();\n\n            // Get a fresh wallet API instance to ensure the popup appears again\n            api = getWalletApi(defaultWallet);\n            _context6.next = 73;\n            return api.signTx(hexTx);\n          case 73:\n            signedTx = _context6.sent;\n            console.log("Signed TX:", signedTx);\n            updateFileProgress(i, {\n              status: "signed",\n              progress: 85,\n              txInfo: TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file.txInfo), {}, {\n                unsignedTx: unsignedTx,\n                signedTx: signedTx\n              })\n            });\n            // Move to the next step only after successful signing\n            moveToNextStep("preparation");\n            _context6.next = 87;\n            break;\n          case 79:\n            _context6.prev = 79;\n            _context6.t2 = _context6["catch"](68);\n            console.error("Error signing transaction:", _context6.t2);\n            // Don\'t move to the next step if there\'s a signing error\n            // This allows the user to retry signing from the same step\n            if (!(_context6.t2 && _context6.t2.name === "TxSignError")) {\n              _context6.next = 86;\n              break;\n            }\n            throw _context6.t2;\n          case 86:\n            throw new Error("Failed to sign transaction: ".concat(_context6.t2.message || JSON.stringify(_context6.t2)));\n          case 87:\n            _context6.next = 89;\n            return fetch(buildApiUrl("/prepare-utxos/submit"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify({\n                tx: unsignedTx.success.tx,\n                ulid: unsignedTx.success.ulid,\n                witnessSet: signedTx\n              })\n            });\n          case 89:\n            submitResponse = _context6.sent;\n            if (submitResponse.ok) {\n              _context6.next = 105;\n              break;\n            }\n            _errorData2 = void 0;\n            _context6.prev = 92;\n            _errorResponse2 = submitResponse.clone();\n            _context6.next = 96;\n            return _errorResponse2.json();\n          case 96:\n            _errorData2 = _context6.sent;\n            _context6.next = 104;\n            break;\n          case 99:\n            _context6.prev = 99;\n            _context6.t3 = _context6["catch"](92);\n            _context6.next = 103;\n            return submitResponse.text();\n          case 103:\n            _errorData2 = _context6.sent;\n          case 104:\n            throw new Error(JSON.stringify({\n              status: submitResponse.status,\n              statusText: submitResponse.statusText,\n              error: _errorData2,\n              endpoint: "/prepare-utxos/submit"\n            }));\n          case 105:\n            _context6.next = 107;\n            return submitResponse.json();\n          case 107:\n            submittedTx = _context6.sent;\n            console.log("Submitted TX:", submittedTx);\n            // Move to the next step after successful submission\n            moveToNextStep("preparation");\n            updateFileProgress(i, {\n              status: "submitted",\n              progress: 95,\n              txInfo: TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file.txInfo), {}, {\n                unsignedTx: unsignedTx,\n                signedTx: signedTx,\n                submittedTx: submittedTx\n              })\n            });\n            _context6.next = 113;\n            return pollForConfirmation(submittedTx);\n          case 113:\n            confirmed = _context6.sent;\n            updateFileProgress(i, {\n              status: confirmed ? "confirmed" : "failed",\n              progress: confirmed ? 100 : 0\n            });\n          case 115:\n            i++;\n            _context6.next = 5;\n            break;\n          case 118:\n            _context6.next = 123;\n            break;\n          case 120:\n            _context6.prev = 120;\n            _context6.t4 = _context6["catch"](3);\n            handleSignAndSubmitError(_context6.t4);\n          case 123:\n            _context6.prev = 123;\n            setIsProcessing(false);\n            return _context6.finish(123);\n          case 126:\n          case "end":\n            return _context6.stop();\n        }\n      }, _callee5, null, [[3, 120, 123, 126], [17, 24], [45, 52], [68, 79], [92, 99]]);\n    }));\n    return function signAndSubmit() {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  var reset = (0,react.useCallback)(function () {\n    setFileProgress([]);\n    setIsProcessing(false);\n    setSubmissionStatus(undefined);\n    setUnsignedTxId(null);\n    setError(null);\n  }, []);\n  (0,react.useEffect)(function () {\n    if (error) {\n      console.log("Error detected in TxPreparationContext:", error);\n\n      // Update all file progress to failed status when an error occurs\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n\n      // Ensure processing state is reset\n      setIsProcessing(false);\n    }\n  }, [error]);\n  return /*#__PURE__*/react.createElement(TxPreparationContext.Provider, {\n    value: {\n      fileProgress: fileProgress,\n      prepareFiles: prepareFiles,\n      prepareText: prepareText,\n      signAndSubmit: signAndSubmit,\n      isProcessing: isProcessing,\n      currentStep: preparation.currentStep,\n      nextStep: preparation.nextStep,\n      error: error,\n      clearError: clearError,\n      reset: reset,\n      submissionStatus: submissionStatus,\n      setSubmissionStatus: setSubmissionStatus,\n      unsignedTxId: unsignedTxId,\n      setUnsignedTxId: setUnsignedTxId\n    }\n  }, children);\n}\n;// ./src/icons/CloseIcon.tsx\n\nvar CloseIcon = function CloseIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "30",\n    height: "30",\n    viewBox: "0 0 30 30",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M15 28.4375C7.5875 28.4375 1.5625 22.4125 1.5625 15C1.5625 7.5875 7.5875 1.5625 15 1.5625C22.4125 1.5625 28.4375 7.5875 28.4375 15C28.4375 22.4125 22.4125 28.4375 15 28.4375ZM15 3.4375C8.625 3.4375 3.4375 8.625 3.4375 15C3.4375 21.375 8.625 26.5625 15 26.5625C21.375 26.5625 26.5625 21.375 26.5625 15C26.5625 8.625 21.375 3.4375 15 3.4375Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M11.4627 19.475C11.2252 19.475 10.9877 19.3875 10.8002 19.2C10.4377 18.8375 10.4377 18.2375 10.8002 17.875L17.8752 10.8C18.2377 10.4375 18.8377 10.4375 19.2002 10.8C19.5627 11.1625 19.5627 11.7625 19.2002 12.125L12.1252 19.2C11.9502 19.3875 11.7002 19.475 11.4627 19.475Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M18.5377 19.475C18.3002 19.475 18.0627 19.3875 17.8752 19.2L10.8002 12.125C10.4377 11.7625 10.4377 11.1625 10.8002 10.8C11.1627 10.4375 11.7627 10.4375 12.1252 10.8L19.2002 17.875C19.5627 18.2375 19.5627 18.8375 19.2002 19.2C19.0127 19.3875 18.7752 19.475 18.5377 19.475Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/components/ui/Button.tsx\nfunction Button_typeof(o) { "@babel/helpers - typeof"; return Button_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Button_typeof(o); }\nvar _excluded = ["children", "variant", "loadingText", "successText", "iconBefore", "iconAfter", "onClick", "animate", "className"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction Button_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ Button_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == Button_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(Button_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction Button_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction Button_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { Button_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { Button_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction Button_slicedToArray(r, e) { return Button_arrayWithHoles(r) || Button_iterableToArrayLimit(r, e) || Button_unsupportedIterableToArray(r, e) || Button_nonIterableRest(); }\nfunction Button_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction Button_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return Button_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? Button_arrayLikeToArray(r, a) : void 0; } }\nfunction Button_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction Button_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction Button_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n\n\n\nvar Button = function Button(_ref) {\n  var children = _ref.children,\n    _ref$variant = _ref.variant,\n    variant = _ref$variant === void 0 ? "primary" : _ref$variant,\n    loadingText = _ref.loadingText,\n    successText = _ref.successText,\n    iconBefore = _ref.iconBefore,\n    iconAfter = _ref.iconAfter,\n    onClick = _ref.onClick,\n    _ref$animate = _ref.animate,\n    animate = _ref$animate === void 0 ? true : _ref$animate,\n    _ref$className = _ref.className,\n    className = _ref$className === void 0 ? "" : _ref$className,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _useState = (0,react.useState)(false),\n    _useState2 = Button_slicedToArray(_useState, 2),\n    isLoading = _useState2[0],\n    setIsLoading = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = Button_slicedToArray(_useState3, 2),\n    isSuccess = _useState4[0],\n    setIsSuccess = _useState4[1];\n  var handleClick = /*#__PURE__*/function () {\n    var _ref2 = Button_asyncToGenerator(/*#__PURE__*/Button_regeneratorRuntime().mark(function _callee(event) {\n      return Button_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!onClick) {\n              _context.next = 7;\n              break;\n            }\n            setIsLoading(animate);\n            _context.next = 4;\n            return onClick(event);\n          case 4:\n            setIsLoading(false);\n            setIsSuccess(animate);\n            setTimeout(function () {\n              return setIsSuccess(false);\n            }, 2000);\n          case 7:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function handleClick(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var baseClasses = "!flex !justify-center !items-center !gap-2 !rounded-full !transition-colors !duration-300 !focus:outline-none !font-bold cursor-pointer";\n  var variantClasses = {\n    primary: "!border !border-white !bg-white !text-primary-tw hover:!bg-transparent hover:!text-white",\n    secondary: "!border !border-white !bg-transparent !text-white hover:!text-white",\n    ghost: "!bg-transparent !text-white hover:!bg-white/10",\n    icon: "!rounded-full !w-10 !h-10 !p-2"\n  };\n  var disabledClasses = "!opacity-50 !cursor-not-allowed";\n  var sizeClasses = variant === "icon" ? "" : "px-5 py-2";\n  var buttonClasses = "".concat(baseClasses, " ").concat(variantClasses[variant], " ").concat(sizeClasses, " ").concat(className, " ").concat(props.disabled ? disabledClasses : "");\n  return /*#__PURE__*/react.createElement(motion.button, _extends({\n    className: buttonClasses,\n    onClick: handleClick,\n    whileTap: {\n      scale: 0.95\n    }\n  }, props), isLoading ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-5 h-5 border-t-2 border-b-2 border-current rounded-full",\n    animate: {\n      rotate: 360\n    },\n    transition: {\n      duration: 1,\n      repeat: Number.POSITIVE_INFINITY,\n      ease: "linear"\n    }\n  }), loadingText) : isSuccess ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(motion.div, {\n    initial: {\n      scale: 0\n    },\n    animate: {\n      scale: 1\n    },\n    transition: {\n      type: "spring",\n      stiffness: 500,\n      damping: 30\n    }\n  }, "\\u2713"), successText) : /*#__PURE__*/react.createElement(react.Fragment, null, iconBefore, Array.isArray(children) ? children.map(function (child, index) {\n    return child instanceof MotionValue ? /*#__PURE__*/react.createElement(motion.span, {\n      key: index\n    }, child) : child;\n  }) : children instanceof MotionValue ? /*#__PURE__*/react.createElement(motion.span, null, children) : children, iconAfter));\n};\n;// ./src/icons/PdfIcon.tsx\n\nvar PdfIcon = function PdfIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M42 28.5C42 28.8978 41.842 29.2794 41.5607 29.5607C41.2794 29.842 40.8978 30 40.5 30H36V33H39C39.3978 33 39.7794 33.158 40.0607 33.4393C40.342 33.7206 40.5 34.1022 40.5 34.5C40.5 34.8978 40.342 35.2794 40.0607 35.5607C39.7794 35.842 39.3978 36 39 36H36V39C36 39.3978 35.842 39.7794 35.5607 40.0607C35.2794 40.342 34.8978 40.5 34.5 40.5C34.1022 40.5 33.7206 40.342 33.4393 40.0607C33.158 39.7794 33 39.3978 33 39V28.5C33 28.1022 33.158 27.7206 33.4393 27.4393C33.7206 27.158 34.1022 27 34.5 27H40.5C40.8978 27 41.2794 27.158 41.5607 27.4393C41.842 27.7206 42 28.1022 42 28.5ZM17.25 32.25C17.25 33.6424 16.6969 34.9777 15.7123 35.9623C14.7277 36.9469 13.3924 37.5 12 37.5H10.5V39C10.5 39.3978 10.342 39.7794 10.0607 40.0607C9.77936 40.342 9.39782 40.5 9 40.5C8.60218 40.5 8.22064 40.342 7.93934 40.0607C7.65804 39.7794 7.5 39.3978 7.5 39V28.5C7.5 28.1022 7.65804 27.7206 7.93934 27.4393C8.22064 27.158 8.60218 27 9 27H12C13.3924 27 14.7277 27.5531 15.7123 28.5377C16.6969 29.5223 17.25 30.8576 17.25 32.25ZM14.25 32.25C14.25 31.6533 14.0129 31.081 13.591 30.659C13.169 30.2371 12.5967 30 12 30H10.5V34.5H12C12.5967 34.5 13.169 34.2629 13.591 33.841C14.0129 33.419 14.25 32.8467 14.25 32.25ZM30.75 33.75C30.75 35.5402 30.0388 37.2571 28.773 38.523C27.5071 39.7888 25.7902 40.5 24 40.5H21C20.6022 40.5 20.2206 40.342 19.9393 40.0607C19.658 39.7794 19.5 39.3978 19.5 39V28.5C19.5 28.1022 19.658 27.7206 19.9393 27.4393C20.2206 27.158 20.6022 27 21 27H24C25.7902 27 27.5071 27.7112 28.773 28.977C30.0388 30.2429 30.75 31.9598 30.75 33.75ZM27.75 33.75C27.75 32.7554 27.3549 31.8016 26.6516 31.0984C25.9484 30.3951 24.9946 30 24 30H22.5V37.5H24C24.9946 37.5 25.9484 37.1049 26.6516 36.4016C27.3549 35.6984 27.75 34.7446 27.75 33.75ZM7.5 21V7.5C7.5 6.70435 7.81607 5.94129 8.37868 5.37868C8.94129 4.81607 9.70435 4.5 10.5 4.5H28.5C28.697 4.49985 28.8922 4.53851 29.0743 4.6138C29.2564 4.68908 29.4218 4.7995 29.5613 4.93875L40.0612 15.4388C40.2005 15.5782 40.3109 15.7436 40.3862 15.9257C40.4615 16.1078 40.5002 16.303 40.5 16.5V21C40.5 21.3978 40.342 21.7794 40.0607 22.0607C39.7794 22.342 39.3978 22.5 39 22.5C38.6022 22.5 38.2206 22.342 37.9393 22.0607C37.658 21.7794 37.5 21.3978 37.5 21V18H28.5C28.1022 18 27.7206 17.842 27.4393 17.5607C27.158 17.2794 27 16.8978 27 16.5V7.5H10.5V21C10.5 21.3978 10.342 21.7794 10.0607 22.0607C9.77936 22.342 9.39782 22.5 9 22.5C8.60218 22.5 8.22064 22.342 7.93934 22.0607C7.65804 21.7794 7.5 21.3978 7.5 21ZM30 15H35.3794L30 9.62063V15Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/icons/PngIcon.tsx\n\nvar PngIcon = function PngIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M11.25 27H8.25C7.85218 27 7.47064 27.158 7.18934 27.4393C6.90804 27.7206 6.75 28.1022 6.75 28.5V39C6.75 39.3978 6.90804 39.7794 7.18934 40.0607C7.47064 40.342 7.85218 40.5 8.25 40.5C8.64782 40.5 9.02936 40.342 9.31066 40.0607C9.59196 39.7794 9.75 39.3978 9.75 39V37.5H11.25C12.6424 37.5 13.9777 36.9469 14.9623 35.9623C15.9469 34.9777 16.5 33.6424 16.5 32.25C16.5 30.8576 15.9469 29.5223 14.9623 28.5377C13.9777 27.5531 12.6424 27 11.25 27ZM11.25 34.5H9.75V30H11.25C11.8467 30 12.419 30.2371 12.841 30.659C13.2629 31.081 13.5 31.6533 13.5 32.25C13.5 32.8467 13.2629 33.419 12.841 33.841C12.419 34.2629 11.8467 34.5 11.25 34.5ZM42 37.6631C42 38.0495 41.8508 38.4209 41.5837 38.7C41.0615 39.2622 40.4298 39.7119 39.7276 40.0214C39.0254 40.3309 38.2674 40.4938 37.5 40.5C34.1906 40.5 31.5 37.4719 31.5 33.75C31.5 30.0281 34.1906 27 37.5 27C38.6026 27.0037 39.6788 27.3374 40.59 27.9581C40.9199 28.1819 41.1475 28.5276 41.2226 28.9191C41.2976 29.3107 41.2141 29.716 40.9903 30.0459C40.7665 30.3759 40.4209 30.6034 40.0293 30.6785C39.6378 30.7536 39.2324 30.67 38.9025 30.4463C38.4911 30.1587 38.0019 30.0031 37.5 30C35.8463 30 34.5 31.6875 34.5 33.75C34.5 35.8125 35.8463 37.5 37.5 37.5C38.0415 37.494 38.567 37.3153 39 36.99V36C38.6022 36 38.2206 35.842 37.9393 35.5607C37.658 35.2794 37.5 34.8978 37.5 34.5C37.5 34.1022 37.658 33.7206 37.9393 33.4393C38.2206 33.158 38.6022 33 39 33H40.5C40.8978 33 41.2794 33.158 41.5607 33.4393C41.842 33.7206 42 34.1022 42 34.5V37.6631ZM29.25 28.5V39C29.25 39.3179 29.1491 39.6276 28.9617 39.8844C28.7744 40.1412 28.5102 40.3318 28.2075 40.4288C28.0597 40.4763 27.9053 40.5004 27.75 40.5C27.5112 40.5 27.2759 40.443 27.0636 40.3338C26.8513 40.2245 26.6682 40.0662 26.5294 39.8719L21.75 33.1875V39C21.75 39.3978 21.592 39.7794 21.3107 40.0607C21.0294 40.342 20.6478 40.5 20.25 40.5C19.8522 40.5 19.4706 40.342 19.1893 40.0607C18.908 39.7794 18.75 39.3978 18.75 39V28.5C18.75 28.1822 18.8509 27.8726 19.0382 27.6158C19.2256 27.3591 19.4896 27.1685 19.7922 27.0715C20.0949 26.9745 20.4205 26.9762 20.7222 27.0762C21.0238 27.1762 21.2859 27.3695 21.4706 27.6281L26.25 34.3125V28.5C26.25 28.1022 26.408 27.7206 26.6893 27.4393C26.9706 27.158 27.3522 27 27.75 27C28.1478 27 28.5294 27.158 28.8107 27.4393C29.092 27.7206 29.25 28.1022 29.25 28.5ZM9 22.5C9.39782 22.5 9.77936 22.342 10.0607 22.0607C10.342 21.7794 10.5 21.3978 10.5 21V7.5H27V16.5C27 16.8978 27.158 17.2794 27.4393 17.5607C27.7206 17.842 28.1022 18 28.5 18H37.5V21C37.5 21.3978 37.658 21.7794 37.9393 22.0607C38.2206 22.342 38.6022 22.5 39 22.5C39.3978 22.5 39.7794 22.342 40.0607 22.0607C40.342 21.7794 40.5 21.3978 40.5 21V16.5C40.5002 16.303 40.4615 16.1078 40.3862 15.9257C40.3109 15.7436 40.2005 15.5782 40.0612 15.4388L29.5613 4.93875C29.4218 4.7995 29.2564 4.68908 29.0743 4.6138C28.8922 4.53851 28.697 4.49985 28.5 4.5H10.5C9.70435 4.5 8.94129 4.81607 8.37868 5.37868C7.81607 5.94129 7.5 6.70435 7.5 7.5V21C7.5 21.3978 7.65804 21.7794 7.93934 22.0607C8.22064 22.342 8.60218 22.5 9 22.5ZM30 9.62063L35.3794 15H30V9.62063Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/icons/PdgIcon.tsx\n\nvar PdgIcon = function PdgIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M11.25 27H8.25C7.85218 27 7.47064 27.158 7.18934 27.4393C6.90804 27.7206 6.75 28.1022 6.75 28.5V39C6.75 39.3978 6.90804 39.7794 7.18934 40.0607C7.47064 40.342 7.85218 40.5 8.25 40.5C8.64782 40.5 9.02936 40.342 9.31066 40.0607C9.59196 39.7794 9.75 39.3978 9.75 39V37.5H11.25C12.6424 37.5 13.9777 36.9469 14.9623 35.9623C15.9469 34.9777 16.5 33.6424 16.5 32.25C16.5 30.8576 15.9469 29.5223 14.9623 28.5377C13.9777 27.5531 12.6424 27 11.25 27ZM11.25 34.5H9.75V30H11.25C11.8467 30 12.419 30.2371 12.841 30.659C13.2629 31.081 13.5 31.6533 13.5 32.25C13.5 32.8467 13.2629 33.419 12.841 33.841C12.419 34.2629 11.8467 34.5 11.25 34.5ZM42 37.6631C42 38.0495 41.8508 38.4209 41.5837 38.7C41.0615 39.2622 40.4298 39.7119 39.7276 40.0214C39.0254 40.3309 38.2674 40.4938 37.5 40.5C34.1906 40.5 31.5 37.4719 31.5 33.75C31.5 30.0281 34.1906 27 37.5 27C38.6026 27.0037 39.6788 27.3374 40.59 27.9581C40.9199 28.1819 41.1475 28.5276 41.2226 28.9191C41.2976 29.3107 41.2141 29.716 40.9903 30.0459C40.7665 30.3759 40.4209 30.6034 40.0293 30.6785C39.6378 30.7536 39.2324 30.67 38.9025 30.4463C38.4911 30.1587 38.0019 30.0031 37.5 30C35.8463 30 34.5 31.6875 34.5 33.75C34.5 35.8125 35.8463 37.5 37.5 37.5C38.0415 37.494 38.567 37.3153 39 36.99V36C38.6022 36 38.2206 35.842 37.9393 35.5607C37.658 35.2794 37.5 34.8978 37.5 34.5C37.5 34.1022 37.658 33.7206 37.9393 33.4393C38.2206 33.158 38.6022 33 39 33H40.5C40.8978 33 41.2794 33.158 41.5607 33.4393C41.842 33.7206 42 34.1022 42 34.5V37.6631ZM29.25 28.5V39C29.25 39.3179 29.1491 39.6276 28.9617 39.8844C28.7744 40.1412 28.5102 40.3318 28.2075 40.4288C28.0597 40.4763 27.9053 40.5004 27.75 40.5C27.5112 40.5 27.2759 40.443 27.0636 40.3338C26.8513 40.2245 26.6682 40.0662 26.5294 39.8719L21.75 33.1875V39C21.75 39.3978 21.592 39.7794 21.3107 40.0607C21.0294 40.342 20.6478 40.5 20.25 40.5C19.8522 40.5 19.4706 40.342 19.1893 40.0607C18.908 39.7794 18.75 39.3978 18.75 39V28.5C18.75 28.1822 18.8509 27.8726 19.0382 27.6158C19.2256 27.3591 19.4896 27.1685 19.7922 27.0715C20.0949 26.9745 20.4205 26.9762 20.7222 27.0762C21.0238 27.1762 21.2859 27.3695 21.4706 27.6281L26.25 34.3125V28.5C26.25 28.1022 26.408 27.7206 26.6893 27.4393C26.9706 27.158 27.3522 27 27.75 27C28.1478 27 28.5294 27.158 28.8107 27.4393C29.092 27.7206 29.25 28.1022 29.25 28.5ZM9 22.5C9.39782 22.5 9.77936 22.342 10.0607 22.0607C10.342 21.7794 10.5 21.3978 10.5 21V7.5H27V16.5C27 16.8978 27.158 17.2794 27.4393 17.5607C27.7206 17.842 28.1022 18 28.5 18H37.5V21C37.5 21.3978 37.658 21.7794 37.9393 22.0607C38.2206 22.342 38.6022 22.5 39 22.5C39.3978 22.5 39.7794 22.342 40.0607 22.0607C40.342 21.7794 40.5 21.3978 40.5 21V16.5C40.5002 16.303 40.4615 16.1078 40.3862 15.9257C40.3109 15.7436 40.2005 15.5782 40.0612 15.4388L29.5613 4.93875C29.4218 4.7995 29.2564 4.68908 29.0743 4.6138C28.8922 4.53851 28.697 4.49985 28.5 4.5H10.5C9.70435 4.5 8.94129 4.81607 8.37868 5.37868C7.81607 5.94129 7.5 6.70435 7.5 7.5V21C7.5 21.3978 7.65804 21.7794 7.93934 22.0607C8.22064 22.342 8.60218 22.5 9 22.5ZM30 9.62063L35.3794 15H30V9.62063Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/icons/Mp4Icon.tsx\n\nvar Mp4Icon = function Mp4Icon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M42 28.5C42 28.8978 41.842 29.2794 41.5607 29.5607C41.2794 29.842 40.8978 30 40.5 30H36V33H39C39.3978 33 39.7794 33.158 40.0607 33.4393C40.342 33.7206 40.5 34.1022 40.5 34.5C40.5 34.8978 40.342 35.2794 40.0607 35.5607C39.7794 35.842 39.3978 36 39 36H36V39C36 39.3978 35.842 39.7794 35.5607 40.0607C35.2794 40.342 34.8978 40.5 34.5 40.5C34.1022 40.5 33.7206 40.342 33.4393 40.0607C33.158 39.7794 33 39.3978 33 39V28.5C33 28.1022 33.158 27.7206 33.4393 27.4393C33.7206 27.158 34.1022 27 34.5 27H40.5C40.8978 27 41.2794 27.158 41.5607 27.4393C41.842 27.7206 42 28.1022 42 28.5ZM17.25 32.25C17.25 33.6424 16.6969 34.9777 15.7123 35.9623C14.7277 36.9469 13.3924 37.5 12 37.5H10.5V39C10.5 39.3978 10.342 39.7794 10.0607 40.0607C9.77936 40.342 9.39782 40.5 9 40.5C8.60218 40.5 8.22064 40.342 7.93934 40.0607C7.65804 39.7794 7.5 39.3978 7.5 39V28.5C7.5 28.1022 7.65804 27.7206 7.93934 27.4393C8.22064 27.158 8.60218 27 9 27H12C13.3924 27 14.7277 27.5531 15.7123 28.5377C16.6969 29.5223 17.25 30.8576 17.25 32.25ZM14.25 32.25C14.25 31.6533 14.0129 31.081 13.591 30.659C13.169 30.2371 12.5967 30 12 30H10.5V34.5H12C12.5967 34.5 13.169 34.2629 13.591 33.841C14.0129 33.419 14.25 32.8467 14.25 32.25ZM30.75 33.75C30.75 35.5402 30.0388 37.2571 28.773 38.523C27.5071 39.7888 25.7902 40.5 24 40.5H21C20.6022 40.5 20.2206 40.342 19.9393 40.0607C19.658 39.7794 19.5 39.3978 19.5 39V28.5C19.5 28.1022 19.658 27.7206 19.9393 27.4393C20.2206 27.158 20.6022 27 21 27H24C25.7902 27 27.5071 27.7112 28.773 28.977C30.0388 30.2429 30.75 31.9598 30.75 33.75ZM27.75 33.75C27.75 32.7554 27.3549 31.8016 26.6516 31.0984C25.9484 30.3951 24.9946 30 24 30H22.5V37.5H24C24.9946 37.5 25.9484 37.1049 26.6516 36.4016C27.3549 35.6984 27.75 34.7446 27.75 33.75ZM7.5 21V7.5C7.5 6.70435 7.81607 5.94129 8.37868 5.37868C8.94129 4.81607 9.70435 4.5 10.5 4.5H28.5C28.697 4.49985 28.8922 4.53851 29.0743 4.6138C29.2564 4.68908 29.4218 4.7995 29.5613 4.93875L40.0612 15.4388C40.2005 15.5782 40.3109 15.7436 40.3862 15.9257C40.4615 16.1078 40.5002 16.303 40.5 16.5V21C40.5 21.3978 40.342 21.7794 40.0607 22.0607C39.7794 22.342 39.3978 22.5 39 22.5C38.6022 22.5 38.2206 22.342 37.9393 22.0607C37.658 21.7794 37.5 21.3978 37.5 21V18H28.5C28.1022 18 27.7206 17.842 27.4393 17.5607C27.158 17.2794 27 16.8978 27 16.5V7.5H10.5V21C10.5 21.3978 10.342 21.7794 10.0607 22.0607C9.77936 22.342 9.39782 22.5 9 22.5C8.60218 22.5 8.22064 22.342 7.93934 22.0607C7.65804 21.7794 7.5 21.3978 7.5 21ZM30 15H35.3794L30 9.62063V15Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/components/uploader/file-list.tsx\n"use client";\n\n\n\n\n\n\n\n\n\n\n\n\nfunction FileList() {\n  var _useFileUpload = useFileUpload(),\n    file = _useFileUpload.file,\n    removeFile = _useFileUpload.removeFile;\n  var _useTxPreparation = useTxPreparation(),\n    fileProgress = _useTxPreparation.fileProgress,\n    isProcessing = _useTxPreparation.isProcessing,\n    currentStep = _useTxPreparation.currentStep;\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation;\n  if (!file) return null;\n\n  // Como solo se admite un archivo, se usa el primer elemento de fileProgress (si existe)\n  var progress = fileProgress[0];\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "flex flex-col gap-4",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement(AnimatePresence, null, /*#__PURE__*/react.createElement(motion.div, {\n    key: file.name,\n    className: "flex flex-col gap-2 p-4 bg-white/5 rounded-lg",\n    initial: {\n      opacity: 0,\n      y: 20\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    exit: {\n      opacity: 0,\n      x: -20\n    },\n    transition: {\n      duration: 0.3\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center justify-between"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center gap-4"\n  }, file.preview ? /*#__PURE__*/react.createElement("img", {\n    src: file.preview,\n    alt: "Preview",\n    className: "w-10 h-10 rounded object-cover"\n  }) : /*#__PURE__*/react.createElement("div", {\n    className: "w-10 h-10 flex items-center justify-center"\n  }, file.type === "application/pdf" ? /*#__PURE__*/react.createElement(PdfIcon, {\n    className: "w-full h-full text-white"\n  }) : file.type === "image/png" ? /*#__PURE__*/react.createElement(PngIcon, {\n    className: "w-full h-full text-white"\n  }) : file.type === "image/pdg" ? /*#__PURE__*/react.createElement(PdgIcon, {\n    className: "w-full h-full text-white"\n  }) : file.type === "video/mp4" ? /*#__PURE__*/react.createElement(Mp4Icon, {\n    className: "w-full h-full text-white"\n  }) : /*#__PURE__*/react.createElement("span", {\n    className: "text-xs text-white"\n  }, file.type.split("/")[1].toUpperCase())), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", {\n    className: "font-medium !text-white"\n  }, file.name), /*#__PURE__*/react.createElement("p", {\n    className: "text-sm !text-white/80"\n  }, (file.size / 1024 / 1024).toFixed(2), " MB"))), /*#__PURE__*/react.createElement(Button, {\n    variant: "icon",\n    onClick: removeFile,\n    className: "text-white hover:bg-white/10",\n    disabled: preparation.currentStep != "prepare/construct"\n  }, /*#__PURE__*/react.createElement(CloseIcon, {\n    className: "w-6 h-6"\n  }))), isProcessing && currentStep === "prepare/construct" && progress && /*#__PURE__*/react.createElement("div", {\n    className: "space-y-1"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "h-1 bg-white/10 rounded-full overflow-hidden"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "h-full bg-primary-tw",\n    initial: {\n      width: 0\n    },\n    animate: {\n      width: "".concat(progress.progress, "%")\n    },\n    transition: {\n      duration: 0.5\n    }\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "text-xs text-white/60"\n  }, progress.status === "constructing" ? "Constructing transaction..." : progress.status === "unsigned" ? "Retrieving unsigned transaction..." : "Processing...")))));\n}\n;// ./src/components/uploader/delegate-view.tsx\n"use client";\n\n\n\n\nfunction DelegateView(_ref) {\n  var text = _ref.text,\n    setText = _ref.setText,\n    isProcessing = _ref.isProcessing;\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation;\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "space-y-4",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    transition: {\n      duration: 0.3\n    }\n  }, /*#__PURE__*/react.createElement("textarea", {\n    value: text,\n    onChange: function onChange(e) {\n      return setText(e.target.value);\n    },\n    placeholder: "Enter your text here...",\n    className: "w-full h-48 p-4 bg-white/5 rounded-xl text-white placeholder:text-white/40 focus:outline-none focus:ring-2 focus:ring-[#447BF4]",\n    disabled: preparation.currentStep != "prepare/construct"\n  }));\n}\n;// ./src/context/TxInscriptionContext.tsx\n"use client";\n\nfunction TxInscriptionContext_typeof(o) { "@babel/helpers - typeof"; return TxInscriptionContext_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, TxInscriptionContext_typeof(o); }\nfunction TxInscriptionContext_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction TxInscriptionContext_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TxInscriptionContext_ownKeys(Object(t), !0).forEach(function (r) { TxInscriptionContext_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TxInscriptionContext_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction TxInscriptionContext_defineProperty(e, r, t) { return (r = TxInscriptionContext_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction TxInscriptionContext_toPropertyKey(t) { var i = TxInscriptionContext_toPrimitive(t, "string"); return "symbol" == TxInscriptionContext_typeof(i) ? i : i + ""; }\nfunction TxInscriptionContext_toPrimitive(t, r) { if ("object" != TxInscriptionContext_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != TxInscriptionContext_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction TxInscriptionContext_slicedToArray(r, e) { return TxInscriptionContext_arrayWithHoles(r) || TxInscriptionContext_iterableToArrayLimit(r, e) || TxInscriptionContext_unsupportedIterableToArray(r, e) || TxInscriptionContext_nonIterableRest(); }\nfunction TxInscriptionContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction TxInscriptionContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TxInscriptionContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TxInscriptionContext_arrayLikeToArray(r, a) : void 0; } }\nfunction TxInscriptionContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TxInscriptionContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction TxInscriptionContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction TxInscriptionContext_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ TxInscriptionContext_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == TxInscriptionContext_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(TxInscriptionContext_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction TxInscriptionContext_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction TxInscriptionContext_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { TxInscriptionContext_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { TxInscriptionContext_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\n\n\n\n\nvar TxInscriptionContext = /*#__PURE__*/(0,react.createContext)({\n  fileProgress: [],\n  inscribeFiles: function () {\n    var _inscribeFiles = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee() {\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    function inscribeFiles() {\n      return _inscribeFiles.apply(this, arguments);\n    }\n    return inscribeFiles;\n  }(),\n  inscribeText: function () {\n    var _inscribeText = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee2() {\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    function inscribeText() {\n      return _inscribeText.apply(this, arguments);\n    }\n    return inscribeText;\n  }(),\n  signAndSubmit: function () {\n    var _signAndSubmit = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee3() {\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    function signAndSubmit() {\n      return _signAndSubmit.apply(this, arguments);\n    }\n    return signAndSubmit;\n  }(),\n  isProcessing: false,\n  currentStep: "inscription/construct",\n  nextStep: null,\n  error: null,\n  clearError: function clearError() {},\n  reset: function reset() {},\n  submissionStatus: undefined,\n  unsignedTx: undefined,\n  setUnsignedTx: function setUnsignedTx() {}\n});\nfunction useTxInscription() {\n  var context = (0,react.useContext)(TxInscriptionContext);\n  if (!context) {\n    throw new Error("useTxInscription must be used within a TxInscriptionProvider");\n  }\n  return context;\n}\nfunction TxInscriptionProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)([]),\n    _useState2 = TxInscriptionContext_slicedToArray(_useState, 2),\n    fileProgress = _useState2[0],\n    setFileProgress = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = TxInscriptionContext_slicedToArray(_useState3, 2),\n    isProcessing = _useState4[0],\n    setIsProcessing = _useState4[1];\n  var _useState5 = (0,react.useState)(null),\n    _useState6 = TxInscriptionContext_slicedToArray(_useState5, 2),\n    error = _useState6[0],\n    setError = _useState6[1];\n  var _useState7 = (0,react.useState)(),\n    _useState8 = TxInscriptionContext_slicedToArray(_useState7, 2),\n    submissionStatus = _useState8[0],\n    setSubmissionStatus = _useState8[1];\n  var _useState9 = (0,react.useState)(),\n    _useState10 = TxInscriptionContext_slicedToArray(_useState9, 2),\n    unsignedTx = _useState10[0],\n    setUnsignedTx = _useState10[1];\n  var _useWallet = useWallet(),\n    getWalletApi = _useWallet.getWalletApi,\n    defaultWallet = _useWallet.defaultWallet;\n  var _useTxStatus = useTxStatus(),\n    inscription = _useTxStatus.inscription,\n    moveToNextStep = _useTxStatus.moveToNextStep;\n  var updateFileProgress = (0,react.useCallback)(function (index, updates) {\n    setFileProgress(function (prev) {\n      return prev.map(function (item, i) {\n        return i === index ? TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, item), updates) : item;\n      });\n    });\n  }, []);\n  var clearError = (0,react.useCallback)(function () {\n    setError(null);\n  }, []);\n  var reset = (0,react.useCallback)(function () {\n    setFileProgress([]);\n    setIsProcessing(false);\n    setSubmissionStatus(undefined);\n    setUnsignedTx(undefined);\n    setError(null);\n  }, []);\n  var constructInscriptionTx = /*#__PURE__*/function () {\n    var _ref2 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee4(api, data, dataType) {\n      var rewardAddresses, utxos, targetAddress, body, response, errorData, errorResponse, constructedTx;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return api.getRewardAddresses();\n          case 2:\n            rewardAddresses = _context4.sent;\n            _context4.next = 5;\n            return api.getUtxos();\n          case 5:\n            _context4.t0 = _context4.sent;\n            if (_context4.t0) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.t0 = [];\n          case 8:\n            utxos = _context4.t0;\n            console.log("UTXOs:", utxos);\n            _context4.next = 12;\n            return api.getUsedAddresses();\n          case 12:\n            targetAddress = _context4.sent[0];\n            if (!(!utxos || utxos.length === 0)) {\n              _context4.next = 16;\n              break;\n            }\n            setError("No hay UTXOs disponibles");\n            throw new Error("No UTXOs available");\n          case 16:\n            body = {\n              payload: data,\n              payloadType: dataType,\n              rewardAddresses: rewardAddresses,\n              changeAddress: targetAddress,\n              utxos: utxos,\n              mintTokenForPayload: "NoMinting"\n            };\n            console.log("Body:", body);\n            _context4.next = 20;\n            return fetch(buildApiUrl("/inscriptions/construct-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(body)\n            });\n          case 20:\n            response = _context4.sent;\n            if (response.ok) {\n              _context4.next = 35;\n              break;\n            }\n            _context4.prev = 22;\n            errorResponse = response.clone();\n            _context4.next = 26;\n            return errorResponse.json();\n          case 26:\n            errorData = _context4.sent;\n            _context4.next = 34;\n            break;\n          case 29:\n            _context4.prev = 29;\n            _context4.t1 = _context4["catch"](22);\n            _context4.next = 33;\n            return response.text();\n          case 33:\n            errorData = _context4.sent;\n          case 34:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/inscriptions/construct-tx"\n            }));\n          case 35:\n            // Avanzamos en el flujo de inscripcin\n            moveToNextStep("inscription");\n            _context4.next = 38;\n            return response.json();\n          case 38:\n            constructedTx = _context4.sent;\n            console.log("Constructed TX:", constructedTx);\n            setIsProcessing(false);\n            return _context4.abrupt("return", constructedTx);\n          case 42:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[22, 29]]);\n    }));\n    return function constructInscriptionTx(_x, _x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var inscribeFiles = /*#__PURE__*/function () {\n    var _ref3 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee5(files) {\n      var api, _loop, i;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee5$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            if (defaultWallet) {\n              _context6.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context6.prev = 4;\n            setFileProgress(files.map(function (file) {\n              return {\n                file: file,\n                status: "pending",\n                progress: 0\n              };\n            }));\n            _loop = /*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _loop(i) {\n              var reader, fileAsBase64, base64Content, constructedTx;\n              return TxInscriptionContext_regeneratorRuntime().wrap(function _loop$(_context5) {\n                while (1) switch (_context5.prev = _context5.next) {\n                  case 0:\n                    updateFileProgress(i, {\n                      status: "constructing",\n                      progress: 25\n                    });\n                    reader = new FileReader();\n                    _context5.next = 4;\n                    return new Promise(function (resolve, reject) {\n                      reader.onload = function () {\n                        return resolve(reader.result);\n                      };\n                      reader.onerror = reject;\n                      reader.readAsDataURL(files[i]);\n                    });\n                  case 4:\n                    fileAsBase64 = _context5.sent;\n                    base64Content = fileAsBase64.split(",")[1];\n                    _context5.next = 8;\n                    return constructInscriptionTx(api, base64Content, files[i].type);\n                  case 8:\n                    constructedTx = _context5.sent;\n                    updateFileProgress(i, {\n                      status: "unsigned",\n                      progress: 50,\n                      txInfo: {\n                        constructedTx: constructedTx\n                      }\n                    });\n                  case 10:\n                  case "end":\n                    return _context5.stop();\n                }\n              }, _loop);\n            });\n            i = 0;\n          case 8:\n            if (!(i < files.length)) {\n              _context6.next = 13;\n              break;\n            }\n            return _context6.delegateYield(_loop(i), "t0", 10);\n          case 10:\n            i++;\n            _context6.next = 8;\n            break;\n          case 13:\n            moveToNextStep("inscription");\n            _context6.next = 21;\n            break;\n          case 16:\n            _context6.prev = 16;\n            _context6.t1 = _context6["catch"](4);\n            console.error("Error inscribing files:", _context6.t1);\n            setError(_context6.t1 instanceof Error ? _context6.t1.message : JSON.stringify(_context6.t1));\n            setIsProcessing(false);\n          case 21:\n          case "end":\n            return _context6.stop();\n        }\n      }, _callee5, null, [[4, 16]]);\n    }));\n    return function inscribeFiles(_x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var inscribeText = /*#__PURE__*/function () {\n    var _ref4 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee6(text) {\n      var api, textFile, base64Content, constructedTx;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee6$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (defaultWallet) {\n              _context7.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context7.prev = 4;\n            textFile = new File([text], "inscription.txt", {\n              type: "text/plain"\n            });\n            setFileProgress([{\n              file: textFile,\n              status: "pending",\n              progress: 0\n            }]);\n            updateFileProgress(0, {\n              status: "constructing",\n              progress: 25\n            });\n            console.log("text", text);\n            base64Content = btoa(unescape(encodeURIComponent(text)));\n            console.log("base64Content", base64Content);\n            _context7.next = 13;\n            return constructInscriptionTx(api, base64Content, "text/plain");\n          case 13:\n            constructedTx = _context7.sent;\n            console.log("constructedTx", constructedTx);\n            updateFileProgress(0, {\n              status: "unsigned",\n              progress: 50,\n              txInfo: {\n                constructedTx: constructedTx\n              }\n            });\n            moveToNextStep("inscription");\n            _context7.next = 24;\n            break;\n          case 19:\n            _context7.prev = 19;\n            _context7.t0 = _context7["catch"](4);\n            console.error("Error inscribing text:", _context7.t0);\n            setError(_context7.t0 instanceof Error ? _context7.t0.message : JSON.stringify(_context7.t0));\n            setIsProcessing(false);\n          case 24:\n            _context7.prev = 24;\n            setIsProcessing(false);\n            return _context7.finish(24);\n          case 27:\n          case "end":\n            return _context7.stop();\n        }\n      }, _callee6, null, [[4, 19, 24, 27]]);\n    }));\n    return function inscribeText(_x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var pollForConfirmation = /*#__PURE__*/function () {\n    var _ref5 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee7(preparedTx) {\n      var retryInterval, response, errorData, errorResponse, status, responseText, errorMessage, _errorMessage, parsedError;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee7$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            retryInterval = 9000;\n            setIsProcessing(true);\n          case 2:\n            if (false) {}\n            _context8.prev = 3;\n            _context8.next = 6;\n            return fetch(buildApiUrl("/inscriptions/retrieve-submission-status"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(preparedTx.executionArn)\n            });\n          case 6:\n            response = _context8.sent;\n            if (response.ok) {\n              _context8.next = 22;\n              break;\n            }\n            errorData = void 0;\n            _context8.prev = 9;\n            errorResponse = response.clone();\n            _context8.next = 13;\n            return errorResponse.json();\n          case 13:\n            errorData = _context8.sent;\n            _context8.next = 21;\n            break;\n          case 16:\n            _context8.prev = 16;\n            _context8.t0 = _context8["catch"](9);\n            _context8.next = 20;\n            return response.text();\n          case 20:\n            errorData = _context8.sent;\n          case 21:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/inscriptions/retrieve-submission-status"\n            }));\n          case 22:\n            // Parse the response carefully to handle potential JSON decoding errors\n            status = void 0;\n            _context8.prev = 23;\n            _context8.next = 26;\n            return response.text();\n          case 26:\n            responseText = _context8.sent;\n            if (!(responseText.includes("States.Timeout") || responseText.includes("JsonDecodeError"))) {\n              _context8.next = 33;\n              break;\n            }\n            console.error("Timeout or JSON decode error detected:", responseText);\n            errorMessage = "Transaction processing timed out or encountered a decoding error. Please try again later.";\n            setError(errorMessage);\n            setIsProcessing(false);\n            return _context8.abrupt("return", false);\n          case 33:\n            status = JSON.parse(responseText);\n            _context8.next = 40;\n            break;\n          case 36:\n            _context8.prev = 36;\n            _context8.t1 = _context8["catch"](23);\n            console.error("Error parsing response:", _context8.t1);\n            throw new Error(JSON.stringify({\n              message: "Failed to parse submission status response",\n              error: _context8.t1 instanceof Error ? _context8.t1.message : String(_context8.t1),\n              endpoint: "/inscriptions/retrieve-submission-status"\n            }));\n          case 40:\n            if (!(status.success && status.success.onchain)) {\n              _context8.next = 46;\n              break;\n            }\n            setSubmissionStatus(status);\n            setIsProcessing(false);\n            moveToNextStep("inscription");\n            console.log("Transaction retrieved:", status);\n            return _context8.abrupt("return", true);\n          case 46:\n            if (!status.inProgress) {\n              _context8.next = 50;\n              break;\n            }\n            console.log("Transaction still in progress...");\n            _context8.next = 51;\n            break;\n          case 50:\n            throw new Error(JSON.stringify({\n              message: "Unexpected submission status response",\n              status: status,\n              endpoint: "/inscriptions/retrieve-submission-status"\n            }));\n          case 51:\n            _context8.next = 53;\n            return new Promise(function (res) {\n              return setTimeout(res, retryInterval);\n            });\n          case 53:\n            _context8.next = 64;\n            break;\n          case 55:\n            _context8.prev = 55;\n            _context8.t2 = _context8["catch"](3);\n            console.error("Polling attempt failed:", _context8.t2);\n\n            // Format the error message for better readability\n            _errorMessage = void 0;\n            if (_context8.t2 instanceof Error) {\n              try {\n                // Try to parse the error message as JSON for better formatting\n                parsedError = JSON.parse(_context8.t2.message);\n                if (parsedError.error && TxInscriptionContext_typeof(parsedError.error) === "object") {\n                  // Handle the specific JsonDecodeError case\n                  if (parsedError.error.message && parsedError.error.message.includes(\'key "onchain" not found\')) {\n                    _errorMessage = "Transaction processing error: The transaction data is incomplete. Please try again later.";\n                  } else {\n                    _errorMessage = "Error: ".concat(JSON.stringify(parsedError.error, null, 2));\n                  }\n                } else {\n                  _errorMessage = _context8.t2.message;\n                }\n              } catch (e) {\n                // If parsing fails, use the original error message\n                _errorMessage = _context8.t2.message;\n              }\n            } else {\n              _errorMessage = JSON.stringify(_context8.t2);\n            }\n            setError(_errorMessage);\n            setIsProcessing(false);\n\n            // Update file progress to failed\n            setFileProgress(function (prev) {\n              return prev.map(function (file) {\n                return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n                  status: "failed",\n                  progress: 0\n                });\n              });\n            });\n            return _context8.abrupt("return", false);\n          case 64:\n            _context8.next = 2;\n            break;\n          case 66:\n          case "end":\n            return _context8.stop();\n        }\n      }, _callee7, null, [[3, 55], [9, 16], [23, 36]]);\n    }));\n    return function pollForConfirmation(_x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitError = function handleSignAndSubmitError(error) {\n    console.error("Error in sign and submit for inscription:", error);\n\n    // Format the error message based on the error type\n    var errorMessage;\n\n    // Handle TxSignError from wallet\n    if (error && error.name === "TxSignError") {\n      errorMessage = "Wallet signing error: ".concat(error.info || error.message || "Failed to sign transaction");\n      // No actualizamos el estado de los archivos aqu ya que lo hacemos en el catch del sign\n      // Solo limpiamos el error y permitimos reintentar\n      setError(errorMessage);\n      setIsProcessing(false);\n      console.log("Wallet signing error detected, keeping current step for retry");\n    }\n    // Handle Error objects\n    else if (error instanceof Error) {\n      try {\n        var _parsedError$error;\n        // Try to parse the error message as JSON\n        var parsedError = JSON.parse(error.message);\n        errorMessage = ((_parsedError$error = parsedError.error) === null || _parsedError$error === void 0 ? void 0 : _parsedError$error.message) || parsedError.message || error.message;\n      } catch (e) {\n        // If parsing fails, use the original error message\n        errorMessage = error.message || "Unknown error occurred";\n      }\n      setError(errorMessage);\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n      setIsProcessing(false);\n      // For other errors, reset to the beginning\n      console.log("Other error detected, moving to end: ", error);\n      moveToNextStep("end");\n    }\n    // Handle other error types\n    else {\n      try {\n        errorMessage = JSON.stringify(error);\n      } catch (e) {\n        errorMessage = "Unknown error occurred";\n      }\n      setError(errorMessage);\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n      setIsProcessing(false);\n      // For other errors, reset to the beginning\n      console.log("Other error detected, moving to end: ", error);\n      moveToNextStep("end");\n    }\n  };\n  var signAndSubmit = /*#__PURE__*/function () {\n    var _ref6 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee9() {\n      var api, _loop2, i;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee9$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            if (defaultWallet) {\n              _context11.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context11.prev = 4;\n            _loop2 = /*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _loop2(i) {\n              var _file$txInfo;\n              var file, executionArn, unsignedTx, unsignedTxResponse, errorData, errorResponse, signedTx, _api, signedShardTxs, inscribeSubmitBody, submitResponse, _errorData, _errorResponse, submittedTx, confirmed;\n              return TxInscriptionContext_regeneratorRuntime().wrap(function _loop2$(_context10) {\n                while (1) switch (_context10.prev = _context10.next) {\n                  case 0:\n                    file = fileProgress[i];\n                    if ((_file$txInfo = file.txInfo) !== null && _file$txInfo !== void 0 && _file$txInfo.constructedTx) {\n                      _context10.next = 3;\n                      break;\n                    }\n                    return _context10.abrupt("return", 1);\n                  case 3:\n                    executionArn = file.txInfo.constructedTx.executionArn;\n                    console.log("executionArn", executionArn);\n\n                    // Solo obtener unsignedTx si no lo tenemos ya\n                    unsignedTx = file.txInfo.unsignedTx;\n                    if (unsignedTx) {\n                      _context10.next = 45;\n                      break;\n                    }\n                  case 7:\n                    if (false) {}\n                    _context10.next = 10;\n                    return fetch(buildApiUrl("/inscriptions/retrieve-unsigned-tx"), {\n                      method: "POST",\n                      headers: {\n                        "Content-Type": "application/json",\n                        "x-api-key": API_KEY || ""\n                      },\n                      body: JSON.stringify(executionArn)\n                    });\n                  case 10:\n                    unsignedTxResponse = _context10.sent;\n                    if (unsignedTxResponse.ok) {\n                      _context10.next = 26;\n                      break;\n                    }\n                    errorData = void 0;\n                    _context10.prev = 13;\n                    errorResponse = unsignedTxResponse.clone();\n                    _context10.next = 17;\n                    return errorResponse.json();\n                  case 17:\n                    errorData = _context10.sent;\n                    _context10.next = 25;\n                    break;\n                  case 20:\n                    _context10.prev = 20;\n                    _context10.t0 = _context10["catch"](13);\n                    _context10.next = 24;\n                    return unsignedTxResponse.text();\n                  case 24:\n                    errorData = _context10.sent;\n                  case 25:\n                    throw new Error(JSON.stringify({\n                      status: unsignedTxResponse.status,\n                      statusText: unsignedTxResponse.statusText,\n                      error: errorData,\n                      endpoint: "/inscriptions/retrieve-unsigned-tx"\n                    }));\n                  case 26:\n                    _context10.next = 28;\n                    return unsignedTxResponse.json();\n                  case 28:\n                    unsignedTx = _context10.sent;\n                    console.log("Unsigned TX:", unsignedTx);\n                    if (!(unsignedTx.success && unsignedTx.success.indexingTx)) {\n                      _context10.next = 36;\n                      break;\n                    }\n                    console.log("Unsigned transaction retrieved:", unsignedTx);\n                    setUnsignedTx(unsignedTx);\n                    moveToNextStep("inscription");\n                    setIsProcessing(false);\n                    return _context10.abrupt("break", 45);\n                  case 36:\n                    if (!unsignedTx.inProgress) {\n                      _context10.next = 42;\n                      break;\n                    }\n                    console.log("Unsigned transaction still in progress...");\n                    _context10.next = 40;\n                    return new Promise(function (res) {\n                      return setTimeout(res, 5000);\n                    });\n                  case 40:\n                    _context10.next = 43;\n                    break;\n                  case 42:\n                    throw new Error(JSON.stringify({\n                      message: "Unexpected response while retrieving unsigned transaction",\n                      response: unsignedTx,\n                      endpoint: "/inscriptions/retrieve-unsigned-tx"\n                    }));\n                  case 43:\n                    _context10.next = 7;\n                    break;\n                  case 45:\n                    updateFileProgress(i, {\n                      progress: 75,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx\n                      })\n                    });\n                    _context10.prev = 46;\n                    // Clear any previous error state before attempting to sign again\n                    clearError();\n\n                    // Get a fresh wallet API instance to ensure the popup appears again\n                    _api = getWalletApi(defaultWallet);\n                    _context10.next = 51;\n                    return _api.signTx(base64ToHex(unsignedTx.success.indexingTx));\n                  case 51:\n                    signedTx = _context10.sent;\n                    console.log("Signed TX:", signedTx);\n                    updateFileProgress(i, {\n                      status: "signed",\n                      progress: 85,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx,\n                        signedTx: signedTx\n                      })\n                    });\n                    moveToNextStep("inscription");\n                    _context10.next = 66;\n                    break;\n                  case 57:\n                    _context10.prev = 57;\n                    _context10.t1 = _context10["catch"](46);\n                    console.error("Error signing transaction:", _context10.t1);\n                    // Don\'t move to the next step if there\'s a signing error\n                    // This allows the user to retry signing from the same step\n                    if (!(_context10.t1 && _context10.t1.name === "TxSignError")) {\n                      _context10.next = 65;\n                      break;\n                    }\n                    // Mantener el estado actual y permitir reintentar\n                    setFileProgress(function (prev) {\n                      return prev.map(function (item, idx) {\n                        return idx === i ? TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, item), {}, {\n                          status: "unsigned",\n                          progress: 75,\n                          error: _context10.t1.message\n                        }) : item;\n                      });\n                    });\n                    throw _context10.t1;\n                  case 65:\n                    throw new Error("Failed to sign transaction: ".concat(_context10.t1.message || JSON.stringify(_context10.t1)));\n                  case 66:\n                    _context10.next = 68;\n                    return Promise.all(unsignedTx.success.shardTxs.map(/*#__PURE__*/function () {\n                      var _ref7 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee8(shardTx) {\n                        var hexShardTx, _api2;\n                        return TxInscriptionContext_regeneratorRuntime().wrap(function _callee8$(_context9) {\n                          while (1) switch (_context9.prev = _context9.next) {\n                            case 0:\n                              hexShardTx = base64ToHex(shardTx);\n                              console.log("Hex Shard TX:", hexShardTx);\n                              _context9.prev = 2;\n                              // Get a fresh wallet API instance for each shard transaction\n                              _api2 = getWalletApi(defaultWallet);\n                              _context9.next = 6;\n                              return _api2.signTx(hexShardTx);\n                            case 6:\n                              return _context9.abrupt("return", _context9.sent);\n                            case 9:\n                              _context9.prev = 9;\n                              _context9.t0 = _context9["catch"](2);\n                              console.error("Error signing shard transaction:", _context9.t0);\n                              // Mantener el estado actual y permitir reintentar\n                              if (!(_context9.t0 && _context9.t0.name === "TxSignError")) {\n                                _context9.next = 17;\n                                break;\n                              }\n                              setFileProgress(function (prev) {\n                                return prev.map(function (item, idx) {\n                                  return idx === i ? TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, item), {}, {\n                                    status: "unsigned",\n                                    progress: 75,\n                                    error: _context9.t0.message\n                                  }) : item;\n                                });\n                              });\n                              throw _context9.t0;\n                            case 17:\n                              throw new Error("Failed to sign shard transaction: ".concat(_context9.t0.message || JSON.stringify(_context9.t0)));\n                            case 18:\n                            case "end":\n                              return _context9.stop();\n                          }\n                        }, _callee8, null, [[2, 9]]);\n                      }));\n                      return function (_x7) {\n                        return _ref7.apply(this, arguments);\n                      };\n                    }()));\n                  case 68:\n                    signedShardTxs = _context10.sent;\n                    console.log("Signed Shard TXs:", signedShardTxs);\n                    updateFileProgress(i, {\n                      status: "signed",\n                      progress: 90,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx,\n                        signedTx: signedTx\n                      })\n                    });\n                    // Move to the next step after successful signing of all transactions\n                    moveToNextStep("inscription");\n                    inscribeSubmitBody = {\n                      indexingTxToSubmit: [unsignedTx.success.indexingTx, signedTx],\n                      txsToSubmit: unsignedTx.success.shardTxs.map(function (shardTx, index) {\n                        return [shardTx, signedShardTxs[index]];\n                      }),\n                      ulidOfObject: unsignedTx.success.objectUlid\n                    };\n                    console.log("Inscribe submit body:", inscribeSubmitBody);\n                    _context10.next = 76;\n                    return fetch(buildApiUrl("/inscriptions/submit"), {\n                      method: "POST",\n                      headers: {\n                        "Content-Type": "application/json",\n                        "x-api-key": API_KEY || ""\n                      },\n                      body: JSON.stringify(inscribeSubmitBody)\n                    });\n                  case 76:\n                    submitResponse = _context10.sent;\n                    if (submitResponse.ok) {\n                      _context10.next = 91;\n                      break;\n                    }\n                    _context10.prev = 78;\n                    _errorResponse = submitResponse.clone();\n                    _context10.next = 82;\n                    return _errorResponse.json();\n                  case 82:\n                    _errorData = _context10.sent;\n                    _context10.next = 90;\n                    break;\n                  case 85:\n                    _context10.prev = 85;\n                    _context10.t2 = _context10["catch"](78);\n                    _context10.next = 89;\n                    return submitResponse.text();\n                  case 89:\n                    _errorData = _context10.sent;\n                  case 90:\n                    throw new Error(JSON.stringify({\n                      status: submitResponse.status,\n                      statusText: submitResponse.statusText,\n                      error: _errorData,\n                      endpoint: "/inscriptions/submit"\n                    }));\n                  case 91:\n                    _context10.next = 93;\n                    return submitResponse.json();\n                  case 93:\n                    submittedTx = _context10.sent;\n                    console.log("Submitted TX:", submittedTx);\n                    // Move to the next step after successful submission\n                    moveToNextStep("inscription");\n                    updateFileProgress(i, {\n                      status: "submitted",\n                      progress: 95,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx,\n                        signedTx: signedTx,\n                        submittedTx: submittedTx\n                      })\n                    });\n                    _context10.next = 99;\n                    return pollForConfirmation(submittedTx);\n                  case 99:\n                    confirmed = _context10.sent;\n                    updateFileProgress(i, {\n                      status: confirmed ? "confirmed" : "failed",\n                      progress: confirmed ? 100 : 0\n                    });\n                    moveToNextStep("inscription");\n                  case 102:\n                  case "end":\n                    return _context10.stop();\n                }\n              }, _loop2, null, [[13, 20], [46, 57], [78, 85]]);\n            });\n            i = 0;\n          case 7:\n            if (!(i < fileProgress.length)) {\n              _context11.next = 14;\n              break;\n            }\n            return _context11.delegateYield(_loop2(i), "t0", 9);\n          case 9:\n            if (!_context11.t0) {\n              _context11.next = 11;\n              break;\n            }\n            return _context11.abrupt("continue", 11);\n          case 11:\n            i++;\n            _context11.next = 7;\n            break;\n          case 14:\n            // Al finalizar, se establece el estado final "end"\n            moveToNextStep("end");\n            setIsProcessing(false);\n            _context11.next = 21;\n            break;\n          case 18:\n            _context11.prev = 18;\n            _context11.t1 = _context11["catch"](4);\n            handleSignAndSubmitError(_context11.t1);\n          case 21:\n          case "end":\n            return _context11.stop();\n        }\n      }, _callee9, null, [[4, 18]]);\n    }));\n    return function signAndSubmit() {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  (0,react.useEffect)(function () {\n    if (error) {\n      console.error("Error occurred:", error);\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n      setIsProcessing(false);\n    }\n  }, [error]);\n  return /*#__PURE__*/react.createElement(TxInscriptionContext.Provider, {\n    value: {\n      fileProgress: fileProgress,\n      inscribeFiles: inscribeFiles,\n      inscribeText: inscribeText,\n      signAndSubmit: signAndSubmit,\n      isProcessing: isProcessing,\n      currentStep: inscription.currentStep,\n      nextStep: inscription.nextStep,\n      error: error,\n      clearError: clearError,\n      reset: reset,\n      submissionStatus: submissionStatus,\n      unsignedTx: unsignedTx,\n      setUnsignedTx: setUnsignedTx\n    }\n  }, children);\n}\n;// ./src/components/ui/LoadingScreen.tsx\n"use client";\n\n\n\nfunction LoadingScreen(_ref) {\n  var _ref$text = _ref.text,\n    text = _ref$text === void 0 ? "Loading..." : _ref$text,\n    _ref$className = _ref.className,\n    className = _ref$className === void 0 ? "" : _ref$className;\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-full h-full  z-50 flex flex-col items-center justify-center rounded-4xl !text-white ".concat(className, " py-8 "),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center gap-6"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-20 h-20",\n    animate: {\n      rotateY: 360\n    },\n    transition: {\n      duration: 2.5,\n      repeat: Number.POSITIVE_INFINITY,\n      ease: "linear" //"easeInOut",\n    }\n  }, /*#__PURE__*/react.createElement("img", {\n    src: "https://cdn.prod.website-files.com/66c3b779674915c288ca9998/66c63fa6307332e239106044_Logo%20(11).png",\n    alt: "Loading spinner",\n    className: "w-full h-full"\n  })), /*#__PURE__*/react.createElement(motion.p, {\n    initial: {\n      opacity: 0,\n      x: -10\n    },\n    animate: {\n      opacity: 1,\n      x: 0\n    },\n    transition: {\n      delay: 0.2\n    },\n    className: "text-[1.25rem] font-medium !text-white"\n  }, text), /*#__PURE__*/react.createElement(motion.p, {\n    initial: {\n      opacity: 0,\n      x: -10\n    },\n    animate: {\n      opacity: 1,\n      x: 0\n    },\n    transition: {\n      delay: 0.2\n    },\n    className: " text-[0.875rem] !text-white"\n  }, "\\xBFHave questions? See our", " ", /*#__PURE__*/react.createElement("a", {\n    className: "underline !text-white",\n    href: "/faq"\n  }, "FAQs"), ".")));\n}\n;// ./src/components/ui/FinishScreen.tsx\n"use client";\n\n\n\n\n\n\n\n\nvar ExplorerLink = function ExplorerLink(_ref) {\n  var txId = _ref.txId;\n  return /*#__PURE__*/react.createElement("a", {\n    href: "https://preprod.cardanoscan.io/transaction/".concat(txId),\n    target: "_blank",\n    rel: "noopener noreferrer",\n    className: "!text-white/80  hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("svg", {\n    className: "w-4 h-4",\n    viewBox: "0 0 24 24",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M12 12V3M12 3L9 6M12 3L15 6",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  })), txId);\n};\nfunction FinishScreen(_ref2) {\n  var _ref2$text = _ref2.text,\n    text = _ref2$text === void 0 ? "Your submissions are now inscribed Onchain." : _ref2$text,\n    _ref2$className = _ref2.className,\n    className = _ref2$className === void 0 ? "" : _ref2$className,\n    setIsPrepared = _ref2.setIsPrepared,\n    setIsInscribed = _ref2.setIsInscribed,\n    setDelegateText = _ref2.setDelegateText,\n    submissionStatus = _ref2.submissionStatus,\n    preparationTxId = _ref2.preparationTxId,\n    unsignedTxId = _ref2.unsignedTxId,\n    indexingTxId = _ref2.indexingTxId,\n    shardTxIds = _ref2.shardTxIds;\n  var _useTxStatus = useTxStatus(),\n    resetStatus = _useTxStatus.resetStatus,\n    setInscriptionStatus = _useTxStatus.setInscriptionStatus,\n    setPreparationStatus = _useTxStatus.setPreparationStatus;\n  var _useFileUpload = useFileUpload(),\n    clearFile = _useFileUpload.clearFile;\n  var _useTxInscription = useTxInscription(),\n    reset = _useTxInscription.reset;\n  var _useTxPreparation = useTxPreparation(),\n    resetPreparation = _useTxPreparation.reset;\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-full h-full z-50 flex flex-col items-center justify-center rounded-4xl !text-white ".concat(className),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center gap-6"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-[1.45456rem] h-[1rem]"\n  }, /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "100%",\n    height: "100%",\n    viewBox: "0 0 28 20",\n    fill: "none"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M25.6364 2L9.63637 18L2.36365 10.7273",\n    stroke: "#2B80FF",\n    strokeWidth: "2.90909",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  }))), /*#__PURE__*/react.createElement("p", {\n    className: "text-center text-[1.25rem]"\n  }, text), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 items-center text-sm w-full mt-4"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Preparation Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "border-t border-white/20 my-1"\n  }), preparationTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Preparation Transaction:"), /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: preparationTxId\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-4"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Inscription Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "border-t border-white/20 my-1"\n  }), indexingTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Indexing Transaction:"), /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: indexingTxId\n  })), shardTxIds && shardTxIds.length > 0 && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80"\n  }, "Shard Transactions:"), shardTxIds.map(function (shardTxId, index) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      key: index,\n      txId: shardTxId\n    });\n  })), (submissionStatus === null || submissionStatus === void 0 ? void 0 : submissionStatus.success) && !indexingTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Indexing Transaction:"), /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: submissionStatus.success.indexingTxId\n  })), (submissionStatus === null || submissionStatus === void 0 ? void 0 : submissionStatus.success) && submissionStatus.success.allShardSubmissions.length > 0 && !shardTxIds && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80"\n  }, "Shard Transactions:"), submissionStatus.success.allShardSubmissions.map(function (shard, index) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      key: index,\n      txId: shard.shardSubmittedTxid\n    });\n  })))), /*#__PURE__*/react.createElement(Button, {\n    onClick: function onClick() {\n      resetStatus("preparation");\n      resetStatus("inscription");\n      setInscriptionStatus({});\n      setPreparationStatus({});\n      reset();\n      resetPreparation();\n      clearFile();\n      setIsPrepared(false);\n      setIsInscribed(false);\n      setDelegateText("");\n    },\n    className: "mt-4"\n  }, "Inscribe more")));\n}\n;// ./src/components/ui/ProgressBar.tsx\n\nvar ProgressBar = function ProgressBar(_ref) {\n  var currentStep = _ref.currentStep,\n    totalSteps = _ref.totalSteps,\n    stepText = _ref.stepText,\n    phase = _ref.phase;\n  var progress = currentStep / totalSteps * 100;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex justify-between items-center mb-2"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-sm text-white/80 font-bold"\n  }, "Step ", currentStep, " of ", totalSteps, ": ", stepText), /*#__PURE__*/react.createElement("span", {\n    className: "text-sm text-white/80"\n  }, phase)), /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-2 bg-white/20 rounded-full overflow-hidden"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "h-full bg-blue-500 rounded-full transition-all duration-300 ease-in-out",\n    style: {\n      width: "".concat(progress, "%")\n    }\n  })));\n};\n;// ./src/components/uploader/mainUploader.tsx\n"use client";\n\nfunction mainUploader_typeof(o) { "@babel/helpers - typeof"; return mainUploader_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, mainUploader_typeof(o); }\nfunction mainUploader_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ mainUploader_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == mainUploader_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(mainUploader_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction mainUploader_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction mainUploader_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { mainUploader_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { mainUploader_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction mainUploader_slicedToArray(r, e) { return mainUploader_arrayWithHoles(r) || mainUploader_iterableToArrayLimit(r, e) || mainUploader_unsupportedIterableToArray(r, e) || mainUploader_nonIterableRest(); }\nfunction mainUploader_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction mainUploader_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return mainUploader_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? mainUploader_arrayLikeToArray(r, a) : void 0; } }\nfunction mainUploader_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction mainUploader_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction mainUploader_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction MainUploader() {\n  var _preparationSubmissio2, _unsignedTx$success, _unsignedTx$success2;\n  var _useState = (0,react.useState)("files"),\n    _useState2 = mainUploader_slicedToArray(_useState, 2),\n    activeView = _useState2[0],\n    setActiveView = _useState2[1];\n  // Se usa el nuevo contexto que maneja un solo archivo\n  var _useFileUpload = useFileUpload(),\n    file = _useFileUpload.file,\n    clearFile = _useFileUpload.clearFile;\n  var _useWallet = useWallet(),\n    defaultWallet = _useWallet.defaultWallet;\n  var _useTxPreparation = useTxPreparation(),\n    isPreparing = _useTxPreparation.isProcessing,\n    prepareStep = _useTxPreparation.currentStep,\n    prepareNextStep = _useTxPreparation.nextStep,\n    prepareError = _useTxPreparation.error,\n    clearPrepareError = _useTxPreparation.clearError,\n    prepareFiles = _useTxPreparation.prepareFiles,\n    prepareText = _useTxPreparation.prepareText,\n    signAndSubmitPreparation = _useTxPreparation.signAndSubmit,\n    resetPreparation = _useTxPreparation.reset,\n    preparationSubmissionStatus = _useTxPreparation.submissionStatus,\n    unsignedTxId = _useTxPreparation.unsignedTxId;\n  var _useTxInscription = useTxInscription(),\n    isInscribePreparing = _useTxInscription.isProcessing,\n    inscribeStep = _useTxInscription.currentStep,\n    inscribeNextStep = _useTxInscription.nextStep,\n    inscribeError = _useTxInscription.error,\n    clearInscribeError = _useTxInscription.clearError,\n    inscribeFiles = _useTxInscription.inscribeFiles,\n    signAndSubmitInscription = _useTxInscription.signAndSubmit,\n    resetInscription = _useTxInscription.reset,\n    submissionStatus = _useTxInscription.submissionStatus,\n    unsignedTx = _useTxInscription.unsignedTx;\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = mainUploader_slicedToArray(_useState3, 2),\n    isPrepared = _useState4[0],\n    setIsPrepared = _useState4[1];\n  var _useState5 = (0,react.useState)(false),\n    _useState6 = mainUploader_slicedToArray(_useState5, 2),\n    isInscribed = _useState6[0],\n    setIsInscribed = _useState6[1];\n  var _useState7 = (0,react.useState)(""),\n    _useState8 = mainUploader_slicedToArray(_useState7, 2),\n    delegateText = _useState8[0],\n    setDelegateText = _useState8[1];\n  var _useTxStatus = useTxStatus(),\n    resetStatus = _useTxStatus.resetStatus;\n  (0,react.useEffect)(function () {\n    console.log("prepareError", prepareError);\n    console.log("inscribeError", inscribeError);\n  }, [prepareError, inscribeError, clearPrepareError, clearInscribeError]);\n\n  // Consolidated state management logic\n  (0,react.useEffect)(function () {\n    var _preparationSubmissio;\n    if (prepareError) {\n      console.log("Resetting isPrepared due to error:", prepareError);\n      setIsPrepared(false);\n    } else if (prepareStep === "prepare/retrieve-submission" || (preparationSubmissionStatus === null || preparationSubmissionStatus === void 0 || (_preparationSubmissio = preparationSubmissionStatus.success) === null || _preparationSubmissio === void 0 ? void 0 : _preparationSubmissio.onchain) === "on-chain") {\n      console.log("Final preparation step reached with no errors or transaction is on-chain, setting isPrepared to true");\n      setIsPrepared(true);\n    }\n    if (inscribeError) {\n      console.log("Resetting isInscribed due to error:", inscribeError);\n      setIsInscribed(false);\n    }\n    console.log("prepareStep", prepareStep);\n    console.log("inscribeStep", inscribeStep);\n    console.log("isPrepared", isPrepared);\n    console.log("isInscribed", isInscribed);\n  }, [prepareError, prepareStep, preparationSubmissionStatus, inscribeError]);\n  var getLoadingText = function getLoadingText() {\n    if (!isPrepared) {\n      switch (prepareStep) {\n        case "prepare/construct":\n          return "Preparing and constructing transaction...";\n        case "prepare/retrieve":\n          return "Retrieving utxo preparation transaction for signing...";\n        case "prepare/submit":\n          return "Submitting signed transaction...";\n        case "prepare/retrieve-submission":\n          return "Retrieving preparation submission status...";\n        default:\n          return "Processing...";\n      }\n    } else {\n      switch (inscribeStep) {\n        case "inscription/construct":\n          return "Constructing inscription transaction...";\n        case "inscription/retrieve":\n          return "Retrieving utxo inscription transaction for signing...";\n        case "inscription/submit":\n          return "Submitting signed transaction...";\n        case "inscription/retrieve-submission":\n          return "Retrieving inscription submission status...";\n        case "end":\n          return "Transaction submitted!";\n        default:\n          return "Processing...";\n      }\n    }\n  };\n  var getProgressText = function getProgressText() {\n    if (isInscribed) {\n      return "Inscription completed successfully!";\n    }\n    if (!isPrepared) {\n      switch (prepareStep) {\n        case "prepare/construct":\n          return "Select content to upload";\n        case "prepare/retrieve":\n          return "Sign your transaction(s)";\n        case "prepare/submit":\n          return "Submitting your signed transaction(s)...";\n        case "prepare/retrieve-submission":\n          return "Validating your transaction(s) on chain...";\n        default:\n          return "Processing...";\n      }\n    } else {\n      switch (inscribeStep) {\n        case "inscription/construct":\n          return "Confirm your inscription content";\n        case "inscription/retrieve":\n          return "Sign your transaction(s)";\n        case "inscription/submit":\n          return "Submitting your signed transaction(s)...";\n        case "inscription/retrieve-submission":\n          return "Validating your transaction(s) on chain...";\n        case "end":\n          return "Transaction submitted!";\n        default:\n          return "Processing...";\n      }\n    }\n  };\n  var getButtonText = function getButtonText() {\n    // If there\'s a wallet signing error, show "Retry Signing" button\n    if (inscribeError && inscribeError.includes("Wallet signing error")) {\n      return "Retry Signing";\n    }\n    if (prepareError && prepareError.includes("Wallet signing error")) {\n      return "Retry Signing";\n    }\n    if (!isPrepared) {\n      if (prepareStep === "prepare/construct") {\n        return "Prepare UTxOs for inscription";\n      } else if (prepareStep === "prepare/retrieve") {\n        return "Sign and submit utxo preparation transaction";\n      }\n    } else if (isPrepared && !isInscribed) {\n      if (inscribeStep === "inscription/construct") {\n        return "Inscribe Onchain";\n      } else if (inscribeStep === "inscription/retrieve") {\n        return "Sign and Inscribe";\n      }\n    }\n    return "Processing...";\n  };\n  var isInFinalStep = function isInFinalStep() {\n    return inscribeStep === "inscription/retrieve-submission" || isInscribePreparing;\n  };\n  var handlePrepare = /*#__PURE__*/function () {\n    var _ref = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(activeView === "files")) {\n              _context.next = 7;\n              break;\n            }\n            if (file) {\n              _context.next = 3;\n              break;\n            }\n            return _context.abrupt("return");\n          case 3:\n            _context.next = 5;\n            return prepareFiles([file]);\n          case 5:\n            _context.next = 9;\n            break;\n          case 7:\n            _context.next = 9;\n            return prepareText(delegateText);\n          case 9:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function handlePrepare() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var handleInscribe = /*#__PURE__*/function () {\n    var _ref2 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee2() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(activeView === "files")) {\n              _context2.next = 7;\n              break;\n            }\n            if (file) {\n              _context2.next = 3;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 3:\n            _context2.next = 5;\n            return inscribeFiles([file]);\n          case 5:\n            _context2.next = 9;\n            break;\n          case 7:\n            _context2.next = 9;\n            return inscribeFiles([new File([delegateText], "inscription.txt", {\n              type: "text/plain"\n            })]);\n          case 9:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function handleInscribe() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitPreparation = /*#__PURE__*/function () {\n    var _ref3 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee3() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            setIsPrepared(false); // Reset the state before starting\n            _context3.next = 4;\n            return signAndSubmitPreparation();\n          case 4:\n            _context3.next = 10;\n            break;\n          case 6:\n            _context3.prev = 6;\n            _context3.t0 = _context3["catch"](0);\n            console.error("Error during preparation:", _context3.t0);\n            // Make sure isPrepared is false in case of error\n            setIsPrepared(false);\n          case 10:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[0, 6]]);\n    }));\n    return function handleSignAndSubmitPreparation() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitInscription = /*#__PURE__*/function () {\n    var _ref4 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee4() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return signAndSubmitInscription();\n          case 3:\n            // Only set isInscribed to true if there was no error\n            if (!inscribeError) {\n              setIsInscribed(true);\n            }\n            _context4.next = 10;\n            break;\n          case 6:\n            _context4.prev = 6;\n            _context4.t0 = _context4["catch"](0);\n            console.error("Error during inscription:", _context4.t0);\n            // Make sure isInscribed is false in case of error\n            setIsInscribed(false);\n          case 10:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0, 6]]);\n    }));\n    return function handleSignAndSubmitInscription() {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var handleBack = function handleBack() {\n    resetPreparation();\n    setIsPrepared(false);\n    // Solo reiniciamos el estado de preparacin\n    resetStatus("preparation");\n  };\n  var handleCancel = function handleCancel() {\n    resetPreparation();\n    resetInscription();\n    setIsPrepared(false);\n    setIsInscribed(false);\n    clearFile();\n    setDelegateText("");\n    resetStatus("preparation");\n    resetStatus("inscription");\n    setDelegateText("");\n  };\n  var showLoader = isPreparing || isInFinalStep();\n  var handleMainButtonClick = /*#__PURE__*/function () {\n    var _ref5 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee5() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!(prepareError && prepareError.includes("Wallet signing error"))) {\n              _context5.next = 4;\n              break;\n            }\n            _context5.next = 3;\n            return handleSignAndSubmitPreparation();\n          case 3:\n            return _context5.abrupt("return");\n          case 4:\n            if (!(inscribeError && inscribeError.includes("Wallet signing error"))) {\n              _context5.next = 8;\n              break;\n            }\n            _context5.next = 7;\n            return handleSignAndSubmitInscription();\n          case 7:\n            return _context5.abrupt("return");\n          case 8:\n            if (isPrepared) {\n              _context5.next = 19;\n              break;\n            }\n            if (!(prepareStep === "prepare/construct")) {\n              _context5.next = 14;\n              break;\n            }\n            _context5.next = 12;\n            return handlePrepare();\n          case 12:\n            _context5.next = 17;\n            break;\n          case 14:\n            if (!(prepareStep === "prepare/retrieve")) {\n              _context5.next = 17;\n              break;\n            }\n            _context5.next = 17;\n            return handleSignAndSubmitPreparation();\n          case 17:\n            _context5.next = 28;\n            break;\n          case 19:\n            if (!(isPrepared && !isInscribed)) {\n              _context5.next = 28;\n              break;\n            }\n            if (!(inscribeStep === "inscription/construct")) {\n              _context5.next = 25;\n              break;\n            }\n            _context5.next = 23;\n            return handleInscribe();\n          case 23:\n            _context5.next = 28;\n            break;\n          case 25:\n            if (!(inscribeStep === "inscription/retrieve")) {\n              _context5.next = 28;\n              break;\n            }\n            _context5.next = 28;\n            return handleSignAndSubmitInscription();\n          case 28:\n          case "end":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return function handleMainButtonClick() {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var getTotalSteps = function getTotalSteps() {\n    return 8; // 4 prepare steps + 4 inscription steps\n  };\n  var getCurrentStep = function getCurrentStep() {\n    if (isInscribed) {\n      return 8; // Stay at final step when inscription is complete\n    }\n    var prepareSteps = {\n      "prepare/construct": 1,\n      "prepare/retrieve": 2,\n      "prepare/submit": 3,\n      "prepare/retrieve-submission": 4\n    };\n    var inscribeSteps = {\n      "inscription/construct": 5,\n      "inscription/retrieve": 6,\n      "inscription/submit": 7,\n      "inscription/retrieve-submission": 8,\n      end: 8\n    };\n    if (!isPrepared) {\n      return prepareSteps[prepareStep] || 1;\n    } else {\n      return inscribeSteps[inscribeStep] || 5;\n    }\n  };\n  var getStepPhase = function getStepPhase() {\n    var currentStep = getCurrentStep();\n    return currentStep <= 4 ? "Preparation" : "Inscription";\n  };\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "bg-white/10 rounded-4xl backdrop-blur-[10px] p-8 max-w-5xl w-full mx-auto text-white",\n    initial: {\n      opacity: 0,\n      scale: 0.9\n    },\n    animate: {\n      opacity: 1,\n      scale: 1\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "mb-6"\n  }, /*#__PURE__*/react.createElement(ProgressBar, {\n    currentStep: getCurrentStep(),\n    totalSteps: getTotalSteps(),\n    stepText: getProgressText(),\n    phase: getStepPhase()\n  })), !showLoader && !isInscribed && /*#__PURE__*/react.createElement("div", {\n    className: "space-y-6"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "flex items-center justify-between",\n    initial: {\n      opacity: 0,\n      y: -20\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    transition: {\n      duration: 0.5,\n      delay: 0.2\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-[1.25rem]"\n  }, prepareStep == "prepare/construct" ? "Add File or Text to inscribe" : prepareStep == "prepare/retrieve" ? "Preparing your UTxOs." : /*#__PURE__*/react.createElement("strong", null, "Please double check the text items below before continuing:")), /*#__PURE__*/react.createElement("div", {\n    className: "flex "\n  }, /*#__PURE__*/react.createElement("button", {\n    className: "px-2 py-[0.125rem] ".concat(activeView === "files" ? "bg-[#051023] text-white" : "bg-[#051023]/20 text-white/60"),\n    onClick: function onClick() {\n      return setActiveView("files");\n    },\n    style: {\n      borderRadius: "0.25rem"\n    },\n    disabled: prepareStep !== "prepare/construct"\n  }, "Files"), /*#__PURE__*/react.createElement("button", {\n    className: "px-2 py-[0.125rem] ".concat(activeView === "delegate" ? "bg-[#051023] text-white" : "bg-[#051023]/20 text-white/60"),\n    onClick: function onClick() {\n      return setActiveView("delegate");\n    },\n    style: {\n      borderRadius: "0.25rem"\n    },\n    disabled: prepareStep !== "prepare/construct"\n  }, "Text"))), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4"\n  }, (prepareError || inscribeError) && /*#__PURE__*/react.createElement("div", {\n    className: "text-sm text-red-600 bg-white p-4 rounded-md overflow-auto"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "mb-2 font-semibold"\n  }, "Error occurred:"), /*#__PURE__*/react.createElement("pre", {\n    className: "whitespace-pre-wrap"\n  }, JSON.stringify({\n    error: prepareError || inscribeError\n  }, null, 2)), /*#__PURE__*/react.createElement("button", {\n    onClick: prepareError ? clearPrepareError : clearInscribeError,\n    className: "!mt-4 px-3 py-1 bg-blue-600 !text-white rounded hover:bg-blue-700"\n  }, "Clear Error")), inscribeStep === "inscription/retrieve" || inscribeStep === "inscription/submit" || inscribeStep === "inscription/construct" && isPrepared && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 text-[1.25rem]"\n  }, /*#__PURE__*/react.createElement("div", null, "We take no responsibility for typos or wrong punctuation. We are also not checking for any previous inscriptions containing the same text.")), activeView === "files" ? /*#__PURE__*/react.createElement(react.Fragment, null, prepareStep === "prepare/construct" && /*#__PURE__*/react.createElement(UploadBox, null), file && /*#__PURE__*/react.createElement(FileList, null)) : /*#__PURE__*/react.createElement(DelegateView, {\n    text: delegateText,\n    setText: function setText(text) {\n      return setDelegateText(text);\n    },\n    isProcessing: isPreparing || isInFinalStep()\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "flex gap-4"\n  }, (prepareStep === "prepare/retrieve" || inscribeStep === "inscription/retrieve") && /*#__PURE__*/react.createElement(Button, {\n    onClick: handleBack,\n    animate: false,\n    className: "w-1/4",\n    variant: "secondary"\n  }, "Back"), /*#__PURE__*/react.createElement(Button, {\n    onClick: handleMainButtonClick,\n    className: "w-full",\n    disabled: activeView === "files" && !file || activeView === "delegate" && !delegateText.trim() || !defaultWallet ||\n    // Don\'t disable the button when there\'s a wallet signing error\n    isPreparing && !(prepareError && prepareError.includes("Wallet signing error")) && !(inscribeError && inscribeError.includes("Wallet signing error")) || isInFinalStep()\n  }, getButtonText()))), showLoader && /*#__PURE__*/react.createElement(LoadingScreen, {\n    text: getLoadingText()\n  }), unsignedTxId && !isInscribed && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 items-center text-sm w-full mt-8"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold self-start"\n  }, "Preparation Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full"\n  }, unsignedTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 "\n  }, "Preparation Transaction:"), /*#__PURE__*/react.createElement("a", {\n    href: "https://preprod.cardanoscan.io/transaction/".concat(unsignedTxId),\n    target: "_blank",\n    rel: "noopener noreferrer",\n    className: "!text-white/80 hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("svg", {\n    className: "w-4 h-4",\n    viewBox: "0 0 24 24",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M12 12V3M12 3L9 6M12 3L15 6",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  })), unsignedTxId)))), (inscribeStep === "inscription/retrieve" || inscribeStep === "inscription/submit") && (unsignedTx === null || unsignedTx === void 0 ? void 0 : unsignedTx.success) && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 items-center text-sm w-full mt-8"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Inscription Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "border-t border-white/20 my-1"\n  }), /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Inscription Indexing Transaction:"), /*#__PURE__*/react.createElement("a", {\n    href: "https://preprod.cardanoscan.io/transaction/".concat(unsignedTx.success.indexingTxId),\n    target: "_blank",\n    rel: "noopener noreferrer",\n    className: "!text-white/80 hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("svg", {\n    className: "w-4 h-4",\n    viewBox: "0 0 24 24",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M12 12V3M12 3L9 6M12 3L15 6",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  })), unsignedTx.success.indexingTxId)), unsignedTx.success.shardTxIds && unsignedTx.success.shardTxIds.length > 0 && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Shard Transactions:"), unsignedTx.success.shardTxIds.map(function (shardTxId, index) {\n    return /*#__PURE__*/react.createElement("a", {\n      key: index,\n      href: "https://preprod.cardanoscan.io/transaction/".concat(shardTxId),\n      target: "_blank",\n      rel: "noopener noreferrer",\n      className: "!text-white/80 hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n    }, /*#__PURE__*/react.createElement("svg", {\n      className: "w-4 h-4",\n      viewBox: "0 0 24 24",\n      fill: "none",\n      xmlns: "http://www.w3.org/2000/svg"\n    }, /*#__PURE__*/react.createElement("path", {\n      d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n      stroke: "currentColor",\n      strokeWidth: "2",\n      strokeLinecap: "round"\n    }), /*#__PURE__*/react.createElement("path", {\n      d: "M12 12V3M12 3L9 6M12 3L15 6",\n      stroke: "currentColor",\n      strokeWidth: "2",\n      strokeLinecap: "round",\n      strokeLinejoin: "round"\n    })), shardTxId);\n  }))), isInscribed && /*#__PURE__*/react.createElement(FinishScreen, {\n    setIsPrepared: setIsPrepared,\n    setIsInscribed: setIsInscribed,\n    setDelegateText: setDelegateText,\n    submissionStatus: submissionStatus,\n    preparationTxId: preparationSubmissionStatus === null || preparationSubmissionStatus === void 0 || (_preparationSubmissio2 = preparationSubmissionStatus.success) === null || _preparationSubmissio2 === void 0 ? void 0 : _preparationSubmissio2.txid,\n    unsignedTxId: unsignedTxId !== null && unsignedTxId !== void 0 ? unsignedTxId : undefined,\n    indexingTxId: unsignedTx === null || unsignedTx === void 0 || (_unsignedTx$success = unsignedTx.success) === null || _unsignedTx$success === void 0 ? void 0 : _unsignedTx$success.indexingTxId,\n    shardTxIds: unsignedTx === null || unsignedTx === void 0 || (_unsignedTx$success2 = unsignedTx.success) === null || _unsignedTx$success2 === void 0 ? void 0 : _unsignedTx$success2.shardTxIds\n  }));\n}\n;// ./src/components/wallet/ConnectWallet.tsx\n\n\n\nfunction ConnectWallet() {\n  var _useWallet = useWallet(),\n    openMenu = _useWallet.openMenu,\n    defaultWallet = _useWallet.defaultWallet;\n  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button, {\n    onClick: openMenu,\n    animate: false\n  }, defaultWallet ? "Connected to ".concat(defaultWallet) : "Connect Wallet"));\n}\n;// ./src/icons/CloseIconSecondary.tsx\n\nvar CloseIconSecondary = function CloseIconSecondary(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "30",\n    height: "30",\n    viewBox: "0 0 20 20",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M18.0553 0.333831C18.5002 -0.111047 19.2215 -0.111047 19.6663 0.33383C20.1112 0.778708 20.1112 1.5 19.6663 1.94487L1.94486 19.6664C1.49998 20.1112 0.778695 20.1112 0.333818 19.6664C-0.111059 19.2215 -0.111059 18.5002 0.333818 18.0553L18.0553 0.333831Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M0.333658 1.9447C-0.111219 1.49982 -0.11122 0.778535 0.333658 0.333658C0.778535 -0.111219 1.49982 -0.111219 1.9447 0.333658L19.6662 18.0551C20.1111 18.5 20.1111 19.2213 19.6662 19.6662C19.2213 20.1111 18.5 20.1111 18.0551 19.6662L0.333658 1.9447Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/components/wallet/WalletMenu.tsx\nfunction WalletMenu_slicedToArray(r, e) { return WalletMenu_arrayWithHoles(r) || WalletMenu_iterableToArrayLimit(r, e) || WalletMenu_unsupportedIterableToArray(r, e) || WalletMenu_nonIterableRest(); }\nfunction WalletMenu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction WalletMenu_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return WalletMenu_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? WalletMenu_arrayLikeToArray(r, a) : void 0; } }\nfunction WalletMenu_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction WalletMenu_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction WalletMenu_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\nfunction WalletMenu() {\n  var _useWallet = useWallet(),\n    isMenuOpen = _useWallet.isMenuOpen,\n    closeMenu = _useWallet.closeMenu,\n    wallets = _useWallet.wallets,\n    connectedWallets = _useWallet.connectedWallets,\n    defaultWallet = _useWallet.defaultWallet,\n    connectWallet = _useWallet.connectWallet,\n    disconnectWallet = _useWallet.disconnectWallet,\n    setDefaultWallet = _useWallet.setDefaultWallet,\n    installedWallets = _useWallet.installedWallets;\n  var availableWallets = Object.entries(wallets).filter(function (_ref) {\n    var _ref2 = WalletMenu_slicedToArray(_ref, 2),\n      key = _ref2[0],\n      _ = _ref2[1];\n    return installedWallets.includes(key) && !connectedWallets.some(function (w) {\n      return w.name.toLowerCase() === key;\n    });\n  });\n  var walletsToInstall = Object.entries(wallets).filter(function (_ref3) {\n    var _ref4 = WalletMenu_slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      _ = _ref4[1];\n    return !installedWallets.includes(key);\n  });\n  return /*#__PURE__*/react.createElement(AnimatePresence, null, isMenuOpen && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(motion.div, {\n    className: "fixed inset-0  backdrop-blur-[2px] z-40",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    },\n    onClick: closeMenu\n  }), /*#__PURE__*/react.createElement(motion.div, {\n    className: "fixed top-0 right-0 h-full w-full max-w-md bg-white/10 backdrop-blur-xl p-6 z-50 text-white overflow-y-auto",\n    initial: {\n      x: "100%"\n    },\n    animate: {\n      x: 0\n    },\n    exit: {\n      x: "100%"\n    },\n    transition: {\n      type: "spring",\n      damping: 20,\n      stiffness: 100\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "h-full flex flex-col"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center justify-between mb-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-[2rem] font-medium"\n  }, "Connect wallet"), /*#__PURE__*/react.createElement(Button, {\n    variant: "ghost",\n    className: "p-1 hover:bg-white/10 rounded-full",\n    onClick: closeMenu\n  }, /*#__PURE__*/react.createElement(CloseIconSecondary, {\n    className: "w-6 h-6"\n  }))), /*#__PURE__*/react.createElement("p", {\n    className: "!text-sm !text-light !mb-6"\n  }, "By connecting your wallet you agree to our", " ", /*#__PURE__*/react.createElement("a", {\n    href: "#",\n    className: "!text-light underline"\n  }, "Terms"), " ", "and", " ", /*#__PURE__*/react.createElement("a", {\n    href: "#",\n    className: "!text-light underline"\n  }, "Privacy Policy"), "."), /*#__PURE__*/react.createElement("div", {\n    className: "overflow-y-auto flex flex-col gap-8"\n  }, connectedWallets.length > 0 && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {\n    className: "text-xl font-medium mb-3"\n  }, "Connected wallets"), /*#__PURE__*/react.createElement("div", {\n    className: "space-y-2"\n  }, connectedWallets.map(function (connectedWallet) {\n    var wallet = wallets[connectedWallet.name.toLowerCase()];\n    var isDefault = (defaultWallet === null || defaultWallet === void 0 ? void 0 : defaultWallet.toLowerCase()) === connectedWallet.name.toLowerCase();\n    return /*#__PURE__*/react.createElement("div", {\n      key: connectedWallet.name,\n      className: "w-full flex items-center justify-between p-3 rounded-xl transition-colors ".concat(isDefault ? "bg-blue-500/20" : "bg-white/5")\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-3"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "w-8 h-8 bg-white/10 rounded-full flex items-center justify-center"\n    }, /*#__PURE__*/react.createElement("img", {\n      src: wallet.icon || "/placeholder.svg",\n      alt: wallet.name,\n      className: "w-5 h-5"\n    })), /*#__PURE__*/react.createElement("span", null, wallet.name)), /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-2"\n    }, !isDefault && /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm hover:bg-white/10",\n      onClick: function onClick() {\n        return setDefaultWallet(wallet.name);\n      }\n    }, "Make default"), /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm text-red-400 hover:bg-red-500/10 !hidden",\n      onClick: function onClick() {\n        return disconnectWallet(wallet.name);\n      }\n    }, "Disconnect")));\n  }))), availableWallets.length > 0 && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {\n    className: "text-xl font-medium mb-3"\n  }, "Available wallets"), /*#__PURE__*/react.createElement("div", {\n    className: "space-y-2"\n  }, availableWallets.map(function (_ref5) {\n    var _ref6 = WalletMenu_slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      wallet = _ref6[1];\n    return /*#__PURE__*/react.createElement("div", {\n      key: key,\n      className: "w-full flex items-center justify-between p-3 bg-white/5 hover:bg-white/10 rounded-xl transition-colors"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-3"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "w-8 h-8 bg-white/10 rounded-full flex items-center justify-center"\n    }, /*#__PURE__*/react.createElement("img", {\n      src: wallet.icon || "/placeholder.svg",\n      alt: wallet.name,\n      className: "w-5 h-5"\n    })), /*#__PURE__*/react.createElement("span", null, wallet.name)), /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm hover:bg-white/10",\n      onClick: function onClick() {\n        return connectWallet(wallet.name);\n      },\n      successText: "Connected"\n    }, "Connect"));\n  }))), walletsToInstall.length > 0 && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {\n    className: "text-xl font-medium mb-3"\n  }, "Select a wallet to install"), /*#__PURE__*/react.createElement("div", {\n    className: "space-y-2"\n  }, walletsToInstall.map(function (_ref7) {\n    var _ref8 = WalletMenu_slicedToArray(_ref7, 2),\n      key = _ref8[0],\n      wallet = _ref8[1];\n    return /*#__PURE__*/react.createElement("div", {\n      key: key,\n      className: "w-full flex items-center justify-between p-3 bg-white/5 hover:bg-white/10 rounded-xl transition-colors"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-3"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "w-8 h-8 bg-white/10 rounded-full flex items-center justify-center"\n    }, /*#__PURE__*/react.createElement("img", {\n      src: wallet.icon || "/placeholder.svg",\n      alt: wallet.name,\n      className: "w-5 h-5"\n    })), /*#__PURE__*/react.createElement("span", null, wallet.name)), /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm hover:bg-white/10",\n      onClick: function onClick(e) {\n        e.stopPropagation();\n        window.open(wallet.url, "_blank");\n      }\n    }, "Install"));\n  }))))))));\n}\n;// ./src/utils/decoder.ts\nfunction decoder_typeof(o) { "@babel/helpers - typeof"; return decoder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, decoder_typeof(o); }\nfunction decoder_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ decoder_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == decoder_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(decoder_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction decoder_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction decoder_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { decoder_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { decoder_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\n// src/utils/decoder.ts\n// No need for WASI imports anymore\n\n/**\n * Type definition for the WASM instance with exported functions\n */\n\n/**\n * Initialize the WASM decoder by fetching and instantiating the WASM module\n * @param wasmModuleUrl Optional URL to the WASM module, defaults to the S3 URL\n * @returns Object containing the instantiated WASM module\n */\nfunction initializeWasmDecoder(_x) {\n  return _initializeWasmDecoder.apply(this, arguments);\n}\n\n/**\n * Validates if a string is a valid hexadecimal string\n */\nfunction _initializeWasmDecoder() {\n  _initializeWasmDecoder = decoder_asyncToGenerator(/*#__PURE__*/decoder_regeneratorRuntime().mark(function _callee(wasmModuleUrl) {\n    var wasmUrl, response, compiledWasmDecoder, wasiHandler, baseWasi, importObject, wasmInstance, _response, wasmBytes, wasmModule, _wasiHandler, _baseWasi, _importObject, _wasmInstance;\n    return decoder_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          wasmUrl = wasmModuleUrl || \'https://metadata-decoder-wasm.s3.us-east-1.amazonaws.com/wasm-decoder.wasm\';\n          console.log("Loading WASM from URL:", wasmUrl);\n\n          // First try the streaming approach\n          _context.prev = 3;\n          _context.next = 6;\n          return fetch(wasmUrl);\n        case 6:\n          response = _context.sent;\n          console.log("Response:", response);\n          // Check if the response is ok\n          if (response.ok) {\n            _context.next = 10;\n            break;\n          }\n          throw new Error("HTTP error! status: ".concat(response.status));\n        case 10:\n          _context.next = 12;\n          return WebAssembly.compileStreaming(response);\n        case 12:\n          compiledWasmDecoder = _context.sent;\n          // Create a dynamic WASI import object with a Proxy\n          // This will automatically handle any WASI function that the module requires\n          wasiHandler = {\n            get: function get(target, prop) {\n              // If the property already exists, return it\n              if (prop in target) {\n                return target[prop];\n              }\n\n              // Otherwise, create a function that returns 0 (success in WASI)\n              console.log("Auto-creating WASI function: ".concat(prop));\n              return function () {\n                console.log("Called auto-created WASI function: ".concat(prop, " with ").concat(arguments.length, " args"));\n                return 0; // Return success for any function\n              };\n            }\n          }; // Base WASI functions with explicit implementations\n          baseWasi = {\n            proc_exit: function proc_exit(code) {\n              console.log("proc_exit called with code: ".concat(code));\n            },\n            fd_write: function fd_write(fd, iovs, iovsLen, nwritten) {\n              console.log("fd_write called: fd=".concat(fd, ", iovs=").concat(iovs, ", iovsLen=").concat(iovsLen, ", nwritten=").concat(nwritten));\n              return 0;\n            }\n          }; // Create the import object with a Proxy for wasi_snapshot_preview1\n          importObject = {\n            wasi_snapshot_preview1: new Proxy(baseWasi, wasiHandler)\n          };\n          _context.next = 18;\n          return WebAssembly.instantiate(compiledWasmDecoder, importObject);\n        case 18:\n          wasmInstance = _context.sent;\n          console.log("WASM initialized successfully via streaming");\n          return _context.abrupt("return", {\n            wasmInstance: wasmInstance\n          });\n        case 23:\n          _context.prev = 23;\n          _context.t0 = _context["catch"](3);\n          console.warn("Streaming compilation failed, falling back to ArrayBuffer approach:", _context.t0);\n\n          // Fallback to ArrayBuffer approach if streaming fails\n          _context.next = 28;\n          return fetch(wasmUrl);\n        case 28:\n          _response = _context.sent;\n          console.log("Response:", _response);\n          if (_response.ok) {\n            _context.next = 32;\n            break;\n          }\n          throw new Error("HTTP error! status: ".concat(_response.status));\n        case 32:\n          _context.next = 34;\n          return _response.arrayBuffer();\n        case 34:\n          wasmBytes = _context.sent;\n          _context.next = 37;\n          return WebAssembly.compile(wasmBytes);\n        case 37:\n          wasmModule = _context.sent;\n          // Reuse the same dynamic WASI handler approach\n          _wasiHandler = {\n            get: function get(target, prop) {\n              // If the property already exists, return it\n              if (prop in target) {\n                return target[prop];\n              }\n\n              // Otherwise, create a function that returns 0 (success in WASI)\n              console.log("Auto-creating WASI function: ".concat(prop));\n              return function () {\n                console.log("Called auto-created WASI function: ".concat(prop, " with ").concat(arguments.length, " args"));\n                return 0; // Return success for any function\n              };\n            }\n          }; // Base WASI functions with explicit implementations\n          _baseWasi = {\n            proc_exit: function proc_exit(code) {\n              console.log("proc_exit called with code: ".concat(code));\n            },\n            fd_write: function fd_write(fd, iovs, iovsLen, nwritten) {\n              console.log("fd_write called: fd=".concat(fd, ", iovs=").concat(iovs, ", iovsLen=").concat(iovsLen, ", nwritten=").concat(nwritten));\n              return 0;\n            }\n          }; // Create the import object with a Proxy for wasi_snapshot_preview1\n          _importObject = {\n            wasi_snapshot_preview1: new Proxy(_baseWasi, _wasiHandler)\n          };\n          _context.next = 43;\n          return WebAssembly.instantiate(wasmModule, _importObject);\n        case 43:\n          _wasmInstance = _context.sent;\n          console.log("WASM initialized successfully via ArrayBuffer");\n          return _context.abrupt("return", {\n            wasmInstance: _wasmInstance\n          });\n        case 46:\n          _context.next = 52;\n          break;\n        case 48:\n          _context.prev = 48;\n          _context.t1 = _context["catch"](0);\n          console.error("WASM initialization failed:", _context.t1);\n          throw _context.t1;\n        case 52:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 48], [3, 23]]);\n  }));\n  return _initializeWasmDecoder.apply(this, arguments);\n}\nfunction isValidHexString(hex) {\n  return true;\n  return /^[0-9A-Fa-f]*$/.test(hex);\n}\n\n/**\n * Pure JavaScript implementation for reconstructing bytes from hex strings\n * This is used as a fallback when WASM initialization fails\n */\nfunction hexToBytes(hex) {\n  // Remove any non-hex characters (like spaces or line breaks)\n  hex = hex.replace(/[^0-9A-Fa-f]/g, \'\');\n\n  // Ensure we have an even number of characters\n  if (hex.length % 2 !== 0) {\n    hex = \'0\' + hex;\n  }\n  var bytes = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert a byte array to a base64 string\n */\nfunction bytesToBase64(bytes) {\n  var binString = Array.from(bytes).map(function (_byte) {\n    return String.fromCharCode(_byte);\n  }).join(\'\');\n  return btoa(binString);\n}\n\n/**\n * Reconstructs the original bytes from an array of hex strings\n * First tries to use the WASM implementation, falls back to pure JS if that fails\n */\nfunction reconstructOriginalBytes(_x2, _x3) {\n  return _reconstructOriginalBytes.apply(this, arguments);\n}\n\n/**\n * Helper: Read a null-terminated C string from WASM memory\n */\nfunction _reconstructOriginalBytes() {\n  _reconstructOriginalBytes = decoder_asyncToGenerator(/*#__PURE__*/decoder_regeneratorRuntime().mark(function _callee2(wInstance, hexStringArray) {\n    var validHexStrings, hexStringPtrs, hexStringArrayPtrAddr, base64Ptr, mem, view, i, _base, combinedHex, bytes, base64;\n    return decoder_regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          console.log(\'Reconstructing bytes from hex strings:\', hexStringArray);\n          _context2.prev = 1;\n          // Validate hex strings\n          validHexStrings = hexStringArray.filter(function (hex) {\n            return isValidHexString(hex);\n          });\n          if (!(validHexStrings.length === 0)) {\n            _context2.next = 5;\n            break;\n          }\n          throw new Error(\'No valid hex strings provided\');\n        case 5:\n          console.log(\'Valid hex strings:\', validHexStrings);\n\n          // Try WASM implementation first if available\n          if (!(wInstance && wInstance.exports && wInstance.exports.memory)) {\n            _context2.next = 42;\n            break;\n          }\n          _context2.prev = 7;\n          console.log(\'Attempting to use WASM implementation...\');\n\n          // Initialize the Haskell runtime\n          wInstance.exports.hs_init(0, 0);\n          hexStringPtrs = [];\n          hexStringArrayPtrAddr = 0;\n          base64Ptr = 0;\n          _context2.prev = 13;\n          // Allocate and write each hex string to WASM memory\n          hexStringPtrs = validHexStrings.map(function (str) {\n            return writeCString(str, wInstance);\n          });\n\n          // Allocate memory for the array of pointers\n          hexStringArrayPtrAddr = wInstance.exports.malloc_bytes_hs(hexStringPtrs.length * 4); // 4 bytes per pointer\n\n          // Write the array of pointers to WASM memory\n          mem = new Uint8Array(wInstance.exports.memory.buffer);\n          view = new DataView(wInstance.exports.memory.buffer);\n          for (i = 0; i < hexStringPtrs.length; i++) {\n            view.setUint32(hexStringArrayPtrAddr + i * 4, hexStringPtrs[i], true); // true for little-endian\n          }\n\n          // Call the WASM function to reconstruct the bytes\n          console.log("Calling reconstructOriginalBytesC with count=".concat(hexStringPtrs.length, ", ptrArray=").concat(hexStringArrayPtrAddr));\n          base64Ptr = wInstance.exports.reconstructOriginalBytesC(hexStringPtrs.length, hexStringArrayPtrAddr);\n          if (!(base64Ptr === 0)) {\n            _context2.next = 23;\n            break;\n          }\n          throw new Error(\'WASM function returned null pointer\');\n        case 23:\n          // Read the result from WASM memory\n          _base = readCString(wInstance.exports.memory.buffer, base64Ptr);\n          console.log("Successfully reconstructed bytes, base64 length: ".concat(_base.length));\n\n          // Free the allocated memory\n          wInstance.exports.free_hs(base64Ptr);\n          wInstance.exports.free_hs(hexStringArrayPtrAddr);\n\n          // Free individual hex strings\n          hexStringPtrs.forEach(function (ptr) {\n            if (ptr !== 0) wInstance.exports.free_hs(ptr);\n          });\n\n          // Shut down the Haskell runtime\n          wInstance.exports.hs_exit();\n          return _context2.abrupt("return", _base);\n        case 32:\n          _context2.prev = 32;\n          _context2.t0 = _context2["catch"](13);\n          console.warn(\'Error during WASM execution:\', _context2.t0);\n\n          // Clean up any allocated memory if possible\n          try {\n            if (base64Ptr !== 0) wInstance.exports.free_hs(base64Ptr);\n            if (hexStringArrayPtrAddr !== 0) wInstance.exports.free_hs(hexStringArrayPtrAddr);\n\n            // Free individual hex strings\n            hexStringPtrs.forEach(function (ptr) {\n              if (ptr !== 0) wInstance.exports.free_hs(ptr);\n            });\n\n            // Shut down the Haskell runtime\n            wInstance.exports.hs_exit();\n          } catch (cleanupError) {\n            console.warn(\'Error during cleanup:\', cleanupError);\n          }\n          throw _context2.t0;\n        case 37:\n          _context2.next = 42;\n          break;\n        case 39:\n          _context2.prev = 39;\n          _context2.t1 = _context2["catch"](7);\n          console.warn(\'WASM implementation failed, falling back to JS:\', _context2.t1);\n          // Fall back to JS implementation\n        case 42:\n          // JavaScript fallback implementation\n          console.log(\'Using JavaScript fallback implementation\');\n\n          // Concatenate all hex strings\n          combinedHex = validHexStrings.join(\'\');\n          console.log(\'Combined hex:\', combinedHex);\n\n          // Convert to bytes\n          bytes = hexToBytes(combinedHex);\n          console.log(\'Converted to bytes, length:\', bytes.length);\n\n          // Convert to base64\n          base64 = bytesToBase64(bytes);\n          console.log(\'Converted to base64, length:\', base64.length);\n          return _context2.abrupt("return", base64);\n        case 52:\n          _context2.prev = 52;\n          _context2.t2 = _context2["catch"](1);\n          console.error(\'Error in reconstructOriginalBytes:\', _context2.t2);\n          throw new Error("Failed to reconstruct bytes: ".concat(_context2.t2.message || String(_context2.t2)));\n        case 56:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[1, 52], [7, 39], [13, 32]]);\n  }));\n  return _reconstructOriginalBytes.apply(this, arguments);\n}\nfunction readCString(memory, ptr) {\n  if (!memory) {\n    throw new Error(\'Memory buffer is undefined in readCString\');\n  }\n  try {\n    console.log("Reading C string from memory at pointer: ".concat(ptr));\n    console.log("Memory buffer size: ".concat(memory.byteLength));\n    var mem = new Uint8Array(memory);\n    var end = ptr;\n    var memLength = mem.length;\n\n    // Check for out-of-bounds access\n    if (ptr >= memLength) {\n      throw new Error("readCString: Pointer ".concat(ptr, " is outside WASM memory bounds."));\n    }\n\n    // Find null terminator, but stop at memory boundary\n    while (end < memLength && mem[end] !== 0) {\n      end++;\n    }\n    if (end >= mem.length) {\n      throw new Error("readCString: Unterminated string (no null byte found).");\n    }\n\n    // Decode the string\n    var result = new TextDecoder().decode(mem.subarray(ptr, end));\n    console.log("Successfully read string of length ".concat(end - ptr));\n    return result;\n  } catch (error) {\n    console.error(\'Error in readCString:\', error);\n    throw new Error("Error in readCString: ".concat(error.message || String(error)));\n  }\n}\n\n/**\n * Helper: Write a JS string to WASM memory (returns pointer)\n */\nfunction writeCString(str, wInstance) {\n  if (!wInstance || !wInstance.exports || !wInstance.exports.memory || !wInstance.exports.memory.buffer) {\n    console.error(\'WASM instance structure:\', wInstance);\n    throw new Error(\'Invalid WASM instance structure in writeCString\');\n  }\n  try {\n    var lengthNeeded = str.length + 1;\n    var ptr = wInstance.exports.malloc_bytes_hs(str.length + 1); // +1 for null terminator\n    console.log("Allocated memory at pointer: ".concat(ptr, " for string length: ").concat(str.length));\n    var mem = new Uint8Array(wInstance.exports.memory.buffer);\n    console.log("Memory buffer size: ".concat(mem.length));\n\n    // Check if pointer is valid and space is sufficient\n    if (ptr + lengthNeeded >= mem.length) {\n      wInstance.exports.free_hs(ptr); // Avoid leaking memory\n      throw new Error("writeCString: String \'".concat(str, "\' exceeds allocated WASM memory."));\n    }\n    for (var i = 0; i < str.length; i++) {\n      mem[ptr + i] = str.charCodeAt(i);\n    }\n    mem[ptr + str.length] = 0; // Null-terminate\n    return ptr;\n  } catch (error) {\n    console.error(\'Error in writeCString:\', error);\n    throw new Error("Error in writeCString: ".concat(error.message || String(error)));\n  }\n}\n\n/**\n * Helper: Convert base64 string to byte array\n */\nfunction base64ToBytes(base64) {\n  var binStr = atob(base64);\n  var bytes = new Uint8Array(binStr.length);\n  for (var i = 0; i < binStr.length; i++) {\n    bytes[i] = binStr.charCodeAt(i);\n  }\n  return bytes;\n}\n;// ./src/components/decoder/HexDecoder.tsx\nfunction HexDecoder_typeof(o) { "@babel/helpers - typeof"; return HexDecoder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, HexDecoder_typeof(o); }\nfunction HexDecoder_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ HexDecoder_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == HexDecoder_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(HexDecoder_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction HexDecoder_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction HexDecoder_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { HexDecoder_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { HexDecoder_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction HexDecoder_slicedToArray(r, e) { return HexDecoder_arrayWithHoles(r) || HexDecoder_iterableToArrayLimit(r, e) || HexDecoder_unsupportedIterableToArray(r, e) || HexDecoder_nonIterableRest(); }\nfunction HexDecoder_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction HexDecoder_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return HexDecoder_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? HexDecoder_arrayLikeToArray(r, a) : void 0; } }\nfunction HexDecoder_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction HexDecoder_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction HexDecoder_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n// Import from our new TypeScript implementation\n\nvar HexDecoder = function HexDecoder() {\n  var _useState = (0,react.useState)(""),\n    _useState2 = HexDecoder_slicedToArray(_useState, 2),\n    input = _useState2[0],\n    setInput = _useState2[1];\n  var _useState3 = (0,react.useState)("utf8"),\n    _useState4 = HexDecoder_slicedToArray(_useState3, 2),\n    format = _useState4[0],\n    setFormat = _useState4[1];\n  var _useState5 = (0,react.useState)(false),\n    _useState6 = HexDecoder_slicedToArray(_useState5, 2),\n    loading = _useState6[0],\n    setLoading = _useState6[1];\n  var _useState7 = (0,react.useState)(null),\n    _useState8 = HexDecoder_slicedToArray(_useState7, 2),\n    result = _useState8[0],\n    setResult = _useState8[1];\n  var _useState9 = (0,react.useState)(null),\n    _useState10 = HexDecoder_slicedToArray(_useState9, 2),\n    error = _useState10[0],\n    setError = _useState10[1];\n  var wasmInstance = (0,react.useRef)(null);\n  var lastHexInput = (0,react.useRef)("");\n  var lastBase64 = (0,react.useRef)("");\n  var initWasm = /*#__PURE__*/function () {\n    var _ref = HexDecoder_asyncToGenerator(/*#__PURE__*/HexDecoder_regeneratorRuntime().mark(function _callee() {\n      var _yield$initializeWasm, inst;\n      return HexDecoder_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (wasmInstance.current) {\n              _context.next = 13;\n              break;\n            }\n            _context.prev = 1;\n            _context.next = 4;\n            return initializeWasmDecoder();\n          case 4:\n            _yield$initializeWasm = _context.sent;\n            inst = _yield$initializeWasm.wasmInstance;\n            wasmInstance.current = inst;\n            console.log("WASM decoder initialized successfully");\n            _context.next = 13;\n            break;\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context["catch"](1);\n            console.warn("Failed to initialize WASM decoder, will use JS fallback:", _context.t0);\n            // We\'ll continue without a WASM instance and use the JS fallback\n          case 13:\n            return _context.abrupt("return", wasmInstance.current);\n          case 14:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 10]]);\n    }));\n    return function initWasm() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var decode = /*#__PURE__*/function () {\n    var _ref2 = HexDecoder_asyncToGenerator(/*#__PURE__*/HexDecoder_regeneratorRuntime().mark(function _callee2() {\n      var inst, hexs, txt, arr, out;\n      return HexDecoder_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            setError(null);\n            setResult(null);\n            if (input.trim()) {\n              _context2.next = 5;\n              break;\n            }\n            setError("Please paste some hexadecimal strings first.");\n            return _context2.abrupt("return");\n          case 5:\n            setLoading(true);\n            _context2.prev = 6;\n            _context2.next = 9;\n            return initWasm();\n          case 9:\n            inst = _context2.sent;\n            txt = input.trim();\n            if (txt.startsWith("[") && txt.endsWith("]")) {\n              try {\n                arr = JSON.parse(txt);\n                hexs = Array.isArray(arr) ? arr : [String(arr)];\n              } catch (_unused) {\n                hexs = txt.split("\\n").filter(function (l) {\n                  return l.trim();\n                });\n              }\n            } else {\n              hexs = txt.split("\\n").map(function (l) {\n                return l.trim();\n              }).filter(Boolean);\n            }\n\n            // Only process if input has changed\n            if (!(txt !== lastHexInput.current)) {\n              _context2.next = 20;\n              break;\n            }\n            console.log("Processing new hex input");\n            // Our reconstructOriginalBytes function can now handle a null WASM instance\n            _context2.next = 16;\n            return reconstructOriginalBytes(inst, hexs);\n          case 16:\n            lastBase64.current = _context2.sent;\n            lastHexInput.current = txt;\n            _context2.next = 21;\n            break;\n          case 20:\n            console.log("Using cached result");\n          case 21:\n            if (format === "utf8") {\n              try {\n                out = atob(lastBase64.current);\n                console.log("Converted base64 to UTF-8 text");\n              } catch (err) {\n                console.warn("Failed to decode base64 as UTF-8, using raw base64:", err);\n                out = lastBase64.current;\n              }\n            } else {\n              // For binary formats we still hold base64; user can download or preview elsewhere\n              out = lastBase64.current;\n            }\n            setResult(out);\n            _context2.next = 29;\n            break;\n          case 25:\n            _context2.prev = 25;\n            _context2.t0 = _context2["catch"](6);\n            console.error("Decoding error:", _context2.t0);\n            setError("Decoding error: " + (_context2.t0.message || _context2.t0.toString()));\n          case 29:\n            _context2.prev = 29;\n            setLoading(false);\n            return _context2.finish(29);\n          case 32:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[6, 25, 29, 32]]);\n    }));\n    return function decode() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var tabs = [{\n    key: "utf8",\n    label: "Text (UTF8)"\n  }, {\n    key: "base64",\n    label: "Base64"\n  }, {\n    key: "png",\n    label: "PNG"\n  }, {\n    key: "jpeg",\n    label: "JPEG"\n  }, {\n    key: "pdf",\n    label: "PDF"\n  }];\n  return /*#__PURE__*/react.createElement("div", {\n    className: "bg-white/10 rounded-4xl backdrop-blur-[10px] p-8 max-w-5xl w-full mx-auto text-white"\n  }, /*#__PURE__*/react.createElement("h2", {\n    className: "text-2xl font-bold text-white mb-4"\n  }, "Metadata:"), /*#__PURE__*/react.createElement("div", {\n    className: "mb-6"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "rounded-3xl bg-white/10 backdrop-blur-[10px] flex flex-col gap-2 relative"\n  }, input.trim() === "" && /*#__PURE__*/react.createElement("div", {\n    className: "font-mono text-base text-[#C3D5F7] mb-1 absolute inset-0 p-8 flex flex-col pointer-events-none"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "block mb-1"\n  }, "Paste your hex strings here, one per line or as an array:"), /*#__PURE__*/react.createElement("span", {\n    className: "italic mt-6"\n  }, "Example (line by line):"), /*#__PURE__*/react.createElement("pre", {\n    className: "mb-1"\n  }, "48656C6C6F20576F726C64", "\\n", "4D756C74694C696E65"), /*#__PURE__*/react.createElement("span", {\n    className: "italic mt-6"\n  }, "Or (array format):"), /*#__PURE__*/react.createElement("pre", null, "[\\"48656C6C6F\\", \\"576F726C64\\"]")), /*#__PURE__*/react.createElement("textarea", {\n    value: input,\n    onChange: function onChange(e) {\n      return setInput(e.target.value);\n    },\n    className: "w-full min-h-[20rem] p-8 font-mono text-sm text-gray-200 bg-transparent rounded-lg resize-y focus:outline-none focus:border-blue-400"\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "mb-6"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-white font-medium mb-2"\n  }, "Output:"), /*#__PURE__*/react.createElement("div", {\n    className: "inline-flex rounded-lg p-1 gap-2"\n  }, tabs.map(function (tab) {\n    return /*#__PURE__*/react.createElement("button", {\n      key: tab.key,\n      onClick: function onClick() {\n        return setFormat(tab.key);\n      },\n      className: "px-2 py-1 text-sm font-medium rounded-lg transition ".concat(format === tab.key ? "bg-[#051023] bg-opacity-50 text-white" : "text-gray-200 bg-white/10")\n    }, tab.label);\n  }))), /*#__PURE__*/react.createElement("button", {\n    onClick: decode,\n    disabled: loading,\n    className: "w-full py-3 rounded-full bg-blue-600 hover:bg-blue-700 text-white font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed"\n  }, loading ? "Decoding" : "Decode"), (result || error) && /*#__PURE__*/react.createElement("div", {\n    className: "mt-8"\n  }, /*#__PURE__*/react.createElement("h3", {\n    className: "text-lg font-semibold text-white mb-2"\n  }, error ? "Error" : "Decoded Result"), /*#__PURE__*/react.createElement("div", {\n    className: "mt-4 bg-white/10 rounded-4xl backdrop-blur-[10px] border-l-4 border-blue-500 p-5 font-mono text-sm text-gray-100 max-h-64 overflow-y-auto whitespace-pre-wrap"\n  }, error ? error : format === "png" || format === "jpeg" ? /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center"\n  }, /*#__PURE__*/react.createElement("img", {\n    src: "data:image/".concat(format, ";base64,").concat(result),\n    alt: "Decoded image",\n    className: "max-w-full max-h-56 object-contain"\n  }), /*#__PURE__*/react.createElement("a", {\n    href: "data:image/".concat(format, ";base64,").concat(result),\n    download: "decoded.".concat(format),\n    className: "mt-3 text-blue-400 hover:text-blue-300 underline text-sm"\n  }, "Download Image")) : format === "pdf" ? /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center"\n  }, /*#__PURE__*/react.createElement("iframe", {\n    src: "data:application/pdf;base64,".concat(result),\n    className: "w-full h-56 border-0",\n    title: "PDF Viewer"\n  }), /*#__PURE__*/react.createElement("a", {\n    href: "data:application/pdf;base64,".concat(result),\n    download: "decoded.pdf",\n    className: "mt-3 text-blue-400 hover:text-blue-300 underline text-sm"\n  }, "Download PDF")) : result)));\n};\n/* harmony default export */ const decoder_HexDecoder = (HexDecoder);\n;// ./src/components/uploads/useRewardAccounts.ts\nfunction useRewardAccounts_typeof(o) { "@babel/helpers - typeof"; return useRewardAccounts_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, useRewardAccounts_typeof(o); }\nfunction useRewardAccounts_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ useRewardAccounts_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == useRewardAccounts_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(useRewardAccounts_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction useRewardAccounts_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction useRewardAccounts_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { useRewardAccounts_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { useRewardAccounts_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction useRewardAccounts_slicedToArray(r, e) { return useRewardAccounts_arrayWithHoles(r) || useRewardAccounts_iterableToArrayLimit(r, e) || useRewardAccounts_unsupportedIterableToArray(r, e) || useRewardAccounts_nonIterableRest(); }\nfunction useRewardAccounts_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction useRewardAccounts_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return useRewardAccounts_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? useRewardAccounts_arrayLikeToArray(r, a) : void 0; } }\nfunction useRewardAccounts_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction useRewardAccounts_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction useRewardAccounts_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\nfunction useRewardAccounts() {\n  var _useState = (0,react.useState)([]),\n    _useState2 = useRewardAccounts_slicedToArray(_useState, 2),\n    rewardAccounts = _useState2[0],\n    setRewardAccounts = _useState2[1];\n  var _useWallet = useWallet(),\n    defaultWallet = _useWallet.defaultWallet,\n    getWalletApi = _useWallet.getWalletApi,\n    connectedWallets = _useWallet.connectedWallets;\n  (0,react.useEffect)(function () {\n    var fetchRewardAccounts = /*#__PURE__*/function () {\n      var _ref = useRewardAccounts_asyncToGenerator(/*#__PURE__*/useRewardAccounts_regeneratorRuntime().mark(function _callee() {\n        var api, rewardAddresses;\n        return useRewardAccounts_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!(!connectedWallets.length || !defaultWallet)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt("return");\n            case 3:\n              api = getWalletApi(defaultWallet);\n              if (api) {\n                _context.next = 6;\n                break;\n              }\n              throw new Error("Wallet API not found");\n            case 6:\n              _context.next = 8;\n              return api.getRewardAddresses();\n            case 8:\n              rewardAddresses = _context.sent;\n              setRewardAccounts(rewardAddresses);\n              _context.next = 15;\n              break;\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context["catch"](0);\n              console.error("Error fetching reward accounts:", _context.t0);\n            case 15:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 12]]);\n      }));\n      return function fetchRewardAccounts() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    if (connectedWallets.length > 0) fetchRewardAccounts();\n  }, [defaultWallet, connectedWallets, getWalletApi]);\n  return rewardAccounts;\n}\n;// ./src/components/uploads/useUploads.ts\nfunction useUploads_typeof(o) { "@babel/helpers - typeof"; return useUploads_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, useUploads_typeof(o); }\nfunction useUploads_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction useUploads_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? useUploads_ownKeys(Object(t), !0).forEach(function (r) { useUploads_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : useUploads_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction useUploads_defineProperty(e, r, t) { return (r = useUploads_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction useUploads_toPropertyKey(t) { var i = useUploads_toPrimitive(t, "string"); return "symbol" == useUploads_typeof(i) ? i : i + ""; }\nfunction useUploads_toPrimitive(t, r) { if ("object" != useUploads_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != useUploads_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction useUploads_toConsumableArray(r) { return useUploads_arrayWithoutHoles(r) || useUploads_iterableToArray(r) || useUploads_unsupportedIterableToArray(r) || useUploads_nonIterableSpread(); }\nfunction useUploads_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction useUploads_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction useUploads_arrayWithoutHoles(r) { if (Array.isArray(r)) return useUploads_arrayLikeToArray(r); }\nfunction useUploads_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ useUploads_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == useUploads_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(useUploads_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction useUploads_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction useUploads_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { useUploads_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { useUploads_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction useUploads_slicedToArray(r, e) { return useUploads_arrayWithHoles(r) || useUploads_iterableToArrayLimit(r, e) || useUploads_unsupportedIterableToArray(r, e) || useUploads_nonIterableRest(); }\nfunction useUploads_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction useUploads_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return useUploads_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? useUploads_arrayLikeToArray(r, a) : void 0; } }\nfunction useUploads_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction useUploads_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction useUploads_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\nfunction useUploads(_ref) {\n  var _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? 9 : _ref$limit,\n    rewardAccounts = _ref.rewardAccounts;\n  var _useState = (0,react.useState)([]),\n    _useState2 = useUploads_slicedToArray(_useState, 2),\n    allUploads = _useState2[0],\n    setAllUploads = _useState2[1];\n  var _useState3 = (0,react.useState)([]),\n    _useState4 = useUploads_slicedToArray(_useState3, 2),\n    filteredUploads = _useState4[0],\n    setFilteredUploads = _useState4[1];\n  var _useState5 = (0,react.useState)([]),\n    _useState6 = useUploads_slicedToArray(_useState5, 2),\n    displayedUploads = _useState6[0],\n    setDisplayedUploads = _useState6[1];\n  var _useState7 = (0,react.useState)(true),\n    _useState8 = useUploads_slicedToArray(_useState7, 2),\n    loading = _useState8[0],\n    setLoading = _useState8[1];\n  var _useState9 = (0,react.useState)(null),\n    _useState10 = useUploads_slicedToArray(_useState9, 2),\n    error = _useState10[0],\n    setError = _useState10[1];\n  var _useState11 = (0,react.useState)({}),\n    _useState12 = useUploads_slicedToArray(_useState11, 2),\n    pagesData = _useState12[0],\n    setPagesData = _useState12[1];\n  var _useState13 = (0,react.useState)({}),\n    _useState14 = useUploads_slicedToArray(_useState13, 2),\n    lastObjectUlids = _useState14[0],\n    setLastObjectUlids = _useState14[1];\n  var _useState15 = (0,react.useState)(1),\n    _useState16 = useUploads_slicedToArray(_useState15, 2),\n    currentPage = _useState16[0],\n    setCurrentPage = _useState16[1];\n  var _useState17 = (0,react.useState)(false),\n    _useState18 = useUploads_slicedToArray(_useState17, 2),\n    hasMorePages = _useState18[0],\n    setHasMorePages = _useState18[1];\n  (0,react.useEffect)(function () {\n    var fetchInitialUploads = /*#__PURE__*/function () {\n      var _ref2 = useUploads_asyncToGenerator(/*#__PURE__*/useUploads_regeneratorRuntime().mark(function _callee() {\n        var body, response, data, formattedUploads, lastUlid;\n        return useUploads_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!(rewardAccounts.length === 0)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt("return");\n            case 3:\n              setLoading(true);\n              setError(null);\n              body = {\n                limit: limit,\n                rewardAccounts: rewardAccounts\n              };\n              _context.next = 8;\n              return fetch(buildApiUrl("/account-uploads"), {\n                method: "POST",\n                headers: {\n                  "Content-Type": "application/json",\n                  "x-api-key": API_KEY\n                },\n                body: JSON.stringify(body)\n              });\n            case 8:\n              response = _context.sent;\n              if (response.ok) {\n                _context.next = 11;\n                break;\n              }\n              throw new Error("API error: ".concat(response.status));\n            case 11:\n              _context.next = 13;\n              return response.json();\n            case 13:\n              data = _context.sent;\n              formattedUploads = data.objects;\n              setAllUploads(formattedUploads);\n              setFilteredUploads(formattedUploads);\n              setDisplayedUploads(formattedUploads);\n              setPagesData({\n                1: formattedUploads\n              });\n              lastUlid = data.mLastObjectUlid;\n              setLastObjectUlids({\n                1: lastUlid\n              });\n              setHasMorePages(lastUlid !== null);\n              setCurrentPage(1);\n              _context.next = 29;\n              break;\n            case 25:\n              _context.prev = 25;\n              _context.t0 = _context["catch"](0);\n              setError(_context.t0 instanceof Error ? _context.t0.message : "An unknown error occurred");\n              console.error("Error fetching initial uploads:", _context.t0);\n            case 29:\n              _context.prev = 29;\n              setLoading(false);\n              return _context.finish(29);\n            case 32:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 25, 29, 32]]);\n      }));\n      return function fetchInitialUploads() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    fetchInitialUploads();\n  }, [rewardAccounts, limit]);\n  var fetchNextPage = (0,react.useCallback)(/*#__PURE__*/function () {\n    var _ref3 = useUploads_asyncToGenerator(/*#__PURE__*/useUploads_regeneratorRuntime().mark(function _callee2(pageNumber) {\n      var lastUlid, body, response, data, formattedUploads, newLastUlid;\n      return useUploads_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!pagesData[pageNumber]) {\n              _context2.next = 4;\n              break;\n            }\n            setDisplayedUploads(pagesData[pageNumber]);\n            setCurrentPage(pageNumber);\n            return _context2.abrupt("return");\n          case 4:\n            lastUlid = lastObjectUlids[pageNumber - 1];\n            if (lastUlid) {\n              _context2.next = 7;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 7:\n            _context2.prev = 7;\n            setLoading(true);\n            body = {\n              lastObjectUlid: lastUlid,\n              limit: limit,\n              rewardAccounts: rewardAccounts\n            };\n            _context2.next = 12;\n            return fetch(buildApiUrl("/account-uploads"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY\n              },\n              body: JSON.stringify(body)\n            });\n          case 12:\n            response = _context2.sent;\n            if (response.ok) {\n              _context2.next = 15;\n              break;\n            }\n            throw new Error("API error: ".concat(response.status));\n          case 15:\n            _context2.next = 17;\n            return response.json();\n          case 17:\n            data = _context2.sent;\n            formattedUploads = data.objects;\n            setAllUploads(function (prev) {\n              return [].concat(useUploads_toConsumableArray(prev), useUploads_toConsumableArray(formattedUploads));\n            });\n            setPagesData(function (prev) {\n              return useUploads_objectSpread(useUploads_objectSpread({}, prev), {}, useUploads_defineProperty({}, pageNumber, formattedUploads));\n            });\n            newLastUlid = data.mLastObjectUlid;\n            setLastObjectUlids(function (prev) {\n              return useUploads_objectSpread(useUploads_objectSpread({}, prev), {}, useUploads_defineProperty({}, pageNumber, newLastUlid));\n            });\n            setHasMorePages(newLastUlid !== null);\n            setDisplayedUploads(formattedUploads);\n            setCurrentPage(pageNumber);\n            _context2.next = 32;\n            break;\n          case 28:\n            _context2.prev = 28;\n            _context2.t0 = _context2["catch"](7);\n            setError(_context2.t0 instanceof Error ? _context2.t0.message : "An unknown error occurred");\n            console.error("Error fetching page ".concat(pageNumber, ":"), _context2.t0);\n          case 32:\n            _context2.prev = 32;\n            setLoading(false);\n            return _context2.finish(32);\n          case 35:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[7, 28, 32, 35]]);\n    }));\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [pagesData, lastObjectUlids, limit, rewardAccounts]);\n  return {\n    allUploads: allUploads,\n    filteredUploads: filteredUploads,\n    displayedUploads: displayedUploads,\n    setFilteredUploads: setFilteredUploads,\n    setDisplayedUploads: setDisplayedUploads,\n    loading: loading,\n    error: error,\n    pagesData: pagesData,\n    lastObjectUlids: lastObjectUlids,\n    currentPage: currentPage,\n    setCurrentPage: setCurrentPage,\n    hasMorePages: hasMorePages,\n    setAllUploads: setAllUploads,\n    setPagesData: setPagesData,\n    setLastObjectUlids: setLastObjectUlids,\n    setHasMorePages: setHasMorePages,\n    fetchNextPage: fetchNextPage\n  };\n}\n;// ./src/components/uploads/UploadCard.tsx\n\n\nvar getImageSrc = function getImageSrc(upload) {\n  if (upload.thumbnailUrl) return upload.thumbnailUrl;\n  if (upload.objectData && upload.objectType && upload.objectType.startsWith("image/")) {\n    return "data:".concat(upload.objectType, ";base64,").concat(upload.objectData);\n  }\n  return undefined;\n};\nvar formatDate = function formatDate(dateString) {\n  if (!dateString) return "Uncompleted";\n  var date = new Date(dateString);\n  if (isNaN(date.getTime())) return "Uncompleted";\n  return date.toLocaleDateString();\n};\nvar UploadCard = function UploadCard(_ref) {\n  var upload = _ref.upload,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "bg-gradient-to-b from-[rgba(30,30,60,0.7)] to-[rgba(20,20,40,0.7)] rounded-lg p-4 flex flex-col h-full border border-[rgba(255,255,255,0.1)] transition-all duration-200 hover:transform hover:-translate-y-1.5 hover:shadow-lg"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-xs text-[var(--color-text-secondary)] mb-1.5"\n  }, formatDate(upload.indexingTxSubmittedAt || "")), /*#__PURE__*/react.createElement("div", {\n    className: "text-lg font-bold mb-2.5 text-[var(--color-primary-tw)]"\n  }, upload.name), /*#__PURE__*/react.createElement("p", {\n    className: "text-sm text-[var(--color-light)] mb-4 flex-grow overflow-hidden text-ellipsis line-clamp-3"\n  }, upload.description), /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-[150px] bg-[var(--color-bg-card)] rounded-md flex items-center justify-center mb-4 overflow-hidden"\n  }, upload.objectType === "text/plain" && upload.objectData ? /*#__PURE__*/react.createElement("pre", {\n    className: "whitespace-pre-wrap break-all bg-[#f6f6f6] p-3 rounded-md max-h-[300px] overflow-auto w-full h-full"\n  }, atob(upload.objectData)) : upload.fileType && upload.fileType.toLowerCase().includes("pdf") && upload.objectData ? /*#__PURE__*/react.createElement("iframe", {\n    src: "data:application/pdf;base64,".concat(upload.objectData),\n    title: upload.name,\n    className: "w-full h-full object-cover"\n  }) : getImageSrc(upload) ? /*#__PURE__*/react.createElement("img", {\n    src: getImageSrc(upload),\n    alt: upload.name,\n    className: "w-full h-full object-cover"\n  }) : /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-full flex items-center justify-center bg-[var(--color-bg-card)]"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-3xl text-[var(--color-text-secondary)]"\n  }, "\\uD83D\\uDDBC\\uFE0F"))), upload.fileType && upload.fileType.toLowerCase().includes("text") && /*#__PURE__*/react.createElement("button", {\n    className: "bg-transparent border border-[rgba(255,255,255,0.2)] text-[var(--color-primary-tw)] py-2 px-3 rounded-md cursor-pointer transition-colors duration-200 hover:bg-[rgba(255,255,255,0.1)] text-sm",\n    onClick: function onClick() {\n      return onCopyText(upload.description || "");\n    }\n  }, "Copy text"), upload.indexingTxId && /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: upload.indexingTxId\n  }), upload.shardTxIds && upload.shardTxIds.length > 0 && upload.shardTxIds.map(function (txId, index) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      txId: txId,\n      key: index\n    });\n  }));\n};\n/* harmony default export */ const uploads_UploadCard = (UploadCard);\n;// ./src/components/uploads/UploadsGrid.tsx\n\n\nvar UploadsGrid = function UploadsGrid(_ref) {\n  var uploads = _ref.uploads,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "grid grid-cols-3 gap-5 mb-8 md:grid-cols-2 sm:grid-cols-1"\n  }, uploads.map(function (upload) {\n    return /*#__PURE__*/react.createElement(uploads_UploadCard, {\n      key: upload.id,\n      upload: upload,\n      onCopyText: onCopyText\n    });\n  }));\n};\n/* harmony default export */ const uploads_UploadsGrid = (UploadsGrid);\n;// ./src/components/uploads/UploadListItem.tsx\n\n\nvar UploadListItem_getImageSrc = function getImageSrc(upload) {\n  if (upload.thumbnailUrl) return upload.thumbnailUrl;\n  if (upload.objectData && upload.objectType && upload.objectType.startsWith("image/")) {\n    return "data:".concat(upload.objectType, ";base64,").concat(upload.objectData);\n  }\n  return undefined;\n};\nvar UploadListItem_formatDate = function formatDate(dateString) {\n  if (!dateString) return "Uncompleted";\n  var date = new Date(dateString);\n  if (isNaN(date.getTime())) return "Uncompleted";\n  return date.toLocaleDateString();\n};\nvar UploadListItem = function UploadListItem(_ref) {\n  var upload = _ref.upload,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "bg-gradient-to-r from-[rgba(30,30,60,0.7)] to-[rgba(20,20,40,0.7)] rounded-lg p-4 grid grid-cols-[1fr_2fr_100px] gap-4 border border-[rgba(255,255,255,0.1)] transition-all duration-200 hover:transform hover:-translate-y-0.5 hover:shadow-lg items-center md:grid-cols-1 md:grid-rows-[auto_auto_auto]"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-1.5"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-xs text-[var(--color-text-secondary)]"\n  }, UploadListItem_formatDate(upload.indexingTxSubmittedAt || "")), /*#__PURE__*/react.createElement("div", {\n    className: "text-lg font-bold text-[var(--color-primary-tw)]"\n  }, upload.name)), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2.5"\n  }, /*#__PURE__*/react.createElement("p", {\n    className: "text-sm text-[var(--color-light)] overflow-hidden text-ellipsis line-clamp-2"\n  }, upload.description), upload.fileType && upload.fileType.toLowerCase().includes("text") && /*#__PURE__*/react.createElement("button", {\n    className: "bg-transparent border border-[rgba(255,255,255,0.2)] text-[var(--color-primary-tw)] py-2 px-3 rounded-md cursor-pointer transition-colors duration-200 hover:bg-[rgba(255,255,255,0.1)] text-sm",\n    onClick: function onClick() {\n      return onCopyText(upload.description || "");\n    }\n  }, "Copy text")), /*#__PURE__*/react.createElement("div", {\n    className: "w-[100px] h-[100px] bg-[var(--color-bg-card)] rounded-md flex items-center justify-center overflow-hidden md:w-full md:h-[150px] md:order-first"\n  }, upload.objectType === "text/plain" && upload.objectData ? /*#__PURE__*/react.createElement("pre", {\n    className: "whitespace-pre-wrap break-all bg-[#f6f6f6] p-3 rounded-md max-h-[300px] overflow-auto w-full h-full"\n  }, atob(upload.objectData)) : upload.fileType && upload.fileType.toLowerCase().includes("pdf") && upload.objectData ? /*#__PURE__*/react.createElement("iframe", {\n    src: "data:application/pdf;base64,".concat(upload.objectData),\n    title: upload.name,\n    className: "w-full h-full object-cover"\n  }) : UploadListItem_getImageSrc(upload) ? /*#__PURE__*/react.createElement("img", {\n    src: UploadListItem_getImageSrc(upload),\n    alt: upload.name,\n    className: "w-full h-full object-cover"\n  }) : /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-full flex items-center justify-center bg-[var(--color-bg-card)]"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-3xl text-[var(--color-text-secondary)]"\n  }, "\\uD83D\\uDDBC\\uFE0F")), upload.indexingTxId && /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: upload.indexingTxId\n  }), upload.shardTxIds && upload.shardTxIds.length > 0 && upload.shardTxIds.map(function (txId, idx) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      txId: txId,\n      key: idx\n    });\n  })));\n};\n/* harmony default export */ const uploads_UploadListItem = (UploadListItem);\n;// ./src/components/uploads/UploadsList.tsx\n\n\nvar UploadsList = function UploadsList(_ref) {\n  var uploads = _ref.uploads,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 mb-8"\n  }, uploads.map(function (upload, idx) {\n    return /*#__PURE__*/react.createElement(uploads_UploadListItem, {\n      key: upload.id || idx,\n      upload: upload,\n      onCopyText: onCopyText\n    });\n  }));\n};\n/* harmony default export */ const uploads_UploadsList = (UploadsList);\n;// ./src/components/uploads/UploadsFilters.tsx\n\nvar UploadsFilters = function UploadsFilters(_ref) {\n  var dateFilter = _ref.dateFilter,\n    setDateFilter = _ref.setDateFilter,\n    typeFilter = _ref.typeFilter,\n    setTypeFilter = _ref.setTypeFilter,\n    searchQuery = _ref.searchQuery,\n    setSearchQuery = _ref.setSearchQuery,\n    onSearch = _ref.onSearch,\n    dateFilterOptions = _ref.dateFilterOptions,\n    typeFilterOptions = _ref.typeFilterOptions,\n    viewMode = _ref.viewMode,\n    setViewMode = _ref.setViewMode;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center w-full flex-wrap gap-8 font-thin"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center border border-white rounded-full overflow-hidden"\n  }, /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return setViewMode("grid");\n    },\n    className: "p-4 cursor-pointer ".concat(viewMode === "grid" ? "bg-[rgba(255,255,255,0.15)]" : ""),\n    "aria-label": "Grid view"\n  }, /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "16",\n    height: "16",\n    viewBox: "0 0 16 16",\n    fill: "none"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M0.888889 7.11111H6.22222C6.45797 7.11111 6.68406 7.01746 6.85076 6.85076C7.01746 6.68406 7.11111 6.45797 7.11111 6.22222V0.888889C7.11111 0.653141 7.01746 0.427048 6.85076 0.260349C6.68406 0.0936505 6.45797 0 6.22222 0H0.888889C0.653141 0 0.427048 0.0936505 0.260349 0.260349C0.0936505 0.427048 0 0.653141 0 0.888889V6.22222C0 6.45797 0.0936505 6.68406 0.260349 6.85076C0.427048 7.01746 0.653141 7.11111 0.888889 7.11111ZM9.77778 7.11111H15.1111C15.3469 7.11111 15.573 7.01746 15.7397 6.85076C15.9064 6.68406 16 6.45797 16 6.22222V0.888889C16 0.653141 15.9064 0.427048 15.7397 0.260349C15.573 0.0936505 15.3469 0 15.1111 0H9.77778C9.54203 0 9.31594 0.0936505 9.14924 0.260349C8.98254 0.427048 8.88889 0.653141 8.88889 0.888889V6.22222C8.88889 6.45797 8.98254 6.68406 9.14924 6.85076C9.31594 7.01746 9.54203 7.11111 9.77778 7.11111ZM0.888889 16H6.22222C6.45797 16 6.68406 15.9064 6.85076 15.7397C7.01746 15.573 7.11111 15.3469 7.11111 15.1111V9.77778C7.11111 9.54203 7.01746 9.31594 6.85076 9.14924C6.68406 8.98254 6.45797 8.88889 6.22222 8.88889H0.888889C0.653141 8.88889 0.427048 8.98254 0.260349 9.14924C0.0936505 9.31594 0 9.54203 0 9.77778V15.1111C0 15.3469 0.0936505 15.573 0.260349 15.7397C0.427048 15.9064 0.653141 16 0.888889 16ZM9.77778 16H15.1111C15.3469 16 15.573 15.9064 15.7397 15.7397C15.9064 15.573 16 15.3469 16 15.1111V9.77778C16 9.54203 15.9064 9.31594 15.7397 9.14924C15.573 8.98254 15.3469 8.88889 15.1111 8.88889H9.77778C9.54203 8.88889 9.31594 8.98254 9.14924 9.14924C8.98254 9.31594 8.88889 9.54203 8.88889 9.77778V15.1111C8.88889 15.3469 8.98254 15.573 9.14924 15.7397C9.31594 15.9064 9.54203 16 9.77778 16Z",\n    fill: "white"\n  }))), /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return setViewMode("list");\n    },\n    className: "p-4 cursor-pointer ".concat(viewMode === "list" ? "bg-[rgba(255,255,255,0.15)]" : ""),\n    "aria-label": "List view"\n  }, /*#__PURE__*/react.createElement("svg", {\n    width: "20",\n    height: "16",\n    viewBox: "0 0 20 16",\n    fill: "none"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M1.73379 6.4C0.848456 6.4 0.133789 7.11467 0.133789 8C0.133789 8.88533 0.848456 9.6 1.73379 9.6C2.61912 9.6 3.33379 8.88533 3.33379 8C3.33379 7.11467 2.61912 6.4 1.73379 6.4ZM1.73379 0C0.848456 0 0.133789 0.714667 0.133789 1.6C0.133789 2.48533 0.848456 3.2 1.73379 3.2C2.61912 3.2 3.33379 2.48533 3.33379 1.6C3.33379 0.714667 2.61912 0 1.73379 0ZM1.73379 12.8C0.848456 12.8 0.133789 13.5253 0.133789 14.4C0.133789 15.2747 0.859122 16 1.73379 16C2.60846 16 3.33379 15.2747 3.33379 14.4C3.33379 13.5253 2.61912 12.8 1.73379 12.8ZM6.00046 15.4667H18.8005C19.3871 15.4667 19.8671 14.9867 19.8671 14.4C19.8671 13.8133 19.3871 13.3333 18.8005 13.3333H6.00046C5.41379 13.3333 4.93379 13.8133 4.93379 14.4C4.93379 14.9867 5.41379 15.4667 6.00046 15.4667ZM6.00046 9.06667H18.8005C19.3871 9.06667 19.8671 8.58667 19.8671 8C19.8671 7.41333 19.3871 6.93333 18.8005 6.93333H6.00046C5.41379 6.93333 4.93379 7.41333 4.93379 8C4.93379 8.58667 5.41379 9.06667 6.00046 9.06667ZM4.93379 1.6C4.93379 2.18667 5.41379 2.66667 6.00046 2.66667H18.8005C19.3871 2.66667 19.8671 2.18667 19.8671 1.6C19.8671 1.01333 19.3871 0.533333 18.8005 0.533333H6.00046C5.41379 0.533333 4.93379 1.01333 4.93379 1.6Z",\n    fill: "white"\n  })))), /*#__PURE__*/react.createElement("div", {\n    className: "relative flex-grow max-w-md mx-2"\n  }, /*#__PURE__*/react.createElement("form", {\n    onSubmit: onSearch,\n    className: "flex w-full relative"\n  }, /*#__PURE__*/react.createElement("svg", {\n    width: "16",\n    height: "16",\n    viewBox: "0 0 16 16",\n    fill: "none",\n    className: "absolute left-3 top-1/2 -translate-y-1/2"\n  }, /*#__PURE__*/react.createElement("path", {\n    "fill-rule": "evenodd",\n    "clip-rule": "evenodd",\n    d: "M13.875 12.4554L17.875 16.4602C18.0536 16.6589 18.0448 16.9631 17.855 17.1511L17.155 17.8519C17.0611 17.9467 16.9333 18 16.8 18C16.6667 18 16.5389 17.9467 16.445 17.8519L12.445 13.8471C12.3344 13.7362 12.234 13.6156 12.145 13.4867L11.395 12.4855C10.1541 13.4776 8.613 14.0178 7.025 14.0173C3.75261 14.0287 0.909021 11.7686 0.177731 8.5751C-0.553569 5.38161 1.0226 2.10699 3.9731 0.689912C6.92359 -0.727158 10.461 0.0915127 12.491 2.66125C14.521 5.23099 14.5019 8.866 12.445 11.4142L13.445 12.105C13.6012 12.2051 13.7454 12.3226 13.875 12.4554ZM2.025 7.0089C2.025 9.7736 4.26357 12.0149 7.025 12.0149C8.3511 12.0149 9.6229 11.4875 10.5605 10.5487C11.4982 9.6099 12.025 8.3366 12.025 7.0089C12.025 4.24412 9.7864 2.00285 7.025 2.00285C4.26357 2.00285 2.025 4.24412 2.025 7.0089Z",\n    fill: "white"\n  })), /*#__PURE__*/react.createElement("input", {\n    type: "text",\n    placeholder: "Search",\n    value: searchQuery,\n    onChange: function onChange(e) {\n      return setSearchQuery(e.target.value);\n    },\n    className: "w-full py-2 px-4 rounded-full bg-[rgba(255,255,255,0.1)] text-white border border-white pl-10"\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center gap-2"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-sm text-white"\n  }, "Filter by Date"), /*#__PURE__*/react.createElement("select", {\n    value: dateFilter,\n    onChange: function onChange(e) {\n      return setDateFilter(e.target.value);\n    },\n    className: "py-1 px-3 rounded-full bg-[rgba(255,255,255,0.1)] text-white border border-white"\n  }, dateFilterOptions.map(function (option) {\n    return /*#__PURE__*/react.createElement("option", {\n      key: option.id,\n      value: option.id\n    }, option.label);\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "flex justify-center items-center gap-2"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-sm text-white"\n  }, "Filter by Type"), typeFilterOptions.map(function (option) {\n    return /*#__PURE__*/react.createElement("button", {\n      key: option.id,\n      onClick: function onClick() {\n        return setTypeFilter(option.id);\n      },\n      className: "py-1.5 px-6 rounded-full border ".concat(typeFilter === option.id ? "!bg-[var(--color-bg-active)] !text-black" : "bg-transparent ", " border-white text-white transition-colors duration-200 hover:bg-[var(--color-bg-hover)] cursor-pointer")\n    }, option.label);\n  }))));\n};\n/* harmony default export */ const uploads_UploadsFilters = (UploadsFilters);\n;// ./src/components/uploads/mockData.ts\nvar mockUploads = [{\n  id: "1",\n  name: "Chart Image",\n  dateUploaded: "2025-03-15T10:30:00Z",\n  description: "A chart showing data visualization",\n  fileType: "png",\n  indexingTxId: undefined,\n  indexingTxSubmittedAt: undefined,\n  objectData: "iVBORw0KGgoAAAANSUhEUgAAA+kAAAIjCAYAAAB/OVoZAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAWmlJREFUeJzt3Qmc3PP9P/BP7kMSEYmECCHu+yaoow1RSumFHkJbWkW1jpK2RLRFVdFD0QO9Hb+i/5aqiJu4qauoM64cjojItcnO//H+rlmzm83KsbvznZnn8/GY7M53vjvzmfl+ZjKv7+fqVCgUCgkAAAAou87lLgAAAADQQEgHAACAnBDSAQAAICeEdAAAAMgJIR0AAAByQkgHAACAnBDSAQAAICeEdAAAAMgJIR0AAAByQkgHaGOdOnVKp512Wpve52WXXZbd74svvpjy7Cc/+Ulae+21U5cuXdIWW2xR7uJAE/H+ifdRvJ+qxa233po9p/i5pPv+3//9XyqHSvkc6+jPd4DmhHSgKhW/DC7ucs8996Q8OuOMM9K1116bKtGNN96YvvOd76SddtopXXrppdlzWZxDDz10scfmhhtuSLXk9ddfTyeffHLafffdU9++fT80cN19991p5513Tr17905DhgxJ3/zmN9OsWbM6tMx595e//CWdf/75qVbV8vN/7bXXshD9yCOPLPN9XH/99YI4UFZdy/vwAO3r9NNPT2uttdYi29dZZ52URxFsP/OZz6T999+/yfYvfelL6aCDDko9evRIeXXzzTenzp07p9/97nepe/fuH7p/PJff/va3i2zffPPNUy15+umn049//OO07rrrpk033TRNmjRpsftG8PjYxz6WNtxww3TuueemV155JZ1zzjnpf//7X/rXv/7VoeXOe0h9/PHH07e+9a0m29dcc800Z86c1K1bt1Qtdtlll+w5lb7nFvf8ayWkjx8/Pg0fPnyZe/NESL/gggtaDOrxWnft6usz0L58ygBV7eMf/3jaZpttUqWL7uNxybNp06alXr16LVFAD/FF94tf/GKqZO+9915aYYUVlus+tt566/Tmm2+mAQMGZN2QP/vZzy523+9+97tppZVWylra+/Xrl22LMHL44YdnPRn23HPPVI1mz56d9RxYXtFLoWfPnqmaxImxantOeea1BjqC7u5Azaqrq8uC0WGHHbbIbTNnzsy+jJ1wwglNQuhXvvKVNHjw4Oy2aPH9/e9//6GPE127I0g1F600ERqK4vcIfXGfxa7f8betjeX81a9+lTbeeOOsVXq11VZLRx11VJoxY0aTfXbbbbe0ySabpCeffDLrUh1hZ+jQoenss89eotdpwYIF6Qc/+EEaMWJE9jjxXCIszps3r0nZo4t7lL9Y9vYc9/unP/0pC7dxUiCOYfQyePnllxtvP/roo1OfPn2ycNfcwQcfnHUTX7hwYeO2aIX+yEc+kgXu6HK+zz77pCeeeKLJ38WxiPt87rnn0t57753t94UvfCGNGzcua5mdPn36Io91xBFHpP79+6e5c+cu9rnE/cRz+DBRJydMmJCd2CgG9HDIIYdk5bryyis/9D5eeumltN9++2XPc5VVVknf/va307///e8Wu9jfe++9aa+99korrrhiVmd23XXXdNddd7VYh5999tns9YnnGvvHe6ql1/7DjltpfX3wwQezVuJ47Khv4e9//3t2bKKuR12MOhl1s/RYxt9fd9112XMt1sXi+29xY9KjF0jx+Mdz+OQnP5n++9//LvNzjeMUQxJinzg266+/fuNzWJxPfepTaauttmqybd99980e8//9v//X5LjEtmLPieZj0lt7/kX19fXpRz/6UVp99dWzz7LonRHP68PEfX7jG9/Ink8cw5VXXjk7qdTSGPN4/3z0ox/N9ovH+eEPf5g9bnNLckyb14sdd9wxu9/oJXXRRRc17hOvwbbbbpv9Hsel+WfRHXfckZV3jTXWyB5r2LBh2XsgWseL4thGK3ooHYbT2pj0hx9+ODshHO/LON7xejYfUlX8DI/30HHHHZcGDRqU1bcDDjigxc8OoLZpSQeq2jvvvJPeeOONJtvii1J8uYxgFV+Qrr766nTxxRc3aQGOceERQiNEhPgSF18S44tsBMD4cnjVVVdlX+giFB977LHLXdY//vGP6atf/WrabrvtsnAX4gvr4sQXxejWOWrUqHTkkUdm3aYvvPDCdP/992dfBEu79L799ttZ4Iog8LnPfS5rsT3ppJOy7tXx5bI1UaY4cRDd8I8//vgsJJx55plZiLnmmmsay/7rX/863XfffY1d2OOL9IdpfmyizBF8WhPh4pRTTsmeR5QtvuD+4he/yAJdfFmOYHTggQdmX7QjrJS2TEeY+sc//pEdt2LPhCj7mDFj0ujRo7Nu57FPvI4RsuL+SgNOnLCI/eK26GYeAXLkyJHZsIorrrgiqxtF8+fPz17nT3/6023S+vbYY49lj9+8Z0jU2+jWG2VtTZxAidAUY+CjvsaJiugWfcsttyyyb4TWqBcRqOMkRLTWxkmY+PsIOlFHS8WxiPdE1IuHHnooqwNxEiBez6U5bkXRsyAeP95/cVIiTowVg06EoAg58TPKeeqpp2YnMGLSwvC9730ve9/HUIDzzjsv2xb7Ls5NN92UPVZMeBjvqXivR7liboV4Ls0D7oc91winn/jEJ9Jmm22W1YsIg/G50fwER3NxkiACazyXCHuFQiH7m3jt4zWPkyshfo9tUb6WLMnzP+uss7L7iJOQsW+csIsTTvHebk18tsScCHFcInhHOI/3Snw2xknAYm+HKVOmZCcEo77GfAsRRuPzIYJ1c0tyTEs/x+IEWRyDONkWJ6bisy/eA1/+8pezYSDxmsffx2dovKaln0XxmR3v7/ib+D8gPq/iWMdrFbeFr33ta1mX+TjREp8NHyaOdzxOHLOYkyM+w+L/k3hNbrvttrT99ts32f+YY47JesPE+ypev5g7ID434vMDoFEBoApdeumlhfiIa+nSo0ePxv3+/e9/Z9v+8Y9/NPn7vffeu7D22ms3Xj///POz/f70pz81bps/f35h5MiRhT59+hRmzpzZuD32GzduXOP1MWPGFNZcc81Fyhj7NP8YXmGFFbL9F/d8Xnjhhez6tGnTCt27dy/sueeehYULFzbu98tf/jLb75JLLmnctuuuu2bb/vCHPzRumzdvXmHIkCGFT3/6062+jo888kj2t1/96lebbD/hhBOy7TfffHOT5xnlXxKxb0vHJsramhdffLHQpUuXwo9+9KMm2x977LFC165dG7fX19cXhg4dusjzu/LKK7PHuf3227Pr7777bqF///6Fww8/vMl+U6ZMKay44opNthfLfPLJJy9SrqgH22+/fZNtV199dbb/LbfcUlhSV1111WL/pnhbseylPvvZz2bHszU//elPs7+/9tprG7fNmTOnsMEGGzR5zHjt1l133cLo0aOz34tmz55dWGuttQp77LHHInX4y1/+cpPHOuCAAworr7zyUh+30vp60UUXLfIcogzNfe1rXyv07t27MHfu3MZt++yzT4vvuXj/xH3H+6loiy22KKyyyiqFN998s3Hbf/7z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1zR37tzstSinGBPfpUuX5b4fIR0AAKACzZo1K73yyivZGty1qlAopCFDhmSrdy3JpGztKR4/llfr06fPct2PkA4AAFBhotU4AnrMbD5o0KCyB9Ryqa+vz05WRDDu3LlzWU8WTJ8+PTsm66677nK1qAvpAAAAFdjNO4JhBPRevXqlWlVfX5/mz5+fevbsWdaQHuJYvPjii9mxWZ6QbuI4AACAClWrLejVfCyEdAAAAMgJIR0AAAByQkgHAACAnBDSAQAA6BCHHnpoNna7+eXZZ58td9Fyw+zuAAAAdJi99torXXrppYvMjE4DLekAAAB0mB49eqQhQ4Y0uSxuybLLLrss9e/fP/3zn/9M66+/frYu/Gc+85k0e/bs9Pvf/z6tvfbaafjw4enYY4/N1o4vmjdvXjrhhBPS0KFD0worrJC23377dOuttzbe/uabb6aDDz44uz3uc9NNN01//etfmzz2brvtlr75zW+m73znO2nAgAFZOU877bRUEy3pF1xwQfrJT36SpkyZkjbffPP0i1/8Im233XaLPUiHHXbYIgd57ty5HVRaAACA/Nlmm22yTNXRIrw+8MAD7Xb/s2fPTj//+c/T5Zdfnt599930qU99Kh1wwAGN4f3xxx9PY8aMSTvvvHM68MADs785+uij05NPPpn9zWqrrZauueaarAX/scceS+uuu26WH7feeut00kknpX79+qXrrrsufelLX0ojRoxokkXjRMBxxx2X7r333jRp0qSsu/5OO+2U9thjj+oN6VdccUX2pC+66KLs7Mb555+fRo8enZ5++um0yiqrtPg38SLG7UXWBgQAAGpdBPRXX3015V0E6z59+jRe//jHP56uuuqqxe5fV1eXLrzwwixAh2hJ/+Mf/5imTp2atYKvvvrqWav3LbfckoX0yZMnZ93p42cE9BCt6jfccEO2/Ywzzsha0GNb0THHHJP+/e9/pyuvvLJJSN9ss83SuHHjst8j3P/yl79MEydOrO6Qfu6556bDDz+8sXU8wnqcxbjkkkvSySef3OLfRCiPszVVbdas1OOtt1J6/fWUunVLKbp/DByYUmcjFAAAgEWVKyMt7ePuvvvuWeguiu7orendu3djQA+DBw/OurhH0K+vr2/cNm3atOz3aC2Pru/rrbdek/uJLvArr7xy9nvcHmE9Qnmc2Jg/f352ezxWqQjppVZd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vjBw4MDC2LFjG/d5/vnnC7179y4cd9xxhSeffLLwi1/8otClS5fCDTfc0OHPl/yLOvS9732vcPXVV8fKI4Vrrrmmye1nnXVWYcUVVyxce+21hf/85z+F/fbbr7DWWmsV5syZ07jPXnvtVdh8880L99xzT+GOO+4orLPOOoWDDz648fZ33nmnMHjw4MIXvvCFwuOPP17461//WujVq1fh4osvbtznrrvuyurp2WefndXb73//+4Vu3boVHnvssQ56JajkejpmzJisHpZ+tr711ltN9lFPaS+jR48uXHrppVm9eeSRRwp77713YY011ijMmjWrw/9/952WZa2ju+66a1ZfSj9H43OxVuqokJ5D2223XeGoo45qvL5w4cLCaqutVjjzzDPLWi6qT4T0+JLYkhkzZmRf9q666qrGbf/973+zL6STJk3KrscHYufOnQtTpkxp3OfCCy8s9OvXrzBv3rzs+ne+853sRECpAw88MPuAhtY0Dz/19fWFIUOGFH7yk580qac9evTIAkyI/4Tj7+6///7Gff71r38VOnXqVHj11Vez67/61a8KK620UmMdDSeddFJh/fXXb7z+uc99rrDPPvs0Kc/2229f+NrXvtZOz5ZKtbiQ/slPfnKxf6Oe0pGmTZuW1bfbbrutw/9/952WZamjxZB+7LHHFhan2uuo7u45M3/+/PTggw9mXTiLOnfunF2fNGlSWctGdYquwtFlc+211866XkbXoRD1sK6urkldjC6Va6yxRmNdjJ/RvXLw4MGN+4wePTrNnDkzPfHEE437lN5HcR/1maX1wgsvpClTpjSpTyuuuGLWNa20TkbX4W222aZxn9g/Pkfvvffexn122WWX1L179yZ1Mrravf322437qLcsj+hiGd0v119//XTkkUemN998s/E29ZSO9M4772Q/BwwY0KH/v/tOy7LW0aI///nPaeDAgWmTTTZJY8eOTbNnz268rdrraNeyPjqLeOONN9LChQubVLgQ15966qmylYvqFOEmxubEl8jXX389jR8/Phv/+Pjjj2dhKL4cxhfJ5nUxbgvxs6W6WryttX3iQ3TOnDnZuGJYEsU61VJ9Kq1vEYxKde3aNfuPv3SftdZaa5H7KN620korLbbeFu8DWhPjzz/1qU9l9ey5555L3/3ud9PHP/7x7Etfly5d1FM6TH19ffrWt76VdtpppyzohI76/z1OJvlOy7LU0fD5z38+rbnmmllDUszPcdJJJ2UnKa+++uqaqKNCOtSw+NJYtNlmm2WhPT4Qr7zySuEZYBkddNBBjb9HS098vo4YMSJrXf/Yxz5W1rJRW2JyuDjxfuedd5a7KLBUdfSII45o8jkaE8bG52ec+IzP02qnu3vORJeOOMvefIbNuD5kyJCylYvaEGfV11tvvfTss89m9S26Ac2YMWOxdTF+tlRXi7e1tk/MaOxEAEujWKda+3yMn9OmTWtye8z0GjNpt0W99TnMsojhRPH/e3y2BvWUjnD00Uenf/7zn+mWW25Jq6++euP2jvr/3XdalrWOtiQakkLp52g111EhPWei+9HWW2+dJk6c2KQbSFwfOXJkWctG9Yvlf+IMZZytjHrYrVu3JnUxuhnFmPViXYyfjz32WJMvmxMmTMg+/DbaaKPGfUrvo7iP+szSiq6/8Z9maX2KLmsxhre0TsYXzxhjVnTzzTdnn6PF/+Bjn1hCK8ZkltbJGPYRXYiL+6i3tJVXXnklG5Men61BPaU9xXyGEX6uueaarF41HzbRUf+/+07LstbRljzyyCPZz9LP0aquo2Wdto4WxVIAMVvxZZddls0Ae8QRR2RLAZTOXght4fjjjy/ceuuthRdeeCFbyieWsYjlK2KWzeISLbEkxs0335wt0TJy5Mjs0nz5iz333DNbQiOWtBg0aFCLy1+ceOKJ2eyxF1xwgSXYWKx33303W0olLvFf1Lnnnpv9/tJLLzUuwRafh3//+98Ljz76aDaDdktLsG255ZaFe++9t3DnnXcW1l133SZLW8XMxrG01Ze+9KVs+Zf4zI062nxpq65duxbOOeecrN7GSgiWtmJJ6mncdsIJJ2SzZMdn60033VTYaqutsno4d+7cxvtQT2kvRx55ZLZUZfz/Xrp81ezZsxv36aj/332nZVnq6LPPPls4/fTTs7oZn6Pxf/7aa69d2GWXXWqmjgrpORXr+MWHZ6zbF0sDxDqq0NZiGYpVV101q2dDhw7NrscHY1EEn2984xvZMkDxIXfAAQdkH6KlXnzxxcLHP/7xbP3eCPgR/Ovq6prsc8sttxS22GKL7HHiQzbWxoSWRF2J0NP8EktaFZdhO+WUU7LwEv+pfuxjHys8/fTTTe7jzTffzMJOnz59sqVYDjvssCw4lYo11nfeeefsPqLuR/hv7sorryyst956Wb2NJVyuu+66dn72VEM9jS+Z8aUxvixGYF5zzTWzdXebf+FTT2kvLdXNuJT+39uR/7/7TsvS1tHJkydngXzAgAHZ598666yTBe3SddKrvY52in/K25YPAAAABGPSAQAAICeEdAAAAMgJIR0AAAByQkgHAACAnBDSAQAAICeEdAAAAMgJIR0AAAByQkgHAACAnBDSAYAOd9lll6X+/fuXuxgAkDtCOgDk2JQpU9Kxxx6b1llnndSzZ880ePDgtNNOO6ULL7wwzZ49O1WC4cOHp/PPP7/JtgMPPDA988wzZSsTAORV13IXAABo2fPPP58F8mhxPuOMM9Kmm26aevTokR577LH061//Og0dOjTtt99+ZSlboVBICxcuTF27LttXiV69emUXAKApLekAkFPf+MY3shD8wAMPpM997nNpww03TGuvvXb65Cc/ma677rq07777ZvvNmDEjffWrX02DBg1K/fr1Sx/96EfTf/7zn8b7Oe2009IWW2yR/vjHP2at2iuuuGI66KCD0rvvvtu4T319fTrzzDPTWmutlYXnzTffPP3f//1f4+233npr6tSpU/rXv/6Vtt566+xkwZ133pmee+65rDzRwt+nT5+07bbbpptuuqnx73bbbbf00ksvpW9/+9vZ38dlcd3do3fAiBEjUvfu3dP666+flbdU/O1vf/vbdMABB6TevXunddddN/2///f/2uGVB4DyEdIBIIfefPPNdOONN6ajjjoqrbDCCi3uUwy8n/3sZ9O0adOyAP3ggw+mrbbaKn3sYx9Lb731VuO+Eaavvfba9M9//jO73Hbbbemss85qvD0C+h/+8Id00UUXpSeeeCIL1V/84hez/UqdfPLJ2d/997//TZtttlmaNWtW2nvvvdPEiRPTww8/nPbaa6/s5MHkyZOz/a+++uq0+uqrp9NPPz29/vrr2aUl11xzTdat//jjj0+PP/54+trXvpYOO+ywdMsttzTZb/z48dkJi0cffTR73C984QtNnicAVLwCAJA799xzTyH+m7766qubbF955ZULK6ywQnb5zne+U7jjjjsK/fr1K8ydO7fJfiNGjChcfPHF2e/jxo0r9O7duzBz5szG20888cTC9ttvn/0efxu333333U3u4ytf+Urh4IMPzn6/5ZZbsvJce+21H1r2jTfeuPCLX/yi8fqaa65ZOO+885rsc+mllxZWXHHFxus77rhj4fDDD2+yz2c/+9nC3nvv3Xg9Hv/73/9+4/VZs2Zl2/71r399aJkAoFIYkw4AFeS+++7LuqZHC/K8efOybu3Rmr3yyis32W/OnDlZ63lRdHPv27dv4/VVV101a30Pzz77bDYJ3R577NHkPubPn5+23HLLJtu22WabJtfjsaM7fXS/j1byBQsWZI9dbElfUtEyf8QRRzTZFuPxf/aznzXZFq33RdHDILr3F58HAFQDIR0Acihmc4/u7E8//XST7TEmPRQnXYuQHIE7xow3Vzrmu1u3bk1ui/uOsF+8jxBBOyajKxVjz0s173p/wgknpAkTJqRzzjknK3OU6zOf+UwW8NtDa88DAKqBkA4AORQt49Gy/ctf/jIdc8wxix2XHuPPY5m2mGAuWsuXxUYbbZSF8Wj93nXXXZfqb++666506KGHZpO5FQP/iy++2GSfmAguZoJvTUyKF/c1ZsyYJvcdZQOAWiKkA0BO/epXv8q6fEcX8+hSHl29O3funO6///701FNPZbOsjxo1Ko0cOTLtv//+6eyzz07rrbdeeu2117JW8QjOzbuntyS6wUeLeEwWF63SO++8c3rnnXeykBzdyUuDc3Mxw3pMDheTxUWr9imnnLJIy3acPLj99tuzGeXjZMDAgQMXuZ8TTzwxmxAuutfHc/rHP/6R3W/pTPEAUAuEdADIqViOLGZMjzXSx44dm1555ZUs5EbrcoTqWKItgvH111+fvve972WzoU+fPj0NGTIk7bLLLtmyaEvqBz/4QbaEW8zyHuuzR1f5aKX/7ne/2+rfnXvuuenLX/5y2nHHHbPwfdJJJ6WZM2c22Sdmdo/Z2uP5xDj6hjngmoqTDDH+PLrNxyzvsRTcpZdemi3hBgC1pFPMHlfuQgAAAADWSQcAAIDcENIBAAAgJ4R0AAAAyAkhHQAAAHJCSAcAAICcENIBAAAgJ4R0AAAAyAkhHQAAAHJCSAcAAICcENIBAAAgJ4R0AAAASPnw/wGhg5nU9W+vawAAAABJRU5ErkJggg==",\n  objectType: "image/png",\n  objectUlid: "01JTHRT2RNYTQHNDNS0VPX442S",\n  shardTxIds: []\n}, {\n  id: "2",\n  name: "Graph Visualization",\n  dateUploaded: "2025-03-18T11:45:00Z",\n  description: "Complex graph data visualization",\n  fileType: "png",\n  indexingTxId: undefined,\n  indexingTxSubmittedAt: undefined,\n  objectData: "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lYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpMdHOQDTFxMY1BpAJoC2APlHNDBERERERkTYHgFMA9lRXVTqinJeouEGSpGjnIeKuBawvAZgQ7bwQERERERGZsBfArLoWwNa5wDUmNs4OYA+ARPFeh/Z3osPtt+PGGxN1v0dERERERBRp3333LY796184eeokfqi4ovxoYnVV5dooZSvi6lTgei1o3QvgRgDIGj8Jf/zT02hhax7djBEREREREfmx+Oln8dKKFbh48UvxVp0JXuta4OoAkPqT+AZ4a/Nm9O3fJ9pZIiIiIiIiMqzc9SV+2a0Hzp47Jd7qXBduG64zowrHxMZlAUgFgBefe55BKxERERER1TgtbM3x/oF38ZP4BuKtBVHMTsTUmcAVwCzA/Tzrw9OnRDsvREREREREAWlh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30hfYoR6nlgiqnnqUuB6gyRJ0b7oG3YxsXF9AOwGgOqqyuhmhoiioiCvCBMmTQBQ9/qBmNg4AO7nKznQC9VGbONEVFd16tQFxz77BAAWVldVLohydsKKz7gSERERERGRpTFwJaI6RcwTXJfUxW2muoVtnIio9uOtwkRERERERDUQbxUmIiIiIiIisggGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaXVlcD1lPjPhvUbo5gNIiIiIiKi0Dh56qT47zfRzEck1InAtbqq8hSA0wCwYePfopsZIiIiIiKiIG1YvxE/VFwRf+6JYlYiok4ErtdsBoAt27fiSMkn0c4LERERERFRwBYt/qP47+nqqkpHNPMSCXUpcH0JwHc/VFzBrzLvR7nry2jnh4iIiIiIyLR7B2Xg2GfyxbgFUcxKxNSZwPXa7cKPAsDZc6fwy249sHvXnqjmiYiIiIiIyKhy15e4d1AGdu0uFm/9vbqqcm0UsxQxN0iSFO08RFRMbNxLuBbAAkDa3fegxz33IC3t7ijmioiIiIiISNvxE5/jnX37sP//3lU+11oCoE91VWWtH5gJqIOBKwDExMZlAlgLIDHKWSEiIiIiIjJrYXVV5YJoZyKS6mTgCgAxsXGNAWRee/UBg1giIiIiIrKuvQAcAF669hhknVJnA1ciIiIiIiKqGerM4ExERERERERUMzFwJSIiIiIiIktj4EpERERERESWxsCViIiIiIiILI2BKxEREREREVkaA1ciIiIiIiKyNAauREREREREZGkMXImIiIiIiMjSGLgSERERERGRpTFwJSIiIiIiIkv7/23ZtH5VPDHFAAAAAElFTkSuQmCC",\n  objectType: "image/png",\n  objectUlid: "01JTKET54305R2GHEHECW33A0C",\n  shardTxIds: []\n}, {\n  id: "3",\n  name: "Company Logo",\n  dateUploaded: "2025-05-06T23:20:15Z",\n  description: "Official company logo in PNG format",\n  fileType: "png",\n  indexingTxId: "8dbc61bfd92f4832d7fac744b661ca45bab8e08726cae03be86658c6016bac1f",\n  indexingTxSubmittedAt: "2025-05-06T23:26:25Z",\n  objectData: "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",\n  objectType: "image/png",\n  objectUlid: "01JTKYKXJX5C0Z7J0QX9JVDB6Y",\n  shardTxIds: ["391ebd902eb2d952d42c7642273f08fb89ac7a789ddf3e7fe0d52779a6178835"]\n}, {\n  id: "4",\n  name: "Simple Text Note",\n  dateUploaded: "2025-05-07T10:30:00Z",\n  description: "A basic text note",\n  fileType: "text",\n  indexingTxId: "4c388550759784ef408cfc192453227f99d343bdbcd2f3c1f429cf815fd11125",\n  indexingTxSubmittedAt: undefined,\n  objectData: "SGVsbG8gdGhlcmU=",\n  objectType: "text/plain",\n  objectUlid: "01JTRF45NHFGMMDB0F0WHCMCR4",\n  shardTxIds: ["ac5db4d92ae51edd458008fae300570f102a6846f697fe181d96b62a19736b41"]\n}, {\n  id: "5",\n  name: "Greeting Note",\n  dateUploaded: "2025-05-07T14:22:00Z",\n  description: "A simple greeting message",\n  fileType: "text",\n  indexingTxId: undefined,\n  indexingTxSubmittedAt: undefined,\n  objectData: "SGVsbG8gdGhlcmUhISE=",\n  objectType: "text/plain",\n  objectUlid: "01JTRF9H4RQJ91HMSJ6E4TV2KQ",\n  shardTxIds: []\n}, {\n  id: "6",\n  name: "Important Note",\n  dateUploaded: "2025-05-08T17:40:00Z",\n  description: "An important text note with alphabet",\n  fileType: "text",\n  indexingTxId: "239a196d1b4dc1048c2ec022c71477b651ba3ab2eea5cf273f72304d257f0dbd",\n  indexingTxSubmittedAt: "2025-05-08T17:49:32Z",\n  objectData: "SGVsbG8gdGhlcmUhIEFCQ0RFRkdISUpLTE1OTw==",\n  objectType: "text/plain",\n  objectUlid: "01JTRFBTQZXXABTD6KBTVW75BJ",\n  shardTxIds: ["4491478fc8714213d3d8ecd3e6438f49c2a9cc5d5b5f8ae358834f43980f7127"]\n}];\n;// ./src/components/uploads/GradientText.tsx\n\nfunction GradientText(_ref) {\n  var text = _ref.text;\n  return /*#__PURE__*/react.createElement("span", {\n    className: "text-transparent bg-clip-text bg-gradient-to-r from-[var(--color-light)] to-white"\n  }, text);\n}\n;// ./src/components/uploads/uploads.tsx\nfunction uploads_toConsumableArray(r) { return uploads_arrayWithoutHoles(r) || uploads_iterableToArray(r) || uploads_unsupportedIterableToArray(r) || uploads_nonIterableSpread(); }\nfunction uploads_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction uploads_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction uploads_arrayWithoutHoles(r) { if (Array.isArray(r)) return uploads_arrayLikeToArray(r); }\nfunction uploads_slicedToArray(r, e) { return uploads_arrayWithHoles(r) || uploads_iterableToArrayLimit(r, e) || uploads_unsupportedIterableToArray(r, e) || uploads_nonIterableRest(); }\nfunction uploads_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction uploads_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return uploads_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? uploads_arrayLikeToArray(r, a) : void 0; } }\nfunction uploads_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction uploads_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction uploads_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n/**\n * Uploads component\n * This component fetches account uploads data from the API and displays them in a grid\n * with filtering and pagination options\n */\n\n\n\n\n\n\n\n\n\n\nvar dateFilterOptions = [{\n  id: "select",\n  label: "Select"\n}, {\n  id: "today",\n  label: "Today"\n}, {\n  id: "week",\n  label: "This Week"\n}, {\n  id: "month",\n  label: "This Month"\n}, {\n  id: "year",\n  label: "This Year"\n}];\nvar typeFilterOptions = [{\n  id: "all",\n  label: "All"\n}, {\n  id: "pdf",\n  label: "PDF"\n}, {\n  id: "text",\n  label: "Text"\n}, {\n  id: "png",\n  label: "PNG"\n}, {\n  id: "jpeg",\n  label: "JPEG/JPG"\n}];\nvar Uploads = function Uploads(_ref) {\n  var _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? 9 : _ref$limit;\n  var _useState = (0,react.useState)("select"),\n    _useState2 = uploads_slicedToArray(_useState, 2),\n    dateFilter = _useState2[0],\n    setDateFilter = _useState2[1];\n  var _useState3 = (0,react.useState)("all"),\n    _useState4 = uploads_slicedToArray(_useState3, 2),\n    typeFilter = _useState4[0],\n    setTypeFilter = _useState4[1];\n  var _useState5 = (0,react.useState)(""),\n    _useState6 = uploads_slicedToArray(_useState5, 2),\n    searchQuery = _useState6[0],\n    setSearchQuery = _useState6[1];\n  var _useState7 = (0,react.useState)("grid"),\n    _useState8 = uploads_slicedToArray(_useState7, 2),\n    viewMode = _useState8[0],\n    setViewMode = _useState8[1];\n  var _useWallet = useWallet(),\n    defaultWallet = _useWallet.defaultWallet;\n  var rewardAccounts = useRewardAccounts();\n  var _useUploads = useUploads({\n      limit: limit,\n      rewardAccounts: rewardAccounts\n    }),\n    allUploads = _useUploads.allUploads,\n    filteredUploads = _useUploads.filteredUploads,\n    displayedUploads = _useUploads.displayedUploads,\n    setFilteredUploads = _useUploads.setFilteredUploads,\n    setDisplayedUploads = _useUploads.setDisplayedUploads,\n    loading = _useUploads.loading,\n    error = _useUploads.error,\n    pagesData = _useUploads.pagesData,\n    lastObjectUlids = _useUploads.lastObjectUlids,\n    currentPage = _useUploads.currentPage,\n    setCurrentPage = _useUploads.setCurrentPage,\n    hasMorePages = _useUploads.hasMorePages,\n    setAllUploads = _useUploads.setAllUploads,\n    setPagesData = _useUploads.setPagesData,\n    setLastObjectUlids = _useUploads.setLastObjectUlids,\n    setHasMorePages = _useUploads.setHasMorePages,\n    fetchNextPage = _useUploads.fetchNextPage;\n\n  // Filtering logic\n  // Use mockData cuando no hay datos reales\n  (0,react.useEffect)(function () {\n    if (allUploads.length === 0 && !loading) {\n      setAllUploads(mockUploads);\n    }\n  }, [allUploads.length, loading, setAllUploads]);\n  (0,react.useEffect)(function () {\n    var filtered = uploads_toConsumableArray(allUploads);\n    // Date filter\n    if (dateFilter !== "select") {\n      var now = new Date();\n      var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      var thisWeek = new Date(today);\n      thisWeek.setDate(today.getDate() - 7);\n      var thisMonth = new Date(today);\n      thisMonth.setMonth(today.getMonth() - 1);\n      var thisYear = new Date(today);\n      thisYear.setFullYear(today.getFullYear() - 1);\n      filtered = filtered.filter(function (upload) {\n        var uploadDate = new Date(upload.dateUploaded);\n        switch (dateFilter) {\n          case "today":\n            return uploadDate >= today;\n          case "week":\n            return uploadDate >= thisWeek;\n          case "month":\n            return uploadDate >= thisMonth;\n          case "year":\n            return uploadDate >= thisYear;\n          default:\n            return true;\n        }\n      });\n    }\n    // Type filter\n    if (typeFilter !== "all") {\n      filtered = filtered.filter(function (upload) {\n        if (!upload.fileType) return false;\n        var lowerFileType = upload.fileType.toLowerCase();\n        switch (typeFilter) {\n          case "pdf":\n            return lowerFileType.includes("pdf");\n          case "text":\n            return lowerFileType.includes("text");\n          case "png":\n            return lowerFileType.includes("png");\n          case "jpeg":\n            return lowerFileType.includes("jpeg") || lowerFileType.includes("jpg");\n          default:\n            return true;\n        }\n      });\n    }\n    // Search\n    if (searchQuery.trim() !== "") {\n      var query = searchQuery.toLowerCase();\n      filtered = filtered.filter(function (upload) {\n        return upload.name && upload.name.toLowerCase().includes(query) || upload.description && upload.description.toLowerCase().includes(query);\n      });\n    }\n    setFilteredUploads(filtered);\n    setDisplayedUploads(filtered.slice(0, limit));\n    setCurrentPage(1);\n  }, [allUploads, dateFilter, typeFilter, searchQuery, limit, setFilteredUploads, setDisplayedUploads, setCurrentPage]);\n  var handleSearch = function handleSearch(e) {\n    e.preventDefault();\n  };\n  var handleCopyText = function handleCopyText(text) {\n    navigator.clipboard.writeText(text).then(function () {\n      // Optional: toast notification\n    });\n  };\n  var loadMore = function loadMore() {\n    if (hasMorePages) fetchNextPage(currentPage + 1);\n  };\n  var goToPreviousPage = function goToPreviousPage() {\n    if (currentPage > 1) {\n      setDisplayedUploads(pagesData[currentPage - 1] || []);\n      setCurrentPage(currentPage - 1);\n    }\n  };\n  var goToPage = function goToPage(page) {\n    if (page === currentPage) return;\n    if (page < currentPage) {\n      setDisplayedUploads(pagesData[page] || []);\n      setCurrentPage(page);\n    } else {\n      fetchNextPage(page);\n    }\n  };\n\n  // if (!defaultWallet) {\n  //   return <div className="uploads-error">Please connect a wallet</div>;\n  // }\n\n  return /*#__PURE__*/react.createElement("div", {\n    className: "max-w-7xl mx-auto p-5 text-black bg-[var(--color-bg-dark)] min-h-screen"\n  }, /*#__PURE__*/react.createElement("h1", {\n    className: "text-7xl font-bold text-center my-8"\n  }, /*#__PURE__*/react.createElement(GradientText, {\n    text: "My uploads"\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "mb-8"\n  }, /*#__PURE__*/react.createElement(uploads_UploadsFilters, {\n    dateFilter: dateFilter,\n    setDateFilter: setDateFilter,\n    typeFilter: typeFilter,\n    setTypeFilter: setTypeFilter,\n    searchQuery: searchQuery,\n    setSearchQuery: setSearchQuery,\n    onSearch: handleSearch,\n    dateFilterOptions: dateFilterOptions,\n    typeFilterOptions: typeFilterOptions,\n    viewMode: viewMode,\n    setViewMode: setViewMode\n  })), loading ? /*#__PURE__*/react.createElement("div", {\n    className: "text-center py-12 text-[var(--color-text-secondary)] text-lg"\n  }, "Loading uploads...") : error ? /*#__PURE__*/react.createElement("div", {\n    className: "text-center py-12 text-[var(--color-text-secondary)] text-lg"\n  }, "Error loading uploads. Using mock data instead.") : displayedUploads.length === 0 ? /*#__PURE__*/react.createElement("div", {\n    className: "text-center py-12 text-[var(--color-text-secondary)] text-lg"\n  }, "No uploads found.") : viewMode === "grid" ? /*#__PURE__*/react.createElement(uploads_UploadsGrid, {\n    uploads: displayedUploads,\n    onCopyText: handleCopyText\n  }) : /*#__PURE__*/react.createElement(uploads_UploadsList, {\n    uploads: displayedUploads,\n    onCopyText: handleCopyText\n  }), displayedUploads.length > 0 && /*#__PURE__*/react.createElement("div", {\n    className: "flex justify-center items-center mt-8 gap-2.5"\n  }, /*#__PURE__*/react.createElement("button", {\n    onClick: goToPreviousPage,\n    disabled: currentPage === 1 || loading,\n    className: "bg-[var(--color-bg-card)] border border-[var(--color-border)] text-[var(--color-primary-tw)] px-4 py-2 rounded-md cursor-pointer transition-colors duration-200 hover:bg-[var(--color-bg-hover)] disabled:opacity-50 disabled:cursor-not-allowed"\n  }, "Previous"), /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center gap-1.5"\n  }, currentPage > 2 && /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return goToPage(1);\n    },\n    className: "w-8 h-8 flex items-center justify-center bg-[var(--color-bg-card)] border border-[var(--color-border)] text-[var(--color-primary-tw)] rounded-md cursor-pointer"\n  }, "1"), currentPage > 3 && /*#__PURE__*/react.createElement("span", {\n    className: "text-[var(--color-text-secondary)]"\n  }, "..."), currentPage > 1 && /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return goToPage(currentPage - 1);\n    },\n    className: "w-8 h-8 flex items-center justify-center bg-[var(--color-bg-card)] border border-[var(--color-border)] text-[var(--color-primary-tw)] rounded-md cursor-pointer"\n  }, currentPage - 1), /*#__PURE__*/react.createElement("button", {\n    className: "w-8 h-8 flex items-center justify-center bg-[var(--color-bg-active)] border border-[var(--color-border-active)] text-[var(--color-primary-tw)] rounded-md cursor-pointer"\n  }, currentPage), hasMorePages && /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return goToPage(currentPage + 1);\n    },\n    className: "w-8 h-8 flex items-center justify-center bg-[var(--color-bg-card)] border border-[var(--color-border)] text-[var(--color-primary-tw)] rounded-md cursor-pointer"\n  }, currentPage + 1), hasMorePages && /*#__PURE__*/react.createElement("span", {\n    className: "text-[var(--color-text-secondary)]"\n  }, "...")), /*#__PURE__*/react.createElement("button", {\n    onClick: loadMore,\n    disabled: !hasMorePages || loading,\n    className: "bg-[var(--color-bg-card)] border border-[var(--color-border)] text-[var(--color-primary-tw)] px-4 py-2 rounded-md cursor-pointer transition-colors duration-200 hover:bg-[var(--color-bg-hover)] disabled:opacity-50 disabled:cursor-not-allowed"\n  }, "Next")));\n};\n/* harmony default export */ const uploads = (Uploads);\n;// ./src/index.tsx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar App = function App() {\n  return /*#__PURE__*/react.createElement(MainUploader, null);\n};\nvar ConnectWalletApp = function ConnectWalletApp() {\n  return /*#__PURE__*/react.createElement(ConnectWallet, null);\n};\n\n// Self-executing function that works whether DOM is already loaded or not\n(function () {\n  var currentExecutingEnvironment = window.location.host.includes("webflow.io") || window.location.host.includes("localhost") ? "preproduction" : "production";\n  if (currentExecutingEnvironment !== ENVIRONMENT) {\n    /* console.error(`Mismatched environment: Expected ${ENVIRONMENT}, found ${currentExecutingEnvironment}`); */\n    console.warn("YOU ARE WORKING IN ".concat(currentExecutingEnvironment, " ENVIRONMENT"));\n    return;\n  }\n  console.log("HELLO THERE FROM PREPROD");\n  var renderApp = function renderApp() {\n    var rootElement = document.getElementById("react-target");\n    var connectWalletElement = document.getElementById("connect-wallet");\n    //const inscriptorElement = document.getElementById("inscriptor-root");\n    var decoderElement = document.getElementById("decoder");\n    console.log("decoderElement", decoderElement);\n    /**\n     * HTML element where the <Uploads /> component will be rendered.\n     * This element should have an id of "uploads" and should be present in the\n     * HTML document.\n     */\n\n    var uploadsElement = document.getElementById("uploads");\n    console.log("uploadsElement", uploadsElement);\n    if (rootElement /* && inscriptorElement */) {\n      var root = client.createRoot(rootElement);\n      console.log("React target element found");\n      console.log("Connect wallet element found");\n      root.render(/*#__PURE__*/react.createElement(react.StrictMode, null, /*#__PURE__*/react.createElement(WalletProvider, null, /*#__PURE__*/react.createElement(TxStatusProvider, null, /*#__PURE__*/react.createElement(FileUploadProvider, null, /*#__PURE__*/react.createElement(TxPreparationProvider, null, /*#__PURE__*/react.createElement(TxInscriptionProvider, null, connectWalletElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(ConnectWalletApp, null), connectWalletElement), rootElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(App, null), rootElement), document.body && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(WalletMenu, null), document.body), uploadsElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(uploads, null), uploadsElement), decoderElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(decoder_HexDecoder, null), decoderElement))))))));\n    }\n  };\n\n  // Check if DOM is already loaded\n  if (document.readyState === "loading") {\n    // If not loaded yet, wait for DOMContentLoaded\n    document.addEventListener("DOMContentLoaded", renderApp);\n  } else {\n    // If already loaded, run immediately\n    renderApp();\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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dUMsY0FBYyxDQUFDLEVBQzFDRCxjQUFjLGlCQUNiWCwwQkFBWSxjQUFDNzBCLG1CQUFBLENBQUM2c0Isa0JBQVUsTUFBRSxDQUFDLEVBQUUySSxjQUFjLENBRXhCLENBQ0YsQ0FDTCxDQUNKLENBQ0osQ0FDQSxDQUNwQixDQUFDO0lBQ0g7RUFDRixDQUFDOztFQUVEO0VBQ0EsSUFBSUgsUUFBUSxDQUFDUyxVQUFVLEtBQUssU0FBUyxFQUFFO0lBQ3JDO0lBQ0FULFFBQVEsQ0FBQ3hpQixnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRXNpQixTQUFTLENBQUM7RUFDMUQsQ0FBQyxNQUFNO0lBQ0w7SUFDQUEsU0FBUyxDQUFDLENBQUM7RUFDYjtBQUNGLENBQUMsRUFBRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9zdHlsZXMuY3NzP2E4ZDAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2NvbXBvbmVudHMvY3JlYXRlLXByb3h5Lm1qcz9mOGNjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzP2M2NzMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWtleWZyYW1lcy10YXJnZXQubWpzPzU2MmMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc2hhbGxvdy1jb21wYXJlLm1qcz8zNTJhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9pcy12YXJpYW50LWxhYmVsLm1qcz84MGJiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9yZXNvbHZlLXZhcmlhbnRzLm1qcz85YTNlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9yZXNvbHZlLWR5bmFtaWMtdmFyaWFudHMubWpzPzYwZmQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3ZhcmlhbnQtcHJvcHMubWpzPzk2M2EiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tdXRpbHMvZGlzdC9lcy9tZW1vLm1qcz81YjNjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3V0aWxzL3N1cHBvcnRzL3Njcm9sbC10aW1lbGluZS5tanM/ZDU4OSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vY29udHJvbHMvQmFzZUdyb3VwLm1qcz8xNGI1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi9jb250cm9scy9Hcm91cC5tanM/MWRmNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvZ2V0LXZhbHVlLXRyYW5zaXRpb24ubWpzPzQyMWMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvYW5pbWF0aW9uL2dlbmVyYXRvcnMvdXRpbHMvY2FsYy1kdXJhdGlvbi5tanM/ZDIzZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy91dGlscy9pcy1nZW5lcmF0b3IubWpzP2YwN2EiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvYW5pbWF0aW9uL3dhYXBpL3V0aWxzL2F0dGFjaC10aW1lbGluZS5tanM/NDFjYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy91dGlscy9pcy1iZXppZXItZGVmaW5pdGlvbi5tanM/YmQ3YSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy91dGlscy9zdXBwb3J0cy9mbGFncy5tanM/NzgzOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy91dGlscy9zdXBwb3J0cy9tZW1vLm1qcz9iMGFlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3V0aWxzL3N1cHBvcnRzL2xpbmVhci1lYXNpbmcubWpzP2VjZDMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tdXRpbHMvZGlzdC9lcy9wcm9ncmVzcy5tanM/NDBjZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vd2FhcGkvdXRpbHMvbGluZWFyLm1qcz9iYjk5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi93YWFwaS91dGlscy9lYXNpbmcubWpzPzE2OTUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy9zdGF0ZS9pcy1hY3RpdmUubWpzP2JlNWYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvdXRpbHMvcmVzb2x2ZS1lbGVtZW50cy5tanM/OWU2ZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9nZXN0dXJlcy91dGlscy9zZXR1cC5tanM/MjBiNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9nZXN0dXJlcy9ob3Zlci5tanM/YzE3NSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9nZXN0dXJlcy91dGlscy9pcy1ub2RlLW9yLWNoaWxkLm1qcz80YjZmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLXByaW1hcnktcG9pbnRlci5tanM/MWI0ZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9nZXN0dXJlcy9wcmVzcy91dGlscy9pcy1rZXlib2FyZC1hY2Nlc3NpYmxlLm1qcz8wZDBhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3ByZXNzL3V0aWxzL3N0YXRlLm1qcz8zYmQzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3ByZXNzL3V0aWxzL2tleWJvYXJkLm1qcz81MzYxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3ByZXNzL2luZGV4Lm1qcz84MGRiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLXV0aWxzL2Rpc3QvZXMvdGltZS1jb252ZXJzaW9uLm1qcz80MTNlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLXV0aWxzL2Rpc3QvZXMvbm9vcC5tanM/N2U3NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vd2FhcGkvTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMubWpzPzhhYmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvYW5pbWF0aW9uL2dlbmVyYXRvcnMvdXRpbHMvY3JlYXRlLWdlbmVyYXRvci1lYXNpbmcubWpzP2Y1ZWQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvYW5pbWF0aW9uL3dhYXBpL3V0aWxzL2NvbnZlcnQtb3B0aW9ucy5tanM/MzIzNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vd2FhcGkvUHNldWRvQW5pbWF0aW9uLm1qcz81MGQ5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3ZpZXcvdXRpbHMvY3NzLm1qcz8wYTA4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3ZpZXcvc3RhcnQubWpzPzFiNTEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvdmlldy9pbmRleC5tanM/MzU1OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3N0YXRlL3NldC1hY3RpdmUubWpzP2Q1MjkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvaW5kZXgubWpzPzFiNWYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzPzM0NDgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMva2V5cy1wb3NpdGlvbi5tanM/YWZlZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9yZXNvbHZlLXZhbHVlLm1qcz82ODcyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL0dsb2JhbENvbmZpZy5tanM/MWVmOCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9mcmFtZWxvb3AvcmVuZGVyLXN0ZXAubWpzP2E1YjMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL2JhdGNoZXIubWpzP2QzNDEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL2ZyYW1lLm1qcz81YjY3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2ZyYW1lbG9vcC9zeW5jLXRpbWUubWpzPzU0ZDAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvYXJyYXkubWpzP2FiNGEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzP2Q4N2MiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanM/M2I5NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS9pbmRleC5tanM/MTEzOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvc2V0dGVycy5tanM/ZGQyMiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzP2Q4Y2YiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXdpbGwtY2hhbmdlL2lzLm1qcz8xN2ZkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS13aWxsLWNoYW5nZS9hZGQtd2lsbC1jaGFuZ2UubWpzPzM2NzYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9jYW1lbC10by1kYXNoLm1qcz81M2IxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9vcHRpbWl6ZWQtYXBwZWFyL2RhdGEtaWQubWpzPzQxODYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL29wdGltaXplZC1hcHBlYXIvZ2V0LWFwcGVhci1pZC5tanM/NGZlZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaW5zdGFudC10cmFuc2l0aW9uLXN0YXRlLm1qcz8zYjg3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy9jdWJpYy1iZXppZXIubWpzP2Q2MmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL21vZGlmaWVycy9taXJyb3IubWpzP2IwODIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL21vZGlmaWVycy9yZXZlcnNlLm1qcz9jYjczIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy9iYWNrLm1qcz9lNTRmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy9hbnRpY2lwYXRlLm1qcz9hMGMzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy9jaXJjLm1qcz8zMTlkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXplcm8tdmFsdWUtc3RyaW5nLm1qcz85OTA4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1ub25lLm1qcz85NTQ2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2NsYW1wLm1qcz9hNDc1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL251bWJlcnMvaW5kZXgubWpzP2I0ZjAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvdXRpbHMvc2FuaXRpemUubWpzPzUwZDMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvdXRpbHMvZmxvYXQtcmVnZXgubWpzP2Q0MmMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvdXRpbHMvaXMtbnVsbGlzaC5tanM/Zjk1NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy91dGlscy9zaW5nbGUtY29sb3ItcmVnZXgubWpzP2VkZjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvY29sb3IvdXRpbHMubWpzPzM0NjgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvY29sb3IvcmdiYS5tanM/NzM4NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy9jb2xvci9oZXgubWpzP2FkYzEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanM/MGMxNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy9jb2xvci9oc2xhLm1qcz9lMmVjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL2NvbG9yL2luZGV4Lm1qcz82YWM2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL3V0aWxzL2NvbG9yLXJlZ2V4Lm1qcz9lMjgwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL2NvbXBsZXgvaW5kZXgubWpzPzM3NmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvY29tcGxleC9maWx0ZXIubWpzPzYyYTciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9udW1iZXItYnJvd3Nlci5tanM/NjJmNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3RyYW5zZm9ybS5tanM/MDM3ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3R5cGUtaW50Lm1qcz83YTdkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvbnVtYmVyLm1qcz81MjE1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMubWpzPzMwNjciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9hbmltYXRhYmxlLW5vbmUubWpzPzNlZDQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvbWFrZS1ub25lLWFuaW1hdGFibGUubWpzPzRkNTQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy91bml0LWNvbnZlcnNpb24ubWpzP2EyYzMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL0tleWZyYW1lc1Jlc29sdmVyLm1qcz9hZWQwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLXV0aWxzL2Rpc3QvZXMvZXJyb3JzLm1qcz82NzcwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLW51bWVyaWNhbC1zdHJpbmcubWpzPzE0ZmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9pcy1jc3MtdmFyaWFibGUubWpzPzYzNzUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9jc3MtdmFyaWFibGVzLWNvbnZlcnNpb24ubWpzP2U1ZDkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90ZXN0Lm1qcz82MDIxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHlwZS1hdXRvLm1qcz8wZDg2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGltZW5zaW9ucy5tanM/N2M1MCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL0RPTUtleWZyYW1lc1Jlc29sdmVyLm1qcz8wNjQ2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRhYmxlLm1qcz9kMjhkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRvcnMvdXRpbHMvY2FuLWFuaW1hdGUubWpzP2NmM2UiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy93YWFwaS91dGlscy9nZXQtZmluYWwta2V5ZnJhbWUubWpzPzc4MzAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy9CYXNlQW5pbWF0aW9uLm1qcz9kYjY2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC9udW1iZXIubWpzP2QwNzgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaHNsYS10by1yZ2JhLm1qcz9iNGJlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC9pbW1lZGlhdGUubWpzPzQ0ODgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4L2NvbG9yLm1qcz84NjRhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3BpcGUubWpzP2ZkYmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4L3Zpc2liaWxpdHkubWpzPzEyMTciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4L2NvbXBsZXgubWpzP2RjYzYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4L2luZGV4Lm1qcz9mODJlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3V0aWxzL3ZlbG9jaXR5Lm1qcz9iOTdlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3NwcmluZy9kZWZhdWx0cy5tanM/MWMyYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy9zcHJpbmcvZmluZC5tanM/MmQ2YyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy9zcHJpbmcvaW5kZXgubWpzPzZlYzkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2dlbmVyYXRvcnMvaW5lcnRpYS5tanM/NGEyYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9lYXNpbmcvZWFzZS5tanM/OGJmYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9lYXNpbmcvdXRpbHMvaXMtZWFzaW5nLWFycmF5Lm1qcz8zMjBjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy91dGlscy9tYXAubWpzP2VkMGYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaW50ZXJwb2xhdGUubWpzPzIyNjMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvb2Zmc2V0cy9maWxsLm1qcz85ZDIxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL29mZnNldHMvZGVmYXVsdC5tanM/YmM1OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9vZmZzZXRzL3RpbWUubWpzPzhjYmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2dlbmVyYXRvcnMva2V5ZnJhbWVzLm1qcz84NWI4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRvcnMvZHJpdmVycy9kcml2ZXItZnJhbWVsb29wLm1qcz9iNDMzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRvcnMvTWFpblRocmVhZEFuaW1hdGlvbi5tanM/N2FmNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0b3JzL3V0aWxzL2FjY2VsZXJhdGVkLXZhbHVlcy5tanM/MDNlNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0b3JzL3dhYXBpL2luZGV4Lm1qcz9lNTlhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRvcnMvd2FhcGkvdXRpbHMvc3VwcG9ydHMtd2FhcGkubWpzPzdiMmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy9BY2NlbGVyYXRlZEFuaW1hdGlvbi5tanM/NjNkMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvZGVmYXVsdC10cmFuc2l0aW9ucy5tanM/YmE1NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMtdHJhbnNpdGlvbi1kZWZpbmVkLm1qcz9kOGY2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9pbnRlcmZhY2VzL21vdGlvbi12YWx1ZS5tanM/N2Q1NSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vaW50ZXJmYWNlcy92aXN1YWwtZWxlbWVudC10YXJnZXQubWpzPzlkOTEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2ludGVyZmFjZXMvdmlzdWFsLWVsZW1lbnQtdmFyaWFudC5tanM/ZTk1YyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vaW50ZXJmYWNlcy92aXN1YWwtZWxlbWVudC5tanM/MDM1MiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvZ2V0LXZhcmlhbnQtY29udGV4dC5tanM/N2E4YSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLXN0YXRlLm1qcz8wM2NjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9GZWF0dXJlLm1qcz82NjdiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb24vaW5kZXgubWpzPzU5M2MiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbi9leGl0Lm1qcz9hMGNmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb25zLm1qcz8xYTBkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy9hZGQtZG9tLWV2ZW50Lm1qcz9kMWUxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy9ldmVudC1pbmZvLm1qcz9lMGYxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy9hZGQtcG9pbnRlci1ldmVudC5tanM/OWJkZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9kaXN0YW5jZS5tanM/NjcyYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9wYW4vUGFuU2Vzc2lvbi5tanM/YjU5ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcz8wYWU2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtY2FsYy5tanM/NmEyZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2NvbnN0cmFpbnRzLm1qcz8wNTY5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qcz9hMWZiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvZWFjaC1heGlzLm1qcz9lNjJmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29udmVyc2lvbi5tanM/YTIwMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL2hhcy10cmFuc2Zvcm0ubWpzPzU2ZjMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1hcHBseS5tanM/NmVmZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL21lYXN1cmUubWpzPzhhMzkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvZ2V0LWNvbnRleHQtd2luZG93Lm1qcz9jODBjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5tanM/NDY2NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL2luZGV4Lm1qcz9hOGQxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3Bhbi9pbmRleC5tanM/NjcxMiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1ByZXNlbmNlQ29udGV4dC5tanM/NDgzOCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS91c2UtcHJlc2VuY2UubWpzPzgwZDAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzPzlhYjMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzP2RhYWUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL3N0YXRlLm1qcz81M2MyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJvcmRlci1yYWRpdXMubWpzPzBhOWQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm94LXNoYWRvdy5tanM/NmE1MSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qcz9lZmJkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2ZyYW1lbG9vcC9taWNyb3Rhc2subWpzPzZiNzQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9NZWFzdXJlTGF5b3V0Lm1qcz9hZWU2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRlL3NpbmdsZS12YWx1ZS5tanM/ZjFhMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1lbGVtZW50Lm1qcz8xNDg5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9jb21wYXJlLWJ5LWRlcHRoLm1qcz84ODc4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzP2Q5N2IiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvZGVsYXkubWpzPzk2MjgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXRpbHMvcmVzb2x2ZS1tb3Rpb24tdmFsdWUubWpzPzIwYjQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9hbmltYXRpb24vbWl4LXZhbHVlcy5tanM/NzMwNCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2NvcHkubWpzPzJmM2YiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1yZW1vdmUubWpzPzU1M2UiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS91dGlscy5tanM/OGVlZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3NoYXJlZC9zdGFjay5tanM/NGQ2ZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy90cmFuc2Zvcm0ubWpzP2RlZmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzP2Y5NDAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL0RvY3VtZW50UHJvamVjdGlvbk5vZGUubWpzP2RjZWQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL0hUTUxQcm9qZWN0aW9uTm9kZS5tanM/ZDJmYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZHJhZy5tanM/OTAwMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9ob3Zlci5tanM/MjIwZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9mb2N1cy5tanM/M2MwMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9wcmVzcy5tanM/MTY5NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdmlld3BvcnQvb2JzZXJ2ZXJzLm1qcz9mNjhkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC9pbmRleC5tanM/OWJjNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZ2VzdHVyZXMubWpzP2NkYzYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC5tanM/OGY3NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xhenlDb250ZXh0Lm1qcz9hMjRkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29uZmlnQ29udGV4dC5tanM/OThkMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXgubWpzPzA2NzkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2lzLWNvbnRyb2xsaW5nLXZhcmlhbnRzLm1qcz8xZTZhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC91dGlscy5tanM/NTQyZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvY3JlYXRlLm1qcz9lYjA1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLWJyb3dzZXIubWpzP2VlOGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RlZmluaXRpb25zLm1qcz9iYjU4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9sb2FkLWZlYXR1cmVzLm1qcz82ODczIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9zeW1ib2wubWpzPzQyZmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS1tb3Rpb24tcmVmLm1qcz8yODNhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanM/YzFjNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1lbGVtZW50Lm1qcz9lN2QzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanM/OTU1MyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL2xvd2VyY2FzZS1lbGVtZW50cy5tanM/N2I3NSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzPzA4M2EiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qcz8xY2ExIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qcz8yOGEyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUubWpzP2M1ZWIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtdHJhbnNmb3JtLm1qcz8zY2YyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL2J1aWxkLXN0eWxlcy5tanM/YTdhMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3BhdGgubWpzPzcxZDYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy90cmFuc2Zvcm0tb3JpZ2luLm1qcz80NzVkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvYnVpbGQtYXR0cnMubWpzP2E0ODgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanM/OWYyMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUubWpzPzI5NmUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9pcy1zdmctdGFnLm1qcz84YTU2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3JlbmRlci5tanM/MjNiZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2NhbWVsLWNhc2UtYXR0cnMubWpzPzk0MDgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9yZW5kZXIubWpzPzFkYjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL2lzLWZvcmNlZC1tb3Rpb24tdmFsdWUubWpzPzA0NGYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzP2ViZGUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanM/ZDg1YiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL2NvbmZpZy1tb3Rpb24ubWpzPzU0ZmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvY29uZmlnLW1vdGlvbi5tanM/YTdlMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91c2UtcHJvcHMubWpzPzEyMDMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzPzVjOTEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9maWx0ZXItcHJvcHMubWpzP2NhNWQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMubWpzPzliNjciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91c2UtcmVuZGVyLm1qcz9kNGQyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9jb21wb25lbnRzL2NyZWF0ZS1mYWN0b3J5Lm1qcz9jYmRmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3JlZHVjZWQtbW90aW9uL3N0YXRlLm1qcz8xNjg4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3JlZHVjZWQtbW90aW9uL2luZGV4Lm1qcz83ZGIwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZmluZC5tanM/NzQxZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3RvcmUubWpzP2U1NzciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL21vdGlvbi12YWx1ZXMubWpzPzIyMzUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL1Zpc3VhbEVsZW1lbnQubWpzP2M0M2QiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9ET01WaXN1YWxFbGVtZW50Lm1qcz8wM2ZkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL0hUTUxWaXN1YWxFbGVtZW50Lm1qcz83ZTUwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvU1ZHVmlzdWFsRWxlbWVudC5tanM/OGI2ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL2NyZWF0ZS12aXN1YWwtZWxlbWVudC5tanM/MzU1ZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvY29tcG9uZW50cy9tb3Rpb24vY3JlYXRlLm1qcz82YzlhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9jb21wb25lbnRzL21vdGlvbi9wcm94eS5tanM/MjRhYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS9Qb3BDaGlsZC5tanM/OGMxOCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS9QcmVzZW5jZUNoaWxkLm1qcz84MTg5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL3V0aWxzLm1qcz82ZDQ1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL2luZGV4Lm1qcz83MDU2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29udGV4dC9GaWxlVXBsb2FkQ29udGV4dC50c3g/MjFjYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2ljb25zL1VwbG9hZEljb24udHN4PzdiY2QiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb250ZXh0L1R4U3RhdHVzQ29udGV4dC50c3g/MmQxZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2FkZXIvdXBsb2FkLWJveC50c3g/MzA0MCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbnRleHQvV2FsbGV0Q29udGV4dC50c3g/NmE5NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL3V0aWxzL2FwaUNvbnN1bXB0aW9uLnRzP2U0OTIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb250ZXh0L1R4UHJlcGFyYXRpb25Db250ZXh0LnRzeD83Nzk1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvaWNvbnMvQ2xvc2VJY29uLnRzeD8wOTc5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91aS9CdXR0b24udHN4P2QxOTUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9pY29ucy9QZGZJY29uLnRzeD8zM2EwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvaWNvbnMvUG5nSWNvbi50c3g/NDA5NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2ljb25zL1BkZ0ljb24udHN4PzNiM2EiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9pY29ucy9NcDRJY29uLnRzeD8wOGRiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91cGxvYWRlci9maWxlLWxpc3QudHN4PzgwNzAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZGVyL2RlbGVnYXRlLXZpZXcudHN4Pzc0MTAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb250ZXh0L1R4SW5zY3JpcHRpb25Db250ZXh0LnRzeD85MWY2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91aS9Mb2FkaW5nU2NyZWVuLnRzeD8yNTY0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91aS9GaW5pc2hTY3JlZW4udHN4PzQ0MTEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VpL1Byb2dyZXNzQmFyLnRzeD82NGI2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91cGxvYWRlci9tYWluVXBsb2FkZXIudHN4P2IyNWIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3dhbGxldC9Db25uZWN0V2FsbGV0LnRzeD8wZjJiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvaWNvbnMvQ2xvc2VJY29uU2Vjb25kYXJ5LnRzeD80YjhjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy93YWxsZXQvV2FsbGV0TWVudS50c3g/MDIyNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL3V0aWxzL2RlY29kZXIudHM/OTBmOCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvZGVjb2Rlci9IZXhEZWNvZGVyLnRzeD9lNTE5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91cGxvYWRzL3VzZVJld2FyZEFjY291bnRzLnRzPzUxZTQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvdXNlVXBsb2Fkcy50cz9mM2QzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91cGxvYWRzL1VwbG9hZENhcmQudHN4PzRhMGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvVXBsb2Fkc0dyaWQudHN4P2ZiNWMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvVXBsb2FkTGlzdEl0ZW0udHN4PzNlMmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvVXBsb2Fkc0xpc3QudHN4P2RlOGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvVXBsb2Fkc0ZpbHRlcnMudHN4PzQ2MDkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvbW9ja0RhdGEudHM/ZGQxYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9HcmFkaWVudFRleHQudHN4P2M0YmYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvdXBsb2Fkcy50c3g/YWRlMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2luZGV4LnRzeD9kOTg2Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgXG4gICAgICBcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybSA9IHN0eWxlVGFnVHJhbnNmb3JtRm47XG5vcHRpb25zLnNldEF0dHJpYnV0ZXMgPSBzZXRBdHRyaWJ1dGVzO1xub3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZXMuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi91dGlscy93YXJuLW9uY2UubWpzJztcblxuZnVuY3Rpb24gY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkoY29tcG9uZW50RmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgUHJveHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2FjaGUgb2YgZ2VuZXJhdGVkIGBtb3Rpb25gIGNvbXBvbmVudHMsIGUuZyBgbW90aW9uLmRpdmAsIGBtb3Rpb24uaW5wdXRgIGV0Yy5cbiAgICAgKiBSYXRoZXIgdGhhbiBnZW5lcmF0aW5nIHRoZW0gYW5ldyBldmVyeSByZW5kZXIuXG4gICAgICovXG4gICAgY29uc3QgY29tcG9uZW50Q2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZGVwcmVjYXRlZEZhY3RvcnlGdW5jdGlvbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGZhbHNlLCBcIm1vdGlvbigpIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb3Rpb24uY3JlYXRlKCkgaW5zdGVhZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudEZhY3RvcnkoLi4uYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb3h5KGRlcHJlY2F0ZWRGYWN0b3J5RnVuY3Rpb24sIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCB3aGVuIGBtb3Rpb25gIGlzIHJlZmVyZW5jZWQgd2l0aCBhIHByb3A6IGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAgICAgKiBUaGUgcHJvcCBuYW1lIGlzIHBhc3NlZCB0aHJvdWdoIGFzIGBrZXlgIGFuZCB3ZSBjYW4gdXNlIHRoYXQgdG8gZ2VuZXJhdGUgYSBgbW90aW9uYFxuICAgICAgICAgKiBET00gY29tcG9uZW50IHdpdGggdGhhdCBuYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiAoX3RhcmdldCwga2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImNyZWF0ZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgY29tcG9uZW50IGNhY2hlLCBjcmVhdGUgaXQgYW5kIGNhY2hlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q2FjaGUuc2V0KGtleSwgY29tcG9uZW50RmFjdG9yeShrZXkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRDYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkgfTtcbiIsImZ1bmN0aW9uIGlzQW5pbWF0aW9uQ29udHJvbHModikge1xuICAgIHJldHVybiAodiAhPT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICB0eXBlb2Ygdi5zdGFydCA9PT0gXCJmdW5jdGlvblwiKTtcbn1cblxuZXhwb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9O1xuIiwiY29uc3QgaXNLZXlmcmFtZXNUYXJnZXQgPSAodikgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xufTtcblxuZXhwb3J0IHsgaXNLZXlmcmFtZXNUYXJnZXQgfTtcbiIsImZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJldikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBwcmV2TGVuZ3RoID0gcHJldi5sZW5ndGg7XG4gICAgaWYgKHByZXZMZW5ndGggIT09IG5leHQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByZXZbaV0gIT09IG5leHRbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgeyBzaGFsbG93Q29tcGFyZSB9O1xuIiwiLyoqXG4gKiBEZWNpZGVzIGlmIHRoZSBzdXBwbGllZCB2YXJpYWJsZSBpcyB2YXJpYW50IGxhYmVsXG4gKi9cbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVsKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuZXhwb3J0IHsgaXNWYXJpYW50TGFiZWwgfTtcbiIsImZ1bmN0aW9uIGdldFZhbHVlU3RhdGUodmlzdWFsRWxlbWVudCkge1xuICAgIGNvbnN0IHN0YXRlID0gW3t9LCB7fV07XG4gICAgdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIHN0YXRlWzBdW2tleV0gPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgc3RhdGVbMV1ba2V5XSA9IHZhbHVlLmdldFZlbG9jaXR5KCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSwgdmlzdWFsRWxlbWVudCkge1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGRlZmluaXRpb24gaXMgYSBmdW5jdGlvbiwgcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBbY3VycmVudCwgdmVsb2NpdHldID0gZ2V0VmFsdWVTdGF0ZSh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24oY3VzdG9tICE9PSB1bmRlZmluZWQgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGN1cnJlbnQsIHZlbG9jaXR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiBpcyBhIHZhcmlhbnQgbGFiZWwsIG9yXG4gICAgICogdGhlIGZ1bmN0aW9uIHJldHVybmVkIGEgdmFyaWFudCBsYWJlbCwgcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGVmaW5pdGlvbiA9IHByb3BzLnZhcmlhbnRzICYmIHByb3BzLnZhcmlhbnRzW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlJ3ZlIHJlc29sdmVkIGJvdGggZnVuY3Rpb25zIGFuZCB2YXJpYW50IGxhYmVscyxcbiAgICAgKiBidXQgdGhlIHJlc29sdmVkIHZhcmlhbnQgbGFiZWwgbWlnaHQgaXRzZWxmIGhhdmUgYmVlbiBhIGZ1bmN0aW9uLlxuICAgICAqIElmIHNvLCByZXNvbHZlLiBUaGlzIGNhbiBvbmx5IGhhdmUgcmV0dXJuZWQgYSB2YWxpZCB0YXJnZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IFtjdXJyZW50LCB2ZWxvY2l0eV0gPSBnZXRWYWx1ZVN0YXRlKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHVuZGVmaW5lZCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudCwgdmVsb2NpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmaW5pdGlvbjtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMgfTtcbiIsImltcG9ydCB7IHJlc29sdmVWYXJpYW50RnJvbVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXZhcmlhbnRzLm1qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIGN1c3RvbSkge1xuICAgIGNvbnN0IHByb3BzID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgIHJldHVybiByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbiwgY3VzdG9tICE9PSB1bmRlZmluZWQgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIHZpc3VhbEVsZW1lbnQpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlVmFyaWFudCB9O1xuIiwiY29uc3QgdmFyaWFudFByaW9yaXR5T3JkZXIgPSBbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIFwid2hpbGVGb2N1c1wiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVUYXBcIixcbiAgICBcIndoaWxlRHJhZ1wiLFxuICAgIFwiZXhpdFwiLFxuXTtcbmNvbnN0IHZhcmlhbnRQcm9wcyA9IFtcImluaXRpYWxcIiwgLi4udmFyaWFudFByaW9yaXR5T3JkZXJdO1xuXG5leHBvcnQgeyB2YXJpYW50UHJpb3JpdHlPcmRlciwgdmFyaWFudFByb3BzIH07XG4iLCIvKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmZ1bmN0aW9uIG1lbW8oY2FsbGJhY2spIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdCA9IGNhbGxiYWNrKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgbWVtbyB9O1xuIiwiaW1wb3J0IHsgbWVtbyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5cbmNvbnN0IHN1cHBvcnRzU2Nyb2xsVGltZWxpbmUgPSBtZW1vKCgpID0+IHdpbmRvdy5TY3JvbGxUaW1lbGluZSAhPT0gdW5kZWZpbmVkKTtcblxuZXhwb3J0IHsgc3VwcG9ydHNTY3JvbGxUaW1lbGluZSB9O1xuIiwiaW1wb3J0IHsgc3VwcG9ydHNTY3JvbGxUaW1lbGluZSB9IGZyb20gJy4uLy4uL3V0aWxzL3N1cHBvcnRzL3Njcm9sbC10aW1lbGluZS5tanMnO1xuXG5jbGFzcyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb25zKSB7XG4gICAgICAgIC8vIEJvdW5kIHRvIGFjY29tb2RhdGUgY29tbW9uIGByZXR1cm4gYW5pbWF0aW9uLnN0b3BgIHBhdHRlcm5cbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4gdGhpcy5ydW5BbGwoXCJzdG9wXCIpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSBhbmltYXRpb25zLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG4gICAgZ2V0IGZpbmlzaGVkKCkge1xuICAgICAgICAvLyBTdXBwb3J0IGZvciBuZXcgZmluaXNoZWQgUHJvbWlzZSBhbmQgbGVnYWN5IHRoZW5uYWJsZSBBUElcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuYW5pbWF0aW9ucy5tYXAoKGFuaW1hdGlvbikgPT4gXCJmaW5pc2hlZFwiIGluIGFuaW1hdGlvbiA/IGFuaW1hdGlvbi5maW5pc2hlZCA6IGFuaW1hdGlvbikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUT0RPOiBGaWx0ZXIgb3V0IGNhbmNlbGxlZCBvciBzdG9wcGVkIGFuaW1hdGlvbnMgYmVmb3JlIHJldHVybmluZ1xuICAgICAqL1xuICAgIGdldEFsbChwcm9wTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb25zWzBdW3Byb3BOYW1lXTtcbiAgICB9XG4gICAgc2V0QWxsKHByb3BOYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW2ldW3Byb3BOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0dGFjaFRpbWVsaW5lKHRpbWVsaW5lLCBmYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25zID0gdGhpcy5hbmltYXRpb25zLm1hcCgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VwcG9ydHNTY3JvbGxUaW1lbGluZSgpICYmIGFuaW1hdGlvbi5hdHRhY2hUaW1lbGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbmltYXRpb24uYXR0YWNoVGltZWxpbmUodGltZWxpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsbGJhY2soYW5pbWF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmZvckVhY2goKGNhbmNlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbmNlbCAmJiBjYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbaV0uc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoXCJ0aW1lXCIpO1xuICAgIH1cbiAgICBzZXQgdGltZSh0aW1lKSB7XG4gICAgICAgIHRoaXMuc2V0QWxsKFwidGltZVwiLCB0aW1lKTtcbiAgICB9XG4gICAgZ2V0IHNwZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoXCJzcGVlZFwiKTtcbiAgICB9XG4gICAgc2V0IHNwZWVkKHNwZWVkKSB7XG4gICAgICAgIHRoaXMuc2V0QWxsKFwic3BlZWRcIiwgc3BlZWQpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRUaW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGwoXCJzdGFydFRpbWVcIik7XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHRoaXMuYW5pbWF0aW9uc1tpXS5kdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgcnVuQWxsKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zLmZvckVhY2goKGNvbnRyb2xzKSA9PiBjb250cm9sc1ttZXRob2ROYW1lXSgpKTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgdGhpcy5ydW5BbGwoXCJmbGF0dGVuXCIpO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLnJ1bkFsbChcInBsYXlcIik7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnJ1bkFsbChcInBhdXNlXCIpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMucnVuQWxsKFwiY2FuY2VsXCIpO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5ydW5BbGwoXCJjb21wbGV0ZVwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJhc2VHcm91cFBsYXliYWNrQ29udHJvbHMgfTtcbiIsImltcG9ydCB7IEJhc2VHcm91cFBsYXliYWNrQ29udHJvbHMgfSBmcm9tICcuL0Jhc2VHcm91cC5tanMnO1xuXG4vKipcbiAqIFRPRE86IFRoaXMgaXMgYSB0ZW1wb3JhcnkgY2xhc3MgdG8gc3VwcG9ydCB0aGUgbGVnYWN5XG4gKiB0aGVubmFibGUgQVBJXG4gKi9cbmNsYXNzIEdyb3VwUGxheWJhY2tDb250cm9scyBleHRlbmRzIEJhc2VHcm91cFBsYXliYWNrQ29udHJvbHMge1xuICAgIHRoZW4ob25SZXNvbHZlLCBvblJlamVjdCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5hbmltYXRpb25zKS50aGVuKG9uUmVzb2x2ZSkuY2F0Y2gob25SZWplY3QpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgR3JvdXBQbGF5YmFja0NvbnRyb2xzIH07XG4iLCJmdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25cbiAgICAgICAgPyB0cmFuc2l0aW9uW2tleV0gfHxcbiAgICAgICAgICAgIHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8XG4gICAgICAgICAgICB0cmFuc2l0aW9uXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgeyBnZXRWYWx1ZVRyYW5zaXRpb24gfTtcbiIsIi8qKlxuICogSW1wbGVtZW50IGEgcHJhY3RpY2FsIG1heCBkdXJhdGlvbiBmb3Iga2V5ZnJhbWUgZ2VuZXJhdGlvblxuICogdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICovXG5jb25zdCBtYXhHZW5lcmF0b3JEdXJhdGlvbiA9IDIwMDAwO1xuZnVuY3Rpb24gY2FsY0dlbmVyYXRvckR1cmF0aW9uKGdlbmVyYXRvcikge1xuICAgIGxldCBkdXJhdGlvbiA9IDA7XG4gICAgY29uc3QgdGltZVN0ZXAgPSA1MDtcbiAgICBsZXQgc3RhdGUgPSBnZW5lcmF0b3IubmV4dChkdXJhdGlvbik7XG4gICAgd2hpbGUgKCFzdGF0ZS5kb25lICYmIGR1cmF0aW9uIDwgbWF4R2VuZXJhdG9yRHVyYXRpb24pIHtcbiAgICAgICAgZHVyYXRpb24gKz0gdGltZVN0ZXA7XG4gICAgICAgIHN0YXRlID0gZ2VuZXJhdG9yLm5leHQoZHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb24gPj0gbWF4R2VuZXJhdG9yRHVyYXRpb24gPyBJbmZpbml0eSA6IGR1cmF0aW9uO1xufVxuXG5leHBvcnQgeyBjYWxjR2VuZXJhdG9yRHVyYXRpb24sIG1heEdlbmVyYXRvckR1cmF0aW9uIH07XG4iLCJmdW5jdGlvbiBpc0dlbmVyYXRvcih0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmV4cG9ydCB7IGlzR2VuZXJhdG9yIH07XG4iLCJmdW5jdGlvbiBhdHRhY2hUaW1lbGluZShhbmltYXRpb24sIHRpbWVsaW5lKSB7XG4gICAgYW5pbWF0aW9uLnRpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgYW5pbWF0aW9uLm9uZmluaXNoID0gbnVsbDtcbn1cblxuZXhwb3J0IHsgYXR0YWNoVGltZWxpbmUgfTtcbiIsImNvbnN0IGlzQmV6aWVyRGVmaW5pdGlvbiA9IChlYXNpbmcpID0+IEFycmF5LmlzQXJyYXkoZWFzaW5nKSAmJiB0eXBlb2YgZWFzaW5nWzBdID09PSBcIm51bWJlclwiO1xuXG5leHBvcnQgeyBpc0JlemllckRlZmluaXRpb24gfTtcbiIsIi8qKlxuICogQWRkIHRoZSBhYmlsaXR5IGZvciB0ZXN0IHN1aXRlcyB0byBtYW51YWxseSBzZXQgc3VwcG9ydCBmbGFnc1xuICogdG8gYmV0dGVyIHRlc3QgbW9yZSBlbnZpcm9ubWVudHMuXG4gKi9cbmNvbnN0IHN1cHBvcnRzRmxhZ3MgPSB7XG4gICAgbGluZWFyRWFzaW5nOiB1bmRlZmluZWQsXG59O1xuXG5leHBvcnQgeyBzdXBwb3J0c0ZsYWdzIH07XG4iLCJpbXBvcnQgeyBtZW1vIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IHN1cHBvcnRzRmxhZ3MgfSBmcm9tICcuL2ZsYWdzLm1qcyc7XG5cbmZ1bmN0aW9uIG1lbW9TdXBwb3J0cyhjYWxsYmFjaywgc3VwcG9ydHNGbGFnKSB7XG4gICAgY29uc3QgbWVtb2l6ZWQgPSBtZW1vKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBzdXBwb3J0c0ZsYWdzW3N1cHBvcnRzRmxhZ10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG1lbW9pemVkKCk7IH07XG59XG5cbmV4cG9ydCB7IG1lbW9TdXBwb3J0cyB9O1xuIiwiaW1wb3J0IHsgbWVtb1N1cHBvcnRzIH0gZnJvbSAnLi9tZW1vLm1qcyc7XG5cbmNvbnN0IHN1cHBvcnRzTGluZWFyRWFzaW5nID0gLypAX19QVVJFX18qLyBtZW1vU3VwcG9ydHMoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGRvY3VtZW50XG4gICAgICAgICAgICAuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgICAgLmFuaW1hdGUoeyBvcGFjaXR5OiAwIH0sIHsgZWFzaW5nOiBcImxpbmVhcigwLCAxKVwiIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufSwgXCJsaW5lYXJFYXNpbmdcIik7XG5cbmV4cG9ydCB7IHN1cHBvcnRzTGluZWFyRWFzaW5nIH07XG4iLCIvKlxuICBQcm9ncmVzcyB3aXRoaW4gZ2l2ZW4gcmFuZ2VcblxuICBHaXZlbiBhIGxvd2VyIGxpbWl0IGFuZCBhbiB1cHBlciBsaW1pdCwgd2UgcmV0dXJuIHRoZSBwcm9ncmVzc1xuICAoZXhwcmVzc2VkIGFzIGEgbnVtYmVyIDAtMSkgcmVwcmVzZW50ZWQgYnkgdGhlIGdpdmVuIHZhbHVlLCBhbmRcbiAgbGltaXQgdGhhdCBwcm9ncmVzcyB0byB3aXRoaW4gMC0xLlxuXG4gIEBwYXJhbSBbbnVtYmVyXTogTG93ZXIgbGltaXRcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdFxuICBAcGFyYW0gW251bWJlcl06IFZhbHVlIHRvIGZpbmQgcHJvZ3Jlc3Mgd2l0aGluIGdpdmVuIHJhbmdlXG4gIEByZXR1cm4gW251bWJlcl06IFByb2dyZXNzIG9mIHZhbHVlIHdpdGhpbiByYW5nZSBhcyBleHByZXNzZWQgMC0xXG4qL1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5jb25zdCBwcm9ncmVzcyA9IChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICBjb25zdCB0b0Zyb21EaWZmZXJlbmNlID0gdG8gLSBmcm9tO1xuICAgIHJldHVybiB0b0Zyb21EaWZmZXJlbmNlID09PSAwID8gMSA6ICh2YWx1ZSAtIGZyb20pIC8gdG9Gcm9tRGlmZmVyZW5jZTtcbn07XG5cbmV4cG9ydCB7IHByb2dyZXNzIH07XG4iLCJpbXBvcnQgeyBwcm9ncmVzcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5cbmNvbnN0IGdlbmVyYXRlTGluZWFyRWFzaW5nID0gKGVhc2luZywgZHVyYXRpb24sIC8vIGFzIG1pbGxpc2Vjb25kc1xucmVzb2x1dGlvbiA9IDEwIC8vIGFzIG1pbGxpc2Vjb25kc1xuKSA9PiB7XG4gICAgbGV0IHBvaW50cyA9IFwiXCI7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gTWF0aC5tYXgoTWF0aC5yb3VuZChkdXJhdGlvbiAvIHJlc29sdXRpb24pLCAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICAgIHBvaW50cyArPSBlYXNpbmcocHJvZ3Jlc3MoMCwgbnVtUG9pbnRzIC0gMSwgaSkpICsgXCIsIFwiO1xuICAgIH1cbiAgICByZXR1cm4gYGxpbmVhcigke3BvaW50cy5zdWJzdHJpbmcoMCwgcG9pbnRzLmxlbmd0aCAtIDIpfSlgO1xufTtcblxuZXhwb3J0IHsgZ2VuZXJhdGVMaW5lYXJFYXNpbmcgfTtcbiIsImltcG9ydCB7IGlzQmV6aWVyRGVmaW5pdGlvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2lzLWJlemllci1kZWZpbml0aW9uLm1qcyc7XG5pbXBvcnQgeyBzdXBwb3J0c0xpbmVhckVhc2luZyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3N1cHBvcnRzL2xpbmVhci1lYXNpbmcubWpzJztcbmltcG9ydCB7IGdlbmVyYXRlTGluZWFyRWFzaW5nIH0gZnJvbSAnLi9saW5lYXIubWpzJztcblxuZnVuY3Rpb24gaXNXYWFwaVN1cHBvcnRlZEVhc2luZyhlYXNpbmcpIHtcbiAgICByZXR1cm4gQm9vbGVhbigodHlwZW9mIGVhc2luZyA9PT0gXCJmdW5jdGlvblwiICYmIHN1cHBvcnRzTGluZWFyRWFzaW5nKCkpIHx8XG4gICAgICAgICFlYXNpbmcgfHxcbiAgICAgICAgKHR5cGVvZiBlYXNpbmcgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIChlYXNpbmcgaW4gc3VwcG9ydGVkV2FhcGlFYXNpbmcgfHwgc3VwcG9ydHNMaW5lYXJFYXNpbmcoKSkpIHx8XG4gICAgICAgIGlzQmV6aWVyRGVmaW5pdGlvbihlYXNpbmcpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KGVhc2luZykgJiYgZWFzaW5nLmV2ZXJ5KGlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcpKSk7XG59XG5jb25zdCBjdWJpY0JlemllckFzU3RyaW5nID0gKFthLCBiLCBjLCBkXSkgPT4gYGN1YmljLWJlemllcigke2F9LCAke2J9LCAke2N9LCAke2R9KWA7XG5jb25zdCBzdXBwb3J0ZWRXYWFwaUVhc2luZyA9IHtcbiAgICBsaW5lYXI6IFwibGluZWFyXCIsXG4gICAgZWFzZTogXCJlYXNlXCIsXG4gICAgZWFzZUluOiBcImVhc2UtaW5cIixcbiAgICBlYXNlT3V0OiBcImVhc2Utb3V0XCIsXG4gICAgZWFzZUluT3V0OiBcImVhc2UtaW4tb3V0XCIsXG4gICAgY2lyY0luOiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAsIDAuNjUsIDAuNTUsIDFdKSxcbiAgICBjaXJjT3V0OiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAuNTUsIDAsIDEsIDAuNDVdKSxcbiAgICBiYWNrSW46IC8qQF9fUFVSRV9fKi8gY3ViaWNCZXppZXJBc1N0cmluZyhbMC4zMSwgMC4wMSwgMC42NiwgLTAuNTldKSxcbiAgICBiYWNrT3V0OiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAuMzMsIDEuNTMsIDAuNjksIDAuOTldKSxcbn07XG5mdW5jdGlvbiBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyhlYXNpbmcsIGR1cmF0aW9uKSB7XG4gICAgaWYgKCFlYXNpbmcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGVhc2luZyA9PT0gXCJmdW5jdGlvblwiICYmIHN1cHBvcnRzTGluZWFyRWFzaW5nKCkpIHtcbiAgICAgICAgcmV0dXJuIGdlbmVyYXRlTGluZWFyRWFzaW5nKGVhc2luZywgZHVyYXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JlemllckRlZmluaXRpb24oZWFzaW5nKSkge1xuICAgICAgICByZXR1cm4gY3ViaWNCZXppZXJBc1N0cmluZyhlYXNpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGVhc2luZykpIHtcbiAgICAgICAgcmV0dXJuIGVhc2luZy5tYXAoKHNlZ21lbnRFYXNpbmcpID0+IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nKHNlZ21lbnRFYXNpbmcsIGR1cmF0aW9uKSB8fFxuICAgICAgICAgICAgc3VwcG9ydGVkV2FhcGlFYXNpbmcuZWFzZU91dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwcG9ydGVkV2FhcGlFYXNpbmdbZWFzaW5nXTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGN1YmljQmV6aWVyQXNTdHJpbmcsIGlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcsIG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nLCBzdXBwb3J0ZWRXYWFwaUVhc2luZyB9O1xuIiwiY29uc3QgaXNEcmFnZ2luZyA9IHtcbiAgICB4OiBmYWxzZSxcbiAgICB5OiBmYWxzZSxcbn07XG5mdW5jdGlvbiBpc0RyYWdBY3RpdmUoKSB7XG4gICAgcmV0dXJuIGlzRHJhZ2dpbmcueCB8fCBpc0RyYWdnaW5nLnk7XG59XG5cbmV4cG9ydCB7IGlzRHJhZ0FjdGl2ZSwgaXNEcmFnZ2luZyB9O1xuIiwiZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnRzKGVsZW1lbnRPclNlbGVjdG9yLCBzY29wZSwgc2VsZWN0b3JDYWNoZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZWxlbWVudE9yU2VsZWN0b3IgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbZWxlbWVudE9yU2VsZWN0b3JdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZWxlbWVudE9yU2VsZWN0b3IgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbGV0IHJvb3QgPSBkb2N1bWVudDtcbiAgICAgICAgaWYgKHNjb3BlKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZWZhY3RvciB0byB1dGlscyBwYWNrYWdlXG4gICAgICAgICAgICAvLyBpbnZhcmlhbnQoXG4gICAgICAgICAgICAvLyAgICAgQm9vbGVhbihzY29wZS5jdXJyZW50KSxcbiAgICAgICAgICAgIC8vICAgICBcIlNjb3BlIHByb3ZpZGVkLCBidXQgbm8gZWxlbWVudCBkZXRlY3RlZC5cIlxuICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgcm9vdCA9IHNjb3BlLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSAoX2EgPSBzZWxlY3RvckNhY2hlID09PSBudWxsIHx8IHNlbGVjdG9yQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdG9yQ2FjaGVbZWxlbWVudE9yU2VsZWN0b3JdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudE9yU2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMgPyBBcnJheS5mcm9tKGVsZW1lbnRzKSA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShlbGVtZW50T3JTZWxlY3Rvcik7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVFbGVtZW50cyB9O1xuIiwiaW1wb3J0IHsgcmVzb2x2ZUVsZW1lbnRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvcmVzb2x2ZS1lbGVtZW50cy5tanMnO1xuXG5mdW5jdGlvbiBzZXR1cEdlc3R1cmUoZWxlbWVudE9yU2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHJlc29sdmVFbGVtZW50cyhlbGVtZW50T3JTZWxlY3Rvcik7XG4gICAgY29uc3QgZ2VzdHVyZUFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBjb25zdCBldmVudE9wdGlvbnMgPSB7XG4gICAgICAgIHBhc3NpdmU6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHNpZ25hbDogZ2VzdHVyZUFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgfTtcbiAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiBnZXN0dXJlQWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgcmV0dXJuIFtlbGVtZW50cywgZXZlbnRPcHRpb25zLCBjYW5jZWxdO1xufVxuXG5leHBvcnQgeyBzZXR1cEdlc3R1cmUgfTtcbiIsImltcG9ydCB7IGlzRHJhZ0FjdGl2ZSB9IGZyb20gJy4vZHJhZy9zdGF0ZS9pcy1hY3RpdmUubWpzJztcbmltcG9ydCB7IHNldHVwR2VzdHVyZSB9IGZyb20gJy4vdXRpbHMvc2V0dXAubWpzJztcblxuZnVuY3Rpb24gaXNWYWxpZEhvdmVyKGV2ZW50KSB7XG4gICAgcmV0dXJuICEoZXZlbnQucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCBpc0RyYWdBY3RpdmUoKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIGhvdmVyIGdlc3R1cmUuIGhvdmVyKCkgaXMgZGlmZmVyZW50IHRvIC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIpXG4gKiBpbiB0aGF0IGl0IGhhcyBhbiBlYXNpZXIgc3ludGF4LCBmaWx0ZXJzIG91dCBwb2x5ZmlsbGVkIHRvdWNoIGV2ZW50cywgaW50ZXJvcGVyYXRlc1xuICogd2l0aCBkcmFnIGdlc3R1cmVzLCBhbmQgYXV0b21hdGljYWxseSByZW1vdmVzIHRoZSBcInBvaW50ZXJlbm5kXCIgZXZlbnQgbGlzdGVuZXIgd2hlbiB0aGUgaG92ZXIgZW5kcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGhvdmVyKGVsZW1lbnRPclNlbGVjdG9yLCBvbkhvdmVyU3RhcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IFtlbGVtZW50cywgZXZlbnRPcHRpb25zLCBjYW5jZWxdID0gc2V0dXBHZXN0dXJlKGVsZW1lbnRPclNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICBjb25zdCBvblBvaW50ZXJFbnRlciA9IChlbnRlckV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghaXNWYWxpZEhvdmVyKGVudGVyRXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gZW50ZXJFdmVudDtcbiAgICAgICAgY29uc3Qgb25Ib3ZlckVuZCA9IG9uSG92ZXJTdGFydCh0YXJnZXQsIGVudGVyRXZlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIG9uSG92ZXJFbmQgIT09IFwiZnVuY3Rpb25cIiB8fCAhdGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvblBvaW50ZXJMZWF2ZSA9IChsZWF2ZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRIb3ZlcihsZWF2ZUV2ZW50KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBvbkhvdmVyRW5kKGxlYXZlRXZlbnQpO1xuICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgb25Qb2ludGVyTGVhdmUpO1xuICAgICAgICB9O1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCBvblBvaW50ZXJMZWF2ZSwgZXZlbnRPcHRpb25zKTtcbiAgICB9O1xuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIG9uUG9pbnRlckVudGVyLCBldmVudE9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYW5jZWw7XG59XG5cbmV4cG9ydCB7IGhvdmVyIH07XG4iLCIvKipcbiAqIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHVwIHRoZSB0cmVlIHRvIGNoZWNrIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGNoaWxkIG5vZGVcbiAqIGlzIHRoZSBwYXJlbnQgb3IgYSBkZXNjZW5kYW50IG9mIGl0LlxuICpcbiAqIEBwYXJhbSBwYXJlbnQgLSBFbGVtZW50IHRvIGZpbmRcbiAqIEBwYXJhbSBjaGlsZCAtIEVsZW1lbnQgdG8gdGVzdCBhZ2FpbnN0IHBhcmVudFxuICovXG5jb25zdCBpc05vZGVPckNoaWxkID0gKHBhcmVudCwgY2hpbGQpID0+IHtcbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50ID09PSBjaGlsZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc05vZGVPckNoaWxkKHBhcmVudCwgY2hpbGQucGFyZW50RWxlbWVudCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgaXNOb2RlT3JDaGlsZCB9O1xuIiwiY29uc3QgaXNQcmltYXJ5UG9pbnRlciA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gXCJtb3VzZVwiKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZXZlbnQuYnV0dG9uICE9PSBcIm51bWJlclwiIHx8IGV2ZW50LmJ1dHRvbiA8PSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlzUHJpbWFyeSBpcyB0cnVlIGZvciBhbGwgbWljZSBidXR0b25zLCB3aGVyZWFzIGV2ZXJ5IHRvdWNoIHBvaW50XG4gICAgICAgICAqIGlzIHJlZ2FyZGVkIGFzIGl0cyBvd24gaW5wdXQuIFNvIHN1YnNlcXVlbnQgY29uY3VycmVudCB0b3VjaCBwb2ludHNcbiAgICAgICAgICogd2lsbCBiZSBmYWxzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogU3BlY2lmaWNhbGx5IG1hdGNoIGFnYWluc3QgZmFsc2UgaGVyZSBhcyBpbmNvbXBsZXRlIHZlcnNpb25zIG9mXG4gICAgICAgICAqIFBvaW50ZXJFdmVudHMgaW4gdmVyeSBvbGQgYnJvd3NlciBtaWdodCBoYXZlIGl0IHNldCBhcyB1bmRlZmluZWQuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZXZlbnQuaXNQcmltYXJ5ICE9PSBmYWxzZTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBpc1ByaW1hcnlQb2ludGVyIH07XG4iLCJjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IG5ldyBTZXQoW1xuICAgIFwiQlVUVE9OXCIsXG4gICAgXCJJTlBVVFwiLFxuICAgIFwiU0VMRUNUXCIsXG4gICAgXCJURVhUQVJFQVwiLFxuICAgIFwiQVwiLFxuXSk7XG5mdW5jdGlvbiBpc0VsZW1lbnRLZXlib2FyZEFjY2Vzc2libGUoZWxlbWVudCkge1xuICAgIHJldHVybiAoZm9jdXNhYmxlRWxlbWVudHMuaGFzKGVsZW1lbnQudGFnTmFtZSkgfHxcbiAgICAgICAgZWxlbWVudC50YWJJbmRleCAhPT0gLTEpO1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnRLZXlib2FyZEFjY2Vzc2libGUgfTtcbiIsImNvbnN0IGlzUHJlc3NpbmcgPSBuZXcgV2Vha1NldCgpO1xuXG5leHBvcnQgeyBpc1ByZXNzaW5nIH07XG4iLCJpbXBvcnQgeyBpc1ByZXNzaW5nIH0gZnJvbSAnLi9zdGF0ZS5tanMnO1xuXG4vKipcbiAqIEZpbHRlciBvdXQgZXZlbnRzIHRoYXQgYXJlIG5vdCBcIkVudGVyXCIga2V5cy5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyRXZlbnRzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBcIkVudGVyXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGxiYWNrKGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZmlyZVBvaW50ZXJFdmVudCh0YXJnZXQsIHR5cGUpIHtcbiAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChuZXcgUG9pbnRlckV2ZW50KFwicG9pbnRlclwiICsgdHlwZSwgeyBpc1ByaW1hcnk6IHRydWUsIGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuY29uc3QgZW5hYmxlS2V5Ym9hcmRQcmVzcyA9IChmb2N1c0V2ZW50LCBldmVudE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBlbGVtZW50ID0gZm9jdXNFdmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGlmICghZWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGhhbmRsZUtleWRvd24gPSBmaWx0ZXJFdmVudHMoKCkgPT4ge1xuICAgICAgICBpZiAoaXNQcmVzc2luZy5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZpcmVQb2ludGVyRXZlbnQoZWxlbWVudCwgXCJkb3duXCIpO1xuICAgICAgICBjb25zdCBoYW5kbGVLZXl1cCA9IGZpbHRlckV2ZW50cygoKSA9PiB7XG4gICAgICAgICAgICBmaXJlUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwidXBcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVCbHVyID0gKCkgPT4gZmlyZVBvaW50ZXJFdmVudChlbGVtZW50LCBcImNhbmNlbFwiKTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgaGFuZGxlS2V5dXAsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgaGFuZGxlQmx1ciwgZXZlbnRPcHRpb25zKTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGhhbmRsZUtleWRvd24sIGV2ZW50T3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgZmlyZXMgb24gYmx1ciB0byByZW1vdmUgdGhlIGtleWRvd24gZXZlbnRzLlxuICAgICAqL1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlkb3duKSwgZXZlbnRPcHRpb25zKTtcbn07XG5cbmV4cG9ydCB7IGVuYWJsZUtleWJvYXJkUHJlc3MgfTtcbiIsImltcG9ydCB7IGlzRHJhZ0FjdGl2ZSB9IGZyb20gJy4uL2RyYWcvc3RhdGUvaXMtYWN0aXZlLm1qcyc7XG5pbXBvcnQgeyBpc05vZGVPckNoaWxkIH0gZnJvbSAnLi4vdXRpbHMvaXMtbm9kZS1vci1jaGlsZC5tanMnO1xuaW1wb3J0IHsgaXNQcmltYXJ5UG9pbnRlciB9IGZyb20gJy4uL3V0aWxzL2lzLXByaW1hcnktcG9pbnRlci5tanMnO1xuaW1wb3J0IHsgc2V0dXBHZXN0dXJlIH0gZnJvbSAnLi4vdXRpbHMvc2V0dXAubWpzJztcbmltcG9ydCB7IGlzRWxlbWVudEtleWJvYXJkQWNjZXNzaWJsZSB9IGZyb20gJy4vdXRpbHMvaXMta2V5Ym9hcmQtYWNjZXNzaWJsZS5tanMnO1xuaW1wb3J0IHsgZW5hYmxlS2V5Ym9hcmRQcmVzcyB9IGZyb20gJy4vdXRpbHMva2V5Ym9hcmQubWpzJztcbmltcG9ydCB7IGlzUHJlc3NpbmcgfSBmcm9tICcuL3V0aWxzL3N0YXRlLm1qcyc7XG5cbi8qKlxuICogRmlsdGVyIG91dCBldmVudHMgdGhhdCBhcmUgbm90IHByaW1hcnkgcG9pbnRlciBldmVudHMsIG9yIGFyZSB0cmlnZ2VyaW5nXG4gKiB3aGlsZSBhIE1vdGlvbiBnZXN0dXJlIGlzIGFjdGl2ZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFByZXNzRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gaXNQcmltYXJ5UG9pbnRlcihldmVudCkgJiYgIWlzRHJhZ0FjdGl2ZSgpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBwcmVzcyBnZXN0dXJlLlxuICpcbiAqIFByZXNzIGlzIGRpZmZlcmVudCB0byBgXCJwb2ludGVyZG93blwiYCwgYFwicG9pbnRlcnVwXCJgIGluIHRoYXQgaXRcbiAqIGF1dG9tYXRpY2FsbHkgZmlsdGVycyBvdXQgc2Vjb25kYXJ5IHBvaW50ZXIgZXZlbnRzIGxpa2UgcmlnaHRcbiAqIGNsaWNrIGFuZCBtdWx0aXRvdWNoLlxuICpcbiAqIEl0IGFsc28gYWRkcyBhY2Nlc3NpYmlsaXR5IHN1cHBvcnQgZm9yIGtleWJvYXJkcywgd2hlcmVcbiAqIGFuIGVsZW1lbnQgd2l0aCBhIHByZXNzIGdlc3R1cmUgd2lsbCByZWNlaXZlIGZvY3VzIGFuZFxuICogIHRyaWdnZXIgb24gRW50ZXIgYFwia2V5ZG93blwiYCBhbmQgYFwia2V5dXBcImAgZXZlbnRzLlxuICpcbiAqIFRoaXMgaXMgZGlmZmVyZW50IHRvIGEgYnJvd3NlcidzIGBcImNsaWNrXCJgIGV2ZW50LCB3aGljaCBkb2VzXG4gKiByZXNwb25kIHRvIGtleWJvYXJkcyBidXQgb25seSBmb3IgdGhlIGBcImNsaWNrXCJgIGl0c2VsZiwgcmF0aGVyXG4gKiB0aGFuIHRoZSBwcmVzcyBzdGFydCBhbmQgZW5kL2NhbmNlbC4gVGhlIGVsZW1lbnQgYWxzbyBuZWVkc1xuICogdG8gYmUgZm9jdXNhYmxlIGZvciB0aGlzIHRvIHdvcmssIHdoZXJlYXMgYSBwcmVzcyBnZXN0dXJlIHdpbGxcbiAqIG1ha2UgYW4gZWxlbWVudCBmb2N1c2FibGUgYnkgZGVmYXVsdC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHByZXNzKGVsZW1lbnRPclNlbGVjdG9yLCBvblByZXNzU3RhcnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IFtlbGVtZW50cywgZXZlbnRPcHRpb25zLCBjYW5jZWxFdmVudHNdID0gc2V0dXBHZXN0dXJlKGVsZW1lbnRPclNlbGVjdG9yLCBvcHRpb25zKTtcbiAgICBjb25zdCBzdGFydFByZXNzID0gKHN0YXJ0RXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXJ0RXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgaWYgKCFpc1ZhbGlkUHJlc3NFdmVudChzdGFydEV2ZW50KSB8fCBpc1ByZXNzaW5nLmhhcyhlbGVtZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaXNQcmVzc2luZy5hZGQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IG9uUHJlc3NFbmQgPSBvblByZXNzU3RhcnQoZWxlbWVudCwgc3RhcnRFdmVudCk7XG4gICAgICAgIGNvbnN0IG9uUG9pbnRlckVuZCA9IChlbmRFdmVudCwgc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgb25Qb2ludGVyVXApO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRQcmVzc0V2ZW50KGVuZEV2ZW50KSB8fCAhaXNQcmVzc2luZy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1ByZXNzaW5nLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25QcmVzc0VuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25QcmVzc0VuZChlbmRFdmVudCwgeyBzdWNjZXNzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblBvaW50ZXJVcCA9ICh1cEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvblBvaW50ZXJFbmQodXBFdmVudCwgb3B0aW9ucy51c2VHbG9iYWxUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICBpc05vZGVPckNoaWxkKGVsZW1lbnQsIHVwRXZlbnQudGFyZ2V0KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uUG9pbnRlckNhbmNlbCA9IChjYW5jZWxFdmVudCkgPT4ge1xuICAgICAgICAgICAgb25Qb2ludGVyRW5kKGNhbmNlbEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBldmVudE9wdGlvbnMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyQ2FuY2VsLCBldmVudE9wdGlvbnMpO1xuICAgIH07XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICBpZiAoIWlzRWxlbWVudEtleWJvYXJkQWNjZXNzaWJsZShlbGVtZW50KSAmJlxuICAgICAgICAgICAgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy51c2VHbG9iYWxUYXJnZXQgPyB3aW5kb3cgOiBlbGVtZW50O1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0YXJ0UHJlc3MsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIChldmVudCkgPT4gZW5hYmxlS2V5Ym9hcmRQcmVzcyhldmVudCwgZXZlbnRPcHRpb25zKSwgZXZlbnRPcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsRXZlbnRzO1xufVxuXG5leHBvcnQgeyBwcmVzcyB9O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICpcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGltZSBpbiBzZWNvbmRzLlxuICogQHJldHVybiBtaWxsaXNlY29uZHMgLSBDb252ZXJ0ZWQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuY29uc3Qgc2Vjb25kc1RvTWlsbGlzZWNvbmRzID0gKHNlY29uZHMpID0+IHNlY29uZHMgKiAxMDAwO1xuLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5jb25zdCBtaWxsaXNlY29uZHNUb1NlY29uZHMgPSAobWlsbGlzZWNvbmRzKSA9PiBtaWxsaXNlY29uZHMgLyAxMDAwO1xuXG5leHBvcnQgeyBtaWxsaXNlY29uZHNUb1NlY29uZHMsIHNlY29uZHNUb01pbGxpc2Vjb25kcyB9O1xuIiwiLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5jb25zdCBub29wID0gKGFueSkgPT4gYW55O1xuXG5leHBvcnQgeyBub29wIH07XG4iLCJpbXBvcnQgeyBtaWxsaXNlY29uZHNUb1NlY29uZHMsIHNlY29uZHNUb01pbGxpc2Vjb25kcywgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBhdHRhY2hUaW1lbGluZSB9IGZyb20gJy4vdXRpbHMvYXR0YWNoLXRpbWVsaW5lLm1qcyc7XG5cbmNsYXNzIE5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uSW5NcyA9ICgoX2IgPSAoX2EgPSB0aGlzLmFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVmZmVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldENvbXB1dGVkVGltaW5nKCkuZHVyYXRpb24pIHx8XG4gICAgICAgICAgICAoKF9jID0gdGhpcy5vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZHVyYXRpb24pIHx8XG4gICAgICAgICAgICAzMDA7XG4gICAgICAgIHJldHVybiBtaWxsaXNlY29uZHNUb1NlY29uZHMoTnVtYmVyKGR1cmF0aW9uSW5NcykpO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBtaWxsaXNlY29uZHNUb1NlY29uZHMoKChfYSA9IHRoaXMuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFRpbWUpIHx8IDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzZXQgdGltZShuZXdUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uY3VycmVudFRpbWUgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMobmV3VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNwZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24gPyB0aGlzLmFuaW1hdGlvbi5wbGF5YmFja1JhdGUgOiAxO1xuICAgIH1cbiAgICBzZXQgc3BlZWQobmV3U3BlZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5wbGF5YmFja1JhdGUgPSBuZXdTcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbiA/IHRoaXMuYW5pbWF0aW9uLnBsYXlTdGF0ZSA6IFwiZmluaXNoZWRcIjtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uID8gdGhpcy5hbmltYXRpb24uc3RhcnRUaW1lIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGZpbmlzaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24gPyB0aGlzLmFuaW1hdGlvbi5maW5pc2hlZCA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiAmJiB0aGlzLmFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiAmJiB0aGlzLmFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uIHx8XG4gICAgICAgICAgICB0aGlzLnN0YXRlID09PSBcImlkbGVcIiB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uLmNvbW1pdFN0eWxlcykge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uY29tbWl0U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuYW5pbWF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAoX2EgPSB0aGlzLmFuaW1hdGlvbi5lZmZlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVUaW1pbmcoeyBlYXNpbmc6IFwibGluZWFyXCIgfSk7XG4gICAgfVxuICAgIGF0dGFjaFRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbilcbiAgICAgICAgICAgIGF0dGFjaFRpbWVsaW5lKHRoaXMuYW5pbWF0aW9uLCB0aW1lbGluZSk7XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gJiYgdGhpcy5hbmltYXRpb24uZmluaXNoKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uICYmIHRoaXMuYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IE5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIH07XG4iLCJpbXBvcnQgeyBtaWxsaXNlY29uZHNUb1NlY29uZHMgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgY2FsY0dlbmVyYXRvckR1cmF0aW9uLCBtYXhHZW5lcmF0b3JEdXJhdGlvbiB9IGZyb20gJy4vY2FsYy1kdXJhdGlvbi5tanMnO1xuXG4vKipcbiAqIENyZWF0ZSBhIHByb2dyZXNzID0+IHByb2dyZXNzIGVhc2luZyBmdW5jdGlvbiBmcm9tIGEgZ2VuZXJhdG9yLlxuICovXG5mdW5jdGlvbiBjcmVhdGVHZW5lcmF0b3JFYXNpbmcob3B0aW9ucywgc2NhbGUgPSAxMDAsIGNyZWF0ZUdlbmVyYXRvcikge1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IGNyZWF0ZUdlbmVyYXRvcih7IC4uLm9wdGlvbnMsIGtleWZyYW1lczogWzAsIHNjYWxlXSB9KTtcbiAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGgubWluKGNhbGNHZW5lcmF0b3JEdXJhdGlvbihnZW5lcmF0b3IpLCBtYXhHZW5lcmF0b3JEdXJhdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICAgICAgZWFzZTogKHByb2dyZXNzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLm5leHQoZHVyYXRpb24gKiBwcm9ncmVzcykudmFsdWUgLyBzY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgZHVyYXRpb246IG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhkdXJhdGlvbiksXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlR2VuZXJhdG9yRWFzaW5nIH07XG4iLCJpbXBvcnQgeyBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgc3VwcG9ydHNMaW5lYXJFYXNpbmcgfSBmcm9tICcuLi8uLi8uLi91dGlscy9zdXBwb3J0cy9saW5lYXItZWFzaW5nLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVHZW5lcmF0b3JFYXNpbmcgfSBmcm9tICcuLi8uLi9nZW5lcmF0b3JzL3V0aWxzL2NyZWF0ZS1nZW5lcmF0b3ItZWFzaW5nLm1qcyc7XG5pbXBvcnQgeyBpc0dlbmVyYXRvciB9IGZyb20gJy4uLy4uL2dlbmVyYXRvcnMvdXRpbHMvaXMtZ2VuZXJhdG9yLm1qcyc7XG5pbXBvcnQgeyBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyB9IGZyb20gJy4vZWFzaW5nLm1qcyc7XG5cbmNvbnN0IGRlZmF1bHRFYXNpbmcgPSBcImVhc2VPdXRcIjtcbmZ1bmN0aW9uIGFwcGx5R2VuZXJhdG9yT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpc0dlbmVyYXRvcihvcHRpb25zLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvck9wdGlvbnMgPSBjcmVhdGVHZW5lcmF0b3JFYXNpbmcob3B0aW9ucywgMTAwLCBvcHRpb25zLnR5cGUpO1xuICAgICAgICBvcHRpb25zLmVhc2UgPSBzdXBwb3J0c0xpbmVhckVhc2luZygpXG4gICAgICAgICAgICA/IGdlbmVyYXRvck9wdGlvbnMuZWFzZVxuICAgICAgICAgICAgOiBkZWZhdWx0RWFzaW5nO1xuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGdlbmVyYXRvck9wdGlvbnMuZHVyYXRpb24pO1xuICAgICAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IHNlY29uZHNUb01pbGxpc2Vjb25kcygoX2EgPSBvcHRpb25zLmR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLjMpO1xuICAgICAgICBvcHRpb25zLmVhc2UgPSBvcHRpb25zLmVhc2UgfHwgZGVmYXVsdEVhc2luZztcbiAgICB9XG59XG4vLyBUT0RPOiBSZXVzZSBmb3IgTmF0aXZlQW5pbWF0aW9uXG5mdW5jdGlvbiBjb252ZXJ0TW90aW9uT3B0aW9uc1RvTmF0aXZlKHZhbHVlTmFtZSwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5hdGl2ZUtleWZyYW1lcyA9IHt9O1xuICAgIGNvbnN0IG5hdGl2ZU9wdGlvbnMgPSB7XG4gICAgICAgIGZpbGw6IFwiYm90aFwiLFxuICAgICAgICBlYXNpbmc6IFwibGluZWFyXCIsXG4gICAgICAgIGNvbXBvc2l0ZTogXCJyZXBsYWNlXCIsXG4gICAgfTtcbiAgICBuYXRpdmVPcHRpb25zLmRlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKChfYSA9IG9wdGlvbnMuZGVsYXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgIGFwcGx5R2VuZXJhdG9yT3B0aW9ucyhvcHRpb25zKTtcbiAgICBuYXRpdmVPcHRpb25zLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICBjb25zdCB7IGVhc2UsIHRpbWVzIH0gPSBvcHRpb25zO1xuICAgIGlmICh0aW1lcylcbiAgICAgICAgbmF0aXZlS2V5ZnJhbWVzLm9mZnNldCA9IHRpbWVzO1xuICAgIG5hdGl2ZUtleWZyYW1lc1t2YWx1ZU5hbWVdID0ga2V5ZnJhbWVzO1xuICAgIGNvbnN0IGVhc2luZyA9IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nKGVhc2UsIG9wdGlvbnMuZHVyYXRpb24pO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYW4gZWFzaW5nIGFycmF5LCBhcHBseSB0byBrZXlmcmFtZXMsIG5vdCBhbmltYXRpb24gYXMgYSB3aG9sZVxuICAgICAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVhc2luZykpIHtcbiAgICAgICAgbmF0aXZlS2V5ZnJhbWVzLmVhc2luZyA9IGVhc2luZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5hdGl2ZU9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBrZXlmcmFtZXM6IG5hdGl2ZUtleWZyYW1lcyxcbiAgICAgICAgb3B0aW9uczogbmF0aXZlT3B0aW9ucyxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhcHBseUdlbmVyYXRvck9wdGlvbnMsIGNvbnZlcnRNb3Rpb25PcHRpb25zVG9OYXRpdmUgfTtcbiIsImltcG9ydCB7IE5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi9OYXRpdmVBbmltYXRpb25Db250cm9scy5tanMnO1xuaW1wb3J0IHsgY29udmVydE1vdGlvbk9wdGlvbnNUb05hdGl2ZSB9IGZyb20gJy4vdXRpbHMvY29udmVydC1vcHRpb25zLm1qcyc7XG5cbmNsYXNzIFBzZXVkb0FuaW1hdGlvbiBleHRlbmRzIE5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBzZXVkb0VsZW1lbnQsIHZhbHVlTmFtZSwga2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjb252ZXJ0TW90aW9uT3B0aW9uc1RvTmF0aXZlKHZhbHVlTmFtZSwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gdGFyZ2V0LmFuaW1hdGUoYW5pbWF0aW9uT3B0aW9ucy5rZXlmcmFtZXMsIHtcbiAgICAgICAgICAgIHBzZXVkb0VsZW1lbnQsXG4gICAgICAgICAgICAuLi5hbmltYXRpb25PcHRpb25zLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICBzdXBlcihhbmltYXRpb24pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUHNldWRvQW5pbWF0aW9uIH07XG4iLCJsZXQgcGVuZGluZ1J1bGVzID0ge307XG5sZXQgc3R5bGUgPSBudWxsO1xuY29uc3QgY3NzID0ge1xuICAgIHNldDogKHNlbGVjdG9yLCB2YWx1ZXMpID0+IHtcbiAgICAgICAgcGVuZGluZ1J1bGVzW3NlbGVjdG9yXSA9IHZhbHVlcztcbiAgICB9LFxuICAgIGNvbW1pdDogKCkgPT4ge1xuICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICAgIHN0eWxlLmlkID0gXCJtb3Rpb24tdmlld1wiO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjc3NUZXh0ID0gXCJcIjtcbiAgICAgICAgZm9yIChjb25zdCBzZWxlY3RvciBpbiBwZW5kaW5nUnVsZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBwZW5kaW5nUnVsZXNbc2VsZWN0b3JdO1xuICAgICAgICAgICAgY3NzVGV4dCArPSBgJHtzZWxlY3Rvcn0ge1xcbmA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgY3NzVGV4dCArPSBgICAke3Byb3BlcnR5fTogJHt2YWx1ZX07XFxuYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNzc1RleHQgKz0gXCJ9XFxuXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgcGVuZGluZ1J1bGVzID0ge307XG4gICAgfSxcbiAgICByZW1vdmU6ICgpID0+IHtcbiAgICAgICAgaWYgKHN0eWxlICYmIHN0eWxlLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHN0eWxlLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGNzcyB9O1xuIiwiaW1wb3J0IHsgc2Vjb25kc1RvTWlsbGlzZWNvbmRzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IEJhc2VHcm91cFBsYXliYWNrQ29udHJvbHMgfSBmcm9tICcuLi9hbmltYXRpb24vY29udHJvbHMvQmFzZUdyb3VwLm1qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZVRyYW5zaXRpb24gfSBmcm9tICcuLi9hbmltYXRpb24vdXRpbHMvZ2V0LXZhbHVlLXRyYW5zaXRpb24ubWpzJztcbmltcG9ydCB7IE5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vYW5pbWF0aW9uL3dhYXBpL05hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzLm1qcyc7XG5pbXBvcnQgeyBQc2V1ZG9BbmltYXRpb24gfSBmcm9tICcuLi9hbmltYXRpb24vd2FhcGkvUHNldWRvQW5pbWF0aW9uLm1qcyc7XG5pbXBvcnQgeyBhcHBseUdlbmVyYXRvck9wdGlvbnMgfSBmcm9tICcuLi9hbmltYXRpb24vd2FhcGkvdXRpbHMvY29udmVydC1vcHRpb25zLm1qcyc7XG5pbXBvcnQgeyBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyB9IGZyb20gJy4uL2FuaW1hdGlvbi93YWFwaS91dGlscy9lYXNpbmcubWpzJztcbmltcG9ydCB7IGNob29zZUxheWVyVHlwZSB9IGZyb20gJy4vdXRpbHMvY2hvb3NlLWxheWVyLXR5cGUubWpzJztcbmltcG9ydCB7IGNzcyB9IGZyb20gJy4vdXRpbHMvY3NzLm1qcyc7XG5pbXBvcnQgeyBnZXRMYXllck5hbWUgfSBmcm9tICcuL3V0aWxzL2dldC1sYXllci1uYW1lLm1qcyc7XG5pbXBvcnQgeyBnZXRWaWV3QW5pbWF0aW9ucyB9IGZyb20gJy4vdXRpbHMvZ2V0LXZpZXctYW5pbWF0aW9ucy5tanMnO1xuaW1wb3J0IHsgaGFzVGFyZ2V0IH0gZnJvbSAnLi91dGlscy9oYXMtdGFyZ2V0Lm1qcyc7XG5cbmNvbnN0IGRlZmluaXRpb25OYW1lcyA9IFtcImxheW91dFwiLCBcImVudGVyXCIsIFwiZXhpdFwiLCBcIm5ld1wiLCBcIm9sZFwiXTtcbmZ1bmN0aW9uIHN0YXJ0Vmlld0FuaW1hdGlvbih1cGRhdGUsIGRlZmF1bHRPcHRpb25zLCB0YXJnZXRzKSB7XG4gICAgaWYgKCFkb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdXBkYXRlKCk7XG4gICAgICAgICAgICByZXNvbHZlKG5ldyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzKFtdKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUT0RPOiBHbyBvdmVyIGV4aXN0aW5nIHRhcmdldHMgYW5kIGVuc3VyZSB0aGV5IGFsbCBoYXZlIGlkc1xuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgYW55IGFuaW1hdGlvbnMgZGVmaW5lZCBmb3IgdGhlIHJvb3QgdGFyZ2V0LFxuICAgICAqIHJlbW92ZSBpdCBmcm9tIGJlaW5nIGNhcHR1cmVkLlxuICAgICAqL1xuICAgIGlmICghaGFzVGFyZ2V0KFwicm9vdFwiLCB0YXJnZXRzKSkge1xuICAgICAgICBjc3Muc2V0KFwiOnJvb3RcIiwge1xuICAgICAgICAgICAgXCJ2aWV3LXRyYW5zaXRpb24tbmFtZVwiOiBcIm5vbmVcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdGltaW5nIGN1cnZlIHRvIGxpbmVhciBmb3IgYWxsIHZpZXcgdHJhbnNpdGlvbiBsYXllcnMuXG4gICAgICogVGhpcyBnZXRzIGJha2VkIGludG8gdGhlIGtleWZyYW1lcywgd2hpY2ggY2FuJ3QgYmUgY2hhbmdlZFxuICAgICAqIHdpdGhvdXQgYnJlYWtpbmcgdGhlIGdlbmVyYXRlZCBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGFsbG93cyB1cyB0byBzZXQgZWFzaW5nIHZpYSB1cGRhdGVUaW1pbmcgLSB3aGljaCBjYW4gYmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBjc3Muc2V0KFwiOjp2aWV3LXRyYW5zaXRpb24tZ3JvdXAoKiksIDo6dmlldy10cmFuc2l0aW9uLW9sZCgqKSwgOjp2aWV3LXRyYW5zaXRpb24tbmV3KCopXCIsIHsgXCJhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uXCI6IFwibGluZWFyICFpbXBvcnRhbnRcIiB9KTtcbiAgICBjc3MuY29tbWl0KCk7IC8vIFdyaXRlXG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24oYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB1cGRhdGUoKTtcbiAgICAgICAgLy8gVE9ETzogR28gb3ZlciBuZXcgdGFyZ2V0cyBhbmQgZW5zdXJlIHRoZXkgYWxsIGhhdmUgaWRzXG4gICAgfSk7XG4gICAgdHJhbnNpdGlvbi5maW5pc2hlZC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgY3NzLnJlbW92ZSgpOyAvLyBXcml0ZVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICB0cmFuc2l0aW9uLnJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkVmlld0FuaW1hdGlvbnMgPSBnZXRWaWV3QW5pbWF0aW9ucygpO1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYW5pbWF0aW9ucyBmb3Igb3VyIGRlZmluaXRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaCgoZGVmaW5pdGlvbiwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSWYgdGFyZ2V0IGlzIG5vdCBcInJvb3RcIiwgcmVzb2x2ZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgIC8vIGFuZCBpdGVyYXRlIG92ZXIgZWFjaFxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGRlZmluaXRpb25OYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZmluaXRpb25ba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtleWZyYW1lcywgb3B0aW9ucyB9ID0gZGVmaW5pdGlvbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBbdmFsdWVOYW1lLCB2YWx1ZUtleWZyYW1lc10gb2YgT2JqZWN0LmVudHJpZXMoa2V5ZnJhbWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZUtleWZyYW1lcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXRWYWx1ZVRyYW5zaXRpb24oZGVmYXVsdE9wdGlvbnMsIHZhbHVlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2V0VmFsdWVUcmFuc2l0aW9uKG9wdGlvbnMsIHZhbHVlTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGNob29zZUxheWVyVHlwZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGFuIG9wYWNpdHkgYW5pbWF0aW9uLCBhbmQga2V5ZnJhbWVzIGFyZSBub3QgYW4gYXJyYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIGNvbnZlcnQgdGhlbSBpbnRvIGFuIGFycmF5IGFuZCBzZXQgYW4gaW5pdGlhbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlTmFtZSA9PT0gXCJvcGFjaXR5XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZUtleWZyYW1lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSB0eXBlID09PSBcIm5ld1wiID8gMCA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXlmcmFtZXMgPSBbaW5pdGlhbFZhbHVlLCB2YWx1ZUtleWZyYW1lc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFJlc29sdmUgc3RhZ2dlciBmdW5jdGlvbiBpZiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZU9wdGlvbnMuZGVsYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlT3B0aW9ucy5kZWxheSA9IHZhbHVlT3B0aW9ucy5kZWxheSgwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5ldyBQc2V1ZG9BbmltYXRpb24oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBgOjp2aWV3LXRyYW5zaXRpb24tJHt0eXBlfSgke3RhcmdldH0pYCwgdmFsdWVOYW1lLCB2YWx1ZUtleWZyYW1lcywgdmFsdWVPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZSBicm93c2VyIGdlbmVyYXRlZCBhbmltYXRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAoY29uc3QgYW5pbWF0aW9uIG9mIGdlbmVyYXRlZFZpZXdBbmltYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbi5wbGF5U3RhdGUgPT09IFwiZmluaXNoZWRcIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlZmZlY3QgfSA9IGFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIWVmZmVjdCB8fCAhKGVmZmVjdCBpbnN0YW5jZW9mIEtleWZyYW1lRWZmZWN0KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwc2V1ZG9FbGVtZW50IH0gPSBlZmZlY3Q7XG4gICAgICAgICAgICAgICAgaWYgKCFwc2V1ZG9FbGVtZW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gZ2V0TGF5ZXJOYW1lKHBzZXVkb0VsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmICghbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGVmaW5pdGlvbiA9IHRhcmdldHMuZ2V0KG5hbWUubGF5ZXIpO1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0RGVmaW5pdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdHJhbnNpdGlvbiBuYW1lIGlzIGdyb3VwIHRoZW4gdXBkYXRlIHRoZSB0aW1pbmcgb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiB3aGVyZWFzIGlmIGl0J3Mgb2xkIG9yIG5ldyB0aGVuIHdlIGNvdWxkIHBvc3NpYmx5IHJlcGxhY2UgaXQgdXNpbmdcbiAgICAgICAgICAgICAgICAgICAgICogdGhlIGFib3ZlIG1ldGhvZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb25OYW1lID0gbmFtZS50eXBlID09PSBcImdyb3VwXCIgPyBcImxheW91dFwiIDogXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uVHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdldFZhbHVlVHJhbnNpdGlvbihkZWZhdWx0T3B0aW9ucywgdHJhbnNpdGlvbk5hbWUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhcHBseUdlbmVyYXRvck9wdGlvbnMoYW5pbWF0aW9uVHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVhc2luZyA9IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nKGFuaW1hdGlvblRyYW5zaXRpb24uZWFzZSwgYW5pbWF0aW9uVHJhbnNpdGlvbi5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdC51cGRhdGVUaW1pbmcoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsYXk6IHNlY29uZHNUb01pbGxpc2Vjb25kcygoX2EgPSBhbmltYXRpb25UcmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBhbmltYXRpb25UcmFuc2l0aW9uLmR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWFzaW5nLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKG5ldyBOYXRpdmVBbmltYXRpb25Db250cm9scyhhbmltYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzT3BhY2l0eSh0YXJnZXREZWZpbml0aW9uLCBcImVudGVyXCIpICYmXG4gICAgICAgICAgICAgICAgICAgIGhhc09wYWNpdHkodGFyZ2V0RGVmaW5pdGlvbiwgXCJleGl0XCIpICYmXG4gICAgICAgICAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgLmdldEtleWZyYW1lcygpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29tZSgoa2V5ZnJhbWUpID0+IGtleWZyYW1lLm1peEJsZW5kTW9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKG5ldyBOYXRpdmVBbmltYXRpb25Db250cm9scyhhbmltYXRpb24pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNvbHZlKG5ldyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzKGFuaW1hdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYXNPcGFjaXR5KHRhcmdldCwga2V5KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXRba2V5XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmtleWZyYW1lcy5vcGFjaXR5O1xufVxuXG5leHBvcnQgeyBzdGFydFZpZXdBbmltYXRpb24gfTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgc3RhcnRWaWV3QW5pbWF0aW9uIH0gZnJvbSAnLi9zdGFydC5tanMnO1xuXG4vKipcbiAqIFRPRE86XG4gKiAtIENyZWF0ZSB2aWV3IHRyYW5zaXRpb24gb24gbmV4dCB0aWNrXG4gKiAtIFJlcGxhY2UgYW5pbWF0aW9ucyB3aXRoIE1vdGlvbiBhbmltYXRpb25zXG4gKiAtIFJldHVybiBHcm91cEFuaW1hdGlvbiBvbiBuZXh0IHRpY2tcbiAqL1xuY2xhc3MgVmlld1RyYW5zaXRpb25CdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cGRhdGUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBcInJvb3RcIjtcbiAgICAgICAgdGhpcy50YXJnZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5vdGlmeVJlYWR5ID0gbm9vcDtcbiAgICAgICAgdGhpcy5yZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlSZWFkeSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICBzdGFydFZpZXdBbmltYXRpb24odXBkYXRlLCBvcHRpb25zLCB0aGlzLnRhcmdldHMpLnRoZW4oKGFuaW1hdGlvbikgPT4gdGhpcy5ub3RpZnlSZWFkeShhbmltYXRpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldChzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUYXJnZXQgPSBzZWxlY3RvcjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxheW91dChrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoXCJsYXlvdXRcIiwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG5ldyhrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoXCJuZXdcIiwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9sZChrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoXCJvbGRcIiwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGVudGVyKGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldChcImVudGVyXCIsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBleGl0KGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldChcImV4aXRcIiwga2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNyb3NzZmFkZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KFwiZW50ZXJcIiwgeyBvcGFjaXR5OiAxIH0sIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldChcImV4aXRcIiwgeyBvcGFjaXR5OiAwIH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdXBkYXRlVGFyZ2V0KHRhcmdldCwga2V5ZnJhbWVzLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50VGFyZ2V0LCB0YXJnZXRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXRhcmdldHMuaGFzKGN1cnJlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICB0YXJnZXRzLnNldChjdXJyZW50VGFyZ2V0LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IHRhcmdldHMuZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB0YXJnZXREYXRhW3RhcmdldF0gPSB7IGtleWZyYW1lcywgb3B0aW9ucyB9O1xuICAgIH1cbiAgICB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZpZXcodXBkYXRlLCBkZWZhdWx0T3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBWaWV3VHJhbnNpdGlvbkJ1aWxkZXIodXBkYXRlLCBkZWZhdWx0T3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IFZpZXdUcmFuc2l0aW9uQnVpbGRlciwgdmlldyB9O1xuIiwiaW1wb3J0IHsgaXNEcmFnZ2luZyB9IGZyb20gJy4vaXMtYWN0aXZlLm1qcyc7XG5cbmZ1bmN0aW9uIHNldERyYWdMb2NrKGF4aXMpIHtcbiAgICBpZiAoYXhpcyA9PT0gXCJ4XCIgfHwgYXhpcyA9PT0gXCJ5XCIpIHtcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmdbYXhpc10pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXNEcmFnZ2luZ1theGlzXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmdbYXhpc10gPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc0RyYWdnaW5nLnggfHwgaXNEcmFnZ2luZy55KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzRHJhZ2dpbmcueCA9IGlzRHJhZ2dpbmcueSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcueCA9IGlzRHJhZ2dpbmcueSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgc2V0RHJhZ0xvY2sgfTtcbiIsImV4cG9ydCB7IEdyb3VwUGxheWJhY2tDb250cm9scyB9IGZyb20gJy4vYW5pbWF0aW9uL2NvbnRyb2xzL0dyb3VwLm1qcyc7XG5leHBvcnQgeyBnZXRWYWx1ZVRyYW5zaXRpb24gfSBmcm9tICcuL2FuaW1hdGlvbi91dGlscy9nZXQtdmFsdWUtdHJhbnNpdGlvbi5tanMnO1xuZXhwb3J0IHsgY2FsY0dlbmVyYXRvckR1cmF0aW9uLCBtYXhHZW5lcmF0b3JEdXJhdGlvbiB9IGZyb20gJy4vYW5pbWF0aW9uL2dlbmVyYXRvcnMvdXRpbHMvY2FsYy1kdXJhdGlvbi5tanMnO1xuZXhwb3J0IHsgY3JlYXRlR2VuZXJhdG9yRWFzaW5nIH0gZnJvbSAnLi9hbmltYXRpb24vZ2VuZXJhdG9ycy91dGlscy9jcmVhdGUtZ2VuZXJhdG9yLWVhc2luZy5tanMnO1xuZXhwb3J0IHsgaXNHZW5lcmF0b3IgfSBmcm9tICcuL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3V0aWxzL2lzLWdlbmVyYXRvci5tanMnO1xuZXhwb3J0IHsgTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMgfSBmcm9tICcuL2FuaW1hdGlvbi93YWFwaS9OYXRpdmVBbmltYXRpb25Db250cm9scy5tanMnO1xuZXhwb3J0IHsgYXR0YWNoVGltZWxpbmUgfSBmcm9tICcuL2FuaW1hdGlvbi93YWFwaS91dGlscy9hdHRhY2gtdGltZWxpbmUubWpzJztcbmV4cG9ydCB7IGN1YmljQmV6aWVyQXNTdHJpbmcsIGlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcsIG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nLCBzdXBwb3J0ZWRXYWFwaUVhc2luZyB9IGZyb20gJy4vYW5pbWF0aW9uL3dhYXBpL3V0aWxzL2Vhc2luZy5tanMnO1xuZXhwb3J0IHsgZ2VuZXJhdGVMaW5lYXJFYXNpbmcgfSBmcm9tICcuL2FuaW1hdGlvbi93YWFwaS91dGlscy9saW5lYXIubWpzJztcbmV4cG9ydCB7IGhvdmVyIH0gZnJvbSAnLi9nZXN0dXJlcy9ob3Zlci5tanMnO1xuZXhwb3J0IHsgcHJlc3MgfSBmcm9tICcuL2dlc3R1cmVzL3ByZXNzL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBpc0JlemllckRlZmluaXRpb24gfSBmcm9tICcuL3V0aWxzL2lzLWJlemllci1kZWZpbml0aW9uLm1qcyc7XG5leHBvcnQgeyByZXNvbHZlRWxlbWVudHMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmUtZWxlbWVudHMubWpzJztcbmV4cG9ydCB7IHN1cHBvcnRzRmxhZ3MgfSBmcm9tICcuL3V0aWxzL3N1cHBvcnRzL2ZsYWdzLm1qcyc7XG5leHBvcnQgeyBzdXBwb3J0c0xpbmVhckVhc2luZyB9IGZyb20gJy4vdXRpbHMvc3VwcG9ydHMvbGluZWFyLWVhc2luZy5tanMnO1xuZXhwb3J0IHsgc3VwcG9ydHNTY3JvbGxUaW1lbGluZSB9IGZyb20gJy4vdXRpbHMvc3VwcG9ydHMvc2Nyb2xsLXRpbWVsaW5lLm1qcyc7XG5leHBvcnQgeyBWaWV3VHJhbnNpdGlvbkJ1aWxkZXIsIHZpZXcgfSBmcm9tICcuL3ZpZXcvaW5kZXgubWpzJztcbmV4cG9ydCB7IGlzRHJhZ0FjdGl2ZSwgaXNEcmFnZ2luZyB9IGZyb20gJy4vZ2VzdHVyZXMvZHJhZy9zdGF0ZS9pcy1hY3RpdmUubWpzJztcbmV4cG9ydCB7IHNldERyYWdMb2NrIH0gZnJvbSAnLi9nZXN0dXJlcy9kcmFnL3N0YXRlL3NldC1hY3RpdmUubWpzJztcbmV4cG9ydCB7IGlzTm9kZU9yQ2hpbGQgfSBmcm9tICcuL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzJztcbmV4cG9ydCB7IGlzUHJpbWFyeVBvaW50ZXIgfSBmcm9tICcuL2dlc3R1cmVzL3V0aWxzL2lzLXByaW1hcnktcG9pbnRlci5tanMnO1xuIiwiLyoqXG4gKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgZXZlcnkgcG9zc2libGUgdHJhbnNmb3JtIGtleS5cbiAqL1xuY29uc3QgdHJhbnNmb3JtUHJvcE9yZGVyID0gW1xuICAgIFwidHJhbnNmb3JtUGVyc3BlY3RpdmVcIixcbiAgICBcInhcIixcbiAgICBcInlcIixcbiAgICBcInpcIixcbiAgICBcInRyYW5zbGF0ZVhcIixcbiAgICBcInRyYW5zbGF0ZVlcIixcbiAgICBcInRyYW5zbGF0ZVpcIixcbiAgICBcInNjYWxlXCIsXG4gICAgXCJzY2FsZVhcIixcbiAgICBcInNjYWxlWVwiLFxuICAgIFwicm90YXRlXCIsXG4gICAgXCJyb3RhdGVYXCIsXG4gICAgXCJyb3RhdGVZXCIsXG4gICAgXCJyb3RhdGVaXCIsXG4gICAgXCJza2V3XCIsXG4gICAgXCJza2V3WFwiLFxuICAgIFwic2tld1lcIixcbl07XG4vKipcbiAqIEEgcXVpY2sgbG9va3VwIGZvciB0cmFuc2Zvcm0gcHJvcHMuXG4gKi9cbmNvbnN0IHRyYW5zZm9ybVByb3BzID0gbmV3IFNldCh0cmFuc2Zvcm1Qcm9wT3JkZXIpO1xuXG5leHBvcnQgeyB0cmFuc2Zvcm1Qcm9wT3JkZXIsIHRyYW5zZm9ybVByb3BzIH07XG4iLCJpbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wT3JkZXIgfSBmcm9tICcuL2tleXMtdHJhbnNmb3JtLm1qcyc7XG5cbmNvbnN0IHBvc2l0aW9uYWxLZXlzID0gbmV3IFNldChbXG4gICAgXCJ3aWR0aFwiLFxuICAgIFwiaGVpZ2h0XCIsXG4gICAgXCJ0b3BcIixcbiAgICBcImxlZnRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b21cIixcbiAgICAuLi50cmFuc2Zvcm1Qcm9wT3JkZXIsXG5dKTtcblxuZXhwb3J0IHsgcG9zaXRpb25hbEtleXMgfTtcbiIsImltcG9ydCB7IGlzS2V5ZnJhbWVzVGFyZ2V0IH0gZnJvbSAnLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWtleWZyYW1lcy10YXJnZXQubWpzJztcblxuY29uc3QgaXNDdXN0b21WYWx1ZSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4odiAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Lm1peCAmJiB2LnRvVmFsdWUpO1xufTtcbmNvbnN0IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSAodikgPT4ge1xuICAgIC8vIFRPRE8gbWF5YmUgdGhyb3cgaWYgdi5sZW5ndGggLSAxIGlzIHBsYWNlaG9sZGVyIHRva2VuP1xuICAgIHJldHVybiBpc0tleWZyYW1lc1RhcmdldCh2KSA/IHZbdi5sZW5ndGggLSAxXSB8fCAwIDogdjtcbn07XG5cbmV4cG9ydCB7IGlzQ3VzdG9tVmFsdWUsIHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgfTtcbiIsImNvbnN0IE1vdGlvbkdsb2JhbENvbmZpZyA9IHtcbiAgICBza2lwQW5pbWF0aW9uczogZmFsc2UsXG4gICAgdXNlTWFudWFsVGltaW5nOiBmYWxzZSxcbn07XG5cbmV4cG9ydCB7IE1vdGlvbkdsb2JhbENvbmZpZyB9O1xuIiwiZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RlcChydW5OZXh0RnJhbWUpIHtcbiAgICAvKipcbiAgICAgKiBXZSBjcmVhdGUgYW5kIHJldXNlIHR3byBxdWV1ZXMsIG9uZSB0byBxdWV1ZSBqb2JzIGZvciB0aGUgY3VycmVudCBmcmFtZVxuICAgICAqIGFuZCBvbmUgZm9yIHRoZSBuZXh0LiBXZSByZXVzZSB0byBhdm9pZCB0cmlnZ2VyaW5nIEdDIGFmdGVyIHggZnJhbWVzLlxuICAgICAqL1xuICAgIGxldCB0aGlzRnJhbWUgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG5leHRGcmFtZSA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKiBUcmFjayB3aGV0aGVyIHdlJ3JlIGN1cnJlbnRseSBwcm9jZXNzaW5nIGpvYnMgaW4gdGhpcyBzdGVwLiBUaGlzIHdheVxuICAgICAqIHdlIGNhbiBkZWNpZGUgd2hldGhlciB0byBzY2hlZHVsZSBuZXcgam9icyBmb3IgdGhpcyBmcmFtZSBvciBuZXh0LlxuICAgICAqL1xuICAgIGxldCBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICBsZXQgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBBIHNldCBvZiBwcm9jZXNzZXMgd2hpY2ggd2VyZSBtYXJrZWQga2VlcEFsaXZlIHdoZW4gc2NoZWR1bGVkLlxuICAgICAqL1xuICAgIGNvbnN0IHRvS2VlcEFsaXZlID0gbmV3IFdlYWtTZXQoKTtcbiAgICBsZXQgbGF0ZXN0RnJhbWVEYXRhID0ge1xuICAgICAgICBkZWx0YTogMC4wLFxuICAgICAgICB0aW1lc3RhbXA6IDAuMCxcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHRyaWdnZXJDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBpZiAodG9LZWVwQWxpdmUuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgc3RlcC5zY2hlZHVsZShjYWxsYmFjayk7XG4gICAgICAgICAgICBydW5OZXh0RnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhsYXRlc3RGcmFtZURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBzdGVwID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGUgYSBwcm9jZXNzIHRvIHJ1biBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIHNjaGVkdWxlOiAoY2FsbGJhY2ssIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkVG9DdXJyZW50RnJhbWUgPSBpbW1lZGlhdGUgJiYgaXNQcm9jZXNzaW5nO1xuICAgICAgICAgICAgY29uc3QgcXVldWUgPSBhZGRUb0N1cnJlbnRGcmFtZSA/IHRoaXNGcmFtZSA6IG5leHRGcmFtZTtcbiAgICAgICAgICAgIGlmIChrZWVwQWxpdmUpXG4gICAgICAgICAgICAgICAgdG9LZWVwQWxpdmUuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmICghcXVldWUuaGFzKGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICBxdWV1ZS5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuY2VsIHRoZSBwcm92aWRlZCBjYWxsYmFjayBmcm9tIHJ1bm5pbmcgb24gdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWw6IChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbmV4dEZyYW1lLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgICAgICB0b0tlZXBBbGl2ZS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRXhlY3V0ZSBhbGwgc2NoZWR1bGUgY2FsbGJhY2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgcHJvY2VzczogKGZyYW1lRGF0YSkgPT4ge1xuICAgICAgICAgICAgbGF0ZXN0RnJhbWVEYXRhID0gZnJhbWVEYXRhO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBhbHJlYWR5IHByb2Nlc3Npbmcgd2UndmUgcHJvYmFibHkgYmVlbiB0cmlnZ2VyZWQgYnkgYSBmbHVzaFN5bmNcbiAgICAgICAgICAgICAqIGluc2lkZSBhbiBleGlzdGluZyBwcm9jZXNzLiBJbnN0ZWFkIG9mIGV4ZWN1dGluZywgbWFyayBmbHVzaE5leHRGcmFtZVxuICAgICAgICAgICAgICogYXMgdHJ1ZSBhbmQgZW5zdXJlIHdlIGZsdXNoIHRoZSBmb2xsb3dpbmcgZnJhbWUgYXQgdGhlIGVuZCBvZiB0aGlzIG9uZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgIGZsdXNoTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgW3RoaXNGcmFtZSwgbmV4dEZyYW1lXSA9IFtuZXh0RnJhbWUsIHRoaXNGcmFtZV07XG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoaXMgZnJhbWVcbiAgICAgICAgICAgIHRoaXNGcmFtZS5mb3JFYWNoKHRyaWdnZXJDYWxsYmFjayk7XG4gICAgICAgICAgICAvLyBDbGVhciB0aGUgZnJhbWUgc28gbm8gY2FsbGJhY2tzIHJlbWFpbi4gVGhpcyBpcyB0byBhdm9pZFxuICAgICAgICAgICAgLy8gbWVtb3J5IGxlYWtzIHNob3VsZCB0aGlzIHJlbmRlciBzdGVwIG5vdCBydW4gZm9yIGEgd2hpbGUuXG4gICAgICAgICAgICB0aGlzRnJhbWUuY2xlYXIoKTtcbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGZsdXNoTmV4dEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdGVwLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBzdGVwO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZW5kZXJTdGVwIH07XG4iLCJpbXBvcnQgeyBNb3Rpb25HbG9iYWxDb25maWcgfSBmcm9tICcuLi91dGlscy9HbG9iYWxDb25maWcubWpzJztcbmltcG9ydCB7IGNyZWF0ZVJlbmRlclN0ZXAgfSBmcm9tICcuL3JlbmRlci1zdGVwLm1qcyc7XG5cbmNvbnN0IHN0ZXBzT3JkZXIgPSBbXG4gICAgXCJyZWFkXCIsIC8vIFJlYWRcbiAgICBcInJlc29sdmVLZXlmcmFtZXNcIiwgLy8gV3JpdGUvUmVhZC9Xcml0ZS9SZWFkXG4gICAgXCJ1cGRhdGVcIiwgLy8gQ29tcHV0ZVxuICAgIFwicHJlUmVuZGVyXCIsIC8vIENvbXB1dGVcbiAgICBcInJlbmRlclwiLCAvLyBXcml0ZVxuICAgIFwicG9zdFJlbmRlclwiLCAvLyBDb21wdXRlXG5dO1xuY29uc3QgbWF4RWxhcHNlZCA9IDQwO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyQmF0Y2hlcihzY2hlZHVsZU5leHRCYXRjaCwgYWxsb3dLZWVwQWxpdmUpIHtcbiAgICBsZXQgcnVuTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgbGV0IHVzZURlZmF1bHRFbGFwc2VkID0gdHJ1ZTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgZGVsdGE6IDAuMCxcbiAgICAgICAgdGltZXN0YW1wOiAwLjAsXG4gICAgICAgIGlzUHJvY2Vzc2luZzogZmFsc2UsXG4gICAgfTtcbiAgICBjb25zdCBmbGFnUnVuTmV4dEZyYW1lID0gKCkgPT4gKHJ1bk5leHRGcmFtZSA9IHRydWUpO1xuICAgIGNvbnN0IHN0ZXBzID0gc3RlcHNPcmRlci5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICAgIGFjY1trZXldID0gY3JlYXRlUmVuZGVyU3RlcChmbGFnUnVuTmV4dEZyYW1lKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgY29uc3QgeyByZWFkLCByZXNvbHZlS2V5ZnJhbWVzLCB1cGRhdGUsIHByZVJlbmRlciwgcmVuZGVyLCBwb3N0UmVuZGVyIH0gPSBzdGVwcztcbiAgICBjb25zdCBwcm9jZXNzQmF0Y2ggPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IE1vdGlvbkdsb2JhbENvbmZpZy51c2VNYW51YWxUaW1pbmdcbiAgICAgICAgICAgID8gc3RhdGUudGltZXN0YW1wXG4gICAgICAgICAgICA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUuZGVsdGEgPSB1c2VEZWZhdWx0RWxhcHNlZFxuICAgICAgICAgICAgPyAxMDAwIC8gNjBcbiAgICAgICAgICAgIDogTWF0aC5tYXgoTWF0aC5taW4odGltZXN0YW1wIC0gc3RhdGUudGltZXN0YW1wLCBtYXhFbGFwc2VkKSwgMSk7XG4gICAgICAgIHN0YXRlLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgc3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gVW5yb2xsZWQgcmVuZGVyIGxvb3AgZm9yIGJldHRlciBwZXItZnJhbWUgcGVyZm9ybWFuY2VcbiAgICAgICAgcmVhZC5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgcmVzb2x2ZUtleWZyYW1lcy5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgdXBkYXRlLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICBwcmVSZW5kZXIucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHJlbmRlci5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgcG9zdFJlbmRlci5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgc3RhdGUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChydW5OZXh0RnJhbWUgJiYgYWxsb3dLZWVwQWxpdmUpIHtcbiAgICAgICAgICAgIHVzZURlZmF1bHRFbGFwc2VkID0gZmFsc2U7XG4gICAgICAgICAgICBzY2hlZHVsZU5leHRCYXRjaChwcm9jZXNzQmF0Y2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCB3YWtlID0gKCkgPT4ge1xuICAgICAgICBydW5OZXh0RnJhbWUgPSB0cnVlO1xuICAgICAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XG4gICAgICAgIGlmICghc3RhdGUuaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICBzY2hlZHVsZU5leHRCYXRjaChwcm9jZXNzQmF0Y2gpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzY2hlZHVsZSA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBzdGVwID0gc3RlcHNba2V5XTtcbiAgICAgICAgYWNjW2tleV0gPSAocHJvY2Vzcywga2VlcEFsaXZlID0gZmFsc2UsIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJ1bk5leHRGcmFtZSlcbiAgICAgICAgICAgICAgICB3YWtlKCk7XG4gICAgICAgICAgICByZXR1cm4gc3RlcC5zY2hlZHVsZShwcm9jZXNzLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IGNhbmNlbCA9IChwcm9jZXNzKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHNPcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RlcHNbc3RlcHNPcmRlcltpXV0uY2FuY2VsKHByb2Nlc3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4geyBzY2hlZHVsZSwgY2FuY2VsLCBzdGF0ZSwgc3RlcHMgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVuZGVyQmF0Y2hlciwgc3RlcHNPcmRlciB9O1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVSZW5kZXJCYXRjaGVyIH0gZnJvbSAnLi9iYXRjaGVyLm1qcyc7XG5cbmNvbnN0IHsgc2NoZWR1bGU6IGZyYW1lLCBjYW5jZWw6IGNhbmNlbEZyYW1lLCBzdGF0ZTogZnJhbWVEYXRhLCBzdGVwczogZnJhbWVTdGVwcywgfSA9IGNyZWF0ZVJlbmRlckJhdGNoZXIodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IG5vb3AsIHRydWUpO1xuXG5leHBvcnQgeyBjYW5jZWxGcmFtZSwgZnJhbWUsIGZyYW1lRGF0YSwgZnJhbWVTdGVwcyB9O1xuIiwiaW1wb3J0IHsgTW90aW9uR2xvYmFsQ29uZmlnIH0gZnJvbSAnLi4vdXRpbHMvR2xvYmFsQ29uZmlnLm1qcyc7XG5pbXBvcnQgeyBmcmFtZURhdGEgfSBmcm9tICcuL2ZyYW1lLm1qcyc7XG5cbmxldCBub3c7XG5mdW5jdGlvbiBjbGVhclRpbWUoKSB7XG4gICAgbm93ID0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBBbiBldmVudGxvb3Atc3luY2hyb25vdXMgYWx0ZXJuYXRpdmUgdG8gcGVyZm9ybWFuY2Uubm93KCkuXG4gKlxuICogRW5zdXJlcyB0aGF0IHRpbWUgbWVhc3VyZW1lbnRzIHJlbWFpbiBjb25zaXN0ZW50IHdpdGhpbiBhIHN5bmNocm9ub3VzIGNvbnRleHQuXG4gKiBVc3VhbGx5IGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgdHdpY2Ugd2l0aGluIHRoZSBzYW1lIHN5bmNocm9ub3VzIGNvbnRleHRcbiAqIHdpbGwgcmV0dXJuIGRpZmZlcmVudCB2YWx1ZXMgd2hpY2ggaXNuJ3QgdXNlZnVsIGZvciBhbmltYXRpb25zIHdoZW4gd2UncmUgdXN1YWxseVxuICogdHJ5aW5nIHRvIHN5bmMgYW5pbWF0aW9ucyB0byB0aGUgc2FtZSBmcmFtZS5cbiAqL1xuY29uc3QgdGltZSA9IHtcbiAgICBub3c6ICgpID0+IHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lLnNldChmcmFtZURhdGEuaXNQcm9jZXNzaW5nIHx8IE1vdGlvbkdsb2JhbENvbmZpZy51c2VNYW51YWxUaW1pbmdcbiAgICAgICAgICAgICAgICA/IGZyYW1lRGF0YS50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICA6IHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm93O1xuICAgIH0sXG4gICAgc2V0OiAobmV3VGltZSkgPT4ge1xuICAgICAgICBub3cgPSBuZXdUaW1lO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjbGVhclRpbWUpO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyB0aW1lIH07XG4iLCJmdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIuaW5kZXhPZihpdGVtKSA9PT0gLTEpXG4gICAgICAgIGFyci5wdXNoKGl0ZW0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlSXRlbShhcnIsIGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBhcnJheS1tb3ZlXG5mdW5jdGlvbiBtb3ZlSXRlbShbLi4uYXJyXSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGZyb21JbmRleCA8IDAgPyBhcnIubGVuZ3RoICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuICAgIGlmIChzdGFydEluZGV4ID49IDAgJiYgc3RhcnRJbmRleCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0b0luZGV4IDwgMCA/IGFyci5sZW5ndGggKyB0b0luZGV4IDogdG9JbmRleDtcbiAgICAgICAgY29uc3QgW2l0ZW1dID0gYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICBhcnIuc3BsaWNlKGVuZEluZGV4LCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IHsgYWRkVW5pcXVlSXRlbSwgbW92ZUl0ZW0sIHJlbW92ZUl0ZW0gfTtcbiIsImltcG9ydCB7IGFkZFVuaXF1ZUl0ZW0sIHJlbW92ZUl0ZW0gfSBmcm9tICcuL2FycmF5Lm1qcyc7XG5cbmNsYXNzIFN1YnNjcmlwdGlvbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgYWRkKGhhbmRsZXIpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpO1xuICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3ZlSXRlbSh0aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpO1xuICAgIH1cbiAgICBub3RpZnkoYSwgYiwgYykge1xuICAgICAgICBjb25zdCBudW1TdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICAgICAgaWYgKCFudW1TdWJzY3JpcHRpb25zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobnVtU3Vic2NyaXB0aW9ucyA9PT0gMSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIG9ubHkgYSBzaW5nbGUgaGFuZGxlciB3ZSBjYW4ganVzdCBjYWxsIGl0IHdpdGhvdXQgaW52b2tpbmcgYSBsb29wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNbMF0oYSwgYiwgYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVN1YnNjcmlwdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIGhhbmRsZXIgZXhpc3RzIGJlZm9yZSBmaXJpbmcgYXMgaXQncyBwb3NzaWJsZVxuICAgICAgICAgICAgICAgICAqIHRoZSBzdWJzY3JpcHRpb25zIHdlcmUgbW9kaWZpZWQgZHVyaW5nIHRoaXMgbG9vcCBydW5uaW5nLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnN1YnNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCA9IDA7XG4gICAgfVxufVxuXG5leHBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH07XG4iLCIvKlxuICBDb252ZXJ0IHZlbG9jaXR5IGludG8gdmVsb2NpdHkgcGVyIHNlY29uZFxuXG4gIEBwYXJhbSBbbnVtYmVyXTogVW5pdCBwZXIgZnJhbWVcbiAgQHBhcmFtIFtudW1iZXJdOiBGcmFtZSBkdXJhdGlvbiBpbiBtc1xuKi9cbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kKHZlbG9jaXR5LCBmcmFtZUR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxMDAwIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufVxuXG5leHBvcnQgeyB2ZWxvY2l0eVBlclNlY29uZCB9O1xuIiwiaW1wb3J0IHsgdGltZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9zeW5jLXRpbWUubWpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbk1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9zdWJzY3JpcHRpb24tbWFuYWdlci5tanMnO1xuaW1wb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQgfSBmcm9tICcuLi91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qcyc7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uL3V0aWxzL3dhcm4tb25jZS5tanMnO1xuaW1wb3J0IHsgZnJhbWUgfSBmcm9tICcuLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuLyoqXG4gKiBNYXhpbXVtIHRpbWUgYmV0d2VlbiB0aGUgdmFsdWUgb2YgdHdvIGZyYW1lcywgYmV5b25kIHdoaWNoIHdlXG4gKiBhc3N1bWUgdGhlIHZlbG9jaXR5IGhhcyBzaW5jZSBiZWVuIDAuXG4gKi9cbmNvbnN0IE1BWF9WRUxPQ0lUWV9ERUxUQSA9IDMwO1xuY29uc3QgaXNGbG9hdCA9ICh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbmNvbnN0IGNvbGxlY3RNb3Rpb25WYWx1ZXMgPSB7XG4gICAgY3VycmVudDogdW5kZWZpbmVkLFxufTtcbi8qKlxuICogYE1vdGlvblZhbHVlYCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgbW90aW9uIHZhbHVlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE1vdGlvblZhbHVlIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5pdCAtIFRoZSBpbml0aWF0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogLSAgYHRyYW5zZm9ybWVyYDogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gaW5jb21pbmcgdmFsdWVzIHdpdGguXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihpbml0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSByZXBsYWNlZCBieSB0aGUgYnVpbGQgc3RlcCB3aXRoIHRoZSBsYXRlc3QgdmVyc2lvbiBudW1iZXIuXG4gICAgICAgICAqIFdoZW4gTW90aW9uVmFsdWVzIGFyZSBwcm92aWRlZCB0byBtb3Rpb24gY29tcG9uZW50cywgd2FybiBpZiB2ZXJzaW9ucyBhcmUgbWl4ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBcIjEyLjAuNlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIHdoZXRoZXIgdGhpcyB2YWx1ZSBjYW4gb3V0cHV0IGEgdmVsb2NpdHkuIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdHJ1ZVxuICAgICAgICAgKiBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpY2FsLCBidXQgd2UgbWlnaHQgYmUgYWJsZSB0byB3aWRlbiB0aGUgc2NvcGUgaGVyZSBhbmQgc3VwcG9ydFxuICAgICAgICAgKiBvdGhlciB2YWx1ZSB0eXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBTdWJzY3JpcHRpb25NYW5hZ2VyIGZvciBlYWNoIGFjdGl2ZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5ID0gKHYsIHJlbmRlciA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZS5ub3coKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgdXBkYXRpbmcgdGhlIHZhbHVlIGR1cmluZyBhbm90aGVyIGZyYW1lIG9yIGV2ZW50bG9vcFxuICAgICAgICAgICAgICogdGhhbiB0aGUgcHJldmlvdXMgZnJhbWUsIHRoZW4gdGhlIHdlIHNldCB0aGUgcHJldmlvdXMgZnJhbWUgdmFsdWVcbiAgICAgICAgICAgICAqIHRvIGN1cnJlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZWRBdCAhPT0gY3VycmVudFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFByZXZGcmFtZVZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnQodik7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdXBkYXRlIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50ICE9PSB0aGlzLnByZXYgJiYgdGhpcy5ldmVudHMuY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuY2hhbmdlLm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIHJlbmRlciBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKHJlbmRlciAmJiB0aGlzLmV2ZW50cy5yZW5kZXJSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMucmVuZGVyUmVxdWVzdC5ub3RpZnkodGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYXNBbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldEN1cnJlbnQoaW5pdCk7XG4gICAgICAgIHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuICAgIH1cbiAgICBzZXRDdXJyZW50KGN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgdGhpcy51cGRhdGVkQXQgPSB0aW1lLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5jYW5UcmFja1ZlbG9jaXR5ID09PSBudWxsICYmIGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gaXNGbG9hdCh0aGlzLmN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFByZXZGcmFtZVZhbHVlKHByZXZGcmFtZVZhbHVlID0gdGhpcy5jdXJyZW50KSB7XG4gICAgICAgIHRoaXMucHJldkZyYW1lVmFsdWUgPSBwcmV2RnJhbWVWYWx1ZTtcbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlZEF0ID0gdGhpcy51cGRhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgbm90aWZpZWQgd2hlbiB0aGUgYE1vdGlvblZhbHVlYCBpcyB1cGRhdGVkLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogV2hlbiBjYWxsaW5nIGBvbkNoYW5nZWAgaW5zaWRlIGEgUmVhY3QgY29tcG9uZW50LCBpdCBzaG91bGQgYmUgd3JhcHBlZCB3aXRoIHRoZVxuICAgICAqIGB1c2VFZmZlY3RgIGhvb2suIEFzIGl0IHJldHVybnMgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJldHVybmVkXG4gICAgICogZnJvbSB0aGUgYHVzZUVmZmVjdGAgZnVuY3Rpb24gdG8gZW5zdXJlIHlvdSBkb24ndCBhZGQgZHVwbGljYXRlIHN1YnNjcmliZXJzLi5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgKiAgIGNvbnN0IHggPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqICAgY29uc3QgeSA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogICBjb25zdCBvcGFjaXR5ID0gdXNlTW90aW9uVmFsdWUoMSlcbiAgICAgKlxuICAgICAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBkYXRlT3BhY2l0eSgpIHtcbiAgICAgKiAgICAgICBjb25zdCBtYXhYWSA9IE1hdGgubWF4KHguZ2V0KCksIHkuZ2V0KCkpXG4gICAgICogICAgICAgY29uc3QgbmV3T3BhY2l0eSA9IHRyYW5zZm9ybShtYXhYWSwgWzAsIDEwMF0sIFsxLCAwXSlcbiAgICAgKiAgICAgICBvcGFjaXR5LnNldChuZXdPcGFjaXR5KVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVYID0geC5vbihcImNoYW5nZVwiLCB1cGRhdGVPcGFjaXR5KVxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVkgPSB5Lm9uKFwiY2hhbmdlXCIsIHVwZGF0ZU9wYWNpdHkpXG4gICAgICpcbiAgICAgKiAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgKiAgICAgICB1bnN1YnNjcmliZVgoKVxuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWSgpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0sIFtdKVxuICAgICAqXG4gICAgICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgeCB9fSAvPlxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyIC0gQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIHRoZSBsYXRlc3QgdmFsdWUuXG4gICAgICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhpcyBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIG9uQ2hhbmdlKHN1YnNjcmlwdGlvbikge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB3YXJuT25jZShmYWxzZSwgYHZhbHVlLm9uQ2hhbmdlKGNhbGxiYWNrKSBpcyBkZXByZWNhdGVkLiBTd2l0Y2ggdG8gdmFsdWUub24oXCJjaGFuZ2VcIiwgY2FsbGJhY2spLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9uKFwiY2hhbmdlXCIsIHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJjaGFuZ2VcIikge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gbW9yZSBjaGFuZ2UgbGlzdGVuZXJzIGJ5IHRoZSBzdGFydFxuICAgICAgICAgICAgICAgICAqIG9mIHRoZSBuZXh0IGZyYW1lLCBzdG9wIGFjdGl2ZSBhbmltYXRpb25zLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRzLmNoYW5nZS5nZXRTaXplKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgICB9XG4gICAgY2xlYXJMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnRNYW5hZ2VycyBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnRNYW5hZ2Vyc10uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBhIHBhc3NpdmUgZWZmZWN0IHRvIHRoZSBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgYXR0YWNoKHBhc3NpdmVFZmZlY3QsIHN0b3BQYXNzaXZlRWZmZWN0KSB7XG4gICAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCA9IHBhc3NpdmVFZmZlY3Q7XG4gICAgICAgIHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QgPSBzdG9wUGFzc2l2ZUVmZmVjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogeC5zZXQoMTApXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0ZXN0IC0gTGF0ZXN0IHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gcmVuZGVyIC0gV2hldGhlciB0byBub3RpZnkgcmVuZGVyIHN1YnNjcmliZXJzLiBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXQodiwgcmVuZGVyID0gdHJ1ZSkge1xuICAgICAgICBpZiAoIXJlbmRlciB8fCAhdGhpcy5wYXNzaXZlRWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2LCByZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0KHYsIHRoaXMudXBkYXRlQW5kTm90aWZ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRXaXRoVmVsb2NpdHkocHJldiwgY3VycmVudCwgZGVsdGEpIHtcbiAgICAgICAgdGhpcy5zZXQoY3VycmVudCk7XG4gICAgICAgIHRoaXMucHJldiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5wcmV2RnJhbWVWYWx1ZSA9IHByZXY7XG4gICAgICAgIHRoaXMucHJldlVwZGF0ZWRBdCA9IHRoaXMudXBkYXRlZEF0IC0gZGVsdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc3RhdGUgb2YgdGhlIGBNb3Rpb25WYWx1ZWAsIHN0b3BwaW5nIGFueSBhY3RpdmUgYW5pbWF0aW9ucyxcbiAgICAgKiBlZmZlY3RzLCBhbmQgcmVzZXRzIHZlbG9jaXR5IHRvIGAwYC5cbiAgICAgKi9cbiAgICBqdW1wKHYsIGVuZEFuaW1hdGlvbiA9IHRydWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkodik7XG4gICAgICAgIHRoaXMucHJldiA9IHY7XG4gICAgICAgIHRoaXMucHJldlVwZGF0ZWRBdCA9IHRoaXMucHJldkZyYW1lVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGVuZEFuaW1hdGlvbiAmJiB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QpXG4gICAgICAgICAgICB0aGlzLnN0b3BQYXNzaXZlRWZmZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXRlc3Qgc3RhdGUgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgaWYgKGNvbGxlY3RNb3Rpb25WYWx1ZXMuY3VycmVudCkge1xuICAgICAgICAgICAgY29sbGVjdE1vdGlvblZhbHVlcy5jdXJyZW50LnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldFByZXZpb3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmV2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWAuIFJldHVybnMgYDBgIGlmIHRoZSBzdGF0ZSBpcyBub24tbnVtZXJpY2FsLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldFZlbG9jaXR5KCkge1xuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWUubm93KCk7XG4gICAgICAgIGlmICghdGhpcy5jYW5UcmFja1ZlbG9jaXR5IHx8XG4gICAgICAgICAgICB0aGlzLnByZXZGcmFtZVZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lIC0gdGhpcy51cGRhdGVkQXQgPiBNQVhfVkVMT0NJVFlfREVMVEEpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5taW4odGhpcy51cGRhdGVkQXQgLSB0aGlzLnByZXZVcGRhdGVkQXQsIE1BWF9WRUxPQ0lUWV9ERUxUQSk7XG4gICAgICAgIC8vIENhc3RzIGJlY2F1c2Ugb2YgcGFyc2VGbG9hdCdzIHBvb3IgdHlwaW5nXG4gICAgICAgIHJldHVybiB2ZWxvY2l0eVBlclNlY29uZChwYXJzZUZsb2F0KHRoaXMuY3VycmVudCkgLVxuICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLnByZXZGcmFtZVZhbHVlKSwgZGVsdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBuZXcgYW5pbWF0aW9uIHRvIGNvbnRyb2wgdGhpcyBgTW90aW9uVmFsdWVgLiBPbmx5IG9uZVxuICAgICAqIGFuaW1hdGlvbiBjYW4gZHJpdmUgYSBgTW90aW9uVmFsdWVgIGF0IG9uZSB0aW1lLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogdmFsdWUuc3RhcnQoKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGFuaW1hdGlvbiAtIEEgZnVuY3Rpb24gdGhhdCBzdGFydHMgdGhlIHByb3ZpZGVkIGFuaW1hdGlvblxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhcnQoc3RhcnRBbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHN0YXJ0QW5pbWF0aW9uKHJlc29sdmUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmFuaW1hdGlvblN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuYW5pbWF0aW9uU3RhcnQubm90aWZ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuYW5pbWF0aW9uQ29tcGxldGUubm90aWZ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyQW5pbWF0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBjdXJyZW50bHkgYWN0aXZlIGFuaW1hdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5hbmltYXRpb25DYW5jZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25DYW5jZWwubm90aWZ5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhckFuaW1hdGlvbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGlzIHZhbHVlIGlzIGN1cnJlbnRseSBhbmltYXRpbmcuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaXNBbmltYXRpbmcoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICBjbGVhckFuaW1hdGlvbigpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYW5pbWF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFuZCBjbGVhbiB1cCBzdWJzY3JpYmVycyB0byB0aGlzIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBUaGUgYE1vdGlvblZhbHVlYCBob29rcyBsaWtlIGB1c2VNb3Rpb25WYWx1ZWAgYW5kIGB1c2VUcmFuc2Zvcm1gIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBoYW5kbGUgdGhlIGxpZmVjeWNsZSBvZiB0aGUgcmV0dXJuZWQgYE1vdGlvblZhbHVlYCwgc28gdGhpcyBtZXRob2QgaXMgb25seSBuZWNlc3NhcnkgaWYgeW91J3ZlIG1hbnVhbGx5XG4gICAgICogY3JlYXRlZCBhIGBNb3Rpb25WYWx1ZWAgdmlhIHRoZSBgbW90aW9uVmFsdWVgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY2xlYXJMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnN0b3BQYXNzaXZlRWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BQYXNzaXZlRWZmZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBtb3Rpb25WYWx1ZShpbml0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0LCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgTW90aW9uVmFsdWUsIGNvbGxlY3RNb3Rpb25WYWx1ZXMsIG1vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvcmVzb2x2ZS12YWx1ZS5tanMnO1xuaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS9pbmRleC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVZhcmlhbnQgfSBmcm9tICcuL3Jlc29sdmUtZHluYW1pYy12YXJpYW50cy5tanMnO1xuXG4vKipcbiAqIFNldCBWaXN1YWxFbGVtZW50J3MgTW90aW9uVmFsdWUsIGNyZWF0aW5nIGEgbmV3IE1vdGlvblZhbHVlIGZvciBpdCBpZlxuICogaXQgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgbGV0IHsgdHJhbnNpdGlvbkVuZCA9IHt9LCB0cmFuc2l0aW9uID0ge30sIC4uLnRhcmdldCB9ID0gcmVzb2x2ZWQgfHwge307XG4gICAgdGFyZ2V0ID0geyAuLi50YXJnZXQsIC4uLnRyYW5zaXRpb25FbmQgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzKHRhcmdldFtrZXldKTtcbiAgICAgICAgc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBzZXRUYXJnZXQgfTtcbiIsImNvbnN0IGlzTW90aW9uVmFsdWUgPSAodmFsdWUpID0+IEJvb2xlYW4odmFsdWUgJiYgdmFsdWUuZ2V0VmVsb2NpdHkpO1xuXG5leHBvcnQgeyBpc01vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgJiYgdmFsdWUuYWRkKTtcbn1cblxuZXhwb3J0IHsgaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUgfTtcbiIsImltcG9ydCB7IGlzV2lsbENoYW5nZU1vdGlvblZhbHVlIH0gZnJvbSAnLi9pcy5tanMnO1xuXG5mdW5jdGlvbiBhZGRWYWx1ZVRvV2lsbENoYW5nZSh2aXN1YWxFbGVtZW50LCBrZXkpIHtcbiAgICBjb25zdCB3aWxsQ2hhbmdlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShcIndpbGxDaGFuZ2VcIik7XG4gICAgLyoqXG4gICAgICogSXQgY291bGQgYmUgdGhhdCBhIHVzZXIgaGFzIHNldCB3aWxsQ2hhbmdlIHRvIGEgcmVndWxhciBNb3Rpb25WYWx1ZSxcbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIGNhbid0IGFkZCB0aGUgdmFsdWUgdG8gaXQuXG4gICAgICovXG4gICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgYWRkVmFsdWVUb1dpbGxDaGFuZ2UgfTtcbiIsIi8qKlxuICogQ29udmVydCBjYW1lbENhc2UgdG8gZGFzaC1jYXNlIHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IGNhbWVsVG9EYXNoID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2d1LCBcIiQxLSQyXCIpLnRvTG93ZXJDYXNlKCk7XG5cbmV4cG9ydCB7IGNhbWVsVG9EYXNoIH07XG4iLCJpbXBvcnQgeyBjYW1lbFRvRGFzaCB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdXRpbHMvY2FtZWwtdG8tZGFzaC5tanMnO1xuXG5jb25zdCBvcHRpbWl6ZWRBcHBlYXJEYXRhSWQgPSBcImZyYW1lckFwcGVhcklkXCI7XG5jb25zdCBvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlID0gXCJkYXRhLVwiICsgY2FtZWxUb0Rhc2gob3B0aW1pemVkQXBwZWFyRGF0YUlkKTtcblxuZXhwb3J0IHsgb3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZSwgb3B0aW1pemVkQXBwZWFyRGF0YUlkIH07XG4iLCJpbXBvcnQgeyBvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlIH0gZnJvbSAnLi9kYXRhLWlkLm1qcyc7XG5cbmZ1bmN0aW9uIGdldE9wdGltaXNlZEFwcGVhcklkKHZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gdmlzdWFsRWxlbWVudC5wcm9wc1tvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlXTtcbn1cblxuZXhwb3J0IHsgZ2V0T3B0aW1pc2VkQXBwZWFySWQgfTtcbiIsImNvbnN0IGluc3RhbnRBbmltYXRpb25TdGF0ZSA9IHtcbiAgICBjdXJyZW50OiBmYWxzZSxcbn07XG5cbmV4cG9ydCB7IGluc3RhbnRBbmltYXRpb25TdGF0ZSB9O1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5cbi8qXG4gIEJlemllciBmdW5jdGlvbiBnZW5lcmF0b3JcbiAgVGhpcyBoYXMgYmVlbiBtb2RpZmllZCBmcm9tIEdhw6t0YW4gUmVuYXVkZWF1J3MgQmV6aWVyRWFzaW5nXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZy9ibG9iL21hc3Rlci9zcmMvaW5kZXguanNcbiAgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAgXG4gIEkndmUgcmVtb3ZlZCB0aGUgbmV3dG9uUmFwaHNvbkl0ZXJhdGUgYWxnbyBiZWNhdXNlIGluIGJlbmNobWFya2luZyBpdFxuICB3YXNuJ3Qgbm90aWNpYWJseSBmYXN0ZXIgdGhhbiBiaW5hcnlTdWJkaXZpc2lvbiwgaW5kZWVkIHJlbW92aW5nIGl0XG4gIHVzdWFsbHkgaW1wcm92ZWQgdGltZXMsIGRlcGVuZGluZyBvbiB0aGUgY3VydmUuXG4gIEkgYWxzbyByZW1vdmVkIHRoZSBsb29rdXAgdGFibGUsIGFzIGZvciB0aGUgYWRkZWQgYnVuZGxlIHNpemUgYW5kIGxvb3Agd2UncmVcbiAgb25seSBjdXR0aW5nIH40IG9yIHNvIHN1YmRpdmlzaW9uIGl0ZXJhdGlvbnMuIEkgYnVtcGVkIHRoZSBtYXggaXRlcmF0aW9ucyB1cFxuICB0byAxMiB0byBjb21wZW5zYXRlIGFuZCB0aGlzIHN0aWxsIHRlbmRlZCB0byBiZSBmYXN0ZXIgZm9yIG5vIHBlcmNlaXZhYmxlXG4gIGxvc3MgaW4gYWNjdXJhY3kuXG4gIFVzYWdlXG4gICAgY29uc3QgZWFzZU91dCA9IGN1YmljQmV6aWVyKC4xNywuNjcsLjgzLC42Nyk7XG4gICAgY29uc3QgeCA9IGVhc2VPdXQoMC41KTsgLy8gcmV0dXJucyAwLjYyNy4uLlxuKi9cbi8vIFJldHVybnMgeCh0KSBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciB5KHQpIGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5jb25zdCBjYWxjQmV6aWVyID0gKHQsIGExLCBhMikgPT4gKCgoMS4wIC0gMy4wICogYTIgKyAzLjAgKiBhMSkgKiB0ICsgKDMuMCAqIGEyIC0gNi4wICogYTEpKSAqIHQgKyAzLjAgKiBhMSkgKlxuICAgIHQ7XG5jb25zdCBzdWJkaXZpc2lvblByZWNpc2lvbiA9IDAuMDAwMDAwMTtcbmNvbnN0IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyA9IDEyO1xuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKHgsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQsIG1YMSwgbVgyKSB7XG4gICAgbGV0IGN1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50VDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgICBjdXJyZW50VCA9IGxvd2VyQm91bmQgKyAodXBwZXJCb3VuZCAtIGxvd2VyQm91bmQpIC8gMi4wO1xuICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIHg7XG4gICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICAgICAgdXBwZXJCb3VuZCA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG93ZXJCb3VuZCA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gc3ViZGl2aXNpb25QcmVjaXNpb24gJiZcbiAgICAgICAgKytpIDwgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zKTtcbiAgICByZXR1cm4gY3VycmVudFQ7XG59XG5mdW5jdGlvbiBjdWJpY0JlemllcihtWDEsIG1ZMSwgbVgyLCBtWTIpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgbGluZWFyIGdyYWRpZW50LCByZXR1cm4gbGluZWFyIGVhc2luZ1xuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMilcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgZ2V0VEZvclggPSAoYVgpID0+IGJpbmFyeVN1YmRpdmlkZShhWCwgMCwgMSwgbVgxLCBtWDIpO1xuICAgIC8vIElmIGFuaW1hdGlvbiBpcyBhdCBzdGFydC9lbmQsIHJldHVybiB0IHdpdGhvdXQgZWFzaW5nXG4gICAgcmV0dXJuICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogY2FsY0JlemllcihnZXRURm9yWCh0KSwgbVkxLCBtWTIpO1xufVxuXG5leHBvcnQgeyBjdWJpY0JlemllciB9O1xuIiwiLy8gQWNjZXB0cyBhbiBlYXNpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb25lIHRoYXQgb3V0cHV0cyBtaXJyb3JlZCB2YWx1ZXMgZm9yXG4vLyB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIGFuaW1hdGlvbi4gVHVybnMgZWFzZUluIGludG8gZWFzZUluT3V0LlxuY29uc3QgbWlycm9yRWFzaW5nID0gKGVhc2luZykgPT4gKHApID0+IHAgPD0gMC41ID8gZWFzaW5nKDIgKiBwKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwKSkpIC8gMjtcblxuZXhwb3J0IHsgbWlycm9yRWFzaW5nIH07XG4iLCIvLyBBY2NlcHRzIGFuIGVhc2luZyBmdW5jdGlvbiBhbmQgcmV0dXJucyBhIG5ldyBvbmUgdGhhdCBvdXRwdXRzIHJldmVyc2VkIHZhbHVlcy5cbi8vIFR1cm5zIGVhc2VJbiBpbnRvIGVhc2VPdXQuXG5jb25zdCByZXZlcnNlRWFzaW5nID0gKGVhc2luZykgPT4gKHApID0+IDEgLSBlYXNpbmcoMSAtIHApO1xuXG5leHBvcnQgeyByZXZlcnNlRWFzaW5nIH07XG4iLCJpbXBvcnQgeyBjdWJpY0JlemllciB9IGZyb20gJy4vY3ViaWMtYmV6aWVyLm1qcyc7XG5pbXBvcnQgeyBtaXJyb3JFYXNpbmcgfSBmcm9tICcuL21vZGlmaWVycy9taXJyb3IubWpzJztcbmltcG9ydCB7IHJldmVyc2VFYXNpbmcgfSBmcm9tICcuL21vZGlmaWVycy9yZXZlcnNlLm1qcyc7XG5cbmNvbnN0IGJhY2tPdXQgPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAuMzMsIDEuNTMsIDAuNjksIDAuOTkpO1xuY29uc3QgYmFja0luID0gLypAX19QVVJFX18qLyByZXZlcnNlRWFzaW5nKGJhY2tPdXQpO1xuY29uc3QgYmFja0luT3V0ID0gLypAX19QVVJFX18qLyBtaXJyb3JFYXNpbmcoYmFja0luKTtcblxuZXhwb3J0IHsgYmFja0luLCBiYWNrSW5PdXQsIGJhY2tPdXQgfTtcbiIsImltcG9ydCB7IGJhY2tJbiB9IGZyb20gJy4vYmFjay5tanMnO1xuXG5jb25zdCBhbnRpY2lwYXRlID0gKHApID0+IChwICo9IDIpIDwgMSA/IDAuNSAqIGJhY2tJbihwKSA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAgLSAxKSkpO1xuXG5leHBvcnQgeyBhbnRpY2lwYXRlIH07XG4iLCJpbXBvcnQgeyBtaXJyb3JFYXNpbmcgfSBmcm9tICcuL21vZGlmaWVycy9taXJyb3IubWpzJztcbmltcG9ydCB7IHJldmVyc2VFYXNpbmcgfSBmcm9tICcuL21vZGlmaWVycy9yZXZlcnNlLm1qcyc7XG5cbmNvbnN0IGNpcmNJbiA9IChwKSA9PiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHApKTtcbmNvbnN0IGNpcmNPdXQgPSByZXZlcnNlRWFzaW5nKGNpcmNJbik7XG5jb25zdCBjaXJjSW5PdXQgPSBtaXJyb3JFYXNpbmcoY2lyY0luKTtcblxuZXhwb3J0IHsgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQgfTtcbiIsIi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgemVybyB2YWx1ZSBzdHJpbmcgbGlrZSBcIjBweFwiIG9yIFwiMCVcIlxuICovXG5jb25zdCBpc1plcm9WYWx1ZVN0cmluZyA9ICh2KSA9PiAvXjBbXi5cXHNdKyQvdS50ZXN0KHYpO1xuXG5leHBvcnQgeyBpc1plcm9WYWx1ZVN0cmluZyB9O1xuIiwiaW1wb3J0IHsgaXNaZXJvVmFsdWVTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlscy9pcy16ZXJvLXZhbHVlLXN0cmluZy5tanMnO1xuXG5mdW5jdGlvbiBpc05vbmUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBcIm5vbmVcIiB8fCB2YWx1ZSA9PT0gXCIwXCIgfHwgaXNaZXJvVmFsdWVTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpc05vbmUgfTtcbiIsImNvbnN0IGNsYW1wID0gKG1pbiwgbWF4LCB2KSA9PiB7XG4gICAgaWYgKHYgPiBtYXgpXG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgaWYgKHYgPCBtaW4pXG4gICAgICAgIHJldHVybiBtaW47XG4gICAgcmV0dXJuIHY7XG59O1xuXG5leHBvcnQgeyBjbGFtcCB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jbGFtcC5tanMnO1xuXG5jb25zdCBudW1iZXIgPSB7XG4gICAgdGVzdDogKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiLFxuICAgIHBhcnNlOiBwYXJzZUZsb2F0LFxuICAgIHRyYW5zZm9ybTogKHYpID0+IHYsXG59O1xuY29uc3QgYWxwaGEgPSB7XG4gICAgLi4ubnVtYmVyLFxuICAgIHRyYW5zZm9ybTogKHYpID0+IGNsYW1wKDAsIDEsIHYpLFxufTtcbmNvbnN0IHNjYWxlID0ge1xuICAgIC4uLm51bWJlcixcbiAgICBkZWZhdWx0OiAxLFxufTtcblxuZXhwb3J0IHsgYWxwaGEsIG51bWJlciwgc2NhbGUgfTtcbiIsIi8vIElmIHRoaXMgbnVtYmVyIGlzIGEgZGVjaW1hbCwgbWFrZSBpdCBqdXN0IGZpdmUgZGVjaW1hbCBwbGFjZXNcbi8vIHRvIGF2b2lkIGV4cG9uZW50c1xuY29uc3Qgc2FuaXRpemUgPSAodikgPT4gTWF0aC5yb3VuZCh2ICogMTAwMDAwKSAvIDEwMDAwMDtcblxuZXhwb3J0IHsgc2FuaXRpemUgfTtcbiIsImNvbnN0IGZsb2F0UmVnZXggPSAvLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspL2d1O1xuXG5leHBvcnQgeyBmbG9hdFJlZ2V4IH07XG4iLCJmdW5jdGlvbiBpc051bGxpc2godikge1xuICAgIHJldHVybiB2ID09IG51bGw7XG59XG5cbmV4cG9ydCB7IGlzTnVsbGlzaCB9O1xuIiwiY29uc3Qgc2luZ2xlQ29sb3JSZWdleCA9IC9eKD86I1tcXGRhLWZdezMsOH18KD86cmdifGhzbClhP1xcKCg/Oi0/W1xcZC5dKyU/WyxcXHNdKyl7Mn0tP1tcXGQuXSslP1xccyooPzpbLC9dXFxzKik/KD86XFxiXFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKT8lP1xcKSkkL2l1O1xuXG5leHBvcnQgeyBzaW5nbGVDb2xvclJlZ2V4IH07XG4iLCJpbXBvcnQgeyBmbG9hdFJlZ2V4IH0gZnJvbSAnLi4vdXRpbHMvZmxvYXQtcmVnZXgubWpzJztcbmltcG9ydCB7IGlzTnVsbGlzaCB9IGZyb20gJy4uL3V0aWxzL2lzLW51bGxpc2gubWpzJztcbmltcG9ydCB7IHNpbmdsZUNvbG9yUmVnZXggfSBmcm9tICcuLi91dGlscy9zaW5nbGUtY29sb3ItcmVnZXgubWpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIGNvbG9yLCBpZSByZ2JhKDAsMCwwLDApIG9yICMwMDAsXG4gKiBidXQgZmFsc2UgaWYgYSBudW1iZXIgb3IgbXVsdGlwbGUgY29sb3JzXG4gKi9cbmNvbnN0IGlzQ29sb3JTdHJpbmcgPSAodHlwZSwgdGVzdFByb3ApID0+ICh2KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHNpbmdsZUNvbG9yUmVnZXgudGVzdCh2KSAmJlxuICAgICAgICB2LnN0YXJ0c1dpdGgodHlwZSkpIHx8XG4gICAgICAgICh0ZXN0UHJvcCAmJlxuICAgICAgICAgICAgIWlzTnVsbGlzaCh2KSAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHYsIHRlc3RQcm9wKSkpO1xufTtcbmNvbnN0IHNwbGl0Q29sb3IgPSAoYU5hbWUsIGJOYW1lLCBjTmFtZSkgPT4gKHYpID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFthLCBiLCBjLCBhbHBoYV0gPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFthTmFtZV06IHBhcnNlRmxvYXQoYSksXG4gICAgICAgIFtiTmFtZV06IHBhcnNlRmxvYXQoYiksXG4gICAgICAgIFtjTmFtZV06IHBhcnNlRmxvYXQoYyksXG4gICAgICAgIGFscGhhOiBhbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyc2VGbG9hdChhbHBoYSkgOiAxLFxuICAgIH07XG59O1xuXG5leHBvcnQgeyBpc0NvbG9yU3RyaW5nLCBzcGxpdENvbG9yIH07XG4iLCJpbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NsYW1wLm1qcyc7XG5pbXBvcnQgeyBhbHBoYSwgbnVtYmVyIH0gZnJvbSAnLi4vbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgc2FuaXRpemUgfSBmcm9tICcuLi91dGlscy9zYW5pdGl6ZS5tanMnO1xuaW1wb3J0IHsgaXNDb2xvclN0cmluZywgc3BsaXRDb2xvciB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuY29uc3QgY2xhbXBSZ2JVbml0ID0gKHYpID0+IGNsYW1wKDAsIDI1NSwgdik7XG5jb25zdCByZ2JVbml0ID0ge1xuICAgIC4uLm51bWJlcixcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSksXG59O1xuY29uc3QgcmdiYSA9IHtcbiAgICB0ZXN0OiAvKkBfX1BVUkVfXyovIGlzQ29sb3JTdHJpbmcoXCJyZ2JcIiwgXCJyZWRcIiksXG4gICAgcGFyc2U6IC8qQF9fUFVSRV9fKi8gc3BsaXRDb2xvcihcInJlZFwiLCBcImdyZWVuXCIsIFwiYmx1ZVwiKSxcbiAgICB0cmFuc2Zvcm06ICh7IHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiBcInJnYmEoXCIgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShyZWQpICtcbiAgICAgICAgXCIsIFwiICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0oZ3JlZW4pICtcbiAgICAgICAgXCIsIFwiICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0oYmx1ZSkgK1xuICAgICAgICBcIiwgXCIgK1xuICAgICAgICBzYW5pdGl6ZShhbHBoYS50cmFuc2Zvcm0oYWxwaGEkMSkpICtcbiAgICAgICAgXCIpXCIsXG59O1xuXG5leHBvcnQgeyByZ2JVbml0LCByZ2JhIH07XG4iLCJpbXBvcnQgeyByZ2JhIH0gZnJvbSAnLi9yZ2JhLm1qcyc7XG5pbXBvcnQgeyBpc0NvbG9yU3RyaW5nIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5mdW5jdGlvbiBwYXJzZUhleCh2KSB7XG4gICAgbGV0IHIgPSBcIlwiO1xuICAgIGxldCBnID0gXCJcIjtcbiAgICBsZXQgYiA9IFwiXCI7XG4gICAgbGV0IGEgPSBcIlwiO1xuICAgIC8vIElmIHdlIGhhdmUgNiBjaGFyYWN0ZXJzLCBpZSAjRkYwMDAwXG4gICAgaWYgKHYubGVuZ3RoID4gNSkge1xuICAgICAgICByID0gdi5zdWJzdHJpbmcoMSwgMyk7XG4gICAgICAgIGcgPSB2LnN1YnN0cmluZygzLCA1KTtcbiAgICAgICAgYiA9IHYuc3Vic3RyaW5nKDUsIDcpO1xuICAgICAgICBhID0gdi5zdWJzdHJpbmcoNywgOSk7XG4gICAgICAgIC8vIE9yIHdlIGhhdmUgMyBjaGFyYWN0ZXJzLCBpZSAjRjAwXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByID0gdi5zdWJzdHJpbmcoMSwgMik7XG4gICAgICAgIGcgPSB2LnN1YnN0cmluZygyLCAzKTtcbiAgICAgICAgYiA9IHYuc3Vic3RyaW5nKDMsIDQpO1xuICAgICAgICBhID0gdi5zdWJzdHJpbmcoNCwgNSk7XG4gICAgICAgIHIgKz0gcjtcbiAgICAgICAgZyArPSBnO1xuICAgICAgICBiICs9IGI7XG4gICAgICAgIGEgKz0gYTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiBwYXJzZUludChyLCAxNiksXG4gICAgICAgIGdyZWVuOiBwYXJzZUludChnLCAxNiksXG4gICAgICAgIGJsdWU6IHBhcnNlSW50KGIsIDE2KSxcbiAgICAgICAgYWxwaGE6IGEgPyBwYXJzZUludChhLCAxNikgLyAyNTUgOiAxLFxuICAgIH07XG59XG5jb25zdCBoZXggPSB7XG4gICAgdGVzdDogLypAX19QVVJFX18qLyBpc0NvbG9yU3RyaW5nKFwiI1wiKSxcbiAgICBwYXJzZTogcGFyc2VIZXgsXG4gICAgdHJhbnNmb3JtOiByZ2JhLnRyYW5zZm9ybSxcbn07XG5cbmV4cG9ydCB7IGhleCB9O1xuIiwiY29uc3QgY3JlYXRlVW5pdFR5cGUgPSAodW5pdCkgPT4gKHtcbiAgICB0ZXN0OiAodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgdi5lbmRzV2l0aCh1bml0KSAmJiB2LnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDEsXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gYCR7dn0ke3VuaXR9YCxcbn0pO1xuY29uc3QgZGVncmVlcyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCJkZWdcIik7XG5jb25zdCBwZXJjZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVVbml0VHlwZShcIiVcIik7XG5jb25zdCBweCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCJweFwiKTtcbmNvbnN0IHZoID0gLypAX19QVVJFX18qLyBjcmVhdGVVbml0VHlwZShcInZoXCIpO1xuY29uc3QgdncgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVVuaXRUeXBlKFwidndcIik7XG5jb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSB7XG4gICAgLi4ucGVyY2VudCxcbiAgICBwYXJzZTogKHYpID0+IHBlcmNlbnQucGFyc2UodikgLyAxMDAsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gcGVyY2VudC50cmFuc2Zvcm0odiAqIDEwMCksXG59O1xuXG5leHBvcnQgeyBkZWdyZWVzLCBwZXJjZW50LCBwcm9ncmVzc1BlcmNlbnRhZ2UsIHB4LCB2aCwgdncgfTtcbiIsImltcG9ydCB7IGFscGhhIH0gZnJvbSAnLi4vbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcGVyY2VudCB9IGZyb20gJy4uL251bWJlcnMvdW5pdHMubWpzJztcbmltcG9ydCB7IHNhbml0aXplIH0gZnJvbSAnLi4vdXRpbHMvc2FuaXRpemUubWpzJztcbmltcG9ydCB7IGlzQ29sb3JTdHJpbmcsIHNwbGl0Q29sb3IgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNvbnN0IGhzbGEgPSB7XG4gICAgdGVzdDogLypAX19QVVJFX18qLyBpc0NvbG9yU3RyaW5nKFwiaHNsXCIsIFwiaHVlXCIpLFxuICAgIHBhcnNlOiAvKkBfX1BVUkVfXyovIHNwbGl0Q29sb3IoXCJodWVcIiwgXCJzYXR1cmF0aW9uXCIsIFwibGlnaHRuZXNzXCIpLFxuICAgIHRyYW5zZm9ybTogKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiB7XG4gICAgICAgIHJldHVybiAoXCJoc2xhKFwiICtcbiAgICAgICAgICAgIE1hdGgucm91bmQoaHVlKSArXG4gICAgICAgICAgICBcIiwgXCIgK1xuICAgICAgICAgICAgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUoc2F0dXJhdGlvbikpICtcbiAgICAgICAgICAgIFwiLCBcIiArXG4gICAgICAgICAgICBwZXJjZW50LnRyYW5zZm9ybShzYW5pdGl6ZShsaWdodG5lc3MpKSArXG4gICAgICAgICAgICBcIiwgXCIgK1xuICAgICAgICAgICAgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArXG4gICAgICAgICAgICBcIilcIik7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGhzbGEgfTtcbiIsImltcG9ydCB7IGhleCB9IGZyb20gJy4vaGV4Lm1qcyc7XG5pbXBvcnQgeyBoc2xhIH0gZnJvbSAnLi9oc2xhLm1qcyc7XG5pbXBvcnQgeyByZ2JhIH0gZnJvbSAnLi9yZ2JhLm1qcyc7XG5cbmNvbnN0IGNvbG9yID0ge1xuICAgIHRlc3Q6ICh2KSA9PiByZ2JhLnRlc3QodikgfHwgaGV4LnRlc3QodikgfHwgaHNsYS50ZXN0KHYpLFxuICAgIHBhcnNlOiAodikgPT4ge1xuICAgICAgICBpZiAocmdiYS50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmdiYS5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc2xhLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiBoc2xhLnBhcnNlKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhleC5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJhbnNmb3JtOiAodikgPT4ge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gdlxuICAgICAgICAgICAgOiB2Lmhhc093blByb3BlcnR5KFwicmVkXCIpXG4gICAgICAgICAgICAgICAgPyByZ2JhLnRyYW5zZm9ybSh2KVxuICAgICAgICAgICAgICAgIDogaHNsYS50cmFuc2Zvcm0odik7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGNvbG9yIH07XG4iLCJjb25zdCBjb2xvclJlZ2V4ID0gLyg/OiNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCkpL2dpdTtcblxuZXhwb3J0IHsgY29sb3JSZWdleCB9O1xuIiwiaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuLi9jb2xvci9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29sb3JSZWdleCB9IGZyb20gJy4uL3V0aWxzL2NvbG9yLXJlZ2V4Lm1qcyc7XG5pbXBvcnQgeyBmbG9hdFJlZ2V4IH0gZnJvbSAnLi4vdXRpbHMvZmxvYXQtcmVnZXgubWpzJztcbmltcG9ydCB7IHNhbml0aXplIH0gZnJvbSAnLi4vdXRpbHMvc2FuaXRpemUubWpzJztcblxuZnVuY3Rpb24gdGVzdCh2KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKGlzTmFOKHYpICYmXG4gICAgICAgIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICgoKF9hID0gdi5tYXRjaChmbG9hdFJlZ2V4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMCkgK1xuICAgICAgICAgICAgKCgoX2IgPSB2Lm1hdGNoKGNvbG9yUmVnZXgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwKSA+XG4gICAgICAgICAgICAwKTtcbn1cbmNvbnN0IE5VTUJFUl9UT0tFTiA9IFwibnVtYmVyXCI7XG5jb25zdCBDT0xPUl9UT0tFTiA9IFwiY29sb3JcIjtcbmNvbnN0IFZBUl9UT0tFTiA9IFwidmFyXCI7XG5jb25zdCBWQVJfRlVOQ1RJT05fVE9LRU4gPSBcInZhcihcIjtcbmNvbnN0IFNQTElUX1RPS0VOID0gXCIke31cIjtcbi8vIHRoaXMgcmVnZXggY29uc2lzdHMgb2YgdGhlIGBzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4fHJnYkhTTFZhbHVlUmVnZXh8ZGlnaXRSZWdleGBcbmNvbnN0IGNvbXBsZXhSZWdleCA9IC92YXJcXHMqXFwoXFxzKi0tKD86W1xcdy1dK1xccyp8W1xcdy1dK1xccyosKD86XFxzKlteKShcXHNdfFxccypcXCgoPzpbXikoXXxcXChbXikoXSpcXCkpKlxcKSkrXFxzKilcXCl8I1tcXGRhLWZdezMsOH18KD86cmdifGhzbClhP1xcKCg/Oi0/W1xcZC5dKyU/WyxcXHNdKyl7Mn0tP1tcXGQuXSslP1xccyooPzpbLC9dXFxzKik/KD86XFxiXFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKT8lP1xcKXwtPyg/OlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKykvZ2l1O1xuZnVuY3Rpb24gYW5hbHlzZUNvbXBsZXhWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGluZGV4ZXMgPSB7XG4gICAgICAgIGNvbG9yOiBbXSxcbiAgICAgICAgbnVtYmVyOiBbXSxcbiAgICAgICAgdmFyOiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHRva2VuaXNlZCA9IG9yaWdpbmFsVmFsdWUucmVwbGFjZShjb21wbGV4UmVnZXgsIChwYXJzZWRWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAoY29sb3IudGVzdChwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGluZGV4ZXMuY29sb3IucHVzaChpKTtcbiAgICAgICAgICAgIHR5cGVzLnB1c2goQ09MT1JfVE9LRU4pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29sb3IucGFyc2UocGFyc2VkVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZWRWYWx1ZS5zdGFydHNXaXRoKFZBUl9GVU5DVElPTl9UT0tFTikpIHtcbiAgICAgICAgICAgIGluZGV4ZXMudmFyLnB1c2goaSk7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKFZBUl9UT0tFTik7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleGVzLm51bWJlci5wdXNoKGkpO1xuICAgICAgICAgICAgdHlwZXMucHVzaChOVU1CRVJfVE9LRU4pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VGbG9hdChwYXJzZWRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgICsraTtcbiAgICAgICAgcmV0dXJuIFNQTElUX1RPS0VOO1xuICAgIH0pO1xuICAgIGNvbnN0IHNwbGl0ID0gdG9rZW5pc2VkLnNwbGl0KFNQTElUX1RPS0VOKTtcbiAgICByZXR1cm4geyB2YWx1ZXMsIHNwbGl0LCBpbmRleGVzLCB0eXBlcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VDb21wbGV4VmFsdWUodikge1xuICAgIHJldHVybiBhbmFseXNlQ29tcGxleFZhbHVlKHYpLnZhbHVlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybWVyKHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc3BsaXQsIHR5cGVzIH0gPSBhbmFseXNlQ29tcGxleFZhbHVlKHNvdXJjZSk7XG4gICAgY29uc3QgbnVtU2VjdGlvbnMgPSBzcGxpdC5sZW5ndGg7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNlY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBzcGxpdFtpXTtcbiAgICAgICAgICAgIGlmICh2W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IE5VTUJFUl9UT0tFTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc2FuaXRpemUodltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IENPTE9SX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBjb2xvci50cmFuc2Zvcm0odltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuY29uc3QgY29udmVydE51bWJlcnNUb1plcm8gPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyAwIDogdjtcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKHYpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUNvbXBsZXhWYWx1ZSh2KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZVRyYW5zZm9ybWVyKHYpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcihwYXJzZWQubWFwKGNvbnZlcnROdW1iZXJzVG9aZXJvKSk7XG59XG5jb25zdCBjb21wbGV4ID0ge1xuICAgIHRlc3QsXG4gICAgcGFyc2U6IHBhcnNlQ29tcGxleFZhbHVlLFxuICAgIGNyZWF0ZVRyYW5zZm9ybWVyLFxuICAgIGdldEFuaW1hdGFibGVOb25lLFxufTtcblxuZXhwb3J0IHsgYW5hbHlzZUNvbXBsZXhWYWx1ZSwgY29tcGxleCB9O1xuIiwiaW1wb3J0IHsgY29tcGxleCB9IGZyb20gJy4vaW5kZXgubWpzJztcbmltcG9ydCB7IGZsb2F0UmVnZXggfSBmcm9tICcuLi91dGlscy9mbG9hdC1yZWdleC5tanMnO1xuXG4vKipcbiAqIFByb3BlcnRpZXMgdGhhdCBzaG91bGQgZGVmYXVsdCB0byAxIG9yIDEwMCVcbiAqL1xuY29uc3QgbWF4RGVmYXVsdHMgPSBuZXcgU2V0KFtcImJyaWdodG5lc3NcIiwgXCJjb250cmFzdFwiLCBcInNhdHVyYXRlXCIsIFwib3BhY2l0eVwiXSk7XG5mdW5jdGlvbiBhcHBseURlZmF1bHRGaWx0ZXIodikge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSB2LnNsaWNlKDAsIC0xKS5zcGxpdChcIihcIik7XG4gICAgaWYgKG5hbWUgPT09IFwiZHJvcC1zaGFkb3dcIilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgY29uc3QgW251bWJlcl0gPSB2YWx1ZS5tYXRjaChmbG9hdFJlZ2V4KSB8fCBbXTtcbiAgICBpZiAoIW51bWJlcilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgY29uc3QgdW5pdCA9IHZhbHVlLnJlcGxhY2UobnVtYmVyLCBcIlwiKTtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gbWF4RGVmYXVsdHMuaGFzKG5hbWUpID8gMSA6IDA7XG4gICAgaWYgKG51bWJlciAhPT0gdmFsdWUpXG4gICAgICAgIGRlZmF1bHRWYWx1ZSAqPSAxMDA7XG4gICAgcmV0dXJuIG5hbWUgKyBcIihcIiArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyBcIilcIjtcbn1cbmNvbnN0IGZ1bmN0aW9uUmVnZXggPSAvXFxiKFthLXotXSopXFwoLio/XFwpL2d1O1xuY29uc3QgZmlsdGVyID0ge1xuICAgIC4uLmNvbXBsZXgsXG4gICAgZ2V0QW5pbWF0YWJsZU5vbmU6ICh2KSA9PiB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHYubWF0Y2goZnVuY3Rpb25SZWdleCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbnMgPyBmdW5jdGlvbnMubWFwKGFwcGx5RGVmYXVsdEZpbHRlcikuam9pbihcIiBcIikgOiB2O1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBmaWx0ZXIgfTtcbiIsImltcG9ydCB7IHB4IH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuXG5jb25zdCBicm93c2VyTnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJXaWR0aDogcHgsXG4gICAgYm9yZGVyVG9wV2lkdGg6IHB4LFxuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHB4LFxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBweCxcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHB4LFxuICAgIGJvcmRlclJhZGl1czogcHgsXG4gICAgcmFkaXVzOiBweCxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBweCxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogcHgsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHB4LFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IHB4LFxuICAgIC8vIFBvc2l0aW9uaW5nIHByb3BzXG4gICAgd2lkdGg6IHB4LFxuICAgIG1heFdpZHRoOiBweCxcbiAgICBoZWlnaHQ6IHB4LFxuICAgIG1heEhlaWdodDogcHgsXG4gICAgdG9wOiBweCxcbiAgICByaWdodDogcHgsXG4gICAgYm90dG9tOiBweCxcbiAgICBsZWZ0OiBweCxcbiAgICAvLyBTcGFjaW5nIHByb3BzXG4gICAgcGFkZGluZzogcHgsXG4gICAgcGFkZGluZ1RvcDogcHgsXG4gICAgcGFkZGluZ1JpZ2h0OiBweCxcbiAgICBwYWRkaW5nQm90dG9tOiBweCxcbiAgICBwYWRkaW5nTGVmdDogcHgsXG4gICAgbWFyZ2luOiBweCxcbiAgICBtYXJnaW5Ub3A6IHB4LFxuICAgIG1hcmdpblJpZ2h0OiBweCxcbiAgICBtYXJnaW5Cb3R0b206IHB4LFxuICAgIG1hcmdpbkxlZnQ6IHB4LFxuICAgIC8vIE1pc2NcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiBweCxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiBweCxcbn07XG5cbmV4cG9ydCB7IGJyb3dzZXJOdW1iZXJWYWx1ZVR5cGVzIH07XG4iLCJpbXBvcnQgeyBzY2FsZSwgYWxwaGEgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBkZWdyZWVzLCBweCwgcHJvZ3Jlc3NQZXJjZW50YWdlIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuXG5jb25zdCB0cmFuc2Zvcm1WYWx1ZVR5cGVzID0ge1xuICAgIHJvdGF0ZTogZGVncmVlcyxcbiAgICByb3RhdGVYOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVk6IGRlZ3JlZXMsXG4gICAgcm90YXRlWjogZGVncmVlcyxcbiAgICBzY2FsZSxcbiAgICBzY2FsZVg6IHNjYWxlLFxuICAgIHNjYWxlWTogc2NhbGUsXG4gICAgc2NhbGVaOiBzY2FsZSxcbiAgICBza2V3OiBkZWdyZWVzLFxuICAgIHNrZXdYOiBkZWdyZWVzLFxuICAgIHNrZXdZOiBkZWdyZWVzLFxuICAgIGRpc3RhbmNlOiBweCxcbiAgICB0cmFuc2xhdGVYOiBweCxcbiAgICB0cmFuc2xhdGVZOiBweCxcbiAgICB0cmFuc2xhdGVaOiBweCxcbiAgICB4OiBweCxcbiAgICB5OiBweCxcbiAgICB6OiBweCxcbiAgICBwZXJzcGVjdGl2ZTogcHgsXG4gICAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IHB4LFxuICAgIG9wYWNpdHk6IGFscGhhLFxuICAgIG9yaWdpblg6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBvcmlnaW5ZOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWjogcHgsXG59O1xuXG5leHBvcnQgeyB0cmFuc2Zvcm1WYWx1ZVR5cGVzIH07XG4iLCJpbXBvcnQgeyBudW1iZXIgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL2luZGV4Lm1qcyc7XG5cbmNvbnN0IGludCA9IHtcbiAgICAuLi5udW1iZXIsXG4gICAgdHJhbnNmb3JtOiBNYXRoLnJvdW5kLFxufTtcblxuZXhwb3J0IHsgaW50IH07XG4iLCJpbXBvcnQgeyBhbHBoYSB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHB4IH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuaW1wb3J0IHsgYnJvd3Nlck51bWJlclZhbHVlVHlwZXMgfSBmcm9tICcuL251bWJlci1icm93c2VyLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1WYWx1ZVR5cGVzIH0gZnJvbSAnLi90cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGludCB9IGZyb20gJy4vdHlwZS1pbnQubWpzJztcblxuY29uc3QgbnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgICAuLi5icm93c2VyTnVtYmVyVmFsdWVUeXBlcyxcbiAgICAuLi50cmFuc2Zvcm1WYWx1ZVR5cGVzLFxuICAgIHpJbmRleDogaW50LFxuICAgIHNpemU6IHB4LFxuICAgIC8vIFNWR1xuICAgIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgICBzdHJva2VPcGFjaXR5OiBhbHBoYSxcbiAgICBudW1PY3RhdmVzOiBpbnQsXG59O1xuXG5leHBvcnQgeyBudW1iZXJWYWx1ZVR5cGVzIH07XG4iLCJpbXBvcnQgeyBjb2xvciB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL2NvbG9yL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2ZpbHRlci5tanMnO1xuaW1wb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9IGZyb20gJy4vbnVtYmVyLm1qcyc7XG5cbi8qKlxuICogQSBtYXAgb2YgZGVmYXVsdCB2YWx1ZSB0eXBlcyBmb3IgY29tbW9uIHZhbHVlc1xuICovXG5jb25zdCBkZWZhdWx0VmFsdWVUeXBlcyA9IHtcbiAgICAuLi5udW1iZXJWYWx1ZVR5cGVzLFxuICAgIC8vIENvbG9yIHByb3BzXG4gICAgY29sb3IsXG4gICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcixcbiAgICBvdXRsaW5lQ29sb3I6IGNvbG9yLFxuICAgIGZpbGw6IGNvbG9yLFxuICAgIHN0cm9rZTogY29sb3IsXG4gICAgLy8gQm9yZGVyIHByb3BzXG4gICAgYm9yZGVyQ29sb3I6IGNvbG9yLFxuICAgIGJvcmRlclRvcENvbG9yOiBjb2xvcixcbiAgICBib3JkZXJSaWdodENvbG9yOiBjb2xvcixcbiAgICBib3JkZXJCb3R0b21Db2xvcjogY29sb3IsXG4gICAgYm9yZGVyTGVmdENvbG9yOiBjb2xvcixcbiAgICBmaWx0ZXIsXG4gICAgV2Via2l0RmlsdGVyOiBmaWx0ZXIsXG59O1xuLyoqXG4gKiBHZXRzIHRoZSBkZWZhdWx0IFZhbHVlVHlwZSBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlIGtleVxuICovXG5jb25zdCBnZXREZWZhdWx0VmFsdWVUeXBlID0gKGtleSkgPT4gZGVmYXVsdFZhbHVlVHlwZXNba2V5XTtcblxuZXhwb3J0IHsgZGVmYXVsdFZhbHVlVHlwZXMsIGdldERlZmF1bHRWYWx1ZVR5cGUgfTtcbiIsImltcG9ydCB7IGNvbXBsZXggfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2ZpbHRlci5tanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFZhbHVlVHlwZSB9IGZyb20gJy4vZGVmYXVsdHMubWpzJztcblxuZnVuY3Rpb24gZ2V0QW5pbWF0YWJsZU5vbmUoa2V5LCB2YWx1ZSkge1xuICAgIGxldCBkZWZhdWx0VmFsdWVUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBmaWx0ZXIpXG4gICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSBjb21wbGV4O1xuICAgIC8vIElmIHZhbHVlIGlzIG5vdCByZWNvZ25pc2VkIGFzIGFuaW1hdGFibGUsIGllIFwibm9uZVwiLCBjcmVhdGUgYW4gYW5pbWF0YWJsZSB2ZXJzaW9uIG9yaWdpbiBiYXNlZCBvbiB0aGUgdGFyZ2V0XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVR5cGUuZ2V0QW5pbWF0YWJsZU5vbmVcbiAgICAgICAgPyBkZWZhdWx0VmFsdWVUeXBlLmdldEFuaW1hdGFibGVOb25lKHZhbHVlKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgZ2V0QW5pbWF0YWJsZU5vbmUgfTtcbiIsImltcG9ydCB7IGFuYWx5c2VDb21wbGV4VmFsdWUgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBnZXRBbmltYXRhYmxlTm9uZSB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9hbmltYXRhYmxlLW5vbmUubWpzJztcblxuLyoqXG4gKiBJZiB3ZSBlbmNvdW50ZXIga2V5ZnJhbWVzIGxpa2UgXCJub25lXCIgb3IgXCIwXCIgYW5kIHdlIGFsc28gaGF2ZSBrZXlmcmFtZXMgbGlrZVxuICogXCIjZmZmXCIgb3IgXCIyMDBweCAyMDBweFwiIHdlIHdhbnQgdG8gZmluZCBhIGtleWZyYW1lIHRvIHNlcnZlIGFzIGEgdGVtcGxhdGUgZm9yXG4gKiB0aGUgXCJub25lXCIga2V5ZnJhbWVzLiBJbiB0aGlzIGNhc2UgXCIjZmZmXCIgb3IgXCIyMDBweCAyMDBweFwiIC0gdGhlbiB0aGVzZSBnZXQgdHVybmVkIGludG9cbiAqIHplcm8gZXF1aXZhbGVudHMsIGkuZS4gXCIjZmZmMFwiIG9yIFwiMHB4IDBweFwiLlxuICovXG5jb25zdCBpbnZhbGlkVGVtcGxhdGVzID0gbmV3IFNldChbXCJhdXRvXCIsIFwibm9uZVwiLCBcIjBcIl0pO1xuZnVuY3Rpb24gbWFrZU5vbmVLZXlmcmFtZXNBbmltYXRhYmxlKHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5vbmVLZXlmcmFtZUluZGV4ZXMsIG5hbWUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGFuaW1hdGFibGVUZW1wbGF0ZSA9IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAoaSA8IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoICYmICFhbmltYXRhYmxlVGVtcGxhdGUpIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGtleWZyYW1lID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAhaW52YWxpZFRlbXBsYXRlcy5oYXMoa2V5ZnJhbWUpICYmXG4gICAgICAgICAgICBhbmFseXNlQ29tcGxleFZhbHVlKGtleWZyYW1lKS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhbmltYXRhYmxlVGVtcGxhdGUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKGFuaW1hdGFibGVUZW1wbGF0ZSAmJiBuYW1lKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9uZUluZGV4IG9mIG5vbmVLZXlmcmFtZUluZGV4ZXMpIHtcbiAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbbm9uZUluZGV4XSA9IGdldEFuaW1hdGFibGVOb25lKG5hbWUsIGFuaW1hdGFibGVUZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IG1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSB9O1xuIiwiaW1wb3J0IHsgbnVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcHggfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL3VuaXRzLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wT3JkZXIgfSBmcm9tICcuLi8uLi9odG1sL3V0aWxzL2tleXMtdHJhbnNmb3JtLm1qcyc7XG5cbmNvbnN0IGlzTnVtT3JQeFR5cGUgPSAodikgPT4gdiA9PT0gbnVtYmVyIHx8IHYgPT09IHB4O1xuY29uc3QgZ2V0UG9zRnJvbU1hdHJpeCA9IChtYXRyaXgsIHBvcykgPT4gcGFyc2VGbG9hdChtYXRyaXguc3BsaXQoXCIsIFwiKVtwb3NdKTtcbmNvbnN0IGdldFRyYW5zbGF0ZUZyb21NYXRyaXggPSAocG9zMiwgcG9zMykgPT4gKF9iYm94LCB7IHRyYW5zZm9ybSB9KSA9PiB7XG4gICAgaWYgKHRyYW5zZm9ybSA9PT0gXCJub25lXCIgfHwgIXRyYW5zZm9ybSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgbWF0cml4M2QgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkL3UpO1xuICAgIGlmIChtYXRyaXgzZCkge1xuICAgICAgICByZXR1cm4gZ2V0UG9zRnJvbU1hdHJpeChtYXRyaXgzZFsxXSwgcG9zMyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRyaXggPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXhcXCgoLispXFwpJC91KTtcbiAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4WzFdLCBwb3MyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxufTtcbmNvbnN0IHRyYW5zZm9ybUtleXMgPSBuZXcgU2V0KFtcInhcIiwgXCJ5XCIsIFwielwiXSk7XG5jb25zdCBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybVByb3BPcmRlci5maWx0ZXIoKGtleSkgPT4gIXRyYW5zZm9ybUtleXMuaGFzKGtleSkpO1xuZnVuY3Rpb24gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSh2aXN1YWxFbGVtZW50KSB7XG4gICAgY29uc3QgcmVtb3ZlZFRyYW5zZm9ybXMgPSBbXTtcbiAgICBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZW1vdmVkVHJhbnNmb3Jtcy5wdXNoKFtrZXksIHZhbHVlLmdldCgpXSk7XG4gICAgICAgICAgICB2YWx1ZS5zZXQoa2V5LnN0YXJ0c1dpdGgoXCJzY2FsZVwiKSA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZW1vdmVkVHJhbnNmb3Jtcztcbn1cbmNvbnN0IHBvc2l0aW9uYWxWYWx1ZXMgPSB7XG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHdpZHRoOiAoeyB4IH0sIHsgcGFkZGluZ0xlZnQgPSBcIjBcIiwgcGFkZGluZ1JpZ2h0ID0gXCIwXCIgfSkgPT4geC5tYXggLSB4Lm1pbiAtIHBhcnNlRmxvYXQocGFkZGluZ0xlZnQpIC0gcGFyc2VGbG9hdChwYWRkaW5nUmlnaHQpLFxuICAgIGhlaWdodDogKHsgeSB9LCB7IHBhZGRpbmdUb3AgPSBcIjBcIiwgcGFkZGluZ0JvdHRvbSA9IFwiMFwiIH0pID0+IHkubWF4IC0geS5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdUb3ApIC0gcGFyc2VGbG9hdChwYWRkaW5nQm90dG9tKSxcbiAgICB0b3A6IChfYmJveCwgeyB0b3AgfSkgPT4gcGFyc2VGbG9hdCh0b3ApLFxuICAgIGxlZnQ6IChfYmJveCwgeyBsZWZ0IH0pID0+IHBhcnNlRmxvYXQobGVmdCksXG4gICAgYm90dG9tOiAoeyB5IH0sIHsgdG9wIH0pID0+IHBhcnNlRmxvYXQodG9wKSArICh5Lm1heCAtIHkubWluKSxcbiAgICByaWdodDogKHsgeCB9LCB7IGxlZnQgfSkgPT4gcGFyc2VGbG9hdChsZWZ0KSArICh4Lm1heCAtIHgubWluKSxcbiAgICAvLyBUcmFuc2Zvcm1cbiAgICB4OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDQsIDEzKSxcbiAgICB5OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDUsIDE0KSxcbn07XG4vLyBBbGlhcyB0cmFuc2xhdGUgbG9uZ2Zvcm0gbmFtZXNcbnBvc2l0aW9uYWxWYWx1ZXMudHJhbnNsYXRlWCA9IHBvc2l0aW9uYWxWYWx1ZXMueDtcbnBvc2l0aW9uYWxWYWx1ZXMudHJhbnNsYXRlWSA9IHBvc2l0aW9uYWxWYWx1ZXMueTtcblxuZXhwb3J0IHsgaXNOdW1PclB4VHlwZSwgcG9zaXRpb25hbFZhbHVlcywgcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSB9O1xuIiwiaW1wb3J0IHsgcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybSB9IGZyb20gJy4uL2RvbS91dGlscy91bml0LWNvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbmNvbnN0IHRvUmVzb2x2ZSA9IG5ldyBTZXQoKTtcbmxldCBpc1NjaGVkdWxlZCA9IGZhbHNlO1xubGV0IGFueU5lZWRzTWVhc3VyZW1lbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIG1lYXN1cmVBbGxLZXlmcmFtZXMoKSB7XG4gICAgaWYgKGFueU5lZWRzTWVhc3VyZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJzVG9NZWFzdXJlID0gQXJyYXkuZnJvbSh0b1Jlc29sdmUpLmZpbHRlcigocmVzb2x2ZXIpID0+IHJlc29sdmVyLm5lZWRzTWVhc3VyZW1lbnQpO1xuICAgICAgICBjb25zdCBlbGVtZW50c1RvTWVhc3VyZSA9IG5ldyBTZXQocmVzb2x2ZXJzVG9NZWFzdXJlLm1hcCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLmVsZW1lbnQpKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3Jtc1RvUmVzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIHBhc3NcbiAgICAgICAgICogSWYgd2UncmUgbWVhc3VyaW5nIGVsZW1lbnRzIHdlIHdhbnQgdG8gcmVtb3ZlIGJvdW5kaW5nIGJveC1jaGFuZ2luZyB0cmFuc2Zvcm1zLlxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudHNUb01lYXN1cmUuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFRyYW5zZm9ybXMgPSByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJhbnNmb3Jtc1RvUmVzdG9yZS5zZXQoZWxlbWVudCwgcmVtb3ZlZFRyYW5zZm9ybXMpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlYWRcbiAgICAgICAgcmVzb2x2ZXJzVG9NZWFzdXJlLmZvckVhY2goKHJlc29sdmVyKSA9PiByZXNvbHZlci5tZWFzdXJlSW5pdGlhbFN0YXRlKCkpO1xuICAgICAgICAvLyBXcml0ZVxuICAgICAgICBlbGVtZW50c1RvTWVhc3VyZS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZSA9IHRyYW5zZm9ybXNUb1Jlc3RvcmUuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWFkXG4gICAgICAgIHJlc29sdmVyc1RvTWVhc3VyZS5mb3JFYWNoKChyZXNvbHZlcikgPT4gcmVzb2x2ZXIubWVhc3VyZUVuZFN0YXRlKCkpO1xuICAgICAgICAvLyBXcml0ZVxuICAgICAgICByZXNvbHZlcnNUb01lYXN1cmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlci5zdXNwZW5kZWRTY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzb2x2ZXIuc3VzcGVuZGVkU2Nyb2xsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhbnlOZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0b1Jlc29sdmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLmNvbXBsZXRlKCkpO1xuICAgIHRvUmVzb2x2ZS5jbGVhcigpO1xufVxuZnVuY3Rpb24gcmVhZEFsbEtleWZyYW1lcygpIHtcbiAgICB0b1Jlc29sdmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgcmVzb2x2ZXIucmVhZEtleWZyYW1lcygpO1xuICAgICAgICBpZiAocmVzb2x2ZXIubmVlZHNNZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgYW55TmVlZHNNZWFzdXJlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZsdXNoS2V5ZnJhbWVSZXNvbHZlcnMoKSB7XG4gICAgcmVhZEFsbEtleWZyYW1lcygpO1xuICAgIG1lYXN1cmVBbGxLZXlmcmFtZXMoKTtcbn1cbmNsYXNzIEtleWZyYW1lUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHVucmVzb2x2ZWRLZXlmcmFtZXMsIG9uQ29tcGxldGUsIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBpc0FzeW5jID0gZmFsc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBoYXMgY29tcGxldGVkLiBPbmNlIGNvbXBsZXRlLCBpdCBuZXZlclxuICAgICAgICAgKiBuZWVkcyB0byBhdHRlbXB0IGtleWZyYW1lIHJlc29sdXRpb24gYWdhaW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBpcyBhc3luYy4gSWYgaXQgaXMsIGl0J2xsIGJlIGFkZGVkIHRvIHRoZVxuICAgICAgICAgKiByZXNvbHZlciBxdWV1ZSBhbmQgZmx1c2hlZCBpbiB0aGUgbmV4dCBmcmFtZS4gUmVzb2x2ZXJzIHRoYXQgYXJlbid0IGdvaW5nXG4gICAgICAgICAqIHRvIHRyaWdnZXIgcmVhZC93cml0ZSB0aHJhc2hpbmcgZG9uJ3QgbmVlZCB0byBiZSBhc3luYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNBc3luYyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2sgd2hldGhlciB0aGlzIHJlc29sdmVyIG5lZWRzIHRvIHBlcmZvcm0gYSBtZWFzdXJlbWVudFxuICAgICAgICAgKiB0byByZXNvbHZlIGl0cyBrZXlmcmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5lZWRzTWVhc3VyZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBpcyBjdXJyZW50bHkgc2NoZWR1bGVkIHRvIHJlc29sdmVcbiAgICAgICAgICogdG8gYWxsb3cgaXQgdG8gYmUgY2FuY2VsbGVkIGFuZCByZXN1bWVkIGV4dGVybmFsbHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5yZXNvbHZlZEtleWZyYW1lcyA9IFsuLi51bnJlc29sdmVkS2V5ZnJhbWVzXTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tb3Rpb25WYWx1ZSA9IG1vdGlvblZhbHVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSBpc0FzeW5jO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlc29sdmUoKSB7XG4gICAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0FzeW5jKSB7XG4gICAgICAgICAgICB0b1Jlc29sdmUuYWRkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5yZWFkKHJlYWRBbGxLZXlmcmFtZXMpO1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlc29sdmVLZXlmcmFtZXMobWVhc3VyZUFsbEtleWZyYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRLZXlmcmFtZXMoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUsIGVsZW1lbnQsIG1vdGlvblZhbHVlIH0gPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBrZXlmcmFtZSBpcyBudWxsLCB3ZSBoeWRyYXRlIGl0IGVpdGhlciBieSByZWFkaW5nIGl0IGZyb21cbiAgICAgICAgICogdGhlIGluc3RhbmNlLCBvciBwcm9wYWdhdGluZyBmcm9tIHByZXZpb3VzIGtleWZyYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgZmlyc3Qga2V5ZnJhbWUgaXMgbnVsbCwgd2UgbmVlZCB0byBmaW5kIGl0cyB2YWx1ZSBieSBzYW1wbGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG1vdGlvblZhbHVlID09PSBudWxsIHx8IG1vdGlvblZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3Rpb25WYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQgJiYgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVBc1JlYWQgPSBlbGVtZW50LnJlYWRWYWx1ZShuYW1lLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFzUmVhZCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlQXNSZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZXNvbHZlZEtleWZyYW1lc1swXSA9IHZhbHVlQXNSZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0gPSBmaW5hbEtleWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb25WYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEZpbmFsS2V5ZnJhbWUoKSB7IH1cbiAgICBtZWFzdXJlSW5pdGlhbFN0YXRlKCkgeyB9XG4gICAgcmVuZGVyRW5kU3R5bGVzKCkgeyB9XG4gICAgbWVhc3VyZUVuZFN0YXRlKCkgeyB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSh0aGlzLnVucmVzb2x2ZWRLZXlmcmFtZXMsIHRoaXMuZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIHRvUmVzb2x2ZS5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvUmVzb2x2ZS5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb21wbGV0ZSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZXNvbHZlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBLZXlmcmFtZVJlc29sdmVyLCBmbHVzaEtleWZyYW1lUmVzb2x2ZXJzIH07XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnLi9ub29wLm1qcyc7XG5cbmxldCB3YXJuaW5nID0gbm9vcDtcbmxldCBpbnZhcmlhbnQgPSBub29wO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHdhcm5pbmcgPSAoY2hlY2ssIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpbnZhcmlhbnQgPSAoY2hlY2ssIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKCFjaGVjaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgaW52YXJpYW50LCB3YXJuaW5nIH07XG4iLCIvKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGEgbnVtZXJpY2FsIHN0cmluZywgaWUgYSBzdHJpbmcgdGhhdCBpcyBwdXJlbHkgYSBudW1iZXIgZWcgXCIxMDBcIiBvciBcIi0xMDAuMVwiXG4gKi9cbmNvbnN0IGlzTnVtZXJpY2FsU3RyaW5nID0gKHYpID0+IC9eLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspJC91LnRlc3Qodik7XG5cbmV4cG9ydCB7IGlzTnVtZXJpY2FsU3RyaW5nIH07XG4iLCJjb25zdCBjaGVja1N0cmluZ1N0YXJ0c1dpdGggPSAodG9rZW4pID0+IChrZXkpID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYga2V5LnN0YXJ0c1dpdGgodG9rZW4pO1xuY29uc3QgaXNDU1NWYXJpYWJsZU5hbWUgPSBcbi8qQF9fUFVSRV9fKi8gY2hlY2tTdHJpbmdTdGFydHNXaXRoKFwiLS1cIik7XG5jb25zdCBzdGFydHNBc1ZhcmlhYmxlVG9rZW4gPSBcbi8qQF9fUFVSRV9fKi8gY2hlY2tTdHJpbmdTdGFydHNXaXRoKFwidmFyKC0tXCIpO1xuY29uc3QgaXNDU1NWYXJpYWJsZVRva2VuID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgc3RhcnRzV2l0aFRva2VuID0gc3RhcnRzQXNWYXJpYWJsZVRva2VuKHZhbHVlKTtcbiAgICBpZiAoIXN0YXJ0c1dpdGhUb2tlbilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEVuc3VyZSBhbnkgY29tbWVudHMgYXJlIHN0cmlwcGVkIGZyb20gdGhlIHZhbHVlIGFzIHRoaXMgY2FuIGhhcm0gcGVyZm9ybWFuY2Ugb2YgdGhlIHJlZ2V4LlxuICAgIHJldHVybiBzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4LnRlc3QodmFsdWUuc3BsaXQoXCIvKlwiKVswXS50cmltKCkpO1xufTtcbmNvbnN0IHNpbmdsZUNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoLS0oPzpbXFx3LV0rXFxzKnxbXFx3LV0rXFxzKiwoPzpcXHMqW14pKFxcc118XFxzKlxcKCg/OlteKShdfFxcKFteKShdKlxcKSkqXFwpKStcXHMqKVxcKSQvaXU7XG5cbmV4cG9ydCB7IGlzQ1NTVmFyaWFibGVOYW1lLCBpc0NTU1ZhcmlhYmxlVG9rZW4gfTtcbiIsImltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBpc051bWVyaWNhbFN0cmluZyB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2lzLW51bWVyaWNhbC1zdHJpbmcubWpzJztcbmltcG9ydCB7IGlzQ1NTVmFyaWFibGVUb2tlbiB9IGZyb20gJy4vaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5cbi8qKlxuICogUGFyc2UgRnJhbWVyJ3Mgc3BlY2lhbCBDU1MgdmFyaWFibGUgZm9ybWF0IGludG8gYSBDU1MgdG9rZW4gYW5kIGEgZmFsbGJhY2suXG4gKlxuICogYGBgXG4gKiBgdmFyKC0tZm9vLCAjZmZmKWAgPT4gW2AtLWZvb2AsICcjZmZmJ11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBjdXJyZW50XG4gKi9cbmNvbnN0IHNwbGl0Q1NTVmFyaWFibGVSZWdleCA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlZG9zLWRldGVjdG9yL25vLXVuc2FmZS1yZWdleCAtLSBmYWxzZSBwb3NpdGl2ZSwgYXMgaXQgY2FuIG1hdGNoIGEgbG90IG9mIHdvcmRzXG4vXnZhclxcKC0tKD86KFtcXHctXSspfChbXFx3LV0rKSwgPyhbYS16QS1aXFxkICgpJSMuLC1dKykpXFwpL3U7XG5mdW5jdGlvbiBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpIHtcbiAgICBjb25zdCBtYXRjaCA9IHNwbGl0Q1NTVmFyaWFibGVSZWdleC5leGVjKGN1cnJlbnQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBbLF07XG4gICAgY29uc3QgWywgdG9rZW4xLCB0b2tlbjIsIGZhbGxiYWNrXSA9IG1hdGNoO1xuICAgIHJldHVybiBbYC0tJHt0b2tlbjEgIT09IG51bGwgJiYgdG9rZW4xICE9PSB2b2lkIDAgPyB0b2tlbjEgOiB0b2tlbjJ9YCwgZmFsbGJhY2tdO1xufVxuY29uc3QgbWF4RGVwdGggPSA0O1xuZnVuY3Rpb24gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50LCBkZXB0aCA9IDEpIHtcbiAgICBpbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsIGBNYXggQ1NTIHZhcmlhYmxlIGZhbGxiYWNrIGRlcHRoIGRldGVjdGVkIGluIHByb3BlcnR5IFwiJHtjdXJyZW50fVwiLiBUaGlzIG1heSBpbmRpY2F0ZSBhIGNpcmN1bGFyIGZhbGxiYWNrIGRlcGVuZGVuY3kuYCk7XG4gICAgY29uc3QgW3Rva2VuLCBmYWxsYmFja10gPSBwYXJzZUNTU1ZhcmlhYmxlKGN1cnJlbnQpO1xuICAgIC8vIE5vIENTUyB2YXJpYWJsZSBkZXRlY3RlZFxuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBBdHRlbXB0IHRvIHJlYWQgdGhpcyBDU1MgdmFyaWFibGUgb2ZmIHRoZSBlbGVtZW50XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHRva2VuKTtcbiAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgY29uc3QgdHJpbW1lZCA9IHJlc29sdmVkLnRyaW0oKTtcbiAgICAgICAgcmV0dXJuIGlzTnVtZXJpY2FsU3RyaW5nKHRyaW1tZWQpID8gcGFyc2VGbG9hdCh0cmltbWVkKSA6IHRyaW1tZWQ7XG4gICAgfVxuICAgIHJldHVybiBpc0NTU1ZhcmlhYmxlVG9rZW4oZmFsbGJhY2spXG4gICAgICAgID8gZ2V0VmFyaWFibGVWYWx1ZShmYWxsYmFjaywgZWxlbWVudCwgZGVwdGggKyAxKVxuICAgICAgICA6IGZhbGxiYWNrO1xufVxuXG5leHBvcnQgeyBnZXRWYXJpYWJsZVZhbHVlLCBwYXJzZUNTU1ZhcmlhYmxlIH07XG4iLCIvKipcbiAqIFRlc3RzIGEgcHJvdmlkZWQgdmFsdWUgYWdhaW5zdCBhIFZhbHVlVHlwZVxuICovXG5jb25zdCB0ZXN0VmFsdWVUeXBlID0gKHYpID0+ICh0eXBlKSA9PiB0eXBlLnRlc3Qodik7XG5cbmV4cG9ydCB7IHRlc3RWYWx1ZVR5cGUgfTtcbiIsIi8qKlxuICogVmFsdWVUeXBlIGZvciBcImF1dG9cIlxuICovXG5jb25zdCBhdXRvID0ge1xuICAgIHRlc3Q6ICh2KSA9PiB2ID09PSBcImF1dG9cIixcbiAgICBwYXJzZTogKHYpID0+IHYsXG59O1xuXG5leHBvcnQgeyBhdXRvIH07XG4iLCJpbXBvcnQgeyBudW1iZXIgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBweCwgcGVyY2VudCwgZGVncmVlcywgdncsIHZoIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuaW1wb3J0IHsgdGVzdFZhbHVlVHlwZSB9IGZyb20gJy4vdGVzdC5tanMnO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gJy4vdHlwZS1hdXRvLm1qcyc7XG5cbi8qKlxuICogQSBsaXN0IG9mIHZhbHVlIHR5cGVzIGNvbW1vbmx5IHVzZWQgZm9yIGRpbWVuc2lvbnNcbiAqL1xuY29uc3QgZGltZW5zaW9uVmFsdWVUeXBlcyA9IFtudW1iZXIsIHB4LCBwZXJjZW50LCBkZWdyZWVzLCB2dywgdmgsIGF1dG9dO1xuLyoqXG4gKiBUZXN0cyBhIGRpbWVuc2lvbmFsIHZhbHVlIGFnYWluc3QgdGhlIGxpc3Qgb2YgZGltZW5zaW9uIFZhbHVlVHlwZXNcbiAqL1xuY29uc3QgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9ICh2KSA9PiBkaW1lbnNpb25WYWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbmV4cG9ydCB7IGRpbWVuc2lvblZhbHVlVHlwZXMsIGZpbmREaW1lbnNpb25WYWx1ZVR5cGUgfTtcbiIsImltcG9ydCB7IGlzTm9uZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1ub25lLm1qcyc7XG5pbXBvcnQgeyBwb3NpdGlvbmFsS2V5cyB9IGZyb20gJy4uL2h0bWwvdXRpbHMva2V5cy1wb3NpdGlvbi5tanMnO1xuaW1wb3J0IHsgbWFrZU5vbmVLZXlmcmFtZXNBbmltYXRhYmxlIH0gZnJvbSAnLi4vaHRtbC91dGlscy9tYWtlLW5vbmUtYW5pbWF0YWJsZS5tanMnO1xuaW1wb3J0IHsgS2V5ZnJhbWVSZXNvbHZlciB9IGZyb20gJy4uL3V0aWxzL0tleWZyYW1lc1Jlc29sdmVyLm1qcyc7XG5pbXBvcnQgeyBnZXRWYXJpYWJsZVZhbHVlIH0gZnJvbSAnLi91dGlscy9jc3MtdmFyaWFibGVzLWNvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IGlzQ1NTVmFyaWFibGVUb2tlbiB9IGZyb20gJy4vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5pbXBvcnQgeyBpc051bU9yUHhUeXBlLCBwb3NpdGlvbmFsVmFsdWVzIH0gZnJvbSAnLi91dGlscy91bml0LWNvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUgfSBmcm9tICcuL3ZhbHVlLXR5cGVzL2RpbWVuc2lvbnMubWpzJztcblxuY2xhc3MgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIgZXh0ZW5kcyBLZXlmcmFtZVJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1bnJlc29sdmVkS2V5ZnJhbWVzLCBvbkNvbXBsZXRlLCBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCkge1xuICAgICAgICBzdXBlcih1bnJlc29sdmVkS2V5ZnJhbWVzLCBvbkNvbXBsZXRlLCBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJlYWRLZXlmcmFtZXMoKSB7XG4gICAgICAgIGNvbnN0IHsgdW5yZXNvbHZlZEtleWZyYW1lcywgZWxlbWVudCwgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN1cGVyLnJlYWRLZXlmcmFtZXMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGFueSBrZXlmcmFtZSBpcyBhIENTUyB2YXJpYWJsZSwgd2UgbmVlZCB0byBmaW5kIGl0cyB2YWx1ZSBieSBzYW1wbGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQga2V5ZnJhbWUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXlmcmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGtleWZyYW1lID0ga2V5ZnJhbWUudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChpc0NTU1ZhcmlhYmxlVG9rZW4oa2V5ZnJhbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShrZXlmcmFtZSwgZWxlbWVudC5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPSByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmFsS2V5ZnJhbWUgPSBrZXlmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzb2x2ZSBcIm5vbmVcIiB2YWx1ZXMuIFdlIGRvIHRoaXMgcG90ZW50aWFsbHkgdHdpY2UgLSBvbmNlIGJlZm9yZSBhbmQgb25jZSBhZnRlciBtZWFzdXJpbmcga2V5ZnJhbWVzLlxuICAgICAgICAgKiBUaGlzIGNvdWxkIGJlIHNlZW4gYXMgaW5lZmZpY2llbnQgYnV0IGl0J3MgYSB0cmFkZS1vZmYgdG8gYXZvaWQgbWVhc3VyZW1lbnRzIGluIG1vcmUgc2l0dWF0aW9ucywgd2hpY2hcbiAgICAgICAgICogaGF2ZSBhIGZhciBiaWdnZXIgcGVyZm9ybWFuY2UgaW1wYWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHZlTm9uZUtleWZyYW1lcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgdG8gc2VlIGlmIHVuaXQgdHlwZSBoYXMgY2hhbmdlZC4gSWYgc28gc2NoZWR1bGUgam9icyB0aGF0IHdpbGxcbiAgICAgICAgICogdGVtcG9yYXJpbHkgc2V0IHN0eWxlcyB0byB0aGUgZGVzdGluYXRpb24ga2V5ZnJhbWVzLlxuICAgICAgICAgKiBTa2lwIGlmIHdlIGhhdmUgbW9yZSB0aGFuIHR3byBrZXlmcmFtZXMgb3IgdGhpcyBpc24ndCBhIHBvc2l0aW9uYWwgdmFsdWUuXG4gICAgICAgICAqIFRPRE86IFdlIGNhbiB0aHJvdyBpZiB0aGVyZSBhcmUgbXVsdGlwbGUga2V5ZnJhbWVzIGFuZCB0aGUgdmFsdWUgdHlwZSBjaGFuZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFwb3NpdGlvbmFsS2V5cy5oYXMobmFtZSkgfHwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbb3JpZ2luLCB0YXJnZXRdID0gdW5yZXNvbHZlZEtleWZyYW1lcztcbiAgICAgICAgY29uc3Qgb3JpZ2luVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUob3JpZ2luKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0VHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodGFyZ2V0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVpdGhlciB3ZSBkb24ndCByZWNvZ25pc2UgdGhlc2UgdmFsdWUgdHlwZXMgb3Igd2UgY2FuIGFuaW1hdGUgYmV0d2VlbiB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG9yaWdpblR5cGUgPT09IHRhcmdldFR5cGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBib3RoIHZhbHVlcyBhcmUgbnVtYmVycyBvciBwaXhlbHMsIHdlIGNhbiBhbmltYXRlIGJldHdlZW4gdGhlbSBieVxuICAgICAgICAgKiBjb252ZXJ0aW5nIHRoZW0gdG8gbnVtYmVycy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpc051bU9yUHhUeXBlKG9yaWdpblR5cGUpICYmIGlzTnVtT3JQeFR5cGUodGFyZ2V0VHlwZSkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVsc2UsIHRoZSBvbmx5IHdheSB0byByZXNvbHZlIHRoaXMgaXMgYnkgbWVhc3VyaW5nIHRoZSBlbGVtZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5lZWRzTWVhc3VyZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVOb25lS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG5vbmVLZXlmcmFtZUluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNOb25lKHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgbm9uZUtleWZyYW1lSW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25lS2V5ZnJhbWVJbmRleGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbWFrZU5vbmVLZXlmcmFtZXNBbmltYXRhYmxlKHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5vbmVLZXlmcmFtZUluZGV4ZXMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVJbml0aWFsU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgdW5yZXNvbHZlZEtleWZyYW1lcywgbmFtZSB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LmN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChuYW1lID09PSBcImhlaWdodFwiKSB7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbmRlZFNjcm9sbFkgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZWFzdXJlZE9yaWdpbiA9IHBvc2l0aW9uYWxWYWx1ZXNbbmFtZV0oZWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKSwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudC5jdXJyZW50KSk7XG4gICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0gPSB0aGlzLm1lYXN1cmVkT3JpZ2luO1xuICAgICAgICAvLyBTZXQgZmluYWwga2V5IGZyYW1lIHRvIG1lYXN1cmUgYWZ0ZXIgbmV4dCByZW5kZXJcbiAgICAgICAgY29uc3QgbWVhc3VyZUtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1t1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobWVhc3VyZUtleWZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0VmFsdWUobmFtZSwgbWVhc3VyZUtleWZyYW1lKS5qdW1wKG1lYXN1cmVLZXlmcmFtZSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lYXN1cmVFbmRTdGF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIG5hbWUsIHVucmVzb2x2ZWRLZXlmcmFtZXMgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGVsZW1lbnQuZ2V0VmFsdWUobmFtZSk7XG4gICAgICAgIHZhbHVlICYmIHZhbHVlLmp1bXAodGhpcy5tZWFzdXJlZE9yaWdpbiwgZmFsc2UpO1xuICAgICAgICBjb25zdCBmaW5hbEtleWZyYW1lSW5kZXggPSB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IGZpbmFsS2V5ZnJhbWUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW2ZpbmFsS2V5ZnJhbWVJbmRleF07XG4gICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbZmluYWxLZXlmcmFtZUluZGV4XSA9IHBvc2l0aW9uYWxWYWx1ZXNbbmFtZV0oZWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKSwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudC5jdXJyZW50KSk7XG4gICAgICAgIGlmIChmaW5hbEtleWZyYW1lICE9PSBudWxsICYmIHRoaXMuZmluYWxLZXlmcmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmFsS2V5ZnJhbWUgPSBmaW5hbEtleWZyYW1lO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgdHJhbnNmb3JtIHZhbHVlcywgcmVhcHBseSB0aGVtIGJlZm9yZSB0aGUgbmV4dCByZW5kZXJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMucmVtb3ZlZFRyYW5zZm9ybXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlZFRyYW5zZm9ybXMuZm9yRWFjaCgoW3Vuc2V0VHJhbnNmb3JtTmFtZSwgdW5zZXRUcmFuc2Zvcm1WYWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC5nZXRWYWx1ZSh1bnNldFRyYW5zZm9ybU5hbWUpXG4gICAgICAgICAgICAgICAgICAgIC5zZXQodW5zZXRUcmFuc2Zvcm1WYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdmVOb25lS2V5ZnJhbWVzKCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBET01LZXlmcmFtZXNSZXNvbHZlciB9O1xuIiwiaW1wb3J0IHsgY29tcGxleCB9IGZyb20gJy4uLy4uL3ZhbHVlL3R5cGVzL2NvbXBsZXgvaW5kZXgubWpzJztcblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuaW1hdGFibGUuIEV4YW1wbGVzOlxuICpcbiAqIOKchTogMTAwLCBcIjEwMHB4XCIsIFwiI2ZmZlwiXG4gKiDinYw6IFwiYmxvY2tcIiwgXCJ1cmwoMi5qcGcpXCJcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBpc0FuaW1hdGFibGUgPSAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAvLyBJZiB0aGUgbGlzdCBvZiBrZXlzIHRhdCBtaWdodCBiZSBub24tYW5pbWF0YWJsZSBncm93cywgcmVwbGFjZSB3aXRoIFNldFxuICAgIGlmIChuYW1lID09PSBcInpJbmRleFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgaXQncyBhIG51bWJlciBvciBhIGtleWZyYW1lcyBhcnJheSwgd2UgY2FuIGFuaW1hdGUgaXQuIFdlIG1pZ2h0IGF0IHNvbWUgcG9pbnRcbiAgICAvLyBuZWVkIHRvIGRvIGEgZGVlcCBpc0FuaW1hdGFibGUgY2hlY2sgb2Yga2V5ZnJhbWVzLCBvciBsZXQgUG9wbW90aW9uIGhhbmRsZSB0aGlzLFxuICAgIC8vIGJ1dCBmb3Igbm93IGxldHMgbGVhdmUgaXQgbGlrZSB0aGlzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAvLyBJdCdzIGFuaW1hdGFibGUgaWYgd2UgaGF2ZSBhIHN0cmluZ1xuICAgICAgICAoY29tcGxleC50ZXN0KHZhbHVlKSB8fCB2YWx1ZSA9PT0gXCIwXCIpICYmIC8vIEFuZCBpdCBjb250YWlucyBudW1iZXJzIGFuZC9vciBjb2xvcnNcbiAgICAgICAgIXZhbHVlLnN0YXJ0c1dpdGgoXCJ1cmwoXCIpIC8vIFVubGVzcyBpdCBzdGFydHMgd2l0aCBcInVybChcIlxuICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZXhwb3J0IHsgaXNBbmltYXRhYmxlIH07XG4iLCJpbXBvcnQgeyBpc0dlbmVyYXRvciB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBpc0FuaW1hdGFibGUgfSBmcm9tICcuLi8uLi91dGlscy9pcy1hbmltYXRhYmxlLm1qcyc7XG5cbmZ1bmN0aW9uIGhhc0tleWZyYW1lc0NoYW5nZWQoa2V5ZnJhbWVzKSB7XG4gICAgY29uc3QgY3VycmVudCA9IGtleWZyYW1lc1swXTtcbiAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleWZyYW1lc1tpXSAhPT0gY3VycmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbkFuaW1hdGUoa2V5ZnJhbWVzLCBuYW1lLCB0eXBlLCB2ZWxvY2l0eSkge1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHdlJ3JlIGFibGUgdG8gYW5pbWF0ZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGtleWZyYW1lcyxcbiAgICAgKiBhbmQgdGhyb3cgYSB3YXJuaW5nIGlmIHdlJ3JlIGF0dGVtcHRpbmcgdG8gYW5pbWF0ZSBiZXR3ZWVuIG9uZSB0aGF0J3NcbiAgICAgKiBhbmltYXRhYmxlIGFuZCBhbm90aGVyIHRoYXQgaXNuJ3QuXG4gICAgICovXG4gICAgY29uc3Qgb3JpZ2luS2V5ZnJhbWUgPSBrZXlmcmFtZXNbMF07XG4gICAgaWYgKG9yaWdpbktleWZyYW1lID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLyoqXG4gICAgICogVGhlc2UgYXJlbid0IHRyYWRpdGlvbmFsbHkgYW5pbWF0YWJsZSBidXQgd2UgZG8gc3VwcG9ydCB0aGVtLlxuICAgICAqIEluIGZ1dHVyZSB3ZSBjb3VsZCBsb29rIGludG8gbWFraW5nIHRoaXMgbW9yZSBnZW5lcmljIG9yIHJlcGxhY2luZ1xuICAgICAqIHRoaXMgZnVuY3Rpb24gd2l0aCBtaXgoKSA9PT0gbWl4SW1tZWRpYXRlXG4gICAgICovXG4gICAgaWYgKG5hbWUgPT09IFwiZGlzcGxheVwiIHx8IG5hbWUgPT09IFwidmlzaWJpbGl0eVwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCB0YXJnZXRLZXlmcmFtZSA9IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgaXNPcmlnaW5BbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKG9yaWdpbktleWZyYW1lLCBuYW1lKTtcbiAgICBjb25zdCBpc1RhcmdldEFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUodGFyZ2V0S2V5ZnJhbWUsIG5hbWUpO1xuICAgIHdhcm5pbmcoaXNPcmlnaW5BbmltYXRhYmxlID09PSBpc1RhcmdldEFuaW1hdGFibGUsIGBZb3UgYXJlIHRyeWluZyB0byBhbmltYXRlICR7bmFtZX0gZnJvbSBcIiR7b3JpZ2luS2V5ZnJhbWV9XCIgdG8gXCIke3RhcmdldEtleWZyYW1lfVwiLiAke29yaWdpbktleWZyYW1lfSBpcyBub3QgYW4gYW5pbWF0YWJsZSB2YWx1ZSAtIHRvIGVuYWJsZSB0aGlzIGFuaW1hdGlvbiBzZXQgJHtvcmlnaW5LZXlmcmFtZX0gdG8gYSB2YWx1ZSBhbmltYXRhYmxlIHRvICR7dGFyZ2V0S2V5ZnJhbWV9IHZpYSB0aGUgXFxgc3R5bGVcXGAgcHJvcGVydHkuYCk7XG4gICAgLy8gQWx3YXlzIHNraXAgaWYgYW55IG9mIHRoZXNlIGFyZSB0cnVlXG4gICAgaWYgKCFpc09yaWdpbkFuaW1hdGFibGUgfHwgIWlzVGFyZ2V0QW5pbWF0YWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoaGFzS2V5ZnJhbWVzQ2hhbmdlZChrZXlmcmFtZXMpIHx8XG4gICAgICAgICgodHlwZSA9PT0gXCJzcHJpbmdcIiB8fCBpc0dlbmVyYXRvcih0eXBlKSkgJiYgdmVsb2NpdHkpKTtcbn1cblxuZXhwb3J0IHsgY2FuQW5pbWF0ZSB9O1xuIiwiY29uc3QgaXNOb3ROdWxsID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbDtcbmZ1bmN0aW9uIGdldEZpbmFsS2V5ZnJhbWUoa2V5ZnJhbWVzLCB7IHJlcGVhdCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiIH0sIGZpbmFsS2V5ZnJhbWUpIHtcbiAgICBjb25zdCByZXNvbHZlZEtleWZyYW1lcyA9IGtleWZyYW1lcy5maWx0ZXIoaXNOb3ROdWxsKTtcbiAgICBjb25zdCBpbmRleCA9IHJlcGVhdCAmJiByZXBlYXRUeXBlICE9PSBcImxvb3BcIiAmJiByZXBlYXQgJSAyID09PSAxXG4gICAgICAgID8gMFxuICAgICAgICA6IHJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuICFpbmRleCB8fCBmaW5hbEtleWZyYW1lID09PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXNvbHZlZEtleWZyYW1lc1tpbmRleF1cbiAgICAgICAgOiBmaW5hbEtleWZyYW1lO1xufVxuXG5leHBvcnQgeyBnZXRGaW5hbEtleWZyYW1lIH07XG4iLCJpbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi4vLi4vZnJhbWVsb29wL3N5bmMtdGltZS5tanMnO1xuaW1wb3J0IHsgZmx1c2hLZXlmcmFtZVJlc29sdmVycyB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9LZXlmcmFtZXNSZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgaW5zdGFudEFuaW1hdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWluc3RhbnQtdHJhbnNpdGlvbi1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgY2FuQW5pbWF0ZSB9IGZyb20gJy4vdXRpbHMvY2FuLWFuaW1hdGUubWpzJztcbmltcG9ydCB7IGdldEZpbmFsS2V5ZnJhbWUgfSBmcm9tICcuL3dhYXBpL3V0aWxzL2dldC1maW5hbC1rZXlmcmFtZS5tanMnO1xuXG4vKipcbiAqIE1heGltdW0gdGltZSBhbGxvd2VkIGJldHdlZW4gYW4gYW5pbWF0aW9uIGJlaW5nIGNyZWF0ZWQgYW5kIGl0IGJlaW5nXG4gKiByZXNvbHZlZCBmb3IgdXMgdG8gdXNlIHRoZSBsYXR0ZXIgYXMgdGhlIHN0YXJ0IHRpbWUuXG4gKlxuICogVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB3aGlsZSB3ZSBwcmVmZXIgdG8gXCJzdGFydFwiIGFuIGFuaW1hdGlvbiBhcyBzb29uXG4gKiBhcyBpdCdzIHRyaWdnZXJlZCwgd2UgYWxzbyB3YW50IHRvIGF2b2lkIGEgdmlzdWFsIGp1bXAgaWYgdGhlcmUncyBhIGJpZyBkZWxheVxuICogYmV0d2VlbiB0aGVzZSB0d28gbW9tZW50cy5cbiAqL1xuY29uc3QgTUFYX1JFU09MVkVfREVMQVkgPSA0MDtcbmNsYXNzIEJhc2VBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgYXV0b3BsYXkgPSB0cnVlLCBkZWxheSA9IDAsIHR5cGUgPSBcImtleWZyYW1lc1wiLCByZXBlYXQgPSAwLCByZXBlYXREZWxheSA9IDAsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiwgLi4ub3B0aW9ucyB9KSB7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiBzdG9wcGVkLiBTdG9wcGVkIGFuaW1hdGlvbnMgd29uJ3QgcmVzdGFydC5cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNBdHRlbXB0ZWRSZXNvbHZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gdGltZS5ub3coKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgYXV0b3BsYXksXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICByZXBlYXQsXG4gICAgICAgICAgICByZXBlYXREZWxheSxcbiAgICAgICAgICAgIHJlcGVhdFR5cGUsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjcmVhdGVkQXQgYW5kIHJlc29sdmVkQXQgdG8gY2FsY3VsYXRlIHRoZVxuICAgICAqIGFuaW1hdGlvbiBzdGFydFRpbWUuICpJZGVhbGx5Kiwgd2Ugd291bGQgdXNlIHRoZSBjcmVhdGVkQXQgdGltZSBhcyB0PTBcbiAgICAgKiBhcyB0aGUgZm9sbG93aW5nIGZyYW1lIHdvdWxkIHRoZW4gYmUgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBhbmltYXRpb24gaW5cbiAgICAgKiBwcm9ncmVzcywgd2hpY2ggd291bGQgZmVlbCBzbmFwcGllci5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGlmIHRoZXJlJ3MgYSBkZWxheSAobWFpbiB0aHJlYWQgd29yaykgYmV0d2VlbiB0aGUgY3JlYXRpb24gb2ZcbiAgICAgKiB0aGUgYW5pbWF0aW9uIGFuZCB0aGUgZmlyc3QgY29tbWl0ZWQgZnJhbWUsIHdlIHByZWZlciB0byB1c2UgcmVzb2x2ZWRBdFxuICAgICAqIHRvIGF2b2lkIGEgc3VkZGVuIGp1bXAgaW50byB0aGUgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGNhbGNTdGFydFRpbWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZEF0IC0gdGhpcy5jcmVhdGVkQXQgPiBNQVhfUkVTT0xWRV9ERUxBWVxuICAgICAgICAgICAgPyB0aGlzLnJlc29sdmVkQXRcbiAgICAgICAgICAgIDogdGhpcy5jcmVhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciByZXNvbHZlZCBkYXRhLiBJZiBrZXlmcmFtZXMgYXJlIG5vdCB5ZXQgcmVzb2x2ZWQsIGFjY2Vzc2luZ1xuICAgICAqIHRoaXMucmVzb2x2ZWQgd2lsbCBzeW5jaHJvbm91c2x5IGZsdXNoIGFsbCBwZW5kaW5nIGtleWZyYW1lIHJlc29sdmVycy5cbiAgICAgKiBUaGlzIGlzIGEgZGVvcHRpbWlzYXRpb24sIGJ1dCBhdCBpdHMgd29yc3Qgc3RpbGwgYmF0Y2hlcyByZWFkL3dyaXRlcy5cbiAgICAgKi9cbiAgICBnZXQgcmVzb2x2ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQgJiYgIXRoaXMuaGFzQXR0ZW1wdGVkUmVzb2x2ZSkge1xuICAgICAgICAgICAgZmx1c2hLZXlmcmFtZVJlc29sdmVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGtleWZyYW1lcyByZXNvbHZlciBjb21wbGV0ZXMuIFRoaXMgbWV0aG9kXG4gICAgICogd2lsbCBjaGVjayBpZiBpdHMgcG9zc2libGUgdG8gcnVuIHRoZSBhbmltYXRpb24gYW5kLCBpZiBub3QsIHNraXAgaXQuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGNhbGwgaW5pdFBsYXliYWNrIG9uIHRoZSBpbXBsZW1lbnRpbmcgY2xhc3MuXG4gICAgICovXG4gICAgb25LZXlmcmFtZXNSZXNvbHZlZChrZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEF0ID0gdGltZS5ub3coKTtcbiAgICAgICAgdGhpcy5oYXNBdHRlbXB0ZWRSZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCB0eXBlLCB2ZWxvY2l0eSwgZGVsYXksIG9uQ29tcGxldGUsIG9uVXBkYXRlLCBpc0dlbmVyYXRvciwgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlIGNhbid0IGFuaW1hdGUgdGhpcyB2YWx1ZSB3aXRoIHRoZSByZXNvbHZlZCBrZXlmcmFtZXNcbiAgICAgICAgICogdGhlbiB3ZSBzaG91bGQgY29tcGxldGUgaXQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWlzR2VuZXJhdG9yICYmICFjYW5BbmltYXRlKGtleWZyYW1lcywgbmFtZSwgdHlwZSwgdmVsb2NpdHkpKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCB8fCAhZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZShnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgdGhpcy5vcHRpb25zLCBmaW5hbEtleWZyYW1lKSk7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluaXNoIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBbmltYXRpb24gPSB0aGlzLmluaXRQbGF5YmFjayhrZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZWRBbmltYXRpb24gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IHtcbiAgICAgICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWUsXG4gICAgICAgICAgICAuLi5yZXNvbHZlZEFuaW1hdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvc3RSZXNvbHZlZCgpO1xuICAgIH1cbiAgICBvblBvc3RSZXNvbHZlZCgpIHsgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgcmV0dXJuZWQgYW5pbWF0aW9uIHRvIGJlIGF3YWl0ZWQgb3IgcHJvbWlzZS1jaGFpbmVkLiBDdXJyZW50bHlcbiAgICAgKiByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMgYXQgYWxsIGJ1dCBpbiBhIGZ1dHVyZSB1cGRhdGUgY291bGQvc2hvdWxkXG4gICAgICogcmVqZWN0IGlmIGl0cyBjYW5jZWxzLlxuICAgICAqL1xuICAgIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgICBmbGF0dGVuKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lYXNlID0gXCJsaW5lYXJcIjtcbiAgICB9XG4gICAgdXBkYXRlRmluaXNoZWRQcm9taXNlKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNlQW5pbWF0aW9uIH07XG4iLCIvKlxuICBWYWx1ZSBpbiByYW5nZSBmcm9tIHByb2dyZXNzXG5cbiAgR2l2ZW4gYSBsb3dlciBsaW1pdCBhbmQgYW4gdXBwZXIgbGltaXQsIHdlIHJldHVybiB0aGUgdmFsdWUgd2l0aGluXG4gIHRoYXQgcmFuZ2UgYXMgZXhwcmVzc2VkIGJ5IHByb2dyZXNzICh1c3VhbGx5IGEgbnVtYmVyIGZyb20gMCB0byAxKVxuXG4gIFNvIHByb2dyZXNzID0gMC41IHdvdWxkIGNoYW5nZVxuXG4gIGZyb20gLS0tLS0tLS0gdG9cblxuICB0b1xuXG4gIGZyb20gLS0tLSB0b1xuXG4gIEUuZy4gZnJvbSA9IDEwLCB0byA9IDIwLCBwcm9ncmVzcyA9IDAuNSA9PiAxNVxuXG4gIEBwYXJhbSBbbnVtYmVyXTogTG93ZXIgbGltaXQgb2YgcmFuZ2VcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdCBvZiByYW5nZVxuICBAcGFyYW0gW251bWJlcl06IFRoZSBwcm9ncmVzcyBiZXR3ZWVuIGxvd2VyIGFuZCB1cHBlciBsaW1pdHMgZXhwcmVzc2VkIDAtMVxuICBAcmV0dXJuIFtudW1iZXJdOiBWYWx1ZSBhcyBjYWxjdWxhdGVkIGZyb20gcHJvZ3Jlc3Mgd2l0aGluIHJhbmdlIChub3QgbGltaXRlZCB3aXRoaW4gcmFuZ2UpXG4qL1xuY29uc3QgbWl4TnVtYmVyID0gKGZyb20sIHRvLCBwcm9ncmVzcykgPT4ge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBwcm9ncmVzcztcbn07XG5cbmV4cG9ydCB7IG1peE51bWJlciB9O1xuIiwiLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qYWNrc29uLzUzMTEyNTZcbmZ1bmN0aW9uIGh1ZVRvUmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpXG4gICAgICAgIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhIH0pIHtcbiAgICBodWUgLz0gMzYwO1xuICAgIHNhdHVyYXRpb24gLz0gMTAwO1xuICAgIGxpZ2h0bmVzcyAvPSAxMDA7XG4gICAgbGV0IHJlZCA9IDA7XG4gICAgbGV0IGdyZWVuID0gMDtcbiAgICBsZXQgYmx1ZSA9IDA7XG4gICAgaWYgKCFzYXR1cmF0aW9uKSB7XG4gICAgICAgIHJlZCA9IGdyZWVuID0gYmx1ZSA9IGxpZ2h0bmVzcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHEgPSBsaWdodG5lc3MgPCAwLjVcbiAgICAgICAgICAgID8gbGlnaHRuZXNzICogKDEgKyBzYXR1cmF0aW9uKVxuICAgICAgICAgICAgOiBsaWdodG5lc3MgKyBzYXR1cmF0aW9uIC0gbGlnaHRuZXNzICogc2F0dXJhdGlvbjtcbiAgICAgICAgY29uc3QgcCA9IDIgKiBsaWdodG5lc3MgLSBxO1xuICAgICAgICByZWQgPSBodWVUb1JnYihwLCBxLCBodWUgKyAxIC8gMyk7XG4gICAgICAgIGdyZWVuID0gaHVlVG9SZ2IocCwgcSwgaHVlKTtcbiAgICAgICAgYmx1ZSA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSAtIDEgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiBNYXRoLnJvdW5kKHJlZCAqIDI1NSksXG4gICAgICAgIGdyZWVuOiBNYXRoLnJvdW5kKGdyZWVuICogMjU1KSxcbiAgICAgICAgYmx1ZTogTWF0aC5yb3VuZChibHVlICogMjU1KSxcbiAgICAgICAgYWxwaGEsXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgaHNsYVRvUmdiYSB9O1xuIiwiZnVuY3Rpb24gbWl4SW1tZWRpYXRlKGEsIGIpIHtcbiAgICByZXR1cm4gKHApID0+IChwID4gMCA/IGIgOiBhKTtcbn1cblxuZXhwb3J0IHsgbWl4SW1tZWRpYXRlIH07XG4iLCJpbXBvcnQgeyBtaXhOdW1iZXIgfSBmcm9tICcuL251bWJlci5tanMnO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBoc2xhVG9SZ2JhIH0gZnJvbSAnLi4vaHNsYS10by1yZ2JhLm1qcyc7XG5pbXBvcnQgeyBoZXggfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9jb2xvci9oZXgubWpzJztcbmltcG9ydCB7IHJnYmEgfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9jb2xvci9yZ2JhLm1qcyc7XG5pbXBvcnQgeyBoc2xhIH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvY29sb3IvaHNsYS5tanMnO1xuaW1wb3J0IHsgbWl4SW1tZWRpYXRlIH0gZnJvbSAnLi9pbW1lZGlhdGUubWpzJztcblxuLy8gTGluZWFyIGNvbG9yIHNwYWNlIGJsZW5kaW5nXG4vLyBFeHBsYWluZWQgaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1MS25xRUNjZzZHd1xuLy8gRGVtb25zdHJhdGVkIGh0dHA6Ly9jb2RlcGVuLmlvL29zdWJsYWtlL3Blbi94R1ZWYU5cbmNvbnN0IG1peExpbmVhckNvbG9yID0gKGZyb20sIHRvLCB2KSA9PiB7XG4gICAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgICBjb25zdCBleHBvID0gdiAqICh0byAqIHRvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG87XG4gICAgcmV0dXJuIGV4cG8gPCAwID8gMCA6IE1hdGguc3FydChleHBvKTtcbn07XG5jb25zdCBjb2xvclR5cGVzID0gW2hleCwgcmdiYSwgaHNsYV07XG5jb25zdCBnZXRDb2xvclR5cGUgPSAodikgPT4gY29sb3JUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLnRlc3QodikpO1xuZnVuY3Rpb24gYXNSR0JBKGNvbG9yKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldENvbG9yVHlwZShjb2xvcik7XG4gICAgd2FybmluZyhCb29sZWFuKHR5cGUpLCBgJyR7Y29sb3J9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gKTtcbiAgICBpZiAoIUJvb2xlYW4odHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbW9kZWwgPSB0eXBlLnBhcnNlKGNvbG9yKTtcbiAgICBpZiAodHlwZSA9PT0gaHNsYSkge1xuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGNhc3QgLSBuZWVkZWQgc2luY2UgTW90aW9uJ3Mgc3RyaWN0ZXIgdHlwaW5nXG4gICAgICAgIG1vZGVsID0gaHNsYVRvUmdiYShtb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn1cbmNvbnN0IG1peENvbG9yID0gKGZyb20sIHRvKSA9PiB7XG4gICAgY29uc3QgZnJvbVJHQkEgPSBhc1JHQkEoZnJvbSk7XG4gICAgY29uc3QgdG9SR0JBID0gYXNSR0JBKHRvKTtcbiAgICBpZiAoIWZyb21SR0JBIHx8ICF0b1JHQkEpIHtcbiAgICAgICAgcmV0dXJuIG1peEltbWVkaWF0ZShmcm9tLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGJsZW5kZWQgPSB7IC4uLmZyb21SR0JBIH07XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGJsZW5kZWQucmVkID0gbWl4TGluZWFyQ29sb3IoZnJvbVJHQkEucmVkLCB0b1JHQkEucmVkLCB2KTtcbiAgICAgICAgYmxlbmRlZC5ncmVlbiA9IG1peExpbmVhckNvbG9yKGZyb21SR0JBLmdyZWVuLCB0b1JHQkEuZ3JlZW4sIHYpO1xuICAgICAgICBibGVuZGVkLmJsdWUgPSBtaXhMaW5lYXJDb2xvcihmcm9tUkdCQS5ibHVlLCB0b1JHQkEuYmx1ZSwgdik7XG4gICAgICAgIGJsZW5kZWQuYWxwaGEgPSBtaXhOdW1iZXIoZnJvbVJHQkEuYWxwaGEsIHRvUkdCQS5hbHBoYSwgdik7XG4gICAgICAgIHJldHVybiByZ2JhLnRyYW5zZm9ybShibGVuZGVkKTtcbiAgICB9O1xufTtcblxuZXhwb3J0IHsgbWl4Q29sb3IsIG1peExpbmVhckNvbG9yIH07XG4iLCIvKipcbiAqIFBpcGVcbiAqIENvbXBvc2Ugb3RoZXIgdHJhbnNmb3JtZXJzIHRvIHJ1biBsaW5lYXJpbHlcbiAqIHBpcGUobWluKDIwKSwgbWF4KDQwKSlcbiAqIEBwYXJhbSAgey4uLmZ1bmN0aW9uc30gdHJhbnNmb3JtZXJzXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuY29uc3QgY29tYmluZUZ1bmN0aW9ucyA9IChhLCBiKSA9PiAodikgPT4gYihhKHYpKTtcbmNvbnN0IHBpcGUgPSAoLi4udHJhbnNmb3JtZXJzKSA9PiB0cmFuc2Zvcm1lcnMucmVkdWNlKGNvbWJpbmVGdW5jdGlvbnMpO1xuXG5leHBvcnQgeyBwaXBlIH07XG4iLCJjb25zdCBpbnZpc2libGVWYWx1ZXMgPSBuZXcgU2V0KFtcIm5vbmVcIiwgXCJoaWRkZW5cIl0pO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwcm92aWRlZCBhIHByb2dyZXNzIHZhbHVlIGJldHdlZW4gMCBhbmQgMSxcbiAqIHdpbGwgcmV0dXJuIHRoZSBcIm5vbmVcIiBvciBcImhpZGRlblwiIHN0cmluZyBvbmx5IHdoZW4gdGhlIHByb2dyZXNzIGlzIHRoYXQgb2ZcbiAqIHRoZSBvcmlnaW4gb3IgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBtaXhWaXNpYmlsaXR5KG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgaWYgKGludmlzaWJsZVZhbHVlcy5oYXMob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gKHApID0+IChwIDw9IDAgPyBvcmlnaW4gOiB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChwKSA9PiAocCA+PSAxID8gdGFyZ2V0IDogb3JpZ2luKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGludmlzaWJsZVZhbHVlcywgbWl4VmlzaWJpbGl0eSB9O1xuIiwiaW1wb3J0IHsgbWl4TnVtYmVyIGFzIG1peE51bWJlciQxIH0gZnJvbSAnLi9udW1iZXIubWpzJztcbmltcG9ydCB7IG1peENvbG9yIH0gZnJvbSAnLi9jb2xvci5tanMnO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJy4uL3BpcGUubWpzJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9jb2xvci9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29tcGxleCwgYW5hbHlzZUNvbXBsZXhWYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3R5cGVzL2NvbXBsZXgvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzQ1NTVmFyaWFibGVUb2tlbiB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5pbXBvcnQgeyBpbnZpc2libGVWYWx1ZXMsIG1peFZpc2liaWxpdHkgfSBmcm9tICcuL3Zpc2liaWxpdHkubWpzJztcbmltcG9ydCB7IG1peEltbWVkaWF0ZSB9IGZyb20gJy4vaW1tZWRpYXRlLm1qcyc7XG5cbmZ1bmN0aW9uIG1peE51bWJlcihhLCBiKSB7XG4gICAgcmV0dXJuIChwKSA9PiBtaXhOdW1iZXIkMShhLCBiLCBwKTtcbn1cbmZ1bmN0aW9uIGdldE1peGVyKGEpIHtcbiAgICBpZiAodHlwZW9mIGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG1peE51bWJlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ1NTVmFyaWFibGVUb2tlbihhKVxuICAgICAgICAgICAgPyBtaXhJbW1lZGlhdGVcbiAgICAgICAgICAgIDogY29sb3IudGVzdChhKVxuICAgICAgICAgICAgICAgID8gbWl4Q29sb3JcbiAgICAgICAgICAgICAgICA6IG1peENvbXBsZXg7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgcmV0dXJuIG1peEFycmF5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gY29sb3IudGVzdChhKSA/IG1peENvbG9yIDogbWl4T2JqZWN0O1xuICAgIH1cbiAgICByZXR1cm4gbWl4SW1tZWRpYXRlO1xufVxuZnVuY3Rpb24gbWl4QXJyYXkoYSwgYikge1xuICAgIGNvbnN0IG91dHB1dCA9IFsuLi5hXTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBvdXRwdXQubGVuZ3RoO1xuICAgIGNvbnN0IGJsZW5kVmFsdWUgPSBhLm1hcCgodiwgaSkgPT4gZ2V0TWl4ZXIodikodiwgYltpXSkpO1xuICAgIHJldHVybiAocCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRbaV0gPSBibGVuZFZhbHVlW2ldKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1peE9iamVjdChhLCBiKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0geyAuLi5hLCAuLi5iIH07XG4gICAgY29uc3QgYmxlbmRWYWx1ZSA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIG91dHB1dCkge1xuICAgICAgICBpZiAoYVtrZXldICE9PSB1bmRlZmluZWQgJiYgYltrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJsZW5kVmFsdWVba2V5XSA9IGdldE1peGVyKGFba2V5XSkoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZFZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IGJsZW5kVmFsdWVba2V5XSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXRjaE9yZGVyKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9yZGVyZWRPcmlnaW4gPSBbXTtcbiAgICBjb25zdCBwb2ludGVycyA9IHsgY29sb3I6IDAsIHZhcjogMCwgbnVtYmVyOiAwIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQudHlwZXNbaV07XG4gICAgICAgIGNvbnN0IG9yaWdpbkluZGV4ID0gb3JpZ2luLmluZGV4ZXNbdHlwZV1bcG9pbnRlcnNbdHlwZV1dO1xuICAgICAgICBjb25zdCBvcmlnaW5WYWx1ZSA9IChfYSA9IG9yaWdpbi52YWx1ZXNbb3JpZ2luSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBvcmRlcmVkT3JpZ2luW2ldID0gb3JpZ2luVmFsdWU7XG4gICAgICAgIHBvaW50ZXJzW3R5cGVdKys7XG4gICAgfVxuICAgIHJldHVybiBvcmRlcmVkT3JpZ2luO1xufVxuY29uc3QgbWl4Q29tcGxleCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcih0YXJnZXQpO1xuICAgIGNvbnN0IG9yaWdpblN0YXRzID0gYW5hbHlzZUNvbXBsZXhWYWx1ZShvcmlnaW4pO1xuICAgIGNvbnN0IHRhcmdldFN0YXRzID0gYW5hbHlzZUNvbXBsZXhWYWx1ZSh0YXJnZXQpO1xuICAgIGNvbnN0IGNhbkludGVycG9sYXRlID0gb3JpZ2luU3RhdHMuaW5kZXhlcy52YXIubGVuZ3RoID09PSB0YXJnZXRTdGF0cy5pbmRleGVzLnZhci5sZW5ndGggJiZcbiAgICAgICAgb3JpZ2luU3RhdHMuaW5kZXhlcy5jb2xvci5sZW5ndGggPT09IHRhcmdldFN0YXRzLmluZGV4ZXMuY29sb3IubGVuZ3RoICYmXG4gICAgICAgIG9yaWdpblN0YXRzLmluZGV4ZXMubnVtYmVyLmxlbmd0aCA+PSB0YXJnZXRTdGF0cy5pbmRleGVzLm51bWJlci5sZW5ndGg7XG4gICAgaWYgKGNhbkludGVycG9sYXRlKSB7XG4gICAgICAgIGlmICgoaW52aXNpYmxlVmFsdWVzLmhhcyhvcmlnaW4pICYmXG4gICAgICAgICAgICAhdGFyZ2V0U3RhdHMudmFsdWVzLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChpbnZpc2libGVWYWx1ZXMuaGFzKHRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAhb3JpZ2luU3RhdHMudmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhWaXNpYmlsaXR5KG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZShtaXhBcnJheShtYXRjaE9yZGVyKG9yaWdpblN0YXRzLCB0YXJnZXRTdGF0cyksIHRhcmdldFN0YXRzLnZhbHVlcyksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHdhcm5pbmcodHJ1ZSwgYENvbXBsZXggdmFsdWVzICcke29yaWdpbn0nIGFuZCAnJHt0YXJnZXR9JyB0b28gZGlmZmVyZW50IHRvIG1peC4gRW5zdXJlIGFsbCBjb2xvcnMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsIGFuZCB0aGF0IGVhY2ggY29udGFpbnMgdGhlIHNhbWUgcXVhbnRpdHkgb2YgbnVtYmVyIGFuZCBjb2xvciB2YWx1ZXMuIEZhbGxpbmcgYmFjayB0byBpbnN0YW50IHRyYW5zaXRpb24uYCk7XG4gICAgICAgIHJldHVybiBtaXhJbW1lZGlhdGUob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGdldE1peGVyLCBtaXhBcnJheSwgbWl4Q29tcGxleCwgbWl4T2JqZWN0IH07XG4iLCJpbXBvcnQgeyBnZXRNaXhlciB9IGZyb20gJy4vY29tcGxleC5tanMnO1xuaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi9udW1iZXIubWpzJztcblxuZnVuY3Rpb24gbWl4KGZyb20sIHRvLCBwKSB7XG4gICAgaWYgKHR5cGVvZiBmcm9tID09PSBcIm51bWJlclwiICYmXG4gICAgICAgIHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgcCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbWl4TnVtYmVyKGZyb20sIHRvLCBwKTtcbiAgICB9XG4gICAgY29uc3QgbWl4ZXIgPSBnZXRNaXhlcihmcm9tKTtcbiAgICByZXR1cm4gbWl4ZXIoZnJvbSwgdG8pO1xufVxuXG5leHBvcnQgeyBtaXggfTtcbiIsImltcG9ydCB7IHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanMnO1xuXG5jb25zdCB2ZWxvY2l0eVNhbXBsZUR1cmF0aW9uID0gNTsgLy8gbXNcbmZ1bmN0aW9uIGNhbGNHZW5lcmF0b3JWZWxvY2l0eShyZXNvbHZlVmFsdWUsIHQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBwcmV2VCA9IE1hdGgubWF4KHQgLSB2ZWxvY2l0eVNhbXBsZUR1cmF0aW9uLCAwKTtcbiAgICByZXR1cm4gdmVsb2NpdHlQZXJTZWNvbmQoY3VycmVudCAtIHJlc29sdmVWYWx1ZShwcmV2VCksIHQgLSBwcmV2VCk7XG59XG5cbmV4cG9ydCB7IGNhbGNHZW5lcmF0b3JWZWxvY2l0eSB9O1xuIiwiY29uc3Qgc3ByaW5nRGVmYXVsdHMgPSB7XG4gICAgLy8gRGVmYXVsdCBzcHJpbmcgcGh5c2ljc1xuICAgIHN0aWZmbmVzczogMTAwLFxuICAgIGRhbXBpbmc6IDEwLFxuICAgIG1hc3M6IDEuMCxcbiAgICB2ZWxvY2l0eTogMC4wLFxuICAgIC8vIERlZmF1bHQgZHVyYXRpb24vYm91bmNlLWJhc2VkIG9wdGlvbnNcbiAgICBkdXJhdGlvbjogODAwLCAvLyBpbiBtc1xuICAgIGJvdW5jZTogMC4zLFxuICAgIHZpc3VhbER1cmF0aW9uOiAwLjMsIC8vIGluIHNlY29uZHNcbiAgICAvLyBSZXN0IHRocmVzaG9sZHNcbiAgICByZXN0U3BlZWQ6IHtcbiAgICAgICAgZ3JhbnVsYXI6IDAuMDEsXG4gICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgfSxcbiAgICByZXN0RGVsdGE6IHtcbiAgICAgICAgZ3JhbnVsYXI6IDAuMDA1LFxuICAgICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbiAgICAvLyBMaW1pdHNcbiAgICBtaW5EdXJhdGlvbjogMC4wMSwgLy8gaW4gc2Vjb25kc1xuICAgIG1heER1cmF0aW9uOiAxMC4wLCAvLyBpbiBzZWNvbmRzXG4gICAgbWluRGFtcGluZzogMC4wNSxcbiAgICBtYXhEYW1waW5nOiAxLFxufTtcblxuZXhwb3J0IHsgc3ByaW5nRGVmYXVsdHMgfTtcbiIsImltcG9ydCB7IHdhcm5pbmcsIHNlY29uZHNUb01pbGxpc2Vjb25kcywgbWlsbGlzZWNvbmRzVG9TZWNvbmRzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2xhbXAubWpzJztcbmltcG9ydCB7IHNwcmluZ0RlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5tanMnO1xuXG5jb25zdCBzYWZlTWluID0gMC4wMDE7XG5mdW5jdGlvbiBmaW5kU3ByaW5nKHsgZHVyYXRpb24gPSBzcHJpbmdEZWZhdWx0cy5kdXJhdGlvbiwgYm91bmNlID0gc3ByaW5nRGVmYXVsdHMuYm91bmNlLCB2ZWxvY2l0eSA9IHNwcmluZ0RlZmF1bHRzLnZlbG9jaXR5LCBtYXNzID0gc3ByaW5nRGVmYXVsdHMubWFzcywgfSkge1xuICAgIGxldCBlbnZlbG9wZTtcbiAgICBsZXQgZGVyaXZhdGl2ZTtcbiAgICB3YXJuaW5nKGR1cmF0aW9uIDw9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhzcHJpbmdEZWZhdWx0cy5tYXhEdXJhdGlvbiksIFwiU3ByaW5nIGR1cmF0aW9uIG11c3QgYmUgMTAgc2Vjb25kcyBvciBsZXNzXCIpO1xuICAgIGxldCBkYW1waW5nUmF0aW8gPSAxIC0gYm91bmNlO1xuICAgIC8qKlxuICAgICAqIFJlc3RyaWN0IGRhbXBpbmdSYXRpbyBhbmQgZHVyYXRpb24gdG8gd2l0aGluIGFjY2VwdGFibGUgcmFuZ2VzLlxuICAgICAqL1xuICAgIGRhbXBpbmdSYXRpbyA9IGNsYW1wKHNwcmluZ0RlZmF1bHRzLm1pbkRhbXBpbmcsIHNwcmluZ0RlZmF1bHRzLm1heERhbXBpbmcsIGRhbXBpbmdSYXRpbyk7XG4gICAgZHVyYXRpb24gPSBjbGFtcChzcHJpbmdEZWZhdWx0cy5taW5EdXJhdGlvbiwgc3ByaW5nRGVmYXVsdHMubWF4RHVyYXRpb24sIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhkdXJhdGlvbikpO1xuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmRlcmRhbXBlZCBzcHJpbmdcbiAgICAgICAgICovXG4gICAgICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgYSA9IGV4cG9uZW50aWFsRGVjYXkgLSB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU1pbiAtIChhIC8gYikgKiBjO1xuICAgICAgICB9O1xuICAgICAgICBkZXJpdmF0aXZlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlbHRhICogdmVsb2NpdHkgKyB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBNYXRoLnBvdyhkYW1waW5nUmF0aW8sIDIpICogTWF0aC5wb3codW5kYW1wZWRGcmVxLCAyKSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgZiA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICAgICAgICBjb25zdCBnID0gY2FsY0FuZ3VsYXJGcmVxKE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMiksIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPSAtZW52ZWxvcGUodW5kYW1wZWRGcmVxKSArIHNhZmVNaW4gPiAwID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIChmYWN0b3IgKiAoKGQgLSBlKSAqIGYpKSAvIGc7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JpdGljYWxseS1kYW1wZWQgc3ByaW5nXG4gICAgICAgICAqL1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxICogZHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYiA9ICh1bmRhbXBlZEZyZXEgLSB2ZWxvY2l0eSkgKiBkdXJhdGlvbiArIDE7XG4gICAgICAgICAgICByZXR1cm4gLXNhZmVNaW4gKyBhICogYjtcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxICogZHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYiA9ICh2ZWxvY2l0eSAtIHVuZGFtcGVkRnJlcSkgKiAoZHVyYXRpb24gKiBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxHdWVzcyA9IDUgLyBkdXJhdGlvbjtcbiAgICBjb25zdCB1bmRhbXBlZEZyZXEgPSBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcyk7XG4gICAgZHVyYXRpb24gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZHVyYXRpb24pO1xuICAgIGlmIChpc05hTih1bmRhbXBlZEZyZXEpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGlmZm5lc3M6IHNwcmluZ0RlZmF1bHRzLnN0aWZmbmVzcyxcbiAgICAgICAgICAgIGRhbXBpbmc6IHNwcmluZ0RlZmF1bHRzLmRhbXBpbmcsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0aWZmbmVzcyA9IE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBtYXNzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICAgICAgZGFtcGluZzogZGFtcGluZ1JhdGlvICogMiAqIE1hdGguc3FydChtYXNzICogc3RpZmZuZXNzKSxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IHJvb3RJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcykge1xuICAgIGxldCByZXN1bHQgPSBpbml0aWFsR3Vlc3M7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb290SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAtIGVudmVsb3BlKHJlc3VsdCkgLyBkZXJpdmF0aXZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pIHtcbiAgICByZXR1cm4gdW5kYW1wZWRGcmVxICogTWF0aC5zcXJ0KDEgLSBkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8pO1xufVxuXG5leHBvcnQgeyBjYWxjQW5ndWxhckZyZXEsIGZpbmRTcHJpbmcgfTtcbiIsImltcG9ydCB7IGNhbGNHZW5lcmF0b3JEdXJhdGlvbiwgbWF4R2VuZXJhdG9yRHVyYXRpb24sIGdlbmVyYXRlTGluZWFyRWFzaW5nIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBtaWxsaXNlY29uZHNUb1NlY29uZHMsIHNlY29uZHNUb01pbGxpc2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NsYW1wLm1qcyc7XG5pbXBvcnQgeyBjYWxjR2VuZXJhdG9yVmVsb2NpdHkgfSBmcm9tICcuLi91dGlscy92ZWxvY2l0eS5tanMnO1xuaW1wb3J0IHsgc3ByaW5nRGVmYXVsdHMgfSBmcm9tICcuL2RlZmF1bHRzLm1qcyc7XG5pbXBvcnQgeyBmaW5kU3ByaW5nLCBjYWxjQW5ndWxhckZyZXEgfSBmcm9tICcuL2ZpbmQubWpzJztcblxuY29uc3QgZHVyYXRpb25LZXlzID0gW1wiZHVyYXRpb25cIiwgXCJib3VuY2VcIl07XG5jb25zdCBwaHlzaWNzS2V5cyA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCJdO1xuZnVuY3Rpb24gaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5zb21lKChrZXkpID0+IG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFNwcmluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGxldCBzcHJpbmdPcHRpb25zID0ge1xuICAgICAgICB2ZWxvY2l0eTogc3ByaW5nRGVmYXVsdHMudmVsb2NpdHksXG4gICAgICAgIHN0aWZmbmVzczogc3ByaW5nRGVmYXVsdHMuc3RpZmZuZXNzLFxuICAgICAgICBkYW1waW5nOiBzcHJpbmdEZWZhdWx0cy5kYW1waW5nLFxuICAgICAgICBtYXNzOiBzcHJpbmdEZWZhdWx0cy5tYXNzLFxuICAgICAgICBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIHN0aWZmbmVzcy9kYW1waW5nL21hc3Mgb3ZlcnJpZGVzIGR1cmF0aW9uL2JvdW5jZVxuICAgIGlmICghaXNTcHJpbmdUeXBlKG9wdGlvbnMsIHBoeXNpY3NLZXlzKSAmJlxuICAgICAgICBpc1NwcmluZ1R5cGUob3B0aW9ucywgZHVyYXRpb25LZXlzKSkge1xuICAgICAgICBpZiAob3B0aW9ucy52aXN1YWxEdXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdmlzdWFsRHVyYXRpb24gPSBvcHRpb25zLnZpc3VhbER1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9ICgyICogTWF0aC5QSSkgLyAodmlzdWFsRHVyYXRpb24gKiAxLjIpO1xuICAgICAgICAgICAgY29uc3Qgc3RpZmZuZXNzID0gcm9vdCAqIHJvb3Q7XG4gICAgICAgICAgICBjb25zdCBkYW1waW5nID0gMiAqXG4gICAgICAgICAgICAgICAgY2xhbXAoMC4wNSwgMSwgMSAtIChvcHRpb25zLmJvdW5jZSB8fCAwKSkgKlxuICAgICAgICAgICAgICAgIE1hdGguc3FydChzdGlmZm5lc3MpO1xuICAgICAgICAgICAgc3ByaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi5zcHJpbmdPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1hc3M6IHNwcmluZ0RlZmF1bHRzLm1hc3MsXG4gICAgICAgICAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgIGRhbXBpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVyaXZlZCA9IGZpbmRTcHJpbmcob3B0aW9ucyk7XG4gICAgICAgICAgICBzcHJpbmdPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnNwcmluZ09wdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4uZGVyaXZlZCxcbiAgICAgICAgICAgICAgICBtYXNzOiBzcHJpbmdEZWZhdWx0cy5tYXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNwcmluZ09wdGlvbnMuaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwcmluZ09wdGlvbnM7XG59XG5mdW5jdGlvbiBzcHJpbmcob3B0aW9uc09yVmlzdWFsRHVyYXRpb24gPSBzcHJpbmdEZWZhdWx0cy52aXN1YWxEdXJhdGlvbiwgYm91bmNlID0gc3ByaW5nRGVmYXVsdHMuYm91bmNlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JWaXN1YWxEdXJhdGlvbiAhPT0gXCJvYmplY3RcIlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHZpc3VhbER1cmF0aW9uOiBvcHRpb25zT3JWaXN1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIGtleWZyYW1lczogWzAsIDFdLFxuICAgICAgICAgICAgYm91bmNlLFxuICAgICAgICB9XG4gICAgICAgIDogb3B0aW9uc09yVmlzdWFsRHVyYXRpb247XG4gICAgbGV0IHsgcmVzdFNwZWVkLCByZXN0RGVsdGEgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb3JpZ2luID0gb3B0aW9ucy5rZXlmcmFtZXNbMF07XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5rZXlmcmFtZXNbb3B0aW9ucy5rZXlmcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgSXRlcmF0b3Itc3BlYyByZXR1cm4gdmFsdWUuIFdlIGVuc3VyZSBpdCdzIG11dGFibGUgcmF0aGVyIHRoYW4gdXNpbmcgYSBnZW5lcmF0b3JcbiAgICAgKiB0byByZWR1Y2UgR0MgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvcmlnaW4gfTtcbiAgICBjb25zdCB7IHN0aWZmbmVzcywgZGFtcGluZywgbWFzcywgZHVyYXRpb24sIHZlbG9jaXR5LCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uLCB9ID0gZ2V0U3ByaW5nT3B0aW9ucyh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHZlbG9jaXR5OiAtbWlsbGlzZWNvbmRzVG9TZWNvbmRzKG9wdGlvbnMudmVsb2NpdHkgfHwgMCksXG4gICAgfSk7XG4gICAgY29uc3QgaW5pdGlhbFZlbG9jaXR5ID0gdmVsb2NpdHkgfHwgMC4wO1xuICAgIGNvbnN0IGRhbXBpbmdSYXRpbyA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gICAgY29uc3QgaW5pdGlhbERlbHRhID0gdGFyZ2V0IC0gb3JpZ2luO1xuICAgIGNvbnN0IHVuZGFtcGVkQW5ndWxhckZyZXEgPSBtaWxsaXNlY29uZHNUb1NlY29uZHMoTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSB3b3JraW5nIG9uIGEgZ3JhbnVsYXIgc2NhbGUsIHVzZSBzbWFsbGVyIGRlZmF1bHRzIGZvciBkZXRlcm1pbmluZ1xuICAgICAqIHdoZW4gdGhlIHNwcmluZyBpcyBmaW5pc2hlZC5cbiAgICAgKlxuICAgICAqIFRoZXNlIGRlZmF1bHRzIGhhdmUgYmVlbiBzZWxlY3RlZCBlbXByaWNhbGx5IGJhc2VkIG9uIHdoYXQgc3RyaWtlcyBhIGdvb2RcbiAgICAgKiByYXRpbyBiZXR3ZWVuIGZlZWxpbmcgZ29vZCBhbmQgZmluaXNoaW5nIGFzIHNvb24gYXMgY2hhbmdlcyBhcmUgaW1wZXJjZXB0aWJsZS5cbiAgICAgKi9cbiAgICBjb25zdCBpc0dyYW51bGFyU2NhbGUgPSBNYXRoLmFicyhpbml0aWFsRGVsdGEpIDwgNTtcbiAgICByZXN0U3BlZWQgfHwgKHJlc3RTcGVlZCA9IGlzR3JhbnVsYXJTY2FsZVxuICAgICAgICA/IHNwcmluZ0RlZmF1bHRzLnJlc3RTcGVlZC5ncmFudWxhclxuICAgICAgICA6IHNwcmluZ0RlZmF1bHRzLnJlc3RTcGVlZC5kZWZhdWx0KTtcbiAgICByZXN0RGVsdGEgfHwgKHJlc3REZWx0YSA9IGlzR3JhbnVsYXJTY2FsZVxuICAgICAgICA/IHNwcmluZ0RlZmF1bHRzLnJlc3REZWx0YS5ncmFudWxhclxuICAgICAgICA6IHNwcmluZ0RlZmF1bHRzLnJlc3REZWx0YS5kZWZhdWx0KTtcbiAgICBsZXQgcmVzb2x2ZVNwcmluZztcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICBjb25zdCBhbmd1bGFyRnJlcSA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEFuZ3VsYXJGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAvLyBVbmRlcmRhbXBlZCBzcHJpbmdcbiAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICByZXR1cm4gKHRhcmdldCAtXG4gICAgICAgICAgICAgICAgZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAoKChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckZyZXEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYW1waW5nUmF0aW8gPT09IDEpIHtcbiAgICAgICAgLy8gQ3JpdGljYWxseSBkYW1wZWQgc3ByaW5nXG4gICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4gdGFyZ2V0IC1cbiAgICAgICAgICAgIE1hdGguZXhwKC11bmRhbXBlZEFuZ3VsYXJGcmVxICogdCkgKlxuICAgICAgICAgICAgICAgIChpbml0aWFsRGVsdGEgK1xuICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbFZlbG9jaXR5ICsgdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKiB0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE92ZXJkYW1wZWQgc3ByaW5nXG4gICAgICAgIGNvbnN0IGRhbXBlZEFuZ3VsYXJGcmVxID0gdW5kYW1wZWRBbmd1bGFyRnJlcSAqIE1hdGguc3FydChkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8gLSAxKTtcbiAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgc2luaCBvciBjb3NoIHZhbHVlcyBjYW4gaGl0IEluZmluaXR5IHNvIHdlIGNhcCB0aGVtIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGZyZXFGb3JUID0gTWF0aC5taW4oZGFtcGVkQW5ndWxhckZyZXEgKiB0LCAzMDApO1xuICAgICAgICAgICAgcmV0dXJuICh0YXJnZXQgLVxuICAgICAgICAgICAgICAgIChlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICgoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luaChmcmVxRm9yVCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3NoKGZyZXFGb3JUKSkpIC9cbiAgICAgICAgICAgICAgICAgICAgZGFtcGVkQW5ndWxhckZyZXEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBnZW5lcmF0b3IgPSB7XG4gICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbjogaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA/IGR1cmF0aW9uIHx8IG51bGwgOiBudWxsLFxuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHJlc29sdmVTcHJpbmcodCk7XG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWRGcm9tRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZlbG9jaXR5ID0gMC4wO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdlIG9ubHkgbmVlZCB0byBjYWxjdWxhdGUgdmVsb2NpdHkgZm9yIHVuZGVyLWRhbXBlZCBzcHJpbmdzXG4gICAgICAgICAgICAgICAgICogYXMgb3Zlci0gYW5kIGNyaXRpY2FsbHktZGFtcGVkIHNwcmluZ3MgY2FuJ3Qgb3ZlcnNob290LCBzb1xuICAgICAgICAgICAgICAgICAqIGNoZWNraW5nIG9ubHkgZm9yIGRpc3BsYWNlbWVudCBpcyBlbm91Z2guXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZlbG9jaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHNlY29uZHNUb01pbGxpc2Vjb25kcyhpbml0aWFsVmVsb2NpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxjR2VuZXJhdG9yVmVsb2NpdHkocmVzb2x2ZVNwcmluZywgdCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCA9IE1hdGguYWJzKGN1cnJlbnRWZWxvY2l0eSkgPD0gcmVzdFNwZWVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSBNYXRoLmFicyh0YXJnZXQgLSBjdXJyZW50KSA8PSByZXN0RGVsdGE7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCAmJiBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0YXJnZXQgOiBjdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZER1cmF0aW9uID0gTWF0aC5taW4oY2FsY0dlbmVyYXRvckR1cmF0aW9uKGdlbmVyYXRvciksIG1heEdlbmVyYXRvckR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZyA9IGdlbmVyYXRlTGluZWFyRWFzaW5nKChwcm9ncmVzcykgPT4gZ2VuZXJhdG9yLm5leHQoY2FsY3VsYXRlZER1cmF0aW9uICogcHJvZ3Jlc3MpLnZhbHVlLCBjYWxjdWxhdGVkRHVyYXRpb24sIDMwKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkRHVyYXRpb24gKyBcIm1zIFwiICsgZWFzaW5nO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cblxuZXhwb3J0IHsgc3ByaW5nIH07XG4iLCJpbXBvcnQgeyBzcHJpbmcgfSBmcm9tICcuL3NwcmluZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgY2FsY0dlbmVyYXRvclZlbG9jaXR5IH0gZnJvbSAnLi91dGlscy92ZWxvY2l0eS5tanMnO1xuXG5mdW5jdGlvbiBpbmVydGlhKHsga2V5ZnJhbWVzLCB2ZWxvY2l0eSA9IDAuMCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDMyNSwgYm91bmNlRGFtcGluZyA9IDEwLCBib3VuY2VTdGlmZm5lc3MgPSA1MDAsIG1vZGlmeVRhcmdldCwgbWluLCBtYXgsIHJlc3REZWx0YSA9IDAuNSwgcmVzdFNwZWVkLCB9KSB7XG4gICAgY29uc3Qgb3JpZ2luID0ga2V5ZnJhbWVzWzBdO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IG9yaWdpbixcbiAgICB9O1xuICAgIGNvbnN0IGlzT3V0T2ZCb3VuZHMgPSAodikgPT4gKG1pbiAhPT0gdW5kZWZpbmVkICYmIHYgPCBtaW4pIHx8IChtYXggIT09IHVuZGVmaW5lZCAmJiB2ID4gbWF4KTtcbiAgICBjb25zdCBuZWFyZXN0Qm91bmRhcnkgPSAodikgPT4ge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobWluIC0gdikgPCBNYXRoLmFicyhtYXggLSB2KSA/IG1pbiA6IG1heDtcbiAgICB9O1xuICAgIGxldCBhbXBsaXR1ZGUgPSBwb3dlciAqIHZlbG9jaXR5O1xuICAgIGNvbnN0IGlkZWFsID0gb3JpZ2luICsgYW1wbGl0dWRlO1xuICAgIGNvbnN0IHRhcmdldCA9IG1vZGlmeVRhcmdldCA9PT0gdW5kZWZpbmVkID8gaWRlYWwgOiBtb2RpZnlUYXJnZXQoaWRlYWwpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0YXJnZXQgaGFzIGNoYW5nZWQgd2UgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlIGFtcGxpdHVkZSwgb3RoZXJ3aXNlXG4gICAgICogdGhlIGFuaW1hdGlvbiB3aWxsIHN0YXJ0IGZyb20gdGhlIHdyb25nIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGlmICh0YXJnZXQgIT09IGlkZWFsKVxuICAgICAgICBhbXBsaXR1ZGUgPSB0YXJnZXQgLSBvcmlnaW47XG4gICAgY29uc3QgY2FsY0RlbHRhID0gKHQpID0+IC1hbXBsaXR1ZGUgKiBNYXRoLmV4cCgtdCAvIHRpbWVDb25zdGFudCk7XG4gICAgY29uc3QgY2FsY0xhdGVzdCA9ICh0KSA9PiB0YXJnZXQgKyBjYWxjRGVsdGEodCk7XG4gICAgY29uc3QgYXBwbHlGcmljdGlvbiA9ICh0KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY2FsY0RlbHRhKHQpO1xuICAgICAgICBjb25zdCBsYXRlc3QgPSBjYWxjTGF0ZXN0KHQpO1xuICAgICAgICBzdGF0ZS5kb25lID0gTWF0aC5hYnMoZGVsdGEpIDw9IHJlc3REZWx0YTtcbiAgICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdGFyZ2V0IDogbGF0ZXN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSWRlYWxseSB0aGlzIHdvdWxkIHJlc29sdmUgZm9yIHQgaW4gYSBzdGF0ZWxlc3Mgd2F5LCB3ZSBjb3VsZFxuICAgICAqIGRvIHRoYXQgYnkgYWx3YXlzIHByZWNhbGN1bGF0aW5nIHRoZSBhbmltYXRpb24gYnV0IGFzIHdlIGtub3dcbiAgICAgKiB0aGlzIHdpbGwgYmUgZG9uZSBhbnl3YXkgd2UgY2FuIGFzc3VtZSB0aGF0IHNwcmluZyB3aWxsXG4gICAgICogYmUgZGlzY292ZXJlZCBkdXJpbmcgdGhhdC5cbiAgICAgKi9cbiAgICBsZXQgdGltZVJlYWNoZWRCb3VuZGFyeTtcbiAgICBsZXQgc3ByaW5nJDE7XG4gICAgY29uc3QgY2hlY2tDYXRjaEJvdW5kYXJ5ID0gKHQpID0+IHtcbiAgICAgICAgaWYgKCFpc091dE9mQm91bmRzKHN0YXRlLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGltZVJlYWNoZWRCb3VuZGFyeSA9IHQ7XG4gICAgICAgIHNwcmluZyQxID0gc3ByaW5nKHtcbiAgICAgICAgICAgIGtleWZyYW1lczogW3N0YXRlLnZhbHVlLCBuZWFyZXN0Qm91bmRhcnkoc3RhdGUudmFsdWUpXSxcbiAgICAgICAgICAgIHZlbG9jaXR5OiBjYWxjR2VuZXJhdG9yVmVsb2NpdHkoY2FsY0xhdGVzdCwgdCwgc3RhdGUudmFsdWUpLCAvLyBUT0RPOiBUaGlzIHNob3VsZCBiZSBwYXNzaW5nICogMTAwMFxuICAgICAgICAgICAgZGFtcGluZzogYm91bmNlRGFtcGluZyxcbiAgICAgICAgICAgIHN0aWZmbmVzczogYm91bmNlU3RpZmZuZXNzLFxuICAgICAgICAgICAgcmVzdERlbHRhLFxuICAgICAgICAgICAgcmVzdFNwZWVkLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNoZWNrQ2F0Y2hCb3VuZGFyeSgwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxjdWxhdGVkRHVyYXRpb246IG51bGwsXG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgZnJpY3Rpb24gdG8gZmlndXJlIG91dCBpZiB3ZSBuZWVkIGFcbiAgICAgICAgICAgICAqIHNwcmluZyBidXQgd2UgZG9uJ3Qgd2FudCB0byBkbyB0aGlzIHR3aWNlIHBlciBmcmFtZS4gU28gaGVyZVxuICAgICAgICAgICAgICogd2UgZmxhZyBpZiB3ZSB1cGRhdGVkIGZvciB0aGlzIGZyYW1lIGFuZCBsYXRlciBpZiB3ZSBkaWRcbiAgICAgICAgICAgICAqIHdlIGNhbiBza2lwIGRvaW5nIGl0IGFnYWluLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaGFzVXBkYXRlZEZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoIXNwcmluZyQxICYmIHRpbWVSZWFjaGVkQm91bmRhcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGhhc1VwZGF0ZWRGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXBwbHlGcmljdGlvbih0KTtcbiAgICAgICAgICAgICAgICBjaGVja0NhdGNoQm91bmRhcnkodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgYSBzcHJpbmcgYW5kIHRoZSBwcm92aWRlZCB0IGlzIGJleW9uZCB0aGUgbW9tZW50IHRoZSBmcmljdGlvblxuICAgICAgICAgICAgICogYW5pbWF0aW9uIGNyb3NzZWQgdGhlIG1pbi9tYXggYm91bmRhcnksIHVzZSB0aGUgc3ByaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGltZVJlYWNoZWRCb3VuZGFyeSAhPT0gdW5kZWZpbmVkICYmIHQgPj0gdGltZVJlYWNoZWRCb3VuZGFyeSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcHJpbmckMS5uZXh0KHQgLSB0aW1lUmVhY2hlZEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICFoYXNVcGRhdGVkRnJhbWUgJiYgYXBwbHlGcmljdGlvbih0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgaW5lcnRpYSB9O1xuIiwiaW1wb3J0IHsgY3ViaWNCZXppZXIgfSBmcm9tICcuL2N1YmljLWJlemllci5tanMnO1xuXG5jb25zdCBlYXNlSW4gPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAuNDIsIDAsIDEsIDEpO1xuY29uc3QgZWFzZU91dCA9IC8qQF9fUFVSRV9fKi8gY3ViaWNCZXppZXIoMCwgMCwgMC41OCwgMSk7XG5jb25zdCBlYXNlSW5PdXQgPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAuNDIsIDAsIDAuNTgsIDEpO1xuXG5leHBvcnQgeyBlYXNlSW4sIGVhc2VJbk91dCwgZWFzZU91dCB9O1xuIiwiY29uc3QgaXNFYXNpbmdBcnJheSA9IChlYXNlKSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZWFzZSkgJiYgdHlwZW9mIGVhc2VbMF0gIT09IFwibnVtYmVyXCI7XG59O1xuXG5leHBvcnQgeyBpc0Vhc2luZ0FycmF5IH07XG4iLCJpbXBvcnQgeyBpc0JlemllckRlZmluaXRpb24gfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IGludmFyaWFudCwgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBhbnRpY2lwYXRlIH0gZnJvbSAnLi4vYW50aWNpcGF0ZS5tanMnO1xuaW1wb3J0IHsgYmFja0luLCBiYWNrSW5PdXQsIGJhY2tPdXQgfSBmcm9tICcuLi9iYWNrLm1qcyc7XG5pbXBvcnQgeyBjaXJjSW4sIGNpcmNJbk91dCwgY2lyY091dCB9IGZyb20gJy4uL2NpcmMubWpzJztcbmltcG9ydCB7IGN1YmljQmV6aWVyIH0gZnJvbSAnLi4vY3ViaWMtYmV6aWVyLm1qcyc7XG5pbXBvcnQgeyBlYXNlSW4sIGVhc2VJbk91dCwgZWFzZU91dCB9IGZyb20gJy4uL2Vhc2UubWpzJztcblxuY29uc3QgZWFzaW5nTG9va3VwID0ge1xuICAgIGxpbmVhcjogbm9vcCxcbiAgICBlYXNlSW4sXG4gICAgZWFzZUluT3V0LFxuICAgIGVhc2VPdXQsXG4gICAgY2lyY0luLFxuICAgIGNpcmNJbk91dCxcbiAgICBjaXJjT3V0LFxuICAgIGJhY2tJbixcbiAgICBiYWNrSW5PdXQsXG4gICAgYmFja091dCxcbiAgICBhbnRpY2lwYXRlLFxufTtcbmNvbnN0IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gKGRlZmluaXRpb24pID0+IHtcbiAgICBpZiAoaXNCZXppZXJEZWZpbml0aW9uKGRlZmluaXRpb24pKSB7XG4gICAgICAgIC8vIElmIGN1YmljIGJlemllciBkZWZpbml0aW9uLCBjcmVhdGUgYmV6aWVyIGN1cnZlXG4gICAgICAgIGludmFyaWFudChkZWZpbml0aW9uLmxlbmd0aCA9PT0gNCwgYEN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5gKTtcbiAgICAgICAgY29uc3QgW3gxLCB5MSwgeDIsIHkyXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBjdWJpY0Jlemllcih4MSwgeTEsIHgyLCB5Mik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEVsc2UgbG9va3VwIGZyb20gdGFibGVcbiAgICAgICAgaW52YXJpYW50KGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXSAhPT0gdW5kZWZpbmVkLCBgSW52YWxpZCBlYXNpbmcgdHlwZSAnJHtkZWZpbml0aW9ufSdgKTtcbiAgICAgICAgcmV0dXJuIGVhc2luZ0xvb2t1cFtkZWZpbml0aW9uXTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59O1xuXG5leHBvcnQgeyBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiB9O1xuIiwiaW1wb3J0IHsgaW52YXJpYW50LCBub29wLCBwcm9ncmVzcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4vY2xhbXAubWpzJztcbmltcG9ydCB7IG1peCB9IGZyb20gJy4vbWl4L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnLi9waXBlLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIGN1c3RvbU1peGVyKSB7XG4gICAgY29uc3QgbWl4ZXJzID0gW107XG4gICAgY29uc3QgbWl4ZXJGYWN0b3J5ID0gY3VzdG9tTWl4ZXIgfHwgbWl4O1xuICAgIGNvbnN0IG51bU1peGVycyA9IG91dHB1dC5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWl4ZXJzOyBpKyspIHtcbiAgICAgICAgbGV0IG1peGVyID0gbWl4ZXJGYWN0b3J5KG91dHB1dFtpXSwgb3V0cHV0W2kgKyAxXSk7XG4gICAgICAgIGlmIChlYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBlYXNpbmdGdW5jdGlvbiA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlW2ldIHx8IG5vb3AgOiBlYXNlO1xuICAgICAgICAgICAgbWl4ZXIgPSBwaXBlKGVhc2luZ0Z1bmN0aW9uLCBtaXhlcik7XG4gICAgICAgIH1cbiAgICAgICAgbWl4ZXJzLnB1c2gobWl4ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWl4ZXJzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IG1hcHMgZnJvbSBhIG51bWVyaWNhbCBpbnB1dCBhcnJheSB0byBhIGdlbmVyaWMgb3V0cHV0IGFycmF5LlxuICpcbiAqIEFjY2VwdHM6XG4gKiAgIC0gTnVtYmVyc1xuICogICAtIENvbG9ycyAoaGV4LCBoc2wsIGhzbGEsIHJnYiwgcmdiYSlcbiAqICAgLSBDb21wbGV4IChjb21iaW5hdGlvbnMgb2Ygb25lIG9yIG1vcmUgbnVtYmVycyBvciBzdHJpbmdzKVxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgbWl4Q29sb3IgPSBpbnRlcnBvbGF0ZShbMCwgMV0sIFsnI2ZmZicsICcjMDAwJ10pXG4gKlxuICogbWl4Q29sb3IoMC41KSAvLyAncmdiYSgxMjgsIDEyOCwgMTI4LCAxKSdcbiAqIGBgYFxuICpcbiAqIFRPRE8gUmV2aXN0IHRoaXMgYXBwcm9hY2ggb25jZSB3ZSd2ZSBtb3ZlZCB0byBkYXRhIG1vZGVscyBmb3IgdmFsdWVzLFxuICogcHJvYmFibHkgbm90IG5lZWRlZCB0byBwcmVnZW5lcmF0ZSBtaXhlciBmdW5jdGlvbnMuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShpbnB1dCwgb3V0cHV0LCB7IGNsYW1wOiBpc0NsYW1wID0gdHJ1ZSwgZWFzZSwgbWl4ZXIgfSA9IHt9KSB7XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgaW52YXJpYW50KGlucHV0TGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoLCBcIkJvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGhcIik7XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgb25seSBwcm92aWRlZCBhIHNpbmdsZSBpbnB1dCwgd2UgY2FuIGp1c3QgbWFrZSBhIGZ1bmN0aW9uXG4gICAgICogdGhhdCByZXR1cm5zIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgaWYgKGlucHV0TGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gKCkgPT4gb3V0cHV0WzBdO1xuICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMiAmJiBvdXRwdXRbMF0gPT09IG91dHB1dFsxXSlcbiAgICAgICAgcmV0dXJuICgpID0+IG91dHB1dFsxXTtcbiAgICBjb25zdCBpc1plcm9EZWx0YVJhbmdlID0gaW5wdXRbMF0gPT09IGlucHV0WzFdO1xuICAgIC8vIElmIGlucHV0IHJ1bnMgaGlnaGVzdCAtPiBsb3dlc3QsIHJldmVyc2UgYm90aCBhcnJheXNcbiAgICBpZiAoaW5wdXRbMF0gPiBpbnB1dFtpbnB1dExlbmd0aCAtIDFdKSB7XG4gICAgICAgIGlucHV0ID0gWy4uLmlucHV0XS5yZXZlcnNlKCk7XG4gICAgICAgIG91dHB1dCA9IFsuLi5vdXRwdXRdLnJldmVyc2UoKTtcbiAgICB9XG4gICAgY29uc3QgbWl4ZXJzID0gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgbWl4ZXIpO1xuICAgIGNvbnN0IG51bU1peGVycyA9IG1peGVycy5sZW5ndGg7XG4gICAgY29uc3QgaW50ZXJwb2xhdG9yID0gKHYpID0+IHtcbiAgICAgICAgaWYgKGlzWmVyb0RlbHRhUmFuZ2UgJiYgdiA8IGlucHV0WzBdKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dFswXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBpZiAobnVtTWl4ZXJzID4gMSkge1xuICAgICAgICAgICAgZm9yICg7IGkgPCBpbnB1dC5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodiA8IGlucHV0W2kgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NJblJhbmdlID0gcHJvZ3Jlc3MoaW5wdXRbaV0sIGlucHV0W2kgKyAxXSwgdik7XG4gICAgICAgIHJldHVybiBtaXhlcnNbaV0ocHJvZ3Jlc3NJblJhbmdlKTtcbiAgICB9O1xuICAgIHJldHVybiBpc0NsYW1wXG4gICAgICAgID8gKHYpID0+IGludGVycG9sYXRvcihjbGFtcChpbnB1dFswXSwgaW5wdXRbaW5wdXRMZW5ndGggLSAxXSwgdikpXG4gICAgICAgIDogaW50ZXJwb2xhdG9yO1xufVxuXG5leHBvcnQgeyBpbnRlcnBvbGF0ZSB9O1xuIiwiaW1wb3J0IHsgcHJvZ3Jlc3MgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi4vbWl4L251bWJlci5tanMnO1xuXG5mdW5jdGlvbiBmaWxsT2Zmc2V0KG9mZnNldCwgcmVtYWluaW5nKSB7XG4gICAgY29uc3QgbWluID0gb2Zmc2V0W29mZnNldC5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSByZW1haW5pbmc7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXRQcm9ncmVzcyA9IHByb2dyZXNzKDAsIHJlbWFpbmluZywgaSk7XG4gICAgICAgIG9mZnNldC5wdXNoKG1peE51bWJlcihtaW4sIDEsIG9mZnNldFByb2dyZXNzKSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBmaWxsT2Zmc2V0IH07XG4iLCJpbXBvcnQgeyBmaWxsT2Zmc2V0IH0gZnJvbSAnLi9maWxsLm1qcyc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRPZmZzZXQoYXJyKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gWzBdO1xuICAgIGZpbGxPZmZzZXQob2Zmc2V0LCBhcnIubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZXhwb3J0IHsgZGVmYXVsdE9mZnNldCB9O1xuIiwiZnVuY3Rpb24gY29udmVydE9mZnNldFRvVGltZXMob2Zmc2V0LCBkdXJhdGlvbikge1xuICAgIHJldHVybiBvZmZzZXQubWFwKChvKSA9PiBvICogZHVyYXRpb24pO1xufVxuXG5leHBvcnQgeyBjb252ZXJ0T2Zmc2V0VG9UaW1lcyB9O1xuIiwiaW1wb3J0IHsgZWFzZUluT3V0IH0gZnJvbSAnLi4vLi4vZWFzaW5nL2Vhc2UubWpzJztcbmltcG9ydCB7IGlzRWFzaW5nQXJyYXkgfSBmcm9tICcuLi8uLi9lYXNpbmcvdXRpbHMvaXMtZWFzaW5nLWFycmF5Lm1qcyc7XG5pbXBvcnQgeyBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiB9IGZyb20gJy4uLy4uL2Vhc2luZy91dGlscy9tYXAubWpzJztcbmltcG9ydCB7IGludGVycG9sYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaW50ZXJwb2xhdGUubWpzJztcbmltcG9ydCB7IGRlZmF1bHRPZmZzZXQgfSBmcm9tICcuLi8uLi91dGlscy9vZmZzZXRzL2RlZmF1bHQubWpzJztcbmltcG9ydCB7IGNvbnZlcnRPZmZzZXRUb1RpbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvb2Zmc2V0cy90aW1lLm1qcyc7XG5cbmZ1bmN0aW9uIGRlZmF1bHRFYXNpbmcodmFsdWVzLCBlYXNpbmcpIHtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgoKSA9PiBlYXNpbmcgfHwgZWFzZUluT3V0KS5zcGxpY2UoMCwgdmFsdWVzLmxlbmd0aCAtIDEpO1xufVxuZnVuY3Rpb24ga2V5ZnJhbWVzKHsgZHVyYXRpb24gPSAzMDAsIGtleWZyYW1lczoga2V5ZnJhbWVWYWx1ZXMsIHRpbWVzLCBlYXNlID0gXCJlYXNlSW5PdXRcIiwgfSkge1xuICAgIC8qKlxuICAgICAqIEVhc2luZyBmdW5jdGlvbnMgY2FuIGJlIGV4dGVybmFsbHkgZGVmaW5lZCBhcyBzdHJpbmdzLiBIZXJlIHdlIGNvbnZlcnQgdGhlbVxuICAgICAqIGludG8gYWN0dWFsIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICBjb25zdCBlYXNpbmdGdW5jdGlvbnMgPSBpc0Vhc2luZ0FycmF5KGVhc2UpXG4gICAgICAgID8gZWFzZS5tYXAoZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24pXG4gICAgICAgIDogZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24oZWFzZSk7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgSXRlcmF0b3Itc3BlYyByZXR1cm4gdmFsdWUuIFdlIGVuc3VyZSBpdCdzIG11dGFibGUgcmF0aGVyIHRoYW4gdXNpbmcgYSBnZW5lcmF0b3JcbiAgICAgKiB0byByZWR1Y2UgR0MgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBrZXlmcmFtZVZhbHVlc1swXSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHRpbWVzIGFycmF5IGJhc2VkIG9uIHRoZSBwcm92aWRlZCAwLTEgb2Zmc2V0c1xuICAgICAqL1xuICAgIGNvbnN0IGFic29sdXRlVGltZXMgPSBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhcbiAgICAvLyBPbmx5IHVzZSB0aGUgcHJvdmlkZWQgb2Zmc2V0cyBpZiB0aGV5J3JlIHRoZSBjb3JyZWN0IGxlbmd0aFxuICAgIC8vIFRPRE8gTWF5YmUgd2Ugc2hvdWxkIHdhcm4gaGVyZSBpZiB0aGVyZSdzIGEgbGVuZ3RoIG1pc21hdGNoXG4gICAgdGltZXMgJiYgdGltZXMubGVuZ3RoID09PSBrZXlmcmFtZVZhbHVlcy5sZW5ndGhcbiAgICAgICAgPyB0aW1lc1xuICAgICAgICA6IGRlZmF1bHRPZmZzZXQoa2V5ZnJhbWVWYWx1ZXMpLCBkdXJhdGlvbik7XG4gICAgY29uc3QgbWFwVGltZVRvS2V5ZnJhbWUgPSBpbnRlcnBvbGF0ZShhYnNvbHV0ZVRpbWVzLCBrZXlmcmFtZVZhbHVlcywge1xuICAgICAgICBlYXNlOiBBcnJheS5pc0FycmF5KGVhc2luZ0Z1bmN0aW9ucylcbiAgICAgICAgICAgID8gZWFzaW5nRnVuY3Rpb25zXG4gICAgICAgICAgICA6IGRlZmF1bHRFYXNpbmcoa2V5ZnJhbWVWYWx1ZXMsIGVhc2luZ0Z1bmN0aW9ucyksXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FsY3VsYXRlZER1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgbmV4dDogKHQpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gbWFwVGltZVRvS2V5ZnJhbWUodCk7XG4gICAgICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBkZWZhdWx0RWFzaW5nLCBrZXlmcmFtZXMgfTtcbiIsImltcG9ydCB7IHRpbWUgfSBmcm9tICcuLi8uLi8uLi9mcmFtZWxvb3Avc3luYy10aW1lLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSwgY2FuY2VsRnJhbWUsIGZyYW1lRGF0YSB9IGZyb20gJy4uLy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5jb25zdCBmcmFtZWxvb3BEcml2ZXIgPSAodXBkYXRlKSA9PiB7XG4gICAgY29uc3QgcGFzc1RpbWVzdGFtcCA9ICh7IHRpbWVzdGFtcCB9KSA9PiB1cGRhdGUodGltZXN0YW1wKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogKCkgPT4gZnJhbWUudXBkYXRlKHBhc3NUaW1lc3RhbXAsIHRydWUpLFxuICAgICAgICBzdG9wOiAoKSA9PiBjYW5jZWxGcmFtZShwYXNzVGltZXN0YW1wKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIHByb2Nlc3NpbmcgdGhpcyBmcmFtZSB3ZSBjYW4gdXNlIHRoZVxuICAgICAgICAgKiBmcmFtZWxvY2tlZCB0aW1lc3RhbXAgdG8ga2VlcCB0aGluZ3MgaW4gc3luYy5cbiAgICAgICAgICovXG4gICAgICAgIG5vdzogKCkgPT4gKGZyYW1lRGF0YS5pc1Byb2Nlc3NpbmcgPyBmcmFtZURhdGEudGltZXN0YW1wIDogdGltZS5ub3coKSksXG4gICAgfTtcbn07XG5cbmV4cG9ydCB7IGZyYW1lbG9vcERyaXZlciB9O1xuIiwiaW1wb3J0IHsgaXNHZW5lcmF0b3IsIGNhbGNHZW5lcmF0b3JEdXJhdGlvbiB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgaW52YXJpYW50LCBtaWxsaXNlY29uZHNUb1NlY29uZHMsIHNlY29uZHNUb01pbGxpc2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBLZXlmcmFtZVJlc29sdmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL0tleWZyYW1lc1Jlc29sdmVyLm1qcyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uL3V0aWxzL2NsYW1wLm1qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuLi8uLi91dGlscy9taXgvaW5kZXgubWpzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICcuLi8uLi91dGlscy9waXBlLm1qcyc7XG5pbXBvcnQgeyBpbmVydGlhIH0gZnJvbSAnLi4vZ2VuZXJhdG9ycy9pbmVydGlhLm1qcyc7XG5pbXBvcnQgeyBrZXlmcmFtZXMgfSBmcm9tICcuLi9nZW5lcmF0b3JzL2tleWZyYW1lcy5tanMnO1xuaW1wb3J0IHsgc3ByaW5nIH0gZnJvbSAnLi4vZ2VuZXJhdG9ycy9zcHJpbmcvaW5kZXgubWpzJztcbmltcG9ydCB7IEJhc2VBbmltYXRpb24gfSBmcm9tICcuL0Jhc2VBbmltYXRpb24ubWpzJztcbmltcG9ydCB7IGZyYW1lbG9vcERyaXZlciB9IGZyb20gJy4vZHJpdmVycy9kcml2ZXItZnJhbWVsb29wLm1qcyc7XG5pbXBvcnQgeyBnZXRGaW5hbEtleWZyYW1lIH0gZnJvbSAnLi93YWFwaS91dGlscy9nZXQtZmluYWwta2V5ZnJhbWUubWpzJztcblxuY29uc3QgZ2VuZXJhdG9ycyA9IHtcbiAgICBkZWNheTogaW5lcnRpYSxcbiAgICBpbmVydGlhLFxuICAgIHR3ZWVuOiBrZXlmcmFtZXMsXG4gICAga2V5ZnJhbWVzOiBrZXlmcmFtZXMsXG4gICAgc3ByaW5nLFxufTtcbmNvbnN0IHBlcmNlbnRUb1Byb2dyZXNzID0gKHBlcmNlbnQpID0+IHBlcmNlbnQgLyAxMDA7XG4vKipcbiAqIEFuaW1hdGlvbiB0aGF0IHJ1bnMgb24gdGhlIG1haW4gdGhyZWFkLiBEZXNpZ25lZCB0byBiZSBXQUFQSS1zcGVjIGluIHRoZSBzdWJzZXQgb2ZcbiAqIGZlYXR1cmVzIHdlIGV4cG9zZSBwdWJsaWNhbGx5LiBNb3N0bHkgdGhlIGNvbXBhdGliaWxpdHkgaXMgdG8gZW5zdXJlIHZpc3VhbCBpZGVudGl0eVxuICogYmV0d2VlbiBib3RoIFdBQVBJIGFuZCBtYWluIHRocmVhZCBhbmltYXRpb25zLlxuICovXG5jbGFzcyBNYWluVGhyZWFkQW5pbWF0aW9uIGV4dGVuZHMgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gd2FzIHBhdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGFuaW1hdGlvbiB3YXMgY2FuY2VsbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheWJhY2sgc3BlZWQgYXMgYSBmYWN0b3IuIDAgd291bGQgYmUgc3RvcHBlZCwgLTEgcmV2ZXJzZSBhbmQgMiBkb3VibGUgc3BlZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYXliYWNrU3BlZWQgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gdG8gYXBwbHkgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIHJlc29sdmVkLiBUaGlzXG4gICAgICAgICAqIGFsbG93cyBjYWxscyB0byB0aGUgcHVibGljIEFQSSB0byBjb250cm9sIHRoZSBhbmltYXRpb24gYmVmb3JlIGl0IGlzIHJlc29sdmVkLFxuICAgICAgICAgKiB3aXRob3V0IHVzIGhhdmluZyB0byByZXNvbHZlIGl0IGZpcnN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUGxheVN0YXRlID0gXCJydW5uaW5nXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBhdCB3aGljaCB0aGUgYW5pbWF0aW9uIHdhcyBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJpZGxlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgaW5zdGFuY2UgdG8gZml4IGEgcGF0dGVybiB3aGVyZVxuICAgICAgICAgKiBhbmltYXRpb24uc3RvcCBpcyByZXR1cm5lZCBhcyBhIHJlZmVyZW5jZSBmcm9tIGEgdXNlRWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImlkbGVcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgICAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgb25TdG9wICYmIG9uU3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBrZXlmcmFtZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgS2V5ZnJhbWVSZXNvbHZlciQxID0gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5LZXlmcmFtZVJlc29sdmVyKSB8fCBLZXlmcmFtZVJlc29sdmVyO1xuICAgICAgICBjb25zdCBvblJlc29sdmVkID0gKHJlc29sdmVkS2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKSA9PiB0aGlzLm9uS2V5ZnJhbWVzUmVzb2x2ZWQocmVzb2x2ZWRLZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gbmV3IEtleWZyYW1lUmVzb2x2ZXIkMShrZXlmcmFtZXMsIG9uUmVzb2x2ZWQsIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5zY2hlZHVsZVJlc29sdmUoKTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgc3VwZXIuZmxhdHRlbigpO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHJlc29sdmVkIHRoZSBhbmltYXRpb24sIHJlLWluaXRpYWxpc2UgaXRcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Jlc29sdmVkLCB0aGlzLmluaXRQbGF5YmFjayh0aGlzLl9yZXNvbHZlZC5rZXlmcmFtZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UGxheWJhY2soa2V5ZnJhbWVzJDEpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlID0gXCJrZXlmcmFtZXNcIiwgcmVwZWF0ID0gMCwgcmVwZWF0RGVsYXkgPSAwLCByZXBlYXRUeXBlLCB2ZWxvY2l0eSA9IDAsIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvckZhY3RvcnkgPSBpc0dlbmVyYXRvcih0eXBlKVxuICAgICAgICAgICAgPyB0eXBlXG4gICAgICAgICAgICA6IGdlbmVyYXRvcnNbdHlwZV0gfHwga2V5ZnJhbWVzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgb3VyIGdlbmVyYXRvciBkb2Vzbid0IHN1cHBvcnQgbWl4aW5nIG51bWJlcnMsIHdlIG5lZWQgdG8gcmVwbGFjZSBrZXlmcmFtZXMgd2l0aFxuICAgICAgICAgKiBbMCwgMTAwXSBhbmQgdGhlbiBtYWtlIGEgZnVuY3Rpb24gdGhhdCBtYXBzIHRoYXQgdG8gdGhlIGFjdHVhbCBrZXlmcmFtZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIDEwMCBpcyBjaG9zZW4gaW5zdGVhZCBvZiAxIGFzIGl0IHdvcmtzIG5pY2VyIHdpdGggc3ByaW5nIGFuaW1hdGlvbnMuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbWFwUGVyY2VudFRvS2V5ZnJhbWVzO1xuICAgICAgICBsZXQgbWlycm9yZWRHZW5lcmF0b3I7XG4gICAgICAgIGlmIChnZW5lcmF0b3JGYWN0b3J5ICE9PSBrZXlmcmFtZXMgJiZcbiAgICAgICAgICAgIHR5cGVvZiBrZXlmcmFtZXMkMVswXSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGludmFyaWFudChrZXlmcmFtZXMkMS5sZW5ndGggPT09IDIsIGBPbmx5IHR3byBrZXlmcmFtZXMgY3VycmVudGx5IHN1cHBvcnRlZCB3aXRoIHNwcmluZyBhbmQgaW5lcnRpYSBhbmltYXRpb25zLiBUcnlpbmcgdG8gYW5pbWF0ZSAke2tleWZyYW1lcyQxfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFwUGVyY2VudFRvS2V5ZnJhbWVzID0gcGlwZShwZXJjZW50VG9Qcm9ncmVzcywgbWl4KGtleWZyYW1lcyQxWzBdLCBrZXlmcmFtZXMkMVsxXSkpO1xuICAgICAgICAgICAga2V5ZnJhbWVzJDEgPSBbMCwgMTAwXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBnZW5lcmF0b3IgPSBnZW5lcmF0b3JGYWN0b3J5KHsgLi4udGhpcy5vcHRpb25zLCBrZXlmcmFtZXM6IGtleWZyYW1lcyQxIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UgaGF2ZSBhIG1pcnJvciByZXBlYXQgdHlwZSB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHNlY29uZCBnZW5lcmF0b3IgdGhhdCBvdXRwdXRzIHRoZVxuICAgICAgICAgKiBtaXJyb3JlZCAobm90IHJldmVyc2VkKSBhbmltYXRpb24gYW5kIGxhdGVyIHBpbmcgcG9uZyBiZXR3ZWVuIHRoZSB0d28gZ2VuZXJhdG9ycy5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcIm1pcnJvclwiKSB7XG4gICAgICAgICAgICBtaXJyb3JlZEdlbmVyYXRvciA9IGdlbmVyYXRvckZhY3Rvcnkoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXM6IFsuLi5rZXlmcmFtZXMkMV0ucmV2ZXJzZSgpLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5OiAtdmVsb2NpdHksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgZHVyYXRpb24gaXMgdW5kZWZpbmVkIGFuZCB3ZSBoYXZlIHJlcGVhdCBvcHRpb25zLFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBhIGR1cmF0aW9uIGZyb20gdGhlIGdlbmVyYXRvci5cbiAgICAgICAgICpcbiAgICAgICAgICogV2Ugc2V0IGl0IHRvIHRoZSBnZW5lcmF0b3IgaXRzZWxmIHRvIGNhY2hlIHRoZSBkdXJhdGlvbi5cbiAgICAgICAgICogQW55IHRpbWVsaW5lIHJlc29sdmVyIHdpbGwgbmVlZCB0byBoYXZlIGFscmVhZHkgcHJlY2FsY3VsYXRlZFxuICAgICAgICAgKiB0aGUgZHVyYXRpb24gYnkgdGhpcyBzdGVwLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGdlbmVyYXRvci5jYWxjdWxhdGVkRHVyYXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGdlbmVyYXRvci5jYWxjdWxhdGVkRHVyYXRpb24gPSBjYWxjR2VuZXJhdG9yRHVyYXRpb24oZ2VuZXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNhbGN1bGF0ZWREdXJhdGlvbiB9ID0gZ2VuZXJhdG9yO1xuICAgICAgICBjb25zdCByZXNvbHZlZER1cmF0aW9uID0gY2FsY3VsYXRlZER1cmF0aW9uICsgcmVwZWF0RGVsYXk7XG4gICAgICAgIGNvbnN0IHRvdGFsRHVyYXRpb24gPSByZXNvbHZlZER1cmF0aW9uICogKHJlcGVhdCArIDEpIC0gcmVwZWF0RGVsYXk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZW5lcmF0b3IsXG4gICAgICAgICAgICBtaXJyb3JlZEdlbmVyYXRvcixcbiAgICAgICAgICAgIG1hcFBlcmNlbnRUb0tleWZyYW1lcyxcbiAgICAgICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbixcbiAgICAgICAgICAgIHJlc29sdmVkRHVyYXRpb24sXG4gICAgICAgICAgICB0b3RhbER1cmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvblBvc3RSZXNvbHZlZCgpIHtcbiAgICAgICAgY29uc3QgeyBhdXRvcGxheSA9IHRydWUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdQbGF5U3RhdGUgPT09IFwicGF1c2VkXCIgfHwgIWF1dG9wbGF5KSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5wZW5kaW5nUGxheVN0YXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRpY2sodGltZXN0YW1wLCBzYW1wbGUgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICAvLyBJZiB0aGUgYW5pbWF0aW9ucyBoYXMgZmFpbGVkIHRvIHJlc29sdmUsIHJldHVybiB0aGUgZmluYWwga2V5ZnJhbWUuXG4gICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5ZnJhbWVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZToga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZmluYWxLZXlmcmFtZSwgZ2VuZXJhdG9yLCBtaXJyb3JlZEdlbmVyYXRvciwgbWFwUGVyY2VudFRvS2V5ZnJhbWVzLCBrZXlmcmFtZXMsIGNhbGN1bGF0ZWREdXJhdGlvbiwgdG90YWxEdXJhdGlvbiwgcmVzb2x2ZWREdXJhdGlvbiwgfSA9IHJlc29sdmVkO1xuICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLm5leHQoMCk7XG4gICAgICAgIGNvbnN0IHsgZGVsYXksIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXksIG9uVXBkYXRlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGltZXN0YW1wcyBjYW4gY29tZSB0aHJvdWdoIGFzIGxvd2VyIHRoYW5cbiAgICAgICAgICogdGhlIHN0YXJ0VGltZSBhcyBzZXQgYnkgcGVyZm9ybWFuY2Uubm93KCkuIEhlcmUgd2UgcHJldmVudCB0aGlzLFxuICAgICAgICAgKiB0aG91Z2ggaW4gdGhlIGZ1dHVyZSBpdCBjb3VsZCBiZSBwb3NzaWJsZSB0byBtYWtlIHNldHRpbmcgc3RhcnRUaW1lXG4gICAgICAgICAqIGEgcGVuZGluZyBvcGVyYXRpb24gdGhhdCBnZXRzIHJlc29sdmVkIGhlcmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4odGhpcy5zdGFydFRpbWUsIHRpbWVzdGFtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zcGVlZCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gTWF0aC5taW4odGltZXN0YW1wIC0gdG90YWxEdXJhdGlvbiAvIHRoaXMuc3BlZWQsIHRoaXMuc3RhcnRUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVcGRhdGUgY3VycmVudFRpbWVcbiAgICAgICAgaWYgKHNhbXBsZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmhvbGRUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5ob2xkVGltZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHRoZSB0aW1lIGJlY2F1c2UgZmxvYXRpbmcgcG9pbnQgYXJpdGhtZXRpYyBpcyBub3QgYWx3YXlzIGFjY3VyYXRlLCBlLmcuIDMwMDAuMzY3IC0gMTAwMC4zNjcgPVxuICAgICAgICAgICAgLy8gMjAwMC4wMDAwMDAwMDAwMDAyLiBUaGlzIGlzIGEgcHJvYmxlbSB3aGVuIHdlIGFyZSBjb21wYXJpbmcgdGhlIGN1cnJlbnRUaW1lIHdpdGggdGhlIGR1cmF0aW9uLCBmb3JcbiAgICAgICAgICAgIC8vIGV4YW1wbGUuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID1cbiAgICAgICAgICAgICAgICBNYXRoLnJvdW5kKHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRUaW1lKSAqIHRoaXMuc3BlZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmViYXNlIG9uIGRlbGF5XG4gICAgICAgIGNvbnN0IHRpbWVXaXRob3V0RGVsYXkgPSB0aGlzLmN1cnJlbnRUaW1lIC0gZGVsYXkgKiAodGhpcy5zcGVlZCA+PSAwID8gMSA6IC0xKTtcbiAgICAgICAgY29uc3QgaXNJbkRlbGF5UGhhc2UgPSB0aGlzLnNwZWVkID49IDBcbiAgICAgICAgICAgID8gdGltZVdpdGhvdXREZWxheSA8IDBcbiAgICAgICAgICAgIDogdGltZVdpdGhvdXREZWxheSA+IHRvdGFsRHVyYXRpb247XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBNYXRoLm1heCh0aW1lV2l0aG91dERlbGF5LCAwKTtcbiAgICAgICAgLy8gSWYgdGhpcyBhbmltYXRpb24gaGFzIGZpbmlzaGVkLCBzZXQgdGhlIGN1cnJlbnQgdGltZSAgdG8gdGhlIHRvdGFsIGR1cmF0aW9uLlxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiICYmIHRoaXMuaG9sZFRpbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0b3RhbER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbGFwc2VkID0gdGhpcy5jdXJyZW50VGltZTtcbiAgICAgICAgbGV0IGZyYW1lR2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgY3VycmVudCBwcm9ncmVzcyAoMC0xKSBvZiB0aGUgYW5pbWF0aW9uLiBJZiB0IGlzID5cbiAgICAgICAgICAgICAqIHRoYW4gZHVyYXRpb24gd2UnbGwgZ2V0IHZhbHVlcyBsaWtlIDIuNSAobWlkd2F5IHRocm91Z2ggdGhlXG4gICAgICAgICAgICAgKiB0aGlyZCBpdGVyYXRpb24pXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4odGhpcy5jdXJyZW50VGltZSwgdG90YWxEdXJhdGlvbikgLyByZXNvbHZlZER1cmF0aW9uO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgaXRlcmF0aW9uICgwIGluZGV4ZWQpLiBGb3IgaW5zdGFuY2UgdGhlIGZsb29yIG9mXG4gICAgICAgICAgICAgKiAyLjUgaXMgMi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRJdGVyYXRpb24gPSBNYXRoLmZsb29yKHByb2dyZXNzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHByb2dyZXNzIG9mIHRoZSBpdGVyYXRpb24gYnkgdGFraW5nIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgICAqIHNvIDIuNSBpcyAwLjUgdGhyb3VnaCBpdGVyYXRpb24gMlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaXRlcmF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcyAlIDEuMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgaXRlcmF0aW9uIHByb2dyZXNzIGlzIDEgd2UgY291bnQgdGhhdCBhcyB0aGUgZW5kXG4gICAgICAgICAgICAgKiBvZiB0aGUgcHJldmlvdXMgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWl0ZXJhdGlvblByb2dyZXNzICYmIHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyA9PT0gMSAmJiBjdXJyZW50SXRlcmF0aW9uLS07XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gTWF0aC5taW4oY3VycmVudEl0ZXJhdGlvbiwgcmVwZWF0ICsgMSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldmVyc2UgcHJvZ3Jlc3MgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW4gXCJub3JtYWxcIiBkaXJlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgaXNPZGRJdGVyYXRpb24gPSBCb29sZWFuKGN1cnJlbnRJdGVyYXRpb24gJSAyKTtcbiAgICAgICAgICAgIGlmIChpc09kZEl0ZXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcInJldmVyc2VcIikge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyA9IDEgLSBpdGVyYXRpb25Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcGVhdERlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25Qcm9ncmVzcyAtPSByZXBlYXREZWxheSAvIHJlc29sdmVkRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIikge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZUdlbmVyYXRvciA9IG1pcnJvcmVkR2VuZXJhdG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsYXBzZWQgPSBjbGFtcCgwLCAxLCBpdGVyYXRpb25Qcm9ncmVzcykgKiByZXNvbHZlZER1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBpbiBuZWdhdGl2ZSB0aW1lLCBzZXQgc3RhdGUgYXMgdGhlIGluaXRpYWwga2V5ZnJhbWUuXG4gICAgICAgICAqIFRoaXMgcHJldmVudHMgZGVsYXk6IHgsIGR1cmF0aW9uOiAwIGFuaW1hdGlvbnMgZnJvbSBmaW5pc2hpbmdcbiAgICAgICAgICogaW5zdGFudGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3RhdGUgPSBpc0luRGVsYXlQaGFzZVxuICAgICAgICAgICAgPyB7IGRvbmU6IGZhbHNlLCB2YWx1ZToga2V5ZnJhbWVzWzBdIH1cbiAgICAgICAgICAgIDogZnJhbWVHZW5lcmF0b3IubmV4dChlbGFwc2VkKTtcbiAgICAgICAgaWYgKG1hcFBlcmNlbnRUb0tleWZyYW1lcykge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBtYXBQZXJjZW50VG9LZXlmcmFtZXMoc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGRvbmUgfSA9IHN0YXRlO1xuICAgICAgICBpZiAoIWlzSW5EZWxheVBoYXNlICYmIGNhbGN1bGF0ZWREdXJhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZG9uZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA+PSAwXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5jdXJyZW50VGltZSA+PSB0b3RhbER1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5jdXJyZW50VGltZSA8PSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQW5pbWF0aW9uRmluaXNoZWQgPSB0aGlzLmhvbGRUaW1lID09PSBudWxsICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiIHx8ICh0aGlzLnN0YXRlID09PSBcInJ1bm5pbmdcIiAmJiBkb25lKSk7XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkZpbmlzaGVkICYmIGZpbmFsS2V5ZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgdGhpcy5vcHRpb25zLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICAgIG9uVXBkYXRlKHN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBbmltYXRpb25GaW5pc2hlZCkge1xuICAgICAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkID8gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKHJlc29sdmVkLmNhbGN1bGF0ZWREdXJhdGlvbikgOiAwO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyh0aGlzLmN1cnJlbnRUaW1lKTtcbiAgICB9XG4gICAgc2V0IHRpbWUobmV3VGltZSkge1xuICAgICAgICBuZXdUaW1lID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG5ld1RpbWUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gbmV3VGltZTtcbiAgICAgICAgaWYgKHRoaXMuaG9sZFRpbWUgIT09IG51bGwgfHwgdGhpcy5zcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5ob2xkVGltZSA9IG5ld1RpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kcml2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5kcml2ZXIubm93KCkgLSBuZXdUaW1lIC8gdGhpcy5zcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3BlZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBsYXliYWNrU3BlZWQ7XG4gICAgfVxuICAgIHNldCBzcGVlZChuZXdTcGVlZCkge1xuICAgICAgICBjb25zdCBoYXNDaGFuZ2VkID0gdGhpcy5wbGF5YmFja1NwZWVkICE9PSBuZXdTcGVlZDtcbiAgICAgICAgdGhpcy5wbGF5YmFja1NwZWVkID0gbmV3U3BlZWQ7XG4gICAgICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWUgPSBtaWxsaXNlY29uZHNUb1NlY29uZHModGhpcy5jdXJyZW50VGltZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGxheSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlc29sdmVyLmlzU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVyLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9IFwicnVubmluZ1wiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBkcml2ZXIgPSBmcmFtZWxvb3BEcml2ZXIsIG9uUGxheSwgc3RhcnRUaW1lIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghdGhpcy5kcml2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZHJpdmVyID0gZHJpdmVyKCh0aW1lc3RhbXApID0+IHRoaXMudGljayh0aW1lc3RhbXApKTtcbiAgICAgICAgfVxuICAgICAgICBvblBsYXkgJiYgb25QbGF5KCk7XG4gICAgICAgIGNvbnN0IG5vdyA9IHRoaXMuZHJpdmVyLm5vdygpO1xuICAgICAgICBpZiAodGhpcy5ob2xkVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBub3cgLSB0aGlzLmhvbGRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0YXJ0VGltZSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBzdGFydFRpbWUgIT09IG51bGwgJiYgc3RhcnRUaW1lICE9PSB2b2lkIDAgPyBzdGFydFRpbWUgOiB0aGlzLmNhbGNTdGFydFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHBsYXlTdGF0ZSB0byBydW5uaW5nIG9ubHkgYWZ0ZXIgd2UndmUgdXNlZCBpdCBpblxuICAgICAgICAgKiB0aGUgcHJldmlvdXMgbG9naWMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJydW5uaW5nXCI7XG4gICAgICAgIHRoaXMuZHJpdmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9IFwicGF1c2VkXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwicGF1c2VkXCI7XG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSAoX2EgPSB0aGlzLmN1cnJlbnRUaW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFwicnVubmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBlbmRpbmdQbGF5U3RhdGUgPSB0aGlzLnN0YXRlID0gXCJmaW5pc2hlZFwiO1xuICAgICAgICB0aGlzLmhvbGRUaW1lID0gbnVsbDtcbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImZpbmlzaGVkXCI7XG4gICAgICAgIGNvbnN0IHsgb25Db21wbGV0ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5jZWxUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2sodGhpcy5jYW5jZWxUaW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgfVxuICAgIHRlYXJkb3duKCkge1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJpZGxlXCI7XG4gICAgICAgIHRoaXMuc3RvcERyaXZlcigpO1xuICAgICAgICB0aGlzLnJlc29sdmVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmNhbmNlbFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnJlc29sdmVyLmNhbmNlbCgpO1xuICAgIH1cbiAgICBzdG9wRHJpdmVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuZHJpdmVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRyaXZlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuZHJpdmVyID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzYW1wbGUodGltZSkge1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2sodGltZSwgdHJ1ZSk7XG4gICAgfVxufVxuLy8gTGVnYWN5IGludGVyZmFjZVxuZnVuY3Rpb24gYW5pbWF0ZVZhbHVlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1haW5UaHJlYWRBbmltYXRpb24ob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IE1haW5UaHJlYWRBbmltYXRpb24sIGFuaW1hdGVWYWx1ZSB9O1xuIiwiLyoqXG4gKiBBIGxpc3Qgb2YgdmFsdWVzIHRoYXQgY2FuIGJlIGhhcmR3YXJlLWFjY2VsZXJhdGVkLlxuICovXG5jb25zdCBhY2NlbGVyYXRlZFZhbHVlcyA9IG5ldyBTZXQoW1xuICAgIFwib3BhY2l0eVwiLFxuICAgIFwiY2xpcFBhdGhcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwidHJhbnNmb3JtXCIsXG4gICAgLy8gVE9ETzogQ2FuIGJlIGFjY2VsZXJhdGVkIGJ1dCBjdXJyZW50bHkgZGlzYWJsZWQgdW50aWwgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MTQ5MTA5OCBpcyByZXNvbHZlZFxuICAgIC8vIG9yIHVudGlsIHdlIGltcGxlbWVudCBzdXBwb3J0IGZvciBsaW5lYXIoKSBlYXNpbmcuXG4gICAgLy8gXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbl0pO1xuXG5leHBvcnQgeyBhY2NlbGVyYXRlZFZhbHVlcyB9O1xuIiwiaW1wb3J0IHsgbWFwRWFzaW5nVG9OYXRpdmVFYXNpbmcgfSBmcm9tICdtb3Rpb24tZG9tJztcblxuZnVuY3Rpb24gc3RhcnRXYWFwaUFuaW1hdGlvbihlbGVtZW50LCB2YWx1ZU5hbWUsIGtleWZyYW1lcywgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gMzAwLCByZXBlYXQgPSAwLCByZXBlYXRUeXBlID0gXCJsb29wXCIsIGVhc2UgPSBcImVhc2VJbk91dFwiLCB0aW1lcywgfSA9IHt9KSB7XG4gICAgY29uc3Qga2V5ZnJhbWVPcHRpb25zID0geyBbdmFsdWVOYW1lXToga2V5ZnJhbWVzIH07XG4gICAgaWYgKHRpbWVzKVxuICAgICAgICBrZXlmcmFtZU9wdGlvbnMub2Zmc2V0ID0gdGltZXM7XG4gICAgY29uc3QgZWFzaW5nID0gbWFwRWFzaW5nVG9OYXRpdmVFYXNpbmcoZWFzZSwgZHVyYXRpb24pO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYW4gZWFzaW5nIGFycmF5LCBhcHBseSB0byBrZXlmcmFtZXMsIG5vdCBhbmltYXRpb24gYXMgYSB3aG9sZVxuICAgICAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVhc2luZykpXG4gICAgICAgIGtleWZyYW1lT3B0aW9ucy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgcmV0dXJuIGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZU9wdGlvbnMsIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6ICFBcnJheS5pc0FycmF5KGVhc2luZykgPyBlYXNpbmcgOiBcImxpbmVhclwiLFxuICAgICAgICBmaWxsOiBcImJvdGhcIixcbiAgICAgICAgaXRlcmF0aW9uczogcmVwZWF0ICsgMSxcbiAgICAgICAgZGlyZWN0aW9uOiByZXBlYXRUeXBlID09PSBcInJldmVyc2VcIiA/IFwiYWx0ZXJuYXRlXCIgOiBcIm5vcm1hbFwiLFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBzdGFydFdhYXBpQW5pbWF0aW9uIH07XG4iLCJpbXBvcnQgeyBtZW1vIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcblxuY29uc3Qgc3VwcG9ydHNXYWFwaSA9IC8qQF9fUFVSRV9fKi8gbWVtbygoKSA9PiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChFbGVtZW50LnByb3RvdHlwZSwgXCJhbmltYXRlXCIpKTtcblxuZXhwb3J0IHsgc3VwcG9ydHNXYWFwaSB9O1xuIiwiaW1wb3J0IHsgc3VwcG9ydHNMaW5lYXJFYXNpbmcsIGF0dGFjaFRpbWVsaW5lLCBpc0dlbmVyYXRvciwgaXNXYWFwaVN1cHBvcnRlZEVhc2luZyB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgbWlsbGlzZWNvbmRzVG9TZWNvbmRzLCBzZWNvbmRzVG9NaWxsaXNlY29uZHMsIG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgYW50aWNpcGF0ZSB9IGZyb20gJy4uLy4uL2Vhc2luZy9hbnRpY2lwYXRlLm1qcyc7XG5pbXBvcnQgeyBiYWNrSW5PdXQgfSBmcm9tICcuLi8uLi9lYXNpbmcvYmFjay5tanMnO1xuaW1wb3J0IHsgY2lyY0luT3V0IH0gZnJvbSAnLi4vLi4vZWFzaW5nL2NpcmMubWpzJztcbmltcG9ydCB7IERPTUtleWZyYW1lc1Jlc29sdmVyIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2RvbS9ET01LZXlmcmFtZXNSZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgQmFzZUFuaW1hdGlvbiB9IGZyb20gJy4vQmFzZUFuaW1hdGlvbi5tanMnO1xuaW1wb3J0IHsgTWFpblRocmVhZEFuaW1hdGlvbiB9IGZyb20gJy4vTWFpblRocmVhZEFuaW1hdGlvbi5tanMnO1xuaW1wb3J0IHsgYWNjZWxlcmF0ZWRWYWx1ZXMgfSBmcm9tICcuL3V0aWxzL2FjY2VsZXJhdGVkLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgc3RhcnRXYWFwaUFuaW1hdGlvbiB9IGZyb20gJy4vd2FhcGkvaW5kZXgubWpzJztcbmltcG9ydCB7IGdldEZpbmFsS2V5ZnJhbWUgfSBmcm9tICcuL3dhYXBpL3V0aWxzL2dldC1maW5hbC1rZXlmcmFtZS5tanMnO1xuaW1wb3J0IHsgc3VwcG9ydHNXYWFwaSB9IGZyb20gJy4vd2FhcGkvdXRpbHMvc3VwcG9ydHMtd2FhcGkubWpzJztcblxuLyoqXG4gKiAxMG1zIGlzIGNob3NlbiBoZXJlIGFzIGl0IHN0cmlrZXMgYSBiYWxhbmNlIGJldHdlZW4gc21vb3RoXG4gKiByZXN1bHRzIChtb3JlIHRoYW4gb25lIGtleWZyYW1lIHBlciBmcmFtZSBhdCA2MGZwcykgYW5kXG4gKiBrZXlmcmFtZSBxdWFudGl0eS5cbiAqL1xuY29uc3Qgc2FtcGxlRGVsdGEgPSAxMDsgLy9tc1xuLyoqXG4gKiBJbXBsZW1lbnQgYSBwcmFjdGljYWwgbWF4IGR1cmF0aW9uIGZvciBrZXlmcmFtZSBnZW5lcmF0aW9uXG4gKiB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG4gKi9cbmNvbnN0IG1heER1cmF0aW9uID0gMjAwMDA7XG4vKipcbiAqIENoZWNrIGlmIGFuIGFuaW1hdGlvbiBjYW4gcnVuIG5hdGl2ZWx5IHZpYSBXQUFQSSBvciByZXF1aXJlcyBwcmVnZW5lcmF0ZWQga2V5ZnJhbWVzLlxuICogV0FBUEkgZG9lc24ndCBzdXBwb3J0IHNwcmluZyBvciBmdW5jdGlvbiBlYXNpbmdzIHNvIHdlIHJ1biB0aGVzZSBhcyBKUyBhbmltYXRpb24gYmVmb3JlXG4gKiBoYW5kaW5nIG9mZi5cbiAqL1xuZnVuY3Rpb24gcmVxdWlyZXNQcmVnZW5lcmF0ZWRLZXlmcmFtZXMob3B0aW9ucykge1xuICAgIHJldHVybiAoaXNHZW5lcmF0b3Iob3B0aW9ucy50eXBlKSB8fFxuICAgICAgICBvcHRpb25zLnR5cGUgPT09IFwic3ByaW5nXCIgfHxcbiAgICAgICAgIWlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcob3B0aW9ucy5lYXNlKSk7XG59XG5mdW5jdGlvbiBwcmVnZW5lcmF0ZUtleWZyYW1lcyhrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBtYWluLXRocmVhZCBhbmltYXRpb24gdG8gcHJlZ2VuZXJhdGUga2V5ZnJhbWVzLlxuICAgICAqIFdlIHNhbXBsZSB0aGlzIGF0IHJlZ3VsYXIgaW50ZXJ2YWxzIHRvIGdlbmVyYXRlIGtleWZyYW1lcyB0aGF0IHdlIHRoZW5cbiAgICAgKiBsaW5lYXJseSBpbnRlcnBvbGF0ZSBiZXR3ZWVuLlxuICAgICAqL1xuICAgIGNvbnN0IHNhbXBsZUFuaW1hdGlvbiA9IG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAga2V5ZnJhbWVzLFxuICAgICAgICByZXBlYXQ6IDAsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBpc0dlbmVyYXRvcjogdHJ1ZSxcbiAgICB9KTtcbiAgICBsZXQgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZToga2V5ZnJhbWVzWzBdIH07XG4gICAgY29uc3QgcHJlZ2VuZXJhdGVkS2V5ZnJhbWVzID0gW107XG4gICAgLyoqXG4gICAgICogQmFpbCBhZnRlciAyMCBzZWNvbmRzIG9mIHByZS1nZW5lcmF0ZWQga2V5ZnJhbWVzIGFzIGl0J3MgbGlrZWx5XG4gICAgICogd2UncmUgaGVhZGluZyBmb3IgYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgKi9cbiAgICBsZXQgdCA9IDA7XG4gICAgd2hpbGUgKCFzdGF0ZS5kb25lICYmIHQgPCBtYXhEdXJhdGlvbikge1xuICAgICAgICBzdGF0ZSA9IHNhbXBsZUFuaW1hdGlvbi5zYW1wbGUodCk7XG4gICAgICAgIHByZWdlbmVyYXRlZEtleWZyYW1lcy5wdXNoKHN0YXRlLnZhbHVlKTtcbiAgICAgICAgdCArPSBzYW1wbGVEZWx0YTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZXM6IHVuZGVmaW5lZCxcbiAgICAgICAga2V5ZnJhbWVzOiBwcmVnZW5lcmF0ZWRLZXlmcmFtZXMsXG4gICAgICAgIGR1cmF0aW9uOiB0IC0gc2FtcGxlRGVsdGEsXG4gICAgICAgIGVhc2U6IFwibGluZWFyXCIsXG4gICAgfTtcbn1cbmNvbnN0IHVuc3VwcG9ydGVkRWFzaW5nRnVuY3Rpb25zID0ge1xuICAgIGFudGljaXBhdGUsXG4gICAgYmFja0luT3V0LFxuICAgIGNpcmNJbk91dCxcbn07XG5mdW5jdGlvbiBpc1Vuc3VwcG9ydGVkRWFzZShrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIHVuc3VwcG9ydGVkRWFzaW5nRnVuY3Rpb25zO1xufVxuY2xhc3MgQWNjZWxlcmF0ZWRBbmltYXRpb24gZXh0ZW5kcyBCYXNlQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBrZXlmcmFtZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IG5ldyBET01LZXlmcmFtZXNSZXNvbHZlcihrZXlmcmFtZXMsIChyZXNvbHZlZEtleWZyYW1lcywgZmluYWxLZXlmcmFtZSkgPT4gdGhpcy5vbktleWZyYW1lc1Jlc29sdmVkKHJlc29sdmVkS2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKSwgbmFtZSwgbW90aW9uVmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnJlc29sdmVyLnNjaGVkdWxlUmVzb2x2ZSgpO1xuICAgIH1cbiAgICBpbml0UGxheWJhY2soa2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKSB7XG4gICAgICAgIGxldCB7IGR1cmF0aW9uID0gMzAwLCB0aW1lcywgZWFzZSwgdHlwZSwgbW90aW9uVmFsdWUsIG5hbWUsIHN0YXJ0VGltZSwgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGVsZW1lbnQgaGFzIHNpbmNlIGJlZW4gdW5tb3VudGVkLCByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGVcbiAgICAgICAgICogdGhlIGFuaW1hdGlvbiBmYWlsZWQgdG8gaW5pdGlhbGlzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIW1vdGlvblZhbHVlLm93bmVyIHx8ICFtb3Rpb25WYWx1ZS5vd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB1c2VyIGhhcyBwcm92aWRlZCBhbiBlYXNpbmcgZnVuY3Rpb24gbmFtZSB0aGF0IGlzbid0IHN1cHBvcnRlZFxuICAgICAgICAgKiBieSBXQUFQSSAobGlrZSBcImFudGljaXBhdGVcIiksIHdlIG5lZWQgdG8gcHJvdmlkZSB0aGUgY29ycmVzc3BvbmRpbmdcbiAgICAgICAgICogZnVuY3Rpb24uIFRoaXMgd2lsbCBsYXRlciBnZXQgY29udmVydGVkIHRvIGEgbGluZWFyKCkgZWFzaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBlYXNlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICBzdXBwb3J0c0xpbmVhckVhc2luZygpICYmXG4gICAgICAgICAgICBpc1Vuc3VwcG9ydGVkRWFzZShlYXNlKSkge1xuICAgICAgICAgICAgZWFzZSA9IHVuc3VwcG9ydGVkRWFzaW5nRnVuY3Rpb25zW2Vhc2VdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGFuaW1hdGlvbiBuZWVkcyBwcmUtZ2VuZXJhdGVkIGtleWZyYW1lcyB0aGVuIGdlbmVyYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlcXVpcmVzUHJlZ2VuZXJhdGVkS2V5ZnJhbWVzKHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Db21wbGV0ZSwgb25VcGRhdGUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCAuLi5vcHRpb25zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBwcmVnZW5lcmF0ZWRBbmltYXRpb24gPSBwcmVnZW5lcmF0ZUtleWZyYW1lcyhrZXlmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAga2V5ZnJhbWVzID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLmtleWZyYW1lcztcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB2ZXJ5IHNob3J0IGFuaW1hdGlvbiwgZW5zdXJlIHdlIGhhdmVcbiAgICAgICAgICAgIC8vIGF0IGxlYXN0IHR3byBrZXlmcmFtZXMgdG8gYW5pbWF0ZSBiZXR3ZWVuIGFzIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyBjYW4ndCBhbmltYXRlIGJldHdlZW4gYSBzaW5nbGUga2V5ZnJhbWUuXG4gICAgICAgICAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGtleWZyYW1lc1sxXSA9IGtleWZyYW1lc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGR1cmF0aW9uID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLmR1cmF0aW9uO1xuICAgICAgICAgICAgdGltZXMgPSBwcmVnZW5lcmF0ZWRBbmltYXRpb24udGltZXM7XG4gICAgICAgICAgICBlYXNlID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLmVhc2U7XG4gICAgICAgICAgICB0eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmltYXRpb24gPSBzdGFydFdhYXBpQW5pbWF0aW9uKG1vdGlvblZhbHVlLm93bmVyLmN1cnJlbnQsIG5hbWUsIGtleWZyYW1lcywgeyAuLi50aGlzLm9wdGlvbnMsIGR1cmF0aW9uLCB0aW1lcywgZWFzZSB9KTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGJyb3dzZXIgY2FsY3VsYXRlZCBzdGFydFRpbWUgd2l0aCBvbmUgc3luY2hyb25pc2VkIHRvIG90aGVyIEpTXG4gICAgICAgIC8vIGFuZCBXQUFQSSBhbmltYXRpb25zIHN0YXJ0aW5nIHRoaXMgZXZlbnQgbG9vcC5cbiAgICAgICAgYW5pbWF0aW9uLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSAhPT0gbnVsbCAmJiBzdGFydFRpbWUgIT09IHZvaWQgMCA/IHN0YXJ0VGltZSA6IHRoaXMuY2FsY1N0YXJ0VGltZSgpO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nVGltZWxpbmUpIHtcbiAgICAgICAgICAgIGF0dGFjaFRpbWVsaW5lKGFuaW1hdGlvbiwgdGhpcy5wZW5kaW5nVGltZWxpbmUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZWxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZWZlciB0aGUgYG9uZmluaXNoYCBwcm9wIGFzIGl0J3MgbW9yZSB3aWRlbHkgc3VwcG9ydGVkIHRoYW5cbiAgICAgICAgICAgICAqIHRoZSBgZmluaXNoZWRgIHByb21pc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSGVyZSwgd2Ugc3luY2hyb25vdXNseSBzZXQgdGhlIHByb3ZpZGVkIE1vdGlvblZhbHVlIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAqIGtleWZyYW1lLiBJZiB3ZSBkaWRuJ3QsIHdoZW4gdGhlIFdBQVBJIGFuaW1hdGlvbiBpcyBmaW5pc2hlZCBpdCB3b3VsZFxuICAgICAgICAgICAgICogYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50IHdoaWNoIHdvdWxkIHRoZW4gcmV2ZXJ0IHRvIGl0cyBvbGQgc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvbkNvbXBsZXRlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KGdldEZpbmFsS2V5ZnJhbWUoa2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMsIGZpbmFsS2V5ZnJhbWUpKTtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1lcyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBlYXNlLFxuICAgICAgICAgICAga2V5ZnJhbWVzOiBrZXlmcmFtZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhkdXJhdGlvbik7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhhbmltYXRpb24uY3VycmVudFRpbWUgfHwgMCk7XG4gICAgfVxuICAgIHNldCB0aW1lKG5ld1RpbWUpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24uY3VycmVudFRpbWUgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMobmV3VGltZSk7XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24ucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICBzZXQgc3BlZWQobmV3U3BlZWQpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24ucGxheWJhY2tSYXRlID0gbmV3U3BlZWQ7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiBcImlkbGVcIjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnBsYXlTdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIC8vIENvZXJjZSB0byBudW1iZXIgYXMgVHlwZVNjcmlwdCBpbmNvcnJlY3RseSB0eXBlcyB0aGlzXG4gICAgICAgIC8vIGFzIENTU051bWJlcmlzaFxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBEb2N1bWVudFRpbWVsaW5lIHdpdGggYW5vdGhlciBBbmltYXRpb25UaW1lbGluZS5cbiAgICAgKiBDdXJyZW50bHkgdXNlZCBmb3Igc2Nyb2xsIGFuaW1hdGlvbnMuXG4gICAgICovXG4gICAgYXR0YWNoVGltZWxpbmUodGltZWxpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgYXR0YWNoVGltZWxpbmUoYW5pbWF0aW9uLCB0aW1lbGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzU3RvcHBlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvbi5wbGF5KCk7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnJlc29sdmVyLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImlkbGVcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uLCBrZXlmcmFtZXMsIGR1cmF0aW9uLCB0eXBlLCBlYXNlLCB0aW1lcyB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIGlmIChhbmltYXRpb24ucGxheVN0YXRlID09PSBcImlkbGVcIiB8fFxuICAgICAgICAgICAgYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdBQVBJIGRvZXNuJ3QgbmF0aXZlbHkgaGF2ZSBhbnkgaW50ZXJydXB0aW9uIGNhcGFiaWxpdGllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogUmF0aGVyIHRoYW4gcmVhZCBjb21taXRlZCBzdHlsZXMgYmFjayBvdXQgb2YgdGhlIERPTSwgd2UgY2FuXG4gICAgICAgICAqIGNyZWF0ZSBhIHJlbmRlcmxlc3MgSlMgYW5pbWF0aW9uIGFuZCBzYW1wbGUgaXQgdHdpY2UgdG8gY2FsY3VsYXRlXG4gICAgICAgICAqIGl0cyBjdXJyZW50IHZhbHVlLCBcInByZXZpb3VzXCIgdmFsdWUsIGFuZCB0aGVyZWZvcmUgYWxsb3dcbiAgICAgICAgICogTW90aW9uIHRvIGNhbGN1bGF0ZSB2ZWxvY2l0eSBmb3IgYW55IHN1YnNlcXVlbnQgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMudGltZSkge1xuICAgICAgICAgICAgY29uc3QgeyBtb3Rpb25WYWx1ZSwgb25VcGRhdGUsIG9uQ29tcGxldGUsIGVsZW1lbnQsIC4uLm9wdGlvbnMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZUFuaW1hdGlvbiA9IG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKHtcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIGVhc2UsXG4gICAgICAgICAgICAgICAgdGltZXMsXG4gICAgICAgICAgICAgICAgaXNHZW5lcmF0b3I6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVRpbWUgPSBzZWNvbmRzVG9NaWxsaXNlY29uZHModGhpcy50aW1lKTtcbiAgICAgICAgICAgIG1vdGlvblZhbHVlLnNldFdpdGhWZWxvY2l0eShzYW1wbGVBbmltYXRpb24uc2FtcGxlKHNhbXBsZVRpbWUgLSBzYW1wbGVEZWx0YSkudmFsdWUsIHNhbXBsZUFuaW1hdGlvbi5zYW1wbGUoc2FtcGxlVGltZSkudmFsdWUsIHNhbXBsZURlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBvblN0b3AgJiYgb25TdG9wKCk7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXNvbHZlZC5hbmltYXRpb24uZmluaXNoKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQuYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgIH1cbiAgICBzdGF0aWMgc3VwcG9ydHMob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1vdGlvblZhbHVlLCBuYW1lLCByZXBlYXREZWxheSwgcmVwZWF0VHlwZSwgZGFtcGluZywgdHlwZSB9ID0gb3B0aW9ucztcbiAgICAgICAgaWYgKCFtb3Rpb25WYWx1ZSB8fFxuICAgICAgICAgICAgIW1vdGlvblZhbHVlLm93bmVyIHx8XG4gICAgICAgICAgICAhKG1vdGlvblZhbHVlLm93bmVyLmN1cnJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IG9uVXBkYXRlLCB0cmFuc2Zvcm1UZW1wbGF0ZSB9ID0gbW90aW9uVmFsdWUub3duZXIuZ2V0UHJvcHMoKTtcbiAgICAgICAgcmV0dXJuIChzdXBwb3J0c1dhYXBpKCkgJiZcbiAgICAgICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgIGFjY2VsZXJhdGVkVmFsdWVzLmhhcyhuYW1lKSAmJlxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBvdXRwdXR0aW5nIHZhbHVlcyB0byBvblVwZGF0ZSB0aGVuIHdlIGNhbid0IHVzZSBXQUFQSSBhcyB0aGVyZSdzXG4gICAgICAgICAgICAgKiBubyB3YXkgdG8gcmVhZCB0aGUgdmFsdWUgZnJvbSBXQUFQSSBldmVyeSBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgIW9uVXBkYXRlICYmXG4gICAgICAgICAgICAhdHJhbnNmb3JtVGVtcGxhdGUgJiZcbiAgICAgICAgICAgICFyZXBlYXREZWxheSAmJlxuICAgICAgICAgICAgcmVwZWF0VHlwZSAhPT0gXCJtaXJyb3JcIiAmJlxuICAgICAgICAgICAgZGFtcGluZyAhPT0gMCAmJlxuICAgICAgICAgICAgdHlwZSAhPT0gXCJpbmVydGlhXCIpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWNjZWxlcmF0ZWRBbmltYXRpb24gfTtcbiIsImltcG9ydCB7IHRyYW5zZm9ybVByb3BzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcblxuY29uc3QgdW5kZXJEYW1wZWRTcHJpbmcgPSB7XG4gICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICBzdGlmZm5lc3M6IDUwMCxcbiAgICBkYW1waW5nOiAyNSxcbiAgICByZXN0U3BlZWQ6IDEwLFxufTtcbmNvbnN0IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcgPSAodGFyZ2V0KSA9PiAoe1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1NTAsXG4gICAgZGFtcGluZzogdGFyZ2V0ID09PSAwID8gMiAqIE1hdGguc3FydCg1NTApIDogMzAsXG4gICAgcmVzdFNwZWVkOiAxMCxcbn0pO1xuY29uc3Qga2V5ZnJhbWVzVHJhbnNpdGlvbiA9IHtcbiAgICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICAgIGR1cmF0aW9uOiAwLjgsXG59O1xuLyoqXG4gKiBEZWZhdWx0IGVhc2luZyBjdXJ2ZSBpcyBhIHNsaWdodGx5IHNoYWxsb3dlciB2ZXJzaW9uIG9mXG4gKiB0aGUgZGVmYXVsdCBicm93c2VyIGVhc2luZyBjdXJ2ZS5cbiAqL1xuY29uc3QgZWFzZSA9IHtcbiAgICB0eXBlOiBcImtleWZyYW1lc1wiLFxuICAgIGVhc2U6IFswLjI1LCAwLjEsIDAuMzUsIDFdLFxuICAgIGR1cmF0aW9uOiAwLjMsXG59O1xuY29uc3QgZ2V0RGVmYXVsdFRyYW5zaXRpb24gPSAodmFsdWVLZXksIHsga2V5ZnJhbWVzIH0pID0+IHtcbiAgICBpZiAoa2V5ZnJhbWVzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1RyYW5zaXRpb247XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyh2YWx1ZUtleSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlS2V5LnN0YXJ0c1dpdGgoXCJzY2FsZVwiKVxuICAgICAgICAgICAgPyBjcml0aWNhbGx5RGFtcGVkU3ByaW5nKGtleWZyYW1lc1sxXSlcbiAgICAgICAgICAgIDogdW5kZXJEYW1wZWRTcHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBlYXNlO1xufTtcblxuZXhwb3J0IHsgZ2V0RGVmYXVsdFRyYW5zaXRpb24gfTtcbiIsIi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYSB0cmFuc2l0aW9uIGlzIGRlZmluZWQgb24gYSBnaXZlbiBUcmFuc2l0aW9uLlxuICogVGhpcyBmaWx0ZXJzIG91dCBvcmNoZXN0cmF0aW9uIG9wdGlvbnMgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgYW55IG9wdGlvbnMgYXJlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoeyB3aGVuLCBkZWxheTogX2RlbGF5LCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXksIGZyb20sIGVsYXBzZWQsIC4uLnRyYW5zaXRpb24gfSkge1xuICAgIHJldHVybiAhIU9iamVjdC5rZXlzKHRyYW5zaXRpb24pLmxlbmd0aDtcbn1cblxuZXhwb3J0IHsgaXNUcmFuc2l0aW9uRGVmaW5lZCB9O1xuIiwiaW1wb3J0IHsgZ2V0VmFsdWVUcmFuc2l0aW9uLCBHcm91cFBsYXliYWNrQ29udHJvbHMgfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuaW1wb3J0IHsgTW90aW9uR2xvYmFsQ29uZmlnIH0gZnJvbSAnLi4vLi4vdXRpbHMvR2xvYmFsQ29uZmlnLm1qcyc7XG5pbXBvcnQgeyBpbnN0YW50QW5pbWF0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaW5zdGFudC10cmFuc2l0aW9uLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyBBY2NlbGVyYXRlZEFuaW1hdGlvbiB9IGZyb20gJy4uL2FuaW1hdG9ycy9BY2NlbGVyYXRlZEFuaW1hdGlvbi5tanMnO1xuaW1wb3J0IHsgTWFpblRocmVhZEFuaW1hdGlvbiB9IGZyb20gJy4uL2FuaW1hdG9ycy9NYWluVGhyZWFkQW5pbWF0aW9uLm1qcyc7XG5pbXBvcnQgeyBnZXRGaW5hbEtleWZyYW1lIH0gZnJvbSAnLi4vYW5pbWF0b3JzL3dhYXBpL3V0aWxzL2dldC1maW5hbC1rZXlmcmFtZS5tanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFRyYW5zaXRpb24gfSBmcm9tICcuLi91dGlscy9kZWZhdWx0LXRyYW5zaXRpb25zLm1qcyc7XG5pbXBvcnQgeyBpc1RyYW5zaXRpb25EZWZpbmVkIH0gZnJvbSAnLi4vdXRpbHMvaXMtdHJhbnNpdGlvbi1kZWZpbmVkLm1qcyc7XG5cbmNvbnN0IGFuaW1hdGVNb3Rpb25WYWx1ZSA9IChuYW1lLCB2YWx1ZSwgdGFyZ2V0LCB0cmFuc2l0aW9uID0ge30sIGVsZW1lbnQsIGlzSGFuZG9mZikgPT4gKG9uQ29tcGxldGUpID0+IHtcbiAgICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwgbmFtZSkgfHwge307XG4gICAgLyoqXG4gICAgICogTW9zdCB0cmFuc2l0aW9uIHZhbHVlcyBhcmUgY3VycmVudGx5IGNvbXBsZXRlbHkgb3ZlcndyaXR0ZW4gYnkgdmFsdWUtc3BlY2lmaWNcbiAgICAgKiB0cmFuc2l0aW9ucy4gSW4gdGhlIGZ1dHVyZSBpdCdkIGJlIG5pY2VyIHRvIGJsZW5kIHRoZXNlIHRyYW5zaXRpb25zLiBCdXQgZm9yIG5vd1xuICAgICAqIGRlbGF5IGFjdHVhbGx5IGRvZXMgaW5oZXJpdCBmcm9tIHRoZSByb290IHRyYW5zaXRpb24gaWYgbm90IHZhbHVlLXNwZWNpZmljLlxuICAgICAqL1xuICAgIGNvbnN0IGRlbGF5ID0gdmFsdWVUcmFuc2l0aW9uLmRlbGF5IHx8IHRyYW5zaXRpb24uZGVsYXkgfHwgMDtcbiAgICAvKipcbiAgICAgKiBFbGFwc2VkIGlzbid0IGEgcHVibGljIHRyYW5zaXRpb24gb3B0aW9uIGJ1dCBjYW4gYmUgcGFzc2VkIHRocm91Z2ggZnJvbVxuICAgICAqIG9wdGltaXplZCBhcHBlYXIgZWZmZWN0cyBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgbGV0IHsgZWxhcHNlZCA9IDAgfSA9IHRyYW5zaXRpb247XG4gICAgZWxhcHNlZCA9IGVsYXBzZWQgLSBzZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXkpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICBrZXlmcmFtZXM6IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldCA6IFtudWxsLCB0YXJnZXRdLFxuICAgICAgICBlYXNlOiBcImVhc2VPdXRcIixcbiAgICAgICAgdmVsb2NpdHk6IHZhbHVlLmdldFZlbG9jaXR5KCksXG4gICAgICAgIC4uLnZhbHVlVHJhbnNpdGlvbixcbiAgICAgICAgZGVsYXk6IC1lbGFwc2VkLFxuICAgICAgICBvblVwZGF0ZTogKHYpID0+IHtcbiAgICAgICAgICAgIHZhbHVlLnNldCh2KTtcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUodik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1vdGlvblZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZWxlbWVudDogaXNIYW5kb2ZmID8gdW5kZWZpbmVkIDogZWxlbWVudCxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3Mgbm8gdHJhbnNpdGlvbiBkZWZpbmVkIGZvciB0aGlzIHZhbHVlLCB3ZSBjYW4gZ2VuZXJhdGVcbiAgICAgKiB1bnFpdWUgdHJhbnNpdGlvbiBzZXR0aW5ncyBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBpZiAoIWlzVHJhbnNpdGlvbkRlZmluZWQodmFsdWVUcmFuc2l0aW9uKSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmdldERlZmF1bHRUcmFuc2l0aW9uKG5hbWUsIG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCb3RoIFdBQVBJIGFuZCBvdXIgaW50ZXJuYWwgYW5pbWF0aW9uIGZ1bmN0aW9ucyB1c2UgZHVyYXRpb25zXG4gICAgICogYXMgZGVmaW5lZCBieSBtaWxsaXNlY29uZHMsIHdoaWxlIG91ciBleHRlcm5hbCBBUEkgZGVmaW5lcyB0aGVtXG4gICAgICogYXMgc2Vjb25kcy5cbiAgICAgKi9cbiAgICBpZiAob3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG9wdGlvbnMuZHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXBlYXREZWxheSkge1xuICAgICAgICBvcHRpb25zLnJlcGVhdERlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG9wdGlvbnMucmVwZWF0RGVsYXkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5rZXlmcmFtZXNbMF0gPSBvcHRpb25zLmZyb207XG4gICAgfVxuICAgIGxldCBzaG91bGRTa2lwID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKG9wdGlvbnMuZHVyYXRpb24gPT09IDAgJiYgIW9wdGlvbnMucmVwZWF0RGVsYXkpKSB7XG4gICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSAwO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50IHx8XG4gICAgICAgIE1vdGlvbkdsb2JhbENvbmZpZy5za2lwQW5pbWF0aW9ucykge1xuICAgICAgICBzaG91bGRTa2lwID0gdHJ1ZTtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIG9wdGlvbnMuZGVsYXkgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBjYW4gb3IgbXVzdCBza2lwIGNyZWF0aW5nIHRoZSBhbmltYXRpb24sIGFuZCBhcHBseSBvbmx5XG4gICAgICogdGhlIGZpbmFsIGtleWZyYW1lLCBkbyBzby4gV2UgYWxzbyBjaGVjayBvbmNlIGtleWZyYW1lcyBhcmUgcmVzb2x2ZWQgYnV0XG4gICAgICogdGhpcyBlYXJseSBjaGVjayBwcmV2ZW50cyB0aGUgbmVlZCB0byBjcmVhdGUgYW4gYW5pbWF0aW9uIGF0IGFsbC5cbiAgICAgKi9cbiAgICBpZiAoc2hvdWxkU2tpcCAmJiAhaXNIYW5kb2ZmICYmIHZhbHVlLmdldCgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZSA9IGdldEZpbmFsS2V5ZnJhbWUob3B0aW9ucy5rZXlmcmFtZXMsIHZhbHVlVHJhbnNpdGlvbik7XG4gICAgICAgIGlmIChmaW5hbEtleWZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyYW1lLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZShmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2Ugc3RpbGwgd2FudCB0byByZXR1cm4gc29tZSBhbmltYXRpb24gY29udHJvbHMgaGVyZSByYXRoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBHcm91cFBsYXliYWNrQ29udHJvbHMoW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuaW1hdGUgdmlhIFdBQVBJIGlmIHBvc3NpYmxlLiBJZiB0aGlzIGlzIGEgaGFuZG9mZiBhbmltYXRpb24sIHRoZSBvcHRpbWlzZWQgYW5pbWF0aW9uIHdpbGwgYmUgcnVubmluZyB2aWFcbiAgICAgKiBXQUFQSS4gVGhlcmVmb3JlLCB0aGlzIGFuaW1hdGlvbiBtdXN0IGJlIEpTIHRvIGVuc3VyZSBpdCBydW5zIFwidW5kZXJcIiB0aGVcbiAgICAgKiBvcHRpbWlzZWQgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGlmICghaXNIYW5kb2ZmICYmIEFjY2VsZXJhdGVkQW5pbWF0aW9uLnN1cHBvcnRzKG9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWNjZWxlcmF0ZWRBbmltYXRpb24ob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IE1haW5UaHJlYWRBbmltYXRpb24ob3B0aW9ucyk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgYW5pbWF0ZU1vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyBnZXRWYWx1ZVRyYW5zaXRpb24gfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IHBvc2l0aW9uYWxLZXlzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2h0bWwvdXRpbHMva2V5cy1wb3NpdGlvbi5tanMnO1xuaW1wb3J0IHsgc2V0VGFyZ2V0IH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL3NldHRlcnMubWpzJztcbmltcG9ydCB7IGFkZFZhbHVlVG9XaWxsQ2hhbmdlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXNlLXdpbGwtY2hhbmdlL2FkZC13aWxsLWNoYW5nZS5tanMnO1xuaW1wb3J0IHsgZ2V0T3B0aW1pc2VkQXBwZWFySWQgfSBmcm9tICcuLi9vcHRpbWl6ZWQtYXBwZWFyL2dldC1hcHBlYXItaWQubWpzJztcbmltcG9ydCB7IGFuaW1hdGVNb3Rpb25WYWx1ZSB9IGZyb20gJy4vbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG4vKipcbiAqIERlY2lkZSB3aGV0aGVyIHdlIHNob3VsZCBibG9jayB0aGlzIGFuaW1hdGlvbi4gUHJldmlvdXNseSwgd2UgYWNoaWV2ZWQgdGhpc1xuICoganVzdCBieSBjaGVja2luZyB3aGV0aGVyIHRoZSBrZXkgd2FzIGxpc3RlZCBpbiBwcm90ZWN0ZWRLZXlzLCBidXQgdGhpc1xuICogcG9zZWQgcHJvYmxlbXMgaWYgYW4gYW5pbWF0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgYWZ0ZXJDaGlsZHJlbiBhbmQgcHJvdGVjdGVkS2V5c1xuICogaGFkIGJlZW4gc2V0IHRvIHRydWUgaW4gdGhlIG1lYW50aW1lLlxuICovXG5mdW5jdGlvbiBzaG91bGRCbG9ja0FuaW1hdGlvbih7IHByb3RlY3RlZEtleXMsIG5lZWRzQW5pbWF0aW5nIH0sIGtleSkge1xuICAgIGNvbnN0IHNob3VsZEJsb2NrID0gcHJvdGVjdGVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG5lZWRzQW5pbWF0aW5nW2tleV0gIT09IHRydWU7XG4gICAgbmVlZHNBbmltYXRpbmdba2V5XSA9IGZhbHNlO1xuICAgIHJldHVybiBzaG91bGRCbG9jaztcbn1cbmZ1bmN0aW9uIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgdGFyZ2V0QW5kVHJhbnNpdGlvbiwgeyBkZWxheSA9IDAsIHRyYW5zaXRpb25PdmVycmlkZSwgdHlwZSB9ID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IHsgdHJhbnNpdGlvbiA9IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSwgdHJhbnNpdGlvbkVuZCwgLi4udGFyZ2V0IH0gPSB0YXJnZXRBbmRUcmFuc2l0aW9uO1xuICAgIGlmICh0cmFuc2l0aW9uT3ZlcnJpZGUpXG4gICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uT3ZlcnJpZGU7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IGFuaW1hdGlvblR5cGVTdGF0ZSA9IHR5cGUgJiZcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSAmJlxuICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLmdldFN0YXRlKClbdHlwZV07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXksIChfYSA9IHZpc3VhbEVsZW1lbnQubGF0ZXN0VmFsdWVzW2tleV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwpO1xuICAgICAgICBjb25zdCB2YWx1ZVRhcmdldCA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAodmFsdWVUYXJnZXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKGFuaW1hdGlvblR5cGVTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZEJsb2NrQW5pbWF0aW9uKGFuaW1hdGlvblR5cGVTdGF0ZSwga2V5KSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgLi4uZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24gfHwge30sIGtleSksXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGEgdmFsdWUgaXMgYmVpbmcgYW5pbWF0ZWQsIGNoZWNrXG4gICAgICAgICAqIHRvIHNlZSBpZiB3ZSdyZSBoYW5kbGluZyBvZmYgZnJvbSBhbiBleGlzdGluZyBhbmltYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaXNIYW5kb2ZmID0gZmFsc2U7XG4gICAgICAgIGlmICh3aW5kb3cuTW90aW9uSGFuZG9mZkFuaW1hdGlvbikge1xuICAgICAgICAgICAgY29uc3QgYXBwZWFySWQgPSBnZXRPcHRpbWlzZWRBcHBlYXJJZCh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChhcHBlYXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmQW5pbWF0aW9uKGFwcGVhcklkLCBrZXksIGZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzSGFuZG9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZFZhbHVlVG9XaWxsQ2hhbmdlKHZpc3VhbEVsZW1lbnQsIGtleSk7XG4gICAgICAgIHZhbHVlLnN0YXJ0KGFuaW1hdGVNb3Rpb25WYWx1ZShrZXksIHZhbHVlLCB2YWx1ZVRhcmdldCwgdmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gJiYgcG9zaXRpb25hbEtleXMuaGFzKGtleSlcbiAgICAgICAgICAgID8geyB0eXBlOiBmYWxzZSB9XG4gICAgICAgICAgICA6IHZhbHVlVHJhbnNpdGlvbiwgdmlzdWFsRWxlbWVudCwgaXNIYW5kb2ZmKSk7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHZhbHVlLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgUHJvbWlzZS5hbGwoYW5pbWF0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbn1cblxuZXhwb3J0IHsgYW5pbWF0ZVRhcmdldCB9O1xuIiwiaW1wb3J0IHsgcmVzb2x2ZVZhcmlhbnQgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvcmVzb2x2ZS1keW5hbWljLXZhcmlhbnRzLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlVGFyZ2V0IH0gZnJvbSAnLi92aXN1YWwtZWxlbWVudC10YXJnZXQubWpzJztcblxuZnVuY3Rpb24gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy50eXBlID09PSBcImV4aXRcIlxuICAgICAgICA/IChfYSA9IHZpc3VhbEVsZW1lbnQucHJlc2VuY2VDb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VzdG9tXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBsZXQgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IH0gPSByZXNvbHZlZCB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGEgdmFyaWFudCwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGl0IGFzIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHJlc29sdmUgYSBQcm9taXNlIGltbWVkaWF0ZWx5IGZvciBhIGNvbXBvc2FibGUgbm8tb3AuXG4gICAgICovXG4gICAgY29uc3QgZ2V0QW5pbWF0aW9uID0gcmVzb2x2ZWRcbiAgICAgICAgPyAoKSA9PiBQcm9taXNlLmFsbChhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkLCBvcHRpb25zKSlcbiAgICAgICAgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGNoaWxkcmVuLCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHJ1bnMgYWxsIHRoZWlyIGFuaW1hdGlvbnMuXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIGNvbnN0IGdldENoaWxkQW5pbWF0aW9ucyA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuICYmIHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemVcbiAgICAgICAgPyAoZm9yd2FyZERlbGF5ID0gMCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICA6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0cmFuc2l0aW9uIGV4cGxpY2l0bHkgZGVmaW5lcyBhIFwid2hlblwiIG9wdGlvbiwgd2UgbmVlZCB0byByZXNvbHZlIGVpdGhlclxuICAgICAqIHRoaXMgYW5pbWF0aW9uIG9yIGFsbCBjaGlsZHJlbiBhbmltYXRpb25zIGJlZm9yZSBwbGF5aW5nIHRoZSBvdGhlci5cbiAgICAgKi9cbiAgICBjb25zdCB7IHdoZW4gfSA9IHRyYW5zaXRpb247XG4gICAgaWYgKHdoZW4pIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBsYXN0XSA9IHdoZW4gPT09IFwiYmVmb3JlQ2hpbGRyZW5cIlxuICAgICAgICAgICAgPyBbZ2V0QW5pbWF0aW9uLCBnZXRDaGlsZEFuaW1hdGlvbnNdXG4gICAgICAgICAgICA6IFtnZXRDaGlsZEFuaW1hdGlvbnMsIGdldEFuaW1hdGlvbl07XG4gICAgICAgIHJldHVybiBmaXJzdCgpLnRoZW4oKCkgPT4gbGFzdCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uKCksIGdldENoaWxkQW5pbWF0aW9ucyhvcHRpb25zLmRlbGF5KV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuID0gMCwgc3RhZ2dlckRpcmVjdGlvbiA9IDEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgbWF4U3RhZ2dlckR1cmF0aW9uID0gKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgICBjb25zdCBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbiA9IHN0YWdnZXJEaXJlY3Rpb24gPT09IDFcbiAgICAgICAgPyAoaSA9IDApID0+IGkgKiBzdGFnZ2VyQ2hpbGRyZW5cbiAgICAgICAgOiAoaSA9IDApID0+IG1heFN0YWdnZXJEdXJhdGlvbiAtIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbilcbiAgICAgICAgLnNvcnQoc29ydEJ5VHJlZU9yZGVyKVxuICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uU3RhcnRcIiwgdmFyaWFudCk7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRlVmFyaWFudChjaGlsZCwgdmFyaWFudCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheUNoaWxkcmVuICsgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24oaSksXG4gICAgICAgIH0pLnRoZW4oKCkgPT4gY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIiwgdmFyaWFudCkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG59XG5mdW5jdGlvbiBzb3J0QnlUcmVlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBhLnNvcnROb2RlUG9zaXRpb24oYik7XG59XG5cbmV4cG9ydCB7IGFuaW1hdGVWYXJpYW50LCBzb3J0QnlUcmVlT3JkZXIgfTtcbiIsImltcG9ydCB7IHJlc29sdmVWYXJpYW50IH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL3Jlc29sdmUtZHluYW1pYy12YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgYW5pbWF0ZVRhcmdldCB9IGZyb20gJy4vdmlzdWFsLWVsZW1lbnQtdGFyZ2V0Lm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlVmFyaWFudCB9IGZyb20gJy4vdmlzdWFsLWVsZW1lbnQtdmFyaWFudC5tanMnO1xuXG5mdW5jdGlvbiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkFuaW1hdGlvblN0YXJ0XCIsIGRlZmluaXRpb24pO1xuICAgIGxldCBhbmltYXRpb247XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IGRlZmluaXRpb24ubWFwKCh2YXJpYW50KSA9PiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zKSk7XG4gICAgICAgIGFuaW1hdGlvbiA9IFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhbmltYXRpb24gPSBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRGVmaW5pdGlvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucy5jdXN0b20pXG4gICAgICAgICAgICA6IGRlZmluaXRpb247XG4gICAgICAgIGFuaW1hdGlvbiA9IFByb21pc2UuYWxsKGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWREZWZpbml0aW9uLCBvcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb24udGhlbigoKSA9PiB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIiwgZGVmaW5pdGlvbik7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGFuaW1hdGVWaXN1YWxFbGVtZW50IH07XG4iLCJpbXBvcnQgeyBpc1ZhcmlhbnRMYWJlbCB9IGZyb20gJy4vaXMtdmFyaWFudC1sYWJlbC5tanMnO1xuaW1wb3J0IHsgdmFyaWFudFByb3BzIH0gZnJvbSAnLi92YXJpYW50LXByb3BzLm1qcyc7XG5cbmNvbnN0IG51bVZhcmlhbnRQcm9wcyA9IHZhcmlhbnRQcm9wcy5sZW5ndGg7XG5mdW5jdGlvbiBnZXRWYXJpYW50Q29udGV4dCh2aXN1YWxFbGVtZW50KSB7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICghdmlzdWFsRWxlbWVudC5pc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHZpc3VhbEVsZW1lbnQucGFyZW50XG4gICAgICAgICAgICA/IGdldFZhcmlhbnRDb250ZXh0KHZpc3VhbEVsZW1lbnQucGFyZW50KSB8fCB7fVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQucHJvcHMuaW5pdGlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250ZXh0LmluaXRpYWwgPSB2aXN1YWxFbGVtZW50LnByb3BzLmluaXRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhcmlhbnRQcm9wczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YXJpYW50UHJvcHNbaV07XG4gICAgICAgIGNvbnN0IHByb3AgPSB2aXN1YWxFbGVtZW50LnByb3BzW25hbWVdO1xuICAgICAgICBpZiAoaXNWYXJpYW50TGFiZWwocHJvcCkgfHwgcHJvcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRleHRbbmFtZV0gPSBwcm9wO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgeyBnZXRWYXJpYW50Q29udGV4dCB9O1xuIiwiaW1wb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzJztcbmltcG9ydCB7IGlzS2V5ZnJhbWVzVGFyZ2V0IH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWtleWZyYW1lcy10YXJnZXQubWpzJztcbmltcG9ydCB7IHNoYWxsb3dDb21wYXJlIH0gZnJvbSAnLi4vLi4vdXRpbHMvc2hhbGxvdy1jb21wYXJlLm1qcyc7XG5pbXBvcnQgeyBpc1ZhcmlhbnRMYWJlbCB9IGZyb20gJy4vaXMtdmFyaWFudC1sYWJlbC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVZhcmlhbnQgfSBmcm9tICcuL3Jlc29sdmUtZHluYW1pYy12YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgdmFyaWFudFByaW9yaXR5T3JkZXIgfSBmcm9tICcuL3ZhcmlhbnQtcHJvcHMubWpzJztcbmltcG9ydCB7IGFuaW1hdGVWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2ludGVyZmFjZXMvdmlzdWFsLWVsZW1lbnQubWpzJztcbmltcG9ydCB7IGdldFZhcmlhbnRDb250ZXh0IH0gZnJvbSAnLi9nZXQtdmFyaWFudC1jb250ZXh0Lm1qcyc7XG5cbmNvbnN0IHJldmVyc2VQcmlvcml0eU9yZGVyID0gWy4uLnZhcmlhbnRQcmlvcml0eU9yZGVyXS5yZXZlcnNlKCk7XG5jb25zdCBudW1BbmltYXRpb25UeXBlcyA9IHZhcmlhbnRQcmlvcml0eU9yZGVyLmxlbmd0aDtcbmZ1bmN0aW9uIGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gKGFuaW1hdGlvbnMpID0+IFByb21pc2UuYWxsKGFuaW1hdGlvbnMubWFwKCh7IGFuaW1hdGlvbiwgb3B0aW9ucyB9KSA9PiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgbGV0IGFuaW1hdGUgPSBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KTtcbiAgICBsZXQgc3RhdGUgPSBjcmVhdGVTdGF0ZSgpO1xuICAgIGxldCBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlZHVjZSB0aGUgYW5pbWF0aW9uIGRlZmluaXRpb25zIGZvclxuICAgICAqIGVhY2ggYWN0aXZlIGFuaW1hdGlvbiB0eXBlIGludG8gYW4gb2JqZWN0IG9mIHJlc29sdmVkIHZhbHVlcyBmb3IgaXQuXG4gICAgICovXG4gICAgY29uc3QgYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMgPSAodHlwZSkgPT4gKGFjYywgZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgdHlwZSA9PT0gXCJleGl0XCJcbiAgICAgICAgICAgID8gKF9hID0gdmlzdWFsRWxlbWVudC5wcmVzZW5jZUNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b21cbiAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQsIC4uLnRhcmdldCB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBhY2MgPSB7IC4uLmFjYywgLi4udGFyZ2V0LCAuLi50cmFuc2l0aW9uRW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMganVzdCBhbGxvd3MgdXMgdG8gaW5qZWN0IG1vY2tlZCBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QW5pbWF0ZUZ1bmN0aW9uKG1ha2VBbmltYXRvcikge1xuICAgICAgICBhbmltYXRlID0gbWFrZUFuaW1hdG9yKHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIHJlY2VpdmUgbmV3IHByb3BzLCB3ZSBuZWVkIHRvOlxuICAgICAqIDEuIENyZWF0ZSBhIGxpc3Qgb2YgcHJvdGVjdGVkIGtleXMgZm9yIGVhY2ggdHlwZS4gVGhpcyBpcyBhIGRpcmVjdG9yeSBvZlxuICAgICAqICAgIHZhbHVlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIFwiaGFuZGxlZFwiIGJ5IHR5cGVzIG9mIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICogICAgc28gdGhhdCB3aGVuZXZlciBhbiBhbmltYXRpb24gaXMgcGxheWVkIG9mIGEgZ2l2ZW4gdHlwZSwgdGhlc2UgdmFsdWVzIGFyZVxuICAgICAqICAgIHByb3RlY3RlZCBmcm9tIGJlaW5nIGFuaW1hdGVkLlxuICAgICAqIDIuIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gdHlwZSBuZWVkcyBhbmltYXRpbmcuXG4gICAgICogMy4gRGV0ZXJtaW5lIGlmIGFueSB2YWx1ZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBhIHR5cGUgYW5kIGZpZ3VyZSBvdXRcbiAgICAgKiAgICB3aGF0IHRvIGFuaW1hdGUgdGhvc2UgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5pbWF0ZUNoYW5nZXMoY2hhbmdlZEFjdGl2ZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGdldFZhcmlhbnRDb250ZXh0KHZpc3VhbEVsZW1lbnQucGFyZW50KSB8fCB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBhbmltYXRpb25zIHRoYXQgd2UnbGwgYnVpbGQgaW50byBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiB0eXBlcy4gVGhpcyB3aWxsIGdldCBleGVjdXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2Ygd2hpY2ggdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLiBUaGVuLCBhcyB3ZSBoaXQgbG93ZXIgcHJpb3JpdHlcbiAgICAgICAgICogYW5pbWF0aW9uIHR5cGVzLCB3ZSBjYW4gY2hlY2sgaWYgdGhleSBjb250YWluIHJlbW92ZWQgdmFsdWVzIGFuZCBhbmltYXRlIHRvIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGljdGlvbmFyeSBvZiBhbGwgZW5jb3VudGVyZWQga2V5cy4gVGhpcyBpcyBhbiBvYmplY3QgdG8gbGV0IHVzIGJ1aWxkIGludG8gYW5kXG4gICAgICAgICAqIGNvcHkgaXQgd2l0aG91dCBpdGVyYXRpb24uIEVhY2ggdGltZSB3ZSBoaXQgYW4gYW5pbWF0aW9uIHR5cGUgd2Ugc2V0IGl0cyBwcm90ZWN0ZWRcbiAgICAgICAgICoga2V5cyAtIHRoZSBrZXlzIGl0cyBub3QgYWxsb3dlZCB0byBhbmltYXRlIC0gdG8gdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGVuY291bnRlcmVkS2V5cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSB2YXJpYW50IGhhcyBiZWVuIHJlbW92ZWQgYXQgYSBnaXZlbiBpbmRleCwgYW5kIHRoaXMgY29tcG9uZW50IGlzIGNvbnRyb2xsaW5nXG4gICAgICAgICAqIHZhcmlhbnQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byBlbnN1cmUgbG93ZXItcHJpb3JpdHkgdmFyaWFudHMgYXJlIGZvcmNlZCB0byBhbmltYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgYW5pbWF0aW9uIHR5cGVzIGluIHJldmVyc2UgcHJpb3JpdHkgb3JkZXIuIEZvciBlYWNoLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIGRldGVjdCB3aGljaCB2YWx1ZXMgaXQncyBoYW5kbGluZyBhbmQgd2hldGhlciBvciBub3QgdGhleSd2ZSBjaGFuZ2VkIChhbmQgdGhlcmVmb3JlXG4gICAgICAgICAqIG5lZWQgdG8gYmUgYW5pbWF0ZWQpLiBJZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLCB3ZSB3YW50IHRvIGRldGVjdCB0aG9zZSBpblxuICAgICAgICAgKiBsb3dlciBwcmlvcml0eSBwcm9wcyBhbmQgZmxhZyBmb3IgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BbmltYXRpb25UeXBlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcmV2ZXJzZVByaW9yaXR5T3JkZXJbaV07XG4gICAgICAgICAgICBjb25zdCB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1t0eXBlXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBwcm9wc1t0eXBlXVxuICAgICAgICAgICAgICAgIDogY29udGV4dFt0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyB0eXBlIGhhcyAqanVzdCogY2hhbmdlZCBpc0FjdGl2ZSBzdGF0dXMsIHNldCBhY3RpdmVEZWx0YVxuICAgICAgICAgICAgICogdG8gdGhhdCBzdGF0dXMuIE90aGVyd2lzZSBzZXQgdG8gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRGVsdGEgPSB0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSA/IHR5cGVTdGF0ZS5pc0FjdGl2ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJlbW92ZWRWYXJpYW50SW5kZXggPSBpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHByb3AgaXMgYW4gaW5oZXJpdGVkIHZhcmlhbnQsIHJhdGhlciB0aGFuIGJlZW4gc2V0IGRpcmVjdGx5IG9uIHRoZVxuICAgICAgICAgICAgICogY29tcG9uZW50IGl0c2VsZiwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYWxsb3cgdGhlIHBhcmVudCB0byB0cmlnZ2VyIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogQ2FuIHByb2JhYmx5IGNoYW5nZSB0aGlzIHRvIGEgIWlzQ29udHJvbGxpbmdWYXJpYW50cyBjaGVja1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaXNJbmhlcml0ZWQgPSBwcm9wID09PSBjb250ZXh0W3R5cGVdICYmXG4gICAgICAgICAgICAgICAgcHJvcCAhPT0gcHJvcHNbdHlwZV0gJiZcbiAgICAgICAgICAgICAgICBwcm9wSXNWYXJpYW50O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNJbmhlcml0ZWQgJiZcbiAgICAgICAgICAgICAgICBpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgICAgICBpc0luaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGVuY291bnRlcmVkIGtleXMgc28gZmFyIGFzIHRoZSBwcm90ZWN0ZWQga2V5cyBmb3IgdGhpcyB0eXBlLiBUaGlzIHdpbGxcbiAgICAgICAgICAgICAqIGJlIGFueSBrZXkgdGhhdCBoYXMgYmVlbiBhbmltYXRlZCBvciBvdGhlcndpc2UgaGFuZGxlZCBieSBhY3RpdmUsIGhpZ2hlci1wcmlvcnRpeSB0eXBlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXMgPSB7IC4uLmVuY291bnRlcmVkS2V5cyB9O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHNraXAgYW5hbHlzaW5nIHRoaXMgcHJvcCBlYXJseVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgYWN0aXZlIGFuZCBoYXNuJ3QgKmp1c3QqIGJlZW4gc2V0IGFzIGluYWN0aXZlXG4gICAgICAgICAgICAoIXR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiBhY3RpdmVEZWx0YSA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgYW5kIGRvbid0IGhhdmUgYW55IGRlZmluZWQgcHJvcCBmb3IgdGhpcyBhbmltYXRpb24gdHlwZVxuICAgICAgICAgICAgICAgICghcHJvcCAmJiAhdHlwZVN0YXRlLnByZXZQcm9wKSB8fFxuICAgICAgICAgICAgICAgIC8vIE9yIGlmIHRoZSBwcm9wIGRvZXNuJ3QgZGVmaW5lIGFuIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcCkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgd2UgZ28gbG9vayB0aHJvdWdoIHRoZSB2YWx1ZXMgZGVmaW5lZCBvbiB0aGlzIHR5cGUsIGlmIHdlIGRldGVjdFxuICAgICAgICAgICAgICogYSBjaGFuZ2VkIHZhbHVlIG9yIGEgdmFsdWUgdGhhdCB3YXMgcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSwgd2Ugc2V0XG4gICAgICAgICAgICAgKiB0aGlzIHRvIHRydWUgYW5kIGFkZCB0aGlzIHByb3AgdG8gdGhlIGFuaW1hdGlvbiBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB2YXJpYW50RGlkQ2hhbmdlID0gY2hlY2tWYXJpYW50c0RpZENoYW5nZSh0eXBlU3RhdGUucHJldlByb3AsIHByb3ApO1xuICAgICAgICAgICAgbGV0IHNob3VsZEFuaW1hdGVUeXBlID0gdmFyaWFudERpZENoYW5nZSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG1ha2luZyB0aGlzIHZhcmlhbnQgYWN0aXZlLCB3ZSB3YW50IHRvIGFsd2F5cyBtYWtlIGl0IGFjdGl2ZVxuICAgICAgICAgICAgICAgICh0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUuaXNBY3RpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSW5oZXJpdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3BJc1ZhcmlhbnQpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIGhpZ2hlci1wcmlvcml0eSB2YXJpYW50IChpIGlzIGluIHJldmVyc2Ugb3JkZXIpXG4gICAgICAgICAgICAgICAgKGkgPiByZW1vdmVkVmFyaWFudEluZGV4ICYmIHByb3BJc1ZhcmlhbnQpO1xuICAgICAgICAgICAgbGV0IGhhbmRsZWRSZW1vdmVkVmFsdWVzID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzIGFuaW1hdGlvbnMgY2FuIGJlIHNldCBhcyB2YXJpYW50IGxpc3RzLCB2YXJpYW50cyBvciB0YXJnZXQgb2JqZWN0cywgd2VcbiAgICAgICAgICAgICAqIGNvZXJjZSBldmVyeXRoaW5nIHRvIGFuIGFycmF5IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25MaXN0ID0gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWxkIGFuIG9iamVjdCBvZiBhbGwgdGhlIHJlc29sdmVkIHZhbHVlcy4gV2UnbGwgdXNlIHRoaXMgaW4gdGhlIHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAqIGFuaW1hdGVDaGFuZ2VzIGNhbGxzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcyh0eXBlKSwge30pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3cgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBrZXlzIGluIHRoZSBwcmV2IHByb3AgYW5kIHRoaXMgcHJvcCxcbiAgICAgICAgICAgICAqIGFuZCBkZWNpZGU6XG4gICAgICAgICAgICAgKiAxLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDIuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZCBuZWVkcyBhZGRpbmcgdG8gdGhlIHJlbW92ZWRLZXlzIHNldFxuICAgICAgICAgICAgICogMy4gSWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSB0eXBlIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDQuIElmIGl0IGhhc24ndCBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgYnV0IGhhc24ndCBjaGFuZ2VkLCBhbmRcbiAgICAgICAgICAgICAqICAgIG5lZWRzIGFkZGluZyB0byB0aGUgdHlwZSdzIHByb3RlY3RlZEtleXMgbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2UmVzb2x2ZWRWYWx1ZXMgPSB7fSB9ID0gdHlwZVN0YXRlO1xuICAgICAgICAgICAgY29uc3QgYWxsS2V5cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2UmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgLi4ucmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbWFya1RvQW5pbWF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRSZW1vdmVkVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5uZWVkc0FuaW1hdGluZ1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLmxpdmVTdHlsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoaXMgd2UgY2FuIGp1c3Qgc2tpcCBhaGVhZFxuICAgICAgICAgICAgICAgIGlmIChlbmNvdW50ZXJlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCB3ZSBwcm9iYWJseSB3YW50IHRvIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlSGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0NoYW5nZWQgPSAhc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0NoYW5nZWQgPSBuZXh0ICE9PSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV4dCBpcyBkZWZpbmVkIGFuZCBkb2Vzbid0IGVxdWFsIHByZXYsIGl0IG5lZWRzIGFuaW1hdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB1bmRlZmluZWQsIGl0J3MgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBuZXh0IGhhc24ndCBjaGFuZ2VkIGFuZCBpdCBpc24ndCB1bmRlZmluZWQsIHdlIHdhbnQgdG8gY2hlY2sgaWYgaXQnc1xuICAgICAgICAgICAgICAgICAgICAgKiBiZWVuIHJlbW92ZWQgYnkgYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBpdCBoYXNuJ3QgY2hhbmdlZCwgd2UgYWRkIGl0IHRvIHRoZSBsaXN0IG9mIHByb3RlY3RlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICogdG8gZW5zdXJlIGl0IGRvZXNuJ3QgZ2V0IGFuaW1hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHR5cGVTdGF0ZSBzbyBuZXh0IHRpbWUgYW5pbWF0ZUNoYW5nZXMgaXMgY2FsbGVkIHdlIGNhbiBjb21wYXJlIHRoZVxuICAgICAgICAgICAgICogbGF0ZXN0IHByb3AgYW5kIHJlc29sdmVkVmFsdWVzIHRvIHRoZXNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0eXBlU3RhdGUucHJldlByb3AgPSBwcm9wO1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcyA9IHJlc29sdmVkVmFsdWVzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZVN0YXRlLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZW5jb3VudGVyZWRLZXlzID0geyAuLi5lbmNvdW50ZXJlZEtleXMsIC4uLnJlc29sdmVkVmFsdWVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBpbmhlcml0ZWQgcHJvcCB3ZSB3YW50IHRvIHNraXAgdGhpcyBhbmltYXRpb25cbiAgICAgICAgICAgICAqIHVubGVzcyB0aGUgaW5oZXJpdGVkIHZhcmlhbnRzIGhhdmVuJ3QgY2hhbmdlZCBvbiB0aGlzIHJlbmRlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgd2lsbEFuaW1hdGVWaWFQYXJlbnQgPSBpc0luaGVyaXRlZCAmJiB2YXJpYW50RGlkQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgbmVlZHNBbmltYXRpbmcgPSAhd2lsbEFuaW1hdGVWaWFQYXJlbnQgfHwgaGFuZGxlZFJlbW92ZWRWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgbmVlZHNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goLi4uZGVmaW5pdGlvbkxpc3QubWFwKChhbmltYXRpb24pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7IHR5cGUgfSxcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSBhcmUgc29tZSByZW1vdmVkIHZhbHVlIHRoYXQgaGF2ZW4ndCBiZWVuIGRlYWx0IHdpdGgsXG4gICAgICAgICAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFuaW1hdGlvbiB0aGF0IGZhbGxzIGJhY2sgZWl0aGVyIHRvIHRoZSB2YWx1ZVxuICAgICAgICAgKiBkZWZpbmVkIGluIHRoZSBzdHlsZSBwcm9wLCBvciB0aGUgbGFzdCByZWFkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlbW92ZWRLZXlzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrQW5pbWF0aW9uID0ge307XG4gICAgICAgICAgICByZW1vdmVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja1RhcmdldCA9IHZpc3VhbEVsZW1lbnQuZ2V0QmFzZVRhcmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtb3Rpb25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUubGl2ZVN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gQG1hdHRncGVycnkgdG8gZmlndXJlIGlmIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uW2tleV0gPSBmYWxsYmFja1RhcmdldCAhPT0gbnVsbCAmJiBmYWxsYmFja1RhcmdldCAhPT0gdm9pZCAwID8gZmFsbGJhY2tUYXJnZXQgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goeyBhbmltYXRpb246IGZhbGxiYWNrQW5pbWF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRBbmltYXRlID0gQm9vbGVhbihhbmltYXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgIChwcm9wcy5pbml0aWFsID09PSBmYWxzZSB8fCBwcm9wcy5pbml0aWFsID09PSBwcm9wcy5hbmltYXRlKSAmJlxuICAgICAgICAgICAgIXZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2hvdWxkQW5pbWF0ZSA/IGFuaW1hdGUoYW5pbWF0aW9ucykgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHdoZXRoZXIgYSBjZXJ0YWluIGFuaW1hdGlvbiB0eXBlIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBJZiB0aGUgYWN0aXZlIHN0YXRlIGhhc24ndCBjaGFuZ2VkLCB3ZSBjYW4gc2FmZWx5IGRvIG5vdGhpbmcgaGVyZVxuICAgICAgICBpZiAoc3RhdGVbdHlwZV0uaXNBY3RpdmUgPT09IGlzQWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAvLyBQcm9wYWdhdGUgYWN0aXZlIGNoYW5nZSB0byBjaGlsZHJlblxuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGNoaWxkKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGNoaWxkLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlKTsgfSk7XG4gICAgICAgIHN0YXRlW3R5cGVdLmlzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBhbmltYXRlQ2hhbmdlcyh0eXBlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgIHN0YXRlW2tleV0ucHJvdGVjdGVkS2V5cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmltYXRlQ2hhbmdlcyxcbiAgICAgICAgc2V0QWN0aXZlLFxuICAgICAgICBzZXRBbmltYXRlRnVuY3Rpb24sXG4gICAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlID0gY3JlYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlU3RhdGUoaXNBY3RpdmUgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzQWN0aXZlLFxuICAgICAgICBwcm90ZWN0ZWRLZXlzOiB7fSxcbiAgICAgICAgbmVlZHNBbmltYXRpbmc6IHt9LFxuICAgICAgICBwcmV2UmVzb2x2ZWRWYWx1ZXM6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbmltYXRlOiBjcmVhdGVUeXBlU3RhdGUodHJ1ZSksXG4gICAgICAgIHdoaWxlSW5WaWV3OiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVIb3ZlcjogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIHdoaWxlVGFwOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVEcmFnOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVGb2N1czogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIGV4aXQ6IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UsIGNyZWF0ZUFuaW1hdGlvblN0YXRlIH07XG4iLCJjbGFzcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgICAgIHRoaXMuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHsgfVxufVxuXG5leHBvcnQgeyBGZWF0dXJlIH07XG4iLCJpbXBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQW5pbWF0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vRmVhdHVyZS5tanMnO1xuXG5jbGFzcyBBbmltYXRpb25GZWF0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgLyoqXG4gICAgICogV2UgZHluYW1pY2FsbHkgZ2VuZXJhdGUgdGhlIEFuaW1hdGlvblN0YXRlIG1hbmFnZXIgYXMgaXQgY29udGFpbnMgYSByZWZlcmVuY2VcbiAgICAgKiB0byB0aGUgdW5kZXJseWluZyBhbmltYXRpb24gbGlicmFyeS4gV2Ugb25seSB3YW50IHRvIGxvYWQgdGhhdCBpZiB3ZSBsb2FkIHRoaXMsXG4gICAgICogc28gcGVvcGxlIGNhbiBvcHRpb25hbGx5IGNvZGUgc3BsaXQgaXQgb3V0IHVzaW5nIHRoZSBgbWAgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgc3VwZXIobm9kZSk7XG4gICAgICAgIG5vZGUuYW5pbWF0aW9uU3RhdGUgfHwgKG5vZGUuYW5pbWF0aW9uU3RhdGUgPSBjcmVhdGVBbmltYXRpb25TdGF0ZShub2RlKSk7XG4gICAgfVxuICAgIHVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBjb25zdCB7IGFuaW1hdGUgfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICBpZiAoaXNBbmltYXRpb25Db250cm9scyhhbmltYXRlKSkge1xuICAgICAgICAgICAgdGhpcy51bm1vdW50Q29udHJvbHMgPSBhbmltYXRlLnN1YnNjcmliZSh0aGlzLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSBhbnkgcHJvdmlkZWQgQW5pbWF0aW9uQ29udHJvbHMgdG8gdGhlIGNvbXBvbmVudCdzIFZpc3VhbEVsZW1lbnRcbiAgICAgKi9cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25Db250cm9sc1N1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0ZSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0ZTogcHJldkFuaW1hdGUgfSA9IHRoaXMubm9kZS5wcmV2UHJvcHMgfHwge307XG4gICAgICAgIGlmIChhbmltYXRlICE9PSBwcmV2QW5pbWF0ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmltYXRpb25Db250cm9sc1N1YnNjcmlwdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnJlc2V0KCk7XG4gICAgICAgIChfYSA9IHRoaXMudW5tb3VudENvbnRyb2xzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFuaW1hdGlvbkZlYXR1cmUgfTtcbiIsImltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuLi9GZWF0dXJlLm1qcyc7XG5cbmxldCBpZCA9IDA7XG5jbGFzcyBFeGl0QW5pbWF0aW9uRmVhdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gaWQrKztcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5wcmVzZW5jZUNvbnRleHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSB9ID0gdGhpcy5ub2RlLnByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgY29uc3QgeyBpc1ByZXNlbnQ6IHByZXZJc1ByZXNlbnQgfSA9IHRoaXMubm9kZS5wcmV2UHJlc2VuY2VDb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSB8fCBpc1ByZXNlbnQgPT09IHByZXZJc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGl0QW5pbWF0aW9uID0gdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcImV4aXRcIiwgIWlzUHJlc2VudCk7XG4gICAgICAgIGlmIChvbkV4aXRDb21wbGV0ZSAmJiAhaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBleGl0QW5pbWF0aW9uLnRoZW4oKCkgPT4gb25FeGl0Q29tcGxldGUodGhpcy5pZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB0aGlzLm5vZGUucHJlc2VuY2VDb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAocmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VudCA9IHJlZ2lzdGVyKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7IH1cbn1cblxuZXhwb3J0IHsgRXhpdEFuaW1hdGlvbkZlYXR1cmUgfTtcbiIsImltcG9ydCB7IEFuaW1hdGlvbkZlYXR1cmUgfSBmcm9tICcuL2FuaW1hdGlvbi9pbmRleC5tanMnO1xuaW1wb3J0IHsgRXhpdEFuaW1hdGlvbkZlYXR1cmUgfSBmcm9tICcuL2FuaW1hdGlvbi9leGl0Lm1qcyc7XG5cbmNvbnN0IGFuaW1hdGlvbnMgPSB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIEZlYXR1cmU6IEFuaW1hdGlvbkZlYXR1cmUsXG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICAgIEZlYXR1cmU6IEV4aXRBbmltYXRpb25GZWF0dXJlLFxuICAgIH0sXG59O1xuXG5leHBvcnQgeyBhbmltYXRpb25zIH07XG4iLCJmdW5jdGlvbiBhZGREb21FdmVudCh0YXJnZXQsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyA9IHsgcGFzc2l2ZTogdHJ1ZSB9KSB7XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbn1cblxuZXhwb3J0IHsgYWRkRG9tRXZlbnQgfTtcbiIsImltcG9ydCB7IGlzUHJpbWFyeVBvaW50ZXIgfSBmcm9tICdtb3Rpb24tZG9tJztcblxuZnVuY3Rpb24gZXh0cmFjdEV2ZW50SW5mbyhldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgICB4OiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgIHk6IGV2ZW50LnBhZ2VZLFxuICAgICAgICB9LFxuICAgIH07XG59XG5jb25zdCBhZGRQb2ludGVySW5mbyA9IChoYW5kbGVyKSA9PiB7XG4gICAgcmV0dXJuIChldmVudCkgPT4gaXNQcmltYXJ5UG9pbnRlcihldmVudCkgJiYgaGFuZGxlcihldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpO1xufTtcblxuZXhwb3J0IHsgYWRkUG9pbnRlckluZm8sIGV4dHJhY3RFdmVudEluZm8gfTtcbiIsImltcG9ydCB7IGFkZERvbUV2ZW50IH0gZnJvbSAnLi9hZGQtZG9tLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBhZGRQb2ludGVySW5mbyB9IGZyb20gJy4vZXZlbnQtaW5mby5tanMnO1xuXG5mdW5jdGlvbiBhZGRQb2ludGVyRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWRkRG9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGFkZFBvaW50ZXJJbmZvKGhhbmRsZXIpLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgYWRkUG9pbnRlckV2ZW50IH07XG4iLCJjb25zdCBkaXN0YW5jZSA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYik7XG5mdW5jdGlvbiBkaXN0YW5jZTJEKGEsIGIpIHtcbiAgICAvLyBNdWx0aS1kaW1lbnNpb25hbFxuICAgIGNvbnN0IHhEZWx0YSA9IGRpc3RhbmNlKGEueCwgYi54KTtcbiAgICBjb25zdCB5RGVsdGEgPSBkaXN0YW5jZShhLnksIGIueSk7XG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiogMiArIHlEZWx0YSAqKiAyKTtcbn1cblxuZXhwb3J0IHsgZGlzdGFuY2UsIGRpc3RhbmNlMkQgfTtcbiIsImltcG9ydCB7IGlzUHJpbWFyeVBvaW50ZXIgfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcywgbWlsbGlzZWNvbmRzVG9TZWNvbmRzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGFkZFBvaW50ZXJFdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50cy9hZGQtcG9pbnRlci1ldmVudC5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdEV2ZW50SW5mbyB9IGZyb20gJy4uLy4uL2V2ZW50cy9ldmVudC1pbmZvLm1qcyc7XG5pbXBvcnQgeyBkaXN0YW5jZTJEIH0gZnJvbSAnLi4vLi4vdXRpbHMvZGlzdGFuY2UubWpzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICcuLi8uLi91dGlscy9waXBlLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSwgY2FuY2VsRnJhbWUsIGZyYW1lRGF0YSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQYW5TZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudCwgaGFuZGxlcnMsIHsgdHJhbnNmb3JtUGFnZVBvaW50LCBjb250ZXh0V2luZG93LCBkcmFnU25hcFRvT3JpZ2luID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHRXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldFBhbkluZm8odGhpcy5sYXN0TW92ZUV2ZW50SW5mbywgdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzUGFuU3RhcnRlZCA9IHRoaXMuc3RhcnRFdmVudCAhPT0gbnVsbDtcbiAgICAgICAgICAgIC8vIE9ubHkgc3RhcnQgcGFubmluZyBpZiB0aGUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIDMgcGl4ZWxzLiBJZiB3ZSBtYWtlIGl0XG4gICAgICAgICAgICAvLyBhbnkgbGFyZ2VyIHRoYW4gdGhpcyB3ZSdsbCB3YW50IHRvIHJlc2V0IHRoZSBwb2ludGVyIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCB1cGRhdGUgdG8gYXZvaWQgdmlzdWFsIHNuYXBwaW5nIHRvIHRoZSBjdXJzb2UuXG4gICAgICAgICAgICBjb25zdCBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlMkQoaW5mby5vZmZzZXQsIHsgeDogMCwgeTogMCB9KSA+PSAzO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9pbnQgfSA9IGluZm87XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVzdGFtcCB9ID0gZnJhbWVEYXRhO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goeyAuLi5wb2ludCwgdGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBvblN0YXJ0LCBvbk1vdmUgfSA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG9uU3RhcnQgJiYgb25TdGFydCh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHRoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZSAmJiBvbk1vdmUodGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgICAgICAgLy8gVGhyb3R0bGUgbW91c2UgbW92ZSBldmVudCB0byBvbmNlIHBlciBmcmFtZVxuICAgICAgICAgICAgZnJhbWUudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb25FbmQsIG9uU2Vzc2lvbkVuZCwgcmVzdW1lQW5pbWF0aW9uIH0gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICByZXN1bWVBbmltYXRpb24gJiYgcmVzdW1lQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcGFuSW5mbyA9IGdldFBhbkluZm8oZXZlbnQudHlwZSA9PT0gXCJwb2ludGVyY2FuY2VsXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMubGFzdE1vdmVFdmVudEluZm9cbiAgICAgICAgICAgICAgICA6IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KSwgdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RXZlbnQgJiYgb25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50LCBwYW5JbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHRvdWNoLCBkb24ndCBzdGFydCBkZXRlY3RpbmcgdGhpcyBnZXN0dXJlXG4gICAgICAgIGlmICghaXNQcmltYXJ5UG9pbnRlcihldmVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZHJhZ1NuYXBUb09yaWdpbiA9IGRyYWdTbmFwVG9PcmlnaW47XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBoYW5kbGVycztcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQgPSB0cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgICAgIHRoaXMuY29udGV4dFdpbmRvdyA9IGNvbnRleHRXaW5kb3cgfHwgd2luZG93O1xuICAgICAgICBjb25zdCBpbmZvID0gZXh0cmFjdEV2ZW50SW5mbyhldmVudCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgICBjb25zdCB7IHBvaW50IH0gPSBpbml0aWFsSW5mbztcbiAgICAgICAgY29uc3QgeyB0aW1lc3RhbXAgfSA9IGZyYW1lRGF0YTtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW3sgLi4ucG9pbnQsIHRpbWVzdGFtcCB9XTtcbiAgICAgICAgY29uc3QgeyBvblNlc3Npb25TdGFydCB9ID0gaGFuZGxlcnM7XG4gICAgICAgIG9uU2Vzc2lvblN0YXJ0ICYmXG4gICAgICAgICAgICBvblNlc3Npb25TdGFydChldmVudCwgZ2V0UGFuSW5mbyhpbml0aWFsSW5mbywgdGhpcy5oaXN0b3J5KSk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gcGlwZShhZGRQb2ludGVyRXZlbnQodGhpcy5jb250ZXh0V2luZG93LCBcInBvaW50ZXJtb3ZlXCIsIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUpLCBhZGRQb2ludGVyRXZlbnQodGhpcy5jb250ZXh0V2luZG93LCBcInBvaW50ZXJ1cFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCksIGFkZFBvaW50ZXJFdmVudCh0aGlzLmNvbnRleHRXaW5kb3csIFwicG9pbnRlcmNhbmNlbFwiLCB0aGlzLmhhbmRsZVBvaW50ZXJVcCkpO1xuICAgIH1cbiAgICB1cGRhdGVIYW5kbGVycyhoYW5kbGVycykge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgfVxuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgY2FuY2VsRnJhbWUodGhpcy51cGRhdGVQb2ludCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNmb3JtUG9pbnQoaW5mbywgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhZ2VQb2ludCA/IHsgcG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludChpbmZvLnBvaW50KSB9IDogaW5mbztcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0UG9pbnQoYSwgYikge1xuICAgIHJldHVybiB7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH07XG59XG5mdW5jdGlvbiBnZXRQYW5JbmZvKHsgcG9pbnQgfSwgaGlzdG9yeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50LFxuICAgICAgICBkZWx0YTogc3VidHJhY3RQb2ludChwb2ludCwgbGFzdERldmljZVBvaW50KGhpc3RvcnkpKSxcbiAgICAgICAgb2Zmc2V0OiBzdWJ0cmFjdFBvaW50KHBvaW50LCBzdGFydERldmljZVBvaW50KGhpc3RvcnkpKSxcbiAgICAgICAgdmVsb2NpdHk6IGdldFZlbG9jaXR5KGhpc3RvcnksIDAuMSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0YXJ0RGV2aWNlUG9pbnQoaGlzdG9yeSkge1xuICAgIHJldHVybiBoaXN0b3J5WzBdO1xufVxuZnVuY3Rpb24gbGFzdERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gaGlzdG9yeVtoaXN0b3J5Lmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0VmVsb2NpdHkoaGlzdG9yeSwgdGltZURlbHRhKSB7XG4gICAgaWYgKGhpc3RvcnkubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIGxldCBpID0gaGlzdG9yeS5sZW5ndGggLSAxO1xuICAgIGxldCB0aW1lc3RhbXBlZFBvaW50ID0gbnVsbDtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBsYXN0RGV2aWNlUG9pbnQoaGlzdG9yeSk7XG4gICAgd2hpbGUgKGkgPj0gMCkge1xuICAgICAgICB0aW1lc3RhbXBlZFBvaW50ID0gaGlzdG9yeVtpXTtcbiAgICAgICAgaWYgKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCA+XG4gICAgICAgICAgICBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZURlbHRhKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoIXRpbWVzdGFtcGVkUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICBjb25zdCB0aW1lID0gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCk7XG4gICAgaWYgKHRpbWUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VmVsb2NpdHkgPSB7XG4gICAgICAgIHg6IChsYXN0UG9pbnQueCAtIHRpbWVzdGFtcGVkUG9pbnQueCkgLyB0aW1lLFxuICAgICAgICB5OiAobGFzdFBvaW50LnkgLSB0aW1lc3RhbXBlZFBvaW50LnkpIC8gdGltZSxcbiAgICB9O1xuICAgIGlmIChjdXJyZW50VmVsb2NpdHkueCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY3VycmVudFZlbG9jaXR5LnggPSAwO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFZlbG9jaXR5LnkgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS55ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRWZWxvY2l0eTtcbn1cblxuZXhwb3J0IHsgUGFuU2Vzc2lvbiB9O1xuIiwiZnVuY3Rpb24gaXNSZWZPYmplY3QocmVmKSB7XG4gICAgcmV0dXJuIChyZWYgJiZcbiAgICAgICAgdHlwZW9mIHJlZiA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocmVmLCBcImN1cnJlbnRcIikpO1xufVxuXG5leHBvcnQgeyBpc1JlZk9iamVjdCB9O1xuIiwiaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWl4L251bWJlci5tanMnO1xuXG5jb25zdCBTQ0FMRV9QUkVDSVNJT04gPSAwLjAwMDE7XG5jb25zdCBTQ0FMRV9NSU4gPSAxIC0gU0NBTEVfUFJFQ0lTSU9OO1xuY29uc3QgU0NBTEVfTUFYID0gMSArIFNDQUxFX1BSRUNJU0lPTjtcbmNvbnN0IFRSQU5TTEFURV9QUkVDSVNJT04gPSAwLjAxO1xuY29uc3QgVFJBTlNMQVRFX01JTiA9IDAgLSBUUkFOU0xBVEVfUFJFQ0lTSU9OO1xuY29uc3QgVFJBTlNMQVRFX01BWCA9IDAgKyBUUkFOU0xBVEVfUFJFQ0lTSU9OO1xuZnVuY3Rpb24gY2FsY0xlbmd0aChheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMubWF4IC0gYXhpcy5taW47XG59XG5mdW5jdGlvbiBpc05lYXIodmFsdWUsIHRhcmdldCwgbWF4RGlzdGFuY2UpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModmFsdWUgLSB0YXJnZXQpIDw9IG1heERpc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FsY0F4aXNEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbiA9IDAuNSkge1xuICAgIGRlbHRhLm9yaWdpbiA9IG9yaWdpbjtcbiAgICBkZWx0YS5vcmlnaW5Qb2ludCA9IG1peE51bWJlcihzb3VyY2UubWluLCBzb3VyY2UubWF4LCBkZWx0YS5vcmlnaW4pO1xuICAgIGRlbHRhLnNjYWxlID0gY2FsY0xlbmd0aCh0YXJnZXQpIC8gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIGRlbHRhLnRyYW5zbGF0ZSA9XG4gICAgICAgIG1peE51bWJlcih0YXJnZXQubWluLCB0YXJnZXQubWF4LCBkZWx0YS5vcmlnaW4pIC0gZGVsdGEub3JpZ2luUG9pbnQ7XG4gICAgaWYgKChkZWx0YS5zY2FsZSA+PSBTQ0FMRV9NSU4gJiYgZGVsdGEuc2NhbGUgPD0gU0NBTEVfTUFYKSB8fFxuICAgICAgICBpc05hTihkZWx0YS5zY2FsZSkpIHtcbiAgICAgICAgZGVsdGEuc2NhbGUgPSAxLjA7XG4gICAgfVxuICAgIGlmICgoZGVsdGEudHJhbnNsYXRlID49IFRSQU5TTEFURV9NSU4gJiZcbiAgICAgICAgZGVsdGEudHJhbnNsYXRlIDw9IFRSQU5TTEFURV9NQVgpIHx8XG4gICAgICAgIGlzTmFOKGRlbHRhLnRyYW5zbGF0ZSkpIHtcbiAgICAgICAgZGVsdGEudHJhbnNsYXRlID0gMC4wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbGNCb3hEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueCwgc291cmNlLngsIHRhcmdldC54LCBvcmlnaW4gPyBvcmlnaW4ub3JpZ2luWCA6IHVuZGVmaW5lZCk7XG4gICAgY2FsY0F4aXNEZWx0YShkZWx0YS55LCBzb3VyY2UueSwgdGFyZ2V0LnksIG9yaWdpbiA/IG9yaWdpbi5vcmlnaW5ZIDogdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IHBhcmVudC5taW4gKyByZWxhdGl2ZS5taW47XG4gICAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKHJlbGF0aXZlKTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUJveCh0YXJnZXQsIHJlbGF0aXZlLCBwYXJlbnQpIHtcbiAgICBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldC54LCByZWxhdGl2ZS54LCBwYXJlbnQueCk7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueSwgcmVsYXRpdmUueSwgcGFyZW50LnkpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldCwgbGF5b3V0LCBwYXJlbnQpIHtcbiAgICB0YXJnZXQubWluID0gbGF5b3V0Lm1pbiAtIHBhcmVudC5taW47XG4gICAgdGFyZ2V0Lm1heCA9IHRhcmdldC5taW4gKyBjYWxjTGVuZ3RoKGxheW91dCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uKHRhcmdldC54LCBsYXlvdXQueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueSwgbGF5b3V0LnksIHBhcmVudC55KTtcbn1cblxuZXhwb3J0IHsgY2FsY0F4aXNEZWx0YSwgY2FsY0JveERlbHRhLCBjYWxjTGVuZ3RoLCBjYWxjUmVsYXRpdmVBeGlzLCBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24sIGNhbGNSZWxhdGl2ZUJveCwgY2FsY1JlbGF0aXZlUG9zaXRpb24sIGlzTmVhciB9O1xuIiwiaW1wb3J0IHsgcHJvZ3Jlc3MgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgY2FsY0xlbmd0aCB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtY2FsYy5tanMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jbGFtcC5tanMnO1xuaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbWl4L251bWJlci5tanMnO1xuXG4vKipcbiAqIEFwcGx5IGNvbnN0cmFpbnRzIHRvIGEgcG9pbnQuIFRoZXNlIGNvbnN0cmFpbnRzIGFyZSBib3RoIHBoeXNpY2FsIGFsb25nIGFuXG4gKiBheGlzLCBhbmQgYW4gZWxhc3RpYyBmYWN0b3IgdGhhdCBkZXRlcm1pbmVzIGhvdyBtdWNoIHRvIGNvbnN0cmFpbiB0aGUgcG9pbnRcbiAqIGJ5IGlmIGl0IGRvZXMgbGllIG91dHNpZGUgdGhlIGRlZmluZWQgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlDb25zdHJhaW50cyhwb2ludCwgeyBtaW4sIG1heCB9LCBlbGFzdGljKSB7XG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkICYmIHBvaW50IDwgbWluKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtaW4gcG9pbnQgZGVmaW5lZCwgYW5kIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGF0LCBjb25zdHJhaW5cbiAgICAgICAgcG9pbnQgPSBlbGFzdGljXG4gICAgICAgICAgICA/IG1peE51bWJlcihtaW4sIHBvaW50LCBlbGFzdGljLm1pbilcbiAgICAgICAgICAgIDogTWF0aC5tYXgocG9pbnQsIG1pbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHBvaW50ID4gbWF4KSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXggcG9pbnQgZGVmaW5lZCwgYW5kIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGF0LCBjb25zdHJhaW5cbiAgICAgICAgcG9pbnQgPSBlbGFzdGljXG4gICAgICAgICAgICA/IG1peE51bWJlcihtYXgsIHBvaW50LCBlbGFzdGljLm1heClcbiAgICAgICAgICAgIDogTWF0aC5taW4ocG9pbnQsIG1heCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuIGRlZmluZWQgcmVsYXRpdmVseSB0byB0aGVcbiAqIG1lYXN1cmVkIGF4aXMuIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSB0aGUgbmVhcmVzdCBlZGdlLCBzbyBhIG1heCBjb25zdHJhaW50IG9mIDIwMFxuICogb24gYW4gYXhpcyB3aXRoIGEgbWF4IHZhbHVlIG9mIDMwMCB3b3VsZCByZXR1cm4gYSBjb25zdHJhaW50IG9mIDUwMCAtIGF4aXMgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhheGlzLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluICE9PSB1bmRlZmluZWQgPyBheGlzLm1pbiArIG1pbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4OiBtYXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBheGlzLm1heCArIG1heCAtIChheGlzLm1heCAtIGF4aXMubWluKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuXG4gKiBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gdGhlIG1lYXN1cmVkIGJvdW5kaW5nIGJveC5cbiAqL1xuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0Qm94LCB7IHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgICAgIHk6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgdG9wLCBib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBheGlzXG4gKi9cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgICBsZXQgbWluID0gY29uc3RyYWludHNBeGlzLm1pbiAtIGxheW91dEF4aXMubWluO1xuICAgIGxldCBtYXggPSBjb25zdHJhaW50c0F4aXMubWF4IC0gbGF5b3V0QXhpcy5tYXg7XG4gICAgLy8gSWYgdGhlIGNvbnN0cmFpbnRzIGF4aXMgaXMgYWN0dWFsbHkgc21hbGxlciB0aGFuIHRoZSBsYXlvdXQgYXhpcyB0aGVuIHdlIGNhblxuICAgIC8vIGZsaXAgdGhlIGNvbnN0cmFpbnRzXG4gICAgaWYgKGNvbnN0cmFpbnRzQXhpcy5tYXggLSBjb25zdHJhaW50c0F4aXMubWluIDxcbiAgICAgICAgbGF5b3V0QXhpcy5tYXggLSBsYXlvdXRBeGlzLm1pbikge1xuICAgICAgICBbbWluLCBtYXhdID0gW21heCwgbWluXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluLCBtYXggfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHdoZW4gZGVmaW5lZCBhcyBhbm90aGVyIHZpZXdwb3J0LXJlbGF0aXZlIGJveFxuICovXG5mdW5jdGlvbiBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhsYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBjb25zdHJhaW50c0JveC54KSxcbiAgICAgICAgeTogY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCBjb25zdHJhaW50c0JveC55KSxcbiAgICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgYSB0cmFuc2Zvcm0gb3JpZ2luIHJlbGF0aXZlIHRvIHRoZSBzb3VyY2UgYXhpcywgYmV0d2VlbiAwLTEsIHRoYXQgcmVzdWx0c1xuICogaW4gYW4gYXN0aGV0aWNhbGx5IHBsZWFzaW5nIHNjYWxlL3RyYW5zZm9ybSBuZWVkZWQgdG8gcHJvamVjdCBmcm9tIHNvdXJjZSB0byB0YXJnZXQuXG4gKi9cbmZ1bmN0aW9uIGNhbGNPcmlnaW4oc291cmNlLCB0YXJnZXQpIHtcbiAgICBsZXQgb3JpZ2luID0gMC41O1xuICAgIGNvbnN0IHNvdXJjZUxlbmd0aCA9IGNhbGNMZW5ndGgoc291cmNlKTtcbiAgICBjb25zdCB0YXJnZXRMZW5ndGggPSBjYWxjTGVuZ3RoKHRhcmdldCk7XG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwcm9ncmVzcyh0YXJnZXQubWluLCB0YXJnZXQubWF4IC0gc291cmNlTGVuZ3RoLCBzb3VyY2UubWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IHByb2dyZXNzKHNvdXJjZS5taW4sIHNvdXJjZS5tYXggLSB0YXJnZXRMZW5ndGgsIHRhcmdldC5taW4pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXAoMCwgMSwgb3JpZ2luKTtcbn1cbi8qKlxuICogUmViYXNlIHRoZSBjYWxjdWxhdGVkIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHJlbGF0aXZlIHRvIHRoZSBsYXlvdXQubWluIHBvaW50LlxuICovXG5mdW5jdGlvbiByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LCBjb25zdHJhaW50cykge1xuICAgIGNvbnN0IHJlbGF0aXZlQ29uc3RyYWludHMgPSB7fTtcbiAgICBpZiAoY29uc3RyYWludHMubWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5taW4gPSBjb25zdHJhaW50cy5taW4gLSBsYXlvdXQubWluO1xuICAgIH1cbiAgICBpZiAoY29uc3RyYWludHMubWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVsYXRpdmVDb25zdHJhaW50cy5tYXggPSBjb25zdHJhaW50cy5tYXggLSBsYXlvdXQubWluO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmVDb25zdHJhaW50cztcbn1cbmNvbnN0IGRlZmF1bHRFbGFzdGljID0gMC4zNTtcbi8qKlxuICogQWNjZXB0cyBhIGRyYWdFbGFzdGljIHByb3AgYW5kIHJldHVybnMgcmVzb2x2ZWQgZWxhc3RpYyB2YWx1ZXMgZm9yIGVhY2ggYXhpcy5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWMpIHtcbiAgICBpZiAoZHJhZ0VsYXN0aWMgPT09IGZhbHNlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHJhZ0VsYXN0aWMgPT09IHRydWUpIHtcbiAgICAgICAgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcImxlZnRcIiwgXCJyaWdodFwiKSxcbiAgICAgICAgeTogcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBcInRvcFwiLCBcImJvdHRvbVwiKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZUF4aXNFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCwgbWF4TGFiZWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsKSxcbiAgICAgICAgbWF4OiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtYXhMYWJlbCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIGxhYmVsKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkcmFnRWxhc3RpYyA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IGRyYWdFbGFzdGljXG4gICAgICAgIDogZHJhZ0VsYXN0aWNbbGFiZWxdIHx8IDA7XG59XG5cbmV4cG9ydCB7IGFwcGx5Q29uc3RyYWludHMsIGNhbGNPcmlnaW4sIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cywgY2FsY1JlbGF0aXZlQ29uc3RyYWludHMsIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cywgY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMsIGRlZmF1bHRFbGFzdGljLCByZWJhc2VBeGlzQ29uc3RyYWludHMsIHJlc29sdmVBeGlzRWxhc3RpYywgcmVzb2x2ZURyYWdFbGFzdGljLCByZXNvbHZlUG9pbnRFbGFzdGljIH07XG4iLCJjb25zdCBjcmVhdGVBeGlzRGVsdGEgPSAoKSA9PiAoe1xuICAgIHRyYW5zbGF0ZTogMCxcbiAgICBzY2FsZTogMSxcbiAgICBvcmlnaW46IDAsXG4gICAgb3JpZ2luUG9pbnQ6IDAsXG59KTtcbmNvbnN0IGNyZWF0ZURlbHRhID0gKCkgPT4gKHtcbiAgICB4OiBjcmVhdGVBeGlzRGVsdGEoKSxcbiAgICB5OiBjcmVhdGVBeGlzRGVsdGEoKSxcbn0pO1xuY29uc3QgY3JlYXRlQXhpcyA9ICgpID0+ICh7IG1pbjogMCwgbWF4OiAwIH0pO1xuY29uc3QgY3JlYXRlQm94ID0gKCkgPT4gKHtcbiAgICB4OiBjcmVhdGVBeGlzKCksXG4gICAgeTogY3JlYXRlQXhpcygpLFxufSk7XG5cbmV4cG9ydCB7IGNyZWF0ZUF4aXMsIGNyZWF0ZUF4aXNEZWx0YSwgY3JlYXRlQm94LCBjcmVhdGVEZWx0YSB9O1xuIiwiZnVuY3Rpb24gZWFjaEF4aXMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gW2NhbGxiYWNrKFwieFwiKSwgY2FsbGJhY2soXCJ5XCIpXTtcbn1cblxuZXhwb3J0IHsgZWFjaEF4aXMgfTtcbiIsIi8qKlxuICogQm91bmRpbmcgYm94ZXMgdGVuZCB0byBiZSBkZWZpbmVkIGFzIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbS4gRm9yIHZhcmlvdXMgb3BlcmF0aW9uc1xuICogaXQncyBlYXNpZXIgdG8gY29uc2lkZXIgZWFjaCBheGlzIGluZGl2aWR1YWxseS4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgYm91bmRpbmcgYm94XG4gKiBhcyBhIG1hcCBvZiBzaW5nbGUtYXhpcyBtaW4vbWF4IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJvdW5kaW5nQm94VG9Cb3goeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB7IG1pbjogbGVmdCwgbWF4OiByaWdodCB9LFxuICAgICAgICB5OiB7IG1pbjogdG9wLCBtYXg6IGJvdHRvbSB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCh7IHgsIHkgfSkge1xuICAgIHJldHVybiB7IHRvcDogeS5taW4sIHJpZ2h0OiB4Lm1heCwgYm90dG9tOiB5Lm1heCwgbGVmdDogeC5taW4gfTtcbn1cbi8qKlxuICogQXBwbGllcyBhIFRyYW5zZm9ybVBvaW50IGZ1bmN0aW9uIHRvIGEgYm91bmRpbmcgYm94LiBUcmFuc2Zvcm1Qb2ludCBpcyB1c3VhbGx5IGEgZnVuY3Rpb25cbiAqIHByb3ZpZGVkIGJ5IEZyYW1lciB0byBhbGxvdyBtZWFzdXJlZCBwb2ludHMgdG8gYmUgY29ycmVjdGVkIGZvciBkZXZpY2Ugc2NhbGluZy4gVGhpcyBpcyB1c2VkXG4gKiB3aGVuIG1lYXN1cmluZyBET00gZWxlbWVudHMgYW5kIERPTSBldmVudCBwb2ludHMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveFBvaW50cyhwb2ludCwgdHJhbnNmb3JtUG9pbnQpIHtcbiAgICBpZiAoIXRyYW5zZm9ybVBvaW50KVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgY29uc3QgdG9wTGVmdCA9IHRyYW5zZm9ybVBvaW50KHsgeDogcG9pbnQubGVmdCwgeTogcG9pbnQudG9wIH0pO1xuICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5yaWdodCwgeTogcG9pbnQuYm90dG9tIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wTGVmdC55LFxuICAgICAgICBsZWZ0OiB0b3BMZWZ0LngsXG4gICAgICAgIGJvdHRvbTogYm90dG9tUmlnaHQueSxcbiAgICAgICAgcmlnaHQ6IGJvdHRvbVJpZ2h0LngsXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgY29udmVydEJvdW5kaW5nQm94VG9Cb3gsIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94LCB0cmFuc2Zvcm1Cb3hQb2ludHMgfTtcbiIsImZ1bmN0aW9uIGlzSWRlbnRpdHlTY2FsZShzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSA9PT0gdW5kZWZpbmVkIHx8IHNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaGFzU2NhbGUoeyBzY2FsZSwgc2NhbGVYLCBzY2FsZVkgfSkge1xuICAgIHJldHVybiAoIWlzSWRlbnRpdHlTY2FsZShzY2FsZSkgfHxcbiAgICAgICAgIWlzSWRlbnRpdHlTY2FsZShzY2FsZVgpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVZKSk7XG59XG5mdW5jdGlvbiBoYXNUcmFuc2Zvcm0odmFsdWVzKSB7XG4gICAgcmV0dXJuIChoYXNTY2FsZSh2YWx1ZXMpIHx8XG4gICAgICAgIGhhczJEVHJhbnNsYXRlKHZhbHVlcykgfHxcbiAgICAgICAgdmFsdWVzLnogfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZSB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlWCB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlWSB8fFxuICAgICAgICB2YWx1ZXMuc2tld1ggfHxcbiAgICAgICAgdmFsdWVzLnNrZXdZKTtcbn1cbmZ1bmN0aW9uIGhhczJEVHJhbnNsYXRlKHZhbHVlcykge1xuICAgIHJldHVybiBpczJEVHJhbnNsYXRlKHZhbHVlcy54KSB8fCBpczJEVHJhbnNsYXRlKHZhbHVlcy55KTtcbn1cbmZ1bmN0aW9uIGlzMkRUcmFuc2xhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUgIT09IFwiMCVcIjtcbn1cblxuZXhwb3J0IHsgaGFzMkRUcmFuc2xhdGUsIGhhc1NjYWxlLCBoYXNUcmFuc2Zvcm0gfTtcbiIsImltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcbmltcG9ydCB7IGhhc1RyYW5zZm9ybSB9IGZyb20gJy4uL3V0aWxzL2hhcy10cmFuc2Zvcm0ubWpzJztcblxuLyoqXG4gKiBTY2FsZXMgYSBwb2ludCBiYXNlZCBvbiBhIGZhY3RvciBhbmQgYW4gb3JpZ2luUG9pbnRcbiAqL1xuZnVuY3Rpb24gc2NhbGVQb2ludChwb2ludCwgc2NhbGUsIG9yaWdpblBvaW50KSB7XG4gICAgY29uc3QgZGlzdGFuY2VGcm9tT3JpZ2luID0gcG9pbnQgLSBvcmlnaW5Qb2ludDtcbiAgICBjb25zdCBzY2FsZWQgPSBzY2FsZSAqIGRpc3RhbmNlRnJvbU9yaWdpbjtcbiAgICByZXR1cm4gb3JpZ2luUG9pbnQgKyBzY2FsZWQ7XG59XG4vKipcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGUvc2NhbGUgZGVsdGEgdG8gYSBwb2ludFxuICovXG5mdW5jdGlvbiBhcHBseVBvaW50RGVsdGEocG9pbnQsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIGlmIChib3hTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgYm94U2NhbGUsIG9yaWdpblBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlLCBvcmlnaW5Qb2ludCkgKyB0cmFuc2xhdGU7XG59XG4vKipcbiAqIEFwcGxpZXMgYSB0cmFuc2xhdGUvc2NhbGUgZGVsdGEgdG8gYW4gYXhpc1xuICovXG5mdW5jdGlvbiBhcHBseUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUgPSAwLCBzY2FsZSA9IDEsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIGF4aXMubWluID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWluLCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xuICAgIGF4aXMubWF4ID0gYXBwbHlQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgYm94XG4gKi9cbmZ1bmN0aW9uIGFwcGx5Qm94RGVsdGEoYm94LCB7IHgsIHkgfSkge1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC54LCB4LnRyYW5zbGF0ZSwgeC5zY2FsZSwgeC5vcmlnaW5Qb2ludCk7XG4gICAgYXBwbHlBeGlzRGVsdGEoYm94LnksIHkudHJhbnNsYXRlLCB5LnNjYWxlLCB5Lm9yaWdpblBvaW50KTtcbn1cbmNvbnN0IFRSRUVfU0NBTEVfU05BUF9NSU4gPSAwLjk5OTk5OTk5OTk5OTtcbmNvbnN0IFRSRUVfU0NBTEVfU05BUF9NQVggPSAxLjAwMDAwMDAwMDAwMDE7XG4vKipcbiAqIEFwcGx5IGEgdHJlZSBvZiBkZWx0YXMgdG8gYSBib3guIFdlIGRvIHRoaXMgdG8gY2FsY3VsYXRlIHRoZSBlZmZlY3Qgb2YgYWxsIHRoZSB0cmFuc2Zvcm1zXG4gKiBpbiBhIHRyZWUgdXBvbiBvdXIgYm94IGJlZm9yZSB0aGVuIGNhbGN1bGF0aW5nIGhvdyB0byBwcm9qZWN0IGl0IGludG8gb3VyIGRlc2lyZWQgdmlld3BvcnQtcmVsYXRpdmUgYm94XG4gKlxuICogVGhpcyBpcyB0aGUgZmluYWwgbmVzdGVkIGxvb3Agd2l0aGluIHVwZGF0ZUxheW91dERlbHRhIGZvciBmdXR1cmUgcmVmYWN0b3JpbmdcbiAqL1xuZnVuY3Rpb24gYXBwbHlUcmVlRGVsdGFzKGJveCwgdHJlZVNjYWxlLCB0cmVlUGF0aCwgaXNTaGFyZWRUcmFuc2l0aW9uID0gZmFsc2UpIHtcbiAgICBjb25zdCB0cmVlTGVuZ3RoID0gdHJlZVBhdGgubGVuZ3RoO1xuICAgIGlmICghdHJlZUxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFJlc2V0IHRoZSB0cmVlU2NhbGVcbiAgICB0cmVlU2NhbGUueCA9IHRyZWVTY2FsZS55ID0gMTtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZGVsdGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IHRyZWVQYXRoW2ldO1xuICAgICAgICBkZWx0YSA9IG5vZGUucHJvamVjdGlvbkRlbHRhO1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogUHJlZmVyIHRvIHJlbW92ZSB0aGlzLCBidXQgY3VycmVudGx5IHdlIGhhdmUgbW90aW9uIGNvbXBvbmVudHMgd2l0aFxuICAgICAgICAgKiBkaXNwbGF5OiBjb250ZW50cyBpbiBGcmFtZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiZcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQucHJvcHMuc3R5bGUgJiZcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQucHJvcHMuc3R5bGUuZGlzcGxheSA9PT0gXCJjb250ZW50c1wiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmXG4gICAgICAgICAgICBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICBub2RlLnNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZSAhPT0gbm9kZS5yb290KSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3goYm94LCB7XG4gICAgICAgICAgICAgICAgeDogLW5vZGUuc2Nyb2xsLm9mZnNldC54LFxuICAgICAgICAgICAgICAgIHk6IC1ub2RlLnNjcm9sbC5vZmZzZXQueSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgLy8gSW5jb3BvcmF0ZSBlYWNoIGFuY2VzdG9yJ3Mgc2NhbGUgaW50byBhIGN1bG11bGF0aXZlIHRyZWVTY2FsZSBmb3IgdGhpcyBjb21wb25lbnRcbiAgICAgICAgICAgIHRyZWVTY2FsZS54ICo9IGRlbHRhLnguc2NhbGU7XG4gICAgICAgICAgICB0cmVlU2NhbGUueSAqPSBkZWx0YS55LnNjYWxlO1xuICAgICAgICAgICAgLy8gQXBwbHkgZWFjaCBhbmNlc3RvcidzIGNhbGN1bGF0ZWQgZGVsdGEgaW50byB0aGlzIGNvbXBvbmVudCdzIHJlY29yZGVkIGxheW91dCBib3hcbiAgICAgICAgICAgIGFwcGx5Qm94RGVsdGEoYm94LCBkZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJiBoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3goYm94LCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU25hcCB0cmVlIHNjYWxlIGJhY2sgdG8gMSBpZiBpdCdzIHdpdGhpbiBhIG5vbi1wZXJjZWl2YWJsZSB0aHJlc2hvbGQuXG4gICAgICogVGhpcyB3aWxsIGhlbHAgcmVkdWNlIHVzZWxlc3Mgc2NhbGVzIGdldHRpbmcgcmVuZGVyZWQuXG4gICAgICovXG4gICAgaWYgKHRyZWVTY2FsZS54IDwgVFJFRV9TQ0FMRV9TTkFQX01BWCAmJlxuICAgICAgICB0cmVlU2NhbGUueCA+IFRSRUVfU0NBTEVfU05BUF9NSU4pIHtcbiAgICAgICAgdHJlZVNjYWxlLnggPSAxLjA7XG4gICAgfVxuICAgIGlmICh0cmVlU2NhbGUueSA8IFRSRUVfU0NBTEVfU05BUF9NQVggJiZcbiAgICAgICAgdHJlZVNjYWxlLnkgPiBUUkVFX1NDQUxFX1NOQVBfTUlOKSB7XG4gICAgICAgIHRyZWVTY2FsZS55ID0gMS4wO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZUF4aXMoYXhpcywgZGlzdGFuY2UpIHtcbiAgICBheGlzLm1pbiA9IGF4aXMubWluICsgZGlzdGFuY2U7XG4gICAgYXhpcy5tYXggPSBheGlzLm1heCArIGRpc3RhbmNlO1xufVxuLyoqXG4gKiBBcHBseSBhIHRyYW5zZm9ybSB0byBhbiBheGlzIGZyb20gdGhlIGxhdGVzdCByZXNvbHZlZCBtb3Rpb24gdmFsdWVzLlxuICogVGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIGEgZmxhdCBtb3Rpb24gdmFsdWUgbWFwXG4gKiBhbmQgYXBwbHlBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQXhpcyhheGlzLCBheGlzVHJhbnNsYXRlLCBheGlzU2NhbGUsIGJveFNjYWxlLCBheGlzT3JpZ2luID0gMC41KSB7XG4gICAgY29uc3Qgb3JpZ2luUG9pbnQgPSBtaXhOdW1iZXIoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgICAvLyBBcHBseSB0aGUgYXhpcyBkZWx0YSB0byB0aGUgZmluYWwgYXhpc1xuICAgIGFwcGx5QXhpc0RlbHRhKGF4aXMsIGF4aXNUcmFuc2xhdGUsIGF4aXNTY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYSBib3ggZnJvbSB0aGUgbGF0ZXN0IHJlc29sdmVkIG1vdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICAgIHRyYW5zZm9ybUF4aXMoYm94LngsIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0uc2NhbGVYLCB0cmFuc2Zvcm0uc2NhbGUsIHRyYW5zZm9ybS5vcmlnaW5YKTtcbiAgICB0cmFuc2Zvcm1BeGlzKGJveC55LCB0cmFuc2Zvcm0ueSwgdHJhbnNmb3JtLnNjYWxlWSwgdHJhbnNmb3JtLnNjYWxlLCB0cmFuc2Zvcm0ub3JpZ2luWSk7XG59XG5cbmV4cG9ydCB7IGFwcGx5QXhpc0RlbHRhLCBhcHBseUJveERlbHRhLCBhcHBseVBvaW50RGVsdGEsIGFwcGx5VHJlZURlbHRhcywgc2NhbGVQb2ludCwgdHJhbnNmb3JtQXhpcywgdHJhbnNmb3JtQm94LCB0cmFuc2xhdGVBeGlzIH07XG4iLCJpbXBvcnQgeyBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCwgdHJhbnNmb3JtQm94UG9pbnRzIH0gZnJvbSAnLi4vZ2VvbWV0cnkvY29udmVyc2lvbi5tanMnO1xuaW1wb3J0IHsgdHJhbnNsYXRlQXhpcyB9IGZyb20gJy4uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qcyc7XG5cbmZ1bmN0aW9uIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUG9pbnQpIHtcbiAgICByZXR1cm4gY29udmVydEJvdW5kaW5nQm94VG9Cb3godHJhbnNmb3JtQm94UG9pbnRzKGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cmFuc2Zvcm1Qb2ludCkpO1xufVxuZnVuY3Rpb24gbWVhc3VyZVBhZ2VCb3goZWxlbWVudCwgcm9vdFByb2plY3Rpb25Ob2RlLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydEJveCA9IG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIGNvbnN0IHsgc2Nyb2xsIH0gPSByb290UHJvamVjdGlvbk5vZGU7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbC5vZmZzZXQueCk7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueSwgc2Nyb2xsLm9mZnNldC55KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdwb3J0Qm94O1xufVxuXG5leHBvcnQgeyBtZWFzdXJlUGFnZUJveCwgbWVhc3VyZVZpZXdwb3J0Qm94IH07XG4iLCIvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vbW90aW9uZGl2aXNpb24vbW90aW9uL2lzc3Vlcy8yMjcwXG5jb25zdCBnZXRDb250ZXh0V2luZG93ID0gKHsgY3VycmVudCB9KSA9PiB7XG4gICAgcmV0dXJuIGN1cnJlbnQgPyBjdXJyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBudWxsO1xufTtcblxuZXhwb3J0IHsgZ2V0Q29udGV4dFdpbmRvdyB9O1xuIiwiaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IHNldERyYWdMb2NrIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBQYW5TZXNzaW9uIH0gZnJvbSAnLi4vcGFuL1BhblNlc3Npb24ubWpzJztcbmltcG9ydCB7IGlzUmVmT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtcmVmLW9iamVjdC5tanMnO1xuaW1wb3J0IHsgYWRkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi4vLi4vZXZlbnRzL2FkZC1wb2ludGVyLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBhcHBseUNvbnN0cmFpbnRzLCBjYWxjUmVsYXRpdmVDb25zdHJhaW50cywgcmVzb2x2ZURyYWdFbGFzdGljLCByZWJhc2VBeGlzQ29uc3RyYWludHMsIGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzLCBjYWxjT3JpZ2luLCBkZWZhdWx0RWxhc3RpYyB9IGZyb20gJy4vdXRpbHMvY29uc3RyYWludHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUJveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5pbXBvcnQgeyBlYWNoQXhpcyB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vdXRpbHMvZWFjaC1heGlzLm1qcyc7XG5pbXBvcnQgeyBtZWFzdXJlUGFnZUJveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vdXRpbHMvbWVhc3VyZS5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdEV2ZW50SW5mbyB9IGZyb20gJy4uLy4uL2V2ZW50cy9ldmVudC1pbmZvLm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCwgY29udmVydEJvdW5kaW5nQm94VG9Cb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IGFkZERvbUV2ZW50IH0gZnJvbSAnLi4vLi4vZXZlbnRzL2FkZC1kb20tZXZlbnQubWpzJztcbmltcG9ydCB7IGNhbGNMZW5ndGggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcbmltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcbmltcG9ydCB7IHBlcmNlbnQgfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL3VuaXRzLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vaW50ZXJmYWNlcy9tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGdldENvbnRleHRXaW5kb3cgfSBmcm9tICcuLi8uLi91dGlscy9nZXQtY29udGV4dC13aW5kb3cubWpzJztcbmltcG9ydCB7IGFkZFZhbHVlVG9XaWxsQ2hhbmdlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXNlLXdpbGwtY2hhbmdlL2FkZC13aWxsLWNoYW5nZS5tanMnO1xuaW1wb3J0IHsgZnJhbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuY29uc3QgZWxlbWVudERyYWdDb250cm9scyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqXG4gKi9cbi8vIGxldCBsYXRlc3RQb2ludGVyRXZlbnQ6IFBvaW50ZXJFdmVudFxuY2xhc3MgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyB7XG4gICAgY29uc3RydWN0b3IodmlzdWFsRWxlbWVudCkge1xuICAgICAgICB0aGlzLm9wZW5EcmFnTG9jayA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpblBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVybWl0dGVkIGJvdW5kYXJpZXMgb2YgdHJhdmVsLCBpbiBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGVyLWF4aXMgcmVzb2x2ZWQgZWxhc3RpYyB2YWx1ZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVsYXN0aWMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudDtcbiAgICB9XG4gICAgc3RhcnQob3JpZ2luRXZlbnQsIHsgc25hcFRvQ3Vyc29yID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb24ndCBzdGFydCBkcmFnZ2luZyBpZiB0aGlzIGNvbXBvbmVudCBpcyBleGl0aW5nXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB7IHByZXNlbmNlQ29udGV4dCB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICBpZiAocHJlc2VuY2VDb250ZXh0ICYmIHByZXNlbmNlQ29udGV4dC5pc1ByZXNlbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvblNlc3Npb25TdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnU25hcFRvT3JpZ2luIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICAvLyBTdG9wIG9yIHBhdXNlIGFueSBhbmltYXRpb25zIG9uIGJvdGggYXhpcyB2YWx1ZXMgaW1tZWRpYXRlbHkuIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIHRocm93IGFuZCBjYXRjaFxuICAgICAgICAgICAgLy8gdGhlIGNvbXBvbmVudC5cbiAgICAgICAgICAgIGRyYWdTbmFwVG9PcmlnaW4gPyB0aGlzLnBhdXNlQW5pbWF0aW9uKCkgOiB0aGlzLnN0b3BBbmltYXRpb24oKTtcbiAgICAgICAgICAgIGlmIChzbmFwVG9DdXJzb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBUb0N1cnNvcihleHRyYWN0RXZlbnRJbmZvKGV2ZW50KS5wb2ludCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uU3RhcnQgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiB0aGUgZ2xvYmFsIGRyYWcgZ2VzdHVyZSBsb2NrIC0gbWF5YmUgbWFrZSB0aGlzIHBhcnQgb2YgUGFuU2Vzc2lvblxuICAgICAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnUHJvcGFnYXRpb24sIG9uRHJhZ1N0YXJ0IH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBpZiAoZHJhZyAmJiAhZHJhZ1Byb3BhZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlbkRyYWdMb2NrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jaygpO1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbkRyYWdMb2NrID0gc2V0RHJhZ0xvY2soZHJhZyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uICd0IGhhdmUgdGhlIGxvY2ssIGRvbid0IHN0YXJ0IGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wZW5EcmFnTG9jaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERpcmVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgaWYgKHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29yZCBnZXN0dXJlIG9yaWdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuZ2V0KCkgfHwgMDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgTW90aW9uVmFsdWUgaXMgYSBwZXJjZW50YWdlIHZhbHVlIGNvbnZlcnQgdG8gcHhcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVhc3VyZWRBeGlzID0gcHJvamVjdGlvbi5sYXlvdXQubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1lYXN1cmVkQXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobWVhc3VyZWRBeGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbGVuZ3RoICogKHBhcnNlRmxvYXQoY3VycmVudCkgLyAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gPSBjdXJyZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBGaXJlIG9uRHJhZ1N0YXJ0IGV2ZW50XG4gICAgICAgICAgICBpZiAob25EcmFnU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IG9uRHJhZ1N0YXJ0KGV2ZW50LCBpbmZvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRWYWx1ZVRvV2lsbENoYW5nZSh0aGlzLnZpc3VhbEVsZW1lbnQsIFwidHJhbnNmb3JtXCIpO1xuICAgICAgICAgICAgY29uc3QgeyBhbmltYXRpb25TdGF0ZSB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgYW5pbWF0aW9uU3RhdGUgJiYgYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVEcmFnXCIsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbk1vdmUgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgIC8vIGxhdGVzdFBvaW50ZXJFdmVudCA9IGV2ZW50XG4gICAgICAgICAgICBjb25zdCB7IGRyYWdQcm9wYWdhdGlvbiwgZHJhZ0RpcmVjdGlvbkxvY2ssIG9uRGlyZWN0aW9uTG9jaywgb25EcmFnLCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IHN1Y2Nlc3NmdWxseSByZWNlaXZlIHRoZSBnZXN0dXJlIGxvY2ssIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmICF0aGlzLm9wZW5EcmFnTG9jaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gaW5mbztcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZGV0ZWN0IGRyYWcgZGlyZWN0aW9uIGlmIGRpcmVjdGlvbkxvY2sgaXMgdHJ1ZVxuICAgICAgICAgICAgaWYgKGRyYWdEaXJlY3Rpb25Mb2NrICYmIHRoaXMuY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERpcmVjdGlvbiA9IGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBzdWNjZXNzZnVsbHkgc2V0IGEgZGlyZWN0aW9uLCBub3RpZnkgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RGlyZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRGlyZWN0aW9uTG9jayAmJiBvbkRpcmVjdGlvbkxvY2sodGhpcy5jdXJyZW50RGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVXBkYXRlIGVhY2ggcG9pbnQgd2l0aCB0aGUgbGF0ZXN0IHBvc2l0aW9uXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF4aXMoXCJ4XCIsIGluZm8ucG9pbnQsIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUF4aXMoXCJ5XCIsIGluZm8ucG9pbnQsIG9mZnNldCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElkZWFsbHkgd2Ugd291bGQgbGVhdmUgdGhlIHJlbmRlcmVyIHRvIGZpcmUgbmF0dXJhbGx5IGF0IHRoZSBlbmQgb2ZcbiAgICAgICAgICAgICAqIHRoaXMgZnJhbWUgYnV0IGlmIHRoZSBlbGVtZW50IGlzIGFib3V0IHRvIGNoYW5nZSBsYXlvdXQgYXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICogb2YgYSByZS1yZW5kZXIgd2Ugd2FudCB0byBlbnN1cmUgdGhlIGJyb3dzZXIgY2FuIHJlYWQgdGhlIGxhdGVzdFxuICAgICAgICAgICAgICogYm91bmRpbmcgYm94IHRvIGVuc3VyZSB0aGUgcG9pbnRlciBhbmQgZWxlbWVudCBkb24ndCBmYWxsIG91dCBvZiBzeW5jLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgbXVzdCBmaXJlIGFmdGVyIHRoZSByZW5kZXIgY2FsbCBhcyBpdCBtaWdodCB0cmlnZ2VyIGEgc3RhdGVcbiAgICAgICAgICAgICAqIGNoYW5nZSB3aGljaCBpdHNlbGYgbWlnaHQgdHJpZ2dlciBhIGxheW91dCB1cGRhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uRHJhZyAmJiBvbkRyYWcoZXZlbnQsIGluZm8pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblNlc3Npb25FbmQgPSAoZXZlbnQsIGluZm8pID0+IHRoaXMuc3RvcChldmVudCwgaW5mbyk7XG4gICAgICAgIGNvbnN0IHJlc3VtZUFuaW1hdGlvbiA9ICgpID0+IGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmltYXRpb25TdGF0ZShheGlzKSA9PT0gXCJwYXVzZWRcIiAmJlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5hbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wbGF5KCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyBkcmFnU25hcFRvT3JpZ2luIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiA9IG5ldyBQYW5TZXNzaW9uKG9yaWdpbkV2ZW50LCB7XG4gICAgICAgICAgICBvblNlc3Npb25TdGFydCxcbiAgICAgICAgICAgIG9uU3RhcnQsXG4gICAgICAgICAgICBvbk1vdmUsXG4gICAgICAgICAgICBvblNlc3Npb25FbmQsXG4gICAgICAgICAgICByZXN1bWVBbmltYXRpb24sXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpLFxuICAgICAgICAgICAgZHJhZ1NuYXBUb09yaWdpbixcbiAgICAgICAgICAgIGNvbnRleHRXaW5kb3c6IGdldENvbnRleHRXaW5kb3codGhpcy52aXN1YWxFbGVtZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgY29uc3QgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZztcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSBpbmZvO1xuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKHZlbG9jaXR5KTtcbiAgICAgICAgY29uc3QgeyBvbkRyYWdFbmQgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKG9uRHJhZ0VuZCkge1xuICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBvbkRyYWdFbmQoZXZlbnQsIGluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24sIGFuaW1hdGlvblN0YXRlIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiAmJiB0aGlzLnBhblNlc3Npb24uZW5kKCk7XG4gICAgICAgIHRoaXMucGFuU2Vzc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgeyBkcmFnUHJvcGFnYXRpb24gfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgdGhpcy5vcGVuRHJhZ0xvY2spIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkRyYWdMb2NrKCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbWF0aW9uU3RhdGUgJiYgYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVEcmFnXCIsIGZhbHNlKTtcbiAgICB9XG4gICAgdXBkYXRlQXhpcyhheGlzLCBfcG9pbnQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCB7IGRyYWcgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIHRoaXMgYXhpcywgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgICAgICBpZiAoIW9mZnNldCB8fCAhc2hvdWxkRHJhZyhheGlzLCBkcmFnLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm9yaWdpblBvaW50W2F4aXNdICsgb2Zmc2V0W2F4aXNdO1xuICAgICAgICAvLyBBcHBseSBjb25zdHJhaW50c1xuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50cyAmJiB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKSB7XG4gICAgICAgICAgICBuZXh0ID0gYXBwbHlDb25zdHJhaW50cyhuZXh0LCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdLCB0aGlzLmVsYXN0aWNbYXhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGF4aXNWYWx1ZS5zZXQobmV4dCk7XG4gICAgfVxuICAgIHJlc29sdmVDb25zdHJhaW50cygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50cywgZHJhZ0VsYXN0aWMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgbGF5b3V0ID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24gJiZcbiAgICAgICAgICAgICF0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5sYXlvdXRcbiAgICAgICAgICAgID8gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24ubWVhc3VyZShmYWxzZSlcbiAgICAgICAgICAgIDogKF9hID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXQ7XG4gICAgICAgIGNvbnN0IHByZXZDb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMucmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGxheW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXQubGF5b3V0Qm94LCBkcmFnQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxhc3RpYyA9IHJlc29sdmVEcmFnRWxhc3RpYyhkcmFnRWxhc3RpYyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBvdXRwdXR0aW5nIHRvIGV4dGVybmFsIE1vdGlvblZhbHVlcywgd2Ugd2FudCB0byByZWJhc2UgdGhlIG1lYXN1cmVkIGNvbnN0cmFpbnRzXG4gICAgICAgICAqIGZyb20gdmlld3BvcnQtcmVsYXRpdmUgdG8gY29tcG9uZW50LXJlbGF0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByZXZDb25zdHJhaW50cyAhPT0gdGhpcy5jb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgbGF5b3V0ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICAhdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHNbYXhpc10gPSByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LmxheW91dEJveFtheGlzXSwgdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCkge1xuICAgICAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50czogY29uc3RyYWludHMsIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBpZiAoIWNvbnN0cmFpbnRzIHx8ICFpc1JlZk9iamVjdChjb25zdHJhaW50cykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzRWxlbWVudCA9IGNvbnN0cmFpbnRzLmN1cnJlbnQ7XG4gICAgICAgIGludmFyaWFudChjb25zdHJhaW50c0VsZW1lbnQgIT09IG51bGwsIFwiSWYgYGRyYWdDb25zdHJhaW50c2AgaXMgc2V0IGFzIGEgUmVhY3QgcmVmLCB0aGF0IHJlZiBtdXN0IGJlIHBhc3NlZCB0byBhbm90aGVyIGNvbXBvbmVudCdzIGByZWZgIHByb3AuXCIpO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBpZiAoIXByb2plY3Rpb24gfHwgIXByb2plY3Rpb24ubGF5b3V0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0JveCA9IG1lYXN1cmVQYWdlQm94KGNvbnN0cmFpbnRzRWxlbWVudCwgcHJvamVjdGlvbi5yb290LCB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkpO1xuICAgICAgICBsZXQgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveCwgY29uc3RyYWludHNCb3gpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUncyBhbiBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgbGlzdGVuZXIgd2UgY2FsbCBpdCBhbmRcbiAgICAgICAgICogaWYgZGlmZmVyZW50IGNvbnN0cmFpbnRzIGFyZSByZXR1cm5lZCwgc2V0IGNvbnN0cmFpbnRzIHRvIHRoYXRcbiAgICAgICAgICovXG4gICAgICAgIGlmIChvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJDb25zdHJhaW50cyA9IG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyhjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveChtZWFzdXJlZENvbnN0cmFpbnRzKSk7XG4gICAgICAgICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9ICEhdXNlckNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgaWYgKHVzZXJDb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgIG1lYXN1cmVkQ29uc3RyYWludHMgPSBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh1c2VyQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZWFzdXJlZENvbnN0cmFpbnRzO1xuICAgIH1cbiAgICBzdGFydEFuaW1hdGlvbih2ZWxvY2l0eSkge1xuICAgICAgICBjb25zdCB7IGRyYWcsIGRyYWdNb21lbnR1bSwgZHJhZ0VsYXN0aWMsIGRyYWdUcmFuc2l0aW9uLCBkcmFnU25hcFRvT3JpZ2luLCBvbkRyYWdUcmFuc2l0aW9uRW5kLCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHMgfHwge307XG4gICAgICAgIGNvbnN0IG1vbWVudHVtQW5pbWF0aW9ucyA9IGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0cmFuc2l0aW9uID0gKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzW2F4aXNdKSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChkcmFnU25hcFRvT3JpZ2luKVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gPSB7IG1pbjogMCwgbWF4OiAwIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE92ZXJkYW1wIHRoZSBib3VuZGFyeSBzcHJpbmcgaWYgYGRyYWdFbGFzdGljYCBpcyBkaXNhYmxlZC4gVGhlcmUncyBzdGlsbCBhIGZyYW1lXG4gICAgICAgICAgICAgKiBvZiBzcHJpbmcgYW5pbWF0aW9ucyBzbyB3ZSBzaG91bGQgbG9vayBpbnRvIGFkZGluZyBhIGRpc2FibGUgc3ByaW5nIG9wdGlvbiB0byBgaW5lcnRpYWAuXG4gICAgICAgICAgICAgKiBXZSBjb3VsZCBkbyBzb21ldGhpbmcgaGVyZSB3aGVyZSB3ZSBhZmZlY3QgdGhlIGBib3VuY2VTdGlmZm5lc3NgIGFuZCBgYm91bmNlRGFtcGluZ2BcbiAgICAgICAgICAgICAqIHVzaW5nIHRoZSB2YWx1ZSBvZiBgZHJhZ0VsYXN0aWNgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBib3VuY2VTdGlmZm5lc3MgPSBkcmFnRWxhc3RpYyA/IDIwMCA6IDEwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBib3VuY2VEYW1waW5nID0gZHJhZ0VsYXN0aWMgPyA0MCA6IDEwMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgaW5lcnRpYSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImluZXJ0aWFcIixcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eTogZHJhZ01vbWVudHVtID8gdmVsb2NpdHlbYXhpc10gOiAwLFxuICAgICAgICAgICAgICAgIGJvdW5jZVN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICBib3VuY2VEYW1waW5nLFxuICAgICAgICAgICAgICAgIHRpbWVDb25zdGFudDogNzUwLFxuICAgICAgICAgICAgICAgIHJlc3REZWx0YTogMSxcbiAgICAgICAgICAgICAgICByZXN0U3BlZWQ6IDEwLFxuICAgICAgICAgICAgICAgIC4uLmRyYWdUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIC4uLnRyYW5zaXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGFuaW1hdGluZyBvbiBhbiBleHRlcm5hbGx5LXByb3ZpZGVkIGBNb3Rpb25WYWx1ZWAgd2UgY2FuIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCdzIGFuaW1hdGlvbiBjb250cm9scyB3aGljaCB3aWxsIGhhbmRsZSBpbnRlcmFjdGlvbnMgd2l0aCB3aGlsZUhvdmVyIChldGMpLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgaGF2ZSB0byBhbmltYXRlIHRoZSBgTW90aW9uVmFsdWVgIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIGluZXJ0aWEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gUnVuIGFsbCBhbmltYXRpb25zIGFuZCB0aGVuIHJlc29sdmUgdGhlIG5ldyBkcmFnIGNvbnN0cmFpbnRzLlxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobW9tZW50dW1BbmltYXRpb25zKS50aGVuKG9uRHJhZ1RyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgICBzdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCB0cmFuc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICBhZGRWYWx1ZVRvV2lsbENoYW5nZSh0aGlzLnZpc3VhbEVsZW1lbnQsIGF4aXMpO1xuICAgICAgICByZXR1cm4gYXhpc1ZhbHVlLnN0YXJ0KGFuaW1hdGVNb3Rpb25WYWx1ZShheGlzLCBheGlzVmFsdWUsIDAsIHRyYW5zaXRpb24sIHRoaXMudmlzdWFsRWxlbWVudCwgZmFsc2UpKTtcbiAgICB9XG4gICAgc3RvcEFuaW1hdGlvbigpIHtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLnN0b3AoKSk7XG4gICAgfVxuICAgIHBhdXNlQW5pbWF0aW9uKCkge1xuICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5hbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgpOyB9KTtcbiAgICB9XG4gICAgZ2V0QW5pbWF0aW9uU3RhdGUoYXhpcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5hbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHJhZyB3b3JrcyBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb24gd2hpY2ggcHJvcHMgYXJlIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogLSBJZiBfZHJhZ1ggYW5kIF9kcmFnWSBhcmUgcHJvdmlkZWQsIHdlIG91dHB1dCB0aGUgZ2VzdHVyZSBkZWx0YSBkaXJlY3RseSB0byB0aG9zZSBtb3Rpb24gdmFsdWVzLlxuICAgICAqIC0gT3RoZXJ3aXNlLCB3ZSBhcHBseSB0aGUgZGVsdGEgdG8gdGhlIHgveSBtb3Rpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIGdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSB7XG4gICAgICAgIGNvbnN0IGRyYWdLZXkgPSBgX2RyYWcke2F4aXMudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCBleHRlcm5hbE1vdGlvblZhbHVlID0gcHJvcHNbZHJhZ0tleV07XG4gICAgICAgIHJldHVybiBleHRlcm5hbE1vdGlvblZhbHVlXG4gICAgICAgICAgICA/IGV4dGVybmFsTW90aW9uVmFsdWVcbiAgICAgICAgICAgIDogdGhpcy52aXN1YWxFbGVtZW50LmdldFZhbHVlKGF4aXMsIChwcm9wcy5pbml0aWFsXG4gICAgICAgICAgICAgICAgPyBwcm9wcy5pbml0aWFsW2F4aXNdXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpIHx8IDApO1xuICAgIH1cbiAgICBzbmFwVG9DdXJzb3IocG9pbnQpIHtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGRyYWdnaW5nIHRoaXMgYXhpcywgZG8gYW4gZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uICYmIHByb2plY3Rpb24ubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gcHJvamVjdGlvbi5sYXlvdXQubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgICAgICAgIGF4aXNWYWx1ZS5zZXQocG9pbnRbYXhpc10gLSBtaXhOdW1iZXIobWluLCBtYXgsIDAuNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgdmlld3BvcnQgcmVzaXplcyB3ZSB3YW50IHRvIGNoZWNrIGlmIHRoZSBtZWFzdXJlZCBjb25zdHJhaW50c1xuICAgICAqIGhhdmUgY2hhbmdlZCBhbmQsIGlmIHNvLCByZXBvc2l0aW9uIHRoZSBlbGVtZW50IHdpdGhpbiB0aG9zZSBuZXcgY29uc3RyYWludHNcbiAgICAgKiByZWxhdGl2ZSB0byB3aGVyZSBpdCB3YXMgYmVmb3JlIHRoZSByZXNpemUuXG4gICAgICovXG4gICAgc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGRyYWcsIGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKCFpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpIHx8ICFwcm9qZWN0aW9uIHx8ICF0aGlzLmNvbnN0cmFpbnRzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RvcCBjdXJyZW50IGFuaW1hdGlvbnMgYXMgdGhlcmUgY2FuIGJlIHZpc3VhbCBnbGl0Y2hpbmcgaWYgd2UgdHJ5IHRvIGRvXG4gICAgICAgICAqIHRoaXMgbWlkLWFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWNvcmQgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIGJveCBhbmQgc2F2ZSBhcyBhIHByb2dyZXNzIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYm94UHJvZ3Jlc3MgPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgaWYgKGF4aXNWYWx1ZSAmJiB0aGlzLmNvbnN0cmFpbnRzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdCA9IGF4aXNWYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICBib3hQcm9ncmVzc1theGlzXSA9IGNhbGNPcmlnaW4oeyBtaW46IGxhdGVzdCwgbWF4OiBsYXRlc3QgfSwgdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhpcyBlbGVtZW50IGFuZCByZXNvbHZlIHRoZSBsYXRlc3QgZHJhZyBjb25zdHJhaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm1UZW1wbGF0ZSB9ID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKVxuICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgcHJvamVjdGlvbi5yb290ICYmIHByb2plY3Rpb24ucm9vdC51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgcHJvamVjdGlvbi51cGRhdGVMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBlYWNoIGF4aXMsIGNhbGN1bGF0ZSB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgbGF5b3V0IGF4aXNcbiAgICAgICAgICogd2l0aGluIHRoZSBuZXcgY29uc3RyYWludHMuXG4gICAgICAgICAqL1xuICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsY3VsYXRlIGEgbmV3IHRyYW5zZm9ybSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgYm94IHByb2dyZXNzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcy5jb25zdHJhaW50c1theGlzXTtcbiAgICAgICAgICAgIGF4aXNWYWx1ZS5zZXQobWl4TnVtYmVyKG1pbiwgbWF4LCBib3hQcm9ncmVzc1theGlzXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbGVtZW50RHJhZ0NvbnRyb2xzLnNldCh0aGlzLnZpc3VhbEVsZW1lbnQsIHRoaXMpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSBwb2ludGVyZG93biBldmVudCBsaXN0ZW5lciBvbiB0aGlzIERPTSBlbGVtZW50IHRvIGluaXRpYXRlIGRyYWcgdHJhY2tpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdG9wUG9pbnRlckxpc3RlbmVyID0gYWRkUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRyYWcsIGRyYWdMaXN0ZW5lciA9IHRydWUgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIGRyYWcgJiYgZHJhZ0xpc3RlbmVyICYmIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWVhc3VyZURyYWdDb25zdHJhaW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBpZiAoaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSAmJiBkcmFnQ29uc3RyYWludHMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgY29uc3Qgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lciA9IHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1lYXN1cmVcIiwgbWVhc3VyZURyYWdDb25zdHJhaW50cyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uICYmICFwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5yb290ICYmIHByb2plY3Rpb24ucm9vdC51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUucmVhZChtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaCBhIHdpbmRvdyByZXNpemUgbGlzdGVuZXIgdG8gc2NhbGUgdGhlIGRyYWdnYWJsZSB0YXJnZXQgd2l0aGluIGl0cyBkZWZpbmVkXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIGFzIHRoZSB3aW5kb3cgcmVzaXplcy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHN0b3BSZXNpemVMaXN0ZW5lciA9IGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCdzIGxheW91dCBjaGFuZ2VzLCBjYWxjdWxhdGUgdGhlIGRlbHRhIGFuZCBhcHBseSB0aGF0IHRvXG4gICAgICAgICAqIHRoZSBkcmFnIGdlc3R1cmUncyBvcmlnaW4gcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKCh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKz0gZGVsdGFbYXhpc10udHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25WYWx1ZS5zZXQobW90aW9uVmFsdWUuZ2V0KCkgKyBkZWx0YVtheGlzXS50cmFuc2xhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3RvcFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wUG9pbnRlckxpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgJiYgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFByb3BzKCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCB7IGRyYWcgPSBmYWxzZSwgZHJhZ0RpcmVjdGlvbkxvY2sgPSBmYWxzZSwgZHJhZ1Byb3BhZ2F0aW9uID0gZmFsc2UsIGRyYWdDb25zdHJhaW50cyA9IGZhbHNlLCBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljLCBkcmFnTW9tZW50dW0gPSB0cnVlLCB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGRyYWcsXG4gICAgICAgICAgICBkcmFnRGlyZWN0aW9uTG9jayxcbiAgICAgICAgICAgIGRyYWdQcm9wYWdhdGlvbixcbiAgICAgICAgICAgIGRyYWdDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGRyYWdFbGFzdGljLFxuICAgICAgICAgICAgZHJhZ01vbWVudHVtLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3VsZERyYWcoZGlyZWN0aW9uLCBkcmFnLCBjdXJyZW50RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuICgoZHJhZyA9PT0gdHJ1ZSB8fCBkcmFnID09PSBkaXJlY3Rpb24pICYmXG4gICAgICAgIChjdXJyZW50RGlyZWN0aW9uID09PSBudWxsIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09IGRpcmVjdGlvbikpO1xufVxuLyoqXG4gKiBCYXNlZCBvbiBhbiB4L3kgb2Zmc2V0IGRldGVybWluZSB0aGUgY3VycmVudCBkcmFnIGRpcmVjdGlvbi4gSWYgYm90aCBheGlzJyBvZmZzZXRzIGFyZSBsb3dlclxuICogdGhhbiB0aGUgcHJvdmlkZWQgdGhyZXNob2xkLCByZXR1cm4gYG51bGxgLlxuICpcbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgeC95IG9mZnNldCBmcm9tIG9yaWdpbi5cbiAqIEBwYXJhbSBsb2NrVGhyZXNob2xkIC0gKE9wdGlvbmFsKSAtIHRoZSBtaW5pbXVtIGFic29sdXRlIG9mZnNldCBiZWZvcmUgd2UgY2FuIGRldGVybWluZSBhIGRyYWcgZGlyZWN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCwgbG9ja1RocmVzaG9sZCA9IDEwKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IG51bGw7XG4gICAgaWYgKE1hdGguYWJzKG9mZnNldC55KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ5XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldC54KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ4XCI7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbmV4cG9ydCB7IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMsIGVsZW1lbnREcmFnQ29udHJvbHMgfTtcbiIsImltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuLi8uLi9tb3Rpb24vZmVhdHVyZXMvRmVhdHVyZS5tanMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzIH0gZnJvbSAnLi9WaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLm1qcyc7XG5cbmNsYXNzIERyYWdHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICBzdXBlcihub2RlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzID0gbm9vcDtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgPSBub29wO1xuICAgICAgICB0aGlzLmNvbnRyb2xzID0gbmV3IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMobm9kZSk7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIHByb3ZpZGVkIGEgRHJhZ0NvbnRyb2xzIGZvciBtYW51YWwgY29udHJvbCBvdmVyIHRoZSBkcmFnIGdlc3R1cmUsXG4gICAgICAgIC8vIHN1YnNjcmliZSB0aGlzIGNvbXBvbmVudCB0byBpdCBvbiBtb3VudC5cbiAgICAgICAgY29uc3QgeyBkcmFnQ29udHJvbHMgfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICBpZiAoZHJhZ0NvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUdyb3VwQ29udHJvbHMgPSBkcmFnQ29udHJvbHMuc3Vic2NyaWJlKHRoaXMuY29udHJvbHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5jb250cm9scy5hZGRMaXN0ZW5lcnMoKSB8fCBub29wO1xuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUdyb3VwQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IERyYWdHZXN0dXJlIH07XG4iLCJpbXBvcnQgeyBQYW5TZXNzaW9uIH0gZnJvbSAnLi9QYW5TZXNzaW9uLm1qcyc7XG5pbXBvcnQgeyBhZGRQb2ludGVyRXZlbnQgfSBmcm9tICcuLi8uLi9ldmVudHMvYWRkLXBvaW50ZXItZXZlbnQubWpzJztcbmltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuLi8uLi9tb3Rpb24vZmVhdHVyZXMvRmVhdHVyZS5tanMnO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBnZXRDb250ZXh0V2luZG93IH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2V0LWNvbnRleHQtd2luZG93Lm1qcyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5jb25zdCBhc3luY0hhbmRsZXIgPSAoaGFuZGxlcikgPT4gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBoYW5kbGVyKGV2ZW50LCBpbmZvKSk7XG4gICAgfVxufTtcbmNsYXNzIFBhbkdlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyID0gbm9vcDtcbiAgICB9XG4gICAgb25Qb2ludGVyRG93bihwb2ludGVyRG93bkV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IG5ldyBQYW5TZXNzaW9uKHBvaW50ZXJEb3duRXZlbnQsIHRoaXMuY3JlYXRlUGFuSGFuZGxlcnMoKSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtUGFnZVBvaW50OiB0aGlzLm5vZGUuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCksXG4gICAgICAgICAgICBjb250ZXh0V2luZG93OiBnZXRDb250ZXh0V2luZG93KHRoaXMubm9kZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQYW5IYW5kbGVycygpIHtcbiAgICAgICAgY29uc3QgeyBvblBhblNlc3Npb25TdGFydCwgb25QYW5TdGFydCwgb25QYW4sIG9uUGFuRW5kIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0OiBhc3luY0hhbmRsZXIob25QYW5TZXNzaW9uU3RhcnQpLFxuICAgICAgICAgICAgb25TdGFydDogYXN5bmNIYW5kbGVyKG9uUGFuU3RhcnQpLFxuICAgICAgICAgICAgb25Nb3ZlOiBvblBhbixcbiAgICAgICAgICAgIG9uRW5kOiAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIGlmIChvblBhbkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IG9uUGFuRW5kKGV2ZW50LCBpbmZvKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9pbnRlckRvd25MaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudCh0aGlzLm5vZGUuY3VycmVudCwgXCJwb2ludGVyZG93blwiLCAoZXZlbnQpID0+IHRoaXMub25Qb2ludGVyRG93bihldmVudCkpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiAmJiB0aGlzLnNlc3Npb24udXBkYXRlSGFuZGxlcnModGhpcy5jcmVhdGVQYW5IYW5kbGVycygpKTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiAmJiB0aGlzLnNlc3Npb24uZW5kKCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYW5HZXN0dXJlIH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBQcmVzZW5jZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuXG5leHBvcnQgeyBQcmVzZW5jZUNvbnRleHQgfTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUlkLCB1c2VFZmZlY3QsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJlc2VuY2VDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcblxuLyoqXG4gKiBXaGVuIGEgY29tcG9uZW50IGlzIHRoZSBjaGlsZCBvZiBgQW5pbWF0ZVByZXNlbmNlYCwgaXQgY2FuIHVzZSBgdXNlUHJlc2VuY2VgXG4gKiB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgd2hldGhlciBpdCdzIHN0aWxsIHByZXNlbnQgaW4gdGhlIFJlYWN0IHRyZWUuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyB1c2VQcmVzZW5jZSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBleHBvcnQgY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBbaXNQcmVzZW50LCBzYWZlVG9SZW1vdmVdID0gdXNlUHJlc2VuY2UoKVxuICpcbiAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgICAhaXNQcmVzZW50ICYmIHNldFRpbWVvdXQoc2FmZVRvUmVtb3ZlLCAxMDAwKVxuICogICB9LCBbaXNQcmVzZW50XSlcbiAqXG4gKiAgIHJldHVybiA8ZGl2IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBJZiBgaXNQcmVzZW50YCBpcyBgZmFsc2VgLCBpdCBtZWFucyB0aGF0IGEgY29tcG9uZW50IGhhcyBiZWVuIHJlbW92ZWQgdGhlIHRyZWUsIGJ1dFxuICogYEFuaW1hdGVQcmVzZW5jZWAgd29uJ3QgcmVhbGx5IHJlbW92ZSBpdCB1bnRpbCBgc2FmZVRvUmVtb3ZlYCBoYXMgYmVlbiBjYWxsZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VQcmVzZW5jZShzdWJzY3JpYmUgPSB0cnVlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIFt0cnVlLCBudWxsXTtcbiAgICBjb25zdCB7IGlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUsIHJlZ2lzdGVyIH0gPSBjb250ZXh0O1xuICAgIC8vIEl0J3Mgc2FmZSB0byBjYWxsIHRoZSBmb2xsb3dpbmcgaG9va3MgY29uZGl0aW9uYWxseSAoYWZ0ZXIgYW4gZWFybHkgcmV0dXJuKSBiZWNhdXNlIHRoZSBjb250ZXh0IHdpbGwgYWx3YXlzXG4gICAgLy8gZWl0aGVyIGJlIG51bGwgb3Igbm9uLW51bGwgZm9yIHRoZSBsaWZlc3BhbiBvZiB0aGUgY29tcG9uZW50LlxuICAgIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc3Vic2NyaWJlKVxuICAgICAgICAgICAgcmVnaXN0ZXIoaWQpO1xuICAgIH0sIFtzdWJzY3JpYmVdKTtcbiAgICBjb25zdCBzYWZlVG9SZW1vdmUgPSB1c2VDYWxsYmFjaygoKSA9PiBzdWJzY3JpYmUgJiYgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoaWQpLCBbaWQsIG9uRXhpdENvbXBsZXRlLCBzdWJzY3JpYmVdKTtcbiAgICByZXR1cm4gIWlzUHJlc2VudCAmJiBvbkV4aXRDb21wbGV0ZSA/IFtmYWxzZSwgc2FmZVRvUmVtb3ZlXSA6IFt0cnVlXTtcbn1cbi8qKlxuICogU2ltaWxhciB0byBgdXNlUHJlc2VuY2VgLCBleGNlcHQgYHVzZUlzUHJlc2VudGAgc2ltcGx5IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyBwcmVzZW50LlxuICogVGhlcmUgaXMgbm8gYHNhZmVUb1JlbW92ZWAgZnVuY3Rpb24uXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyB1c2VJc1ByZXNlbnQgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgaXNQcmVzZW50ID0gdXNlSXNQcmVzZW50KClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBjb25zb2xlLmxvZyhcIkkndmUgYmVlbiByZW1vdmVkIVwiKVxuICogICB9LCBbaXNQcmVzZW50XSlcbiAqXG4gKiAgIHJldHVybiA8ZGl2IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZUlzUHJlc2VudCgpIHtcbiAgICByZXR1cm4gaXNQcmVzZW50KHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KSk7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID09PSBudWxsID8gdHJ1ZSA6IGNvbnRleHQuaXNQcmVzZW50O1xufVxuXG5leHBvcnQgeyBpc1ByZXNlbnQsIHVzZUlzUHJlc2VudCwgdXNlUHJlc2VuY2UgfTtcbiIsIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgTGF5b3V0R3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5cbmV4cG9ydCB7IExheW91dEdyb3VwQ29udGV4dCB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsLCBleHBvcnRlZCBvbmx5IGZvciB1c2FnZSBpbiBGcmFtZXJcbiAqL1xuY29uc3QgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5cbmV4cG9ydCB7IFN3aXRjaExheW91dEdyb3VwQ29udGV4dCB9O1xuIiwiLyoqXG4gKiBUaGlzIHNob3VsZCBvbmx5IGV2ZXIgYmUgbW9kaWZpZWQgb24gdGhlIGNsaWVudCBvdGhlcndpc2UgaXQnbGxcbiAqIHBlcnNpc3QgdGhyb3VnaCBzZXJ2ZXIgcmVxdWVzdHMuIElmIHdlIG5lZWQgaW5zdGFuY2VkIHN0YXRlcyB3ZVxuICogY291bGQgbGF6eS1pbml0IHZpYSByb290LlxuICovXG5jb25zdCBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgPSB7XG4gICAgLyoqXG4gICAgICogR2xvYmFsIGZsYWcgYXMgdG8gd2hldGhlciB0aGUgdHJlZSBoYXMgYW5pbWF0ZWQgc2luY2UgdGhlIGxhc3QgdGltZVxuICAgICAqIHdlIHJlc2l6ZWQgdGhlIHdpbmRvd1xuICAgICAqL1xuICAgIGhhc0FuaW1hdGVkU2luY2VSZXNpemU6IHRydWUsXG4gICAgLyoqXG4gICAgICogV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBvbmNlLCBvbiB0aGUgZmlyc3QgdXBkYXRlLiBBbnkgbm9kZXMgYWRkZWQgdG8gdGhlIHRyZWUgYmV5b25kIHRoYXRcbiAgICAgKiB1cGRhdGUgd2lsbCBiZSBnaXZlbiBhIGBkYXRhLXByb2plY3Rpb24taWRgIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBoYXNFdmVyVXBkYXRlZDogZmFsc2UsXG59O1xuXG5leHBvcnQgeyBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgfTtcbiIsImltcG9ydCB7IHB4IH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuXG5mdW5jdGlvbiBwaXhlbHNUb1BlcmNlbnQocGl4ZWxzLCBheGlzKSB7XG4gICAgaWYgKGF4aXMubWF4ID09PSBheGlzLm1pbilcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChwaXhlbHMgLyAoYXhpcy5tYXggLSBheGlzLm1pbikpICogMTAwO1xufVxuLyoqXG4gKiBXZSBhbHdheXMgY29ycmVjdCBib3JkZXJSYWRpdXMgYXMgYSBwZXJjZW50YWdlIHJhdGhlciB0aGFuIHBpeGVscyB0byByZWR1Y2UgcGFpbnRzLlxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBhcmUgcHJvamVjdGluZyBhIGJveCB0aGF0IGlzIDEwMHB4IHdpZGUgd2l0aCBhIDEwcHggYm9yZGVyUmFkaXVzXG4gKiBpbnRvIGEgYm94IHRoYXQgaXMgMjAwcHggd2lkZSB3aXRoIGEgMjBweCBib3JkZXJSYWRpdXMsIHRoYXQgaXMgYWN0dWFsbHkgYSAxMCVcbiAqIGJvcmRlclJhZGl1cyBpbiBib3RoIHN0YXRlcy4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGl4ZWxzIHRoYXQgd2lsbCB0cmlnZ2VyXG4gKiBhIHBhaW50IGVhY2ggdGltZS4gSWYgd2UgYW5pbWF0ZSBiZXR3ZWVuIHRoZSB0d28gaW4gcGVyY2VudGFnZSB3ZSdsbCBhdm9pZCBhIHBhaW50LlxuICovXG5jb25zdCBjb3JyZWN0Qm9yZGVyUmFkaXVzID0ge1xuICAgIGNvcnJlY3Q6IChsYXRlc3QsIG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLnRhcmdldClcbiAgICAgICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBzdHJpbmcsIGlmIGl0J3MgYSBwZXJjZW50YWdlIHdlIGNhbiByZXR1cm4gaW1tZWRpYXRlbHkgYXMgaXQnc1xuICAgICAgICAgKiBnb2luZyB0byBiZSBzdHJldGNoZWQgYXBwcm9wcmlhdGVseS4gT3RoZXJ3aXNlLCBpZiBpdCdzIGEgcGl4ZWwsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIGxhdGVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHB4LnRlc3QobGF0ZXN0KSkge1xuICAgICAgICAgICAgICAgIGxhdGVzdCA9IHBhcnNlRmxvYXQobGF0ZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGxhdGVzdCBpcyBhIG51bWJlciwgaXQncyBhIHBpeGVsIHZhbHVlLiBXZSB1c2UgdGhlIGN1cnJlbnQgdmlld3BvcnRCb3ggdG8gY2FsY3VsYXRlIHRoYXRcbiAgICAgICAgICogcGl4ZWwgdmFsdWUgYXMgYSBwZXJjZW50YWdlIG9mIGVhY2ggYXhpc1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeCA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LngpO1xuICAgICAgICBjb25zdCB5ID0gcGl4ZWxzVG9QZXJjZW50KGxhdGVzdCwgbm9kZS50YXJnZXQueSk7XG4gICAgICAgIHJldHVybiBgJHt4fSUgJHt5fSVgO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBjb3JyZWN0Qm9yZGVyUmFkaXVzLCBwaXhlbHNUb1BlcmNlbnQgfTtcbiIsImltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcbmltcG9ydCB7IGNvbXBsZXggfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2luZGV4Lm1qcyc7XG5cbmNvbnN0IGNvcnJlY3RCb3hTaGFkb3cgPSB7XG4gICAgY29ycmVjdDogKGxhdGVzdCwgeyB0cmVlU2NhbGUsIHByb2plY3Rpb25EZWx0YSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsID0gbGF0ZXN0O1xuICAgICAgICBjb25zdCBzaGFkb3cgPSBjb21wbGV4LnBhcnNlKGxhdGVzdCk7XG4gICAgICAgIC8vIFRPRE86IERvZXNuJ3Qgc3VwcG9ydCBtdWx0aXBsZSBzaGFkb3dzXG4gICAgICAgIGlmIChzaGFkb3cubGVuZ3RoID4gNSlcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGUgPSBjb21wbGV4LmNyZWF0ZVRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHR5cGVvZiBzaGFkb3dbMF0gIT09IFwibnVtYmVyXCIgPyAxIDogMDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvdmVyYWxsIGNvbnRleHQgc2NhbGVcbiAgICAgICAgY29uc3QgeFNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICAgICAgY29uc3QgeVNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICAgICAgc2hhZG93WzAgKyBvZmZzZXRdIC89IHhTY2FsZTtcbiAgICAgICAgc2hhZG93WzEgKyBvZmZzZXRdIC89IHlTY2FsZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElkZWFsbHkgd2UnZCBjb3JyZWN0IHggYW5kIHkgc2NhbGVzIGluZGl2aWR1YWxseSwgYnV0IGJlY2F1c2UgYmx1ciBhbmRcbiAgICAgICAgICogc3ByZWFkIGFwcGx5IHRvIGJvdGggd2UgaGF2ZSB0byB0YWtlIGEgc2NhbGUgYXZlcmFnZSBhbmQgYXBwbHkgdGhhdCBpbnN0ZWFkLlxuICAgICAgICAgKiBXZSBjb3VsZCBwb3RlbnRpYWxseSBpbXByb3ZlIHRoZSBvdXRjb21lIG9mIHRoaXMgYnkgaW5jb3Jwb3JhdGluZyB0aGUgcmF0aW8gYmV0d2VlblxuICAgICAgICAgKiB0aGUgdHdvIHNjYWxlcy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGF2ZXJhZ2VTY2FsZSA9IG1peE51bWJlcih4U2NhbGUsIHlTY2FsZSwgMC41KTtcbiAgICAgICAgLy8gQmx1clxuICAgICAgICBpZiAodHlwZW9mIHNoYWRvd1syICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNoYWRvd1syICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgICAgIC8vIFNwcmVhZFxuICAgICAgICBpZiAodHlwZW9mIHNoYWRvd1szICsgb2Zmc2V0XSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNoYWRvd1szICsgb2Zmc2V0XSAvPSBhdmVyYWdlU2NhbGU7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZShzaGFkb3cpO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBjb3JyZWN0Qm94U2hhZG93IH07XG4iLCJpbXBvcnQgeyBpc0NTU1ZhcmlhYmxlTmFtZSB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5cbmNvbnN0IHNjYWxlQ29ycmVjdG9ycyA9IHt9O1xuZnVuY3Rpb24gYWRkU2NhbGVDb3JyZWN0b3IoY29ycmVjdG9ycykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvcnJlY3RvcnMpIHtcbiAgICAgICAgc2NhbGVDb3JyZWN0b3JzW2tleV0gPSBjb3JyZWN0b3JzW2tleV07XG4gICAgICAgIGlmIChpc0NTU1ZhcmlhYmxlTmFtZShrZXkpKSB7XG4gICAgICAgICAgICBzY2FsZUNvcnJlY3RvcnNba2V5XS5pc0NTU1ZhcmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgYWRkU2NhbGVDb3JyZWN0b3IsIHNjYWxlQ29ycmVjdG9ycyB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlUmVuZGVyQmF0Y2hlciB9IGZyb20gJy4vYmF0Y2hlci5tanMnO1xuXG5jb25zdCB7IHNjaGVkdWxlOiBtaWNyb3Rhc2ssIGNhbmNlbDogY2FuY2VsTWljcm90YXNrIH0gPSBjcmVhdGVSZW5kZXJCYXRjaGVyKHF1ZXVlTWljcm90YXNrLCBmYWxzZSk7XG5cbmV4cG9ydCB7IGNhbmNlbE1pY3JvdGFzaywgbWljcm90YXNrIH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7IHVzZUNvbnRleHQsIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qcyc7XG5pbXBvcnQgeyBMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IGdsb2JhbFByb2plY3Rpb25TdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vbm9kZS9zdGF0ZS5tanMnO1xuaW1wb3J0IHsgY29ycmVjdEJvcmRlclJhZGl1cyB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJvcmRlci1yYWRpdXMubWpzJztcbmltcG9ydCB7IGNvcnJlY3RCb3hTaGFkb3cgfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3gtc2hhZG93Lm1qcyc7XG5pbXBvcnQgeyBhZGRTY2FsZUNvcnJlY3RvciB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzJztcbmltcG9ydCB7IG1pY3JvdGFzayB9IGZyb20gJy4uLy4uLy4uL2ZyYW1lbG9vcC9taWNyb3Rhc2subWpzJztcbmltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vLi4vLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbmNsYXNzIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBvbmx5IG1vdW50cyBwcm9qZWN0aW9uIG5vZGVzIGZvciBjb21wb25lbnRzIHRoYXRcbiAgICAgKiBuZWVkIG1lYXN1cmluZywgd2UgbWlnaHQgd2FudCB0byBkbyBpdCBmb3IgYWxsIGNvbXBvbmVudHNcbiAgICAgKiBpbiBvcmRlciB0byBpbmNvcnBvcmF0ZSB0cmFuc2Zvcm1zXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwLCBsYXlvdXRJZCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgICAgICBhZGRTY2FsZUNvcnJlY3RvcihkZWZhdWx0U2NhbGVDb3JyZWN0b3JzKTtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChsYXlvdXRHcm91cC5ncm91cClcbiAgICAgICAgICAgICAgICBsYXlvdXRHcm91cC5ncm91cC5hZGQocHJvamVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc3dpdGNoTGF5b3V0R3JvdXAgJiYgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIgJiYgbGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hMYXlvdXRHcm91cC5yZWdpc3Rlcihwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbkNvbXBsZXRlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNldE9wdGlvbnMoe1xuICAgICAgICAgICAgICAgIC4uLnByb2plY3Rpb24ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBvbkV4aXRDb21wbGV0ZTogKCkgPT4gdGhpcy5zYWZlVG9SZW1vdmUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNFdmVyVXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHByZXZQcm9wcykge1xuICAgICAgICBjb25zdCB7IGxheW91dERlcGVuZGVuY3ksIHZpc3VhbEVsZW1lbnQsIGRyYWcsIGlzUHJlc2VudCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbiA9IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBXZSB1c2UgdGhpcyBkYXRhIGluIHJlbGVnYXRlIHRvIGRldGVybWluZSB3aGV0aGVyIHRvXG4gICAgICAgICAqIHByb21vdGUgYSBwcmV2aW91cyBlbGVtZW50LiBUaGVyZSdzIG5vIGd1YXJhbnRlZSBpdHMgcHJlc2VuY2UgZGF0YVxuICAgICAgICAgKiB3aWxsIGhhdmUgdXBkYXRlZCBieSB0aGlzIHBvaW50IC0gaWYgYSBidWcgbGlrZSB0aGlzIGFyaXNlcyBpdCB3aWxsXG4gICAgICAgICAqIGhhdmUgdG8gYmUgdGhhdCB3ZSBtYXJrRm9yUmVsZWdhdGlvbiBhbmQgdGhlbiBmaW5kIGEgbmV3IGxlYWQgc29tZSBvdGhlciB3YXksXG4gICAgICAgICAqIHBlcmhhcHMgaW4gZGlkVXBkYXRlXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0aW9uLmlzUHJlc2VudCA9IGlzUHJlc2VudDtcbiAgICAgICAgaWYgKGRyYWcgfHxcbiAgICAgICAgICAgIHByZXZQcm9wcy5sYXlvdXREZXBlbmRlbmN5ICE9PSBsYXlvdXREZXBlbmRlbmN5IHx8XG4gICAgICAgICAgICBsYXlvdXREZXBlbmRlbmN5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ud2lsbFVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzLmlzUHJlc2VudCAhPT0gaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdGlvbi5wcm9tb3RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghcHJvamVjdGlvbi5yZWxlZ2F0ZSgpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlcmUncyBhbm90aGVyIHN0YWNrIG1lbWJlciB0YWtpbmcgb3ZlciBmcm9tIHRoaXMgb25lLFxuICAgICAgICAgICAgICAgICAqIGl0J3MgaW4gY2hhcmdlIG9mIHRoZSBleGl0IGFuaW1hdGlvbiBhbmQgdGhlcmVmb3JlIHNob3VsZFxuICAgICAgICAgICAgICAgICAqIGJlIGluIGNoYXJnZSBvZiB0aGUgc2FmZSB0byByZW1vdmUuIE90aGVyd2lzZSB3ZSBjYWxsIGl0IGhlcmUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gcHJvamVjdGlvbi5nZXRTdGFjaygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YWNrIHx8ICFzdGFjay5tZW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy5wcm9wcy52aXN1YWxFbGVtZW50O1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgbWljcm90YXNrLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJvamVjdGlvbi5jdXJyZW50QW5pbWF0aW9uICYmIHByb2plY3Rpb24uaXNMZWFkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXA6IHByb21vdGVDb250ZXh0LCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5zY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCk7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAgJiYgbGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgICAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAucmVtb3ZlKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHByb21vdGVDb250ZXh0ICYmIHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIpXG4gICAgICAgICAgICAgICAgcHJvbW90ZUNvbnRleHQuZGVyZWdpc3Rlcihwcm9qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzYWZlVG9SZW1vdmUoKSB7XG4gICAgICAgIGNvbnN0IHsgc2FmZVRvUmVtb3ZlIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBzYWZlVG9SZW1vdmUgJiYgc2FmZVRvUmVtb3ZlKCk7XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gTWVhc3VyZUxheW91dChwcm9wcykge1xuICAgIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpO1xuICAgIGNvbnN0IGxheW91dEdyb3VwID0gdXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIHJldHVybiAoanN4KE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCwgeyAuLi5wcm9wcywgbGF5b3V0R3JvdXA6IGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogdXNlQ29udGV4dChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpLCBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgc2FmZVRvUmVtb3ZlOiBzYWZlVG9SZW1vdmUgfSkpO1xufVxuY29uc3QgZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyA9IHtcbiAgICBib3JkZXJSYWRpdXM6IHtcbiAgICAgICAgLi4uY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICAgICAgYXBwbHlUbzogW1xuICAgICAgICAgICAgXCJib3JkZXJUb3BMZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlclRvcFJpZ2h0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbUxlZnRSYWRpdXNcIixcbiAgICAgICAgICAgIFwiYm9yZGVyQm90dG9tUmlnaHRSYWRpdXNcIixcbiAgICAgICAgXSxcbiAgICB9LFxuICAgIGJvcmRlclRvcExlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3JkZXJCb3R0b21SaWdodFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3hTaGFkb3c6IGNvcnJlY3RCb3hTaGFkb3csXG59O1xuXG5leHBvcnQgeyBNZWFzdXJlTGF5b3V0IH07XG4iLCJpbXBvcnQgeyBtb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlTW90aW9uVmFsdWUgfSBmcm9tICcuLi9pbnRlcmZhY2VzL21vdGlvbi12YWx1ZS5tanMnO1xuXG5mdW5jdGlvbiBhbmltYXRlU2luZ2xlVmFsdWUodmFsdWUsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vdGlvblZhbHVlJDEgPSBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogbW90aW9uVmFsdWUodmFsdWUpO1xuICAgIG1vdGlvblZhbHVlJDEuc3RhcnQoYW5pbWF0ZU1vdGlvblZhbHVlKFwiXCIsIG1vdGlvblZhbHVlJDEsIGtleWZyYW1lcywgb3B0aW9ucykpO1xuICAgIHJldHVybiBtb3Rpb25WYWx1ZSQxLmFuaW1hdGlvbjtcbn1cblxuZXhwb3J0IHsgYW5pbWF0ZVNpbmdsZVZhbHVlIH07XG4iLCJmdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUgIT09IFwic3ZnXCI7XG59XG5cbmV4cG9ydCB7IGlzU1ZHRWxlbWVudCB9O1xuIiwiY29uc3QgY29tcGFyZUJ5RGVwdGggPSAoYSwgYikgPT4gYS5kZXB0aCAtIGIuZGVwdGg7XG5cbmV4cG9ydCB7IGNvbXBhcmVCeURlcHRoIH07XG4iLCJpbXBvcnQgeyBhZGRVbmlxdWVJdGVtLCByZW1vdmVJdGVtIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXJyYXkubWpzJztcbmltcG9ydCB7IGNvbXBhcmVCeURlcHRoIH0gZnJvbSAnLi9jb21wYXJlLWJ5LWRlcHRoLm1qcyc7XG5cbmNsYXNzIEZsYXRUcmVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgYWRkKGNoaWxkKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICByZW1vdmUoY2hpbGQpIHtcbiAgICAgICAgcmVtb3ZlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ICYmIHRoaXMuY2hpbGRyZW4uc29ydChjb21wYXJlQnlEZXB0aCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgRmxhdFRyZWUgfTtcbiIsImltcG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi4vZnJhbWVsb29wL3N5bmMtdGltZS5tanMnO1xuaW1wb3J0IHsgZnJhbWUsIGNhbmNlbEZyYW1lIH0gZnJvbSAnLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbi8qKlxuICogVGltZW91dCBkZWZpbmVkIGluIG1zXG4gKi9cbmZ1bmN0aW9uIGRlbGF5KGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aW1lLm5vdygpO1xuICAgIGNvbnN0IGNoZWNrRWxhcHNlZCA9ICh7IHRpbWVzdGFtcCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSB0aW1lc3RhbXAgLSBzdGFydDtcbiAgICAgICAgaWYgKGVsYXBzZWQgPj0gdGltZW91dCkge1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUoY2hlY2tFbGFwc2VkKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVsYXBzZWQgLSB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZnJhbWUucmVhZChjaGVja0VsYXBzZWQsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiBjYW5jZWxGcmFtZShjaGVja0VsYXBzZWQpO1xufVxuZnVuY3Rpb24gZGVsYXlJblNlY29uZHMoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gZGVsYXkoY2FsbGJhY2ssIHNlY29uZHNUb01pbGxpc2Vjb25kcyh0aW1lb3V0KSk7XG59XG5cbmV4cG9ydCB7IGRlbGF5LCBkZWxheUluU2Vjb25kcyB9O1xuIiwiaW1wb3J0IHsgaXNDdXN0b21WYWx1ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuXG4vKipcbiAqIElmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1vdGlvblZhbHVlLCB0aGlzIHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3QgdGhlIHZhbHVlIGl0c2VsZlxuICpcbiAqIFRPRE86IFJlbW92ZSBhbmQgbW92ZSB0byBsaWJyYXJ5XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHVud3JhcHBlZFZhbHVlID0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICAgIHJldHVybiBpc0N1c3RvbVZhbHVlKHVud3JhcHBlZFZhbHVlKVxuICAgICAgICA/IHVud3JhcHBlZFZhbHVlLnRvVmFsdWUoKVxuICAgICAgICA6IHVud3JhcHBlZFZhbHVlO1xufVxuXG5leHBvcnQgeyByZXNvbHZlTW90aW9uVmFsdWUgfTtcbiIsImltcG9ydCB7IHByb2dyZXNzLCBub29wIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGNpcmNPdXQgfSBmcm9tICcuLi8uLi9lYXNpbmcvY2lyYy5tanMnO1xuaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWl4L251bWJlci5tanMnO1xuaW1wb3J0IHsgcGVyY2VudCwgcHggfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL3VuaXRzLm1qcyc7XG5cbmNvbnN0IGJvcmRlcnMgPSBbXCJUb3BMZWZ0XCIsIFwiVG9wUmlnaHRcIiwgXCJCb3R0b21MZWZ0XCIsIFwiQm90dG9tUmlnaHRcIl07XG5jb25zdCBudW1Cb3JkZXJzID0gYm9yZGVycy5sZW5ndGg7XG5jb25zdCBhc051bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IGlzUHggPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBweC50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIG1peFZhbHVlcyh0YXJnZXQsIGZvbGxvdywgbGVhZCwgcHJvZ3Jlc3MsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcikge1xuICAgIGlmIChzaG91bGRDcm9zc2ZhZGVPcGFjaXR5KSB7XG4gICAgICAgIHRhcmdldC5vcGFjaXR5ID0gbWl4TnVtYmVyKDAsIFxuICAgICAgICAvLyBUT0RPIFJlaW5zdGF0ZSB0aGlzIGlmIG9ubHkgY2hpbGRcbiAgICAgICAgbGVhZC5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBsZWFkLm9wYWNpdHkgOiAxLCBlYXNlQ3Jvc3NmYWRlSW4ocHJvZ3Jlc3MpKTtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHlFeGl0ID0gbWl4TnVtYmVyKGZvbGxvdy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBmb2xsb3cub3BhY2l0eSA6IDEsIDAsIGVhc2VDcm9zc2ZhZGVPdXQocHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPbmx5TWVtYmVyKSB7XG4gICAgICAgIHRhcmdldC5vcGFjaXR5ID0gbWl4TnVtYmVyKGZvbGxvdy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBmb2xsb3cub3BhY2l0eSA6IDEsIGxlYWQub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gbGVhZC5vcGFjaXR5IDogMSwgcHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaXggYm9yZGVyIHJhZGl1c1xuICAgICAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQm9yZGVyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJvcmRlckxhYmVsID0gYGJvcmRlciR7Ym9yZGVyc1tpXX1SYWRpdXNgO1xuICAgICAgICBsZXQgZm9sbG93UmFkaXVzID0gZ2V0UmFkaXVzKGZvbGxvdywgYm9yZGVyTGFiZWwpO1xuICAgICAgICBsZXQgbGVhZFJhZGl1cyA9IGdldFJhZGl1cyhsZWFkLCBib3JkZXJMYWJlbCk7XG4gICAgICAgIGlmIChmb2xsb3dSYWRpdXMgPT09IHVuZGVmaW5lZCAmJiBsZWFkUmFkaXVzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9sbG93UmFkaXVzIHx8IChmb2xsb3dSYWRpdXMgPSAwKTtcbiAgICAgICAgbGVhZFJhZGl1cyB8fCAobGVhZFJhZGl1cyA9IDApO1xuICAgICAgICBjb25zdCBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGxlYWRSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGlzUHgoZm9sbG93UmFkaXVzKSA9PT0gaXNQeChsZWFkUmFkaXVzKTtcbiAgICAgICAgaWYgKGNhbk1peCkge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KG1peE51bWJlcihhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MpLCAwKTtcbiAgICAgICAgICAgIGlmIChwZXJjZW50LnRlc3QobGVhZFJhZGl1cykgfHwgcGVyY2VudC50ZXN0KGZvbGxvd1JhZGl1cykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdICs9IFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IGxlYWRSYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IHJvdGF0aW9uXG4gICAgICovXG4gICAgaWYgKGZvbGxvdy5yb3RhdGUgfHwgbGVhZC5yb3RhdGUpIHtcbiAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IG1peE51bWJlcihmb2xsb3cucm90YXRlIHx8IDAsIGxlYWQucm90YXRlIHx8IDAsIHByb2dyZXNzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSYWRpdXModmFsdWVzLCByYWRpdXNOYW1lKSB7XG4gICAgcmV0dXJuIHZhbHVlc1tyYWRpdXNOYW1lXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gdmFsdWVzW3JhZGl1c05hbWVdXG4gICAgICAgIDogdmFsdWVzLmJvcmRlclJhZGl1cztcbn1cbi8vIC8qKlxuLy8gICogV2Ugb25seSB3YW50IHRvIG1peCB0aGUgYmFja2dyb3VuZCBjb2xvciBpZiB0aGVyZSdzIGEgZm9sbG93IGVsZW1lbnRcbi8vICAqIHRoYXQgd2UncmUgbm90IGNyb3NzZmFkaW5nIG9wYWNpdHkgYmV0d2Vlbi4gRm9yIGluc3RhbmNlIHdpdGggc3dpdGNoXG4vLyAgKiBBbmltYXRlU2hhcmVkTGF5b3V0IGFuaW1hdGlvbnMsIHRoaXMgaGVscHMgdGhlIGlsbHVzaW9uIG9mIGEgY29udGludW91c1xuLy8gICogZWxlbWVudCBiZWluZyBhbmltYXRlZCBidXQgYWxzbyBjdXRzIGRvd24gb24gdGhlIG51bWJlciBvZiBwYWludHMgdHJpZ2dlcmVkXG4vLyAgKiBmb3IgZWxlbWVudHMgd2hlcmUgb3BhY2l0eSBpcyBkb2luZyB0aGF0IHdvcmsgZm9yIHVzLlxuLy8gICovXG4vLyBpZiAoXG4vLyAgICAgIWhhc0ZvbGxvd0VsZW1lbnQgJiZcbi8vICAgICBsYXRlc3RMZWFkVmFsdWVzLmJhY2tncm91bmRDb2xvciAmJlxuLy8gICAgIGxhdGVzdEZvbGxvd1ZhbHVlcy5iYWNrZ3JvdW5kQ29sb3Jcbi8vICkge1xuLy8gICAgIC8qKlxuLy8gICAgICAqIFRoaXMgaXNuJ3QgaWRlYWwgcGVyZm9ybWFuY2Utd2lzZSBhcyBtaXhDb2xvciBpcyBjcmVhdGluZyBhIG5ldyBmdW5jdGlvbiBldmVyeSBmcmFtZS5cbi8vICAgICAgKiBXZSBjb3VsZCBwcm9iYWJseSBjcmVhdGUgYSBtaXhlciB0aGF0IHJ1bnMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb24gYnV0XG4vLyAgICAgICogdGhlIGlkZWEgYmVoaW5kIHRoZSBjcm9zc2ZhZGVyIGlzIHRoYXQgaXQgcnVucyBkeW5hbWljYWxseSBiZXR3ZWVuIHR3byBwb3RlbnRpYWxseVxuLy8gICAgICAqIGNoYW5naW5nIHRhcmdldHMgKGllIG9wYWNpdHkgb3IgYm9yZGVyUmFkaXVzIG1heSBiZSBhbmltYXRpbmcgaW5kZXBlbmRlbnRseSB2aWEgdmFyaWFudHMpXG4vLyAgICAgICovXG4vLyAgICAgbGVhZFN0YXRlLmJhY2tncm91bmRDb2xvciA9IGZvbGxvd1N0YXRlLmJhY2tncm91bmRDb2xvciA9IG1peENvbG9yKFxuLy8gICAgICAgICBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yIGFzIHN0cmluZyxcbi8vICAgICAgICAgbGF0ZXN0TGVhZFZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgYXMgc3RyaW5nXG4vLyAgICAgKShwKVxuLy8gfVxuY29uc3QgZWFzZUNyb3NzZmFkZUluID0gLypAX19QVVJFX18qLyBjb21wcmVzcygwLCAwLjUsIGNpcmNPdXQpO1xuY29uc3QgZWFzZUNyb3NzZmFkZU91dCA9IC8qQF9fUFVSRV9fKi8gY29tcHJlc3MoMC41LCAwLjk1LCBub29wKTtcbmZ1bmN0aW9uIGNvbXByZXNzKG1pbiwgbWF4LCBlYXNpbmcpIHtcbiAgICByZXR1cm4gKHApID0+IHtcbiAgICAgICAgLy8gQ291bGQgcmVwbGFjZSBpZnMgd2l0aCBjbGFtcFxuICAgICAgICBpZiAocCA8IG1pbilcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBpZiAocCA+IG1heClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gZWFzaW5nKHByb2dyZXNzKG1pbiwgbWF4LCBwKSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgbWl4VmFsdWVzIH07XG4iLCIvKipcbiAqIFJlc2V0IGFuIGF4aXMgdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUF4aXNJbnRvKGF4aXMsIG9yaWdpbkF4aXMpIHtcbiAgICBheGlzLm1pbiA9IG9yaWdpbkF4aXMubWluO1xuICAgIGF4aXMubWF4ID0gb3JpZ2luQXhpcy5tYXg7XG59XG4vKipcbiAqIFJlc2V0IGEgYm94IHRvIHRoZSBwcm92aWRlZCBvcmlnaW4gYm94LlxuICpcbiAqIFRoaXMgaXMgYSBtdXRhdGl2ZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvcHlCb3hJbnRvKGJveCwgb3JpZ2luQm94KSB7XG4gICAgY29weUF4aXNJbnRvKGJveC54LCBvcmlnaW5Cb3gueCk7XG4gICAgY29weUF4aXNJbnRvKGJveC55LCBvcmlnaW5Cb3gueSk7XG59XG4vKipcbiAqIFJlc2V0IGEgZGVsdGEgdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUF4aXNEZWx0YUludG8oZGVsdGEsIG9yaWdpbkRlbHRhKSB7XG4gICAgZGVsdGEudHJhbnNsYXRlID0gb3JpZ2luRGVsdGEudHJhbnNsYXRlO1xuICAgIGRlbHRhLnNjYWxlID0gb3JpZ2luRGVsdGEuc2NhbGU7XG4gICAgZGVsdGEub3JpZ2luUG9pbnQgPSBvcmlnaW5EZWx0YS5vcmlnaW5Qb2ludDtcbiAgICBkZWx0YS5vcmlnaW4gPSBvcmlnaW5EZWx0YS5vcmlnaW47XG59XG5cbmV4cG9ydCB7IGNvcHlBeGlzRGVsdGFJbnRvLCBjb3B5QXhpc0ludG8sIGNvcHlCb3hJbnRvIH07XG4iLCJpbXBvcnQgeyBtaXhOdW1iZXIgfSBmcm9tICcuLi8uLi91dGlscy9taXgvbnVtYmVyLm1qcyc7XG5pbXBvcnQgeyBwZXJjZW50IH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuaW1wb3J0IHsgc2NhbGVQb2ludCB9IGZyb20gJy4vZGVsdGEtYXBwbHkubWpzJztcblxuLyoqXG4gKiBSZW1vdmUgYSBkZWx0YSBmcm9tIGEgcG9pbnQuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5UG9pbnREZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBvaW50RGVsdGEocG9pbnQsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIHBvaW50IC09IHRyYW5zbGF0ZTtcbiAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBzY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIGlmIChib3hTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgMSAvIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNEZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUgPSAwLCBzY2FsZSA9IDEsIG9yaWdpbiA9IDAuNSwgYm94U2NhbGUsIG9yaWdpbkF4aXMgPSBheGlzLCBzb3VyY2VBeGlzID0gYXhpcykge1xuICAgIGlmIChwZXJjZW50LnRlc3QodHJhbnNsYXRlKSkge1xuICAgICAgICB0cmFuc2xhdGUgPSBwYXJzZUZsb2F0KHRyYW5zbGF0ZSk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUHJvZ3Jlc3MgPSBtaXhOdW1iZXIoc291cmNlQXhpcy5taW4sIHNvdXJjZUF4aXMubWF4LCB0cmFuc2xhdGUgLyAxMDApO1xuICAgICAgICB0cmFuc2xhdGUgPSByZWxhdGl2ZVByb2dyZXNzIC0gc291cmNlQXhpcy5taW47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlICE9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG9yaWdpblBvaW50ID0gbWl4TnVtYmVyKG9yaWdpbkF4aXMubWluLCBvcmlnaW5BeGlzLm1heCwgb3JpZ2luKTtcbiAgICBpZiAoYXhpcyA9PT0gb3JpZ2luQXhpcylcbiAgICAgICAgb3JpZ2luUG9pbnQgLT0gdHJhbnNsYXRlO1xuICAgIGF4aXMubWluID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zZm9ybXMgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNUcmFuc2Zvcm1zIGluIHJldmVyc2VcbiAqIGFuZCBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gbW90aW9uIHZhbHVlcyBhbmQgcmVtb3ZlQXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGF4aXMsIHRyYW5zZm9ybXMsIFtrZXksIHNjYWxlS2V5LCBvcmlnaW5LZXldLCBvcmlnaW4sIHNvdXJjZUF4aXMpIHtcbiAgICByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgdHJhbnNmb3Jtc1tvcmlnaW5LZXldLCB0cmFuc2Zvcm1zLnNjYWxlLCBvcmlnaW4sIHNvdXJjZUF4aXMpO1xufVxuLyoqXG4gKiBUaGUgbmFtZXMgb2YgdGhlIG1vdGlvbiB2YWx1ZXMgd2Ugd2FudCB0byBhcHBseSBhcyB0cmFuc2xhdGlvbiwgc2NhbGUgYW5kIG9yaWdpbi5cbiAqL1xuY29uc3QgeEtleXMgPSBbXCJ4XCIsIFwic2NhbGVYXCIsIFwib3JpZ2luWFwiXTtcbmNvbnN0IHlLZXlzID0gW1wieVwiLCBcInNjYWxlWVwiLCBcIm9yaWdpbllcIl07XG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zZm9ybXMgZnJvbSBhbiBib3guIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5QXhpc0JveCBpbiByZXZlcnNlXG4gKiBhbmQgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIG1vdGlvbiB2YWx1ZXMgYW5kIHJlbW92ZUF4aXNEZWx0YVxuICovXG5mdW5jdGlvbiByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveCwgdHJhbnNmb3Jtcywgb3JpZ2luQm94LCBzb3VyY2VCb3gpIHtcbiAgICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueCwgdHJhbnNmb3JtcywgeEtleXMsIG9yaWdpbkJveCA/IG9yaWdpbkJveC54IDogdW5kZWZpbmVkLCBzb3VyY2VCb3ggPyBzb3VyY2VCb3gueCA6IHVuZGVmaW5lZCk7XG4gICAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LnksIHRyYW5zZm9ybXMsIHlLZXlzLCBvcmlnaW5Cb3ggPyBvcmlnaW5Cb3gueSA6IHVuZGVmaW5lZCwgc291cmNlQm94ID8gc291cmNlQm94LnkgOiB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgeyByZW1vdmVBeGlzRGVsdGEsIHJlbW92ZUF4aXNUcmFuc2Zvcm1zLCByZW1vdmVCb3hUcmFuc2Zvcm1zLCByZW1vdmVQb2ludERlbHRhIH07XG4iLCJpbXBvcnQgeyBjYWxjTGVuZ3RoIH0gZnJvbSAnLi9kZWx0YS1jYWxjLm1qcyc7XG5cbmZ1bmN0aW9uIGlzQXhpc0RlbHRhWmVybyhkZWx0YSkge1xuICAgIHJldHVybiBkZWx0YS50cmFuc2xhdGUgPT09IDAgJiYgZGVsdGEuc2NhbGUgPT09IDE7XG59XG5mdW5jdGlvbiBpc0RlbHRhWmVybyhkZWx0YSkge1xuICAgIHJldHVybiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueCkgJiYgaXNBeGlzRGVsdGFaZXJvKGRlbHRhLnkpO1xufVxuZnVuY3Rpb24gYXhpc0VxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGEubWluID09PSBiLm1pbiAmJiBhLm1heCA9PT0gYi5tYXg7XG59XG5mdW5jdGlvbiBib3hFcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBheGlzRXF1YWxzKGEueCwgYi54KSAmJiBheGlzRXF1YWxzKGEueSwgYi55KTtcbn1cbmZ1bmN0aW9uIGF4aXNFcXVhbHNSb3VuZGVkKGEsIGIpIHtcbiAgICByZXR1cm4gKE1hdGgucm91bmQoYS5taW4pID09PSBNYXRoLnJvdW5kKGIubWluKSAmJlxuICAgICAgICBNYXRoLnJvdW5kKGEubWF4KSA9PT0gTWF0aC5yb3VuZChiLm1heCkpO1xufVxuZnVuY3Rpb24gYm94RXF1YWxzUm91bmRlZChhLCBiKSB7XG4gICAgcmV0dXJuIGF4aXNFcXVhbHNSb3VuZGVkKGEueCwgYi54KSAmJiBheGlzRXF1YWxzUm91bmRlZChhLnksIGIueSk7XG59XG5mdW5jdGlvbiBhc3BlY3RSYXRpbyhib3gpIHtcbiAgICByZXR1cm4gY2FsY0xlbmd0aChib3gueCkgLyBjYWxjTGVuZ3RoKGJveC55KTtcbn1cbmZ1bmN0aW9uIGF4aXNEZWx0YUVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLnRyYW5zbGF0ZSA9PT0gYi50cmFuc2xhdGUgJiZcbiAgICAgICAgYS5zY2FsZSA9PT0gYi5zY2FsZSAmJlxuICAgICAgICBhLm9yaWdpblBvaW50ID09PSBiLm9yaWdpblBvaW50KTtcbn1cblxuZXhwb3J0IHsgYXNwZWN0UmF0aW8sIGF4aXNEZWx0YUVxdWFscywgYXhpc0VxdWFscywgYXhpc0VxdWFsc1JvdW5kZWQsIGJveEVxdWFscywgYm94RXF1YWxzUm91bmRlZCwgaXNEZWx0YVplcm8gfTtcbiIsImltcG9ydCB7IGFkZFVuaXF1ZUl0ZW0sIHJlbW92ZUl0ZW0gfSBmcm9tICcuLi8uLi91dGlscy9hcnJheS5tanMnO1xuXG5jbGFzcyBOb2RlU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkKG5vZGUpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuICAgIHJlbW92ZShub2RlKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMucHJldkxlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkxlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVhZCkge1xuICAgICAgICAgICAgY29uc3QgcHJldkxlYWQgPSB0aGlzLm1lbWJlcnNbdGhpcy5tZW1iZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZWxlZ2F0ZShub2RlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4T2ZOb2RlID0gdGhpcy5tZW1iZXJzLmZpbmRJbmRleCgobWVtYmVyKSA9PiBub2RlID09PSBtZW1iZXIpO1xuICAgICAgICBpZiAoaW5kZXhPZk5vZGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBuZXh0IHByb2plY3Rpb24gbm9kZSB0aGF0IGlzIHByZXNlbnRcbiAgICAgICAgICovXG4gICAgICAgIGxldCBwcmV2TGVhZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4T2ZOb2RlOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5tZW1iZXJzW2ldO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5pc1ByZXNlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvbW90ZShub2RlLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgY29uc3QgcHJldkxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIGlmIChub2RlID09PSBwcmV2TGVhZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wcmV2TGVhZCA9IHByZXZMZWFkO1xuICAgICAgICB0aGlzLmxlYWQgPSBub2RlO1xuICAgICAgICBub2RlLnNob3coKTtcbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICBwcmV2TGVhZC5pbnN0YW5jZSAmJiBwcmV2TGVhZC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tID0gcHJldkxlYWQ7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNuYXBzaG90ID0gcHJldkxlYWQuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdC5sYXRlc3RWYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgcHJldkxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUucm9vdCAmJiBub2RlLnJvb3QuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNyb3NzZmFkZSB9ID0gbm9kZS5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNyb3NzZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGVhZC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86XG4gICAgICAgICAgICAgKiAgIC0gVGVzdCBib3JkZXIgcmFkaXVzIHdoZW4gcHJldmlvdXMgbm9kZSB3YXMgZGVsZXRlZFxuICAgICAgICAgICAgICogICAtIGJveFNoYWRvdyBtaXhpbmdcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gc2Nyb2xsZWQgY29udGFpbmVyIGFuZCBlbGVtZW50IEIgKHNjcm9sbCBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiB0cmFuc2Zvcm1lZCBjb250YWluZXIgYW5kIGVsZW1lbnQgQiAodHJhbnNmb3JtIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHNjcm9sbGVkIHBhZ2UgYW5kIGVsZW1lbnQgQiAoc2Nyb2xsIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAtLS1cbiAgICAgICAgICAgICAqICAgLSBDcm9zc2ZhZGUgb3BhY2l0eSBvZiByb290IG5vZGVzXG4gICAgICAgICAgICAgKiAgIC0gbGF5b3V0SWQgY2hhbmdlcyBhZnRlciBhbmltYXRpb25cbiAgICAgICAgICAgICAqICAgLSBsYXlvdXRJZCBjaGFuZ2VzIG1pZCBhbmltYXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXRBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcmVzdW1pbmdGcm9tIH0gPSBub2RlO1xuICAgICAgICAgICAgb3B0aW9ucy5vbkV4aXRDb21wbGV0ZSAmJiBvcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICBpZiAocmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgICAgICAgcmVzdW1pbmdGcm9tLm9wdGlvbnMub25FeGl0Q29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1pbmdGcm9tLm9wdGlvbnMub25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlUmVuZGVyKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5pbnN0YW5jZSAmJiBub2RlLnNjaGVkdWxlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFueSBsZWFkcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIHRoaXMgcmVuZGVyIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nXG4gICAgICogdXNlZCBpbiBmdXR1cmUgYW5pbWF0aW9ucyBhbmQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgKi9cbiAgICByZW1vdmVMZWFkU25hcHNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlYWQgJiYgdGhpcy5sZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxlYWQuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IE5vZGVTdGFjayB9O1xuIiwiZnVuY3Rpb24gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKGRlbHRhLCB0cmVlU2NhbGUsIGxhdGVzdFRyYW5zZm9ybSkge1xuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2xhdGlvbnMgd2UgdXNlIHRvIGNhbGN1bGF0ZSBhcmUgYWx3YXlzIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCBjb29yZGluYXRlIHNwYWNlLlxuICAgICAqIEJ1dCB3aGVuIHdlIGFwcGx5IHNjYWxlcywgd2UgYWxzbyBzY2FsZSB0aGUgY29vcmRpbmF0ZSBzcGFjZSBvZiBhbiBlbGVtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICogRm9yIGluc3RhbmNlIGlmIHdlIGhhdmUgYSB0cmVlU2NhbGUgKHRoZSBjdWxtaW5hdGlvbiBvZiBhbGwgcGFyZW50IHNjYWxlcykgb2YgMC41IGFuZCB3ZSBuZWVkXG4gICAgICogdG8gbW92ZSBhbiBlbGVtZW50IDEwMCBwaXhlbHMsIHdlIGFjdHVhbGx5IG5lZWQgdG8gbW92ZSBpdCAyMDAgaW4gd2l0aGluIHRoYXQgc2NhbGVkIHNwYWNlLlxuICAgICAqL1xuICAgIGNvbnN0IHhUcmFuc2xhdGUgPSBkZWx0YS54LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICAgIGNvbnN0IHlUcmFuc2xhdGUgPSBkZWx0YS55LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS55O1xuICAgIGNvbnN0IHpUcmFuc2xhdGUgPSAobGF0ZXN0VHJhbnNmb3JtID09PSBudWxsIHx8IGxhdGVzdFRyYW5zZm9ybSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF0ZXN0VHJhbnNmb3JtLnopIHx8IDA7XG4gICAgaWYgKHhUcmFuc2xhdGUgfHwgeVRyYW5zbGF0ZSB8fCB6VHJhbnNsYXRlKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IGB0cmFuc2xhdGUzZCgke3hUcmFuc2xhdGV9cHgsICR7eVRyYW5zbGF0ZX1weCwgJHt6VHJhbnNsYXRlfXB4KSBgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSBzY2FsZSBjb3JyZWN0aW9uIGZvciB0aGUgdHJlZSB0cmFuc2Zvcm0uXG4gICAgICogVGhpcyB3aWxsIGFwcGx5IHNjYWxlIHRvIHRoZSBzY3JlZW4tb3JpZW50YXRlZCBheGVzLlxuICAgICAqL1xuICAgIGlmICh0cmVlU2NhbGUueCAhPT0gMSB8fCB0cmVlU2NhbGUueSAhPT0gMSkge1xuICAgICAgICB0cmFuc2Zvcm0gKz0gYHNjYWxlKCR7MSAvIHRyZWVTY2FsZS54fSwgJHsxIC8gdHJlZVNjYWxlLnl9KSBgO1xuICAgIH1cbiAgICBpZiAobGF0ZXN0VHJhbnNmb3JtKSB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtUGVyc3BlY3RpdmUsIHJvdGF0ZSwgcm90YXRlWCwgcm90YXRlWSwgc2tld1gsIHNrZXdZIH0gPSBsYXRlc3RUcmFuc2Zvcm07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1QZXJzcGVjdGl2ZSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSA9IGBwZXJzcGVjdGl2ZSgke3RyYW5zZm9ybVBlcnNwZWN0aXZlfXB4KSAke3RyYW5zZm9ybX1gO1xuICAgICAgICBpZiAocm90YXRlKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGByb3RhdGUoJHtyb3RhdGV9ZGVnKSBgO1xuICAgICAgICBpZiAocm90YXRlWClcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlWCgke3JvdGF0ZVh9ZGVnKSBgO1xuICAgICAgICBpZiAocm90YXRlWSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlWSgke3JvdGF0ZVl9ZGVnKSBgO1xuICAgICAgICBpZiAoc2tld1gpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHNrZXdYKCR7c2tld1h9ZGVnKSBgO1xuICAgICAgICBpZiAoc2tld1kpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHNrZXdZKCR7c2tld1l9ZGVnKSBgO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBseSBzY2FsZSB0byBtYXRjaCB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCB0byB0aGUgc2l6ZSB3ZSB3YW50IGl0LlxuICAgICAqIFRoaXMgd2lsbCBhcHBseSBzY2FsZSB0byB0aGUgZWxlbWVudC1vcmllbnRhdGVkIGF4ZXMuXG4gICAgICovXG4gICAgY29uc3QgZWxlbWVudFNjYWxlWCA9IGRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICBjb25zdCBlbGVtZW50U2NhbGVZID0gZGVsdGEueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICAgIGlmIChlbGVtZW50U2NhbGVYICE9PSAxIHx8IGVsZW1lbnRTY2FsZVkgIT09IDEpIHtcbiAgICAgICAgdHJhbnNmb3JtICs9IGBzY2FsZSgke2VsZW1lbnRTY2FsZVh9LCAke2VsZW1lbnRTY2FsZVl9KWA7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm0gfHwgXCJub25lXCI7XG59XG5cbmV4cG9ydCB7IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSB9O1xuIiwiaW1wb3J0IHsgZ2V0VmFsdWVUcmFuc2l0aW9uIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBub29wIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGFuaW1hdGVTaW5nbGVWYWx1ZSB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9hbmltYXRlL3NpbmdsZS12YWx1ZS5tanMnO1xuaW1wb3J0IHsgZ2V0T3B0aW1pc2VkQXBwZWFySWQgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vb3B0aW1pemVkLWFwcGVhci9nZXQtYXBwZWFyLWlkLm1qcyc7XG5pbXBvcnQgeyBjYW5jZWxGcmFtZSwgZnJhbWVEYXRhLCBmcmFtZVN0ZXBzLCBmcmFtZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuaW1wb3J0IHsgbWljcm90YXNrIH0gZnJvbSAnLi4vLi4vZnJhbWVsb29wL21pY3JvdGFzay5tanMnO1xuaW1wb3J0IHsgdGltZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9zeW5jLXRpbWUubWpzJztcbmltcG9ydCB7IGlzU1ZHRWxlbWVudCB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdXRpbHMvaXMtc3ZnLWVsZW1lbnQubWpzJztcbmltcG9ydCB7IEZsYXRUcmVlIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL2ZsYXQtdHJlZS5tanMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi91dGlscy9jbGFtcC5tanMnO1xuaW1wb3J0IHsgZGVsYXkgfSBmcm9tICcuLi8uLi91dGlscy9kZWxheS5tanMnO1xuaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWl4L251bWJlci5tanMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9IGZyb20gJy4uLy4uL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgbWl4VmFsdWVzIH0gZnJvbSAnLi4vYW5pbWF0aW9uL21peC12YWx1ZXMubWpzJztcbmltcG9ydCB7IGNvcHlCb3hJbnRvLCBjb3B5QXhpc0RlbHRhSW50byB9IGZyb20gJy4uL2dlb21ldHJ5L2NvcHkubWpzJztcbmltcG9ydCB7IHRyYW5zbGF0ZUF4aXMsIHRyYW5zZm9ybUJveCwgYXBwbHlCb3hEZWx0YSwgYXBwbHlUcmVlRGVsdGFzIH0gZnJvbSAnLi4vZ2VvbWV0cnkvZGVsdGEtYXBwbHkubWpzJztcbmltcG9ydCB7IGNhbGNMZW5ndGgsIGNhbGNSZWxhdGl2ZVBvc2l0aW9uLCBjYWxjUmVsYXRpdmVCb3gsIGNhbGNCb3hEZWx0YSwgaXNOZWFyIH0gZnJvbSAnLi4vZ2VvbWV0cnkvZGVsdGEtY2FsYy5tanMnO1xuaW1wb3J0IHsgcmVtb3ZlQm94VHJhbnNmb3JtcyB9IGZyb20gJy4uL2dlb21ldHJ5L2RlbHRhLXJlbW92ZS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQm94LCBjcmVhdGVEZWx0YSB9IGZyb20gJy4uL2dlb21ldHJ5L21vZGVscy5tanMnO1xuaW1wb3J0IHsgYm94RXF1YWxzUm91bmRlZCwgaXNEZWx0YVplcm8sIGF4aXNEZWx0YUVxdWFscywgYXNwZWN0UmF0aW8sIGJveEVxdWFscyB9IGZyb20gJy4uL2dlb21ldHJ5L3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBOb2RlU3RhY2sgfSBmcm9tICcuLi9zaGFyZWQvc3RhY2subWpzJztcbmltcG9ydCB7IHNjYWxlQ29ycmVjdG9ycyB9IGZyb20gJy4uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qcyc7XG5pbXBvcnQgeyBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0gfSBmcm9tICcuLi9zdHlsZXMvdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBlYWNoQXhpcyB9IGZyb20gJy4uL3V0aWxzL2VhY2gtYXhpcy5tanMnO1xuaW1wb3J0IHsgaGFzVHJhbnNmb3JtLCBoYXNTY2FsZSwgaGFzMkRUcmFuc2xhdGUgfSBmcm9tICcuLi91dGlscy9oYXMtdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgfSBmcm9tICcuL3N0YXRlLm1qcyc7XG5cbmNvbnN0IG1ldHJpY3MgPSB7XG4gICAgdHlwZTogXCJwcm9qZWN0aW9uRnJhbWVcIixcbiAgICB0b3RhbE5vZGVzOiAwLFxuICAgIHJlc29sdmVkVGFyZ2V0RGVsdGFzOiAwLFxuICAgIHJlY2FsY3VsYXRlZFByb2plY3Rpb246IDAsXG59O1xuY29uc3QgaXNEZWJ1ZyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lk1vdGlvbkRlYnVnICE9PSB1bmRlZmluZWQ7XG5jb25zdCB0cmFuc2Zvcm1BeGVzID0gW1wiXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdO1xuY29uc3QgaGlkZGVuVmlzaWJpbGl0eSA9IHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9O1xuLyoqXG4gKiBXZSB1c2UgMTAwMCBhcyB0aGUgYW5pbWF0aW9uIHRhcmdldCBhcyAwLTEwMDAgbWFwcyBiZXR0ZXIgdG8gcGl4ZWxzIHRoYW4gMC0xXG4gKiB3aGljaCBoYXMgYSBub3RpY2VhYmxlIGRpZmZlcmVuY2UgaW4gc3ByaW5nIGFuaW1hdGlvbnNcbiAqL1xuY29uc3QgYW5pbWF0aW9uVGFyZ2V0ID0gMTAwMDtcbmxldCBpZCA9IDA7XG5mdW5jdGlvbiByZXNldERpc3RvcnRpbmdUcmFuc2Zvcm0oa2V5LCB2aXN1YWxFbGVtZW50LCB2YWx1ZXMsIHNoYXJlZEFuaW1hdGlvblZhbHVlcykge1xuICAgIGNvbnN0IHsgbGF0ZXN0VmFsdWVzIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgIC8vIFJlY29yZCB0aGUgZGlzdG9ydGluZyB0cmFuc2Zvcm0gYW5kIHRoZW4gdGVtcG9yYXJpbHkgc2V0IGl0IHRvIDBcbiAgICBpZiAobGF0ZXN0VmFsdWVzW2tleV0pIHtcbiAgICAgICAgdmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIDApO1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICBzaGFyZWRBbmltYXRpb25WYWx1ZXNba2V5XSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjYW5jZWxUcmVlT3B0aW1pc2VkVHJhbnNmb3JtQW5pbWF0aW9ucyhwcm9qZWN0aW9uTm9kZSkge1xuICAgIHByb2plY3Rpb25Ob2RlLmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIgPSB0cnVlO1xuICAgIGlmIChwcm9qZWN0aW9uTm9kZS5yb290ID09PSBwcm9qZWN0aW9uTm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gcHJvamVjdGlvbk5vZGUub3B0aW9ucztcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBhcHBlYXJJZCA9IGdldE9wdGltaXNlZEFwcGVhcklkKHZpc3VhbEVsZW1lbnQpO1xuICAgIGlmICh3aW5kb3cuTW90aW9uSGFzT3B0aW1pc2VkQW5pbWF0aW9uKGFwcGVhcklkLCBcInRyYW5zZm9ybVwiKSkge1xuICAgICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHByb2plY3Rpb25Ob2RlLm9wdGlvbnM7XG4gICAgICAgIHdpbmRvdy5Nb3Rpb25DYW5jZWxPcHRpbWlzZWRBbmltYXRpb24oYXBwZWFySWQsIFwidHJhbnNmb3JtXCIsIGZyYW1lLCAhKGxheW91dCB8fCBsYXlvdXRJZCkpO1xuICAgIH1cbiAgICBjb25zdCB7IHBhcmVudCB9ID0gcHJvamVjdGlvbk5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiAhcGFyZW50Lmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIpIHtcbiAgICAgICAgY2FuY2VsVHJlZU9wdGltaXNlZFRyYW5zZm9ybUFuaW1hdGlvbnMocGFyZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7IGF0dGFjaFJlc2l6ZUxpc3RlbmVyLCBkZWZhdWx0UGFyZW50LCBtZWFzdXJlU2Nyb2xsLCBjaGVja0lzU2Nyb2xsUm9vdCwgcmVzZXRUcmFuc2Zvcm0sIH0pIHtcbiAgICByZXR1cm4gY2xhc3MgUHJvamVjdGlvbk5vZGUge1xuICAgICAgICBjb25zdHJ1Y3RvcihsYXRlc3RWYWx1ZXMgPSB7fSwgcGFyZW50ID0gZGVmYXVsdFBhcmVudCA9PT0gbnVsbCB8fCBkZWZhdWx0UGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZWZhdWx0UGFyZW50KCkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSB1bmlxdWUgSUQgZ2VuZXJhdGVkIGZvciBldmVyeSBwcm9qZWN0aW9uIG5vZGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaWQgPSBpZCsrO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBpZCB0aGF0IHJlcHJlc2VudHMgYSB1bmlxdWUgc2Vzc2lvbiBpbnN0aWdhdGVkIGJ5IHN0YXJ0VXBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbklkID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBTZXQgY29udGFpbmluZyBhbGwgdGhpcyBjb21wb25lbnQncyBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIHRvIGl0ZXJhdGVcbiAgICAgICAgICAgICAqIHRocm91Z2ggdGhlIGNoaWxkcmVuLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IFRoaXMgY291bGQgYmUgZmFzdGVyIHRvIGl0ZXJhdGUgYXMgYSBmbGF0IGFycmF5IHN0b3JlZCBvbiB0aGUgcm9vdCBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25zIGZvciB0aGUgbm9kZS4gV2UgdXNlIHRoaXMgdG8gY29uZmlndXJlIHdoYXQga2luZCBvZiBsYXlvdXQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICogd2Ugc2hvdWxkIHBlcmZvcm0gKGlmIGFueSkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSB1c2UgdGhpcyB0byBkZXRlY3Qgd2hlbiBpdHMgc2FmZSB0byBzaHV0IGRvd24gcGFydCBvZiBhIHByb2plY3Rpb24gdHJlZS5cbiAgICAgICAgICAgICAqIFdlIGhhdmUgdG8ga2VlcCBwcm9qZWN0aW5nIGNoaWxkcmVuIGZvciBzY2FsZSBjb3JyZWN0aW9uIGFuZCByZWxhdGl2ZSBwcm9qZWN0aW9uXG4gICAgICAgICAgICAgKiB1bnRpbCBhbGwgdGhlaXIgcGFyZW50cyBzdG9wIHBlcmZvcm1pbmcgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgaWYgd2UgdGhpbmsgdGhpcyBsYXlvdXQgaGFzIGJlZW4gY2hhbmdlZC4gV2UgY2FuJ3QgYWx3YXlzIGtub3cgdGhpcyxcbiAgICAgICAgICAgICAqIGN1cnJlbnRseSB3ZSBzZXQgaXQgdG8gdHJ1ZSBldmVyeSB0aW1lIGEgY29tcG9uZW50IHJlbmRlcnMsIG9yIGlmIGl0IGhhcyBhIGxheW91dERlcGVuZGVuY3lcbiAgICAgICAgICAgICAqIGlmIHRoYXQgaGFzIGNoYW5nZWQgYmV0d2VlbiByZW5kZXJzLiBBZGRpdGlvbmFsbHksIGNvbXBvbmVudHMgY2FuIGJlIGdyb3VwZWQgYnkgTGF5b3V0R3JvdXBcbiAgICAgICAgICAgICAqIGFuZCBpZiBvbmUgbm9kZSBpcyBkaXJ0aWVkLCB0aGV5IGFsbCBhcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgaWYgd2UgdGhpbmsgdGhlIHByb2plY3Rpb24gY2FsY3VsYXRpb25zIGZvciB0aGlzIG5vZGUgbmVlZHNcbiAgICAgICAgICAgICAqIHJlY2FsY3VsYXRpbmcgYXMgYSByZXN1bHQgb2YgYW4gdXBkYXRlZCB0cmFuc2Zvcm0gb3IgbGF5b3V0IGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1Byb2plY3Rpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgaWYgdGhlIGxheW91dCAqb3IqIHRyYW5zZm9ybSBoYXMgY2hhbmdlZC4gVGhpcyB0aGVuIGdldHMgcHJvcGFnYXRlZFxuICAgICAgICAgICAgICogdGhyb3VnaG91dCB0aGUgcHJvamVjdGlvbiB0cmVlLCBmb3JjaW5nIGFueSBlbGVtZW50IGJlbG93IHRvIHJlY2FsY3VsYXRlIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdHJhbnNmb3JtIGRpcnR5LiBUaGlzIGdldHMgcHJvcGFnYXRlZCB0aHJvdWdob3V0IHRoZSB3aG9sZSB0cmVlIGJ1dCBpcyBvbmx5XG4gICAgICAgICAgICAgKiByZXNwZWN0ZWQgYnkgc2hhcmVkIG5vZGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmxvY2sgbGF5b3V0IHVwZGF0ZXMgZm9yIGluc3RhbnQgbGF5b3V0IHRyYW5zaXRpb25zIHRocm91Z2hvdXQgdGhlIHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBiZXR3ZWVuIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgYHdpbGxVcGRhdGVgIGNhbGwgYW5kIHRoZSBlbmQgb2YgdGhlIGBkaWRVcGRhdGVgXG4gICAgICAgICAgICAgKiBjYWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBTVkcgZWxlbWVudCB3ZSBjdXJyZW50bHkgZGlzYWJsZSBwcm9qZWN0aW9uIHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1NWRyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgKGR1cmluZyBwcm9tb3Rpb24pIGlmIGEgbm9kZSBkb2luZyBhbiBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9uIG5lZWRzIHRvIHJlc2V0XG4gICAgICAgICAgICAgKiBpdHMgcHJvamVjdGlvbiBzdHlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFncyB3aGV0aGVyIHRoaXMgbm9kZSBzaG91bGQgaGF2ZSBpdHMgdHJhbnNmb3JtIHJlc2V0IHByaW9yIHRvIG1lYXN1cmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9yZSB3aGV0aGVyIHRoaXMgbm9kZSBoYXMgYmVlbiBjaGVja2VkIGZvciBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnMuIEFzXG4gICAgICAgICAgICAgKiBlZmZlY3RzIGZpcmUgYm90dG9tLXVwLCBhbmQgd2Ugd2FudCB0byBsb29rIHVwIHRoZSB0cmVlIGZvciBhcHBlYXIgYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAqIHRoaXMgbWFrZXMgc3VyZSB3ZSBvbmx5IGNoZWNrIGVhY2ggcGF0aCBvbmNlLCBzdG9wcGluZyBhdCBub2RlcyB0aGF0XG4gICAgICAgICAgICAgKiBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY2FsY3VsYXRlZCBjb250ZXh0dWFsL2FjY3VtdWxhdGVkL3RyZWUgc2NhbGUuXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYmUgdXNlZCB0byBzY2FsZSBjYWxjdWxjYXRlZCBwcm9qZWN0aW9uIHRyYW5zZm9ybXMsIGFzIHRoZXNlIGFyZVxuICAgICAgICAgICAgICogY2FsY3VsYXRlZCBpbiBzY3JlZW4tc3BhY2UgYnV0IG5lZWQgdG8gYmUgc2NhbGVkIGZvciBlbGVtZW50cyB0byBsYXlvdXRseVxuICAgICAgICAgICAgICogbWFrZSBpdCB0byB0aGVpciBjYWxjdWxhdGVkIGRlc3RpbmF0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBMYXp5LWluaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNUcmVlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9ICgpID0+IHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tVcGRhdGVGYWlsZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYSBtdWx0aS1zdGVwIHByb2Nlc3MgYXMgc2hhcmVkIG5vZGVzIG1pZ2h0IGJlIG9mIGRpZmZlcmVudCBkZXB0aHMuIE5vZGVzXG4gICAgICAgICAgICAgKiBhcmUgc29ydGVkIGJ5IGRlcHRoIG9yZGVyLCBzbyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGVudGlyZSB0cmVlIGJlZm9yZSBtb3ZpbmcgdG9cbiAgICAgICAgICAgICAqIHRoZSBuZXh0IHN0ZXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXNldCBkZWJ1ZyBjb3VudHMuIE1hbnVhbGx5IHJlc2V0dGluZyByYXRoZXIgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAgICAgICAgICAgICAgICAqIG9iamVjdCBlYWNoIGZyYW1lLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldHJpY3MudG90YWxOb2RlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnJlc29sdmVkVGFyZ2V0RGVsdGFzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnJlY2FsY3VsYXRlZFByb2plY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gocHJvcGFnYXRlRGlydHlOb2Rlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc29sdmVUYXJnZXREZWx0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNhbGNQcm9qZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYW5EaXJ0eU5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuTW90aW9uRGVidWcucmVjb3JkKG1ldHJpY3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZyYW1lIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hhcmVkIGxheW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPIE9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IHx8IHBhcmVudCA6IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXJlbnQgPyBbLi4ucGFyZW50LnBhdGgsIHBhcmVudF0gOiBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhbaV0uc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gbmV3IEZsYXRUcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMuc2V0KG5hbWUsIG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSkuYWRkKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyhuYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIgJiYgc3Vic2NyaXB0aW9uTWFuYWdlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzTGlzdGVuZXJzKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaWZlY3ljbGVzXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudChpbnN0YW5jZSwgaXNMYXlvdXREaXJ0eSA9IHRoaXMucm9vdC5oYXNUcmVlQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPSBpc1NWR0VsZW1lbnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0LCB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiAhdmlzdWFsRWxlbWVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuYWRkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0RGlydHkgJiYgKGxheW91dCB8fCBsYXlvdXRJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dGFjaFJlc2l6ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbmNlbERlbGF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVVuYmxvY2tVcGRhdGUgPSAoKSA9PiAodGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hSZXNpemVMaXN0ZW5lcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRGVsYXkgJiYgY2FuY2VsRGVsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRGVsYXkgPSBkZWxheShyZXNpemVVbmJsb2NrVXBkYXRlLCAyNTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goZmluaXNoQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIHRoZSBoYW5kbGVyIGlmIGl0IHJlcXVpcmVzIGxheW91dCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgKGxheW91dElkIHx8IGxheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKHsgZGVsdGEsIGhhc0xheW91dENoYW5nZWQsIGhhc1JlbGF0aXZlTGF5b3V0Q2hhbmdlZCwgbGF5b3V0OiBuZXdMYXlvdXQsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgaGVyZSBpZiBhbiBhbmltYXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxheW91dFRyYW5zaXRpb24gPSB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbkxheW91dEFuaW1hdGlvblN0YXJ0LCBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlLCB9ID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHRhcmdldCBsYXlvdXQgb2YgdGhlIGVsZW1lbnQgbWlnaHQgc3RheSB0aGUgc2FtZSxcbiAgICAgICAgICAgICAgICAgICAgICogYnV0IGl0cyBwb3NpdGlvbiByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzVGFyZ2V0Q2hhbmdlZCA9ICF0aGlzLnRhcmdldExheW91dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWJveEVxdWFsc1JvdW5kZWQodGhpcy50YXJnZXRMYXlvdXQsIG5ld0xheW91dCk7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIE5vdGU6IERpc2FibGVkIHRvIGZpeCByZWxhdGl2ZSBhbmltYXRpb25zIGFsd2F5cyB0cmlnZ2VyaW5nIG5ld1xuICAgICAgICAgICAgICAgICAgICAgKiBsYXlvdXQgYW5pbWF0aW9ucy4gSWYgdGhpcyBjYXVzZXMgZnVydGhlciBpc3N1ZXMsIHdlIGNhbiB0cnlcbiAgICAgICAgICAgICAgICAgICAgICogYSBkaWZmZXJlbnQgYXBwcm9hY2ggdG8gZGV0ZWN0aW5nIHJlbGF0aXZlIHRhcmdldCBjaGFuZ2VzLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgLy8gfHwgaGFzUmVsYXRpdmVMYXlvdXRDaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBzZWVtZWQgdG8gaGF2ZSBjaGFuZ2VkLCBpdCBtaWdodCBiZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIHZpc3VhbGx5IGluIHRoZSBzYW1lIHBsYWNlIGluIHRoZSBkb2N1bWVudCBidXQgaXRzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGluZGVlZCBjaGFuZ2VkLiBTbyBoZXJlIHdlIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9ICFoYXNMYXlvdXRDaGFuZ2VkICYmIGhhc1JlbGF0aXZlTGF5b3V0Q2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRSb290IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZUZyb20gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChoYXNMYXlvdXRDaGFuZ2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhhc1RhcmdldENoYW5nZWQgfHwgIXRoaXMuY3VycmVudEFuaW1hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB0aGlzLnJlc3VtZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucmVzdW1pbmdGcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXRWYWx1ZVRyYW5zaXRpb24obGF5b3V0VHJhbnNpdGlvbiwgXCJsYXlvdXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25QbGF5OiBvbkxheW91dEFuaW1hdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuc2hvdWxkUmVkdWNlTW90aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLnR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBsYXlvdXQgaGFzbid0IGNoYW5nZWQgYW5kIHdlIGhhdmUgYW4gYW5pbWF0aW9uIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogZmluaXNoIGl0IGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhbmltYXRpbmcgZnJvbSBhIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdhcyBwcm9iYWJseSBuZXZlciBjb21taXRlZCB0byBzY3JlZW4gYW5kIGxvb2sgbGlrZSBhIGp1bXB5IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMYXlvdXRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMZWFkKCkgJiYgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sYXlvdXRJZCAmJiB0aGlzLndpbGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIHN0YWNrICYmIHN0YWNrLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5jZWxGcmFtZSh0aGlzLnVwZGF0ZVByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgb24gdGhlIHJvb3RcbiAgICAgICAgYmxvY2tVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdW5ibG9ja1VwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaXNVcGRhdGVCbG9ja2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkIHx8IHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNBbmltYXRpb25CbG9ja2VkIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkgfHxcbiAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1VwZGF0ZUJsb2NrZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmZvckVhY2gocmVzZXRTa2V3QW5kUm90YXRpb24pO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JZCsrO1xuICAgICAgICB9XG4gICAgICAgIGdldFRyYW5zZm9ybVRlbXBsYXRlKCkge1xuICAgICAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdmlzdWFsRWxlbWVudCAmJiB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgd2lsbFVwZGF0ZShzaG91bGROb3RpZnlMaXN0ZW5lcnMgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaGFzVHJlZUFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QuaXNVcGRhdGVCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25FeGl0Q29tcGxldGUgJiYgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBydW5uaW5nIG9wdGltaXNlZCBhcHBlYXIgYW5pbWF0aW9ucyB0aGVuIHRoZXNlIG11c3QgYmVcbiAgICAgICAgICAgICAqIGNhbmNlbGxlZCBiZWZvcmUgbWVhc3VyaW5nIHRoZSBET00uIFRoaXMgaXMgc28gd2UgY2FuIG1lYXN1cmVcbiAgICAgICAgICAgICAqIHRoZSB0cnVlIGxheW91dCBvZiB0aGUgZWxlbWVudCByYXRoZXIgdGhhbiB0aGUgV0FBUEkgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiB3aGljaCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnkgdGhlIHJlc2V0U2tld0FuZFJvdGF0ZSBzdGVwLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGU6IFRoaXMgaXMgYSBET00gd3JpdGUuIFdvcnN0IGNhc2Ugc2NlbmFyaW8gaXMgdGhpcyBpcyBzYW5kd2ljaGVkXG4gICAgICAgICAgICAgKiBiZXR3ZWVuIG90aGVyIHNuYXBzaG90IHJlYWRzIHdoaWNoIHdpbGwgY2F1c2UgdW5uZWNlc3Nhcnkgc3R5bGUgcmVjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICAgKiBUaGlzIGhhcyB0byBoYXBwZW4gaGVyZSB0aG91Z2gsIGFzIHdlIGRvbid0IHlldCBrbm93IHdoaWNoIG5vZGVzIHdpbGwgbmVlZFxuICAgICAgICAgICAgICogc25hcHNob3RzIGluIHN0YXJ0VXBkYXRlKCksIGJ1dCB3ZSBvbmx5IHdhbnQgdG8gY2FuY2VsIG9wdGltaXNlZCBhbmltYXRpb25zXG4gICAgICAgICAgICAgKiBpZiBhIGxheW91dCBhbmltYXRpb24gbWVhc3VyZW1lbnQgaXMgYWN0dWFsbHkgZ29pbmcgdG8gYmUgYWZmZWN0ZWQgYnkgdGhlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5Nb3Rpb25DYW5jZWxPcHRpbWlzZWRBbmltYXRpb24gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5oYXNDaGVja2VkT3B0aW1pc2VkQXBwZWFyKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsVHJlZU9wdGltaXNlZFRyYW5zZm9ybUFuaW1hdGlvbnModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhdGhpcy5yb290LmlzVXBkYXRpbmcgJiYgdGhpcy5yb290LnN0YXJ0VXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgbm9kZS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoXCJzbmFwc2hvdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS53aWxsVXBkYXRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCA9PT0gdW5kZWZpbmVkICYmICFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSB0aGlzLmdldFRyYW5zZm9ybVRlbXBsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgc2hvdWxkTm90aWZ5TGlzdGVuZXJzICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwid2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlV2FzQmxvY2tlZCA9IHRoaXMuaXNVcGRhdGVCbG9ja2VkKCk7XG4gICAgICAgICAgICAvLyBXaGVuIGRvaW5nIGFuIGluc3RhbnQgdHJhbnNpdGlvbiwgd2Ugc2tpcCB0aGUgbGF5b3V0IHVwZGF0ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBzaG91bGQgc3RpbGwgY2xlYW4gdXAgdGhlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBzbmFwc2hvdCBjb3VsZCBiZSB0YWtlbiBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAodXBkYXRlV2FzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5ibG9ja1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFySXNMYXlvdXREaXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc2V0VHJhbnNmb3JtU3R5bGUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWFkID09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGF5b3V0IG1lYXN1cmVtZW50cyBvZiB1cGRhdGVkIGNoaWxkcmVuXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2godXBkYXRlTGF5b3V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gTm90aWZ5IGxpc3RlbmVycyB0aGF0IHRoZSBsYXlvdXQgaXMgdXBkYXRlZFxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vdGlmeUxheW91dFVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hbnVhbGx5IGZsdXNoIGFueSBwZW5kaW5nIHVwZGF0ZXMuIElkZWFsbHlcbiAgICAgICAgICAgICAqIHdlIGNvdWxkIGxlYXZlIHRoaXMgdG8gdGhlIGZvbGxvd2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYnV0IHRoaXMgc2VlbXNcbiAgICAgICAgICAgICAqIHRvIGxlYXZlIGEgZmxhc2ggb2YgaW5jb3JyZWN0bHkgc3R5bGVkIGNvbnRlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHRpbWUubm93KCk7XG4gICAgICAgICAgICBmcmFtZURhdGEuZGVsdGEgPSBjbGFtcCgwLCAxMDAwIC8gNjAsIG5vdyAtIGZyYW1lRGF0YS50aW1lc3RhbXApO1xuICAgICAgICAgICAgZnJhbWVEYXRhLnRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICAgIGZyYW1lRGF0YS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZnJhbWVTdGVwcy51cGRhdGUucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgZnJhbWVTdGVwcy5wcmVSZW5kZXIucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgZnJhbWVTdGVwcy5yZW5kZXIucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgZnJhbWVEYXRhLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRpZFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51cGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWljcm90YXNrLnJlYWQodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJBbGxTbmFwc2hvdHMoKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJTbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLmZvckVhY2gocmVtb3ZlTGVhZFNuYXBzaG90cyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgdW5tb3VudGluZyBub2RlIGlzIGluIGEgbGF5b3V0R3JvdXAgYW5kIGRpZCB0cmlnZ2VyIGEgd2lsbFVwZGF0ZSxcbiAgICAgICAgICAgICAqIHdlIG1hbnVhbGx5IGNhbGwgZGlkVXBkYXRlIHRvIGdpdmUgYSBjaGFuY2UgdG8gdGhlIHNpYmxpbmdzIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UsIGNsZWFudXAgYWxsIHNuYXBzaG90cyB0byBwcmV2ZW50cyBmdXR1cmUgbm9kZXMgZnJvbSByZXVzaW5nIHRoZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LmNoZWNrVXBkYXRlRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBtZWFzdXJlbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVNuYXBzaG90KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc25hcHNob3QgfHwgIXRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc25hcHNob3QgJiZcbiAgICAgICAgICAgICAgICAhY2FsY0xlbmd0aCh0aGlzLnNuYXBzaG90Lm1lYXN1cmVkQm94LngpICYmXG4gICAgICAgICAgICAgICAgIWNhbGNMZW5ndGgodGhpcy5zbmFwc2hvdC5tZWFzdXJlZEJveC55KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlTGF5b3V0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFRPRE86IEluY29ycG9yYXRlIGludG8gYSBmb3J3YXJkZWQgc2Nyb2xsIG9mZnNldFxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0ICYmIHRoaXMuaXNMZWFkKCkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIG5vZGUgaXMgbW91bnRlZCwgaXQgc2ltcGx5IHJlc3VtZXMgZnJvbSB0aGUgcHJldkxlYWQnc1xuICAgICAgICAgICAgICogc25hcHNob3QgaW5zdGVhZCBvZiB0YWtpbmcgYSBuZXcgb25lLCBidXQgdGhlIGFuY2VzdG9ycyBzY3JvbGxcbiAgICAgICAgICAgICAqIG1pZ2h0IGhhdmUgdXBkYXRlZCB3aGlsZSB0aGUgcHJldkxlYWQgaXMgdW5tb3VudGVkLiBXZSBuZWVkIHRvXG4gICAgICAgICAgICAgKiB1cGRhdGUgdGhlIHNjcm9sbCBhZ2FpbiB0byBtYWtlIHN1cmUgdGhlIGxheW91dCB3ZSBtZWFzdXJlIGlzXG4gICAgICAgICAgICAgKiB1cCB0byBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWVGcm9tICYmICF0aGlzLnJlc3VtZUZyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnVwZGF0ZVNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZMYXlvdXQgPSB0aGlzLmxheW91dDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0gdGhpcy5tZWFzdXJlKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q29ycmVjdGVkID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJtZWFzdXJlXCIsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkxheW91dE1lYXN1cmVcIiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCBwcmV2TGF5b3V0ID8gcHJldkxheW91dC5sYXlvdXRCb3ggOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVNjcm9sbChwaGFzZSA9IFwibWVhc3VyZVwiKSB7XG4gICAgICAgICAgICBsZXQgbmVlZHNNZWFzdXJlbWVudCA9IEJvb2xlYW4odGhpcy5vcHRpb25zLmxheW91dFNjcm9sbCAmJiB0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNjcm9sbCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsLmFuaW1hdGlvbklkID09PSB0aGlzLnJvb3QuYW5pbWF0aW9uSWQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbC5waGFzZSA9PT0gcGhhc2UpIHtcbiAgICAgICAgICAgICAgICBuZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmVlZHNNZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUm9vdCA9IGNoZWNrSXNTY3JvbGxSb290KHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0ge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JZDogdGhpcy5yb290LmFuaW1hdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICBwaGFzZSxcbiAgICAgICAgICAgICAgICAgICAgaXNSb290LFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG1lYXN1cmVTY3JvbGwodGhpcy5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIHdhc1Jvb3Q6IHRoaXMuc2Nyb2xsID8gdGhpcy5zY3JvbGwuaXNSb290IDogaXNSb290LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICAgICAgICBpZiAoIXJlc2V0VHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGlzUmVzZXRSZXF1ZXN0ZWQgPSB0aGlzLmlzTGF5b3V0RGlydHkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmFsd2F5c01lYXN1cmVMYXlvdXQ7XG4gICAgICAgICAgICBjb25zdCBoYXNQcm9qZWN0aW9uID0gdGhpcy5wcm9qZWN0aW9uRGVsdGEgJiYgIWlzRGVsdGFaZXJvKHRoaXMucHJvamVjdGlvbkRlbHRhKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCA9IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgIT09IHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNSZXNldFJlcXVlc3RlZCAmJlxuICAgICAgICAgICAgICAgIChoYXNQcm9qZWN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykgfHxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIHJlc2V0VHJhbnNmb3JtKHRoaXMuaW5zdGFuY2UsIHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWVhc3VyZShyZW1vdmVUcmFuc2Zvcm0gPSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBwYWdlQm94ID0gdGhpcy5tZWFzdXJlUGFnZUJveCgpO1xuICAgICAgICAgICAgbGV0IGxheW91dEJveCA9IHRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChwYWdlQm94KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWVhc3VyZW1lbnRzIHRha2VuIGR1cmluZyB0aGUgcHJlLXJlbmRlciBzdGFnZVxuICAgICAgICAgICAgICogc3RpbGwgaGF2ZSB0cmFuc2Zvcm1zIGFwcGxpZWQgc28gd2UgcmVtb3ZlIHRoZW1cbiAgICAgICAgICAgICAqIHZpYSBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlbW92ZVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGxheW91dEJveCA9IHRoaXMucmVtb3ZlVHJhbnNmb3JtKGxheW91dEJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3VuZEJveChsYXlvdXRCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JZDogdGhpcy5yb290LmFuaW1hdGlvbklkLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkQm94OiBwYWdlQm94LFxuICAgICAgICAgICAgICAgIGxheW91dEJveCxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5pZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVhc3VyZVBhZ2VCb3goKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb25zdCBib3ggPSB2aXN1YWxFbGVtZW50Lm1lYXN1cmVWaWV3cG9ydEJveCgpO1xuICAgICAgICAgICAgY29uc3Qgd2FzSW5TY3JvbGxSb290ID0gKChfYSA9IHRoaXMuc2Nyb2xsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FzUm9vdCkgfHwgdGhpcy5wYXRoLnNvbWUoY2hlY2tOb2RlV2FzU2Nyb2xsUm9vdCk7XG4gICAgICAgICAgICBpZiAoIXdhc0luU2Nyb2xsUm9vdCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB2aWV3cG9ydCBzY3JvbGwgdG8gZ2l2ZSBwYWdlLXJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JvbGwgfSA9IHRoaXMucm9vdDtcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LngsIHNjcm9sbC5vZmZzZXQueCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94LnksIHNjcm9sbC5vZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVFbGVtZW50U2Nyb2xsKGJveCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgYm94V2l0aG91dFNjcm9sbCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnNjcm9sbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndhc1Jvb3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFNjcm9sbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGVyZm9ybWFuY2UgVE9ETzogS2VlcCBhIGN1bXVsYXRpdmUgc2Nyb2xsIG9mZnNldCBkb3duIHRoZSB0cmVlXG4gICAgICAgICAgICAgKiByYXRoZXIgdGhhbiBsb29wIGJhY2sgdXAgdGhlIHBhdGguXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNjcm9sbCwgb3B0aW9ucyB9ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSAhPT0gdGhpcy5yb290ICYmIHNjcm9sbCAmJiBvcHRpb25zLmxheW91dFNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIG5ldyBzY3JvbGwgcm9vdCwgd2Ugd2FudCB0byByZW1vdmUgYWxsIHByZXZpb3VzIHNjcm9sbHNcbiAgICAgICAgICAgICAgICAgICAgICogZnJvbSB0aGUgdmlld3BvcnQgYm94LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjcm9sbC53YXNSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0U2Nyb2xsLCBib3gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC54LCBzY3JvbGwub2Zmc2V0LngpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueSwgc2Nyb2xsLm9mZnNldC55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFNjcm9sbDtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVRyYW5zZm9ybShib3gsIHRyYW5zZm9ybU9ubHkgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3Qgd2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKHdpdGhUcmFuc2Zvcm1zLCBib3gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNmb3JtT25seSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IC1ub2RlLnNjcm9sbC5vZmZzZXQueSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCBub2RlLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3JtcywgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdpdGhUcmFuc2Zvcm1zO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZVRyYW5zZm9ybShib3gpIHtcbiAgICAgICAgICAgIGNvbnN0IGJveFdpdGhvdXRUcmFuc2Zvcm0gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRUcmFuc2Zvcm0sIGJveCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGhhc1NjYWxlKG5vZGUubGF0ZXN0VmFsdWVzKSAmJiBub2RlLnVwZGF0ZVNuYXBzaG90KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQm94ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUJveCA9IG5vZGUubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhzb3VyY2VCb3gsIG5vZGVCb3gpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgbm9kZS5sYXRlc3RWYWx1ZXMsIG5vZGUuc25hcHNob3QgPyBub2RlLnNuYXBzaG90LmxheW91dEJveCA6IHVuZGVmaW5lZCwgc291cmNlQm94KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3hXaXRob3V0VHJhbnNmb3JtLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgICBzZXRUYXJnZXREZWx0YShkZWx0YSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IGRlbHRhO1xuICAgICAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5pc1Byb2plY3Rpb25EaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgY3Jvc3NmYWRlOiBvcHRpb25zLmNyb3NzZmFkZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jcm9zc2ZhZGUgOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhck1lYXN1cmVtZW50cygpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVQYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcGFyZW50IHRhcmdldCBpc24ndCB1cC10by1kYXRlLCBmb3JjZSBpdCB0byB1cGRhdGUuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGFuIHVuZm9ydHVuYXRlIGRlLW9wdGltaXNhdGlvbiBhcyBpdCBtZWFucyBhbnkgdXBkYXRpbmcgcmVsYXRpdmVcbiAgICAgICAgICAgICAqIHByb2plY3Rpb24gd2lsbCBjYXVzZSBhbGwgdGhlIHJlbGF0aXZlIHBhcmVudHMgdG8gcmVjYWxjdWxhdGUgYmFja1xuICAgICAgICAgICAgICogdXAgdGhlIHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlUGFyZW50LnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCAhPT1cbiAgICAgICAgICAgICAgICBmcmFtZURhdGEudGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC5yZXNvbHZlVGFyZ2V0RGVsdGEodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZVRhcmdldERlbHRhKGZvcmNlUmVjYWxjdWxhdGlvbiA9IGZhbHNlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9uY2UgdGhlIGRpcnR5IHN0YXR1cyBvZiBub2RlcyBoYXMgYmVlbiBzcHJlYWQgdGhyb3VnaCB0aGUgdHJlZSwgd2UgYWxzb1xuICAgICAgICAgICAgICogbmVlZCB0byBjaGVjayBpZiB3ZSBoYXZlIGEgc2hhcmVkIG5vZGUgb2YgYSBkaWZmZXJlbnQgZGVwdGggdGhhdCBoYXMgaXRzZWxmXG4gICAgICAgICAgICAgKiBiZWVuIGRpcnRpZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgfHwgKHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSBsZWFkLmlzUHJvamVjdGlvbkRpcnR5KTtcbiAgICAgICAgICAgIHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eSB8fCAodGhpcy5pc1RyYW5zZm9ybURpcnR5ID0gbGVhZC5pc1RyYW5zZm9ybURpcnR5KTtcbiAgICAgICAgICAgIHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgfHwgKHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgPSBsZWFkLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2hhcmVkID0gQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgfHwgdGhpcyAhPT0gbGVhZDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgZG9uJ3QgdXNlIHRyYW5zZm9ybSBmb3IgdGhpcyBzdGVwIG9mIHByb2Nlc3Npbmcgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgICAqIG5lZWQgdG8gY2hlY2sgd2hldGhlciBhbnkgbm9kZXMgaGF2ZSBjaGFuZ2VkIHRyYW5zZm9ybS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgY2FuU2tpcCA9ICEoZm9yY2VSZWNhbGN1bGF0aW9uIHx8XG4gICAgICAgICAgICAgICAgKGlzU2hhcmVkICYmIHRoaXMuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb2plY3Rpb25EaXJ0eSB8fFxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUHJvamVjdGlvbkRpcnR5KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSk7XG4gICAgICAgICAgICBpZiAoY2FuU2tpcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyBsYXlvdXQsIHdlIGNhbid0IHBlcmZvcm0gcHJvamVjdGlvbiwgc28gZWFybHkgcmV0dXJuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWRSZWxhdGl2ZVRhcmdldEF0ID0gZnJhbWVEYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldERlbHRhIGJ1dCBkbyBoYXZlIGEgbGF5b3V0LCB3ZSBjYW4gYXR0ZW1wdCB0byByZXNvbHZlXG4gICAgICAgICAgICAgKiBhIHJlbGF0aXZlUGFyZW50LiBUaGlzIHdpbGwgYWxsb3cgYSBjb21wb25lbnQgdG8gcGVyZm9ybSBzY2FsZSBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgKiBldmVuIGlmIG5vIGFuaW1hdGlvbiBoYXMgc3RhcnRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRhcmdldERlbHRhICYmICF0aGlzLnJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSB0aGlzLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGFyZW50LmxheW91dCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIHJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyByZWxhdGl2ZSB0YXJnZXQgb3Igbm8gdGFyZ2V0IGRlbHRhIG91ciB0YXJnZXQgaXNuJ3QgdmFsaWRcbiAgICAgICAgICAgICAqIGZvciB0aGlzIGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVUYXJnZXQgJiYgIXRoaXMudGFyZ2V0RGVsdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMYXp5LWluaXQgdGFyZ2V0IGRhdGEgc3RydWN0dXJlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UndmUgZ290IGEgcmVsYXRpdmUgYm94IGZvciB0aGlzIGNvbXBvbmVudCwgcmVzb2x2ZSBpdCBpbnRvIGEgdGFyZ2V0IHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJlxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCgpO1xuICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZUJveCh0aGlzLnRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3ZlIG9ubHkgZ290IGEgdGFyZ2V0RGVsdGEsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy50YXJnZXREZWx0YSkge1xuICAgICAgICAgICAgICAgIGlmIChCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIGNyZWF0aW5nIGEgbmV3IG9iamVjdCBldmVyeSBmcmFtZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0odGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcHBseUJveERlbHRhKHRoaXMudGFyZ2V0LCB0aGlzLnRhcmdldERlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIG5vIHRhcmdldCwgdXNlIG93biBsYXlvdXQgYXMgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy50YXJnZXQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gdG9sZCB0byBhdHRlbXB0IHRvIHJlc29sdmUgYSByZWxhdGl2ZSB0YXJnZXQsIGRvIHNvLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHJlbGF0aXZlUGFyZW50LnJlc3VtaW5nRnJvbSkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSAmJlxuICAgICAgICAgICAgICAgICAgICAhcmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXJlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHRoaXMudGFyZ2V0LCByZWxhdGl2ZVBhcmVudC50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5jcmVhc2UgZGVidWcgY291bnRlciBmb3IgcmVzb2x2ZWQgdGFyZ2V0IGRlbHRhc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MucmVzb2x2ZWRUYXJnZXREZWx0YXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQgfHxcbiAgICAgICAgICAgICAgICBoYXNTY2FsZSh0aGlzLnBhcmVudC5sYXRlc3RWYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgaGFzMkRUcmFuc2xhdGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuaXNQcm9qZWN0aW5nKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1Byb2plY3RpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbigodGhpcy5yZWxhdGl2ZVRhcmdldCB8fFxuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmxheW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsY1Byb2plY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICBjb25zdCBpc1NoYXJlZCA9IEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQ7XG4gICAgICAgICAgICBsZXQgY2FuU2tpcCA9IHRydWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBub3JtYWwgbGF5b3V0IGFuaW1hdGlvbiBhbmQgbmVpdGhlciB0aGlzIG5vZGUgbm9yIGl0cyBuZWFyZXN0IHByb2plY3RpbmdcbiAgICAgICAgICAgICAqIGlzIGRpcnR5IHRoZW4gd2UgY2FuJ3Qgc2tpcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgfHwgKChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNQcm9qZWN0aW9uRGlydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FuU2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgc2hhcmVkIGxheW91dCBhbmltYXRpb24gYW5kIHRoaXMgbm9kZSdzIHNoYXJlZCBwcm9qZWN0aW9uIGlzIGRpcnR5IHRoZW5cbiAgICAgICAgICAgICAqIHdlIGNhbid0IHNraXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1NoYXJlZCAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IHx8IHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYW5Ta2lwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgcmVzb2x2ZWQgdGhlIHRhcmdldCB0aGlzIGZyYW1lIHdlIG11c3QgcmVjYWxjdWxhdGUgdGhlXG4gICAgICAgICAgICAgKiBwcm9qZWN0aW9uIHRvIGVuc3VyZSBpdCB2aXN1YWxseSByZXByZXNlbnRzIHRoZSBpbnRlcm5hbCBjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCA9PT0gZnJhbWVEYXRhLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIGNhblNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5Ta2lwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0LCBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHNlY3Rpb24gb2YgdGhlIHRyZWUgaXNuJ3QgYW5pbWF0aW5nIHdlIGNhblxuICAgICAgICAgICAgICogZGVsZXRlIG91ciB0YXJnZXQgc291cmNlcyBmb3IgdGhlIGZvbGxvd2luZyBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyZWVBbmltYXRpbmcgPSBCb29sZWFuKCh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1RyZWVBbmltYXRpbmcpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc1RyZWVBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXlvdXQgfHwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVzZXQgdGhlIGNvcnJlY3RlZCBib3ggd2l0aCB0aGUgbGF0ZXN0IHZhbHVlcyBmcm9tIGJveCwgYXMgd2UncmUgdGhlbiBnb2luZ1xuICAgICAgICAgICAgICogdG8gcGVyZm9ybSBtdXRhdGl2ZSBvcGVyYXRpb25zIG9uIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjb3JkIHByZXZpb3VzIHRyZWUgc2NhbGVzIGJlZm9yZSB1cGRhdGluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVggPSB0aGlzLnRyZWVTY2FsZS54O1xuICAgICAgICAgICAgY29uc3QgcHJldlRyZWVTY2FsZVkgPSB0aGlzLnRyZWVTY2FsZS55O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBhbGwgdGhlIHBhcmVudCBkZWx0YXMgdG8gdGhpcyBib3ggdG8gcHJvZHVjZSB0aGUgY29ycmVjdGVkIGJveC4gVGhpc1xuICAgICAgICAgICAgICogaXMgdGhlIGxheW91dCBib3gsIGFzIGl0IHdpbGwgYXBwZWFyIG9uIHNjcmVlbiBhcyBhIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtcyBvZiBpdHMgcGFyZW50cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXBwbHlUcmVlRGVsdGFzKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLnRyZWVTY2FsZSwgdGhpcy5wYXRoLCBpc1NoYXJlZCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgbGF5ZXIgbmVlZHMgdG8gcGVyZm9ybSBzY2FsZSBjb3JyZWN0aW9uIGJ1dCBkb2Vzbid0IGhhdmUgYSB0YXJnZXQsXG4gICAgICAgICAgICAgKiB1c2UgdGhlIGxheW91dCBhcyB0aGUgdGFyZ2V0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAobGVhZC5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAhbGVhZC50YXJnZXQgJiZcbiAgICAgICAgICAgICAgICAodGhpcy50cmVlU2NhbGUueCAhPT0gMSB8fCB0aGlzLnRyZWVTY2FsZS55ICE9PSAxKSkge1xuICAgICAgICAgICAgICAgIGxlYWQudGFyZ2V0ID0gbGVhZC5sYXlvdXQubGF5b3V0Qm94O1xuICAgICAgICAgICAgICAgIGxlYWQudGFyZ2V0V2l0aFRyYW5zZm9ybXMgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBsZWFkO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGEgdGFyZ2V0IHRvIHByb2plY3QgaW50bywgYnV0IHdlIHdlcmUgcHJldmlvdXNseVxuICAgICAgICAgICAgICAgICAqIHByb2plY3RpbmcsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoZSBzdG9yZWQgdHJhbnNmb3JtIGFuZCBzY2hlZHVsZVxuICAgICAgICAgICAgICAgICAqIGEgcmVuZGVyIHRvIGVuc3VyZSB0aGUgZWxlbWVudHMgcmVmbGVjdCB0aGUgcmVtb3ZlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldlByb2plY3Rpb25EZWx0YSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByb2plY3Rpb25EZWx0YXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVByb2plY3Rpb25EZWx0YXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcHlBeGlzRGVsdGFJbnRvKHRoaXMucHJldlByb2plY3Rpb25EZWx0YS54LCB0aGlzLnByb2plY3Rpb25EZWx0YS54KTtcbiAgICAgICAgICAgICAgICBjb3B5QXhpc0RlbHRhSW50byh0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEueSwgdGhpcy5wcm9qZWN0aW9uRGVsdGEueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIHRhcmdldCBib3ggYmVmb3JlIHVzZXItc2V0IHRyYW5zZm9ybXMgd2VyZSBhcHBsaWVkLlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGFsbG93IHVzIHRvIGNhbGN1bGF0ZSB0aGUgY29ycmVjdGVkIGJvcmRlclJhZGl1cyBhbmQgYm94U2hhZG93IHRvIGNvbXBlbnNhdGVcbiAgICAgICAgICAgICAqIGZvciBvdXIgbGF5b3V0IHJlcHJvamVjdGlvbiwgYnV0IHN0aWxsIGFsbG93IHRoZW0gdG8gYmUgc2NhbGVkIGNvcnJlY3RseSBieSB0aGUgdXNlci5cbiAgICAgICAgICAgICAqIEl0IG1pZ2h0IGJlIHRoYXQgdG8gc2ltcGxpZnkgdGhpcyB3ZSBtYXkgd2FudCB0byBhY2NlcHQgdGhhdCB1c2VyLXNldCBzY2FsZSBpcyBhbHNvIGNvcnJlY3RlZFxuICAgICAgICAgICAgICogYW5kIHdlIHdvdWxkbid0IGhhdmUgdG8ga2VlcCBhbmQgY2FsYyBib3RoIGRlbHRhcywgT1Igd2UgY291bGQgc3VwcG9ydCBhIHVzZXIgc2V0dGluZ1xuICAgICAgICAgICAgICogdG8gYWxsb3cgcGVvcGxlIHRvIGNob29zZSB3aGV0aGVyIHRoZXNlIHN0eWxlcyBhcmUgY29ycmVjdGVkIGJhc2VkIG9uIGp1c3QgdGhlXG4gICAgICAgICAgICAgKiBsYXlvdXQgcmVwcm9qZWN0aW9uIG9yIHRoZSBmaW5hbCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRhcmdldCwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJlZVNjYWxlLnggIT09IHByZXZUcmVlU2NhbGVYIHx8XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUueSAhPT0gcHJldlRyZWVTY2FsZVkgfHxcbiAgICAgICAgICAgICAgICAhYXhpc0RlbHRhRXF1YWxzKHRoaXMucHJvamVjdGlvbkRlbHRhLngsIHRoaXMucHJldlByb2plY3Rpb25EZWx0YS54KSB8fFxuICAgICAgICAgICAgICAgICFheGlzRGVsdGFFcXVhbHModGhpcy5wcm9qZWN0aW9uRGVsdGEueSwgdGhpcy5wcmV2UHJvamVjdGlvbkRlbHRhLnkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcInByb2plY3Rpb25VcGRhdGVcIiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5jcmVhc2UgZGVidWcgY291bnRlciBmb3IgcmVjYWxjdWxhdGVkIHByb2plY3Rpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgbWV0cmljcy5yZWNhbGN1bGF0ZWRQcm9qZWN0aW9uKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGlkZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBUT0RPOiBTY2hlZHVsZSByZW5kZXJcbiAgICAgICAgfVxuICAgICAgICBzaG93KCkge1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogU2NoZWR1bGUgcmVuZGVyXG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVSZW5kZXIobm90aWZ5QWxsID0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgaWYgKG5vdGlmeUFsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgICAgIHN0YWNrICYmIHN0YWNrLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgIXRoaXMucmVzdW1pbmdGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3JlYXRlUHJvamVjdGlvbkRlbHRhcygpIHtcbiAgICAgICAgICAgIHRoaXMucHJldlByb2plY3Rpb25EZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0gPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuc25hcHNob3Q7XG4gICAgICAgICAgICBjb25zdCBzbmFwc2hvdExhdGVzdFZhbHVlcyA9IHNuYXBzaG90XG4gICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5sYXRlc3RWYWx1ZXNcbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgY29uc3QgbWl4ZWRWYWx1ZXMgPSB7IC4uLnRoaXMubGF0ZXN0VmFsdWVzIH07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVsYXRpdmVQYXJlbnQgfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5yZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0ID0gIWhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RTb3VyY2UgPSBzbmFwc2hvdCA/IHNuYXBzaG90LnNvdXJjZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dFNvdXJjZSA9IHRoaXMubGF5b3V0ID8gdGhpcy5sYXlvdXQuc291cmNlIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gPSBzbmFwc2hvdFNvdXJjZSAhPT0gbGF5b3V0U291cmNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBjb25zdCBpc09ubHlNZW1iZXIgPSAhc3RhY2sgfHwgc3RhY2subWVtYmVycy5sZW5ndGggPD0gMTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZENyb3NzZmFkZU9wYWNpdHkgPSBCb29sZWFuKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzT25seU1lbWJlciAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5jcm9zc2ZhZGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5wYXRoLnNvbWUoaGFzT3BhY2l0eUNyb3NzZmFkZSkpO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICBsZXQgcHJldlJlbGF0aXZlVGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSA9IChsYXRlc3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IGxhdGVzdCAvIDEwMDA7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLngsIGRlbHRhLngsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBtaXhBeGlzRGVsdGEodGFyZ2V0RGVsdGEueSwgZGVsdGEueSwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGFyZ2V0RGVsdGEodGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgICAgICBtaXhCb3godGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgcmVsYXRpdmVMYXlvdXQsIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gdW5jaGFuZ2VkIHJlbGF0aXZlIHRhcmdldCB3ZSBjYW4gY29uc2lkZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIHByb2plY3Rpb24gbm90IGRpcnR5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZSZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYm94RXF1YWxzKHRoaXMucmVsYXRpdmVUYXJnZXQsIHByZXZSZWxhdGl2ZVRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZSZWxhdGl2ZVRhcmdldClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZSZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhwcmV2UmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNTaGFyZWRMYXlvdXRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXMgPSBtaXhlZFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgbWl4VmFsdWVzKG1peGVkVmFsdWVzLCBzbmFwc2hvdExhdGVzdFZhbHVlcywgdGhpcy5sYXRlc3RWYWx1ZXMsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKHRoaXMub3B0aW9ucy5sYXlvdXRSb290ID8gMTAwMCA6IDApO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwiYW5pbWF0aW9uU3RhcnRcIik7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gJiYgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSAmJiB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsRnJhbWUodGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0YXJ0IHRoZSBhbmltYXRpb24gaW4gdGhlIG5leHQgZnJhbWUgdG8gaGF2ZSBhIGZyYW1lIHdpdGggcHJvZ3Jlc3MgMCxcbiAgICAgICAgICAgICAqIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWQsIHNvIHdlIGNhblxuICAgICAgICAgICAgICogY2FsY3VsYXRlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgY29ycmVjdGx5IGZvciBpbnN0YW50IHRyYW5zaXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRlU2luZ2xlVmFsdWUoMCwgYW5pbWF0aW9uVGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIG9uVXBkYXRlOiAobGF0ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uVXBkYXRlICYmIG9wdGlvbnMub25VcGRhdGUobGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlICYmIG9wdGlvbnMub25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb21wbGV0ZUFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucHJlc2VydmVPcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBzdGFjayAmJiBzdGFjay5leGl0QW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvbkNvbXBsZXRlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmlzaEFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1peFRhcmdldERlbHRhICYmIHRoaXMubWl4VGFyZ2V0RGVsdGEoYW5pbWF0aW9uVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUFuaW1hdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCkge1xuICAgICAgICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgbGV0IHsgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCwgbGF5b3V0LCBsYXRlc3RWYWx1ZXMgfSA9IGxlYWQ7XG4gICAgICAgICAgICBpZiAoIXRhcmdldFdpdGhUcmFuc2Zvcm1zIHx8ICF0YXJnZXQgfHwgIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIG9ubHkgYW5pbWF0aW5nIHBvc2l0aW9uLCBhbmQgdGhpcyBlbGVtZW50IGlzbid0IHRoZSBsZWFkIGVsZW1lbnQsXG4gICAgICAgICAgICAgKiB0aGVuIGluc3RlYWQgb2YgcHJvamVjdGluZyBpbnRvIHRoZSBsZWFkIGJveCB3ZSBpbnN0ZWFkIHdhbnQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAgKiBhIG5ldyB0YXJnZXQgdGhhdCBhbGlnbnMgdGhlIHR3byBib3hlcyBidXQgbWFpbnRhaW5zIHRoZSBsYXlvdXQgc2hhcGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzICE9PSBsZWFkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICBsYXlvdXQgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KHRoaXMub3B0aW9ucy5hbmltYXRpb25UeXBlLCB0aGlzLmxheW91dC5sYXlvdXRCb3gsIGxheW91dC5sYXlvdXRCb3gpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy50YXJnZXQgfHwgY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeExlbmd0aCA9IGNhbGNMZW5ndGgodGhpcy5sYXlvdXQubGF5b3V0Qm94LngpO1xuICAgICAgICAgICAgICAgIHRhcmdldC54Lm1pbiA9IGxlYWQudGFyZ2V0LngubWluO1xuICAgICAgICAgICAgICAgIHRhcmdldC54Lm1heCA9IHRhcmdldC54Lm1pbiArIHhMZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgeUxlbmd0aCA9IGNhbGNMZW5ndGgodGhpcy5sYXlvdXQubGF5b3V0Qm94LnkpO1xuICAgICAgICAgICAgICAgIHRhcmdldC55Lm1pbiA9IGxlYWQudGFyZ2V0LnkubWluO1xuICAgICAgICAgICAgICAgIHRhcmdldC55Lm1heCA9IHRhcmdldC55Lm1pbiArIHlMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3B5Qm94SW50byh0YXJnZXRXaXRoVHJhbnNmb3JtcywgdGFyZ2V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgdGhlIGxhdGVzdCB1c2VyLXNldCB0cmFuc2Zvcm1zIHRvIHRoZSB0YXJnZXRCb3ggdG8gcHJvZHVjZSB0aGUgdGFyZ2V0Qm94RmluYWwuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRoZSBmaW5hbCBib3ggdGhhdCB3ZSB3aWxsIHRoZW4gcHJvamVjdCBpbnRvIGJ5IGNhbGN1bGF0aW5nIGEgdHJhbnNmb3JtIGRlbHRhIGFuZFxuICAgICAgICAgICAgICogYXBwbHlpbmcgaXQgdG8gdGhlIGNvcnJlY3RlZCBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRyYW5zZm9ybUJveCh0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBkZWx0YSBiZXR3ZWVuIHRoZSBjb3JyZWN0ZWQgYm94IGFuZCB0aGUgZmluYWwgdGFyZ2V0IGJveCwgYWZ0ZXJcbiAgICAgICAgICAgICAqIHVzZXItc2V0IHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoaXMgd2lsbCBiZSB1c2VkIGJ5IHRoZSByZW5kZXJlciB0b1xuICAgICAgICAgICAgICogY3JlYXRlIGEgdHJhbnNmb3JtIHN0eWxlIHRoYXQgd2lsbCByZXByb2plY3QgdGhlIGVsZW1lbnQgZnJvbSBpdHMgbGF5b3V0IGxheW91dFxuICAgICAgICAgICAgICogaW50byB0aGUgZGVzaXJlZCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXRXaXRoVHJhbnNmb3JtcywgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIG5vZGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFyZWROb2Rlcy5oYXMobGF5b3V0SWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5zZXQobGF5b3V0SWQsIG5ldyBOb2RlU3RhY2soKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgICAgICAgIHN0YWNrLmFkZChub2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IG5vZGUub3B0aW9ucy5pbml0aWFsUHJvbW90aW9uQ29uZmlnO1xuICAgICAgICAgICAgbm9kZS5wcm9tb3RlKHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uOiBjb25maWcgPyBjb25maWcudHJhbnNpdGlvbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZUZvbGxvd09wYWNpdHk6IGNvbmZpZyAmJiBjb25maWcuc2hvdWxkUHJlc2VydmVGb2xsb3dPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgID8gY29uZmlnLnNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eShub2RlKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlzTGVhZCgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrID8gc3RhY2subGVhZCA9PT0gdGhpcyA6IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0TGVhZCgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/ICgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZWFkKSB8fCB0aGlzIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICBnZXRQcmV2TGVhZCgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXRJZCA/IChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXZMZWFkIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGdldFN0YWNrKCkge1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXRJZCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKGxheW91dElkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9tb3RlKHsgbmVlZHNSZXNldCwgdHJhbnNpdGlvbiwgcHJlc2VydmVGb2xsb3dPcGFjaXR5LCB9ID0ge30pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgaWYgKHN0YWNrKVxuICAgICAgICAgICAgICAgIHN0YWNrLnByb21vdGUodGhpcywgcHJlc2VydmVGb2xsb3dPcGFjaXR5KTtcbiAgICAgICAgICAgIGlmIChuZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IHRyYW5zaXRpb24gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVsZWdhdGUoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIGlmIChzdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFjay5yZWxlZ2F0ZSh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXNldFNrZXdBbmRSb3RhdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZGV0ZWN0ZWQgc2tldyBvciByb3RhdGlvbiB2YWx1ZXMsIHdlIGNhbiBlYXJseSByZXR1cm4gd2l0aG91dCBhIGZvcmNlZCByZW5kZXIuXG4gICAgICAgICAgICBsZXQgaGFzRGlzdG9ydGluZ1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiB1bnJvbGxlZCBjaGVjayBmb3Igcm90YXRpb24gdmFsdWVzLiBNb3N0IGVsZW1lbnRzIGRvbid0IGhhdmUgYW55IHJvdGF0aW9uIGFuZFxuICAgICAgICAgICAgICogc2tpcHBpbmcgdGhlIG5lc3RlZCBsb29wIGFuZCBuZXcgb2JqZWN0IGNyZWF0aW9uIGlzIDUwJSBmYXN0ZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHsgbGF0ZXN0VmFsdWVzIH0gPSB2aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZhbHVlcy56IHx8XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzLnJvdGF0ZSB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5yb3RhdGVYIHx8XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzLnJvdGF0ZVkgfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMucm90YXRlWiB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5za2V3WCB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5za2V3WSkge1xuICAgICAgICAgICAgICAgIGhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBkaXN0b3J0aW5nIHZhbHVlcywgd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnkgbW9yZS5cbiAgICAgICAgICAgIGlmICghaGFzRGlzdG9ydGluZ1RyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCByZXNldFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZhbHVlcy56KSB7XG4gICAgICAgICAgICAgICAgcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKFwielwiLCB2aXN1YWxFbGVtZW50LCByZXNldFZhbHVlcywgdGhpcy5hbmltYXRpb25WYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHNrZXcgYW5kIHJvdGF0ZSB2YWx1ZSBvZiBhbGwgYXhlcyBhbmQgcmVzZXQgdG8gMFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm1BeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKGByb3RhdGUke3RyYW5zZm9ybUF4ZXNbaV19YCwgdmlzdWFsRWxlbWVudCwgcmVzZXRWYWx1ZXMsIHRoaXMuYW5pbWF0aW9uVmFsdWVzKTtcbiAgICAgICAgICAgICAgICByZXNldERpc3RvcnRpbmdUcmFuc2Zvcm0oYHNrZXcke3RyYW5zZm9ybUF4ZXNbaV19YCwgdmlzdWFsRWxlbWVudCwgcmVzZXRWYWx1ZXMsIHRoaXMuYW5pbWF0aW9uVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvcmNlIGEgcmVuZGVyIG9mIHRoaXMgZWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHdpdGggYWxsIHNrZXdzIGFuZCByb3RhdGlvbnNcbiAgICAgICAgICAgIC8vIHNldCB0byAwLlxuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgIC8vIFB1dCBiYWNrIGFsbCB0aGUgdmFsdWVzIHdlIHJlc2V0XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiByZXNldFZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCByZXNldFZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXNba2V5XSA9IHJlc2V0VmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBuZXh0IGZyYW1lLiBUaGlzIGVuc3VyZXMgd2Ugd29uJ3QgdmlzdWFsbHlcbiAgICAgICAgICAgIC8vIHNlZSB0aGUgZWxlbWVudCB3aXRoIHRoZSByZXNldCByb3RhdGUgdmFsdWUgYXBwbGllZC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBnZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSB8fCB0aGlzLmlzU1ZHKVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZGRlblZpc2liaWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wID09PSBudWxsIHx8IHN0eWxlUHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEgfHwgIXRoaXMubGF5b3V0IHx8ICFsZWFkLnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5U3R5bGVzID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wID09PSBudWxsIHx8IHN0eWxlUHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmhhc1Byb2plY3RlZCAmJiAhaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBlbXB0eVN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlc1RvUmVuZGVyID0gbGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgbGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCk7XG4gICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy50cmVlU2NhbGUsIHZhbHVlc1RvUmVuZGVyKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSh2YWx1ZXNUb1JlbmRlciwgc3R5bGVzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMucHJvamVjdGlvbkRlbHRhO1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybU9yaWdpbiA9IGAke3gub3JpZ2luICogMTAwfSUgJHt5Lm9yaWdpbiAqIDEwMH0lIDBgO1xuICAgICAgICAgICAgaWYgKGxlYWQuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGxlYWQgY29tcG9uZW50IGlzIGFuaW1hdGluZywgYXNzaWduIHRoaXMgZWl0aGVyIHRoZSBlbnRlcmluZy9sZWF2aW5nXG4gICAgICAgICAgICAgICAgICogb3BhY2l0eVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoX2IgPSAoX2EgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucHJlc2VydmVPcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9yIHdlJ3JlIG5vdCBhbmltYXRpbmcgYXQgYWxsLCBzZXQgdGhlIGxlYWQgY29tcG9uZW50IHRvIGl0cyBsYXlvdXRcbiAgICAgICAgICAgICAgICAgKiBvcGFjaXR5IGFuZCBvdGhlciBjb21wb25lbnRzIHRvIGhpZGRlbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBzY2FsZSBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjYWxlQ29ycmVjdG9ycykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNUb1JlbmRlcltrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29ycmVjdCwgYXBwbHlUbywgaXNDU1NWYXJpYWJsZSB9ID0gc2NhbGVDb3JyZWN0b3JzW2tleV07XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT25seSBhcHBseSBzY2FsZSBjb3JyZWN0aW9uIHRvIHRoZSB2YWx1ZSBpZiB3ZSBoYXZlIGFuXG4gICAgICAgICAgICAgICAgICogYWN0aXZlIHByb2plY3Rpb24gdHJhbnNmb3JtLiBPdGhlcndpc2UgdGhlc2UgdmFsdWVzIGJlY29tZVxuICAgICAgICAgICAgICAgICAqIHZ1bG5lcmFibGUgdG8gZGlzdG9ydGlvbiBpZiB0aGUgZWxlbWVudCBjaGFuZ2VzIHNpemUgd2l0aG91dFxuICAgICAgICAgICAgICAgICAqIGEgY29ycmVzcG9uZGluZyBsYXlvdXQgYW5pbWF0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZCA9IHN0eWxlcy50cmFuc2Zvcm0gPT09IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgID8gdmFsdWVzVG9SZW5kZXJba2V5XVxuICAgICAgICAgICAgICAgICAgICA6IGNvcnJlY3QodmFsdWVzVG9SZW5kZXJba2V5XSwgbGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5VG8pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbnVtID0gYXBwbHlUby5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1thcHBseVRvW2ldXSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIENTUyB2YXJpYWJsZSwgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjaW5nIHRoaXMgZnVuY3Rpb24gZnJvbSBjcmVhdGluZyBzdHlsZXMgdG8gc2V0dGluZyB0aGVtXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIGEgZ29vZCBwbGFjZSB0byByZW1vdmUgcGVyIGZyYW1lIG9iamVjdCBjcmVhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQucmVuZGVyU3RhdGUudmFyc1trZXldID0gY29ycmVjdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzW2tleV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpc2FibGUgcG9pbnRlciBldmVudHMgb24gZm9sbG93IGNvbXBvbmVudHMuIFRoaXMgaXMgdG8gZW5zdXJlXG4gICAgICAgICAgICAgKiB0aGF0IGlmIGEgZm9sbG93IGNvbXBvbmVudCBjb3ZlcnMgYSBsZWFkIGNvbXBvbmVudCBpdCBkb2Vzbid0IGJsb2NrXG4gICAgICAgICAgICAgKiBwb2ludGVyIGV2ZW50cyBvbiB0aGUgbGVhZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wID09PSBudWxsIHx8IHN0eWxlUHJvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyU25hcHNob3QoKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VtZUZyb20gPSB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgcnVuIG9uIHJvb3RcbiAgICAgICAgcmVzZXRUcmVlKCkge1xuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gbm9kZS5jdXJyZW50QW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpOyB9KTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKGNsZWFyTWVhc3VyZW1lbnRzKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zaGFyZWROb2Rlcy5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dChub2RlKSB7XG4gICAgbm9kZS51cGRhdGVMYXlvdXQoKTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUxheW91dFVwZGF0ZShub2RlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNuYXBzaG90ID0gKChfYSA9IG5vZGUucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNuYXBzaG90KSB8fCBub2RlLnNuYXBzaG90O1xuICAgIGlmIChub2RlLmlzTGVhZCgpICYmXG4gICAgICAgIG5vZGUubGF5b3V0ICYmXG4gICAgICAgIHNuYXBzaG90ICYmXG4gICAgICAgIG5vZGUuaGFzTGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5b3V0Qm94OiBsYXlvdXQsIG1lYXN1cmVkQm94OiBtZWFzdXJlZExheW91dCB9ID0gbm9kZS5sYXlvdXQ7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uVHlwZSB9ID0gbm9kZS5vcHRpb25zO1xuICAgICAgICBjb25zdCBpc1NoYXJlZCA9IHNuYXBzaG90LnNvdXJjZSAhPT0gbm9kZS5sYXlvdXQuc291cmNlO1xuICAgICAgICAvLyBUT0RPIE1heWJlIHdlIHdhbnQgdG8gYWxzbyByZXNpemUgdGhlIGxheW91dCBzbmFwc2hvdCBzbyB3ZSBkb24ndCB0cmlnZ2VyXG4gICAgICAgIC8vIGFuaW1hdGlvbnMgZm9yIGluc3RhbmNlIGlmIGxheW91dD1cInNpemVcIiBhbmQgYW4gZWxlbWVudCBoYXMgb25seSBjaGFuZ2VkIHBvc2l0aW9uXG4gICAgICAgIGlmIChhbmltYXRpb25UeXBlID09PSBcInNpemVcIikge1xuICAgICAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBheGlzU25hcHNob3QgPSBpc1NoYXJlZFxuICAgICAgICAgICAgICAgICAgICA/IHNuYXBzaG90Lm1lYXN1cmVkQm94W2F4aXNdXG4gICAgICAgICAgICAgICAgICAgIDogc25hcHNob3QubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgoYXhpc1NuYXBzaG90KTtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWluID0gbGF5b3V0W2F4aXNdLm1pbjtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNob3VsZEFuaW1hdGVQb3NpdGlvbk9ubHkoYW5pbWF0aW9uVHlwZSwgc25hcHNob3QubGF5b3V0Qm94LCBsYXlvdXQpKSB7XG4gICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF4aXNTbmFwc2hvdCA9IGlzU2hhcmVkXG4gICAgICAgICAgICAgICAgICAgID8gc25hcHNob3QubWVhc3VyZWRCb3hbYXhpc11cbiAgICAgICAgICAgICAgICAgICAgOiBzbmFwc2hvdC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FsY0xlbmd0aChsYXlvdXRbYXhpc10pO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVuc3VyZSByZWxhdGl2ZSB0YXJnZXQgZ2V0cyByZXNpemVkIGFuZCByZXJlbmRlcmVyZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnJlbGF0aXZlVGFyZ2V0ICYmICFub2RlLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pc1Byb2plY3Rpb25EaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpdmVUYXJnZXRbYXhpc10ubWF4ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpdmVUYXJnZXRbYXhpc10ubWluICsgbGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxheW91dERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgY2FsY0JveERlbHRhKGxheW91dERlbHRhLCBsYXlvdXQsIHNuYXBzaG90LmxheW91dEJveCk7XG4gICAgICAgIGNvbnN0IHZpc3VhbERlbHRhID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgaWYgKGlzU2hhcmVkKSB7XG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodmlzdWFsRGVsdGEsIG5vZGUuYXBwbHlUcmFuc2Zvcm0obWVhc3VyZWRMYXlvdXQsIHRydWUpLCBzbmFwc2hvdC5tZWFzdXJlZEJveCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodmlzdWFsRGVsdGEsIGxheW91dCwgc25hcHNob3QubGF5b3V0Qm94KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNMYXlvdXRDaGFuZ2VkID0gIWlzRGVsdGFaZXJvKGxheW91dERlbHRhKTtcbiAgICAgICAgbGV0IGhhc1JlbGF0aXZlTGF5b3V0Q2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIW5vZGUucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXJlbnQgPSBub2RlLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSByZWxhdGl2ZVBhcmVudCBpcyBpdHNlbGYgcmVzdW1pbmcgZnJvbSBhIGRpZmZlcmVudCBlbGVtZW50IHRoZW5cbiAgICAgICAgICAgICAqIHRoZSByZWxhdGl2ZSBzbmFwc2hvdCBpcyBub3QgcmVsYXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50ICYmICFyZWxhdGl2ZVBhcmVudC5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzbmFwc2hvdDogcGFyZW50U25hcHNob3QsIGxheW91dDogcGFyZW50TGF5b3V0IH0gPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50U25hcHNob3QgJiYgcGFyZW50TGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlU25hcHNob3QgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVTbmFwc2hvdCwgc25hcHNob3QubGF5b3V0Qm94LCBwYXJlbnRTbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZUxheW91dCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgbGF5b3V0LCBwYXJlbnRMYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFib3hFcXVhbHNSb3VuZGVkKHJlbGF0aXZlU25hcHNob3QsIHJlbGF0aXZlTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVsYXRpdmVMYXlvdXRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlVGFyZ2V0ID0gcmVsYXRpdmVMYXlvdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gcmVsYXRpdmVTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vdGlmeUxpc3RlbmVycyhcImRpZFVwZGF0ZVwiLCB7XG4gICAgICAgICAgICBsYXlvdXQsXG4gICAgICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgICAgIGRlbHRhOiB2aXN1YWxEZWx0YSxcbiAgICAgICAgICAgIGxheW91dERlbHRhLFxuICAgICAgICAgICAgaGFzTGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgICAgIGhhc1JlbGF0aXZlTGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUuaXNMZWFkKCkpIHtcbiAgICAgICAgY29uc3QgeyBvbkV4aXRDb21wbGV0ZSB9ID0gbm9kZS5vcHRpb25zO1xuICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcmluZyB0cmFuc2l0aW9uXG4gICAgICogVE9ETzogSW52ZXN0aWdhdGUgd2h5IHRoaXMgdHJhbnNpdGlvbiBpcyBiZWluZyBwYXNzZWQgaW4gYXMge3R5cGU6IGZhbHNlIH0gZnJvbSBGcmFtZXJcbiAgICAgKiBhbmQgd2h5IHdlIG5lZWQgaXQgYXQgYWxsXG4gICAgICovXG4gICAgbm9kZS5vcHRpb25zLnRyYW5zaXRpb24gPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVEaXJ0eU5vZGVzKG5vZGUpIHtcbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSBkZWJ1ZyBjb3VudGVyIGZvciBub2RlcyBlbmNvdW50ZXJlZCB0aGlzIGZyYW1lXG4gICAgICovXG4gICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgbWV0cmljcy50b3RhbE5vZGVzKys7XG4gICAgfVxuICAgIGlmICghbm9kZS5wYXJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG5vZGUgaXNuJ3QgcHJvamVjdGluZywgcHJvcGFnYXRlIGlzUHJvamVjdGlvbkRpcnR5LiBJdCB3aWxsIGhhdmVcbiAgICAgKiBubyBwZXJmb3JtYW5jZSBpbXBhY3QgYnV0IGl0IHdpbGwgYWxsb3cgdGhlIG5leHQgY2hpbGQgdGhhdCAqaXMqIHByb2plY3RpbmdcbiAgICAgKiBidXQgKmlzbid0KiBkaXJ0eSB0byBqdXN0IGNoZWNrIGl0cyBwYXJlbnQgdG8gc2VlIGlmICphbnkqIGFuY2VzdG9yIG5lZWRzXG4gICAgICogY29ycmVjdGluZy5cbiAgICAgKi9cbiAgICBpZiAoIW5vZGUuaXNQcm9qZWN0aW5nKCkpIHtcbiAgICAgICAgbm9kZS5pc1Byb2plY3Rpb25EaXJ0eSA9IG5vZGUucGFyZW50LmlzUHJvamVjdGlvbkRpcnR5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9wYWdhdGUgaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgYW5kIGlzVHJhbnNmb3JtRGlydHlcbiAgICAgKiB0aHJvdWdob3V0IHRoZSB3aG9sZSB0cmVlLiBBIGZ1dHVyZSByZXZpc2lvbiBjYW4gdGFrZSBhbm90aGVyIGxvb2sgYXRcbiAgICAgKiB0aGlzIGJ1dCBmb3Igc2FmZXR5IHdlIHN0aWxsIHJlY2FsY3VhbHRlIHNoYXJlZCBub2Rlcy5cbiAgICAgKi9cbiAgICBub2RlLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IHx8IChub2RlLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID0gQm9vbGVhbihub2RlLmlzUHJvamVjdGlvbkRpcnR5IHx8XG4gICAgICAgIG5vZGUucGFyZW50LmlzUHJvamVjdGlvbkRpcnR5IHx8XG4gICAgICAgIG5vZGUucGFyZW50LmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5KSk7XG4gICAgbm9kZS5pc1RyYW5zZm9ybURpcnR5IHx8IChub2RlLmlzVHJhbnNmb3JtRGlydHkgPSBub2RlLnBhcmVudC5pc1RyYW5zZm9ybURpcnR5KTtcbn1cbmZ1bmN0aW9uIGNsZWFuRGlydHlOb2Rlcyhub2RlKSB7XG4gICAgbm9kZS5pc1Byb2plY3Rpb25EaXJ0eSA9XG4gICAgICAgIG5vZGUuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgPVxuICAgICAgICAgICAgbm9kZS5pc1RyYW5zZm9ybURpcnR5ID1cbiAgICAgICAgICAgICAgICBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNsZWFyU25hcHNob3Qobm9kZSkge1xuICAgIG5vZGUuY2xlYXJTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gY2xlYXJNZWFzdXJlbWVudHMobm9kZSkge1xuICAgIG5vZGUuY2xlYXJNZWFzdXJlbWVudHMoKTtcbn1cbmZ1bmN0aW9uIGNsZWFySXNMYXlvdXREaXJ0eShub2RlKSB7XG4gICAgbm9kZS5pc0xheW91dERpcnR5ID0gZmFsc2U7XG59XG5mdW5jdGlvbiByZXNldFRyYW5zZm9ybVN0eWxlKG5vZGUpIHtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IG5vZGUub3B0aW9ucztcbiAgICBpZiAodmlzdWFsRWxlbWVudCAmJiB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkub25CZWZvcmVMYXlvdXRNZWFzdXJlKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiKTtcbiAgICB9XG4gICAgbm9kZS5yZXNldFRyYW5zZm9ybSgpO1xufVxuZnVuY3Rpb24gZmluaXNoQW5pbWF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmZpbmlzaEFuaW1hdGlvbigpO1xuICAgIG5vZGUudGFyZ2V0RGVsdGEgPSBub2RlLnJlbGF0aXZlVGFyZ2V0ID0gbm9kZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgbm9kZS5pc1Byb2plY3Rpb25EaXJ0eSA9IHRydWU7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0RGVsdGEobm9kZSkge1xuICAgIG5vZGUucmVzb2x2ZVRhcmdldERlbHRhKCk7XG59XG5mdW5jdGlvbiBjYWxjUHJvamVjdGlvbihub2RlKSB7XG4gICAgbm9kZS5jYWxjUHJvamVjdGlvbigpO1xufVxuZnVuY3Rpb24gcmVzZXRTa2V3QW5kUm90YXRpb24obm9kZSkge1xuICAgIG5vZGUucmVzZXRTa2V3QW5kUm90YXRpb24oKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxlYWRTbmFwc2hvdHMoc3RhY2spIHtcbiAgICBzdGFjay5yZW1vdmVMZWFkU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIG1peEF4aXNEZWx0YShvdXRwdXQsIGRlbHRhLCBwKSB7XG4gICAgb3V0cHV0LnRyYW5zbGF0ZSA9IG1peE51bWJlcihkZWx0YS50cmFuc2xhdGUsIDAsIHApO1xuICAgIG91dHB1dC5zY2FsZSA9IG1peE51bWJlcihkZWx0YS5zY2FsZSwgMSwgcCk7XG4gICAgb3V0cHV0Lm9yaWdpbiA9IGRlbHRhLm9yaWdpbjtcbiAgICBvdXRwdXQub3JpZ2luUG9pbnQgPSBkZWx0YS5vcmlnaW5Qb2ludDtcbn1cbmZ1bmN0aW9uIG1peEF4aXMob3V0cHV0LCBmcm9tLCB0bywgcCkge1xuICAgIG91dHB1dC5taW4gPSBtaXhOdW1iZXIoZnJvbS5taW4sIHRvLm1pbiwgcCk7XG4gICAgb3V0cHV0Lm1heCA9IG1peE51bWJlcihmcm9tLm1heCwgdG8ubWF4LCBwKTtcbn1cbmZ1bmN0aW9uIG1peEJveChvdXRwdXQsIGZyb20sIHRvLCBwKSB7XG4gICAgbWl4QXhpcyhvdXRwdXQueCwgZnJvbS54LCB0by54LCBwKTtcbiAgICBtaXhBeGlzKG91dHB1dC55LCBmcm9tLnksIHRvLnksIHApO1xufVxuZnVuY3Rpb24gaGFzT3BhY2l0eUNyb3NzZmFkZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLmFuaW1hdGlvblZhbHVlcyAmJiBub2RlLmFuaW1hdGlvblZhbHVlcy5vcGFjaXR5RXhpdCAhPT0gdW5kZWZpbmVkKTtcbn1cbmNvbnN0IGRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uID0ge1xuICAgIGR1cmF0aW9uOiAwLjQ1LFxuICAgIGVhc2U6IFswLjQsIDAsIDAuMSwgMV0sXG59O1xuY29uc3QgdXNlckFnZW50Q29udGFpbnMgPSAoc3RyaW5nKSA9PiB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzdHJpbmcpO1xuLyoqXG4gKiBNZWFzdXJlZCBib3VuZGluZyBib3hlcyBtdXN0IGJlIHJvdW5kZWQgaW4gU2FmYXJpIGFuZFxuICogbGVmdCB1bnRvdWNoZWQgaW4gQ2hyb21lLCBvdGhlcndpc2Ugbm9uLWludGVnZXIgbGF5b3V0cyB3aXRoaW4gc2NhbGVkLXVwIGVsZW1lbnRzXG4gKiBjYW4gYXBwZWFyIHRvIGp1bXAuXG4gKi9cbmNvbnN0IHJvdW5kUG9pbnQgPSB1c2VyQWdlbnRDb250YWlucyhcImFwcGxld2Via2l0L1wiKSAmJiAhdXNlckFnZW50Q29udGFpbnMoXCJjaHJvbWUvXCIpXG4gICAgPyBNYXRoLnJvdW5kXG4gICAgOiBub29wO1xuZnVuY3Rpb24gcm91bmRBeGlzKGF4aXMpIHtcbiAgICAvLyBSb3VuZCB0byB0aGUgbmVhcmVzdCAuNSBwaXhlbHMgdG8gc3VwcG9ydCBzdWJwaXhlbCBsYXlvdXRzXG4gICAgYXhpcy5taW4gPSByb3VuZFBvaW50KGF4aXMubWluKTtcbiAgICBheGlzLm1heCA9IHJvdW5kUG9pbnQoYXhpcy5tYXgpO1xufVxuZnVuY3Rpb24gcm91bmRCb3goYm94KSB7XG4gICAgcm91bmRBeGlzKGJveC54KTtcbiAgICByb3VuZEF4aXMoYm94LnkpO1xufVxuZnVuY3Rpb24gc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seShhbmltYXRpb25UeXBlLCBzbmFwc2hvdCwgbGF5b3V0KSB7XG4gICAgcmV0dXJuIChhbmltYXRpb25UeXBlID09PSBcInBvc2l0aW9uXCIgfHxcbiAgICAgICAgKGFuaW1hdGlvblR5cGUgPT09IFwicHJlc2VydmUtYXNwZWN0XCIgJiZcbiAgICAgICAgICAgICFpc05lYXIoYXNwZWN0UmF0aW8oc25hcHNob3QpLCBhc3BlY3RSYXRpbyhsYXlvdXQpLCAwLjIpKSk7XG59XG5mdW5jdGlvbiBjaGVja05vZGVXYXNTY3JvbGxSb290KG5vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIG5vZGUgIT09IG5vZGUucm9vdCAmJiAoKF9hID0gbm9kZS5zY3JvbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YXNSb290KTtcbn1cblxuZXhwb3J0IHsgY2xlYW5EaXJ0eU5vZGVzLCBjcmVhdGVQcm9qZWN0aW9uTm9kZSwgbWl4QXhpcywgbWl4QXhpc0RlbHRhLCBtaXhCb3gsIHByb3BhZ2F0ZURpcnR5Tm9kZXMgfTtcbiIsImltcG9ydCB7IGNyZWF0ZVByb2plY3Rpb25Ob2RlIH0gZnJvbSAnLi9jcmVhdGUtcHJvamVjdGlvbi1ub2RlLm1qcyc7XG5pbXBvcnQgeyBhZGREb21FdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50cy9hZGQtZG9tLWV2ZW50Lm1qcyc7XG5cbmNvbnN0IERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gICAgYXR0YWNoUmVzaXplTGlzdGVuZXI6IChyZWYsIG5vdGlmeSkgPT4gYWRkRG9tRXZlbnQocmVmLCBcInJlc2l6ZVwiLCBub3RpZnkpLFxuICAgIG1lYXN1cmVTY3JvbGw6ICgpID0+ICh7XG4gICAgICAgIHg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICB9KSxcbiAgICBjaGVja0lzU2Nyb2xsUm9vdDogKCkgPT4gdHJ1ZSxcbn0pO1xuXG5leHBvcnQgeyBEb2N1bWVudFByb2plY3Rpb25Ob2RlIH07XG4iLCJpbXBvcnQgeyBjcmVhdGVQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vY3JlYXRlLXByb2plY3Rpb24tbm9kZS5tanMnO1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vRG9jdW1lbnRQcm9qZWN0aW9uTm9kZS5tanMnO1xuXG5jb25zdCByb290UHJvamVjdGlvbk5vZGUgPSB7XG4gICAgY3VycmVudDogdW5kZWZpbmVkLFxufTtcbmNvbnN0IEhUTUxQcm9qZWN0aW9uTm9kZSA9IGNyZWF0ZVByb2plY3Rpb25Ob2RlKHtcbiAgICBtZWFzdXJlU2Nyb2xsOiAoaW5zdGFuY2UpID0+ICh7XG4gICAgICAgIHg6IGluc3RhbmNlLnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGluc3RhbmNlLnNjcm9sbFRvcCxcbiAgICB9KSxcbiAgICBkZWZhdWx0UGFyZW50OiAoKSA9PiB7XG4gICAgICAgIGlmICghcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50Tm9kZSA9IG5ldyBEb2N1bWVudFByb2plY3Rpb25Ob2RlKHt9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5tb3VudCh3aW5kb3cpO1xuICAgICAgICAgICAgZG9jdW1lbnROb2RlLnNldE9wdGlvbnMoeyBsYXlvdXRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudCA9IGRvY3VtZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQ7XG4gICAgfSxcbiAgICByZXNldFRyYW5zZm9ybTogKGluc3RhbmNlLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgICB9LFxuICAgIGNoZWNrSXNTY3JvbGxSb290OiAoaW5zdGFuY2UpID0+IEJvb2xlYW4od2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5zdGFuY2UpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpLFxufSk7XG5cbmV4cG9ydCB7IEhUTUxQcm9qZWN0aW9uTm9kZSwgcm9vdFByb2plY3Rpb25Ob2RlIH07XG4iLCJpbXBvcnQgeyBEcmFnR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL2RyYWcvaW5kZXgubWpzJztcbmltcG9ydCB7IFBhbkdlc3R1cmUgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy9wYW4vaW5kZXgubWpzJztcbmltcG9ydCB7IE1lYXN1cmVMYXlvdXQgfSBmcm9tICcuL2xheW91dC9NZWFzdXJlTGF5b3V0Lm1qcyc7XG5pbXBvcnQgeyBIVE1MUHJvamVjdGlvbk5vZGUgfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL25vZGUvSFRNTFByb2plY3Rpb25Ob2RlLm1qcyc7XG5cbmNvbnN0IGRyYWcgPSB7XG4gICAgcGFuOiB7XG4gICAgICAgIEZlYXR1cmU6IFBhbkdlc3R1cmUsXG4gICAgfSxcbiAgICBkcmFnOiB7XG4gICAgICAgIEZlYXR1cmU6IERyYWdHZXN0dXJlLFxuICAgICAgICBQcm9qZWN0aW9uTm9kZTogSFRNTFByb2plY3Rpb25Ob2RlLFxuICAgICAgICBNZWFzdXJlTGF5b3V0LFxuICAgIH0sXG59O1xuXG5leHBvcnQgeyBkcmFnIH07XG4iLCJpbXBvcnQgeyBob3ZlciB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgZXh0cmFjdEV2ZW50SW5mbyB9IGZyb20gJy4uL2V2ZW50cy9ldmVudC1pbmZvLm1qcyc7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vbW90aW9uL2ZlYXR1cmVzL0ZlYXR1cmUubWpzJztcbmltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbmZ1bmN0aW9uIGhhbmRsZUhvdmVyRXZlbnQobm9kZSwgZXZlbnQsIGxpZmVjeWNsZSkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XG4gICAgaWYgKG5vZGUuYW5pbWF0aW9uU3RhdGUgJiYgcHJvcHMud2hpbGVIb3Zlcikge1xuICAgICAgICBub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlSG92ZXJcIiwgbGlmZWN5Y2xlID09PSBcIlN0YXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBldmVudE5hbWUgPSAoXCJvbkhvdmVyXCIgKyBsaWZlY3ljbGUpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcHJvcHNbZXZlbnROYW1lXTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBjYWxsYmFjayhldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpKTtcbiAgICB9XG59XG5jbGFzcyBIb3Zlckdlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmICghY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy51bm1vdW50ID0gaG92ZXIoY3VycmVudCwgKF9lbGVtZW50LCBzdGFydEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVIb3ZlckV2ZW50KHRoaXMubm9kZSwgc3RhcnRFdmVudCwgXCJTdGFydFwiKTtcbiAgICAgICAgICAgIHJldHVybiAoZW5kRXZlbnQpID0+IGhhbmRsZUhvdmVyRXZlbnQodGhpcy5ub2RlLCBlbmRFdmVudCwgXCJFbmRcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbmV4cG9ydCB7IEhvdmVyR2VzdHVyZSB9O1xuIiwiaW1wb3J0IHsgYWRkRG9tRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvYWRkLWRvbS1ldmVudC5tanMnO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gJy4uL21vdGlvbi9mZWF0dXJlcy9GZWF0dXJlLm1qcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnLi4vdXRpbHMvcGlwZS5tanMnO1xuXG5jbGFzcyBGb2N1c0dlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBvbkZvY3VzKCkge1xuICAgICAgICBsZXQgaXNGb2N1c1Zpc2libGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgZWxlbWVudCBkb2Vzbid0IG1hdGNoIGZvY3VzLXZpc2libGUgdGhlbiBkb24ndFxuICAgICAgICAgKiBhcHBseSB3aGlsZUhvdmVyLiBCdXQsIGlmIG1hdGNoZXMgdGhyb3dzIHRoYXQgZm9jdXMtdmlzaWJsZVxuICAgICAgICAgKiBpcyBub3QgYSB2YWxpZCBzZWxlY3RvciB0aGVuIGluIHRoYXQgYnJvd3NlciBvdXRsaW5lIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgICogdG8gdGhlIGVsZW1lbnQgYnkgZGVmYXVsdCBhbmQgd2Ugd2FudCB0byBtYXRjaCB0aGF0IGJlaGF2aW91ciB3aXRoIHdoaWxlRm9jdXMuXG4gICAgICAgICAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNGb2N1c1Zpc2libGUgPSB0aGlzLm5vZGUuY3VycmVudC5tYXRjaGVzKFwiOmZvY3VzLXZpc2libGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlzRm9jdXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRm9jdXNWaXNpYmxlIHx8ICF0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZUZvY3VzXCIsIHRydWUpO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgb25CbHVyKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgIXRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRm9jdXNcIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnVubW91bnQgPSBwaXBlKGFkZERvbUV2ZW50KHRoaXMubm9kZS5jdXJyZW50LCBcImZvY3VzXCIsICgpID0+IHRoaXMub25Gb2N1cygpKSwgYWRkRG9tRXZlbnQodGhpcy5ub2RlLmN1cnJlbnQsIFwiYmx1clwiLCAoKSA9PiB0aGlzLm9uQmx1cigpKSk7XG4gICAgfVxuICAgIHVubW91bnQoKSB7IH1cbn1cblxuZXhwb3J0IHsgRm9jdXNHZXN0dXJlIH07XG4iLCJpbXBvcnQgeyBwcmVzcyB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgZXh0cmFjdEV2ZW50SW5mbyB9IGZyb20gJy4uL2V2ZW50cy9ldmVudC1pbmZvLm1qcyc7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vbW90aW9uL2ZlYXR1cmVzL0ZlYXR1cmUubWpzJztcbmltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbmZ1bmN0aW9uIGhhbmRsZVByZXNzRXZlbnQobm9kZSwgZXZlbnQsIGxpZmVjeWNsZSkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XG4gICAgaWYgKG5vZGUuYW5pbWF0aW9uU3RhdGUgJiYgcHJvcHMud2hpbGVUYXApIHtcbiAgICAgICAgbm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZVRhcFwiLCBsaWZlY3ljbGUgPT09IFwiU3RhcnRcIik7XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50TmFtZSA9IChcIm9uVGFwXCIgKyAobGlmZWN5Y2xlID09PSBcIkVuZFwiID8gXCJcIiA6IGxpZmVjeWNsZSkpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcHJvcHNbZXZlbnROYW1lXTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBjYWxsYmFjayhldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpKTtcbiAgICB9XG59XG5jbGFzcyBQcmVzc0dlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmICghY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy51bm1vdW50ID0gcHJlc3MoY3VycmVudCwgKF9lbGVtZW50LCBzdGFydEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVQcmVzc0V2ZW50KHRoaXMubm9kZSwgc3RhcnRFdmVudCwgXCJTdGFydFwiKTtcbiAgICAgICAgICAgIHJldHVybiAoZW5kRXZlbnQsIHsgc3VjY2VzcyB9KSA9PiBoYW5kbGVQcmVzc0V2ZW50KHRoaXMubm9kZSwgZW5kRXZlbnQsIHN1Y2Nlc3MgPyBcIkVuZFwiIDogXCJDYW5jZWxcIik7XG4gICAgICAgIH0sIHsgdXNlR2xvYmFsVGFyZ2V0OiB0aGlzLm5vZGUucHJvcHMuZ2xvYmFsVGFwVGFyZ2V0IH0pO1xuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbmV4cG9ydCB7IFByZXNzR2VzdHVyZSB9O1xuIiwiLyoqXG4gKiBNYXAgYW4gSW50ZXJzZWN0aW9uSGFuZGxlciBjYWxsYmFjayB0byBhbiBlbGVtZW50LiBXZSBvbmx5IGV2ZXIgbWFrZSBvbmUgaGFuZGxlciBmb3Igb25lXG4gKiBlbGVtZW50LCBzbyBldmVuIHRob3VnaCB0aGVzZSBoYW5kbGVycyBtaWdodCBhbGwgYmUgdHJpZ2dlcmVkIGJ5IGRpZmZlcmVudFxuICogb2JzZXJ2ZXJzLCB3ZSBjYW4ga2VlcCB0aGVtIGluIHRoZSBzYW1lIG1hcC5cbiAqL1xuY29uc3Qgb2JzZXJ2ZXJDYWxsYmFja3MgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBNdWx0aXBsZSBvYnNlcnZlcnMgY2FuIGJlIGNyZWF0ZWQgZm9yIG11bHRpcGxlIGVsZW1lbnQvZG9jdW1lbnQgcm9vdHMuIEVhY2ggd2l0aFxuICogZGlmZmVyZW50IHNldHRpbmdzLiBTbyBoZXJlIHdlIHN0b3JlIGRpY3Rpb25hcmllcyBvZiBvYnNlcnZlcnMgdG8gZWFjaCByb290LFxuICogdXNpbmcgc2VyaWFsaXNlZCBzZXR0aW5ncyAodGhyZXNob2xkL21hcmdpbikgYXMgbG9va3VwIGtleXMuXG4gKi9cbmNvbnN0IG9ic2VydmVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBmaXJlT2JzZXJ2ZXJDYWxsYmFjayA9IChlbnRyeSkgPT4ge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gb2JzZXJ2ZXJDYWxsYmFja3MuZ2V0KGVudHJ5LnRhcmdldCk7XG4gICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW50cnkpO1xufTtcbmNvbnN0IGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcyA9IChlbnRyaWVzKSA9PiB7XG4gICAgZW50cmllcy5mb3JFYWNoKGZpcmVPYnNlcnZlckNhbGxiYWNrKTtcbn07XG5mdW5jdGlvbiBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoeyByb290LCAuLi5vcHRpb25zIH0pIHtcbiAgICBjb25zdCBsb29rdXBSb290ID0gcm9vdCB8fCBkb2N1bWVudDtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGxvb2t1cCBtYXAgZm9yIHRoaXMgcm9vdCwgY3JlYXRlIG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIW9ic2VydmVycy5oYXMobG9va3VwUm9vdCkpIHtcbiAgICAgICAgb2JzZXJ2ZXJzLnNldChsb29rdXBSb290LCB7fSk7XG4gICAgfVxuICAgIGNvbnN0IHJvb3RPYnNlcnZlcnMgPSBvYnNlcnZlcnMuZ2V0KGxvb2t1cFJvb3QpO1xuICAgIGNvbnN0IGtleSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgYW4gb2JzZXJ2ZXIgZm9yIHRoaXMgY29tYmluYXRpb24gb2Ygcm9vdCBhbmQgc2V0dGluZ3MsXG4gICAgICogY3JlYXRlIG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIXJvb3RPYnNlcnZlcnNba2V5XSkge1xuICAgICAgICByb290T2JzZXJ2ZXJzW2tleV0gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzLCB7IHJvb3QsIC4uLm9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHJldHVybiByb290T2JzZXJ2ZXJzW2tleV07XG59XG5mdW5jdGlvbiBvYnNlcnZlSW50ZXJzZWN0aW9uKGVsZW1lbnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlciA9IGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihvcHRpb25zKTtcbiAgICBvYnNlcnZlckNhbGxiYWNrcy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBvYnNlcnZlckNhbGxiYWNrcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG9ic2VydmVJbnRlcnNlY3Rpb24gfTtcbiIsImltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuLi9GZWF0dXJlLm1qcyc7XG5pbXBvcnQgeyBvYnNlcnZlSW50ZXJzZWN0aW9uIH0gZnJvbSAnLi9vYnNlcnZlcnMubWpzJztcblxuY29uc3QgdGhyZXNob2xkTmFtZXMgPSB7XG4gICAgc29tZTogMCxcbiAgICBhbGw6IDEsXG59O1xuY2xhc3MgSW5WaWV3RmVhdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc0VudGVyZWRWaWV3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJblZpZXcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRPYnNlcnZlcigpIHtcbiAgICAgICAgdGhpcy51bm1vdW50KCk7XG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnQgPSB7fSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgbWFyZ2luOiByb290TWFyZ2luLCBhbW91bnQgPSBcInNvbWVcIiwgb25jZSB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiByb290ID8gcm9vdC5jdXJyZW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgICAgIHRocmVzaG9sZDogdHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIiA/IGFtb3VudCA6IHRocmVzaG9sZE5hbWVzW2Ftb3VudF0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uSW50ZXJzZWN0aW9uVXBkYXRlID0gKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlzSW50ZXJzZWN0aW5nIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUncyBiZWVuIG5vIGNoYW5nZSBpbiB0aGUgdmlld3BvcnQgc3RhdGUsIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNJblZpZXcgPSBpc0ludGVyc2VjdGluZztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlIGhhc0VudGVyZWRWaWV3LiBJZiB0aGlzIGlzIG9ubHkgbWVhbnQgdG8gcnVuIG9uY2UsIGFuZFxuICAgICAgICAgICAgICogZWxlbWVudCBpc24ndCB2aXNpYmxlLCBlYXJseSByZXR1cm4uIE90aGVyd2lzZSBzZXQgaGFzRW50ZXJlZFZpZXcgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG9uY2UgJiYgIWlzSW50ZXJzZWN0aW5nICYmIHRoaXMuaGFzRW50ZXJlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZUluVmlld1wiLCBpc0ludGVyc2VjdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBwcm9wcyByYXRoZXIgdGhhbiB0aGUgb25lcyBpbiBzY29wZVxuICAgICAgICAgICAgICogd2hlbiB0aGlzIG9ic2VydmVyIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0RW50ZXIsIG9uVmlld3BvcnRMZWF2ZSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGlzSW50ZXJzZWN0aW5nID8gb25WaWV3cG9ydEVudGVyIDogb25WaWV3cG9ydExlYXZlO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW50cnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZUludGVyc2VjdGlvbih0aGlzLm5vZGUuY3VycmVudCwgb3B0aW9ucywgb25JbnRlcnNlY3Rpb25VcGRhdGUpO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zdGFydE9ic2VydmVyKCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgcHJldlByb3BzIH0gPSB0aGlzLm5vZGU7XG4gICAgICAgIGNvbnN0IGhhc09wdGlvbnNDaGFuZ2VkID0gW1wiYW1vdW50XCIsIFwibWFyZ2luXCIsIFwicm9vdFwiXS5zb21lKGhhc1ZpZXdwb3J0T3B0aW9uQ2hhbmdlZChwcm9wcywgcHJldlByb3BzKSk7XG4gICAgICAgIGlmIChoYXNPcHRpb25zQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydE9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudCgpIHsgfVxufVxuZnVuY3Rpb24gaGFzVmlld3BvcnRPcHRpb25DaGFuZ2VkKHsgdmlld3BvcnQgPSB7fSB9LCB7IHZpZXdwb3J0OiBwcmV2Vmlld3BvcnQgPSB7fSB9ID0ge30pIHtcbiAgICByZXR1cm4gKG5hbWUpID0+IHZpZXdwb3J0W25hbWVdICE9PSBwcmV2Vmlld3BvcnRbbmFtZV07XG59XG5cbmV4cG9ydCB7IEluVmlld0ZlYXR1cmUgfTtcbiIsImltcG9ydCB7IEhvdmVyR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL2hvdmVyLm1qcyc7XG5pbXBvcnQgeyBGb2N1c0dlc3R1cmUgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy9mb2N1cy5tanMnO1xuaW1wb3J0IHsgUHJlc3NHZXN0dXJlIH0gZnJvbSAnLi4vLi4vZ2VzdHVyZXMvcHJlc3MubWpzJztcbmltcG9ydCB7IEluVmlld0ZlYXR1cmUgfSBmcm9tICcuL3ZpZXdwb3J0L2luZGV4Lm1qcyc7XG5cbmNvbnN0IGdlc3R1cmVBbmltYXRpb25zID0ge1xuICAgIGluVmlldzoge1xuICAgICAgICBGZWF0dXJlOiBJblZpZXdGZWF0dXJlLFxuICAgIH0sXG4gICAgdGFwOiB7XG4gICAgICAgIEZlYXR1cmU6IFByZXNzR2VzdHVyZSxcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICAgIEZlYXR1cmU6IEZvY3VzR2VzdHVyZSxcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICAgIEZlYXR1cmU6IEhvdmVyR2VzdHVyZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgZ2VzdHVyZUFuaW1hdGlvbnMgfTtcbiIsImltcG9ydCB7IEhUTUxQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzJztcbmltcG9ydCB7IE1lYXN1cmVMYXlvdXQgfSBmcm9tICcuL2xheW91dC9NZWFzdXJlTGF5b3V0Lm1qcyc7XG5cbmNvbnN0IGxheW91dCA9IHtcbiAgICBsYXlvdXQ6IHtcbiAgICAgICAgUHJvamVjdGlvbk5vZGU6IEhUTUxQcm9qZWN0aW9uTm9kZSxcbiAgICAgICAgTWVhc3VyZUxheW91dCxcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgbGF5b3V0IH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IExhenlDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7IHN0cmljdDogZmFsc2UgfSk7XG5cbmV4cG9ydCB7IExhenlDb250ZXh0IH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBNb3Rpb25Db25maWdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgdHJhbnNmb3JtUGFnZVBvaW50OiAocCkgPT4gcCxcbiAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgcmVkdWNlZE1vdGlvbjogXCJuZXZlclwiLFxufSk7XG5cbmV4cG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfTtcbiIsIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgTW90aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuXG5leHBvcnQgeyBNb3Rpb25Db250ZXh0IH07XG4iLCJpbXBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanMnO1xuaW1wb3J0IHsgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuL2lzLXZhcmlhbnQtbGFiZWwubWpzJztcbmltcG9ydCB7IHZhcmlhbnRQcm9wcyB9IGZyb20gJy4vdmFyaWFudC1wcm9wcy5tanMnO1xuXG5mdW5jdGlvbiBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHtcbiAgICByZXR1cm4gKGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcHMuYW5pbWF0ZSkgfHxcbiAgICAgICAgdmFyaWFudFByb3BzLnNvbWUoKG5hbWUpID0+IGlzVmFyaWFudExhYmVsKHByb3BzW25hbWVdKSkpO1xufVxuZnVuY3Rpb24gaXNWYXJpYW50Tm9kZShwcm9wcykge1xuICAgIHJldHVybiBCb29sZWFuKGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykgfHwgcHJvcHMudmFyaWFudHMpO1xufVxuXG5leHBvcnQgeyBpc0NvbnRyb2xsaW5nVmFyaWFudHMsIGlzVmFyaWFudE5vZGUgfTtcbiIsImltcG9ydCB7IGlzVmFyaWFudExhYmVsIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL2lzLXZhcmlhbnQtbGFiZWwubWpzJztcbmltcG9ydCB7IGlzQ29udHJvbGxpbmdWYXJpYW50cyB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9pcy1jb250cm9sbGluZy12YXJpYW50cy5tanMnO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykpIHtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXRpYWw6IGluaXRpYWwgPT09IGZhbHNlIHx8IGlzVmFyaWFudExhYmVsKGluaXRpYWwpXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbmltYXRlOiBpc1ZhcmlhbnRMYWJlbChhbmltYXRlKSA/IGFuaW1hdGUgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5pbmhlcml0ICE9PSBmYWxzZSA/IGNvbnRleHQgOiB7fTtcbn1cblxuZXhwb3J0IHsgZ2V0Q3VycmVudFRyZWVWYXJpYW50cyB9O1xuIiwiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vdGlvbkNvbnRleHQgfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBnZXRDdXJyZW50VHJlZVZhcmlhbnRzIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5mdW5jdGlvbiB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKSB7XG4gICAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlIH0gPSBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBpbml0aWFsLCBhbmltYXRlIH0pLCBbdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShpbml0aWFsKSwgdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShhbmltYXRlKV0pO1xufVxuZnVuY3Rpb24gdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShwcm9wKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wLmpvaW4oXCIgXCIpIDogcHJvcDtcbn1cblxuZXhwb3J0IHsgdXNlQ3JlYXRlTW90aW9uQ29udGV4dCB9O1xuIiwiY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZXhwb3J0IHsgaXNCcm93c2VyIH07XG4iLCJjb25zdCBmZWF0dXJlUHJvcHMgPSB7XG4gICAgYW5pbWF0aW9uOiBbXG4gICAgICAgIFwiYW5pbWF0ZVwiLFxuICAgICAgICBcInZhcmlhbnRzXCIsXG4gICAgICAgIFwid2hpbGVIb3ZlclwiLFxuICAgICAgICBcIndoaWxlVGFwXCIsXG4gICAgICAgIFwiZXhpdFwiLFxuICAgICAgICBcIndoaWxlSW5WaWV3XCIsXG4gICAgICAgIFwid2hpbGVGb2N1c1wiLFxuICAgICAgICBcIndoaWxlRHJhZ1wiLFxuICAgIF0sXG4gICAgZXhpdDogW1wiZXhpdFwiXSxcbiAgICBkcmFnOiBbXCJkcmFnXCIsIFwiZHJhZ0NvbnRyb2xzXCJdLFxuICAgIGZvY3VzOiBbXCJ3aGlsZUZvY3VzXCJdLFxuICAgIGhvdmVyOiBbXCJ3aGlsZUhvdmVyXCIsIFwib25Ib3ZlclN0YXJ0XCIsIFwib25Ib3ZlckVuZFwiXSxcbiAgICB0YXA6IFtcIndoaWxlVGFwXCIsIFwib25UYXBcIiwgXCJvblRhcFN0YXJ0XCIsIFwib25UYXBDYW5jZWxcIl0sXG4gICAgcGFuOiBbXCJvblBhblwiLCBcIm9uUGFuU3RhcnRcIiwgXCJvblBhblNlc3Npb25TdGFydFwiLCBcIm9uUGFuRW5kXCJdLFxuICAgIGluVmlldzogW1wid2hpbGVJblZpZXdcIiwgXCJvblZpZXdwb3J0RW50ZXJcIiwgXCJvblZpZXdwb3J0TGVhdmVcIl0sXG4gICAgbGF5b3V0OiBbXCJsYXlvdXRcIiwgXCJsYXlvdXRJZFwiXSxcbn07XG5jb25zdCBmZWF0dXJlRGVmaW5pdGlvbnMgPSB7fTtcbmZvciAoY29uc3Qga2V5IGluIGZlYXR1cmVQcm9wcykge1xuICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXldID0ge1xuICAgICAgICBpc0VuYWJsZWQ6IChwcm9wcykgPT4gZmVhdHVyZVByb3BzW2tleV0uc29tZSgobmFtZSkgPT4gISFwcm9wc1tuYW1lXSksXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgZmVhdHVyZURlZmluaXRpb25zIH07XG4iLCJpbXBvcnQgeyBmZWF0dXJlRGVmaW5pdGlvbnMgfSBmcm9tICcuL2RlZmluaXRpb25zLm1qcyc7XG5cbmZ1bmN0aW9uIGxvYWRGZWF0dXJlcyhmZWF0dXJlcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZlYXR1cmVzKSB7XG4gICAgICAgIGZlYXR1cmVEZWZpbml0aW9uc1trZXldID0ge1xuICAgICAgICAgICAgLi4uZmVhdHVyZURlZmluaXRpb25zW2tleV0sXG4gICAgICAgICAgICAuLi5mZWF0dXJlc1trZXldLFxuICAgICAgICB9O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgbG9hZEZlYXR1cmVzIH07XG4iLCJjb25zdCBtb3Rpb25Db21wb25lbnRTeW1ib2wgPSBTeW1ib2wuZm9yKFwibW90aW9uQ29tcG9uZW50U3ltYm9sXCIpO1xuXG5leHBvcnQgeyBtb3Rpb25Db21wb25lbnRTeW1ib2wgfTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNSZWZPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlZiBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaHlkcmF0ZXMgdGhlIHByb3ZpZGVkXG4gKiBleHRlcm5hbCByZWYgYW5kIFZpc3VhbEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmlzdWFsU3RhdGUub25Nb3VudCAmJiB2aXN1YWxTdGF0ZS5vbk1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50LnVubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZXJuYWxSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmT2JqZWN0KGV4dGVybmFsUmVmKSkge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFxuICAgIC8qKlxuICAgICAqIE9ubHkgcGFzcyBhIG5ldyByZWYgY2FsbGJhY2sgdG8gUmVhY3QgaWYgd2UndmUgcmVjZWl2ZWQgYSB2aXN1YWwgZWxlbWVudFxuICAgICAqIGZhY3RvcnkuIE90aGVyd2lzZSB3ZSdsbCBiZSBtb3VudGluZy9yZW1vdW50aW5nIGV2ZXJ5IHRpbWUgZXh0ZXJuYWxSZWZcbiAgICAgKiBvciBvdGhlciBkZXBlbmRlbmNpZXMgY2hhbmdlLlxuICAgICAqL1xuICAgIFt2aXN1YWxFbGVtZW50XSk7XG59XG5cbmV4cG9ydCB7IHVzZU1vdGlvblJlZiB9O1xuIiwiaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuL2lzLWJyb3dzZXIubWpzJztcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZXhwb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9O1xuIiwiaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VJbnNlcnRpb25FZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyBMYXp5Q29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvTGF6eUNvbnRleHQubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmltcG9ydCB7IG9wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vb3B0aW1pemVkLWFwcGVhci9kYXRhLWlkLm1qcyc7XG5pbXBvcnQgeyBtaWNyb3Rhc2sgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvbWljcm90YXNrLm1qcyc7XG5pbXBvcnQgeyBpc1JlZk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzJztcbmltcG9ydCB7IFN3aXRjaExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0Lm1qcyc7XG5cbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgcHJvcHMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudDogcGFyZW50IH0gPSB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IGxhenlDb250ZXh0ID0gdXNlQ29udGV4dChMYXp5Q29udGV4dCk7XG4gICAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gdXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIGNvbnN0IHJlZHVjZWRNb3Rpb25Db25maWcgPSB1c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLnJlZHVjZWRNb3Rpb247XG4gICAgY29uc3QgdmlzdWFsRWxlbWVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlbid0IHByZWxvYWRlZCBhIHJlbmRlcmVyLCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBvbmUgbGF6eS1sb2FkZWRcbiAgICAgKi9cbiAgICBjcmVhdGVWaXN1YWxFbGVtZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudCB8fCBsYXp5Q29udGV4dC5yZW5kZXJlcjtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCAmJiBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCA9IGNyZWF0ZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICB2aXN1YWxTdGF0ZSxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgcHJlc2VuY2VDb250ZXh0LFxuICAgICAgICAgICAgYmxvY2tJbml0aWFsQW5pbWF0aW9uOiBwcmVzZW5jZUNvbnRleHRcbiAgICAgICAgICAgICAgICA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICByZWR1Y2VkTW90aW9uQ29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAvKipcbiAgICAgKiBMb2FkIE1vdGlvbiBnZXN0dXJlIGFuZCBhbmltYXRpb24gZmVhdHVyZXMuIFRoZXNlIGFyZSByZW5kZXJlZCBhcyByZW5kZXJsZXNzXG4gICAgICogY29tcG9uZW50cyBzbyBlYWNoIGZlYXR1cmUgY2FuIG9wdGlvbmFsbHkgbWFrZSB1c2Ugb2YgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMuXG4gICAgICovXG4gICAgY29uc3QgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnID0gdXNlQ29udGV4dChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIGlmICh2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICF2aXN1YWxFbGVtZW50LnByb2plY3Rpb24gJiZcbiAgICAgICAgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciAmJlxuICAgICAgICAodmlzdWFsRWxlbWVudC50eXBlID09PSBcImh0bWxcIiB8fCB2aXN1YWxFbGVtZW50LnR5cGUgPT09IFwic3ZnXCIpKSB7XG4gICAgICAgIGNyZWF0ZVByb2plY3Rpb25Ob2RlKHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCwgcHJvcHMsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHRoZSBjb21wb25lbnQgaGFzIGFscmVhZHkgbW91bnRlZCBiZWZvcmUgY2FsbGluZ1xuICAgICAgICAgKiBgdXBkYXRlYCB1bm5lY2Vzc2FyaWx5LiBUaGlzIGVuc3VyZXMgd2Ugc2tpcCB0aGUgaW5pdGlhbCB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiBpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC51cGRhdGUocHJvcHMsIHByZXNlbmNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGlzIHZhbHVlIGFzIHdlIHdhbnQgdG8ga25vdyB3aGV0aGVyIEhhbmRvZmZBcHBlYXJBbmltYXRpb25zXG4gICAgICogd2FzIHByZXNlbnQgb24gaW5pdGlhbCByZW5kZXIgLSBpdCB3aWxsIGJlIGRlbGV0ZWQgYWZ0ZXIgdGhpcy5cbiAgICAgKi9cbiAgICBjb25zdCBvcHRpbWlzZWRBcHBlYXJJZCA9IHByb3BzW29wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGVdO1xuICAgIGNvbnN0IHdhbnRzSGFuZG9mZiA9IHVzZVJlZihCb29sZWFuKG9wdGltaXNlZEFwcGVhcklkKSAmJlxuICAgICAgICAhKChfYSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmSXNDb21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBvcHRpbWlzZWRBcHBlYXJJZCkpICYmXG4gICAgICAgICgoX2IgPSB3aW5kb3cuTW90aW9uSGFzT3B0aW1pc2VkQW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh3aW5kb3csIG9wdGltaXNlZEFwcGVhcklkKSkpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgd2luZG93Lk1vdGlvbklzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQudXBkYXRlRmVhdHVyZXMoKTtcbiAgICAgICAgbWljcm90YXNrLnJlbmRlcih2aXN1YWxFbGVtZW50LnJlbmRlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHRoaXMgZnVuY3Rpb24gd291bGQgYWx3YXlzIHJ1biBpbiBhIHVzZUVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnMgdG8gaGFuZG9mZiBmcm9tLFxuICAgICAgICAgKiBpdCBuZWVkcyB0byBoYXBwZW4gc3luY2hyb25vdXNseSB0byBlbnN1cmUgdGhlcmUncyBubyBmbGFzaCBvZlxuICAgICAgICAgKiBpbmNvcnJlY3Qgc3R5bGVzIGluIHRoZSBldmVudCBvZiBhIGh5ZHJhdGlvbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogU28gaWYgd2UgZGV0ZWN0IGEgc2l0dXRhdGlvbiB3aGVyZSBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnNcbiAgICAgICAgICogYXJlIHJ1bm5pbmcsIHdlIHVzZSB1c2VMYXlvdXRFZmZlY3QgdG8gdHJpZ2dlciBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHdhbnRzSGFuZG9mZi5jdXJyZW50ICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuYW5pbWF0ZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF3YW50c0hhbmRvZmYuY3VycmVudCAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLmFuaW1hdGVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhbnRzSGFuZG9mZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgYWxsIGZ1dHVyZSBjYWxscyB0byBhbmltYXRlQ2hhbmdlcygpIGluIHRoaXMgY29tcG9uZW50IHdpbGwgcnVuIGluIHVzZUVmZmVjdFxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB3aW5kb3cuTW90aW9uSGFuZG9mZk1hcmtBc0NvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3aW5kb3csIG9wdGltaXNlZEFwcGVhcklkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2FudHNIYW5kb2ZmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUodmlzdWFsRWxlbWVudCwgcHJvcHMsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIGluaXRpYWxQcm9tb3Rpb25Db25maWcpIHtcbiAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQsIGRyYWcsIGRyYWdDb25zdHJhaW50cywgbGF5b3V0U2Nyb2xsLCBsYXlvdXRSb290LCB9ID0gcHJvcHM7XG4gICAgdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IodmlzdWFsRWxlbWVudC5sYXRlc3RWYWx1ZXMsIHByb3BzW1wiZGF0YS1mcmFtZXItcG9ydGFsLWlkXCJdXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZ2V0Q2xvc2VzdFByb2plY3RpbmdOb2RlKHZpc3VhbEVsZW1lbnQucGFyZW50KSk7XG4gICAgdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnNldE9wdGlvbnMoe1xuICAgICAgICBsYXlvdXRJZCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBhbHdheXNNZWFzdXJlTGF5b3V0OiBCb29sZWFuKGRyYWcpIHx8IChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSksXG4gICAgICAgIHZpc3VhbEVsZW1lbnQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBVcGRhdGUgb3B0aW9ucyBpbiBhbiBlZmZlY3QuIFRoaXMgY291bGQgYmUgdHJpY2t5IGFzIGl0J2xsIGJlIHRvbyBsYXRlXG4gICAgICAgICAqIHRvIHVwZGF0ZSBieSB0aGUgdGltZSBsYXlvdXQgYW5pbWF0aW9ucyBydW4uXG4gICAgICAgICAqIFdlIGFsc28gbmVlZCB0byBmaXggdGhpcyBzYWZlVG9SZW1vdmUgYnkgbGlua2luZyBpdCB1cCB0byB0aGUgb25lIHJldHVybmVkIGJ5IHVzZVByZXNlbmNlLFxuICAgICAgICAgKiBlbnN1cmluZyBpdCBnZXRzIGNhbGxlZCBpZiB0aGVyZSdzIG5vIHBvdGVudGlhbCBsYXlvdXQgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IHR5cGVvZiBsYXlvdXQgPT09IFwic3RyaW5nXCIgPyBsYXlvdXQgOiBcImJvdGhcIixcbiAgICAgICAgaW5pdGlhbFByb21vdGlvbkNvbmZpZyxcbiAgICAgICAgbGF5b3V0U2Nyb2xsLFxuICAgICAgICBsYXlvdXRSb290LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFByb2plY3RpbmdOb2RlKHZpc3VhbEVsZW1lbnQpIHtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQub3B0aW9ucy5hbGxvd1Byb2plY3Rpb24gIT09IGZhbHNlXG4gICAgICAgID8gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uXG4gICAgICAgIDogZ2V0Q2xvc2VzdFByb2plY3RpbmdOb2RlKHZpc3VhbEVsZW1lbnQucGFyZW50KTtcbn1cblxuZXhwb3J0IHsgdXNlVmlzdWFsRWxlbWVudCB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBqc3hzLCBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB3YXJuaW5nLCBpbnZhcmlhbnQgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvTGF5b3V0R3JvdXBDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBMYXp5Q29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvTGF6eUNvbnRleHQubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbnRleHQvaW5kZXgubWpzJztcbmltcG9ydCB7IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbnRleHQvY3JlYXRlLm1qcyc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuLi91dGlscy9pcy1icm93c2VyLm1qcyc7XG5pbXBvcnQgeyBmZWF0dXJlRGVmaW5pdGlvbnMgfSBmcm9tICcuL2ZlYXR1cmVzL2RlZmluaXRpb25zLm1qcyc7XG5pbXBvcnQgeyBsb2FkRmVhdHVyZXMgfSBmcm9tICcuL2ZlYXR1cmVzL2xvYWQtZmVhdHVyZXMubWpzJztcbmltcG9ydCB7IG1vdGlvbkNvbXBvbmVudFN5bWJvbCB9IGZyb20gJy4vdXRpbHMvc3ltYm9sLm1qcyc7XG5pbXBvcnQgeyB1c2VNb3Rpb25SZWYgfSBmcm9tICcuL3V0aWxzL3VzZS1tb3Rpb24tcmVmLm1qcyc7XG5pbXBvcnQgeyB1c2VWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzJztcblxuLyoqXG4gKiBDcmVhdGUgYSBgbW90aW9uYCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgQ29tcG9uZW50IGFyZ3VtZW50LCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIChpZSBcImRpdlwiXG4gKiBmb3IgYG1vdGlvbi5kaXZgKSwgb3IgYW4gYWN0dWFsIFJlYWN0IGNvbXBvbmVudC5cbiAqXG4gKiBBbG9uZ3NpZGUgdGhpcyBpcyBhIGNvbmZpZyBvcHRpb24gd2hpY2ggcHJvdmlkZXMgYSB3YXkgb2YgcmVuZGVyaW5nIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IFwib2ZmbGluZVwiLCBvciBvdXRzaWRlIHRoZSBSZWFjdCByZW5kZXIgY3ljbGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50KHsgcHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIHVzZVJlbmRlciwgdXNlVmlzdWFsU3RhdGUsIENvbXBvbmVudCwgfSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcHJlbG9hZGVkRmVhdHVyZXMgJiYgbG9hZEZlYXR1cmVzKHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICBmdW5jdGlvbiBNb3Rpb25Db21wb25lbnQocHJvcHMsIGV4dGVybmFsUmVmKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSBuZWVkIHRvIG1lYXN1cmUgdGhlIGVsZW1lbnQgd2UgbG9hZCB0aGlzIGZ1bmN0aW9uYWxpdHkgaW4gYVxuICAgICAgICAgKiBzZXBhcmF0ZSBjbGFzcyBjb21wb25lbnQgaW4gb3JkZXIgdG8gZ2FpbiBhY2Nlc3MgdG8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgTWVhc3VyZUxheW91dDtcbiAgICAgICAgY29uc3QgY29uZmlnQW5kUHJvcHMgPSB7XG4gICAgICAgICAgICAuLi51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLFxuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBsYXlvdXRJZDogdXNlTGF5b3V0SWQocHJvcHMpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGlzU3RhdGljIH0gPSBjb25maWdBbmRQcm9wcztcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpO1xuICAgICAgICBjb25zdCB2aXN1YWxTdGF0ZSA9IHVzZVZpc3VhbFN0YXRlKHByb3BzLCBpc1N0YXRpYyk7XG4gICAgICAgIGlmICghaXNTdGF0aWMgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB1c2VTdHJpY3RNb2RlKGNvbmZpZ0FuZFByb3BzLCBwcmVsb2FkZWRGZWF0dXJlcyk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRQcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbkZ1bmN0aW9uYWxpdHkoY29uZmlnQW5kUHJvcHMpO1xuICAgICAgICAgICAgTWVhc3VyZUxheW91dCA9IGxheW91dFByb2plY3Rpb24uTWVhc3VyZUxheW91dDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGEgVmlzdWFsRWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQuIEEgVmlzdWFsRWxlbWVudCBwcm92aWRlcyBhIGNvbW1vblxuICAgICAgICAgICAgICogaW50ZXJmYWNlIHRvIHJlbmRlcmVyLXNwZWNpZmljIEFQSXMgKGllIERPTS9UaHJlZS5qcyBldGMpIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAqIHByb3ZpZGluZyBhIHdheSBvZiByZW5kZXJpbmcgdG8gdGhlc2UgQVBJcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCByZW5kZXIgbG9vcFxuICAgICAgICAgICAgICogZm9yIG1vcmUgcGVyZm9ybWFudCBhbmltYXRpb25zIGFuZCBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udGV4dC52aXN1YWxFbGVtZW50ID0gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBjb25maWdBbmRQcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgbGF5b3V0UHJvamVjdGlvbi5Qcm9qZWN0aW9uTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3VudCBvcmRlciBhbmQgaGllcmFyY2h5IGlzIHNwZWNpZmljIHRvIGVuc3VyZSBvdXIgZWxlbWVudCByZWZcbiAgICAgICAgICogaXMgaHlkcmF0ZWQgYnkgdGhlIHRpbWUgZmVhdHVyZXMgZmlyZSB0aGVpciBlZmZlY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIChqc3hzKE1vdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBbTWVhc3VyZUxheW91dCAmJiBjb250ZXh0LnZpc3VhbEVsZW1lbnQgPyAoanN4KE1lYXN1cmVMYXlvdXQsIHsgdmlzdWFsRWxlbWVudDogY29udGV4dC52aXN1YWxFbGVtZW50LCAuLi5jb25maWdBbmRQcm9wcyB9KSkgOiBudWxsLCB1c2VSZW5kZXIoQ29tcG9uZW50LCBwcm9wcywgdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIGV4dGVybmFsUmVmKSwgdmlzdWFsU3RhdGUsIGlzU3RhdGljLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQpXSB9KSk7XG4gICAgfVxuICAgIE1vdGlvbkNvbXBvbmVudC5kaXNwbGF5TmFtZSA9IGBtb3Rpb24uJHt0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gQ29tcG9uZW50XG4gICAgICAgIDogYGNyZWF0ZSgkeyhfYiA9IChfYSA9IENvbXBvbmVudC5kaXNwbGF5TmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogQ29tcG9uZW50Lm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFwiXCJ9KWB9YDtcbiAgICBjb25zdCBGb3J3YXJkUmVmTW90aW9uQ29tcG9uZW50ID0gZm9yd2FyZFJlZihNb3Rpb25Db21wb25lbnQpO1xuICAgIEZvcndhcmRSZWZNb3Rpb25Db21wb25lbnRbbW90aW9uQ29tcG9uZW50U3ltYm9sXSA9IENvbXBvbmVudDtcbiAgICByZXR1cm4gRm9yd2FyZFJlZk1vdGlvbkNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dElkKHsgbGF5b3V0SWQgfSkge1xuICAgIGNvbnN0IGxheW91dEdyb3VwSWQgPSB1c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCkuaWQ7XG4gICAgcmV0dXJuIGxheW91dEdyb3VwSWQgJiYgbGF5b3V0SWQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxheW91dEdyb3VwSWQgKyBcIi1cIiArIGxheW91dElkXG4gICAgICAgIDogbGF5b3V0SWQ7XG59XG5mdW5jdGlvbiB1c2VTdHJpY3RNb2RlKGNvbmZpZ0FuZFByb3BzLCBwcmVsb2FkZWRGZWF0dXJlcykge1xuICAgIGNvbnN0IGlzU3RyaWN0ID0gdXNlQ29udGV4dChMYXp5Q29udGV4dCkuc3RyaWN0O1xuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIGluIGRldmVsb3BtZW50IG1vZGUsIGNoZWNrIHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3QgcmVuZGVyaW5nIGEgbW90aW9uIGNvbXBvbmVudFxuICAgICAqIGFzIGEgY2hpbGQgb2YgTGF6eU1vdGlvbiwgYXMgdGhpcyB3aWxsIGJyZWFrIHRoZSBmaWxlLXNpemUgYmVuZWZpdHMgb2YgdXNpbmcgaXQuXG4gICAgICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJlxuICAgICAgICBwcmVsb2FkZWRGZWF0dXJlcyAmJlxuICAgICAgICBpc1N0cmljdCkge1xuICAgICAgICBjb25zdCBzdHJpY3RNZXNzYWdlID0gXCJZb3UgaGF2ZSByZW5kZXJlZCBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoaW4gYSBgTGF6eU1vdGlvbmAgY29tcG9uZW50LiBUaGlzIHdpbGwgYnJlYWsgdHJlZSBzaGFraW5nLiBJbXBvcnQgYW5kIHJlbmRlciBhIGBtYCBjb21wb25lbnQgaW5zdGVhZC5cIjtcbiAgICAgICAgY29uZmlnQW5kUHJvcHMuaWdub3JlU3RyaWN0XG4gICAgICAgICAgICA/IHdhcm5pbmcoZmFsc2UsIHN0cmljdE1lc3NhZ2UpXG4gICAgICAgICAgICA6IGludmFyaWFudChmYWxzZSwgc3RyaWN0TWVzc2FnZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UHJvamVjdGlvbkZ1bmN0aW9uYWxpdHkocHJvcHMpIHtcbiAgICBjb25zdCB7IGRyYWcsIGxheW91dCB9ID0gZmVhdHVyZURlZmluaXRpb25zO1xuICAgIGlmICghZHJhZyAmJiAhbGF5b3V0KVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgY29tYmluZWQgPSB7IC4uLmRyYWcsIC4uLmxheW91dCB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIE1lYXN1cmVMYXlvdXQ6IChkcmFnID09PSBudWxsIHx8IGRyYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWcuaXNFbmFibGVkKHByb3BzKSkgfHwgKGxheW91dCA9PT0gbnVsbCB8fCBsYXlvdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dC5pc0VuYWJsZWQocHJvcHMpKVxuICAgICAgICAgICAgPyBjb21iaW5lZC5NZWFzdXJlTGF5b3V0XG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgUHJvamVjdGlvbk5vZGU6IGNvbWJpbmVkLlByb2plY3Rpb25Ob2RlLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50IH07XG4iLCIvKipcbiAqIFdlIGtlZXAgdGhlc2UgbGlzdGVkIHNlcGFyYXRlbHkgYXMgd2UgdXNlIHRoZSBsb3dlcmNhc2UgdGFnIG5hbWVzIGFzIHBhcnRcbiAqIG9mIHRoZSBydW50aW1lIGJ1bmRsZSB0byBkZXRlY3QgU1ZHIGNvbXBvbmVudHNcbiAqL1xuY29uc3QgbG93ZXJjYXNlU1ZHRWxlbWVudHMgPSBbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJjaXJjbGVcIixcbiAgICBcImRlZnNcIixcbiAgICBcImRlc2NcIixcbiAgICBcImVsbGlwc2VcIixcbiAgICBcImdcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJsaW5lXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcIm1hcmtlclwiLFxuICAgIFwibWFza1wiLFxuICAgIFwibWV0YWRhdGFcIixcbiAgICBcInBhdGhcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcInBvbHlnb25cIixcbiAgICBcInBvbHlsaW5lXCIsXG4gICAgXCJyZWN0XCIsXG4gICAgXCJzdG9wXCIsXG4gICAgXCJzd2l0Y2hcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwic3ZnXCIsXG4gICAgXCJ0ZXh0XCIsXG4gICAgXCJ0c3BhblwiLFxuICAgIFwidXNlXCIsXG4gICAgXCJ2aWV3XCIsXG5dO1xuXG5leHBvcnQgeyBsb3dlcmNhc2VTVkdFbGVtZW50cyB9O1xuIiwiaW1wb3J0IHsgbG93ZXJjYXNlU1ZHRWxlbWVudHMgfSBmcm9tICcuLi8uLi9zdmcvbG93ZXJjYXNlLWVsZW1lbnRzLm1qcyc7XG5cbmZ1bmN0aW9uIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIGlmIChcbiAgICAvKipcbiAgICAgKiBJZiBpdCdzIG5vdCBhIHN0cmluZywgaXQncyBhIGN1c3RvbSBSZWFjdCBjb21wb25lbnQuIEN1cnJlbnRseSB3ZSBvbmx5IHN1cHBvcnRcbiAgICAgKiBIVE1MIGN1c3RvbSBSZWFjdCBjb21wb25lbnRzLlxuICAgICAqL1xuICAgIHR5cGVvZiBDb21wb25lbnQgIT09IFwic3RyaW5nXCIgfHxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGNvbnRhaW5zIGEgZGFzaCwgdGhlIGVsZW1lbnQgaXMgYSBjdXN0b20gSFRNTCB3ZWJjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBDb21wb25lbnQuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoXG4gICAgLyoqXG4gICAgICogSWYgaXQncyBpbiBvdXIgbGlzdCBvZiBsb3dlcmNhc2UgU1ZHIHRhZ3MsIGl0J3MgYW4gU1ZHIGNvbXBvbmVudFxuICAgICAqL1xuICAgIGxvd2VyY2FzZVNWR0VsZW1lbnRzLmluZGV4T2YoQ29tcG9uZW50KSA+IC0xIHx8XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBpdCBjb250YWlucyBhIGNhcGl0YWwgbGV0dGVyLCBpdCdzIGFuIFNWRyBjb21wb25lbnRcbiAgICAgICAgICovXG4gICAgICAgIC9bQS1aXS91LnRlc3QoQ29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgeyBpc1NWR0NvbXBvbmVudCB9O1xuIiwiaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdGFudCB2YWx1ZSBvdmVyIHRoZSBsaWZlY3ljbGUgb2YgYSBjb21wb25lbnQuXG4gKlxuICogRXZlbiBpZiBgdXNlTWVtb2AgaXMgcHJvdmlkZWQgYW4gZW1wdHkgYXJyYXkgYXMgaXRzIGZpbmFsIGFyZ3VtZW50LCBpdCBkb2Vzbid0IG9mZmVyXG4gKiBhIGd1YXJhbnRlZSB0aGF0IGl0IHdvbid0IHJlLXJ1biBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBsYXRlciBvbi4gQnkgdXNpbmcgYHVzZUNvbnN0YW50YFxuICogeW91IGNhbiBlbnN1cmUgdGhhdCBpbml0aWFsaXNlcnMgZG9uJ3QgZXhlY3V0ZSB0d2ljZSBvciBtb3JlLlxuICovXG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGlmIChyZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IGluaXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG5leHBvcnQgeyB1c2VDb25zdGFudCB9O1xuIiwiaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzQW5pbWF0aW9uQ29udHJvbHMgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvaXMtYW5pbWF0aW9uLWNvbnRyb2xzLm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBQcmVzZW5jZUNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L1ByZXNlbmNlQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgaXNDb250cm9sbGluZ1ZhcmlhbnRzLCBpc1ZhcmlhbnROb2RlIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL2lzLWNvbnRyb2xsaW5nLXZhcmlhbnRzLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9yZXNvbHZlLXZhcmlhbnRzLm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvcmVzb2x2ZS1tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gbWFrZVN0YXRlKHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLCBjcmVhdGVSZW5kZXJTdGF0ZSwgb25VcGRhdGUsIH0sIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgbGF0ZXN0VmFsdWVzOiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyksXG4gICAgICAgIHJlbmRlclN0YXRlOiBjcmVhdGVSZW5kZXJTdGF0ZSgpLFxuICAgIH07XG4gICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbk1vdW50IHdvcmtzIHdpdGhvdXQgdGhlIFZpc3VhbEVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZVxuICAgICAgICAgKiBjYWxsZWQgYmVmb3JlIHRoZSBWaXN1YWxFbGVtZW50IHBheWxvYWQgaGFzIGJlZW4gaHlkcmF0ZWQuXG4gICAgICAgICAqIChlLmcuIGlmIHNvbWVvbmUgaXMgdXNpbmcgbSBjb21wb25lbnRzIDxtLmNpcmNsZSAvPilcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlLm9uTW91bnQgPSAoaW5zdGFuY2UpID0+IG9uVXBkYXRlKHsgcHJvcHMsIGN1cnJlbnQ6IGluc3RhbmNlLCAuLi5zdGF0ZSB9KTtcbiAgICAgICAgc3RhdGUub25VcGRhdGUgPSAodmlzdWFsRWxlbWVudCkgPT4gb25VcGRhdGUodmlzdWFsRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IG1ha2VVc2VWaXN1YWxTdGF0ZSA9IChjb25maWcpID0+IChwcm9wcywgaXNTdGF0aWMpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgY29uc3QgbWFrZSA9ICgpID0+IG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICAgIHJldHVybiBpc1N0YXRpYyA/IG1ha2UoKSA6IHVzZUNvbnN0YW50KG1ha2UpO1xufTtcbmZ1bmN0aW9uIG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgY29uc3QgbW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzKHByb3BzLCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblZhbHVlc1trZXldKTtcbiAgICB9XG4gICAgbGV0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgIGNvbnN0IGlzVmFyaWFudE5vZGUkMSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICAgIGlmIChjb250ZXh0ICYmXG4gICAgICAgIGlzVmFyaWFudE5vZGUkMSAmJlxuICAgICAgICAhaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgJiZcbiAgICAgICAgcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGluaXRpYWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGluaXRpYWwgPSBjb250ZXh0LmluaXRpYWw7XG4gICAgICAgIGlmIChhbmltYXRlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhbmltYXRlID0gY29udGV4dC5hbmltYXRlO1xuICAgIH1cbiAgICBsZXQgaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA9IHByZXNlbmNlQ29udGV4dFxuICAgICAgICA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZVxuICAgICAgICA6IGZhbHNlO1xuICAgIGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkIHx8IGluaXRpYWwgPT09IGZhbHNlO1xuICAgIGNvbnN0IHZhcmlhbnRUb1NldCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyBhbmltYXRlIDogaW5pdGlhbDtcbiAgICBpZiAodmFyaWFudFRvU2V0ICYmXG4gICAgICAgIHR5cGVvZiB2YXJpYW50VG9TZXQgIT09IFwiYm9vbGVhblwiICYmXG4gICAgICAgICFpc0FuaW1hdGlvbkNvbnRyb2xzKHZhcmlhbnRUb1NldCkpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGxpc3RbaV0pO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uLCAuLi50YXJnZXQgfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRha2UgZmluYWwga2V5ZnJhbWUgaWYgdGhlIGluaXRpYWwgYW5pbWF0aW9uIGlzIGJsb2NrZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBpbml0aWFsaXNlIGF0IHRoZSBlbmQgb2YgdGhhdCBibG9ja2VkIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVRhcmdldC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUYXJnZXQgPSB2YWx1ZVRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbmV4cG9ydCB7IG1ha2VVc2VWaXN1YWxTdGF0ZSB9O1xuIiwiLyoqXG4gKiBQcm92aWRlZCBhIHZhbHVlIGFuZCBhIFZhbHVlVHlwZSwgcmV0dXJucyB0aGUgdmFsdWUgYXMgdGhhdCB2YWx1ZSB0eXBlLlxuICovXG5jb25zdCBnZXRWYWx1ZUFzVHlwZSA9ICh2YWx1ZSwgdHlwZSkgPT4ge1xuICAgIHJldHVybiB0eXBlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IHR5cGUudHJhbnNmb3JtKHZhbHVlKVxuICAgICAgICA6IHZhbHVlO1xufTtcblxuZXhwb3J0IHsgZ2V0VmFsdWVBc1R5cGUgfTtcbiIsImltcG9ydCB7IGdldFZhbHVlQXNUeXBlIH0gZnJvbSAnLi4vLi4vZG9tL3ZhbHVlLXR5cGVzL2dldC1hcy10eXBlLm1qcyc7XG5pbXBvcnQgeyBudW1iZXJWYWx1ZVR5cGVzIH0gZnJvbSAnLi4vLi4vZG9tL3ZhbHVlLXR5cGVzL251bWJlci5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcE9yZGVyIH0gZnJvbSAnLi9rZXlzLXRyYW5zZm9ybS5tanMnO1xuXG5jb25zdCB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgICB4OiBcInRyYW5zbGF0ZVhcIixcbiAgICB5OiBcInRyYW5zbGF0ZVlcIixcbiAgICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogXCJwZXJzcGVjdGl2ZVwiLFxufTtcbmNvbnN0IG51bVRyYW5zZm9ybXMgPSB0cmFuc2Zvcm1Qcm9wT3JkZXIubGVuZ3RoO1xuLyoqXG4gKiBCdWlsZCBhIENTUyB0cmFuc2Zvcm0gc3R5bGUgZnJvbSBpbmRpdmlkdWFsIHgveS9zY2FsZSBldGMgcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG91dHB1dHMgd2l0aCBhIGRlZmF1bHQgb3JkZXIgb2YgdHJhbnNmb3Jtcy9zY2FsZXMvcm90YXRpb25zLCB0aGlzIGNhbiBiZSBjdXN0b21pc2VkIGJ5XG4gKiBwcm92aWRpbmcgYSB0cmFuc2Zvcm1UZW1wbGF0ZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm0obGF0ZXN0VmFsdWVzLCB0cmFuc2Zvcm0sIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgLy8gVGhlIHRyYW5zZm9ybSBzdHJpbmcgd2UncmUgZ29pbmcgdG8gYnVpbGQgaW50by5cbiAgICBsZXQgdHJhbnNmb3JtU3RyaW5nID0gXCJcIjtcbiAgICBsZXQgdHJhbnNmb3JtSXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBMb29wIG92ZXIgYWxsIHBvc3NpYmxlIHRyYW5zZm9ybXMgaW4gb3JkZXIsIGFkZGluZyB0aGUgb25lcyB0aGF0XG4gICAgICogYXJlIHByZXNlbnQgdG8gdGhlIHRyYW5zZm9ybSBzdHJpbmcuXG4gICAgICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UcmFuc2Zvcm1zOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHJhbnNmb3JtUHJvcE9yZGVyW2ldO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxhdGVzdFZhbHVlc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgdmFsdWVJc0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB2YWx1ZUlzRGVmYXVsdCA9IHZhbHVlID09PSAoa2V5LnN0YXJ0c1dpdGgoXCJzY2FsZVwiKSA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlSXNEZWZhdWx0ID0gcGFyc2VGbG9hdCh2YWx1ZSkgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUlzRGVmYXVsdCB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgbnVtYmVyVmFsdWVUeXBlc1trZXldKTtcbiAgICAgICAgICAgIGlmICghdmFsdWVJc0RlZmF1bHQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Jc0RlZmF1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1OYW1lID0gdHJhbnNsYXRlQWxpYXNba2V5XSB8fCBrZXk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nICs9IGAke3RyYW5zZm9ybU5hbWV9KCR7dmFsdWVBc1R5cGV9KSBgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmcudHJpbSgpO1xuICAgIC8vIElmIHdlIGhhdmUgYSBjdXN0b20gYHRyYW5zZm9ybWAgdGVtcGxhdGUsIHBhc3Mgb3VyIHRyYW5zZm9ybSB2YWx1ZXMgYW5kXG4gICAgLy8gZ2VuZXJhdGVkIHRyYW5zZm9ybVN0cmluZyB0byB0aGF0IGJlZm9yZSByZXR1cm5pbmdcbiAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtVGVtcGxhdGUodHJhbnNmb3JtLCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPyBcIlwiIDogdHJhbnNmb3JtU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtSXNEZWZhdWx0KSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9IFwibm9uZVwiO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtU3RyaW5nO1xufVxuXG5leHBvcnQgeyBidWlsZFRyYW5zZm9ybSB9O1xuIiwiaW1wb3J0IHsgaXNDU1NWYXJpYWJsZU5hbWUgfSBmcm9tICcuLi8uLi9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZUFzVHlwZSB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanMnO1xuaW1wb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzJztcbmltcG9ydCB7IGJ1aWxkVHJhbnNmb3JtIH0gZnJvbSAnLi9idWlsZC10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVByb3BzIH0gZnJvbSAnLi9rZXlzLXRyYW5zZm9ybS5tanMnO1xuXG5mdW5jdGlvbiBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdFZhbHVlcywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICBjb25zdCB7IHN0eWxlLCB2YXJzLCB0cmFuc2Zvcm1PcmlnaW4gfSA9IHN0YXRlO1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgd2UgZW5jb3VudGVyIGFueSB0cmFuc2Zvcm0gb3IgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcy5cbiAgICBsZXQgaGFzVHJhbnNmb3JtID0gZmFsc2U7XG4gICAgbGV0IGhhc1RyYW5zZm9ybU9yaWdpbiA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIExvb3Agb3ZlciBhbGwgb3VyIGxhdGVzdCBhbmltYXRlZCB2YWx1ZXMgYW5kIGRlY2lkZSB3aGV0aGVyIHRvIGhhbmRsZSB0aGVtXG4gICAgICogYXMgYSBzdHlsZSBvciBDU1MgdmFyaWFibGUuXG4gICAgICpcbiAgICAgKiBUcmFuc2Zvcm1zIGFuZCB0cmFuc2Zvcm0gb3JpZ2lucyBhcmUga2VwdCBzZXBhcmF0ZWx5IGZvciBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICovXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRyYW5zZm9ybSwgZmxhZyB0byBlbmFibGUgZnVydGhlciB0cmFuc2Zvcm0gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgaGFzVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ1NTVmFyaWFibGVOYW1lKGtleSkpIHtcbiAgICAgICAgICAgIHZhcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBpdHMgZGVmYXVsdCB2YWx1ZSB0eXBlLCBpZSAwIC0+IFwiMHB4XCJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNUeXBlID0gZ2V0VmFsdWVBc1R5cGUodmFsdWUsIG51bWJlclZhbHVlVHlwZXNba2V5XSk7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoXCJvcmlnaW5cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdHJhbnNmb3JtIG9yaWdpbiwgZmxhZyBhbmQgZW5hYmxlIGZ1cnRoZXIgdHJhbnNmb3JtLW9yaWdpbiBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgaGFzVHJhbnNmb3JtT3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW5ba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbGF0ZXN0VmFsdWVzLnRyYW5zZm9ybSkge1xuICAgICAgICBpZiAoaGFzVHJhbnNmb3JtIHx8IHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBidWlsZFRyYW5zZm9ybShsYXRlc3RWYWx1ZXMsIHN0YXRlLnRyYW5zZm9ybSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0eWxlLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHByZXZpb3VzbHkgY3JlYXRlZCBhIHRyYW5zZm9ybSBidXQgY3VycmVudGx5IGRvbid0IGhhdmUgYW55LFxuICAgICAgICAgICAgICogcmVzZXQgdHJhbnNmb3JtIHN0eWxlIHRvIG5vbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkIGEgdHJhbnNmb3JtT3JpZ2luIHN0eWxlLiBVc2VzIHRoZSBzYW1lIGRlZmF1bHRzIGFzIHRoZSBicm93c2VyIGZvclxuICAgICAqIHVuZGVmaW5lZCBvcmlnaW5zLlxuICAgICAqL1xuICAgIGlmIChoYXNUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW5YID0gXCI1MCVcIiwgb3JpZ2luWSA9IFwiNTAlXCIsIG9yaWdpblogPSAwLCB9ID0gdHJhbnNmb3JtT3JpZ2luO1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBgJHtvcmlnaW5YfSAke29yaWdpbll9ICR7b3JpZ2luWn1gO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgYnVpbGRIVE1MU3R5bGVzIH07XG4iLCJpbXBvcnQgeyBweCB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcblxuY29uc3QgZGFzaEtleXMgPSB7XG4gICAgb2Zmc2V0OiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gICAgYXJyYXk6IFwic3Ryb2tlLWRhc2hhcnJheVwiLFxufTtcbmNvbnN0IGNhbWVsS2V5cyA9IHtcbiAgICBvZmZzZXQ6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICAgIGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxufTtcbi8qKlxuICogQnVpbGQgU1ZHIHBhdGggcHJvcGVydGllcy4gVXNlcyB0aGUgcGF0aCdzIG1lYXN1cmVkIGxlbmd0aCB0byBjb252ZXJ0XG4gKiBvdXIgY3VzdG9tIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nIGFuZCBwYXRoT2Zmc2V0IGludG8gc3Ryb2tlLWRhc2hvZmZzZXRcbiAqIGFuZCBzdHJva2UtZGFzaGFycmF5IGF0dHJpYnV0ZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBtdXRhdGl2ZSB0byByZWR1Y2UgcGVyLWZyYW1lIEdDLlxuICovXG5mdW5jdGlvbiBidWlsZFNWR1BhdGgoYXR0cnMsIGxlbmd0aCwgc3BhY2luZyA9IDEsIG9mZnNldCA9IDAsIHVzZURhc2hDYXNlID0gdHJ1ZSkge1xuICAgIC8vIE5vcm1hbGlzZSBwYXRoIGxlbmd0aCBieSBzZXR0aW5nIFNWRyBhdHRyaWJ1dGUgcGF0aExlbmd0aCB0byAxXG4gICAgYXR0cnMucGF0aExlbmd0aCA9IDE7XG4gICAgLy8gV2UgdXNlIGRhc2ggY2FzZSB3aGVuIHNldHRpbmcgYXR0cmlidXRlcyBkaXJlY3RseSB0byB0aGUgRE9NIG5vZGUgYW5kIGNhbWVsIGNhc2VcbiAgICAvLyB3aGVuIGRlZmluaW5nIHByb3BzIG9uIGEgUmVhY3QgY29tcG9uZW50LlxuICAgIGNvbnN0IGtleXMgPSB1c2VEYXNoQ2FzZSA/IGRhc2hLZXlzIDogY2FtZWxLZXlzO1xuICAgIC8vIEJ1aWxkIHRoZSBkYXNoIG9mZnNldFxuICAgIGF0dHJzW2tleXMub2Zmc2V0XSA9IHB4LnRyYW5zZm9ybSgtb2Zmc2V0KTtcbiAgICAvLyBCdWlsZCB0aGUgZGFzaCBhcnJheVxuICAgIGNvbnN0IHBhdGhMZW5ndGggPSBweC50cmFuc2Zvcm0obGVuZ3RoKTtcbiAgICBjb25zdCBwYXRoU3BhY2luZyA9IHB4LnRyYW5zZm9ybShzcGFjaW5nKTtcbiAgICBhdHRyc1trZXlzLmFycmF5XSA9IGAke3BhdGhMZW5ndGh9ICR7cGF0aFNwYWNpbmd9YDtcbn1cblxuZXhwb3J0IHsgYnVpbGRTVkdQYXRoIH07XG4iLCJpbXBvcnQgeyBweCB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcblxuZnVuY3Rpb24gY2FsY09yaWdpbihvcmlnaW4sIG9mZnNldCwgc2l6ZSkge1xuICAgIHJldHVybiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gb3JpZ2luXG4gICAgICAgIDogcHgudHJhbnNmb3JtKG9mZnNldCArIHNpemUgKiBvcmlnaW4pO1xufVxuLyoqXG4gKiBUaGUgU1ZHIHRyYW5zZm9ybSBvcmlnaW4gZGVmYXVsdHMgYXJlIGRpZmZlcmVudCB0byBDU1MgYW5kIGlzIGxlc3MgaW50dWl0aXZlLFxuICogc28gd2UgdXNlIHRoZSBtZWFzdXJlZCBkaW1lbnNpb25zIG9mIHRoZSBTVkcgdG8gcmVjb25jaWxlIHRoZXNlLlxuICovXG5mdW5jdGlvbiBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICBjb25zdCBweE9yaWdpblggPSBjYWxjT3JpZ2luKG9yaWdpblgsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy53aWR0aCk7XG4gICAgY29uc3QgcHhPcmlnaW5ZID0gY2FsY09yaWdpbihvcmlnaW5ZLCBkaW1lbnNpb25zLnksIGRpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICByZXR1cm4gYCR7cHhPcmlnaW5YfSAke3B4T3JpZ2luWX1gO1xufVxuXG5leHBvcnQgeyBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luIH07XG4iLCJpbXBvcnQgeyBidWlsZEhUTUxTdHlsZXMgfSBmcm9tICcuLi8uLi9odG1sL3V0aWxzL2J1aWxkLXN0eWxlcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdQYXRoIH0gZnJvbSAnLi9wYXRoLm1qcyc7XG5pbXBvcnQgeyBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luIH0gZnJvbSAnLi90cmFuc2Zvcm0tb3JpZ2luLm1qcyc7XG5cbi8qKlxuICogQnVpbGQgU1ZHIHZpc3VhbCBhdHRyYnV0ZXMsIGxpa2UgY3ggYW5kIHN0eWxlLnRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiBidWlsZFNWR0F0dHJzKHN0YXRlLCB7IGF0dHJYLCBhdHRyWSwgYXR0clNjYWxlLCBvcmlnaW5YLCBvcmlnaW5ZLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZyA9IDEsIHBhdGhPZmZzZXQgPSAwLCBcbi8vIFRoaXMgaXMgb2JqZWN0IGNyZWF0aW9uLCB3aGljaCB3ZSB0cnkgdG8gYXZvaWQgcGVyLWZyYW1lLlxuLi4ubGF0ZXN0IH0sIGlzU1ZHVGFnLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0LCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgLyoqXG4gICAgICogRm9yIHN2ZyB0YWdzIHdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUgdmlld0JveCBpcyBhbmltYXRhYmxlIGFuZCB0cmVhdCBhbGwgdGhlIHN0eWxlc1xuICAgICAqIGFzIG5vcm1hbCBIVE1MIHRhZ3MuXG4gICAgICovXG4gICAgaWYgKGlzU1ZHVGFnKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdHlsZS52aWV3Qm94KSB7XG4gICAgICAgICAgICBzdGF0ZS5hdHRycy52aWV3Qm94ID0gc3RhdGUuc3R5bGUudmlld0JveDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmF0dHJzID0gc3RhdGUuc3R5bGU7XG4gICAgc3RhdGUuc3R5bGUgPSB7fTtcbiAgICBjb25zdCB7IGF0dHJzLCBzdHlsZSwgZGltZW5zaW9ucyB9ID0gc3RhdGU7XG4gICAgLyoqXG4gICAgICogSG93ZXZlciwgd2UgYXBwbHkgdHJhbnNmb3JtcyBhcyBDU1MgdHJhbnNmb3Jtcy4gU28gaWYgd2UgZGV0ZWN0IGEgdHJhbnNmb3JtIHdlIHRha2UgaXQgZnJvbSBhdHRyc1xuICAgICAqIGFuZCBjb3B5IGl0IGludG8gc3R5bGUuXG4gICAgICovXG4gICAgaWYgKGF0dHJzLnRyYW5zZm9ybSkge1xuICAgICAgICBpZiAoZGltZW5zaW9ucylcbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGF0dHJzLnRyYW5zZm9ybTtcbiAgICAgICAgZGVsZXRlIGF0dHJzLnRyYW5zZm9ybTtcbiAgICB9XG4gICAgLy8gUGFyc2UgdHJhbnNmb3JtT3JpZ2luXG4gICAgaWYgKGRpbWVuc2lvbnMgJiZcbiAgICAgICAgKG9yaWdpblggIT09IHVuZGVmaW5lZCB8fCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgfHwgc3R5bGUudHJhbnNmb3JtKSkge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblggIT09IHVuZGVmaW5lZCA/IG9yaWdpblggOiAwLjUsIG9yaWdpblkgIT09IHVuZGVmaW5lZCA/IG9yaWdpblkgOiAwLjUpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgYXR0clgvYXR0clkvYXR0clNjYWxlIGFzIGF0dHJpYnV0ZXNcbiAgICBpZiAoYXR0clggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueCA9IGF0dHJYO1xuICAgIGlmIChhdHRyWSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy55ID0gYXR0clk7XG4gICAgaWYgKGF0dHJTY2FsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy5zY2FsZSA9IGF0dHJTY2FsZTtcbiAgICAvLyBCdWlsZCBTVkcgcGF0aCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZFxuICAgIGlmIChwYXRoTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVpbGRTVkdQYXRoKGF0dHJzLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZywgcGF0aE9mZnNldCwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgYnVpbGRTVkdBdHRycyB9O1xuIiwiY29uc3QgY3JlYXRlSHRtbFJlbmRlclN0YXRlID0gKCkgPT4gKHtcbiAgICBzdHlsZToge30sXG4gICAgdHJhbnNmb3JtOiB7fSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHt9LFxuICAgIHZhcnM6IHt9LFxufSk7XG5cbmV4cG9ydCB7IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlSHRtbFJlbmRlclN0YXRlIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbmNvbnN0IGNyZWF0ZVN2Z1JlbmRlclN0YXRlID0gKCkgPT4gKHtcbiAgICAuLi5jcmVhdGVIdG1sUmVuZGVyU3RhdGUoKSxcbiAgICBhdHRyczoge30sXG59KTtcblxuZXhwb3J0IHsgY3JlYXRlU3ZnUmVuZGVyU3RhdGUgfTtcbiIsImNvbnN0IGlzU1ZHVGFnID0gKHRhZykgPT4gdHlwZW9mIHRhZyA9PT0gXCJzdHJpbmdcIiAmJiB0YWcudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIjtcblxuZXhwb3J0IHsgaXNTVkdUYWcgfTtcbiIsImZ1bmN0aW9uIHJlbmRlckhUTUwoZWxlbWVudCwgeyBzdHlsZSwgdmFycyB9LCBzdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlLCBwcm9qZWN0aW9uICYmIHByb2plY3Rpb24uZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3ApKTtcbiAgICAvLyBMb29wIG92ZXIgYW55IENTUyB2YXJpYWJsZXMgYW5kIGFzc2lnbiB0aG9zZS5cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YXJzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YXJzW2tleV0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgcmVuZGVySFRNTCB9O1xuIiwiLyoqXG4gKiBBIHNldCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBhcmUgYWx3YXlzIHJlYWQvd3JpdHRlbiBhcyBjYW1lbCBjYXNlLlxuICovXG5jb25zdCBjYW1lbENhc2VBdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgXCJiYXNlRnJlcXVlbmN5XCIsXG4gICAgXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgICBcImtlcm5lbE1hdHJpeFwiLFxuICAgIFwia2VybmVsVW5pdExlbmd0aFwiLFxuICAgIFwia2V5U3BsaW5lc1wiLFxuICAgIFwia2V5VGltZXNcIixcbiAgICBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgXCJtYXJrZXJIZWlnaHRcIixcbiAgICBcIm1hcmtlcldpZHRoXCIsXG4gICAgXCJudW1PY3RhdmVzXCIsXG4gICAgXCJ0YXJnZXRYXCIsXG4gICAgXCJ0YXJnZXRZXCIsXG4gICAgXCJzdXJmYWNlU2NhbGVcIixcbiAgICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICBcInN0ZERldmlhdGlvblwiLFxuICAgIFwidGFibGVWYWx1ZXNcIixcbiAgICBcInZpZXdCb3hcIixcbiAgICBcImdyYWRpZW50VHJhbnNmb3JtXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJzdGFydE9mZnNldFwiLFxuICAgIFwidGV4dExlbmd0aFwiLFxuICAgIFwibGVuZ3RoQWRqdXN0XCIsXG5dKTtcblxuZXhwb3J0IHsgY2FtZWxDYXNlQXR0cmlidXRlcyB9O1xuIiwiaW1wb3J0IHsgY2FtZWxUb0Rhc2ggfSBmcm9tICcuLi8uLi9kb20vdXRpbHMvY2FtZWwtdG8tZGFzaC5tanMnO1xuaW1wb3J0IHsgcmVuZGVySFRNTCB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvcmVuZGVyLm1qcyc7XG5pbXBvcnQgeyBjYW1lbENhc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi9jYW1lbC1jYXNlLWF0dHJzLm1qcyc7XG5cbmZ1bmN0aW9uIHJlbmRlclNWRyhlbGVtZW50LCByZW5kZXJTdGF0ZSwgX3N0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHJlbmRlckhUTUwoZWxlbWVudCwgcmVuZGVyU3RhdGUsIHVuZGVmaW5lZCwgcHJvamVjdGlvbik7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVuZGVyU3RhdGUuYXR0cnMpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5LCByZW5kZXJTdGF0ZS5hdHRyc1trZXldKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHJlbmRlclNWRyB9O1xuIiwiaW1wb3J0IHsgc2NhbGVDb3JyZWN0b3JzIH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtY29ycmVjdGlvbi5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcHMgfSBmcm9tICcuLi8uLi9yZW5kZXIvaHRtbC91dGlscy9rZXlzLXRyYW5zZm9ybS5tanMnO1xuXG5mdW5jdGlvbiBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgeyBsYXlvdXQsIGxheW91dElkIH0pIHtcbiAgICByZXR1cm4gKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwib3JpZ2luXCIpIHx8XG4gICAgICAgICgobGF5b3V0IHx8IGxheW91dElkICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoISFzY2FsZUNvcnJlY3RvcnNba2V5XSB8fCBrZXkgPT09IFwib3BhY2l0eVwiKSkpO1xufVxuXG5leHBvcnQgeyBpc0ZvcmNlZE1vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyBpc0ZvcmNlZE1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL3V0aWxzL2lzLWZvcmNlZC1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgbmV3VmFsdWVzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc3R5bGUpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoc3R5bGVba2V5XSkgfHxcbiAgICAgICAgICAgIChwcmV2UHJvcHMuc3R5bGUgJiZcbiAgICAgICAgICAgICAgICBpc01vdGlvblZhbHVlKHByZXZQcm9wcy5zdHlsZVtrZXldKSkgfHxcbiAgICAgICAgICAgIGlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykgfHxcbiAgICAgICAgICAgICgoX2EgPSB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxpdmVTdHlsZSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2tleV0gPSBzdHlsZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbmV4cG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9O1xuIiwiaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcE9yZGVyIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9rZXlzLXRyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIGFzIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuXG5mdW5jdGlvbiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMsIHByZXZQcm9wcywgdmlzdWFsRWxlbWVudCkge1xuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHByb3BzW2tleV0pIHx8XG4gICAgICAgICAgICBpc01vdGlvblZhbHVlKHByZXZQcm9wc1trZXldKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdHJhbnNmb3JtUHJvcE9yZGVyLmluZGV4T2Yoa2V5KSAhPT0gLTFcbiAgICAgICAgICAgICAgICA/IFwiYXR0clwiICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKVxuICAgICAgICAgICAgICAgIDoga2V5O1xuICAgICAgICAgICAgbmV3VmFsdWVzW3RhcmdldEtleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdWYWx1ZXM7XG59XG5cbmV4cG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9O1xuIiwiaW1wb3J0IHsgZnJhbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcbmltcG9ydCB7IG1ha2VVc2VWaXN1YWxTdGF0ZSB9IGZyb20gJy4uLy4uL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4uL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGJ1aWxkU1ZHQXR0cnMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLWF0dHJzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdmdSZW5kZXJTdGF0ZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgaXNTVkdUYWcgfSBmcm9tICcuL3V0aWxzL2lzLXN2Zy10YWcubWpzJztcbmltcG9ydCB7IHJlbmRlclNWRyB9IGZyb20gJy4vdXRpbHMvcmVuZGVyLm1qcyc7XG5pbXBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfSBmcm9tICcuL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcyc7XG5cbmZ1bmN0aW9uIHVwZGF0ZVNWR0RpbWVuc2lvbnMoaW5zdGFuY2UsIHJlbmRlclN0YXRlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9XG4gICAgICAgICAgICB0eXBlb2YgaW5zdGFuY2UuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyBpbnN0YW5jZS5nZXRCQm94KClcbiAgICAgICAgICAgICAgICA6IGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBNb3N0IGxpa2VseSB0cnlpbmcgdG8gbWVhc3VyZSBhbiB1bnJlbmRlcmVkIGVsZW1lbnQgdW5kZXIgRmlyZWZveFxuICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCBsYXlvdXRQcm9wcyA9IFtcInhcIiwgXCJ5XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJjeFwiLCBcImN5XCIsIFwiclwiXTtcbmNvbnN0IHN2Z01vdGlvbkNvbmZpZyA9IHtcbiAgICB1c2VWaXN1YWxTdGF0ZTogbWFrZVVzZVZpc3VhbFN0YXRlKHtcbiAgICAgICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVTdmdSZW5kZXJTdGF0ZSxcbiAgICAgICAgb25VcGRhdGU6ICh7IHByb3BzLCBwcmV2UHJvcHMsIGN1cnJlbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIH0pID0+IHtcbiAgICAgICAgICAgIGlmICghY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaGFzVHJhbnNmb3JtID0gISFwcm9wcy5kcmFnO1xuICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3RWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgbmVlZHNNZWFzdXJlID0gIXByZXZQcm9wcztcbiAgICAgICAgICAgIGlmIChwcmV2UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVjayB0aGUgbGF5b3V0IHByb3BzIGZvciBjaGFuZ2VzLCBpZiBhbnkgYXJlIGZvdW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAgICAgKiBtZWFzdXJlIHRoZSBlbGVtZW50IGFnYWluLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGF5b3V0UHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gbGF5b3V0UHJvcHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldlByb3BzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzTWVhc3VyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5lZWRzTWVhc3VyZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBmcmFtZS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTVkdEaW1lbnNpb25zKGN1cnJlbnQsIHJlbmRlclN0YXRlKTtcbiAgICAgICAgICAgICAgICBmcmFtZS5yZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIGlzU1ZHVGFnKGN1cnJlbnQudGFnTmFtZSksIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyU1ZHKGN1cnJlbnQsIHJlbmRlclN0YXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pLFxufTtcblxuZXhwb3J0IHsgc3ZnTW90aW9uQ29uZmlnIH07XG4iLCJpbXBvcnQgeyBtYWtlVXNlVmlzdWFsU3RhdGUgfSBmcm9tICcuLi8uLi9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlSHRtbFJlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbmNvbnN0IGh0bWxNb3Rpb25Db25maWcgPSB7XG4gICAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCB7IGh0bWxNb3Rpb25Db25maWcgfTtcbiIsImltcG9ydCB7IHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0ZvcmNlZE1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vbW90aW9uL3V0aWxzL2lzLWZvcmNlZC1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtc3R5bGVzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUubWpzJztcblxuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHsgdHJhbnNmb3JtVGVtcGxhdGUgfSwgdmlzdWFsU3RhdGUpIHtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlSHRtbFJlbmRlclN0YXRlKCk7XG4gICAgICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnZhcnMsIHN0YXRlLnN0eWxlKTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIGNvbnN0IHN0eWxlUHJvcCA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgLyoqXG4gICAgICogQ29weSBub24tTW90aW9uIFZhbHVlcyBzdHJhaWdodCBpbnRvIHN0eWxlXG4gICAgICovXG4gICAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gdXNlSFRNTFByb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIC8vIFRoZSBgYW55YCBpc24ndCBpZGVhbCBidXQgaXQgaXMgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBwcm9wcyBhcmd1bWVudFxuICAgIGNvbnN0IGh0bWxQcm9wcyA9IHt9O1xuICAgIGNvbnN0IHN0eWxlID0gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlKTtcbiAgICBpZiAocHJvcHMuZHJhZyAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGdob3N0IGVsZW1lbnQgd2hlbiBhIHVzZXIgZHJhZ3NcbiAgICAgICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uXG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9XG4gICAgICAgICAgICAgICAgc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCI7XG4gICAgICAgIC8vIERpc2FibGUgc2Nyb2xsaW5nIG9uIHRoZSBkcmFnZ2FibGUgZGlyZWN0aW9uXG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID1cbiAgICAgICAgICAgIHByb3BzLmRyYWcgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgOiBgcGFuLSR7cHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwifWA7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJJbmRleCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChwcm9wcy5vblRhcCB8fCBwcm9wcy5vblRhcFN0YXJ0IHx8IHByb3BzLndoaWxlVGFwKSkge1xuICAgICAgICBodG1sUHJvcHMudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICBodG1sUHJvcHMuc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gaHRtbFByb3BzO1xufVxuXG5leHBvcnQgeyBjb3B5UmF3VmFsdWVzT25seSwgdXNlSFRNTFByb3BzIH07XG4iLCIvKipcbiAqIEEgbGlzdCBvZiBhbGwgdmFsaWQgTW90aW9uUHJvcHMuXG4gKlxuICogQHByaXZhdGVSZW1hcmtzXG4gKiBUaGlzIGRvZXNuJ3QgdGhyb3cgaWYgYSBgTW90aW9uUHJvcGAgbmFtZSBpcyBtaXNzaW5nIC0gaXQgc2hvdWxkLlxuICovXG5jb25zdCB2YWxpZE1vdGlvblByb3BzID0gbmV3IFNldChbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJleGl0XCIsXG4gICAgXCJ2YXJpYW50c1wiLFxuICAgIFwiaW5pdGlhbFwiLFxuICAgIFwic3R5bGVcIixcbiAgICBcInZhbHVlc1wiLFxuICAgIFwidmFyaWFudHNcIixcbiAgICBcInRyYW5zaXRpb25cIixcbiAgICBcInRyYW5zZm9ybVRlbXBsYXRlXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImluaGVyaXRcIixcbiAgICBcIm9uQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwib25BbmltYXRpb25TdGFydFwiLFxuICAgIFwib25BbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwib25VcGRhdGVcIixcbiAgICBcIm9uRHJhZ1N0YXJ0XCIsXG4gICAgXCJvbkRyYWdcIixcbiAgICBcIm9uRHJhZ0VuZFwiLFxuICAgIFwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzXCIsXG4gICAgXCJvbkRpcmVjdGlvbkxvY2tcIixcbiAgICBcIm9uRHJhZ1RyYW5zaXRpb25FbmRcIixcbiAgICBcIl9kcmFnWFwiLFxuICAgIFwiX2RyYWdZXCIsXG4gICAgXCJvbkhvdmVyU3RhcnRcIixcbiAgICBcIm9uSG92ZXJFbmRcIixcbiAgICBcIm9uVmlld3BvcnRFbnRlclwiLFxuICAgIFwib25WaWV3cG9ydExlYXZlXCIsXG4gICAgXCJnbG9iYWxUYXBUYXJnZXRcIixcbiAgICBcImlnbm9yZVN0cmljdFwiLFxuICAgIFwidmlld3BvcnRcIixcbl0pO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvcCBuYW1lIGlzIGEgdmFsaWQgYE1vdGlvblByb3BgIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGB0cnVlYCBpcyBrZXkgaXMgYSB2YWxpZCBgTW90aW9uUHJvcGAuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHtcbiAgICByZXR1cm4gKGtleS5zdGFydHNXaXRoKFwid2hpbGVcIikgfHxcbiAgICAgICAgKGtleS5zdGFydHNXaXRoKFwiZHJhZ1wiKSAmJiBrZXkgIT09IFwiZHJhZ2dhYmxlXCIpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwibGF5b3V0XCIpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwib25UYXBcIikgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJvblBhblwiKSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9uTGF5b3V0XCIpIHx8XG4gICAgICAgIHZhbGlkTW90aW9uUHJvcHMuaGFzKGtleSkpO1xufVxuXG5leHBvcnQgeyBpc1ZhbGlkTW90aW9uUHJvcCB9O1xuIiwiaW1wb3J0IHsgaXNWYWxpZE1vdGlvblByb3AgfSBmcm9tICcuLi8uLi8uLi9tb3Rpb24vdXRpbHMvdmFsaWQtcHJvcC5tanMnO1xuXG5sZXQgc2hvdWxkRm9yd2FyZCA9IChrZXkpID0+ICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpO1xuZnVuY3Rpb24gbG9hZEV4dGVybmFsSXNWYWxpZFByb3AoaXNWYWxpZFByb3ApIHtcbiAgICBpZiAoIWlzVmFsaWRQcm9wKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gRXhwbGljaXRseSBmaWx0ZXIgb3VyIGV2ZW50c1xuICAgIHNob3VsZEZvcndhcmQgPSAoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcIm9uXCIpID8gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkgOiBpc1ZhbGlkUHJvcChrZXkpO1xufVxuLyoqXG4gKiBFbW90aW9uIGFuZCBTdHlsZWQgQ29tcG9uZW50cyBib3RoIGFsbG93IHVzZXJzIHRvIHBhc3MgdGhyb3VnaCBhcmJpdHJhcnkgcHJvcHMgdG8gdGhlaXIgY29tcG9uZW50c1xuICogdG8gZHluYW1pY2FsbHkgZ2VuZXJhdGUgQ1NTLiBUaGV5IGJvdGggdXNlIHRoZSBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAgcGFja2FnZSB0byBkZXRlcm1pbmUgd2hpY2hcbiAqIG9mIHRoZXNlIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuXG4gKlxuICogSG93ZXZlciwgd2hlbiBzdHlsaW5nIGEgTW90aW9uIGNvbXBvbmVudCBgc3R5bGVkKG1vdGlvbi5kaXYpYCwgYm90aCBwYWNrYWdlcyBwYXNzIHRocm91Z2ggKmFsbCogcHJvcHNcbiAqIGFzIGl0J3Mgc2VlbiBhcyBhbiBhcmJpdHJhcnkgY29tcG9uZW50IHJhdGhlciB0aGFuIGEgRE9NIG5vZGUuIE1vdGlvbiBvbmx5IGFsbG93cyBhcmJpdHJhcnkgcHJvcHNcbiAqIHBhc3NlZCB0aHJvdWdoIHRoZSBgY3VzdG9tYCBwcm9wIHNvIGl0IGRvZXNuJ3QgKm5lZWQqIHRoZSBwYXlsb2FkIG9yIGNvbXB1dGF0aW9uYWwgb3ZlcmhlYWQgb2ZcbiAqIGBAZW1vdGlvbi9pcy1wcm9wLXZhbGlkYCwgaG93ZXZlciB0byBmaXggdGhpcyBwcm9ibGVtIHdlIG5lZWQgdG8gdXNlIGl0LlxuICpcbiAqIEJ5IG1ha2luZyBpdCBhbiBvcHRpb25hbERlcGVuZGVuY3kgd2UgY2FuIG9mZmVyIHRoaXMgZnVuY3Rpb25hbGl0eSBvbmx5IGluIHRoZSBzaXR1YXRpb25zIHdoZXJlIGl0J3NcbiAqIGFjdHVhbGx5IHJlcXVpcmVkLlxuICovXG50cnkge1xuICAgIC8qKlxuICAgICAqIFdlIGF0dGVtcHQgdG8gaW1wb3J0IHRoaXMgcGFja2FnZSBidXQgcmVxdWlyZSB3b24ndCBiZSBkZWZpbmVkIGluIGVzbSBlbnZpcm9ubWVudHMsIGluIHRoYXQgY2FzZVxuICAgICAqIGlzUHJvcFZhbGlkIHdpbGwgaGF2ZSB0byBiZSBwcm92aWRlZCB2aWEgYE1vdGlvbkNvbnRleHRgLiBJbiBhIDYuMC4wIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWRcbiAgICAgKiBpbiBmYXZvdXIgb2YgZXhwbGljaXQgaW5qZWN0aW9uLlxuICAgICAqL1xuICAgIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKHJlcXVpcmUoXCJAZW1vdGlvbi9pcy1wcm9wLXZhbGlkXCIpLmRlZmF1bHQpO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBhY3R1YWxseSBkbyBhbnl0aGluZyBoZXJlIC0gdGhlIGZhbGxiYWNrIGlzIHRoZSBleGlzdGluZyBgaXNQcm9wVmFsaWRgLlxufVxuZnVuY3Rpb24gZmlsdGVyUHJvcHMocHJvcHMsIGlzRG9tLCBmb3J3YXJkTW90aW9uUHJvcHMpIHtcbiAgICBjb25zdCBmaWx0ZXJlZFByb3BzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHZhbHVlcyBpcyBjb25zaWRlcmVkIGEgdmFsaWQgcHJvcCBieSBFbW90aW9uLCBzbyBpZiBpdCdzIHByZXNlbnRcbiAgICAgICAgICogdGhpcyB3aWxsIGJlIHJlbmRlcmVkIG91dCB0byB0aGUgRE9NIHVubGVzcyBleHBsaWNpdGx5IGZpbHRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZSBjaGVjayB0aGUgdHlwZSBhcyBpdCBjb3VsZCBiZSB1c2VkIHdpdGggdGhlIGBmZUNvbG9yTWF0cml4YFxuICAgICAgICAgKiBlbGVtZW50LCB3aGljaCB3ZSBzdXBwb3J0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGtleSA9PT0gXCJ2YWx1ZXNcIiAmJiB0eXBlb2YgcHJvcHMudmFsdWVzID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChzaG91bGRGb3J3YXJkKGtleSkgfHxcbiAgICAgICAgICAgIChmb3J3YXJkTW90aW9uUHJvcHMgPT09IHRydWUgJiYgaXNWYWxpZE1vdGlvblByb3Aoa2V5KSkgfHxcbiAgICAgICAgICAgICghaXNEb20gJiYgIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSkpIHx8XG4gICAgICAgICAgICAvLyBJZiB0cnlpbmcgdG8gdXNlIG5hdGl2ZSBIVE1MIGRyYWcgZXZlbnRzLCBmb3J3YXJkIGRyYWcgbGlzdGVuZXJzXG4gICAgICAgICAgICAocHJvcHNbXCJkcmFnZ2FibGVcIl0gJiZcbiAgICAgICAgICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9uRHJhZ1wiKSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkUHJvcHNba2V5XSA9XG4gICAgICAgICAgICAgICAgcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRQcm9wcztcbn1cblxuZXhwb3J0IHsgZmlsdGVyUHJvcHMsIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wIH07XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29weVJhd1ZhbHVlc09ubHkgfSBmcm9tICcuLi9odG1sL3VzZS1wcm9wcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdBdHRycyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtYXR0cnMubWpzJztcbmltcG9ydCB7IGNyZWF0ZVN2Z1JlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyBpc1NWR1RhZyB9IGZyb20gJy4vdXRpbHMvaXMtc3ZnLXRhZy5tanMnO1xuXG5mdW5jdGlvbiB1c2VTVkdQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUsIF9pc1N0YXRpYywgQ29tcG9uZW50KSB7XG4gICAgY29uc3QgdmlzdWFsUHJvcHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdmdSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZFNWR0F0dHJzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgaXNTVkdUYWcoQ29tcG9uZW50KSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUuYXR0cnMsXG4gICAgICAgICAgICBzdHlsZTogeyAuLi5zdGF0ZS5zdHlsZSB9LFxuICAgICAgICB9O1xuICAgIH0sIFt2aXN1YWxTdGF0ZV0pO1xuICAgIGlmIChwcm9wcy5zdHlsZSkge1xuICAgICAgICBjb25zdCByYXdTdHlsZXMgPSB7fTtcbiAgICAgICAgY29weVJhd1ZhbHVlc09ubHkocmF3U3R5bGVzLCBwcm9wcy5zdHlsZSwgcHJvcHMpO1xuICAgICAgICB2aXN1YWxQcm9wcy5zdHlsZSA9IHsgLi4ucmF3U3R5bGVzLCAuLi52aXN1YWxQcm9wcy5zdHlsZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmlzdWFsUHJvcHM7XG59XG5cbmV4cG9ydCB7IHVzZVNWR1Byb3BzIH07XG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgdXNlTWVtbywgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUhUTUxQcm9wcyB9IGZyb20gJy4uL2h0bWwvdXNlLXByb3BzLm1qcyc7XG5pbXBvcnQgeyBmaWx0ZXJQcm9wcyB9IGZyb20gJy4vdXRpbHMvZmlsdGVyLXByb3BzLm1qcyc7XG5pbXBvcnQgeyBpc1NWR0NvbXBvbmVudCB9IGZyb20gJy4vdXRpbHMvaXMtc3ZnLWNvbXBvbmVudC5tanMnO1xuaW1wb3J0IHsgdXNlU1ZHUHJvcHMgfSBmcm9tICcuLi9zdmcvdXNlLXByb3BzLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZSkge1xuICAgIGNvbnN0IHVzZVJlbmRlciA9IChDb21wb25lbnQsIHByb3BzLCByZWYsIHsgbGF0ZXN0VmFsdWVzIH0sIGlzU3RhdGljKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZVZpc3VhbFByb3BzID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICAgICAgPyB1c2VTVkdQcm9wc1xuICAgICAgICAgICAgOiB1c2VIVE1MUHJvcHM7XG4gICAgICAgIGNvbnN0IHZpc3VhbFByb3BzID0gdXNlVmlzdWFsUHJvcHMocHJvcHMsIGxhdGVzdFZhbHVlcywgaXNTdGF0aWMsIENvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUHJvcHMgPSBmaWx0ZXJQcm9wcyhwcm9wcywgdHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIiwgZm9yd2FyZE1vdGlvblByb3BzKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BzID0gQ29tcG9uZW50ICE9PSBGcmFnbWVudFxuICAgICAgICAgICAgPyB7IC4uLmZpbHRlcmVkUHJvcHMsIC4uLnZpc3VhbFByb3BzLCByZWYgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGNvbXBvbmVudCBoYXMgYmVlbiBoYW5kZWQgYSBtb3Rpb24gdmFsdWUgYXMgaXRzIGNoaWxkLFxuICAgICAgICAgKiBtZW1vaXNlIGl0cyBpbml0aWFsIHZhbHVlIGFuZCByZW5kZXIgdGhhdC4gU3Vic2VxdWVudCB1cGRhdGVzXG4gICAgICAgICAqIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgb25DaGFuZ2UgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGRyZW4gPSB1c2VNZW1vKCgpID0+IChpc01vdGlvblZhbHVlKGNoaWxkcmVuKSA/IGNoaWxkcmVuLmdldCgpIDogY2hpbGRyZW4pLCBbY2hpbGRyZW5dKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAuLi5lbGVtZW50UHJvcHMsXG4gICAgICAgICAgICBjaGlsZHJlbjogcmVuZGVyZWRDaGlsZHJlbixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG5leHBvcnQgeyBjcmVhdGVVc2VSZW5kZXIgfTtcbiIsImltcG9ydCB7IGNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vbW90aW9uL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc1NWR0NvbXBvbmVudCB9IGZyb20gJy4uL2RvbS91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgeyBzdmdNb3Rpb25Db25maWcgfSBmcm9tICcuLi9zdmcvY29uZmlnLW1vdGlvbi5tanMnO1xuaW1wb3J0IHsgaHRtbE1vdGlvbkNvbmZpZyB9IGZyb20gJy4uL2h0bWwvY29uZmlnLW1vdGlvbi5tanMnO1xuaW1wb3J0IHsgY3JlYXRlVXNlUmVuZGVyIH0gZnJvbSAnLi4vZG9tL3VzZS1yZW5kZXIubWpzJztcblxuZnVuY3Rpb24gY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeShwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnQoQ29tcG9uZW50LCB7IGZvcndhcmRNb3Rpb25Qcm9wcyB9ID0geyBmb3J3YXJkTW90aW9uUHJvcHM6IGZhbHNlIH0pIHtcbiAgICAgICAgY29uc3QgYmFzZUNvbmZpZyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgICAgID8gc3ZnTW90aW9uQ29uZmlnXG4gICAgICAgICAgICA6IGh0bWxNb3Rpb25Db25maWc7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmJhc2VDb25maWcsXG4gICAgICAgICAgICBwcmVsb2FkZWRGZWF0dXJlcyxcbiAgICAgICAgICAgIHVzZVJlbmRlcjogY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcyksXG4gICAgICAgICAgICBjcmVhdGVWaXN1YWxFbGVtZW50LFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVuZGVyZXJNb3Rpb25Db21wb25lbnQoY29uZmlnKTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVNb3Rpb25Db21wb25lbnRGYWN0b3J5IH07XG4iLCIvLyBEb2VzIHRoaXMgZGV2aWNlIHByZWZlciByZWR1Y2VkIG1vdGlvbj8gUmV0dXJucyBgbnVsbGAgc2VydmVyLXNpZGUuXG5jb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHsgY3VycmVudDogbnVsbCB9O1xuY29uc3QgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyID0geyBjdXJyZW50OiBmYWxzZSB9O1xuXG5leHBvcnQgeyBoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIsIHByZWZlcnNSZWR1Y2VkTW90aW9uIH07XG4iLCJpbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuLi9pcy1icm93c2VyLm1qcyc7XG5pbXBvcnQgeyBoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIsIHByZWZlcnNSZWR1Y2VkTW90aW9uIH0gZnJvbSAnLi9zdGF0ZS5tanMnO1xuXG5mdW5jdGlvbiBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gICAgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQgPSB0cnVlO1xuICAgIGlmICghaXNCcm93c2VyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIGNvbnN0IG1vdGlvbk1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uKVwiKTtcbiAgICAgICAgY29uc3Qgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzID0gKCkgPT4gKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBtb3Rpb25NZWRpYVF1ZXJ5Lm1hdGNoZXMpO1xuICAgICAgICBtb3Rpb25NZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyk7XG4gICAgICAgIHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uIH07XG4iLCJpbXBvcnQgeyBjb2xvciB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL2NvbG9yL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvY29tcGxleC9pbmRleC5tanMnO1xuaW1wb3J0IHsgZGltZW5zaW9uVmFsdWVUeXBlcyB9IGZyb20gJy4vZGltZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgdGVzdFZhbHVlVHlwZSB9IGZyb20gJy4vdGVzdC5tanMnO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgVmFsdWVUeXBlc1xuICovXG5jb25zdCB2YWx1ZVR5cGVzID0gWy4uLmRpbWVuc2lvblZhbHVlVHlwZXMsIGNvbG9yLCBjb21wbGV4XTtcbi8qKlxuICogVGVzdHMgYSB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIFZhbHVlVHlwZXNcbiAqL1xuY29uc3QgZmluZFZhbHVlVHlwZSA9ICh2KSA9PiB2YWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbmV4cG9ydCB7IGZpbmRWYWx1ZVR5cGUgfTtcbiIsImNvbnN0IHZpc3VhbEVsZW1lbnRTdG9yZSA9IG5ldyBXZWFrTWFwKCk7XG5cbmV4cG9ydCB7IHZpc3VhbEVsZW1lbnRTdG9yZSB9O1xuIiwiaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi91dGlscy93YXJuLW9uY2UubWpzJztcbmltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKGVsZW1lbnQsIG5leHQsIHByZXYpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBuZXh0KSB7XG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IG5leHRba2V5XTtcbiAgICAgICAgY29uc3QgcHJldlZhbHVlID0gcHJldltrZXldO1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShuZXh0VmFsdWUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBtb3Rpb24gdmFsdWUgZm91bmQgaW4gcHJvcHMgb3Igc3R5bGUsIHdlIHdhbnQgdG8gYWRkIGl0XG4gICAgICAgICAgICAgKiB0byBvdXIgdmlzdWFsIGVsZW1lbnQncyBtb3Rpb24gdmFsdWUgbWFwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbmV4dFZhbHVlKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgdGhlIHZlcnNpb24gb2YgdGhlIGluY29taW5nIG1vdGlvbiB2YWx1ZSB3aXRoIHRoaXMgdmVyc2lvblxuICAgICAgICAgICAgICogYW5kIHdhcm4gYWdhaW5zdCBtaXNtYXRjaGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlKG5leHRWYWx1ZS52ZXJzaW9uID09PSBcIjEyLjAuNlwiLCBgQXR0ZW1wdGluZyB0byBtaXggTW90aW9uIHZlcnNpb25zICR7bmV4dFZhbHVlLnZlcnNpb259IHdpdGggMTIuMC42IG1heSBub3Qgd29yayBhcyBleHBlY3RlZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01vdGlvblZhbHVlKHByZXZWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgc3dhcHBpbmcgZnJvbSBhIG1vdGlvbiB2YWx1ZSB0byBhIHN0YXRpYyB2YWx1ZSxcbiAgICAgICAgICAgICAqIGNyZWF0ZSBhIG5ldyBtb3Rpb24gdmFsdWUgZnJvbSB0aGF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShuZXh0VmFsdWUsIHsgb3duZXI6IGVsZW1lbnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBmbGF0IHZhbHVlIHRoYXQgaGFzIGNoYW5nZWQsIHVwZGF0ZSB0aGUgbW90aW9uIHZhbHVlXG4gICAgICAgICAgICAgKiBvciBjcmVhdGUgb25lIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIGlmIHdlJ3JlXG4gICAgICAgICAgICAgKiBub3QgaGFuZGxpbmcgdGhlIHZhbHVlIHdpdGggb3VyIGFuaW1hdGlvbiBzdGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUubGl2ZVN0eWxlID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUuanVtcChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghZXhpc3RpbmdWYWx1ZS5oYXNBbmltYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlLnNldChuZXh0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhdGVzdFZhbHVlID0gZWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBtb3Rpb25WYWx1ZShsYXRlc3RWYWx1ZSAhPT0gdW5kZWZpbmVkID8gbGF0ZXN0VmFsdWUgOiBuZXh0VmFsdWUsIHsgb3duZXI6IGVsZW1lbnQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZW1vdmVkIHZhbHVlc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByZXYpIHtcbiAgICAgICAgaWYgKG5leHRba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVWYWx1ZShrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dDtcbn1cblxuZXhwb3J0IHsgdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzIH07XG4iLCJpbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi4vZnJhbWVsb29wL3N5bmMtdGltZS5tanMnO1xuaW1wb3J0IHsgZmVhdHVyZURlZmluaXRpb25zIH0gZnJvbSAnLi4vbW90aW9uL2ZlYXR1cmVzL2RlZmluaXRpb25zLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVCb3ggfSBmcm9tICcuLi9wcm9qZWN0aW9uL2dlb21ldHJ5L21vZGVscy5tanMnO1xuaW1wb3J0IHsgaXNOdW1lcmljYWxTdHJpbmcgfSBmcm9tICcuLi91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpc1plcm9WYWx1ZVN0cmluZyB9IGZyb20gJy4uL3V0aWxzL2lzLXplcm8tdmFsdWUtc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24gfSBmcm9tICcuLi91dGlscy9yZWR1Y2VkLW1vdGlvbi9pbmRleC5tanMnO1xuaW1wb3J0IHsgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLCBwcmVmZXJzUmVkdWNlZE1vdGlvbiB9IGZyb20gJy4uL3V0aWxzL3JlZHVjZWQtbW90aW9uL3N0YXRlLm1qcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzJztcbmltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vdXRpbHMvd2Fybi1vbmNlLm1qcyc7XG5pbXBvcnQgeyBtb3Rpb25WYWx1ZSB9IGZyb20gJy4uL3ZhbHVlL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnLi4vdmFsdWUvdHlwZXMvY29tcGxleC9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgZ2V0QW5pbWF0YWJsZU5vbmUgfSBmcm9tICcuL2RvbS92YWx1ZS10eXBlcy9hbmltYXRhYmxlLW5vbmUubWpzJztcbmltcG9ydCB7IGZpbmRWYWx1ZVR5cGUgfSBmcm9tICcuL2RvbS92YWx1ZS10eXBlcy9maW5kLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4vaHRtbC91dGlscy9rZXlzLXRyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgdmlzdWFsRWxlbWVudFN0b3JlIH0gZnJvbSAnLi9zdG9yZS5tanMnO1xuaW1wb3J0IHsgaXNDb250cm9sbGluZ1ZhcmlhbnRzLCBpc1ZhcmlhbnROb2RlIH0gZnJvbSAnLi91dGlscy9pcy1jb250cm9sbGluZy12YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgS2V5ZnJhbWVSZXNvbHZlciB9IGZyb20gJy4vdXRpbHMvS2V5ZnJhbWVzUmVzb2x2ZXIubWpzJztcbmltcG9ydCB7IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvbW90aW9uLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMgfSBmcm9tICcuL3V0aWxzL3Jlc29sdmUtdmFyaWFudHMubWpzJztcbmltcG9ydCB7IGZyYW1lLCBjYW5jZWxGcmFtZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5jb25zdCBwcm9wRXZlbnRIYW5kbGVycyA9IFtcbiAgICBcIkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJBbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwiVXBkYXRlXCIsXG4gICAgXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJMYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICAgIFwiTGF5b3V0QW5pbWF0aW9uQ29tcGxldGVcIixcbl07XG4vKipcbiAqIEEgVmlzdWFsRWxlbWVudCBpcyBhbiBpbXBlcmF0aXZlIGFic3RyYWN0aW9uIGFyb3VuZCBVSSBlbGVtZW50cyBzdWNoIGFzXG4gKiBIVE1MRWxlbWVudCwgU1ZHRWxlbWVudCwgVGhyZWUuT2JqZWN0M0QgZXRjLlxuICovXG5jbGFzcyBWaXN1YWxFbGVtZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB0YWtlcyBSZWFjdCBwcm9wcyBhbmQgcmV0dXJucyBmb3VuZCBNb3Rpb25WYWx1ZXMuIEZvciBleGFtcGxlLCBIVE1MXG4gICAgICogTW90aW9uVmFsdWVzIHdpbGwgYmUgZm91bmQgd2l0aGluIHRoZSBzdHlsZSBwcm9wLCB3aGVyZWFzIGZvciBUaHJlZS5qcyB3aXRoaW4gYXR0cmlidXRlIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXNuJ3QgYW4gYWJzdHJhY3QgbWV0aG9kIGFzIGl0IG5lZWRzIGNhbGxpbmcgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgaXQgaXNcbiAgICAgKiBpbnRlbmRlZCB0byBiZSBvbmUuXG4gICAgICovXG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKF9wcm9wcywgX3ByZXZQcm9wcywgX3Zpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih7IHBhcmVudCwgcHJvcHMsIHByZXNlbmNlQ29udGV4dCwgcmVkdWNlZE1vdGlvbkNvbmZpZywgYmxvY2tJbml0aWFsQW5pbWF0aW9uLCB2aXN1YWxTdGF0ZSwgfSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCB1bmRlcmx5aW5nIEluc3RhbmNlLCBlLmcuIGEgSFRNTEVsZW1lbnRcbiAgICAgICAgICogb3IgVGhyZWUuTWVzaCBldGMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZXQgY29udGFpbmluZyByZWZlcmVuY2VzIHRvIHRoaXMgVmlzdWFsRWxlbWVudCdzIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSB3aGF0IHJvbGUgdGhpcyB2aXN1YWwgZWxlbWVudCBzaG91bGQgdGFrZSBpbiB0aGUgdmFyaWFudCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1ZhcmlhbnROb2RlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWNpZGVzIHdoZXRoZXIgdGhpcyBWaXN1YWxFbGVtZW50IHNob3VsZCBhbmltYXRlIGluIHJlZHVjZWQgbW90aW9uXG4gICAgICAgICAqIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IFRoaXMgaXMgY3VycmVudGx5IHNldCBvbiBldmVyeSBpbmRpdmlkdWFsIFZpc3VhbEVsZW1lbnQgYnV0IGZlZWxzXG4gICAgICAgICAqIGxpa2UgaXQgY291bGQgYmUgc2V0IGdsb2JhbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaG91bGRSZWR1Y2VNb3Rpb24gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgYWxsIG1vdGlvbiB2YWx1ZXMgYXR0YWNoZWQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC4gTW90aW9uXG4gICAgICAgICAqIHZhbHVlcyBhcmUgc291cmNlIG9mIHRydXRoIGZvciBhbnkgZ2l2ZW4gYW5pbWF0ZWQgdmFsdWUuIEEgbW90aW9uXG4gICAgICAgICAqIHZhbHVlIG1pZ2h0IGJlIHByb3ZpZGVkIGV4dGVybmFsbHkgYnkgdGhlIGNvbXBvbmVudCB2aWEgcHJvcHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5LZXlmcmFtZVJlc29sdmVyID0gS2V5ZnJhbWVSZXNvbHZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsZWFudXAgZnVuY3Rpb25zIGZvciBhY3RpdmUgZmVhdHVyZXMgKGhvdmVyL3RhcC9leGl0IGV0YylcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGV2ZXJ5IHN1YnNjcmlwdGlvbiB0aGF0IGJpbmRzIHRoZSBwcm92aWRlZCBvciBnZW5lcmF0ZWRcbiAgICAgICAgICogbW90aW9uIHZhbHVlcyBvbkNoYW5nZSBsaXN0ZW5lcnMgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzbHktcHJvdmlkZWQgbW90aW9uIHZhbHVlcyBhcyByZXR1cm5lZFxuICAgICAgICAgKiBmcm9tIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcy4gV2UgdXNlIHRoZSBrZXlzIGluIGhlcmUgdG8gZGV0ZXJtaW5lXG4gICAgICAgICAqIGlmIGFueSBtb3Rpb24gdmFsdWVzIG5lZWQgdG8gYmUgcmVtb3ZlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBTdWJzY3JpcHRpb25NYW5hZ2VyIGZvciBlYWNoIGFjdGl2ZSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiBmb3IgZWFjaCBwcm9wIGV2ZW50IHN1YnNjcmlwdGlvbi5cbiAgICAgICAgICogRm9yIGV4YW1wbGUsIGV2ZXJ5IFwiVXBkYXRlXCIgZXZlbnQgY2FuIGhhdmUgbXVsdGlwbGUgc3Vic2NyaWJlcnMgdmlhXG4gICAgICAgICAqIFZpc3VhbEVsZW1lbnQub24oKSwgYnV0IG9ubHkgb25lIG9mIHRob3NlIGNhbiBiZSBkZWZpbmVkIHZpYSB0aGUgb25VcGRhdGUgcHJvcC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLm5vdGlmeVVwZGF0ZSA9ICgpID0+IHRoaXMubm90aWZ5KFwiVXBkYXRlXCIsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXJCdWlsZCgpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJJbnN0YW5jZSh0aGlzLmN1cnJlbnQsIHRoaXMucmVuZGVyU3RhdGUsIHRoaXMucHJvcHMuc3R5bGUsIHRoaXMucHJvamVjdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyU2NoZWR1bGVkQXQgPSAwLjA7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSB0aW1lLm5vdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVuZGVyU2NoZWR1bGVkQXQgPCBub3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclNjaGVkdWxlZEF0ID0gbm93O1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlbmRlcih0aGlzLnJlbmRlciwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGxhdGVzdFZhbHVlcywgcmVuZGVyU3RhdGUsIG9uVXBkYXRlIH0gPSB2aXN1YWxTdGF0ZTtcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICAgICAgdGhpcy5iYXNlVGFyZ2V0ID0geyAuLi5sYXRlc3RWYWx1ZXMgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVzID0gcHJvcHMuaW5pdGlhbCA/IHsgLi4ubGF0ZXN0VmFsdWVzIH0gOiB7fTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdGF0ZSA9IHJlbmRlclN0YXRlO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnByZXNlbmNlQ29udGV4dCA9IHByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgICB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPSByZWR1Y2VkTW90aW9uQ29uZmlnO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmJsb2NrSW5pdGlhbEFuaW1hdGlvbiA9IEJvb2xlYW4oYmxvY2tJbml0aWFsQW5pbWF0aW9uKTtcbiAgICAgICAgdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgICAgICB0aGlzLmlzVmFyaWFudE5vZGUgPSBpc1ZhcmlhbnROb2RlKHByb3BzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNWYXJpYW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy52YXJpYW50Q2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYW51YWxseUFuaW1hdGVPbk1vdW50ID0gQm9vbGVhbihwYXJlbnQgJiYgcGFyZW50LmN1cnJlbnQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW55IG1vdGlvbiB2YWx1ZXMgdGhhdCBhcmUgcHJvdmlkZWQgdG8gdGhlIGVsZW1lbnQgd2hlbiBjcmVhdGVkXG4gICAgICAgICAqIGFyZW4ndCB5ZXQgYm91bmQgdG8gdGhlIGVsZW1lbnQsIGFzIHRoaXMgd291bGQgdGVjaG5pY2FsbHkgYmUgaW1wdXJlLlxuICAgICAgICAgKiBIb3dldmVyLCB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIG1vdGlvbiB2YWx1ZXMgYW5kIHNldCB0aGVtIHRvIHRoZVxuICAgICAgICAgKiBpbml0aWFsIHZhbHVlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRPRE86IFRoaXMgaXMgaW1wdXJlIGFuZCB3ZSBzaG91bGQgbG9vayBhdCBjaGFuZ2luZyB0aGlzIHRvIHJ1biBvbiBtb3VudC5cbiAgICAgICAgICogRG9pbmcgc28gd2lsbCBicmVhayBzb21lIHRlc3RzIGJ1dCB0aGlzIGlzbid0IG5lY2Vzc2FyaWx5IGEgYnJlYWtpbmcgY2hhbmdlLFxuICAgICAgICAgKiBtb3JlIGEgcmVmbGVjdGlvbiBvZiB0aGUgdGVzdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgd2lsbENoYW5nZSwgLi4uaW5pdGlhbE1vdGlvblZhbHVlcyB9ID0gdGhpcy5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMsIHt9LCB0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5pdGlhbE1vdGlvblZhbHVlcykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsTW90aW9uVmFsdWVzW2tleV07XG4gICAgICAgICAgICBpZiAobGF0ZXN0VmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCAmJiBpc01vdGlvblZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnNldChsYXRlc3RWYWx1ZXNba2V5XSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50KGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGluc3RhbmNlO1xuICAgICAgICB2aXN1YWxFbGVtZW50U3RvcmUuc2V0KGluc3RhbmNlLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMucHJvamVjdGlvbiAmJiAhdGhpcy5wcm9qZWN0aW9uLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb24ubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCAmJiB0aGlzLmlzVmFyaWFudE5vZGUgJiYgIXRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZSA9IHRoaXMucGFyZW50LmFkZFZhcmlhbnRDaGlsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0aGlzLmJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpKTtcbiAgICAgICAgaWYgKCFoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIuY3VycmVudCkge1xuICAgICAgICAgICAgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG91bGRSZWR1Y2VNb3Rpb24gPVxuICAgICAgICAgICAgdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID09PSBcIm5ldmVyXCJcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPT09IFwiYWx3YXlzXCJcbiAgICAgICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgICAgIDogcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudDtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgd2Fybk9uY2UodGhpcy5zaG91bGRSZWR1Y2VNb3Rpb24gIT09IHRydWUsIFwiWW91IGhhdmUgUmVkdWNlZCBNb3Rpb24gZW5hYmxlZCBvbiB5b3VyIGRldmljZS4gQW5pbWF0aW9ucyBtYXkgbm90IGFwcGVhciBhcyBleHBlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh0aGlzLnByb3BzLCB0aGlzLnByZXNlbmNlQ29udGV4dCk7XG4gICAgfVxuICAgIHVubW91bnQoKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnRTdG9yZS5kZWxldGUodGhpcy5jdXJyZW50KTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uICYmIHRoaXMucHJvamVjdGlvbi51bm1vdW50KCk7XG4gICAgICAgIGNhbmNlbEZyYW1lKHRoaXMubm90aWZ5VXBkYXRlKTtcbiAgICAgICAgY2FuY2VsRnJhbWUodGhpcy5yZW5kZXIpO1xuICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKChyZW1vdmUpID0+IHJlbW92ZSgpKTtcbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUgJiYgdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUoKTtcbiAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY2hpbGRyZW4uZGVsZXRlKHRoaXMpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNba2V5XS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW2tleV07XG4gICAgICAgICAgICBpZiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUudW5tb3VudCgpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuaXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmdldChrZXkpKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVJc1RyYW5zZm9ybSA9IHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCByZW1vdmVPbkNoYW5nZSA9IHZhbHVlLm9uKFwiY2hhbmdlXCIsIChsYXRlc3RWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IGxhdGVzdFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblVwZGF0ZSAmJiBmcmFtZS5wcmVSZW5kZXIodGhpcy5ub3RpZnlVcGRhdGUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlSXNUcmFuc2Zvcm0gJiYgdGhpcy5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uLmlzVHJhbnNmb3JtRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0ID0gdmFsdWUub24oXCJyZW5kZXJSZXF1ZXN0XCIsIHRoaXMuc2NoZWR1bGVSZW5kZXIpO1xuICAgICAgICBsZXQgcmVtb3ZlU3luY0NoZWNrO1xuICAgICAgICBpZiAod2luZG93Lk1vdGlvbkNoZWNrQXBwZWFyU3luYykge1xuICAgICAgICAgICAgcmVtb3ZlU3luY0NoZWNrID0gd2luZG93Lk1vdGlvbkNoZWNrQXBwZWFyU3luYyh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCAoKSA9PiB7XG4gICAgICAgICAgICByZW1vdmVPbkNoYW5nZSgpO1xuICAgICAgICAgICAgcmVtb3ZlT25SZW5kZXJSZXF1ZXN0KCk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlU3luY0NoZWNrKVxuICAgICAgICAgICAgICAgIHJlbW92ZVN5bmNDaGVjaygpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLm93bmVyKVxuICAgICAgICAgICAgICAgIHZhbHVlLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNvcnROb2RlUG9zaXRpb24ob3RoZXIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZXNlIG5vZGVzIGFyZW4ndCBldmVuIG9mIHRoZSBzYW1lIHR5cGUgd2UgY2FuJ3QgY29tcGFyZSB0aGVpciBkZXB0aC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50IHx8XG4gICAgICAgICAgICAhdGhpcy5zb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24gfHxcbiAgICAgICAgICAgIHRoaXMudHlwZSAhPT0gb3RoZXIudHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKHRoaXMuY3VycmVudCwgb3RoZXIuY3VycmVudCk7XG4gICAgfVxuICAgIHVwZGF0ZUZlYXR1cmVzKCkge1xuICAgICAgICBsZXQga2V5ID0gXCJhbmltYXRpb25cIjtcbiAgICAgICAgZm9yIChrZXkgaW4gZmVhdHVyZURlZmluaXRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlRGVmaW5pdGlvbiA9IGZlYXR1cmVEZWZpbml0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKCFmZWF0dXJlRGVmaW5pdGlvbilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNFbmFibGVkLCBGZWF0dXJlOiBGZWF0dXJlQ29uc3RydWN0b3IgfSA9IGZlYXR1cmVEZWZpbml0aW9uO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGZlYXR1cmUgaXMgZW5hYmxlZCBidXQgbm90IGFjdGl2ZSwgbWFrZSBhIG5ldyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmVzW2tleV0gJiZcbiAgICAgICAgICAgICAgICBGZWF0dXJlQ29uc3RydWN0b3IgJiZcbiAgICAgICAgICAgICAgICBpc0VuYWJsZWQodGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzW2tleV0gPSBuZXcgRmVhdHVyZUNvbnN0cnVjdG9yKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIGEgZmVhdHVyZSwgbW91bnQgb3IgdXBkYXRlIGl0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuZmVhdHVyZXNba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5pc01vdW50ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUubW91bnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmlnZ2VyQnVpbGQoKSB7XG4gICAgICAgIHRoaXMuYnVpbGQodGhpcy5yZW5kZXJTdGF0ZSwgdGhpcy5sYXRlc3RWYWx1ZXMsIHRoaXMucHJvcHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZWFzdXJlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGJveCB3aXRoIG9yIHdpdGhvdXQgdHJhbnNmb3Jtcy5cbiAgICAgKiBPbmx5IG1lYXN1cmVzIGF4aXMtYWxpZ25lZCBib3hlcywgcm90YXRlIGFuZCBza2V3IG11c3QgYmUgbWFudWFsbHlcbiAgICAgKiByZW1vdmVkIHdpdGggYSByZS1yZW5kZXIgdG8gd29yay5cbiAgICAgKi9cbiAgICBtZWFzdXJlVmlld3BvcnRCb3goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRcbiAgICAgICAgICAgID8gdGhpcy5tZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCh0aGlzLmN1cnJlbnQsIHRoaXMucHJvcHMpXG4gICAgICAgICAgICA6IGNyZWF0ZUJveCgpO1xuICAgIH1cbiAgICBnZXRTdGF0aWNWYWx1ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF0ZXN0VmFsdWVzW2tleV07XG4gICAgfVxuICAgIHNldFN0YXRpY1ZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIHByb3ZpZGVkIHByb3BzLiBFbnN1cmUgYW55IG5ld2x5LWFkZGVkIG1vdGlvbiB2YWx1ZXMgYXJlXG4gICAgICogYWRkZWQgdG8gb3VyIG1hcCwgb2xkIG9uZXMgcmVtb3ZlZCwgYW5kIGxpc3RlbmVycyB1cGRhdGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZShwcm9wcywgcHJlc2VuY2VDb250ZXh0KSB7XG4gICAgICAgIGlmIChwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSB8fCB0aGlzLnByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2UHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMucHJldlByZXNlbmNlQ29udGV4dCA9IHRoaXMucHJlc2VuY2VDb250ZXh0O1xuICAgICAgICB0aGlzLnByZXNlbmNlQ29udGV4dCA9IHByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBwcm9wIGV2ZW50IGhhbmRsZXJzIGllIG9uQW5pbWF0aW9uU3RhcnQsIG9uQW5pbWF0aW9uQ29tcGxldGVcbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvcEV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHByb3BFdmVudEhhbmRsZXJzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV0oKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lck5hbWUgPSAoXCJvblwiICsga2V5KTtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gcHJvcHNbbGlzdGVuZXJOYW1lXTtcbiAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldID0gdGhpcy5vbihrZXksIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZNb3Rpb25WYWx1ZXMgPSB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHModGhpcywgdGhpcy5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMsIHRoaXMucHJldlByb3BzLCB0aGlzKSwgdGhpcy5wcmV2TW90aW9uVmFsdWVzKTtcbiAgICAgICAgaWYgKHRoaXMuaGFuZGxlQ2hpbGRNb3Rpb25WYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGlsZE1vdGlvblZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblVwZGF0ZSAmJiB0aGlzLm9uVXBkYXRlKHRoaXMpO1xuICAgIH1cbiAgICBnZXRQcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiB3aXRoIGEgZ2l2ZW4gbmFtZS5cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudmFyaWFudHMgPyB0aGlzLnByb3BzLnZhcmlhbnRzW25hbWVdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZpbmVkIGRlZmF1bHQgdHJhbnNpdGlvbiBvbiB0aGlzIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBnZXREZWZhdWx0VHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudHJhbnNpdGlvbjtcbiAgICB9XG4gICAgZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgfVxuICAgIGdldENsb3Nlc3RWYXJpYW50Tm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYXJpYW50Tm9kZVxuICAgICAgICAgICAgPyB0aGlzXG4gICAgICAgICAgICA6IHRoaXMucGFyZW50XG4gICAgICAgICAgICAgICAgPyB0aGlzLnBhcmVudC5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjaGlsZCB2aXN1YWwgZWxlbWVudCB0byBvdXIgc2V0IG9mIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGFkZFZhcmlhbnRDaGlsZChjaGlsZCkge1xuICAgICAgICBjb25zdCBjbG9zZXN0VmFyaWFudE5vZGUgPSB0aGlzLmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2VzdFZhcmlhbnROb2RlKSB7XG4gICAgICAgICAgICBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuICYmXG4gICAgICAgICAgICAgICAgY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbi5hZGQoY2hpbGQpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4uZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBtb3Rpb24gdmFsdWUgYW5kIGJpbmQgaXQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC5cbiAgICAgKi9cbiAgICBhZGRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyB2YWx1ZSBpZiBpdCBleGlzdHNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHRoaXMudmFsdWVzLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IGV4aXN0aW5nVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ1ZhbHVlKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbW90aW9uIHZhbHVlIGFuZCB1bmJpbmQgYW55IGFjdGl2ZSBzdWJzY3JpcHRpb25zLlxuICAgICAqL1xuICAgIHJlbW92ZVZhbHVlKGtleSkge1xuICAgICAgICB0aGlzLnZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMubGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIHRoaXMucmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoa2V5LCB0aGlzLnJlbmRlclN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgbW90aW9uIHZhbHVlIGZvciB0aGlzIGtleVxuICAgICAqL1xuICAgIGhhc1ZhbHVlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZXMuaGFzKGtleSk7XG4gICAgfVxuICAgIGdldFZhbHVlKGtleSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnZhbHVlcyAmJiB0aGlzLnByb3BzLnZhbHVlc1trZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy52YWx1ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLnZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogZGVmYXVsdFZhbHVlLCB7IG93bmVyOiB0aGlzIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRWYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIHRyeWluZyB0byBhbmltYXRlIHRvIGEgcHJldmlvdXNseSB1bmVuY291bnRlcmVkIHZhbHVlLFxuICAgICAqIHdlIG5lZWQgdG8gY2hlY2sgZm9yIGl0IGluIG91ciBzdGF0ZSBhbmQgYXMgYSBsYXN0IHJlc29ydCByZWFkIGl0XG4gICAgICogZGlyZWN0bHkgZnJvbSB0aGUgaW5zdGFuY2UgKHdoaWNoIG1pZ2h0IGhhdmUgcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zKS5cbiAgICAgKi9cbiAgICByZWFkVmFsdWUoa2V5LCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmxhdGVzdFZhbHVlc1trZXldICE9PSB1bmRlZmluZWQgfHwgIXRoaXMuY3VycmVudFxuICAgICAgICAgICAgPyB0aGlzLmxhdGVzdFZhbHVlc1trZXldXG4gICAgICAgICAgICA6IChfYSA9IHRoaXMuZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyh0aGlzLnByb3BzLCBrZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJlYWRWYWx1ZUZyb21JbnN0YW5jZSh0aGlzLmN1cnJlbnQsIGtleSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICAoaXNOdW1lcmljYWxTdHJpbmcodmFsdWUpIHx8IGlzWmVyb1ZhbHVlU3RyaW5nKHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbnVtYmVyIHJlYWQgYXMgYSBzdHJpbmcsIGllIFwiMFwiIG9yIFwiMjAwXCIsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWZpbmRWYWx1ZVR5cGUodmFsdWUpICYmIGNvbXBsZXgudGVzdCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRBbmltYXRhYmxlTm9uZShrZXksIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEJhc2VUYXJnZXQoa2V5LCBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlLmdldCgpIDogdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlLmdldCgpIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYmFzZSB0YXJnZXQgdG8gbGF0ZXIgYW5pbWF0ZSBiYWNrIHRvLiBUaGlzIGlzIGN1cnJlbnRseVxuICAgICAqIG9ubHkgaHlkcmF0ZWQgb24gY3JlYXRpb24gYW5kIHdoZW4gd2UgZmlyc3QgcmVhZCBhIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEJhc2VUYXJnZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmJhc2VUYXJnZXRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBiYXNlIHRhcmdldCBmb3IgYSB2YWx1ZSB0aGF0cyBiZWVuIHJlbW92ZWQgZnJvbSBhbGwgYW5pbWF0aW9uXG4gICAgICogcHJvcHMuXG4gICAgICovXG4gICAgZ2V0QmFzZVRhcmdldChrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGluaXRpYWwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB2YWx1ZUZyb21Jbml0aWFsO1xuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWwgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGluaXRpYWwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhcmlhbnQgPSByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyh0aGlzLnByb3BzLCBpbml0aWFsLCAoX2EgPSB0aGlzLnByZXNlbmNlQ29udGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1c3RvbSk7XG4gICAgICAgICAgICBpZiAodmFyaWFudCkge1xuICAgICAgICAgICAgICAgIHZhbHVlRnJvbUluaXRpYWwgPSB2YXJpYW50W2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgdmFsdWUgc3RpbGwgZXhpc3RzIGluIHRoZSBjdXJyZW50IGluaXRpYWwgdmFyaWFudCwgcmVhZCB0aGF0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGluaXRpYWwgJiYgdmFsdWVGcm9tSW5pdGlhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVGcm9tSW5pdGlhbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQWx0ZXJuYXRpdmVseSwgaWYgdGhpcyBWaXN1YWxFbGVtZW50IGNvbmZpZyBoYXMgZGVmaW5lZCBhIGdldEJhc2VUYXJnZXRcbiAgICAgICAgICogc28gd2UgY2FuIHJlYWQgdGhlIHZhbHVlIGZyb20gYW4gYWx0ZXJuYXRpdmUgc291cmNlLCB0cnkgdGhhdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyh0aGlzLnByb3BzLCBrZXkpO1xuICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgIWlzTW90aW9uVmFsdWUodGFyZ2V0KSlcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgd2FzIGluaXRpYWxseSBkZWZpbmVkIG9uIGluaXRpYWwsIGJ1dCBpdCBkb2Vzbid0IGFueSBtb3JlLFxuICAgICAgICAgKiByZXR1cm4gdW5kZWZpbmVkLiBPdGhlcndpc2UgcmV0dXJuIHRoZSB2YWx1ZSBhcyBpbml0aWFsbHkgcmVhZCBmcm9tIHRoZSBET00uXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdmFsdWVGcm9tSW5pdGlhbCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB0aGlzLmJhc2VUYXJnZXRba2V5XTtcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmFkZChjYWxsYmFjayk7XG4gICAgfVxuICAgIG5vdGlmeShldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ubm90aWZ5KC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBWaXN1YWxFbGVtZW50IH07XG4iLCJpbXBvcnQgeyBWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vVmlzdWFsRWxlbWVudC5tanMnO1xuaW1wb3J0IHsgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIgfSBmcm9tICcuL0RPTUtleWZyYW1lc1Jlc29sdmVyLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmNsYXNzIERPTVZpc3VhbEVsZW1lbnQgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5LZXlmcmFtZVJlc29sdmVyID0gRE9NS2V5ZnJhbWVzUmVzb2x2ZXI7XG4gICAgfVxuICAgIHNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbihhLCBiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiByZXR1cm5zIGEgYml0bWFzaywgYnkgdXNpbmcgdGhlIGJpdHdpc2UgJlxuICAgICAgICAgKiB3ZSdyZSByZXR1cm5pbmcgdHJ1ZSBpZiAyIGluIHRoYXQgYml0bWFzayBpcyBzZXQgdG8gdHJ1ZS4gMiBpcyBzZXRcbiAgICAgICAgICogdG8gdHJ1ZSBpZiBiIHByZWNlZWRzIGEuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIGdldEJhc2VUYXJnZXRGcm9tUHJvcHMocHJvcHMsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJvcHMuc3R5bGVcbiAgICAgICAgICAgID8gcHJvcHMuc3R5bGVba2V5XVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgeyB2YXJzLCBzdHlsZSB9KSB7XG4gICAgICAgIGRlbGV0ZSB2YXJzW2tleV07XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZE1vdGlvblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRTdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkU3Vic2NyaXB0aW9uID0gY2hpbGRyZW4ub24oXCJjaGFuZ2VcIiwgKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7bGF0ZXN0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IERPTVZpc3VhbEVsZW1lbnQgfTtcbiIsImltcG9ydCB7IG1lYXN1cmVWaWV3cG9ydEJveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vdXRpbHMvbWVhc3VyZS5tanMnO1xuaW1wb3J0IHsgRE9NVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL2RvbS9ET01WaXN1YWxFbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBpc0NTU1ZhcmlhYmxlTmFtZSB9IGZyb20gJy4uL2RvbS91dGlscy9pcy1jc3MtdmFyaWFibGUubWpzJztcbmltcG9ydCB7IGdldERlZmF1bHRWYWx1ZVR5cGUgfSBmcm9tICcuLi9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMubWpzJztcbmltcG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtc3R5bGVzLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4vdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHJlbmRlckhUTUwgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59XG5jbGFzcyBIVE1MVmlzdWFsRWxlbWVudCBleHRlbmRzIERPTVZpc3VhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBcImh0bWxcIjtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnN0YW5jZSA9IHJlbmRlckhUTUw7XG4gICAgfVxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZShpbnN0YW5jZSwga2V5KSB7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFR5cGUgPSBnZXREZWZhdWx0VmFsdWVUeXBlKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFR5cGUgPyBkZWZhdWx0VHlwZS5kZWZhdWx0IHx8IDAgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoaW5zdGFuY2UpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAoaXNDU1NWYXJpYWJsZU5hbWUoa2V5KVxuICAgICAgICAgICAgICAgID8gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKGtleSlcbiAgICAgICAgICAgICAgICA6IGNvbXB1dGVkU3R5bGVba2V5XSkgfHwgMDtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS50cmltKCkgOiB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveChpbnN0YW5jZSwgeyB0cmFuc2Zvcm1QYWdlUG9pbnQgfSkge1xuICAgICAgICByZXR1cm4gbWVhc3VyZVZpZXdwb3J0Qm94KGluc3RhbmNlLCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIH1cbiAgICBidWlsZChyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBwcm9wcykge1xuICAgICAgICBidWlsZEhUTUxTdHlsZXMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH1cbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMsIHByZXZQcm9wcywgdmlzdWFsRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgSFRNTFZpc3VhbEVsZW1lbnQsIGdldENvbXB1dGVkU3R5bGUgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUJveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5pbXBvcnQgeyBET01WaXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vZG9tL0RPTVZpc3VhbEVsZW1lbnQubWpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoIH0gZnJvbSAnLi4vZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzJztcbmltcG9ydCB7IGdldERlZmF1bHRWYWx1ZVR5cGUgfSBmcm9tICcuLi9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVByb3BzIH0gZnJvbSAnLi4vaHRtbC91dGlscy9rZXlzLXRyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdBdHRycyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtYXR0cnMubWpzJztcbmltcG9ydCB7IGNhbWVsQ2FzZUF0dHJpYnV0ZXMgfSBmcm9tICcuL3V0aWxzL2NhbWVsLWNhc2UtYXR0cnMubWpzJztcbmltcG9ydCB7IGlzU1ZHVGFnIH0gZnJvbSAnLi91dGlscy9pcy1zdmctdGFnLm1qcyc7XG5pbXBvcnQgeyByZW5kZXJTVkcgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuXG5jbGFzcyBTVkdWaXN1YWxFbGVtZW50IGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic3ZnXCI7XG4gICAgICAgIHRoaXMuaXNTVkdUYWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCA9IGNyZWF0ZUJveDtcbiAgICB9XG4gICAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyhwcm9wcywga2V5KSB7XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgIH1cbiAgICByZWFkVmFsdWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UsIGtleSkge1xuICAgICAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlID8gZGVmYXVsdFR5cGUuZGVmYXVsdCB8fCAwIDogMDtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSAhY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvcHMpIHtcbiAgICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCB0aGlzLmlzU1ZHVGFnLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJlbmRlckluc3RhbmNlKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIG1vdW50KGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuaXNTVkdUYWcgPSBpc1NWR1RhZyhpbnN0YW5jZS50YWdOYW1lKTtcbiAgICAgICAgc3VwZXIubW91bnQoaW5zdGFuY2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU1ZHVmlzdWFsRWxlbWVudCB9O1xuIiwiaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBIVE1MVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL2h0bWwvSFRNTFZpc3VhbEVsZW1lbnQubWpzJztcbmltcG9ydCB7IFNWR1Zpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi9zdmcvU1ZHVmlzdWFsRWxlbWVudC5tanMnO1xuaW1wb3J0IHsgaXNTVkdDb21wb25lbnQgfSBmcm9tICcuL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzJztcblxuY29uc3QgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCA9IChDb21wb25lbnQsIG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICA/IG5ldyBTVkdWaXN1YWxFbGVtZW50KG9wdGlvbnMpXG4gICAgICAgIDogbmV3IEhUTUxWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHtcbiAgICAgICAgICAgIGFsbG93UHJvamVjdGlvbjogQ29tcG9uZW50ICE9PSBGcmFnbWVudCxcbiAgICAgICAgfSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVEb21WaXN1YWxFbGVtZW50IH07XG4iLCJpbXBvcnQgeyBhbmltYXRpb25zIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICcuLi8uLi8uLi9tb3Rpb24vZmVhdHVyZXMvZHJhZy5tanMnO1xuaW1wb3J0IHsgZ2VzdHVyZUFuaW1hdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9tb3Rpb24vZmVhdHVyZXMvZ2VzdHVyZXMubWpzJztcbmltcG9ydCB7IGxheW91dCB9IGZyb20gJy4uLy4uLy4uL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQubWpzJztcbmltcG9ydCB7IGNyZWF0ZU1vdGlvbkNvbXBvbmVudEZhY3RvcnkgfSBmcm9tICcuLi9jcmVhdGUtZmFjdG9yeS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uLy4uL2RvbS9jcmVhdGUtdmlzdWFsLWVsZW1lbnQubWpzJztcblxuY29uc3QgY3JlYXRlTW90aW9uQ29tcG9uZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVNb3Rpb25Db21wb25lbnRGYWN0b3J5KHtcbiAgICAuLi5hbmltYXRpb25zLFxuICAgIC4uLmdlc3R1cmVBbmltYXRpb25zLFxuICAgIC4uLmRyYWcsXG4gICAgLi4ubGF5b3V0LFxufSwgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCk7XG5cbmV4cG9ydCB7IGNyZWF0ZU1vdGlvbkNvbXBvbmVudCB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkgfSBmcm9tICcuLi9jcmVhdGUtcHJveHkubWpzJztcbmltcG9ydCB7IGNyZWF0ZU1vdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vY3JlYXRlLm1qcyc7XG5cbmNvbnN0IG1vdGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkoY3JlYXRlTW90aW9uQ29tcG9uZW50KTtcblxuZXhwb3J0IHsgbW90aW9uIH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUlkLCB1c2VSZWYsIHVzZUNvbnRleHQsIHVzZUluc2VydGlvbkVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcblxuLyoqXG4gKiBNZWFzdXJlbWVudCBmdW5jdGlvbmFsaXR5IGhhcyB0byBiZSB3aXRoaW4gYSBzZXBhcmF0ZSBjb21wb25lbnRcbiAqIHRvIGxldmVyYWdlIHNuYXBzaG90IGxpZmVjeWNsZS5cbiAqL1xuY2xhc3MgUG9wQ2hpbGRNZWFzdXJlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJvcHMuY2hpbGRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgcHJldlByb3BzLmlzUHJlc2VudCAmJiAhdGhpcy5wcm9wcy5pc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IHBhcmVudC5vZmZzZXRXaWR0aCB8fCAwIDogMDtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnByb3BzLnNpemVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHNpemUuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIHNpemUud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgICAgICAgICBzaXplLnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgc2l6ZS5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICAgICAgc2l6ZS5yaWdodCA9IHBhcmVudFdpZHRoIC0gc2l6ZS53aWR0aCAtIHNpemUubGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWlyZWQgd2l0aCBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB0byBzdG9wIFJlYWN0IGNvbXBsYWluaW5nLlxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHsgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxufVxuZnVuY3Rpb24gUG9wQ2hpbGQoeyBjaGlsZHJlbiwgaXNQcmVzZW50LCBhbmNob3JYIH0pIHtcbiAgICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNpemUgPSB1c2VSZWYoe1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHJpZ2h0OiAwLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCk7XG4gICAgLyoqXG4gICAgICogV2UgY3JlYXRlIGFuZCBpbmplY3QgYSBzdHlsZSBibG9jayBzbyB3ZSBjYW4gYXBwbHkgdGhpcyBleHBsaWNpdFxuICAgICAqIHNpemluZyBpbiBhIG5vbi1kZXN0cnVjdGl2ZSBtYW5uZXIgYnkganVzdCBkZWxldGluZyB0aGUgc3R5bGUgYmxvY2suXG4gICAgICpcbiAgICAgKiBXZSBjYW4ndCBhcHBseSBzaXplIHZpYSByZW5kZXIgYXMgdGhlIG1lYXN1cmVtZW50IGhhcHBlbnNcbiAgICAgKiBpbiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAocG9zdC1yZW5kZXIpLCBsaWtld2lzZSBpZiB3ZSBhcHBseSB0aGVcbiAgICAgKiBzdHlsZXMgZGlyZWN0bHkgb24gdGhlIERPTSBub2RlLCB3ZSBtaWdodCBiZSBvdmVyd3JpdGluZ1xuICAgICAqIHN0eWxlcyBzZXQgdmlhIHRoZSBzdHlsZSBwcm9wLlxuICAgICAqL1xuICAgIHVzZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdG9wLCBsZWZ0LCByaWdodCB9ID0gc2l6ZS5jdXJyZW50O1xuICAgICAgICBpZiAoaXNQcmVzZW50IHx8ICFyZWYuY3VycmVudCB8fCAhd2lkdGggfHwgIWhlaWdodClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeCA9IGFuY2hvclggPT09IFwibGVmdFwiID8gYGxlZnQ6ICR7bGVmdH1gIDogYHJpZ2h0OiAke3JpZ2h0fWA7XG4gICAgICAgIHJlZi5jdXJyZW50LmRhdGFzZXQubW90aW9uUG9wSWQgPSBpZDtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgIGlmIChub25jZSlcbiAgICAgICAgICAgIHN0eWxlLm5vbmNlID0gbm9uY2U7XG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICBpZiAoc3R5bGUuc2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlLnNoZWV0Lmluc2VydFJ1bGUoYFxuICAgICAgICAgIFtkYXRhLW1vdGlvbi1wb3AtaWQ9XCIke2lkfVwiXSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGUgIWltcG9ydGFudDtcbiAgICAgICAgICAgIHdpZHRoOiAke3dpZHRofXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICBoZWlnaHQ6ICR7aGVpZ2h0fXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICAke3h9cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIHRvcDogJHt0b3B9cHggIWltcG9ydGFudDtcbiAgICAgICAgICB9XG4gICAgICAgIGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaXNQcmVzZW50XSk7XG4gICAgcmV0dXJuIChqc3goUG9wQ2hpbGRNZWFzdXJlLCB7IGlzUHJlc2VudDogaXNQcmVzZW50LCBjaGlsZFJlZjogcmVmLCBzaXplUmVmOiBzaXplLCBjaGlsZHJlbjogUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7IHJlZiB9KSB9KSk7XG59XG5cbmV4cG9ydCB7IFBvcENoaWxkIH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUlkLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgUG9wQ2hpbGQgfSBmcm9tICcuL1BvcENoaWxkLm1qcyc7XG5cbmNvbnN0IFByZXNlbmNlQ2hpbGQgPSAoeyBjaGlsZHJlbiwgaW5pdGlhbCwgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSwgY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQsIG1vZGUsIGFuY2hvclgsIH0pID0+IHtcbiAgICBjb25zdCBwcmVzZW5jZUNoaWxkcmVuID0gdXNlQ29uc3RhbnQobmV3Q2hpbGRyZW5NYXApO1xuICAgIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgICBjb25zdCBtZW1vaXplZE9uRXhpdENvbXBsZXRlID0gdXNlQ2FsbGJhY2soKGNoaWxkSWQpID0+IHtcbiAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgdHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgaXNDb21wbGV0ZSBvZiBwcmVzZW5jZUNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW4gc3RvcCBzZWFyY2hpbmcgd2hlbiBhbnkgaXMgaW5jb21wbGV0ZVxuICAgICAgICB9XG4gICAgICAgIG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKCk7XG4gICAgfSwgW3ByZXNlbmNlQ2hpbGRyZW4sIG9uRXhpdENvbXBsZXRlXSk7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRpYWwsXG4gICAgICAgIGlzUHJlc2VudCxcbiAgICAgICAgY3VzdG9tLFxuICAgICAgICBvbkV4aXRDb21wbGV0ZTogbWVtb2l6ZWRPbkV4aXRDb21wbGV0ZSxcbiAgICAgICAgcmVnaXN0ZXI6IChjaGlsZElkKSA9PiB7XG4gICAgICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLnNldChjaGlsZElkLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gcHJlc2VuY2VDaGlsZHJlbi5kZWxldGUoY2hpbGRJZCk7XG4gICAgICAgIH0sXG4gICAgfSksIFxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcmVzZW5jZSBvZiBhIGNoaWxkIGFmZmVjdHMgdGhlIGxheW91dCBvZiB0aGUgY29tcG9uZW50cyBhcm91bmQgaXQsXG4gICAgICogd2Ugd2FudCB0byBtYWtlIGEgbmV3IGNvbnRleHQgdmFsdWUgdG8gZW5zdXJlIHRoZXkgZ2V0IHJlLXJlbmRlcmVkXG4gICAgICogc28gdGhleSBjYW4gZGV0ZWN0IHRoYXQgbGF5b3V0IGNoYW5nZS5cbiAgICAgKi9cbiAgICBwcmVzZW5jZUFmZmVjdHNMYXlvdXRcbiAgICAgICAgPyBbTWF0aC5yYW5kb20oKSwgbWVtb2l6ZWRPbkV4aXRDb21wbGV0ZV1cbiAgICAgICAgOiBbaXNQcmVzZW50LCBtZW1vaXplZE9uRXhpdENvbXBsZXRlXSk7XG4gICAgdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uZm9yRWFjaCgoXywga2V5KSA9PiBwcmVzZW5jZUNoaWxkcmVuLnNldChrZXksIGZhbHNlKSk7XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3Mgbm8gYG1vdGlvbmAgY29tcG9uZW50cyB0byBmaXJlIGV4aXQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byByZW1vdmUgdGhpc1xuICAgICAqIGNvbXBvbmVudCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAhaXNQcmVzZW50ICYmXG4gICAgICAgICAgICAhcHJlc2VuY2VDaGlsZHJlbi5zaXplICYmXG4gICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJlxuICAgICAgICAgICAgb25FeGl0Q29tcGxldGUoKTtcbiAgICB9LCBbaXNQcmVzZW50XSk7XG4gICAgaWYgKG1vZGUgPT09IFwicG9wTGF5b3V0XCIpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAoanN4KFBvcENoaWxkLCB7IGlzUHJlc2VudDogaXNQcmVzZW50LCBhbmNob3JYOiBhbmNob3JYLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChQcmVzZW5jZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuZnVuY3Rpb24gbmV3Q2hpbGRyZW5NYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBNYXAoKTtcbn1cblxuZXhwb3J0IHsgUHJlc2VuY2VDaGlsZCB9O1xuIiwiaW1wb3J0IHsgQ2hpbGRyZW4sIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBnZXRDaGlsZEtleSA9IChjaGlsZCkgPT4gY2hpbGQua2V5IHx8IFwiXCI7XG5mdW5jdGlvbiBvbmx5RWxlbWVudHMoY2hpbGRyZW4pIHtcbiAgICBjb25zdCBmaWx0ZXJlZCA9IFtdO1xuICAgIC8vIFdlIHVzZSBmb3JFYWNoIGhlcmUgaW5zdGVhZCBvZiBtYXAgYXMgbWFwIG11dGF0ZXMgdGhlIGNvbXBvbmVudCBrZXkgYnkgcHJlcHJlbmRpbmcgYC4kYFxuICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaChjaGlsZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuXG5leHBvcnQgeyBnZXRDaGlsZEtleSwgb25seUVsZW1lbnRzIH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGpzeCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyc7XG5pbXBvcnQgeyBQcmVzZW5jZUNoaWxkIH0gZnJvbSAnLi9QcmVzZW5jZUNoaWxkLm1qcyc7XG5pbXBvcnQgeyB1c2VQcmVzZW5jZSB9IGZyb20gJy4vdXNlLXByZXNlbmNlLm1qcyc7XG5pbXBvcnQgeyBvbmx5RWxlbWVudHMsIGdldENoaWxkS2V5IH0gZnJvbSAnLi91dGlscy5tanMnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanMnO1xuXG4vKipcbiAqIGBBbmltYXRlUHJlc2VuY2VgIGVuYWJsZXMgdGhlIGFuaW1hdGlvbiBvZiBjb21wb25lbnRzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS5cbiAqXG4gKiBXaGVuIGFkZGluZy9yZW1vdmluZyBtb3JlIHRoYW4gYSBzaW5nbGUgY2hpbGQsIGV2ZXJ5IGNoaWxkICoqbXVzdCoqIGJlIGdpdmVuIGEgdW5pcXVlIGBrZXlgIHByb3AuXG4gKlxuICogQW55IGBtb3Rpb25gIGNvbXBvbmVudHMgdGhhdCBoYXZlIGFuIGBleGl0YCBwcm9wZXJ0eSBkZWZpbmVkIHdpbGwgYW5pbWF0ZSBvdXQgd2hlbiByZW1vdmVkIGZyb21cbiAqIHRoZSB0cmVlLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tICdmcmFtZXItbW90aW9uJ1xuICpcbiAqIGV4cG9ydCBjb25zdCBJdGVtcyA9ICh7IGl0ZW1zIH0pID0+IChcbiAqICAgPEFuaW1hdGVQcmVzZW5jZT5cbiAqICAgICB7aXRlbXMubWFwKGl0ZW0gPT4gKFxuICogICAgICAgPG1vdGlvbi5kaXZcbiAqICAgICAgICAga2V5PXtpdGVtLmlkfVxuICogICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxIH19XG4gKiAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCB9fVxuICogICAgICAgLz5cbiAqICAgICApKX1cbiAqICAgPC9BbmltYXRlUHJlc2VuY2U+XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIHNlcXVlbmNlIGV4aXQgYW5pbWF0aW9ucyB0aHJvdWdob3V0IGEgdHJlZSB1c2luZyB2YXJpYW50cy5cbiAqXG4gKiBJZiBhIGNoaWxkIGNvbnRhaW5zIG11bHRpcGxlIGBtb3Rpb25gIGNvbXBvbmVudHMgd2l0aCBgZXhpdGAgcHJvcHMsIGl0IHdpbGwgb25seSB1bm1vdW50IHRoZSBjaGlsZFxuICogb25jZSBhbGwgYG1vdGlvbmAgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIGFuaW1hdGluZyBvdXQuIExpa2V3aXNlLCBhbnkgY29tcG9uZW50cyB1c2luZ1xuICogYHVzZVByZXNlbmNlYCBhbGwgbmVlZCB0byBjYWxsIGBzYWZlVG9SZW1vdmVgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgQW5pbWF0ZVByZXNlbmNlID0gKHsgY2hpbGRyZW4sIGN1c3RvbSwgaW5pdGlhbCA9IHRydWUsIG9uRXhpdENvbXBsZXRlLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSB0cnVlLCBtb2RlID0gXCJzeW5jXCIsIHByb3BhZ2F0ZSA9IGZhbHNlLCBhbmNob3JYID0gXCJsZWZ0XCIsIH0pID0+IHtcbiAgICBjb25zdCBbaXNQYXJlbnRQcmVzZW50LCBzYWZlVG9SZW1vdmVdID0gdXNlUHJlc2VuY2UocHJvcGFnYXRlKTtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgYW55IGNoaWxkcmVuIHRoYXQgYXJlbid0IFJlYWN0RWxlbWVudHMuIFdlIGNhbiBvbmx5IHRyYWNrIGNvbXBvbmVudHNcbiAgICAgKiBiZXR3ZWVuIHJlbmRlcnMgd2l0aCBhIHByb3BzLmtleS5cbiAgICAgKi9cbiAgICBjb25zdCBwcmVzZW50Q2hpbGRyZW4gPSB1c2VNZW1vKCgpID0+IG9ubHlFbGVtZW50cyhjaGlsZHJlbiksIFtjaGlsZHJlbl0pO1xuICAgIC8qKlxuICAgICAqIFRyYWNrIHRoZSBrZXlzIG9mIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCB0b1xuICAgICAqIGRldGVybWluZSB3aGljaCBjaGlsZHJlbiBhcmUgZXhpdGluZy5cbiAgICAgKi9cbiAgICBjb25zdCBwcmVzZW50S2V5cyA9IHByb3BhZ2F0ZSAmJiAhaXNQYXJlbnRQcmVzZW50ID8gW10gOiBwcmVzZW50Q2hpbGRyZW4ubWFwKGdldENoaWxkS2V5KTtcbiAgICAvKipcbiAgICAgKiBJZiBgaW5pdGlhbD17ZmFsc2V9YCB3ZSBvbmx5IHdhbnQgdG8gcGFzcyB0aGlzIHRvIGNvbXBvbmVudHMgaW4gdGhlIGZpcnN0IHJlbmRlci5cbiAgICAgKi9cbiAgICBjb25zdCBpc0luaXRpYWxSZW5kZXIgPSB1c2VSZWYodHJ1ZSk7XG4gICAgLyoqXG4gICAgICogQSByZWYgY29udGFpbmluZyB0aGUgY3VycmVudGx5IHByZXNlbnQgY2hpbGRyZW4uIFdoZW4gYWxsIGV4aXQgYW5pbWF0aW9uc1xuICAgICAqIGFyZSBjb21wbGV0ZSwgd2UgdXNlIHRoaXMgdG8gcmUtcmVuZGVyIHRoZSBjb21wb25lbnQgd2l0aCB0aGUgbGF0ZXN0IGNoaWxkcmVuXG4gICAgICogKmNvbW1pdHRlZCogcmF0aGVyIHRoYW4gdGhlIGxhdGVzdCBjaGlsZHJlbiAqcmVuZGVyZWQqLlxuICAgICAqL1xuICAgIGNvbnN0IHBlbmRpbmdQcmVzZW50Q2hpbGRyZW4gPSB1c2VSZWYocHJlc2VudENoaWxkcmVuKTtcbiAgICAvKipcbiAgICAgKiBUcmFjayB3aGljaCBleGl0aW5nIGNoaWxkcmVuIGhhdmUgZmluaXNoZWQgYW5pbWF0aW5nIG91dC5cbiAgICAgKi9cbiAgICBjb25zdCBleGl0Q29tcGxldGUgPSB1c2VDb25zdGFudCgoKSA9PiBuZXcgTWFwKCkpO1xuICAgIC8qKlxuICAgICAqIFNhdmUgY2hpbGRyZW4gdG8gcmVuZGVyIGFzIFJlYWN0IHN0YXRlLiBUbyBlbnN1cmUgdGhpcyBjb21wb25lbnQgaXMgY29uY3VycmVudC1zYWZlLFxuICAgICAqIHdlIGNoZWNrIGZvciBleGl0aW5nIGNoaWxkcmVuIHZpYSBhbiBlZmZlY3QuXG4gICAgICovXG4gICAgY29uc3QgW2RpZmZlZENoaWxkcmVuLCBzZXREaWZmZWRDaGlsZHJlbl0gPSB1c2VTdGF0ZShwcmVzZW50Q2hpbGRyZW4pO1xuICAgIGNvbnN0IFtyZW5kZXJlZENoaWxkcmVuLCBzZXRSZW5kZXJlZENoaWxkcmVuXSA9IHVzZVN0YXRlKHByZXNlbnRDaGlsZHJlbik7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlci5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHBlbmRpbmdQcmVzZW50Q2hpbGRyZW4uY3VycmVudCA9IHByZXNlbnRDaGlsZHJlbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBjb21wbGV0ZSBzdGF0dXMgb2YgZXhpdGluZyBjaGlsZHJlbi5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0Q2hpbGRLZXkocmVuZGVyZWRDaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpZiAoIXByZXNlbnRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpdENvbXBsZXRlLmdldChrZXkpICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5zZXQoa2V5LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXhpdENvbXBsZXRlLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3JlbmRlcmVkQ2hpbGRyZW4sIHByZXNlbnRLZXlzLmxlbmd0aCwgcHJlc2VudEtleXMuam9pbihcIi1cIildKTtcbiAgICBjb25zdCBleGl0aW5nQ2hpbGRyZW4gPSBbXTtcbiAgICBpZiAocHJlc2VudENoaWxkcmVuICE9PSBkaWZmZWRDaGlsZHJlbikge1xuICAgICAgICBsZXQgbmV4dENoaWxkcmVuID0gWy4uLnByZXNlbnRDaGlsZHJlbl07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb29wIHRocm91Z2ggYWxsIHRoZSBjdXJyZW50bHkgcmVuZGVyZWQgY29tcG9uZW50cyBhbmQgZGVjaWRlIHdoaWNoXG4gICAgICAgICAqIGFyZSBleGl0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5baV07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRDaGlsZEtleShjaGlsZCk7XG4gICAgICAgICAgICBpZiAoIXByZXNlbnRLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBuZXh0Q2hpbGRyZW4uc3BsaWNlKGksIDAsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBleGl0aW5nQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIGluIFwid2FpdFwiIG1vZGUsIGFuZCB3ZSBoYXZlIGV4aXRpbmcgY2hpbGRyZW4sIHdlIHdhbnQgdG9cbiAgICAgICAgICogb25seSByZW5kZXIgdGhlc2UgdW50aWwgdGhleSd2ZSBhbGwgZXhpdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG1vZGUgPT09IFwid2FpdFwiICYmIGV4aXRpbmdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGV4aXRpbmdDaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICBzZXRSZW5kZXJlZENoaWxkcmVuKG9ubHlFbGVtZW50cyhuZXh0Q2hpbGRyZW4pKTtcbiAgICAgICAgc2V0RGlmZmVkQ2hpbGRyZW4ocHJlc2VudENoaWxkcmVuKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVhcmx5IHJldHVybiB0byBlbnN1cmUgb25jZSB3ZSd2ZSBzZXQgc3RhdGUgd2l0aCB0aGUgbGF0ZXN0IGRpZmZlZFxuICAgICAgICAgKiBjaGlsZHJlbiwgd2UgY2FuIGltbWVkaWF0ZWx5IHJlLXJlbmRlci5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJlxuICAgICAgICBtb2RlID09PSBcIndhaXRcIiAmJlxuICAgICAgICByZW5kZXJlZENoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBZb3UncmUgYXR0ZW1wdGluZyB0byBhbmltYXRlIG11bHRpcGxlIGNoaWxkcmVuIHdpdGhpbiBBbmltYXRlUHJlc2VuY2UsIGJ1dCBpdHMgbW9kZSBpcyBzZXQgdG8gXCJ3YWl0XCIuIFRoaXMgd2lsbCBsZWFkIHRvIG9kZCB2aXN1YWwgYmVoYXZpb3VyLmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSd2ZSBiZWVuIHByb3ZpZGVkIGEgZm9yY2VSZW5kZXIgZnVuY3Rpb24gYnkgdGhlIExheW91dEdyb3VwQ29udGV4dCxcbiAgICAgKiB3ZSBjYW4gdXNlIGl0IHRvIGZvcmNlIGEgcmUtcmVuZGVyIGFtb25nc3QgYWxsIHN1cnJvdW5kaW5nIGNvbXBvbmVudHMgb25jZVxuICAgICAqIGFsbCBjb21wb25lbnRzIGhhdmUgZmluaXNoZWQgYW5pbWF0aW5nIG91dC5cbiAgICAgKi9cbiAgICBjb25zdCB7IGZvcmNlUmVuZGVyIH0gPSB1c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgcmV0dXJuIChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IHJlbmRlcmVkQ2hpbGRyZW4ubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0Q2hpbGRLZXkoY2hpbGQpO1xuICAgICAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gcHJvcGFnYXRlICYmICFpc1BhcmVudFByZXNlbnRcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBwcmVzZW50Q2hpbGRyZW4gPT09IHJlbmRlcmVkQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudEtleXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpdENvbXBsZXRlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlzRXZlcnlFeGl0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5mb3JFYWNoKChpc0V4aXRDb21wbGV0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXhpdENvbXBsZXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVyeUV4aXRDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0V2ZXJ5RXhpdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyID09PSBudWxsIHx8IGZvcmNlUmVuZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSZW5kZXJlZENoaWxkcmVuKHBlbmRpbmdQcmVzZW50Q2hpbGRyZW4uY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSAmJiAoc2FmZVRvUmVtb3ZlID09PSBudWxsIHx8IHNhZmVUb1JlbW92ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2FmZVRvUmVtb3ZlKCkpO1xuICAgICAgICAgICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGpzeChQcmVzZW5jZUNoaWxkLCB7IGlzUHJlc2VudDogaXNQcmVzZW50LCBpbml0aWFsOiAhaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgfHwgaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICA6IGZhbHNlLCBjdXN0b206IGlzUHJlc2VudCA/IHVuZGVmaW5lZCA6IGN1c3RvbSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0OiBwcmVzZW5jZUFmZmVjdHNMYXlvdXQsIG1vZGU6IG1vZGUsIG9uRXhpdENvbXBsZXRlOiBpc1ByZXNlbnQgPyB1bmRlZmluZWQgOiBvbkV4aXQsIGFuY2hvclg6IGFuY2hvclgsIGNoaWxkcmVuOiBjaGlsZCB9LCBrZXkpKTtcbiAgICAgICAgfSkgfSkpO1xufTtcblxuZXhwb3J0IHsgQW5pbWF0ZVByZXNlbmNlIH07XG4iLCJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBGaWxlV2l0aFByZXZpZXcgZXh0ZW5kcyBGaWxlIHtcbiAgcHJldmlldz86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIEZpbGVVcGxvYWRDb250ZXh0VHlwZSB7XG4gIGZpbGU6IEZpbGVXaXRoUHJldmlldyB8IG51bGw7XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBhZGRGaWxlOiAobmV3RmlsZTogRmlsZUxpc3QgfCBGaWxlW10pID0+IHZvaWQ7XG4gIHJlbW92ZUZpbGU6ICgpID0+IHZvaWQ7XG4gIGNsZWFyRmlsZTogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgRmlsZVVwbG9hZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PEZpbGVVcGxvYWRDb250ZXh0VHlwZSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZpbGVVcGxvYWQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KEZpbGVVcGxvYWRDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUZpbGVVcGxvYWQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEZpbGVVcGxvYWRQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuaW50ZXJmYWNlIEZpbGVVcGxvYWRQcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbWF4U2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZpbGVVcGxvYWRQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBtYXhTaXplID0gNDUgKiAxMDI0LCAvLyA0NUtCIGRlZmF1bHRcbn06IEZpbGVVcGxvYWRQcm92aWRlclByb3BzKSB7XG4gIGNvbnN0IFtmaWxlLCBzZXRGaWxlXSA9IHVzZVN0YXRlPEZpbGVXaXRoUHJldmlldyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IHZhbGlkYXRlRmlsZSA9IHVzZUNhbGxiYWNrKFxuICAgIChmaWxlOiBGaWxlKTogYm9vbGVhbiA9PiB7XG4gICAgICBjb25zdCB2YWxpZFR5cGVzID0gW1wiaW1hZ2UvanBlZ1wiLCBcImltYWdlL3BuZ1wiLCBcImltYWdlL3BkZ1wiLCBcInZpZGVvL21wNFwiXTtcbiAgICAgIGlmICghdmFsaWRUeXBlcy5pbmNsdWRlcyhmaWxlLnR5cGUpKSB7XG4gICAgICAgIHNldEVycm9yKFwiRmlsZSB0eXBlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWxlLnNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgIHNldEVycm9yKFwiRmlsZSBzaXplIGV4Y2VlZHMgNDVLQiBsaW1pdFwiKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBbbWF4U2l6ZV1cbiAgKTtcblxuICBjb25zdCBhZGRGaWxlID0gdXNlQ2FsbGJhY2soXG4gICAgKG5ld0ZpbGVzOiBGaWxlTGlzdCB8IEZpbGVbXSkgPT4ge1xuICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAvLyBTZSB0b21hIHNvbG8gZWwgcHJpbWVyIGFyY2hpdm9cbiAgICAgIGNvbnN0IGZpbGVUb0FkZCA9IEFycmF5LmZyb20obmV3RmlsZXMpWzBdO1xuICAgICAgaWYgKCF2YWxpZGF0ZUZpbGUoZmlsZVRvQWRkKSkgcmV0dXJuO1xuXG4gICAgICBsZXQgZmlsZVdpdGhQcmV2aWV3OiBGaWxlV2l0aFByZXZpZXcgPSBmaWxlVG9BZGQ7XG4gICAgICBpZiAoZmlsZVRvQWRkLnR5cGUuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICBmaWxlV2l0aFByZXZpZXcgPSBPYmplY3QuYXNzaWduKGZpbGVUb0FkZCwge1xuICAgICAgICAgIHByZXZpZXc6IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZVRvQWRkKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBTaSB5YSBleGlzdGUgdW4gYXJjaGl2bywgc2UgcmV2b2NhIHN1IFVSTCBkZSBwcmV2aWV3XG4gICAgICBpZiAoZmlsZSAmJiBmaWxlLnByZXZpZXcpIHtcbiAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChmaWxlLnByZXZpZXcpO1xuICAgICAgfVxuICAgICAgc2V0RmlsZShmaWxlV2l0aFByZXZpZXcpO1xuICAgIH0sXG4gICAgW3ZhbGlkYXRlRmlsZSwgZmlsZV1cbiAgKTtcblxuICBjb25zdCByZW1vdmVGaWxlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChmaWxlICYmIGZpbGUucHJldmlldykge1xuICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChmaWxlLnByZXZpZXcpO1xuICAgIH1cbiAgICBzZXRGaWxlKG51bGwpO1xuICB9LCBbZmlsZV0pO1xuXG4gIGNvbnN0IGNsZWFyRmlsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoZmlsZSAmJiBmaWxlLnByZXZpZXcpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZS5wcmV2aWV3KTtcbiAgICB9XG4gICAgc2V0RmlsZShudWxsKTtcbiAgfSwgW2ZpbGVdKTtcblxuICByZXR1cm4gKFxuICAgIDxGaWxlVXBsb2FkQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgZmlsZSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGFkZEZpbGUsXG4gICAgICAgIHJlbW92ZUZpbGUsXG4gICAgICAgIGNsZWFyRmlsZSxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvRmlsZVVwbG9hZENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBVcGxvYWRJY29uUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBVcGxvYWRJY29uOiBSZWFjdC5GQzxVcGxvYWRJY29uUHJvcHM+ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB3aWR0aD1cIjQ2XCJcbiAgICAgIGhlaWdodD1cIjQ3XCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgNDYgNDdcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTE0LjI5OTEgMzcuNTY4NUgxMC42MTlDNC45ODQgMzcuMTY2IDIuNDU0MSAzMi44MzQzIDIuNDU0MSAyOC45ODE4QzIuNDU0MSAyNS4xMjkzIDQuOTg0MDMgMjAuNzc4NSAxMC41MjMyIDIwLjM5NTFDMTEuMzA5IDIwLjMxODUgMTEuOTk5IDIwLjkzMTggMTIuMDU2NSAyMS43MzY4QzEyLjExNCAyMi41MjI2IDExLjUxOTkgMjMuMjEyNiAxMC43MTQ5IDIzLjI3MDFDNi45OTY2IDIzLjUzODUgNS4zMjkxIDI2LjMzNjggNS4zMjkxIDI5LjAwMUM1LjMyOTEgMzEuNjY1MSA2Ljk5NjYgMzQuNDYzNSAxMC43MTQ5IDM0LjczMThIMTQuMjk5MUMxNS4wODQ5IDM0LjczMTggMTUuNzM2NiAzNS4zODM1IDE1LjczNjYgMzYuMTY5M0MxNS43MzY2IDM2Ljk1NTEgMTUuMDg0OSAzNy41Njg1IDE0LjI5OTEgMzcuNTY4NVpcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTMxLjk1MDcgMzcuNTY4MkMzMS45MTI0IDM3LjU2ODIgMzEuODkzMiAzNy41NjgyIDMxLjg1NDkgMzcuNTY4MkMzMS4wNjkxIDM3LjU2ODIgMzAuMzQwOCAzNi45MTY2IDMwLjM0MDggMzYuMTMwN0MzMC4zNDA4IDM1LjMwNjYgMzAuOTU0MSAzNC42OTMyIDMxLjc1OTEgMzQuNjkzMkMzNC4xMTY2IDM0LjY5MzIgMzYuMjI0OSAzMy44NjkxIDM3Ljg3MzMgMzIuMzkzM0M0MC44NjMzIDI5Ljc4NjYgNDEuMDU0OSAyNi4wMjk5IDQwLjI0OTkgMjMuMzg0OUMzOS40NDQ5IDIwLjc1OTEgMzcuMjAyNCAxNy43NDk5IDMzLjI5MjQgMTcuMjcwOEMzMi42NTk5IDE3LjE5NDEgMzIuMTYxNSAxNi43MTQ5IDMyLjA0NjUgMTYuMDgyNEMzMS4yNzk5IDExLjQ4MjQgMjguODA3NCA4LjMwMDc2IDI1LjA1MDggNy4xNTA3NkMyMS4xNzkxIDUuOTQzMjYgMTYuNjU1NyA3LjEzMTU5IDEzLjgzODIgMTAuMDgzM0MxMS4wOTc0IDEyLjkzOTEgMTAuNDY0OSAxNi45NDQ5IDEyLjA1NTcgMjEuMzUzM0MxMi4zMjQgMjIuMTAwOCAxMS45NDA4IDIyLjkyNDkgMTEuMTkzMyAyMy4xOTMyQzEwLjQ0NTggMjMuNDYxNiA5LjYyMTU5IDIzLjA3ODMgOS4zNTMyNiAyMi4zMzA4QzcuNDE3NDMgMTYuOTI1OCA4LjI5OTExIDExLjc1MDggMTEuNzY4MyA4LjEwOTA5QzE1LjMxNDEgNC4zOTA3NiAyMS4wMDY2IDIuOTE0OTEgMjUuODk0MSA0LjQwOTkxQzMwLjM3OTEgNS43ODk5MSAzMy41NDE1IDkuNDg5MDggMzQuNjkxNSAxNC42MjU3QzM4LjYwMTUgMTUuNTA3NCA0MS43NDQ5IDE4LjQ3ODMgNDIuOTkwNyAyMi41Nzk5QzQ0LjM1MTYgMjcuMDQ1OCA0My4xMjQ5IDMxLjY0NTggMzkuNzcwNyAzNC41NTkxQzM3LjY0MzIgMzYuNDc1OCAzNC44NjQgMzcuNTY4MiAzMS45NTA3IDM3LjU2ODJaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0yMi45OTk4IDQzLjIwMzNDMTkuMTQ3MyA0My4yMDMzIDE1LjU0NCA0MS4xNTI0IDEzLjU2OTkgMzcuODM2NkMxMy4zNTkgMzcuNTEwOCAxMy4xNDgyIDM3LjEyNzUgMTIuOTc1NyAzNi43MDU4QzEyLjMyNCAzNS4zNDUgMTEuOTc5IDMzLjc5MjUgMTEuOTc5IDMyLjE4MjVDMTEuOTc5IDI2LjEwNjYgMTYuOTI0IDIxLjE2MTYgMjIuOTk5OCAyMS4xNjE2QzI5LjA3NTcgMjEuMTYxNiAzNC4wMjA3IDI2LjEwNjYgMzQuMDIwNyAzMi4xODI1QzM0LjAyMDcgMzMuODExNiAzMy42NzU3IDM1LjM0NSAzMi45ODU3IDM2Ljc2MzNDMzIuODMyNCAzNy4xMjc1IDMyLjYyMTYgMzcuNTEwOCAzMi4zOTE2IDM3Ljg3NUMzMC40NTU3IDQxLjE1MjUgMjYuODUyMyA0My4yMDMzIDIyLjk5OTggNDMuMjAzM1pNMjIuOTk5OCAyNC4wMzY2QzE4LjUxNDggMjQuMDM2NiAxNC44NTQgMjcuNjk3NSAxNC44NTQgMzIuMTgyNUMxNC44NTQgMzMuMzcwOCAxNS4xMDMyIDM0LjQ4MjQgMTUuNTgyMyAzNS40OTgzQzE1LjczNTcgMzUuODI0MSAxNS44Njk4IDM2LjA5MjUgMTYuMDIzMSAzNi4zNDE2QzE3LjQ3OTggMzguODE0MSAyMC4xNDQgNDAuMzI4MyAyMi45ODA3IDQwLjMyODNDMjUuODE3MyA0MC4zMjgzIDI4LjQ4MTUgMzguODE0MSAyOS45MTkgMzYuMzhDMzAuMDkxNSAzNi4wOTI1IDMwLjI0NDkgMzUuODI0MSAzMC4zNTk5IDM1LjU1NThDMzAuODc3NCAzNC41MDE2IDMxLjEyNjUgMzMuMzg5OSAzMS4xMjY1IDMyLjIwMTZDMzEuMTQ1NyAyNy42OTc0IDI3LjQ4NDggMjQuMDM2NiAyMi45OTk4IDI0LjAzNjZaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0yMS45MDc0IDM1LjUxNzVDMjEuNTQzMiAzNS41MTc1IDIxLjE3OTEgMzUuMzgzNCAyMC44OTE2IDM1LjA5NTlMMTguOTk0IDMzLjE5ODRDMTguNDM4MiAzMi42NDI1IDE4LjQzODIgMzEuNzIyNSAxOC45OTQgMzEuMTY2N0MxOS41NDk5IDMwLjYxMDkgMjAuNDY5OSAzMC42MTA5IDIxLjAyNTcgMzEuMTY2N0wyMS45NDU4IDMyLjA4NjdMMjUuMDEyNCAyOS4yNUMyNS42MDY2IDI4LjcxMzQgMjYuNTA3NCAyOC43NTE3IDI3LjA0NCAyOS4zMjY3QzI3LjU4MDcgMjkuOTAxNyAyNy41NDI0IDMwLjgyMTcgMjYuOTY3NCAzMS4zNTg0TDIyLjg4NDkgMzUuMTM0MkMyMi41OTc0IDM1LjM4MzQgMjIuMjUyNCAzNS41MTc1IDIxLjkwNzQgMzUuNTE3NVpcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIiwiLy8gVHhTdGF0dXNDb250ZXh0LnRzeFxuXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBUeFN0YXR1cyB7XG4gIGlzUHJvY2Vzc2luZzogYm9vbGVhbjtcbiAgY3VycmVudFN0ZXA6IHN0cmluZztcbiAgbmV4dFN0ZXA6IHN0cmluZyB8IG51bGw7XG59XG5cbmludGVyZmFjZSBUeFN0YXR1c0NvbnRleHRUeXBlIHtcbiAgcHJlcGFyYXRpb246IFR4U3RhdHVzO1xuICBpbnNjcmlwdGlvbjogVHhTdGF0dXM7XG4gIHNldFByZXBhcmF0aW9uU3RhdHVzOiAoc3RhdHVzOiBQYXJ0aWFsPFR4U3RhdHVzPikgPT4gdm9pZDtcbiAgc2V0SW5zY3JpcHRpb25TdGF0dXM6IChzdGF0dXM6IFBhcnRpYWw8VHhTdGF0dXM+KSA9PiB2b2lkO1xuICBtb3ZlVG9OZXh0U3RlcDogKGZsb3c6IFwicHJlcGFyYXRpb25cIiB8IFwiaW5zY3JpcHRpb25cIiB8IFwiZW5kXCIpID0+IHZvaWQ7XG4gIHJlc2V0U3RhdHVzOiAoZmxvdzogXCJwcmVwYXJhdGlvblwiIHwgXCJpbnNjcmlwdGlvblwiKSA9PiB2b2lkO1xufVxuXG5jb25zdCBUeFN0YXR1c0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFR4U3RhdHVzQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBjb25zdCBUeFN0YXR1c1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pID0+IHtcbiAgY29uc3QgW3ByZXBhcmF0aW9uLCBzZXRQcmVwYXJhdGlvbl0gPSB1c2VTdGF0ZTxUeFN0YXR1cz4oe1xuICAgIGlzUHJvY2Vzc2luZzogZmFsc2UsXG4gICAgY3VycmVudFN0ZXA6IFwicHJlcGFyZS9jb25zdHJ1Y3RcIixcbiAgICBuZXh0U3RlcDogXCJwcmVwYXJlL3JldHJpZXZlXCIsXG4gIH0pO1xuXG4gIGNvbnN0IFtpbnNjcmlwdGlvbiwgc2V0SW5zY3JpcHRpb25dID0gdXNlU3RhdGU8VHhTdGF0dXM+KHtcbiAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIGN1cnJlbnRTdGVwOiBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiLFxuICAgIG5leHRTdGVwOiBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIsXG4gIH0pO1xuXG4gIGNvbnN0IHNldFByZXBhcmF0aW9uU3RhdHVzID0gdXNlQ2FsbGJhY2soKHN0YXR1czogUGFydGlhbDxUeFN0YXR1cz4pID0+IHtcbiAgICBzZXRQcmVwYXJhdGlvbigocHJldikgPT4gKHsgLi4ucHJldiwgLi4uc3RhdHVzIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNldEluc2NyaXB0aW9uU3RhdHVzID0gdXNlQ2FsbGJhY2soKHN0YXR1czogUGFydGlhbDxUeFN0YXR1cz4pID0+IHtcbiAgICBzZXRJbnNjcmlwdGlvbigocHJldikgPT4gKHsgLi4ucHJldiwgLi4uc3RhdHVzIH0pKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IG1vdmVUb05leHRTdGVwID0gKGZsb3c6IFwicHJlcGFyYXRpb25cIiB8IFwiaW5zY3JpcHRpb25cIiB8IFwiZW5kXCIpID0+IHtcbiAgICBpZiAoZmxvdyA9PT0gXCJwcmVwYXJhdGlvblwiICYmIHByZXBhcmF0aW9uLm5leHRTdGVwKSB7XG4gICAgICBjb25zdCBuZXh0U3RlcE1hcDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudWxsIH0gPSB7XG4gICAgICAgIFwicHJlcGFyZS9jb25zdHJ1Y3RcIjogXCJwcmVwYXJlL3JldHJpZXZlXCIsXG4gICAgICAgIFwicHJlcGFyZS9yZXRyaWV2ZVwiOiBcInByZXBhcmUvc3VibWl0XCIsXG4gICAgICAgIFwicHJlcGFyZS9zdWJtaXRcIjogXCJwcmVwYXJlL3JldHJpZXZlLXN1Ym1pc3Npb25cIixcbiAgICAgICAgXCJwcmVwYXJlL3JldHJpZXZlLXN1Ym1pc3Npb25cIjogbnVsbCxcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXJyZW50U3RlcCA9IHByZXBhcmF0aW9uLm5leHRTdGVwO1xuICAgICAgY29uc3QgbmV4dFN0ZXAgPSBuZXh0U3RlcE1hcFtjdXJyZW50U3RlcF07XG4gICAgICBzZXRQcmVwYXJhdGlvblN0YXR1cyh7IGN1cnJlbnRTdGVwLCBuZXh0U3RlcCB9KTtcbiAgICB9IGVsc2UgaWYgKGZsb3cgPT09IFwiaW5zY3JpcHRpb25cIiAmJiBpbnNjcmlwdGlvbi5uZXh0U3RlcCkge1xuICAgICAgY29uc3QgbmV4dFN0ZXBNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVsbCB9ID0ge1xuICAgICAgICBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiOiBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIsXG4gICAgICAgIFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIjogXCJpbnNjcmlwdGlvbi9zdWJtaXRcIixcbiAgICAgICAgXCJpbnNjcmlwdGlvbi9zdWJtaXRcIjogXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZS1zdWJtaXNzaW9uXCIsXG4gICAgICAgIFwiaW5zY3JpcHRpb24vcmV0cmlldmUtc3VibWlzc2lvblwiOiBudWxsLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gaW5zY3JpcHRpb24ubmV4dFN0ZXA7XG4gICAgICBjb25zdCBuZXh0U3RlcCA9IG5leHRTdGVwTWFwW2N1cnJlbnRTdGVwXTtcbiAgICAgIHNldEluc2NyaXB0aW9uU3RhdHVzKHsgY3VycmVudFN0ZXAsIG5leHRTdGVwIH0pO1xuICAgIH0gZWxzZSBpZiAoZmxvdyA9PT0gXCJlbmRcIikge1xuICAgICAgLy8gQWwgbGxlZ2FyIGFsIGZpbmFsLCByZWluaWNpYW1vcyBsb3MgZXN0YWRvc1xuICAgICAgc2V0UHJlcGFyYXRpb24oe1xuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICBjdXJyZW50U3RlcDogXCJwcmVwYXJlL2NvbnN0cnVjdFwiLFxuICAgICAgICBuZXh0U3RlcDogXCJwcmVwYXJlL3JldHJpZXZlXCIsXG4gICAgICB9KTtcbiAgICAgIHNldEluc2NyaXB0aW9uKHtcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFN0ZXA6IFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCIsXG4gICAgICAgIG5leHRTdGVwOiBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVzZXRTdGF0dXMgPSAoZmxvdzogXCJwcmVwYXJhdGlvblwiIHwgXCJpbnNjcmlwdGlvblwiKSA9PiB7XG4gICAgaWYgKGZsb3cgPT09IFwicHJlcGFyYXRpb25cIikge1xuICAgICAgc2V0UHJlcGFyYXRpb24oe1xuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICBjdXJyZW50U3RlcDogXCJwcmVwYXJlL2NvbnN0cnVjdFwiLFxuICAgICAgICBuZXh0U3RlcDogXCJwcmVwYXJlL3JldHJpZXZlXCIsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0SW5zY3JpcHRpb24oe1xuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgICAgICBjdXJyZW50U3RlcDogXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIixcbiAgICAgICAgbmV4dFN0ZXA6IFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIixcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxUeFN0YXR1c0NvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIHByZXBhcmF0aW9uLFxuICAgICAgICBpbnNjcmlwdGlvbixcbiAgICAgICAgc2V0UHJlcGFyYXRpb25TdGF0dXMsXG4gICAgICAgIHNldEluc2NyaXB0aW9uU3RhdHVzLFxuICAgICAgICBtb3ZlVG9OZXh0U3RlcCxcbiAgICAgICAgcmVzZXRTdGF0dXMsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1R4U3RhdHVzQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBjb25zdCB1c2VUeFN0YXR1cyA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVHhTdGF0dXNDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlVHhTdGF0dXMgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFR4U3RhdHVzUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59OyIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtb3Rpb24sIEFuaW1hdGVQcmVzZW5jZSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5pbXBvcnQgeyB1c2VGaWxlVXBsb2FkIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvRmlsZVVwbG9hZENvbnRleHRcIjtcbmltcG9ydCB7IFVwbG9hZEljb24gfSBmcm9tIFwiLi4vLi4vaWNvbnMvVXBsb2FkSWNvblwiO1xuaW1wb3J0IHsgdXNlVHhTdGF0dXMgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeFN0YXR1c0NvbnRleHRcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIFVwbG9hZEJveCgpIHtcbiAgY29uc3QgeyBhZGRGaWxlLCBlcnJvciB9ID0gdXNlRmlsZVVwbG9hZCgpO1xuICBjb25zdCBbaXNEcmFnZ2luZywgc2V0SXNEcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkcmFnQ291bnRlciwgc2V0RHJhZ0NvdW50ZXJdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IHsgcHJlcGFyYXRpb24gfSA9IHVzZVR4U3RhdHVzKCk7XG5cbiAgY29uc3QgaGFuZGxlRHJhZ0VudGVyID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LkRyYWdFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNldERyYWdDb3VudGVyKChwcmV2KSA9PiBwcmV2ICsgMSk7XG4gICAgc2V0SXNEcmFnZ2luZyh0cnVlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZURyYWdMZWF2ZSA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBzZXREcmFnQ291bnRlcigocHJldikgPT4gcHJldiAtIDEpO1xuICAgICAgaWYgKGRyYWdDb3VudGVyID09PSAwKSB7XG4gICAgICAgIHNldElzRHJhZ2dpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2RyYWdDb3VudGVyXVxuICApO1xuXG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LkRyYWdFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgaGFuZGxlRHJvcCA9IHVzZUNhbGxiYWNrKFxuICAgIChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgICAgIHNldERyYWdDb3VudGVyKDApO1xuXG4gICAgICBjb25zdCB7IGZpbGVzIH0gPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlc1swXTtcbiAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IDQ1ICogMTAyNCkge1xuICAgICAgICAgIC8vIDQ1S0IgaW4gYnl0ZXNcbiAgICAgICAgICBhbGVydChcIkZpbGUgdG9vIGJpZ1wiKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYWRkRmlsZShmaWxlcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbYWRkRmlsZV1cbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxtb3Rpb24uZGl2XG4gICAgICBjbGFzc05hbWU9e2ByZWxhdGl2ZSBib3JkZXItMiBib3JkZXItZGFzaGVkIGJvcmRlci13aGl0ZSByb3VuZGVkLTN4bCBwLTEyIHRleHQtY2VudGVyIHRyYW5zaXRpb24tYWxsICR7XG4gICAgICAgIGlzRHJhZ2dpbmcgPyBcImJnLXdoaXRlLzIwXCIgOiBcIlwiXG4gICAgICB9YH1cbiAgICAgIG9uRHJhZ0VudGVyPXtoYW5kbGVEcmFnRW50ZXJ9XG4gICAgICBvbkRyYWdMZWF2ZT17aGFuZGxlRHJhZ0xlYXZlfVxuICAgICAgb25EcmFnT3Zlcj17aGFuZGxlRHJhZ092ZXJ9XG4gICAgICBvbkRyb3A9e2hhbmRsZURyb3B9XG4gICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHk6IDIwIH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEsIHk6IDAgfX1cbiAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuNSB9fVxuICAgID5cbiAgICAgIDxpbnB1dFxuICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgIGlkPVwiZmlsZS11cGxvYWRcIlxuICAgICAgICBjbGFzc05hbWU9e2BhYnNvbHV0ZSBpbnNldC0wIHctZnVsbCBoLWZ1bGwgb3BhY2l0eS0wICR7XG4gICAgICAgICAgcHJlcGFyYXRpb24uY3VycmVudFN0ZXAgPT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwiXG4gICAgICAgICAgICA/IFwiY3Vyc29yLXBvaW50ZXJcIlxuICAgICAgICAgICAgOiBcImN1cnNvci1ub3QtYWxsb3dlZFwiXG4gICAgICAgIH0gYH1cbiAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiB7XG4gICAgICAgICAgaWYgKGUudGFyZ2V0LmZpbGVzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gZS50YXJnZXQuZmlsZXNbMF07XG4gICAgICAgICAgICBpZiAoZmlsZSAmJiBmaWxlLnNpemUgPiA0NSAqIDEwMjQpIHtcbiAgICAgICAgICAgICAgLy8gNDVLQiBpbiBieXRlc1xuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZEZpbGUoZS50YXJnZXQuZmlsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgYWNjZXB0PVwiLmpwZywuanBlZywucG5nLC5wZGcsLm1wNFwiXG4gICAgICAgIGRpc2FibGVkPXtwcmVwYXJhdGlvbi5jdXJyZW50U3RlcCAhPSBcInByZXBhcmUvY29uc3RydWN0XCJ9XG4gICAgICAvPlxuXG4gICAgICA8bW90aW9uLmRpdlxuICAgICAgICBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtNlwiXG4gICAgICAgIHdoaWxlSG92ZXI9e3sgc2NhbGU6IDEuMDUgfX1cbiAgICAgICAgdHJhbnNpdGlvbj17eyB0eXBlOiBcInNwcmluZ1wiLCBzdGlmZm5lc3M6IDMwMCB9fVxuICAgICAgPlxuICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cInctWzIuODc1cmVtXSBoLVsyLjg3NXJlbV0gcm91bmRlZC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCJcbiAgICAgICAgICB3aGlsZUhvdmVyPXt7IHJvdGF0ZTogMzYwIH19XG4gICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC41IH19XG4gICAgICAgID5cbiAgICAgICAgICA8VXBsb2FkSWNvbiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIHRleHQtd2hpdGVcIiAvPlxuICAgICAgICA8L21vdGlvbi5kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00XCI+XG4gICAgICAgICAgPEFuaW1hdGVQcmVzZW5jZSBtb2RlPVwid2FpdFwiPlxuICAgICAgICAgICAge2lzRHJhZ2dpbmcgPyAoXG4gICAgICAgICAgICAgIDxtb3Rpb24ucFxuICAgICAgICAgICAgICAgIGtleT1cImRyYWdnaW5nXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LW1lZGl1bSAhdGV4dC13aGl0ZVwiXG4gICAgICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB5OiAxMCB9fVxuICAgICAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeTogMCB9fVxuICAgICAgICAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCwgeTogLTEwIH19XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4yIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBEcm9wIGhlcmUgeW91ciBmaWxlXG4gICAgICAgICAgICAgIDwvbW90aW9uLnA+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8bW90aW9uLnBcbiAgICAgICAgICAgICAgICBrZXk9XCJub3QtZHJhZ2dpbmdcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtMnhsICF0ZXh0LXdoaXRlIGZvbnQtbWVkaXVtXCJcbiAgICAgICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHk6IDEwIH19XG4gICAgICAgICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxLCB5OiAwIH19XG4gICAgICAgICAgICAgICAgZXhpdD17eyBvcGFjaXR5OiAwLCB5OiAtMTAgfX1cbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjIgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIENob29zZSBhIGZpbGUgb3IgZHJhZyAmIGRyb3AgaXQgaGVyZVxuICAgICAgICAgICAgICA8L21vdGlvbi5wPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L0FuaW1hdGVQcmVzZW5jZT5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWJhc2UgdGV4dC1saWdodFwiPlxuICAgICAgICAgICAgSlBFRywgUE5HLCBQREcsIGFuZCBNUDQgZm9ybWF0cywgdXAgdG8gNDVLQlxuICAgICAgICAgIDwvcD5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAge2Vycm9yICYmIChcbiAgICAgICAgICA8bW90aW9uLnBcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtcmVkLTUwMCB0ZXh0LXNtXCJcbiAgICAgICAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCB9fVxuICAgICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxIH19XG4gICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjMgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICB7ZXJyb3J9XG4gICAgICAgICAgPC9tb3Rpb24ucD5cbiAgICAgICAgKX1cbiAgICAgIDwvbW90aW9uLmRpdj5cbiAgICA8L21vdGlvbi5kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDb250ZXh0LFxuICB1c2VTdGF0ZSxcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUVmZmVjdCxcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIENvbm5lY3RlZFdhbGxldCxcbiAgQWxsU3VwcG9ydGVkV2FsbGV0cyxcbiAgVFdhbGxldEFQSSxcbn0gZnJvbSBcIi4uL3R5cGVzL2NhcmRhbm9cIjtcblxuY29uc3QgYWxsU3VwcG9ydGVkV2FsbGV0czogQWxsU3VwcG9ydGVkV2FsbGV0cyA9IHtcbiAgLyogICB5b3JvaToge1xuICAgIG5hbWU6IFwiWW9yb2lcIixcbiAgICBpY29uOiBcImh0dHBzOi8vdXBsb2Fkcy1zc2wud2ViZmxvdy5jb20vNjZjM2I3Nzk2NzQ5MTVjMjg4Y2E5OTk4LzY2Yzk1ZWZiZWQ5YWJkZjljZjdlMDFkNF9Zb3JvaVdhbGxldC5wbmdcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly95b3JvaS13YWxsZXQuY29tL1wiLFxuICB9LCAqL1xuLyogICBmbGludDoge1xuICAgIG5hbWU6IFwiRmxpbnRcIixcbiAgICBpY29uOiBcImh0dHBzOi8vdXBsb2Fkcy1zc2wud2ViZmxvdy5jb20vNjZjM2I3Nzk2NzQ5MTVjMjg4Y2E5OTk4LzY2Yzk1ZDdjNWZiMDNmMmQ0YjMyYjNlZF9GbGludFdhbGxldC5zdmdcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9mbGludC13YWxsZXQuY29tL1wiLFxuICB9LFxuXG4gIGV0ZXJubDoge1xuICAgIG5hbWU6IFwiRXRlcm5sXCIsXG4gICAgaWNvbjogXCJodHRwczovL3VwbG9hZHMtc3NsLndlYmZsb3cuY29tLzY2YzNiNzc5Njc0OTE1YzI4OGNhOTk5OC82NmM5NWVmY2EwZWJlY2ZlZGZjYTg1OTlfRXRlcm5sV2FsbGV0LnBuZ1wiLFxuICAgIHVybDogXCJodHRwczovL2V0ZXJubC5pby9cIixcbiAgfSwgKi9cbiAgZ2Vybzoge1xuICAgIG5hbWU6IFwiR2Vyb1wiLFxuICAgIGljb246IFwiaHR0cHM6Ly91cGxvYWRzLXNzbC53ZWJmbG93LmNvbS82NmMzYjc3OTY3NDkxNWMyODhjYTk5OTgvNjZjOTVlZmI5MWQ1NDJlNjQzYmY1ZWQ0X0dlcm9XYWxsZXQucG5nXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZ2Vyb3dhbGxldC5pby9cIixcbiAgfSxcbiAgbnVmaToge1xuICAgIG5hbWU6IFwiTnVmaVwiLFxuICAgIGljb246IFwiaHR0cHM6Ly91cGxvYWRzLXNzbC53ZWJmbG93LmNvbS82NmMzYjc3OTY3NDkxNWMyODhjYTk5OTgvNjZjOTVlZmJiZWUxYWJjMTBhZWEyNmFkX051ZmlXYWxsZXQucG5nXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vbnUuZmkvXCIsXG4gIH0sXG4gIGJlZ2luOiB7XG4gICAgbmFtZTogXCJCZWdpblwiLFxuICAgIGljb246IFwiaHR0cHM6Ly91cGxvYWRzLXNzbC53ZWJmbG93LmNvbS82NmMzYjc3OTY3NDkxNWMyODhjYTk5OTgvNjZjOTVlZmIwOGI2YTEyNWE0YWY0NzliX0JlZ2luV2FsbGV0LnBuZ1wiLFxuICAgIHVybDogXCJodHRwczovL2JlZ2luLmlzL1wiLFxuICB9LFxuICBsYWNlOiB7XG4gICAgbmFtZTogXCJMYWNlXCIsXG4gICAgaWNvbjogXCJodHRwczovL3VwbG9hZHMtc3NsLndlYmZsb3cuY29tLzY2YzNiNzc5Njc0OTE1YzI4OGNhOTk5OC82NmM5NWVmYmYyNWVmMTY2MzNjZGQ1MjhfTGFjZVdhbGxldC5wbmdcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly93d3cubGFjZS5pby9cIixcbiAgfSxcbn07XG5cbmludGVyZmFjZSBXYWxsZXRDb250ZXh0VHlwZSB7XG4gIGlzTWVudU9wZW46IGJvb2xlYW47XG4gIG9wZW5NZW51OiAoKSA9PiB2b2lkO1xuICBjbG9zZU1lbnU6ICgpID0+IHZvaWQ7XG4gIHdhbGxldHM6IEFsbFN1cHBvcnRlZFdhbGxldHM7XG4gIGNvbm5lY3RlZFdhbGxldHM6IENvbm5lY3RlZFdhbGxldFtdO1xuICBkZWZhdWx0V2FsbGV0OiBzdHJpbmcgfCBudWxsO1xuICBjb25uZWN0V2FsbGV0OiAod2FsbGV0TmFtZTogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBkaXNjb25uZWN0V2FsbGV0OiAod2FsbGV0TmFtZTogc3RyaW5nKSA9PiB2b2lkO1xuICBzZXREZWZhdWx0V2FsbGV0OiAod2FsbGV0TmFtZTogc3RyaW5nKSA9PiB2b2lkO1xuICBpbnN0YWxsZWRXYWxsZXRzOiBzdHJpbmdbXTtcbiAgZ2V0V2FsbGV0QXBpOiAod2FsbGV0TmFtZTogc3RyaW5nKSA9PiBUV2FsbGV0QVBJIHwgbnVsbDtcbn1cblxuY29uc3QgV2FsbGV0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8V2FsbGV0Q29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VXYWxsZXQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFdhbGxldENvbnRleHQpO1xuICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXNlV2FsbGV0IG11c3QgYmUgdXNlZCB3aXRoaW4gYSBXYWxsZXRQcm92aWRlclwiKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFdhbGxldFByb3ZpZGVyKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgY29uc3QgW2lzTWVudU9wZW4sIHNldElzTWVudU9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbY29ubmVjdGVkV2FsbGV0cywgc2V0Q29ubmVjdGVkV2FsbGV0c10gPSB1c2VTdGF0ZTxDb25uZWN0ZWRXYWxsZXRbXT4oXG4gICAgW11cbiAgKTtcbiAgY29uc3QgW2RlZmF1bHRXYWxsZXQsIHNldERlZmF1bHRXYWxsZXRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4oXG4gICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJkZWZhdWx0V2FsbGV0XCIpXG4gICk7XG4gIGNvbnN0IFtpbnN0YWxsZWRXYWxsZXRzLCBzZXRJbnN0YWxsZWRXYWxsZXRzXSA9IHVzZVN0YXRlPHN0cmluZ1tdPihbXSk7XG5cbiAgY29uc3QgZGV0ZWN0Q29ubmVjdGVkV2FsbGV0cyA9IHVzZUNhbGxiYWNrKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBjYXJkYW5vID0gd2luZG93LmNhcmRhbm87XG4gICAgaWYgKCFjYXJkYW5vKSByZXR1cm47XG5cbiAgICBjb25zdCBjb25uZWN0ZWQ6IENvbm5lY3RlZFdhbGxldFtdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHdhbGxldF0gb2YgT2JqZWN0LmVudHJpZXMoYWxsU3VwcG9ydGVkV2FsbGV0cykpIHtcbiAgICAgIGlmIChjYXJkYW5vW2tleV0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBpc0VuYWJsZWQgPSBhd2FpdCBjYXJkYW5vW2tleV0uaXNFbmFibGVkKCk7XG4gICAgICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgYXBpID0gYXdhaXQgY2FyZGFub1trZXldLmVuYWJsZSgpO1xuICAgICAgICAgICAgY29ubmVjdGVkLnB1c2goeyBuYW1lOiB3YWxsZXQubmFtZSwgYXBpIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBkZXRlY3RpbmcgJHt3YWxsZXQubmFtZX0gY29ubmVjdGlvbjpgLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRDb25uZWN0ZWRXYWxsZXRzKGNvbm5lY3RlZCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjb25uZWN0V2FsbGV0ID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHdhbGxldE5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3QgY2FyZGFubyA9IHdpbmRvdy5jYXJkYW5vO1xuICAgICAgaWYgKCFjYXJkYW5vKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHdhbGxldCA9IGNhcmRhbm9bd2FsbGV0TmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIGlmICghd2FsbGV0KSByZXR1cm47XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFwaSA9IGF3YWl0IHdhbGxldC5lbmFibGUoKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0ZWQgd2FsbGV0OlwiLCB3YWxsZXROYW1lLCBhcGkpO1xuICAgICAgICBzZXRDb25uZWN0ZWRXYWxsZXRzKChwcmV2KSA9PiBbLi4ucHJldiwgeyBuYW1lOiB3YWxsZXROYW1lLCBhcGkgfV0pO1xuXG4gICAgICAgIGlmICghZGVmYXVsdFdhbGxldCkge1xuICAgICAgICAgIHNldERlZmF1bHRXYWxsZXQod2FsbGV0TmFtZSk7XG5cbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImRlZmF1bHRXYWxsZXRcIiwgd2FsbGV0TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjb25uZWN0aW5nIHdhbGxldDpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2RlZmF1bHRXYWxsZXRdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQgJiYgY29ubmVjdGVkV2FsbGV0cy5sZW5ndGggPiAwKSB7XG4gICAgICBzZXREZWZhdWx0V2FsbGV0KGNvbm5lY3RlZFdhbGxldHNbMF0ubmFtZSk7XG4gICAgfVxuICB9LCBbZGVmYXVsdFdhbGxldCwgY29ubmVjdGVkV2FsbGV0c10pO1xuXG4gIGNvbnN0IGRpc2Nvbm5lY3RXYWxsZXQgPSB1c2VDYWxsYmFjayhcbiAgICAod2FsbGV0TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBzZXRDb25uZWN0ZWRXYWxsZXRzKChwcmV2KSA9PlxuICAgICAgICBwcmV2LmZpbHRlcigod2FsbGV0KSA9PiB3YWxsZXQubmFtZSAhPT0gd2FsbGV0TmFtZSlcbiAgICAgICk7XG5cbiAgICAgIGlmIChkZWZhdWx0V2FsbGV0ID09PSB3YWxsZXROYW1lKSB7XG4gICAgICAgIHNldERlZmF1bHRXYWxsZXQobnVsbCk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVmYXVsdFdhbGxldFwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtkZWZhdWx0V2FsbGV0XVxuICApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKFwiZGVmYXVsdFdhbGxldFwiLCBkZWZhdWx0V2FsbGV0KTtcbiAgfSwgW2RlZmF1bHRXYWxsZXRdKTtcblxuICBjb25zdCBoYW5kbGVTZXREZWZhdWx0V2FsbGV0ID0gdXNlQ2FsbGJhY2soKHdhbGxldE5hbWU6IHN0cmluZykgPT4ge1xuICAgIHNldERlZmF1bHRXYWxsZXQod2FsbGV0TmFtZSk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJkZWZhdWx0V2FsbGV0XCIsIHdhbGxldE5hbWUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgb3Blbk1lbnUgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRJc01lbnVPcGVuKHRydWUpLCBbXSk7XG4gIGNvbnN0IGNsb3NlTWVudSA9IHVzZUNhbGxiYWNrKCgpID0+IHNldElzTWVudU9wZW4oZmFsc2UpLCBbXSk7XG5cbiAgY29uc3QgZGV0ZWN0SW5zdGFsbGVkV2FsbGV0cyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBpbnN0YWxsZWQgPSBPYmplY3Qua2V5cyhhbGxTdXBwb3J0ZWRXYWxsZXRzKS5maWx0ZXIoXG4gICAgICAoa2V5KSA9PiB3aW5kb3cuY2FyZGFubyAmJiB3aW5kb3cuY2FyZGFub1trZXldXG4gICAgKTtcbiAgICBzZXRJbnN0YWxsZWRXYWxsZXRzKGluc3RhbGxlZCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBnZXRXYWxsZXRBcGkgPSB1c2VDYWxsYmFjayhcbiAgICAod2FsbGV0TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCB3YWxsZXQgPSBjb25uZWN0ZWRXYWxsZXRzLmZpbmQoXG4gICAgICAgICh3KSA9PiB3Lm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gd2FsbGV0TmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHdhbGxldCA/IHdhbGxldC5hcGkgOiBudWxsO1xuICAgIH0sXG4gICAgW2Nvbm5lY3RlZFdhbGxldHNdXG4gICk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkZXRlY3RJbnN0YWxsZWRXYWxsZXRzKCk7XG4gICAgZGV0ZWN0Q29ubmVjdGVkV2FsbGV0cygpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2FyZGFub1wiLCBkZXRlY3RJbnN0YWxsZWRXYWxsZXRzKTtcbiAgICByZXR1cm4gKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYXJkYW5vXCIsIGRldGVjdEluc3RhbGxlZFdhbGxldHMpO1xuICB9LCBbZGV0ZWN0SW5zdGFsbGVkV2FsbGV0cywgZGV0ZWN0Q29ubmVjdGVkV2FsbGV0c10pO1xuXG4gIHJldHVybiAoXG4gICAgPFdhbGxldENvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGlzTWVudU9wZW4sXG4gICAgICAgIG9wZW5NZW51LFxuICAgICAgICBjbG9zZU1lbnUsXG4gICAgICAgIHdhbGxldHM6IGFsbFN1cHBvcnRlZFdhbGxldHMsXG4gICAgICAgIGNvbm5lY3RlZFdhbGxldHMsXG4gICAgICAgIGRlZmF1bHRXYWxsZXQsXG4gICAgICAgIGNvbm5lY3RXYWxsZXQsXG4gICAgICAgIGRpc2Nvbm5lY3RXYWxsZXQsXG4gICAgICAgIHNldERlZmF1bHRXYWxsZXQ6IGhhbmRsZVNldERlZmF1bHRXYWxsZXQsXG4gICAgICAgIGluc3RhbGxlZFdhbGxldHMsXG4gICAgICAgIGdldFdhbGxldEFwaSxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvV2FsbGV0Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cbiIsIi8qKlxuICogQGF1dGhvcjogRXJpY2sgSGVybsOhbmRleiBTaWx2YSAoZXJpY2tAeXVuZ2xlLmNvbS5teClcbiAqIEBjcmVhdGVkOiAwMS8wMS8yMDI1XG4gKiBAdXBkYXRlZDogMDEvMDEvMjAyNSAgICAgICBcbiAqIEBmaWxlIGZpbGVVcGxvYWQudHNcbiAqL1xuXG4vLyBNYWluIHBhdGggZm9yIHRoZSBBUElcbmV4cG9ydCBjb25zdCBBUElfUEFUSDogc3RyaW5nID1cbiAgXCJodHRwczovLzFyb3pwNjRpYWouZXhlY3V0ZS1hcGkudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vcHJlcHJvZHVjdGlvblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBcGlVcmwocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke0FQSV9QQVRIfSR7cGF0aH1gO1xufVxuXG5leHBvcnQgY29uc3QgQVBJX0tFWTogc3RyaW5nID0gXCJaZlE3Qlk3cGJ3QVFHR3E1RkFPTjZBeExXZndNbDcyOVFwM1c1RnE2XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChpbnB1dDogc3RyaW5nIHwgc3RyaW5nW10pOiBzdHJpbmcgfCBzdHJpbmdbXSB7XG4gIGNvbnNvbGUubG9nKGlucHV0KTtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBlbmNvZGVUb0hleCA9IChzdHI6IHN0cmluZykgPT4gXG4gICAgQXJyYXkuZnJvbShlbmNvZGVyLmVuY29kZShzdHIpKVxuICAgICAgLm1hcChieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpXG4gICAgICAuam9pbignJyk7XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZW5jb2RlVG9IZXgoaW5wdXQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbnB1dC5tYXAoZW5jb2RlVG9IZXgpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0hleChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHJhdyA9IGF0b2Ioc3RyKTtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJhdy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGhleCA9IHJhdy5jaGFyQ29kZUF0KGkpLnRvU3RyaW5nKDE2KTtcbiAgICByZXN1bHQgKz0gKGhleC5sZW5ndGggPT09IDIgPyBoZXggOiAnMCcgKyBoZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQudG9VcHBlckNhc2UoKTtcbn1cblxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UOiAncHJlcHJvZHVjdGlvbicgfCAncHJvZHVjdGlvbicgPSBwcm9jZXNzLmVudi5FTlZJUk9OTUVOVCBhcyAncHJlcHJvZHVjdGlvbicgfCAncHJvZHVjdGlvbicgfHwgJ3ByZXByb2R1Y3Rpb24nOyIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHtcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ29udGV4dCxcbiAgdXNlU3RhdGUsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QsXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVFdhbGxldEFQSSB9IGZyb20gXCIuLi90eXBlcy9jYXJkYW5vXCI7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiLi9XYWxsZXRDb250ZXh0XCI7XG5pbXBvcnQge1xuICBGaWxlUHJvZ3Jlc3MsXG4gIENvbnN0cnVjdFR4UmVxdWVzdCxcbiAgQ29uc3RydWN0VHhSZXNwb25zZSxcbiAgUmV0cmlldmVVbnNpZ25lZFR4UmVzcG9uc2UsXG4gIFByZXBhcmVkVVRYT3MsXG4gIFRTdWJtaXNzaW9uU3RhdHVzLFxuICBURGF0YVR5cGVzLFxufSBmcm9tIFwiLi4vdHlwZXMvdHJhbnNhY3Rpb25cIjtcbmltcG9ydCB7IEFQSV9LRVksIGJhc2U2NFRvSGV4LCBidWlsZEFwaVVybCB9IGZyb20gXCIuLi91dGlscy9hcGlDb25zdW1wdGlvblwiO1xuaW1wb3J0IHsgdXNlVHhTdGF0dXMgfSBmcm9tIFwiLi9UeFN0YXR1c0NvbnRleHRcIjtcblxuZXhwb3J0IHR5cGUgVHhQcmVwYXJhdGlvblN0ZXAgPVxuICB8IFwicHJlcGFyZS9jb25zdHJ1Y3RcIlxuICB8IFwicHJlcGFyZS9yZXRyaWV2ZVwiXG4gIHwgXCJwcmVwYXJlL3N1Ym1pdFwiXG4gIHwgXCJwcmVwYXJlL3JldHJpZXZlLXN1Ym1pc3Npb25cIjtcblxuaW50ZXJmYWNlIFR4UHJlcGFyYXRpb25Db250ZXh0VHlwZSB7XG4gIGZpbGVQcm9ncmVzczogRmlsZVByb2dyZXNzW107XG4gIHByZXBhcmVGaWxlczogKGZpbGVzOiBGaWxlW10pID0+IFByb21pc2U8dm9pZD47XG4gIHByZXBhcmVUZXh0OiAodGV4dDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzaWduQW5kU3VibWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBpc1Byb2Nlc3Npbmc6IGJvb2xlYW47XG4gIGN1cnJlbnRTdGVwOiBUeFByZXBhcmF0aW9uU3RlcDtcbiAgbmV4dFN0ZXA6IFR4UHJlcGFyYXRpb25TdGVwIHwgbnVsbDtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGNsZWFyRXJyb3I6ICgpID0+IHZvaWQ7XG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xuICBzdWJtaXNzaW9uU3RhdHVzPzogVFN1Ym1pc3Npb25TdGF0dXM7XG4gIHNldFN1Ym1pc3Npb25TdGF0dXM6IChzdGF0dXM6IFRTdWJtaXNzaW9uU3RhdHVzKSA9PiB2b2lkO1xuICB1bnNpZ25lZFR4SWQ6IHN0cmluZyB8IG51bGw7XG4gIHNldFVuc2lnbmVkVHhJZDogKHR4SWQ6IHN0cmluZyB8IG51bGwpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFR4UHJlcGFyYXRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxcbiAgVHhQcmVwYXJhdGlvbkNvbnRleHRUeXBlIHwgdW5kZWZpbmVkXG4+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUeFByZXBhcmF0aW9uKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChUeFByZXBhcmF0aW9uQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwidXNlVHhQcmVwYXJhdGlvbiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgVHhQcmVwYXJhdGlvblByb3ZpZGVyXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVHhQcmVwYXJhdGlvblByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG59OiB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG59KSB7XG4gIGNvbnN0IFtmaWxlUHJvZ3Jlc3MsIHNldEZpbGVQcm9ncmVzc10gPSB1c2VTdGF0ZTxGaWxlUHJvZ3Jlc3NbXT4oW10pO1xuICBjb25zdCBbaXNQcm9jZXNzaW5nLCBzZXRJc1Byb2Nlc3NpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCB7IGdldFdhbGxldEFwaSwgZGVmYXVsdFdhbGxldCB9ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHsgcHJlcGFyYXRpb24sIG1vdmVUb05leHRTdGVwIH0gPSB1c2VUeFN0YXR1cygpO1xuICBjb25zdCBbc3VibWlzc2lvblN0YXR1cywgc2V0U3VibWlzc2lvblN0YXR1c10gPSB1c2VTdGF0ZTxUU3VibWlzc2lvblN0YXR1cz4oKTtcbiAgY29uc3QgW3Vuc2lnbmVkVHhJZCwgc2V0VW5zaWduZWRUeElkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IHVwZGF0ZUZpbGVQcm9ncmVzcyA9IHVzZUNhbGxiYWNrKFxuICAgIChpbmRleDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPEZpbGVQcm9ncmVzcz4pID0+IHtcbiAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgcHJldi5tYXAoKGl0ZW0sIGkpID0+IChpID09PSBpbmRleCA/IHsgLi4uaXRlbSwgLi4udXBkYXRlcyB9IDogaXRlbSkpXG4gICAgICApO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCBjbGVhckVycm9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEVycm9yKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY29uc3RydWN0VHggPSBhc3luYyAoXG4gICAgYXBpOiBUV2FsbGV0QVBJLFxuICAgIGRhdGE6IHN0cmluZyxcbiAgICBkYXRhVHlwZTogVERhdGFUeXBlc1xuICApOiBQcm9taXNlPENvbnN0cnVjdFR4UmVzcG9uc2U+ID0+IHtcbiAgICAvLyBTZSBhc3VtZSBxdWUgZWwgZXN0YWRvIGluaWNpYWwgKFwicHJlcGFyZS9jb25zdHJ1Y3RcIiB5IFwicHJlcGFyZS9yZXRyaWV2ZVwiKVxuICAgIC8vIHlhIHNlIGRlZmluacOzIGVuIFR4U3RhdHVzQ29udGV4dCBwYXJhIGxhIHByZXBhcmFjacOzbi5cbiAgICBjb25zdCByZXdhcmRBZGRyZXNzZXMgPSAoYXdhaXQgYXBpLmdldFJld2FyZEFkZHJlc3NlcygpKSBhcyBzdHJpbmdbXTtcbiAgICBjb25zdCB1dHhvcyA9IChhd2FpdCBhcGkuZ2V0VXR4b3MoKSkgfHwgW107XG4gICAgY29uc29sZS5sb2coXCJVVFhPczpcIiwgdXR4b3MpO1xuICAgIGNvbnN0IHRhcmdldEFkZHJlc3MgPSAoYXdhaXQgYXBpLmdldFVzZWRBZGRyZXNzZXMoKSlbMF07XG4gICAgaWYgKCF1dHhvcyB8fCB1dHhvcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHNldEVycm9yKFwiTm8gaGF5IFVUWE9zIGRpc3BvbmlibGVzXCIpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gVVRYT3MgYXZhaWxhYmxlXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHk6IENvbnN0cnVjdFR4UmVxdWVzdCA9IHtcbiAgICAgIGRhdGEsXG4gICAgICBkYXRhVHlwZSxcbiAgICAgIHJld2FyZEFkZHJlc3NlcyxcbiAgICAgIHRhcmdldEFkZHJlc3MsXG4gICAgICB1dHhvcyxcbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKFwiQm9keTpcIiwgYm9keSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGJ1aWxkQXBpVXJsKFwiL3ByZXBhcmUtdXR4b3MvY29uc3RydWN0LXR4XCIpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSB8fCBcIlwiLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIH0pO1xuXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBlcnJvclJlc3BvbnNlLmpzb24oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhLFxuICAgICAgICAgIGVuZHBvaW50OiBcIi9wcmVwYXJlLXV0eG9zL2NvbnN0cnVjdC10eFwiLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gU2UgYXZhbnphIGFsIHNpZ3VpZW50ZSBwYXNvIGVuIGVsIGZsdWpvIGRlIHByZXBhcmFjacOzblxuICAgIG1vdmVUb05leHRTdGVwKFwicHJlcGFyYXRpb25cIik7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfTtcblxuICBjb25zdCBwcmVwYXJlRmlsZXMgPSBhc3luYyAoZmlsZXM6IEZpbGVbXSkgPT4ge1xuICAgIGlmICghZGVmYXVsdFdhbGxldCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gd2FsbGV0IGNvbm5lY3RlZFwiKTtcbiAgICBjb25zdCBhcGkgPSBnZXRXYWxsZXRBcGkoZGVmYXVsdFdhbGxldCkgYXMgVFdhbGxldEFQSTtcbiAgICBzZXRJc1Byb2Nlc3NpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIHNldEZpbGVQcm9ncmVzcyhcbiAgICAgICAgZmlsZXMubWFwKChmaWxlKSA9PiAoe1xuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgfSkpXG4gICAgICApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7IHN0YXR1czogXCJjb25zdHJ1Y3RpbmdcIiwgcHJvZ3Jlc3M6IDI1IH0pO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBmaWxlQXNCYXNlNjQgPSBhd2FpdCBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0IGFzIHN0cmluZyk7XG4gICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZXNbaV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmFzZTY0Q29udGVudCA9IGZpbGVBc0Jhc2U2NC5zcGxpdChcIixcIilbMV07XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkVHggPSBhd2FpdCBjb25zdHJ1Y3RUeChcbiAgICAgICAgICBhcGksXG4gICAgICAgICAgYmFzZTY0Q29udGVudCxcbiAgICAgICAgICBmaWxlc1tpXS50eXBlIGFzIFREYXRhVHlwZXNcbiAgICAgICAgKTtcbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKDAsIHtcbiAgICAgICAgICBzdGF0dXM6IFwidW5zaWduZWRcIixcbiAgICAgICAgICBwcm9ncmVzczogNTAsXG4gICAgICAgICAgdHhJbmZvOiB7IGNvbnN0cnVjdGVkVHggfSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBtb3ZlVG9OZXh0U3RlcChcInByZXBhcmF0aW9uXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcHJlcGFyaW5nIGZpbGVzOlwiLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHByZXBhcmVUZXh0ID0gYXN5bmMgKHRleHQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghZGVmYXVsdFdhbGxldCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gd2FsbGV0IGNvbm5lY3RlZFwiKTtcbiAgICBjb25zdCBhcGkgPSBnZXRXYWxsZXRBcGkoZGVmYXVsdFdhbGxldCkgYXMgVFdhbGxldEFQSTtcbiAgICBzZXRJc1Byb2Nlc3NpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRleHRGaWxlID0gbmV3IEZpbGUoW3RleHRdLCBcImRlbGVnYXRlLnR4dFwiLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pO1xuICAgICAgc2V0RmlsZVByb2dyZXNzKFtcbiAgICAgICAge1xuICAgICAgICAgIGZpbGU6IHRleHRGaWxlLFxuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIH0sXG4gICAgICBdKTtcblxuICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKDAsIHsgc3RhdHVzOiBcImNvbnN0cnVjdGluZ1wiLCBwcm9ncmVzczogMjUgfSk7XG4gICAgICBjb25zb2xlLmxvZyhcInRleHRcIiwgdGV4dCk7XG4gICAgICBjb25zdCBiYXNlNjRDb250ZW50ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGV4dCkpKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiYmFzZTY0Q29udGVudFwiLCBiYXNlNjRDb250ZW50KTtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdGVkVHggPSBhd2FpdCBjb25zdHJ1Y3RUeChcbiAgICAgICAgYXBpLFxuICAgICAgICBiYXNlNjRDb250ZW50LFxuICAgICAgICBcInRleHQvcGxhaW5cIiBhcyBURGF0YVR5cGVzXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coXCJjb25zdHJ1Y3RlZFR4XCIsIGNvbnN0cnVjdGVkVHgpO1xuICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKDAsIHtcbiAgICAgICAgc3RhdHVzOiBcInVuc2lnbmVkXCIsXG4gICAgICAgIHByb2dyZXNzOiA1MCxcbiAgICAgICAgdHhJbmZvOiB7IGNvbnN0cnVjdGVkVHggfSxcbiAgICAgIH0pO1xuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJwcmVwYXJhdGlvblwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByZXBhcmluZyB0ZXh0OlwiLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHBvbGxGb3JDb25maXJtYXRpb24gPSBhc3luYyAoXG4gICAgcHJlcGFyZWRUeDogUHJlcGFyZWRVVFhPc1xuICApOiBQcm9taXNlPGJvb2xlYW4+ID0+IHtcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gOTAwMDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICBidWlsZEFwaVVybChcIi9wcmVwYXJlLXV0eG9zL3JldHJpZXZlLXN1Ym1pc3Npb24tc3RhdHVzXCIpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocHJlcGFyZWRUeC5leGVjdXRpb25Bcm4pLFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSByZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3JSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhLFxuICAgICAgICAgICAgICBlbmRwb2ludDogXCIvcHJlcGFyZS11dHhvcy9yZXRyaWV2ZS1zdWJtaXNzaW9uLXN0YXR1c1wiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1czogYW55ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBpZiAoc3RhdHVzLnN1Y2Nlc3MgJiYgc3RhdHVzLnN1Y2Nlc3Mub25jaGFpbiA9PT0gXCJvbi1jaGFpblwiKSB7XG4gICAgICAgICAgc2V0U3VibWlzc2lvblN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJwcmVwYXJhdGlvblwiKTtcbiAgICAgICAgICBjbGVhckVycm9yKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2UgY29udGluw7phIGhhY2llbmRvIHBvbGxpbmcgbWllbnRyYXMgbGEgdHJhbnNhY2Npw7NuIG5vIGVzdMOpIG9uLWNoYWluXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCByZXRyeUludGVydmFsKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9sbGluZyBhdHRlbXB0IGZhaWxlZDpcIiwgZXJyb3IpO1xuICAgICAgICBzZXRFcnJvcihcbiAgICAgICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU2lnbkFuZFN1Ym1pdEVycm9yID0gKGVycm9yOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gc2lnbiBhbmQgc3VibWl0OlwiLCBlcnJvcik7XG5cbiAgICAvLyBGb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2UgYmFzZWQgb24gdGhlIGVycm9yIHR5cGVcbiAgICBsZXQgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG5cbiAgICAvLyBIYW5kbGUgVHhTaWduRXJyb3IgZnJvbSB3YWxsZXRcbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJUeFNpZ25FcnJvclwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBgV2FsbGV0IHNpZ25pbmcgZXJyb3I6ICR7XG4gICAgICAgIGVycm9yLmluZm8gfHwgZXJyb3IubWVzc2FnZSB8fCBcIkZhaWxlZCB0byBzaWduIHRyYW5zYWN0aW9uXCJcbiAgICAgIH1gO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgRXJyb3Igb2JqZWN0c1xuICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgZXJyb3IgbWVzc2FnZSBhcyBKU09OXG4gICAgICAgIGNvbnN0IHBhcnNlZEVycm9yID0gSlNPTi5wYXJzZShlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBwYXJzZWRFcnJvci5lcnJvcj8ubWVzc2FnZSB8fCBwYXJzZWRFcnJvci5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHVzZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgb3RoZXIgZXJyb3IgdHlwZXNcbiAgICBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICBwcmV2Lm1hcCgoZmlsZSkgPT4gKHsgLi4uZmlsZSwgc3RhdHVzOiBcImZhaWxlZFwiLCBwcm9ncmVzczogMCB9KSlcbiAgICApO1xuICAgIC8vIERvbid0IHJlc2V0IHRoZSBzdGVwIHRvIHRoZSBiZWdpbm5pbmcgZm9yIHdhbGxldCBzaWduaW5nIGVycm9yc1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzZXJzIHRvIHJldHJ5IGZyb20gdGhlIGN1cnJlbnQgc3RlcFxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIlR4U2lnbkVycm9yXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FsbGV0IHNpZ25pbmcgZXJyb3IgZGV0ZWN0ZWQsIGtlZXBpbmcgY3VycmVudCBzdGVwXCIpO1xuICAgICAgLy8gSnVzdCBzZXQgcHJvY2Vzc2luZyB0byBmYWxzZSBidXQgZG9uJ3QgY2hhbmdlIHRoZSBzdGVwXG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3Igb3RoZXIgZXJyb3JzLCB3ZSBjYW4gcmVzZXQgcHJvY2Vzc2luZyBzdGF0ZVxuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2lnbkFuZFN1Ym1pdCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBjb25uZWN0ZWRcIik7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVQcm9ncmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmaWxlID0gZmlsZVByb2dyZXNzW2ldO1xuICAgICAgICBjb25zb2xlLmxvZyhcImZpbGVcIiwgZmlsZSk7XG4gICAgICAgIGlmICghZmlsZS50eEluZm8/LmNvbnN0cnVjdGVkVHgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB7IGV4ZWN1dGlvbkFybiB9ID0gZmlsZS50eEluZm8uY29uc3RydWN0ZWRUeDtcbiAgICAgICAgY29uc29sZS5sb2coXCJleGVjdXRpb25Bcm5cIiwgZXhlY3V0aW9uQXJuKTtcblxuICAgICAgICBjb25zdCB1bnNpZ25lZFR4UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICBidWlsZEFwaVVybChcIi9wcmVwYXJlLXV0eG9zL3JldHJpZXZlLXVuc2lnbmVkLXR4XCIpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXhlY3V0aW9uQXJuKSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICghdW5zaWduZWRUeFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHVuc2lnbmVkVHhSZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3JSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgdW5zaWduZWRUeFJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHVuc2lnbmVkVHhSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHVuc2lnbmVkVHhSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhLFxuICAgICAgICAgICAgICBlbmRwb2ludDogXCIvcHJlcGFyZS11dHhvcy9yZXRyaWV2ZS11bnNpZ25lZC10eFwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1bnNpZ25lZFR4OiBSZXRyaWV2ZVVuc2lnbmVkVHhSZXNwb25zZSA9XG4gICAgICAgICAgYXdhaXQgdW5zaWduZWRUeFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJVbnNpZ25lZCBUWDpcIiwgdW5zaWduZWRUeCk7XG5cbiAgICAgICAgLy8gR3VhcmRhciBlbCB0eGlkIGN1YW5kbyBlc3TDoSBkaXNwb25pYmxlXG4gICAgICAgIGlmICh1bnNpZ25lZFR4LnN1Y2Nlc3MgJiYgdW5zaWduZWRUeC5zdWNjZXNzLnR4aWQpIHtcbiAgICAgICAgICBzZXRVbnNpZ25lZFR4SWQodW5zaWduZWRUeC5zdWNjZXNzLnR4aWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuc2lnbmVkVHguaW5Qcm9ncmVzcykge1xuICAgICAgICAgIHdoaWxlICh1bnNpZ25lZFR4LmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5zaWduZWQgdHJhbnNhY3Rpb24gc3RpbGwgaW4gcHJvZ3Jlc3MuLi5cIik7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgNTAwMCkpO1xuICAgICAgICAgICAgY29uc3QgcmV0cnlSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICAgICAgICBidWlsZEFwaVVybChcIi9wcmVwYXJlLXV0eG9zL3JldHJpZXZlLXVuc2lnbmVkLXR4XCIpLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgIFwieC1hcGkta2V5XCI6IEFQSV9LRVkgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV4ZWN1dGlvbkFybiksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoIXJldHJ5UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gcmV0cnlSZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IGVycm9yUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgcmV0cnlSZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogcmV0cnlSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiByZXRyeVJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhLFxuICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL3ByZXBhcmUtdXR4b3MvcmV0cmlldmUtdW5zaWduZWQtdHhcIixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5zaWduZWRUeCA9IGF3YWl0IHJldHJ5UmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJSZXRyeSBVbnNpZ25lZCBUWDpcIiwgdW5zaWduZWRUeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICBwcm9ncmVzczogNzUsXG4gICAgICAgICAgdHhJbmZvOiB7IC4uLmZpbGUudHhJbmZvLCB1bnNpZ25lZFR4IH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGhleFR4ID0gYmFzZTY0VG9IZXgodW5zaWduZWRUeC5zdWNjZXNzLnR4KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJIZXggVFg6XCIsIGhleFR4KTtcblxuICAgICAgICBsZXQgc2lnbmVkVHg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGVycm9yIHN0YXRlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHNpZ24gYWdhaW5cbiAgICAgICAgICBjbGVhckVycm9yKCk7XG5cbiAgICAgICAgICAvLyBHZXQgYSBmcmVzaCB3YWxsZXQgQVBJIGluc3RhbmNlIHRvIGVuc3VyZSB0aGUgcG9wdXAgYXBwZWFycyBhZ2FpblxuICAgICAgICAgIGNvbnN0IGFwaSA9IGdldFdhbGxldEFwaShkZWZhdWx0V2FsbGV0KSBhcyBUV2FsbGV0QVBJO1xuXG4gICAgICAgICAgc2lnbmVkVHggPSBhd2FpdCBhcGkuc2lnblR4KGhleFR4KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlNpZ25lZCBUWDpcIiwgc2lnbmVkVHgpO1xuXG4gICAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICAgIHN0YXR1czogXCJzaWduZWRcIixcbiAgICAgICAgICAgIHByb2dyZXNzOiA4NSxcbiAgICAgICAgICAgIHR4SW5mbzogeyAuLi5maWxlLnR4SW5mbywgdW5zaWduZWRUeCwgc2lnbmVkVHggfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0ZXAgb25seSBhZnRlciBzdWNjZXNzZnVsIHNpZ25pbmdcbiAgICAgICAgICBtb3ZlVG9OZXh0U3RlcChcInByZXBhcmF0aW9uXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNpZ25pbmcgdHJhbnNhY3Rpb246XCIsIGVycm9yKTtcbiAgICAgICAgICAvLyBEb24ndCBtb3ZlIHRvIHRoZSBuZXh0IHN0ZXAgaWYgdGhlcmUncyBhIHNpZ25pbmcgZXJyb3JcbiAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byByZXRyeSBzaWduaW5nIGZyb20gdGhlIHNhbWUgc3RlcFxuICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIlR4U2lnbkVycm9yXCIpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBMZXQgdGhlIGhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciBmdW5jdGlvbiBoYW5kbGUgdGhpcyBzcGVjaWZpYyBlcnJvclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvbjogJHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlIHx8IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdWJtaXRSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICAgIGJ1aWxkQXBpVXJsKFwiL3ByZXBhcmUtdXR4b3Mvc3VibWl0XCIpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICB0eDogdW5zaWduZWRUeC5zdWNjZXNzLnR4LFxuICAgICAgICAgICAgICB1bGlkOiB1bnNpZ25lZFR4LnN1Y2Nlc3MudWxpZCxcbiAgICAgICAgICAgICAgd2l0bmVzc1NldDogc2lnbmVkVHgsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICghc3VibWl0UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gc3VibWl0UmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IGVycm9yUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHN1Ym1pdFJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHN1Ym1pdFJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogc3VibWl0UmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL3ByZXBhcmUtdXR4b3Mvc3VibWl0XCIsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VibWl0dGVkVHg6IFByZXBhcmVkVVRYT3MgPSBhd2FpdCBzdWJtaXRSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VibWl0dGVkIFRYOlwiLCBzdWJtaXR0ZWRUeCk7XG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RlcCBhZnRlciBzdWNjZXNzZnVsIHN1Ym1pc3Npb25cbiAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJwcmVwYXJhdGlvblwiKTtcbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICBzdGF0dXM6IFwic3VibWl0dGVkXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDk1LFxuICAgICAgICAgIHR4SW5mbzogeyAuLi5maWxlLnR4SW5mbywgdW5zaWduZWRUeCwgc2lnbmVkVHgsIHN1Ym1pdHRlZFR4IH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpcm1lZCA9IGF3YWl0IHBvbGxGb3JDb25maXJtYXRpb24oc3VibWl0dGVkVHgpO1xuICAgICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoaSwge1xuICAgICAgICAgIHN0YXR1czogY29uZmlybWVkID8gXCJjb25maXJtZWRcIiA6IFwiZmFpbGVkXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IGNvbmZpcm1lZCA/IDEwMCA6IDAsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBoYW5kbGVTaWduQW5kU3VibWl0RXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCByZXNldCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRGaWxlUHJvZ3Jlc3MoW10pO1xuICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgc2V0U3VibWlzc2lvblN0YXR1cyh1bmRlZmluZWQpO1xuICAgIHNldFVuc2lnbmVkVHhJZChudWxsKTtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgfSwgW10pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIGRldGVjdGVkIGluIFR4UHJlcGFyYXRpb25Db250ZXh0OlwiLCBlcnJvcik7XG5cbiAgICAgIC8vIFVwZGF0ZSBhbGwgZmlsZSBwcm9ncmVzcyB0byBmYWlsZWQgc3RhdHVzIHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChmaWxlKSA9PiAoeyAuLi5maWxlLCBzdGF0dXM6IFwiZmFpbGVkXCIsIHByb2dyZXNzOiAwIH0pKVxuICAgICAgKTtcblxuICAgICAgLy8gRW5zdXJlIHByb2Nlc3Npbmcgc3RhdGUgaXMgcmVzZXRcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbZXJyb3JdKTtcblxuICByZXR1cm4gKFxuICAgIDxUeFByZXBhcmF0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgZmlsZVByb2dyZXNzLFxuICAgICAgICBwcmVwYXJlRmlsZXMsXG4gICAgICAgIHByZXBhcmVUZXh0LFxuICAgICAgICBzaWduQW5kU3VibWl0LFxuICAgICAgICBpc1Byb2Nlc3NpbmcsXG4gICAgICAgIGN1cnJlbnRTdGVwOiBwcmVwYXJhdGlvbi5jdXJyZW50U3RlcCBhcyBUeFByZXBhcmF0aW9uU3RlcCxcbiAgICAgICAgbmV4dFN0ZXA6IHByZXBhcmF0aW9uLm5leHRTdGVwIGFzIFR4UHJlcGFyYXRpb25TdGVwIHwgbnVsbCxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIGNsZWFyRXJyb3IsXG4gICAgICAgIHJlc2V0LFxuICAgICAgICBzdWJtaXNzaW9uU3RhdHVzLFxuICAgICAgICBzZXRTdWJtaXNzaW9uU3RhdHVzLFxuICAgICAgICB1bnNpZ25lZFR4SWQsXG4gICAgICAgIHNldFVuc2lnbmVkVHhJZCxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVHhQcmVwYXJhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBDbG9zZUljb25Qcm9wcyB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IENsb3NlSWNvbjogUmVhY3QuRkM8Q2xvc2VJY29uUHJvcHM+ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPVwiMzBcIlxuICAgICAgaGVpZ2h0PVwiMzBcIlxuICAgICAgdmlld0JveD1cIjAgMCAzMCAzMFwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTE1IDI4LjQzNzVDNy41ODc1IDI4LjQzNzUgMS41NjI1IDIyLjQxMjUgMS41NjI1IDE1QzEuNTYyNSA3LjU4NzUgNy41ODc1IDEuNTYyNSAxNSAxLjU2MjVDMjIuNDEyNSAxLjU2MjUgMjguNDM3NSA3LjU4NzUgMjguNDM3NSAxNUMyOC40Mzc1IDIyLjQxMjUgMjIuNDEyNSAyOC40Mzc1IDE1IDI4LjQzNzVaTTE1IDMuNDM3NUM4LjYyNSAzLjQzNzUgMy40Mzc1IDguNjI1IDMuNDM3NSAxNUMzLjQzNzUgMjEuMzc1IDguNjI1IDI2LjU2MjUgMTUgMjYuNTYyNUMyMS4zNzUgMjYuNTYyNSAyNi41NjI1IDIxLjM3NSAyNi41NjI1IDE1QzI2LjU2MjUgOC42MjUgMjEuMzc1IDMuNDM3NSAxNSAzLjQzNzVaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xMS40NjI3IDE5LjQ3NUMxMS4yMjUyIDE5LjQ3NSAxMC45ODc3IDE5LjM4NzUgMTAuODAwMiAxOS4yQzEwLjQzNzcgMTguODM3NSAxMC40Mzc3IDE4LjIzNzUgMTAuODAwMiAxNy44NzVMMTcuODc1MiAxMC44QzE4LjIzNzcgMTAuNDM3NSAxOC44Mzc3IDEwLjQzNzUgMTkuMjAwMiAxMC44QzE5LjU2MjcgMTEuMTYyNSAxOS41NjI3IDExLjc2MjUgMTkuMjAwMiAxMi4xMjVMMTIuMTI1MiAxOS4yQzExLjk1MDIgMTkuMzg3NSAxMS43MDAyIDE5LjQ3NSAxMS40NjI3IDE5LjQ3NVpcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTE4LjUzNzcgMTkuNDc1QzE4LjMwMDIgMTkuNDc1IDE4LjA2MjcgMTkuMzg3NSAxNy44NzUyIDE5LjJMMTAuODAwMiAxMi4xMjVDMTAuNDM3NyAxMS43NjI1IDEwLjQzNzcgMTEuMTYyNSAxMC44MDAyIDEwLjhDMTEuMTYyNyAxMC40Mzc1IDExLjc2MjcgMTAuNDM3NSAxMi4xMjUyIDEwLjhMMTkuMjAwMiAxNy44NzVDMTkuNTYyNyAxOC4yMzc1IDE5LjU2MjcgMTguODM3NSAxOS4yMDAyIDE5LjJDMTkuMDEyNyAxOS4zODc1IDE4Ljc3NTIgMTkuNDc1IDE4LjUzNzcgMTkuNDc1WlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uLCBNb3Rpb25WYWx1ZSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5cbmludGVyZmFjZSBCdXR0b25Qcm9wcyBleHRlbmRzIFJlYWN0LkJ1dHRvbkhUTUxBdHRyaWJ1dGVzPEhUTUxCdXR0b25FbGVtZW50PiB7XG4gIHZhcmlhbnQ/OiBcInByaW1hcnlcIiB8IFwic2Vjb25kYXJ5XCIgfCBcImdob3N0XCIgfCBcImljb25cIjtcbiAgbG9hZGluZ1RleHQ/OiBzdHJpbmc7XG4gIHN1Y2Nlc3NUZXh0Pzogc3RyaW5nO1xuICBpY29uQmVmb3JlPzogUmVhY3QuUmVhY3ROb2RlO1xuICBpY29uQWZ0ZXI/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBhbmltYXRlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNvbnN0IEJ1dHRvbjogUmVhY3QuRkM8QnV0dG9uUHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIHZhcmlhbnQgPSBcInByaW1hcnlcIixcbiAgbG9hZGluZ1RleHQsXG4gIHN1Y2Nlc3NUZXh0LFxuICBpY29uQmVmb3JlLFxuICBpY29uQWZ0ZXIsXG4gIG9uQ2xpY2ssXG4gIGFuaW1hdGUgPSB0cnVlLFxuICBjbGFzc05hbWUgPSBcIlwiLFxuICAuLi5wcm9wc1xufSkgPT4ge1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNTdWNjZXNzLCBzZXRJc1N1Y2Nlc3NdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IGhhbmRsZUNsaWNrID0gYXN5bmMgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50PikgPT4ge1xuICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICBzZXRJc0xvYWRpbmcoYW5pbWF0ZSk7XG4gICAgICBhd2FpdCBvbkNsaWNrKGV2ZW50KTtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICBzZXRJc1N1Y2Nlc3MoYW5pbWF0ZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldElzU3VjY2VzcyhmYWxzZSksIDIwMDApO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBiYXNlQ2xhc3NlcyA9XG4gICAgXCIhZmxleCAhanVzdGlmeS1jZW50ZXIgIWl0ZW1zLWNlbnRlciAhZ2FwLTIgIXJvdW5kZWQtZnVsbCAhdHJhbnNpdGlvbi1jb2xvcnMgIWR1cmF0aW9uLTMwMCAhZm9jdXM6b3V0bGluZS1ub25lICFmb250LWJvbGQgY3Vyc29yLXBvaW50ZXJcIjtcbiAgY29uc3QgdmFyaWFudENsYXNzZXMgPSB7XG4gICAgcHJpbWFyeTpcbiAgICAgIFwiIWJvcmRlciAhYm9yZGVyLXdoaXRlICFiZy13aGl0ZSAhdGV4dC1wcmltYXJ5LXR3IGhvdmVyOiFiZy10cmFuc3BhcmVudCBob3ZlcjohdGV4dC13aGl0ZVwiLFxuICAgIHNlY29uZGFyeTpcbiAgICAgIFwiIWJvcmRlciAhYm9yZGVyLXdoaXRlICFiZy10cmFuc3BhcmVudCAhdGV4dC13aGl0ZSBob3ZlcjohdGV4dC13aGl0ZVwiLFxuICAgIGdob3N0OiBcIiFiZy10cmFuc3BhcmVudCAhdGV4dC13aGl0ZSBob3ZlcjohYmctd2hpdGUvMTBcIixcbiAgICBpY29uOiBcIiFyb3VuZGVkLWZ1bGwgIXctMTAgIWgtMTAgIXAtMlwiLFxuICB9O1xuICBjb25zdCBkaXNhYmxlZENsYXNzZXMgPSBcIiFvcGFjaXR5LTUwICFjdXJzb3Itbm90LWFsbG93ZWRcIjtcbiAgY29uc3Qgc2l6ZUNsYXNzZXMgPSB2YXJpYW50ID09PSBcImljb25cIiA/IFwiXCIgOiBcInB4LTUgcHktMlwiO1xuXG4gIGNvbnN0IGJ1dHRvbkNsYXNzZXMgPSBgJHtiYXNlQ2xhc3Nlc30gJHt2YXJpYW50Q2xhc3Nlc1t2YXJpYW50XX0gJHtzaXplQ2xhc3Nlc30gJHtjbGFzc05hbWV9ICR7cHJvcHMuZGlzYWJsZWQgPyBkaXNhYmxlZENsYXNzZXMgOiBcIlwifWA7XG5cbiAgcmV0dXJuIChcbiAgICA8bW90aW9uLmJ1dHRvblxuICAgICAgY2xhc3NOYW1lPXtidXR0b25DbGFzc2VzfVxuICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICB3aGlsZVRhcD17eyBzY2FsZTogMC45NSB9fVxuICAgICAgey4uLihwcm9wcyBhcyBhbnkpfVxuICAgID5cbiAgICAgIHtpc0xvYWRpbmcgPyAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNSBoLTUgYm9yZGVyLXQtMiBib3JkZXItYi0yIGJvcmRlci1jdXJyZW50IHJvdW5kZWQtZnVsbFwiXG4gICAgICAgICAgICBhbmltYXRlPXt7IHJvdGF0ZTogMzYwIH19XG4gICAgICAgICAgICB0cmFuc2l0aW9uPXt7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgICAgICByZXBlYXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgZWFzZTogXCJsaW5lYXJcIixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICB7bG9hZGluZ1RleHR9XG4gICAgICAgIDwvPlxuICAgICAgKSA6IGlzU3VjY2VzcyA/IChcbiAgICAgICAgPD5cbiAgICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgICAgaW5pdGlhbD17eyBzY2FsZTogMCB9fVxuICAgICAgICAgICAgYW5pbWF0ZT17eyBzY2FsZTogMSB9fVxuICAgICAgICAgICAgdHJhbnNpdGlvbj17eyB0eXBlOiBcInNwcmluZ1wiLCBzdGlmZm5lc3M6IDUwMCwgZGFtcGluZzogMzAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICDinJNcbiAgICAgICAgICA8L21vdGlvbi5kaXY+XG4gICAgICAgICAge3N1Y2Nlc3NUZXh0fVxuICAgICAgICA8Lz5cbiAgICAgICkgOiAoXG4gICAgICAgIDw+XG4gICAgICAgICAge2ljb25CZWZvcmV9XG4gICAgICAgICAge0FycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gKFxuICAgICAgICAgICAgY2hpbGRyZW4ubWFwKChjaGlsZCwgaW5kZXgpID0+XG4gICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgTW90aW9uVmFsdWUgPyAoXG4gICAgICAgICAgICAgICAgPG1vdGlvbi5zcGFuIGtleT17aW5kZXh9PntjaGlsZH08L21vdGlvbi5zcGFuPlxuICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIGNoaWxkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApIDogY2hpbGRyZW4gaW5zdGFuY2VvZiBNb3Rpb25WYWx1ZSA/IChcbiAgICAgICAgICAgIDxtb3Rpb24uc3Bhbj57Y2hpbGRyZW59PC9tb3Rpb24uc3Bhbj5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApfVxuICAgICAgICAgIHtpY29uQWZ0ZXJ9XG4gICAgICAgIDwvPlxuICAgICAgKX1cbiAgICA8L21vdGlvbi5idXR0b24+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUGRmSWNvblByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgUGRmSWNvbjogUmVhY3QuRkM8UGRmSWNvblByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB3aWR0aD1cIjQ4XCJcbiAgICAgIGhlaWdodD1cIjQ4XCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgNDggNDhcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk00MiAyOC41QzQyIDI4Ljg5NzggNDEuODQyIDI5LjI3OTQgNDEuNTYwNyAyOS41NjA3QzQxLjI3OTQgMjkuODQyIDQwLjg5NzggMzAgNDAuNSAzMEgzNlYzM0gzOUMzOS4zOTc4IDMzIDM5Ljc3OTQgMzMuMTU4IDQwLjA2MDcgMzMuNDM5M0M0MC4zNDIgMzMuNzIwNiA0MC41IDM0LjEwMjIgNDAuNSAzNC41QzQwLjUgMzQuODk3OCA0MC4zNDIgMzUuMjc5NCA0MC4wNjA3IDM1LjU2MDdDMzkuNzc5NCAzNS44NDIgMzkuMzk3OCAzNiAzOSAzNkgzNlYzOUMzNiAzOS4zOTc4IDM1Ljg0MiAzOS43Nzk0IDM1LjU2MDcgNDAuMDYwN0MzNS4yNzk0IDQwLjM0MiAzNC44OTc4IDQwLjUgMzQuNSA0MC41QzM0LjEwMjIgNDAuNSAzMy43MjA2IDQwLjM0MiAzMy40MzkzIDQwLjA2MDdDMzMuMTU4IDM5Ljc3OTQgMzMgMzkuMzk3OCAzMyAzOVYyOC41QzMzIDI4LjEwMjIgMzMuMTU4IDI3LjcyMDYgMzMuNDM5MyAyNy40MzkzQzMzLjcyMDYgMjcuMTU4IDM0LjEwMjIgMjcgMzQuNSAyN0g0MC41QzQwLjg5NzggMjcgNDEuMjc5NCAyNy4xNTggNDEuNTYwNyAyNy40MzkzQzQxLjg0MiAyNy43MjA2IDQyIDI4LjEwMjIgNDIgMjguNVpNMTcuMjUgMzIuMjVDMTcuMjUgMzMuNjQyNCAxNi42OTY5IDM0Ljk3NzcgMTUuNzEyMyAzNS45NjIzQzE0LjcyNzcgMzYuOTQ2OSAxMy4zOTI0IDM3LjUgMTIgMzcuNUgxMC41VjM5QzEwLjUgMzkuMzk3OCAxMC4zNDIgMzkuNzc5NCAxMC4wNjA3IDQwLjA2MDdDOS43NzkzNiA0MC4zNDIgOS4zOTc4MiA0MC41IDkgNDAuNUM4LjYwMjE4IDQwLjUgOC4yMjA2NCA0MC4zNDIgNy45MzkzNCA0MC4wNjA3QzcuNjU4MDQgMzkuNzc5NCA3LjUgMzkuMzk3OCA3LjUgMzlWMjguNUM3LjUgMjguMTAyMiA3LjY1ODA0IDI3LjcyMDYgNy45MzkzNCAyNy40MzkzQzguMjIwNjQgMjcuMTU4IDguNjAyMTggMjcgOSAyN0gxMkMxMy4zOTI0IDI3IDE0LjcyNzcgMjcuNTUzMSAxNS43MTIzIDI4LjUzNzdDMTYuNjk2OSAyOS41MjIzIDE3LjI1IDMwLjg1NzYgMTcuMjUgMzIuMjVaTTE0LjI1IDMyLjI1QzE0LjI1IDMxLjY1MzMgMTQuMDEyOSAzMS4wODEgMTMuNTkxIDMwLjY1OUMxMy4xNjkgMzAuMjM3MSAxMi41OTY3IDMwIDEyIDMwSDEwLjVWMzQuNUgxMkMxMi41OTY3IDM0LjUgMTMuMTY5IDM0LjI2MjkgMTMuNTkxIDMzLjg0MUMxNC4wMTI5IDMzLjQxOSAxNC4yNSAzMi44NDY3IDE0LjI1IDMyLjI1Wk0zMC43NSAzMy43NUMzMC43NSAzNS41NDAyIDMwLjAzODggMzcuMjU3MSAyOC43NzMgMzguNTIzQzI3LjUwNzEgMzkuNzg4OCAyNS43OTAyIDQwLjUgMjQgNDAuNUgyMUMyMC42MDIyIDQwLjUgMjAuMjIwNiA0MC4zNDIgMTkuOTM5MyA0MC4wNjA3QzE5LjY1OCAzOS43Nzk0IDE5LjUgMzkuMzk3OCAxOS41IDM5VjI4LjVDMTkuNSAyOC4xMDIyIDE5LjY1OCAyNy43MjA2IDE5LjkzOTMgMjcuNDM5M0MyMC4yMjA2IDI3LjE1OCAyMC42MDIyIDI3IDIxIDI3SDI0QzI1Ljc5MDIgMjcgMjcuNTA3MSAyNy43MTEyIDI4Ljc3MyAyOC45NzdDMzAuMDM4OCAzMC4yNDI5IDMwLjc1IDMxLjk1OTggMzAuNzUgMzMuNzVaTTI3Ljc1IDMzLjc1QzI3Ljc1IDMyLjc1NTQgMjcuMzU0OSAzMS44MDE2IDI2LjY1MTYgMzEuMDk4NEMyNS45NDg0IDMwLjM5NTEgMjQuOTk0NiAzMCAyNCAzMEgyMi41VjM3LjVIMjRDMjQuOTk0NiAzNy41IDI1Ljk0ODQgMzcuMTA0OSAyNi42NTE2IDM2LjQwMTZDMjcuMzU0OSAzNS42OTg0IDI3Ljc1IDM0Ljc0NDYgMjcuNzUgMzMuNzVaTTcuNSAyMVY3LjVDNy41IDYuNzA0MzUgNy44MTYwNyA1Ljk0MTI5IDguMzc4NjggNS4zNzg2OEM4Ljk0MTI5IDQuODE2MDcgOS43MDQzNSA0LjUgMTAuNSA0LjVIMjguNUMyOC42OTcgNC40OTk4NSAyOC44OTIyIDQuNTM4NTEgMjkuMDc0MyA0LjYxMzhDMjkuMjU2NCA0LjY4OTA4IDI5LjQyMTggNC43OTk1IDI5LjU2MTMgNC45Mzg3NUw0MC4wNjEyIDE1LjQzODhDNDAuMjAwNSAxNS41NzgyIDQwLjMxMDkgMTUuNzQzNiA0MC4zODYyIDE1LjkyNTdDNDAuNDYxNSAxNi4xMDc4IDQwLjUwMDIgMTYuMzAzIDQwLjUgMTYuNVYyMUM0MC41IDIxLjM5NzggNDAuMzQyIDIxLjc3OTQgNDAuMDYwNyAyMi4wNjA3QzM5Ljc3OTQgMjIuMzQyIDM5LjM5NzggMjIuNSAzOSAyMi41QzM4LjYwMjIgMjIuNSAzOC4yMjA2IDIyLjM0MiAzNy45MzkzIDIyLjA2MDdDMzcuNjU4IDIxLjc3OTQgMzcuNSAyMS4zOTc4IDM3LjUgMjFWMThIMjguNUMyOC4xMDIyIDE4IDI3LjcyMDYgMTcuODQyIDI3LjQzOTMgMTcuNTYwN0MyNy4xNTggMTcuMjc5NCAyNyAxNi44OTc4IDI3IDE2LjVWNy41SDEwLjVWMjFDMTAuNSAyMS4zOTc4IDEwLjM0MiAyMS43Nzk0IDEwLjA2MDcgMjIuMDYwN0M5Ljc3OTM2IDIyLjM0MiA5LjM5NzgyIDIyLjUgOSAyMi41QzguNjAyMTggMjIuNSA4LjIyMDY0IDIyLjM0MiA3LjkzOTM0IDIyLjA2MDdDNy42NTgwNCAyMS43Nzk0IDcuNSAyMS4zOTc4IDcuNSAyMVpNMzAgMTVIMzUuMzc5NEwzMCA5LjYyMDYzVjE1WlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBQbmdJY29uUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBQbmdJY29uOiBSZWFjdC5GQzxQbmdJY29uUHJvcHM+ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPVwiNDhcIlxuICAgICAgaGVpZ2h0PVwiNDhcIlxuICAgICAgdmlld0JveD1cIjAgMCA0OCA0OFwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTExLjI1IDI3SDguMjVDNy44NTIxOCAyNyA3LjQ3MDY0IDI3LjE1OCA3LjE4OTM0IDI3LjQzOTNDNi45MDgwNCAyNy43MjA2IDYuNzUgMjguMTAyMiA2Ljc1IDI4LjVWMzlDNi43NSAzOS4zOTc4IDYuOTA4MDQgMzkuNzc5NCA3LjE4OTM0IDQwLjA2MDdDNy40NzA2NCA0MC4zNDIgNy44NTIxOCA0MC41IDguMjUgNDAuNUM4LjY0NzgyIDQwLjUgOS4wMjkzNiA0MC4zNDIgOS4zMTA2NiA0MC4wNjA3QzkuNTkxOTYgMzkuNzc5NCA5Ljc1IDM5LjM5NzggOS43NSAzOVYzNy41SDExLjI1QzEyLjY0MjQgMzcuNSAxMy45Nzc3IDM2Ljk0NjkgMTQuOTYyMyAzNS45NjIzQzE1Ljk0NjkgMzQuOTc3NyAxNi41IDMzLjY0MjQgMTYuNSAzMi4yNUMxNi41IDMwLjg1NzYgMTUuOTQ2OSAyOS41MjIzIDE0Ljk2MjMgMjguNTM3N0MxMy45Nzc3IDI3LjU1MzEgMTIuNjQyNCAyNyAxMS4yNSAyN1pNMTEuMjUgMzQuNUg5Ljc1VjMwSDExLjI1QzExLjg0NjcgMzAgMTIuNDE5IDMwLjIzNzEgMTIuODQxIDMwLjY1OUMxMy4yNjI5IDMxLjA4MSAxMy41IDMxLjY1MzMgMTMuNSAzMi4yNUMxMy41IDMyLjg0NjcgMTMuMjYyOSAzMy40MTkgMTIuODQxIDMzLjg0MUMxMi40MTkgMzQuMjYyOSAxMS44NDY3IDM0LjUgMTEuMjUgMzQuNVpNNDIgMzcuNjYzMUM0MiAzOC4wNDk1IDQxLjg1MDggMzguNDIwOSA0MS41ODM3IDM4LjdDNDEuMDYxNSAzOS4yNjIyIDQwLjQyOTggMzkuNzExOSAzOS43Mjc2IDQwLjAyMTRDMzkuMDI1NCA0MC4zMzA5IDM4LjI2NzQgNDAuNDkzOCAzNy41IDQwLjVDMzQuMTkwNiA0MC41IDMxLjUgMzcuNDcxOSAzMS41IDMzLjc1QzMxLjUgMzAuMDI4MSAzNC4xOTA2IDI3IDM3LjUgMjdDMzguNjAyNiAyNy4wMDM3IDM5LjY3ODggMjcuMzM3NCA0MC41OSAyNy45NTgxQzQwLjkxOTkgMjguMTgxOSA0MS4xNDc1IDI4LjUyNzYgNDEuMjIyNiAyOC45MTkxQzQxLjI5NzYgMjkuMzEwNyA0MS4yMTQxIDI5LjcxNiA0MC45OTAzIDMwLjA0NTlDNDAuNzY2NSAzMC4zNzU5IDQwLjQyMDkgMzAuNjAzNCA0MC4wMjkzIDMwLjY3ODVDMzkuNjM3OCAzMC43NTM2IDM5LjIzMjQgMzAuNjcgMzguOTAyNSAzMC40NDYzQzM4LjQ5MTEgMzAuMTU4NyAzOC4wMDE5IDMwLjAwMzEgMzcuNSAzMEMzNS44NDYzIDMwIDM0LjUgMzEuNjg3NSAzNC41IDMzLjc1QzM0LjUgMzUuODEyNSAzNS44NDYzIDM3LjUgMzcuNSAzNy41QzM4LjA0MTUgMzcuNDk0IDM4LjU2NyAzNy4zMTUzIDM5IDM2Ljk5VjM2QzM4LjYwMjIgMzYgMzguMjIwNiAzNS44NDIgMzcuOTM5MyAzNS41NjA3QzM3LjY1OCAzNS4yNzk0IDM3LjUgMzQuODk3OCAzNy41IDM0LjVDMzcuNSAzNC4xMDIyIDM3LjY1OCAzMy43MjA2IDM3LjkzOTMgMzMuNDM5M0MzOC4yMjA2IDMzLjE1OCAzOC42MDIyIDMzIDM5IDMzSDQwLjVDNDAuODk3OCAzMyA0MS4yNzk0IDMzLjE1OCA0MS41NjA3IDMzLjQzOTNDNDEuODQyIDMzLjcyMDYgNDIgMzQuMTAyMiA0MiAzNC41VjM3LjY2MzFaTTI5LjI1IDI4LjVWMzlDMjkuMjUgMzkuMzE3OSAyOS4xNDkxIDM5LjYyNzYgMjguOTYxNyAzOS44ODQ0QzI4Ljc3NDQgNDAuMTQxMiAyOC41MTAyIDQwLjMzMTggMjguMjA3NSA0MC40Mjg4QzI4LjA1OTcgNDAuNDc2MyAyNy45MDUzIDQwLjUwMDQgMjcuNzUgNDAuNUMyNy41MTEyIDQwLjUgMjcuMjc1OSA0MC40NDMgMjcuMDYzNiA0MC4zMzM4QzI2Ljg1MTMgNDAuMjI0NSAyNi42NjgyIDQwLjA2NjIgMjYuNTI5NCAzOS44NzE5TDIxLjc1IDMzLjE4NzVWMzlDMjEuNzUgMzkuMzk3OCAyMS41OTIgMzkuNzc5NCAyMS4zMTA3IDQwLjA2MDdDMjEuMDI5NCA0MC4zNDIgMjAuNjQ3OCA0MC41IDIwLjI1IDQwLjVDMTkuODUyMiA0MC41IDE5LjQ3MDYgNDAuMzQyIDE5LjE4OTMgNDAuMDYwN0MxOC45MDggMzkuNzc5NCAxOC43NSAzOS4zOTc4IDE4Ljc1IDM5VjI4LjVDMTguNzUgMjguMTgyMiAxOC44NTA5IDI3Ljg3MjYgMTkuMDM4MiAyNy42MTU4QzE5LjIyNTYgMjcuMzU5MSAxOS40ODk2IDI3LjE2ODUgMTkuNzkyMiAyNy4wNzE1QzIwLjA5NDkgMjYuOTc0NSAyMC40MjA1IDI2Ljk3NjIgMjAuNzIyMiAyNy4wNzYyQzIxLjAyMzggMjcuMTc2MiAyMS4yODU5IDI3LjM2OTUgMjEuNDcwNiAyNy42MjgxTDI2LjI1IDM0LjMxMjVWMjguNUMyNi4yNSAyOC4xMDIyIDI2LjQwOCAyNy43MjA2IDI2LjY4OTMgMjcuNDM5M0MyNi45NzA2IDI3LjE1OCAyNy4zNTIyIDI3IDI3Ljc1IDI3QzI4LjE0NzggMjcgMjguNTI5NCAyNy4xNTggMjguODEwNyAyNy40MzkzQzI5LjA5MiAyNy43MjA2IDI5LjI1IDI4LjEwMjIgMjkuMjUgMjguNVpNOSAyMi41QzkuMzk3ODIgMjIuNSA5Ljc3OTM2IDIyLjM0MiAxMC4wNjA3IDIyLjA2MDdDMTAuMzQyIDIxLjc3OTQgMTAuNSAyMS4zOTc4IDEwLjUgMjFWNy41SDI3VjE2LjVDMjcgMTYuODk3OCAyNy4xNTggMTcuMjc5NCAyNy40MzkzIDE3LjU2MDdDMjcuNzIwNiAxNy44NDIgMjguMTAyMiAxOCAyOC41IDE4SDM3LjVWMjFDMzcuNSAyMS4zOTc4IDM3LjY1OCAyMS43Nzk0IDM3LjkzOTMgMjIuMDYwN0MzOC4yMjA2IDIyLjM0MiAzOC42MDIyIDIyLjUgMzkgMjIuNUMzOS4zOTc4IDIyLjUgMzkuNzc5NCAyMi4zNDIgNDAuMDYwNyAyMi4wNjA3QzQwLjM0MiAyMS43Nzk0IDQwLjUgMjEuMzk3OCA0MC41IDIxVjE2LjVDNDAuNTAwMiAxNi4zMDMgNDAuNDYxNSAxNi4xMDc4IDQwLjM4NjIgMTUuOTI1N0M0MC4zMTA5IDE1Ljc0MzYgNDAuMjAwNSAxNS41NzgyIDQwLjA2MTIgMTUuNDM4OEwyOS41NjEzIDQuOTM4NzVDMjkuNDIxOCA0Ljc5OTUgMjkuMjU2NCA0LjY4OTA4IDI5LjA3NDMgNC42MTM4QzI4Ljg5MjIgNC41Mzg1MSAyOC42OTcgNC40OTk4NSAyOC41IDQuNUgxMC41QzkuNzA0MzUgNC41IDguOTQxMjkgNC44MTYwNyA4LjM3ODY4IDUuMzc4NjhDNy44MTYwNyA1Ljk0MTI5IDcuNSA2LjcwNDM1IDcuNSA3LjVWMjFDNy41IDIxLjM5NzggNy42NTgwNCAyMS43Nzk0IDcuOTM5MzQgMjIuMDYwN0M4LjIyMDY0IDIyLjM0MiA4LjYwMjE4IDIyLjUgOSAyMi41Wk0zMCA5LjYyMDYzTDM1LjM3OTQgMTVIMzBWOS42MjA2M1pcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiXG5cbmludGVyZmFjZSBQZGdJY29uUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGNvbnN0IFBkZ0ljb246IFJlYWN0LkZDPFBkZ0ljb25Qcm9wcz4gPSAoeyBjbGFzc05hbWUgfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgd2lkdGg9XCI0OFwiXG4gICAgICBoZWlnaHQ9XCI0OFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDQ4IDQ4XCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgID5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMTEuMjUgMjdIOC4yNUM3Ljg1MjE4IDI3IDcuNDcwNjQgMjcuMTU4IDcuMTg5MzQgMjcuNDM5M0M2LjkwODA0IDI3LjcyMDYgNi43NSAyOC4xMDIyIDYuNzUgMjguNVYzOUM2Ljc1IDM5LjM5NzggNi45MDgwNCAzOS43Nzk0IDcuMTg5MzQgNDAuMDYwN0M3LjQ3MDY0IDQwLjM0MiA3Ljg1MjE4IDQwLjUgOC4yNSA0MC41QzguNjQ3ODIgNDAuNSA5LjAyOTM2IDQwLjM0MiA5LjMxMDY2IDQwLjA2MDdDOS41OTE5NiAzOS43Nzk0IDkuNzUgMzkuMzk3OCA5Ljc1IDM5VjM3LjVIMTEuMjVDMTIuNjQyNCAzNy41IDEzLjk3NzcgMzYuOTQ2OSAxNC45NjIzIDM1Ljk2MjNDMTUuOTQ2OSAzNC45Nzc3IDE2LjUgMzMuNjQyNCAxNi41IDMyLjI1QzE2LjUgMzAuODU3NiAxNS45NDY5IDI5LjUyMjMgMTQuOTYyMyAyOC41Mzc3QzEzLjk3NzcgMjcuNTUzMSAxMi42NDI0IDI3IDExLjI1IDI3Wk0xMS4yNSAzNC41SDkuNzVWMzBIMTEuMjVDMTEuODQ2NyAzMCAxMi40MTkgMzAuMjM3MSAxMi44NDEgMzAuNjU5QzEzLjI2MjkgMzEuMDgxIDEzLjUgMzEuNjUzMyAxMy41IDMyLjI1QzEzLjUgMzIuODQ2NyAxMy4yNjI5IDMzLjQxOSAxMi44NDEgMzMuODQxQzEyLjQxOSAzNC4yNjI5IDExLjg0NjcgMzQuNSAxMS4yNSAzNC41Wk00MiAzNy42NjMxQzQyIDM4LjA0OTUgNDEuODUwOCAzOC40MjA5IDQxLjU4MzcgMzguN0M0MS4wNjE1IDM5LjI2MjIgNDAuNDI5OCAzOS43MTE5IDM5LjcyNzYgNDAuMDIxNEMzOS4wMjU0IDQwLjMzMDkgMzguMjY3NCA0MC40OTM4IDM3LjUgNDAuNUMzNC4xOTA2IDQwLjUgMzEuNSAzNy40NzE5IDMxLjUgMzMuNzVDMzEuNSAzMC4wMjgxIDM0LjE5MDYgMjcgMzcuNSAyN0MzOC42MDI2IDI3LjAwMzcgMzkuNjc4OCAyNy4zMzc0IDQwLjU5IDI3Ljk1ODFDNDAuOTE5OSAyOC4xODE5IDQxLjE0NzUgMjguNTI3NiA0MS4yMjI2IDI4LjkxOTFDNDEuMjk3NiAyOS4zMTA3IDQxLjIxNDEgMjkuNzE2IDQwLjk5MDMgMzAuMDQ1OUM0MC43NjY1IDMwLjM3NTkgNDAuNDIwOSAzMC42MDM0IDQwLjAyOTMgMzAuNjc4NUMzOS42Mzc4IDMwLjc1MzYgMzkuMjMyNCAzMC42NyAzOC45MDI1IDMwLjQ0NjNDMzguNDkxMSAzMC4xNTg3IDM4LjAwMTkgMzAuMDAzMSAzNy41IDMwQzM1Ljg0NjMgMzAgMzQuNSAzMS42ODc1IDM0LjUgMzMuNzVDMzQuNSAzNS44MTI1IDM1Ljg0NjMgMzcuNSAzNy41IDM3LjVDMzguMDQxNSAzNy40OTQgMzguNTY3IDM3LjMxNTMgMzkgMzYuOTlWMzZDMzguNjAyMiAzNiAzOC4yMjA2IDM1Ljg0MiAzNy45MzkzIDM1LjU2MDdDMzcuNjU4IDM1LjI3OTQgMzcuNSAzNC44OTc4IDM3LjUgMzQuNUMzNy41IDM0LjEwMjIgMzcuNjU4IDMzLjcyMDYgMzcuOTM5MyAzMy40MzkzQzM4LjIyMDYgMzMuMTU4IDM4LjYwMjIgMzMgMzkgMzNINDAuNUM0MC44OTc4IDMzIDQxLjI3OTQgMzMuMTU4IDQxLjU2MDcgMzMuNDM5M0M0MS44NDIgMzMuNzIwNiA0MiAzNC4xMDIyIDQyIDM0LjVWMzcuNjYzMVpNMjkuMjUgMjguNVYzOUMyOS4yNSAzOS4zMTc5IDI5LjE0OTEgMzkuNjI3NiAyOC45NjE3IDM5Ljg4NDRDMjguNzc0NCA0MC4xNDEyIDI4LjUxMDIgNDAuMzMxOCAyOC4yMDc1IDQwLjQyODhDMjguMDU5NyA0MC40NzYzIDI3LjkwNTMgNDAuNTAwNCAyNy43NSA0MC41QzI3LjUxMTIgNDAuNSAyNy4yNzU5IDQwLjQ0MyAyNy4wNjM2IDQwLjMzMzhDMjYuODUxMyA0MC4yMjQ1IDI2LjY2ODIgNDAuMDY2MiAyNi41Mjk0IDM5Ljg3MTlMMjEuNzUgMzMuMTg3NVYzOUMyMS43NSAzOS4zOTc4IDIxLjU5MiAzOS43Nzk0IDIxLjMxMDcgNDAuMDYwN0MyMS4wMjk0IDQwLjM0MiAyMC42NDc4IDQwLjUgMjAuMjUgNDAuNUMxOS44NTIyIDQwLjUgMTkuNDcwNiA0MC4zNDIgMTkuMTg5MyA0MC4wNjA3QzE4LjkwOCAzOS43Nzk0IDE4Ljc1IDM5LjM5NzggMTguNzUgMzlWMjguNUMxOC43NSAyOC4xODIyIDE4Ljg1MDkgMjcuODcyNiAxOS4wMzgyIDI3LjYxNThDMTkuMjI1NiAyNy4zNTkxIDE5LjQ4OTYgMjcuMTY4NSAxOS43OTIyIDI3LjA3MTVDMjAuMDk0OSAyNi45NzQ1IDIwLjQyMDUgMjYuOTc2MiAyMC43MjIyIDI3LjA3NjJDMjEuMDIzOCAyNy4xNzYyIDIxLjI4NTkgMjcuMzY5NSAyMS40NzA2IDI3LjYyODFMMjYuMjUgMzQuMzEyNVYyOC41QzI2LjI1IDI4LjEwMjIgMjYuNDA4IDI3LjcyMDYgMjYuNjg5MyAyNy40MzkzQzI2Ljk3MDYgMjcuMTU4IDI3LjM1MjIgMjcgMjcuNzUgMjdDMjguMTQ3OCAyNyAyOC41Mjk0IDI3LjE1OCAyOC44MTA3IDI3LjQzOTNDMjkuMDkyIDI3LjcyMDYgMjkuMjUgMjguMTAyMiAyOS4yNSAyOC41Wk05IDIyLjVDOS4zOTc4MiAyMi41IDkuNzc5MzYgMjIuMzQyIDEwLjA2MDcgMjIuMDYwN0MxMC4zNDIgMjEuNzc5NCAxMC41IDIxLjM5NzggMTAuNSAyMVY3LjVIMjdWMTYuNUMyNyAxNi44OTc4IDI3LjE1OCAxNy4yNzk0IDI3LjQzOTMgMTcuNTYwN0MyNy43MjA2IDE3Ljg0MiAyOC4xMDIyIDE4IDI4LjUgMThIMzcuNVYyMUMzNy41IDIxLjM5NzggMzcuNjU4IDIxLjc3OTQgMzcuOTM5MyAyMi4wNjA3QzM4LjIyMDYgMjIuMzQyIDM4LjYwMjIgMjIuNSAzOSAyMi41QzM5LjM5NzggMjIuNSAzOS43Nzk0IDIyLjM0MiA0MC4wNjA3IDIyLjA2MDdDNDAuMzQyIDIxLjc3OTQgNDAuNSAyMS4zOTc4IDQwLjUgMjFWMTYuNUM0MC41MDAyIDE2LjMwMyA0MC40NjE1IDE2LjEwNzggNDAuMzg2MiAxNS45MjU3QzQwLjMxMDkgMTUuNzQzNiA0MC4yMDA1IDE1LjU3ODIgNDAuMDYxMiAxNS40Mzg4TDI5LjU2MTMgNC45Mzg3NUMyOS40MjE4IDQuNzk5NSAyOS4yNTY0IDQuNjg5MDggMjkuMDc0MyA0LjYxMzhDMjguODkyMiA0LjUzODUxIDI4LjY5NyA0LjQ5OTg1IDI4LjUgNC41SDEwLjVDOS43MDQzNSA0LjUgOC45NDEyOSA0LjgxNjA3IDguMzc4NjggNS4zNzg2OEM3LjgxNjA3IDUuOTQxMjkgNy41IDYuNzA0MzUgNy41IDcuNVYyMUM3LjUgMjEuMzk3OCA3LjY1ODA0IDIxLjc3OTQgNy45MzkzNCAyMi4wNjA3QzguMjIwNjQgMjIuMzQyIDguNjAyMTggMjIuNSA5IDIyLjVaTTMwIDkuNjIwNjNMMzUuMzc5NCAxNUgzMFY5LjYyMDYzWlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKVxufVxuXG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBNcDRJY29uUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBNcDRJY29uOiBSZWFjdC5GQzxNcDRJY29uUHJvcHM+ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPVwiNDhcIlxuICAgICAgaGVpZ2h0PVwiNDhcIlxuICAgICAgdmlld0JveD1cIjAgMCA0OCA0OFwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTQyIDI4LjVDNDIgMjguODk3OCA0MS44NDIgMjkuMjc5NCA0MS41NjA3IDI5LjU2MDdDNDEuMjc5NCAyOS44NDIgNDAuODk3OCAzMCA0MC41IDMwSDM2VjMzSDM5QzM5LjM5NzggMzMgMzkuNzc5NCAzMy4xNTggNDAuMDYwNyAzMy40MzkzQzQwLjM0MiAzMy43MjA2IDQwLjUgMzQuMTAyMiA0MC41IDM0LjVDNDAuNSAzNC44OTc4IDQwLjM0MiAzNS4yNzk0IDQwLjA2MDcgMzUuNTYwN0MzOS43Nzk0IDM1Ljg0MiAzOS4zOTc4IDM2IDM5IDM2SDM2VjM5QzM2IDM5LjM5NzggMzUuODQyIDM5Ljc3OTQgMzUuNTYwNyA0MC4wNjA3QzM1LjI3OTQgNDAuMzQyIDM0Ljg5NzggNDAuNSAzNC41IDQwLjVDMzQuMTAyMiA0MC41IDMzLjcyMDYgNDAuMzQyIDMzLjQzOTMgNDAuMDYwN0MzMy4xNTggMzkuNzc5NCAzMyAzOS4zOTc4IDMzIDM5VjI4LjVDMzMgMjguMTAyMiAzMy4xNTggMjcuNzIwNiAzMy40MzkzIDI3LjQzOTNDMzMuNzIwNiAyNy4xNTggMzQuMTAyMiAyNyAzNC41IDI3SDQwLjVDNDAuODk3OCAyNyA0MS4yNzk0IDI3LjE1OCA0MS41NjA3IDI3LjQzOTNDNDEuODQyIDI3LjcyMDYgNDIgMjguMTAyMiA0MiAyOC41Wk0xNy4yNSAzMi4yNUMxNy4yNSAzMy42NDI0IDE2LjY5NjkgMzQuOTc3NyAxNS43MTIzIDM1Ljk2MjNDMTQuNzI3NyAzNi45NDY5IDEzLjM5MjQgMzcuNSAxMiAzNy41SDEwLjVWMzlDMTAuNSAzOS4zOTc4IDEwLjM0MiAzOS43Nzk0IDEwLjA2MDcgNDAuMDYwN0M5Ljc3OTM2IDQwLjM0MiA5LjM5NzgyIDQwLjUgOSA0MC41QzguNjAyMTggNDAuNSA4LjIyMDY0IDQwLjM0MiA3LjkzOTM0IDQwLjA2MDdDNy42NTgwNCAzOS43Nzk0IDcuNSAzOS4zOTc4IDcuNSAzOVYyOC41QzcuNSAyOC4xMDIyIDcuNjU4MDQgMjcuNzIwNiA3LjkzOTM0IDI3LjQzOTNDOC4yMjA2NCAyNy4xNTggOC42MDIxOCAyNyA5IDI3SDEyQzEzLjM5MjQgMjcgMTQuNzI3NyAyNy41NTMxIDE1LjcxMjMgMjguNTM3N0MxNi42OTY5IDI5LjUyMjMgMTcuMjUgMzAuODU3NiAxNy4yNSAzMi4yNVpNMTQuMjUgMzIuMjVDMTQuMjUgMzEuNjUzMyAxNC4wMTI5IDMxLjA4MSAxMy41OTEgMzAuNjU5QzEzLjE2OSAzMC4yMzcxIDEyLjU5NjcgMzAgMTIgMzBIMTAuNVYzNC41SDEyQzEyLjU5NjcgMzQuNSAxMy4xNjkgMzQuMjYyOSAxMy41OTEgMzMuODQxQzE0LjAxMjkgMzMuNDE5IDE0LjI1IDMyLjg0NjcgMTQuMjUgMzIuMjVaTTMwLjc1IDMzLjc1QzMwLjc1IDM1LjU0MDIgMzAuMDM4OCAzNy4yNTcxIDI4Ljc3MyAzOC41MjNDMjcuNTA3MSAzOS43ODg4IDI1Ljc5MDIgNDAuNSAyNCA0MC41SDIxQzIwLjYwMjIgNDAuNSAyMC4yMjA2IDQwLjM0MiAxOS45MzkzIDQwLjA2MDdDMTkuNjU4IDM5Ljc3OTQgMTkuNSAzOS4zOTc4IDE5LjUgMzlWMjguNUMxOS41IDI4LjEwMjIgMTkuNjU4IDI3LjcyMDYgMTkuOTM5MyAyNy40MzkzQzIwLjIyMDYgMjcuMTU4IDIwLjYwMjIgMjcgMjEgMjdIMjRDMjUuNzkwMiAyNyAyNy41MDcxIDI3LjcxMTIgMjguNzczIDI4Ljk3N0MzMC4wMzg4IDMwLjI0MjkgMzAuNzUgMzEuOTU5OCAzMC43NSAzMy43NVpNMjcuNzUgMzMuNzVDMjcuNzUgMzIuNzU1NCAyNy4zNTQ5IDMxLjgwMTYgMjYuNjUxNiAzMS4wOTg0QzI1Ljk0ODQgMzAuMzk1MSAyNC45OTQ2IDMwIDI0IDMwSDIyLjVWMzcuNUgyNEMyNC45OTQ2IDM3LjUgMjUuOTQ4NCAzNy4xMDQ5IDI2LjY1MTYgMzYuNDAxNkMyNy4zNTQ5IDM1LjY5ODQgMjcuNzUgMzQuNzQ0NiAyNy43NSAzMy43NVpNNy41IDIxVjcuNUM3LjUgNi43MDQzNSA3LjgxNjA3IDUuOTQxMjkgOC4zNzg2OCA1LjM3ODY4QzguOTQxMjkgNC44MTYwNyA5LjcwNDM1IDQuNSAxMC41IDQuNUgyOC41QzI4LjY5NyA0LjQ5OTg1IDI4Ljg5MjIgNC41Mzg1MSAyOS4wNzQzIDQuNjEzOEMyOS4yNTY0IDQuNjg5MDggMjkuNDIxOCA0Ljc5OTUgMjkuNTYxMyA0LjkzODc1TDQwLjA2MTIgMTUuNDM4OEM0MC4yMDA1IDE1LjU3ODIgNDAuMzEwOSAxNS43NDM2IDQwLjM4NjIgMTUuOTI1N0M0MC40NjE1IDE2LjEwNzggNDAuNTAwMiAxNi4zMDMgNDAuNSAxNi41VjIxQzQwLjUgMjEuMzk3OCA0MC4zNDIgMjEuNzc5NCA0MC4wNjA3IDIyLjA2MDdDMzkuNzc5NCAyMi4zNDIgMzkuMzk3OCAyMi41IDM5IDIyLjVDMzguNjAyMiAyMi41IDM4LjIyMDYgMjIuMzQyIDM3LjkzOTMgMjIuMDYwN0MzNy42NTggMjEuNzc5NCAzNy41IDIxLjM5NzggMzcuNSAyMVYxOEgyOC41QzI4LjEwMjIgMTggMjcuNzIwNiAxNy44NDIgMjcuNDM5MyAxNy41NjA3QzI3LjE1OCAxNy4yNzk0IDI3IDE2Ljg5NzggMjcgMTYuNVY3LjVIMTAuNVYyMUMxMC41IDIxLjM5NzggMTAuMzQyIDIxLjc3OTQgMTAuMDYwNyAyMi4wNjA3QzkuNzc5MzYgMjIuMzQyIDkuMzk3ODIgMjIuNSA5IDIyLjVDOC42MDIxOCAyMi41IDguMjIwNjQgMjIuMzQyIDcuOTM5MzQgMjIuMDYwN0M3LjY1ODA0IDIxLjc3OTQgNy41IDIxLjM5NzggNy41IDIxWk0zMCAxNUgzNS4zNzk0TDMwIDkuNjIwNjNWMTVaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgIDwvc3ZnPlxuICApO1xufTtcbiIsIlwidXNlIGNsaWVudFwiXG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG5pbXBvcnQgeyB1c2VGaWxlVXBsb2FkIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvRmlsZVVwbG9hZENvbnRleHRcIlxuaW1wb3J0IHsgdXNlVHhQcmVwYXJhdGlvbiB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1R4UHJlcGFyYXRpb25Db250ZXh0XCJcbmltcG9ydCB7IENsb3NlSWNvbiB9IGZyb20gXCIuLi8uLi9pY29ucy9DbG9zZUljb25cIlxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIi4uL3VpL0J1dHRvblwiXG5pbXBvcnQgeyBQZGZJY29uIH0gZnJvbSBcIi4uLy4uL2ljb25zL1BkZkljb25cIlxuaW1wb3J0IHsgUG5nSWNvbiB9IGZyb20gXCIuLi8uLi9pY29ucy9QbmdJY29uXCJcbmltcG9ydCB7IFBkZ0ljb24gfSBmcm9tIFwiLi4vLi4vaWNvbnMvUGRnSWNvblwiXG5pbXBvcnQgeyBNcDRJY29uIH0gZnJvbSBcIi4uLy4uL2ljb25zL01wNEljb25cIlxuaW1wb3J0IHsgdXNlVHhTdGF0dXMgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeFN0YXR1c0NvbnRleHRcIlxuXG5leHBvcnQgZnVuY3Rpb24gRmlsZUxpc3QoKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGNvbnN0IHsgZmlsZSwgcmVtb3ZlRmlsZSB9ID0gdXNlRmlsZVVwbG9hZCgpXG4gIGNvbnN0IHsgZmlsZVByb2dyZXNzLCBpc1Byb2Nlc3NpbmcsIGN1cnJlbnRTdGVwIH0gPSB1c2VUeFByZXBhcmF0aW9uKClcbiAgY29uc3Qge3ByZXBhcmF0aW9ufSA9IHVzZVR4U3RhdHVzKClcblxuICBpZiAoIWZpbGUpIHJldHVybiBudWxsXG5cbiAgLy8gQ29tbyBzb2xvIHNlIGFkbWl0ZSB1biBhcmNoaXZvLCBzZSB1c2EgZWwgcHJpbWVyIGVsZW1lbnRvIGRlIGZpbGVQcm9ncmVzcyAoc2kgZXhpc3RlKVxuICBjb25zdCBwcm9ncmVzcyA9IGZpbGVQcm9ncmVzc1swXVxuXG4gIHJldHVybiAoXG4gICAgPG1vdGlvbi5kaXZcbiAgICAgIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTRcIlxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuNSB9fVxuICAgID5cbiAgICAgIDxBbmltYXRlUHJlc2VuY2U+XG4gICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAga2V5PXtmaWxlLm5hbWV9XG4gICAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMiBwLTQgYmctd2hpdGUvNSByb3VuZGVkLWxnXCJcbiAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHk6IDIwIH19XG4gICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxLCB5OiAwIH19XG4gICAgICAgICAgZXhpdD17eyBvcGFjaXR5OiAwLCB4OiAtMjAgfX1cbiAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjMgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC00XCI+XG4gICAgICAgICAgICAgIHtmaWxlLnByZXZpZXcgPyAoXG4gICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgc3JjPXtmaWxlLnByZXZpZXd9XG4gICAgICAgICAgICAgICAgICBhbHQ9XCJQcmV2aWV3XCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctMTAgaC0xMCByb3VuZGVkIG9iamVjdC1jb3ZlclwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctMTAgaC0xMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAge2ZpbGUudHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9wZGZcIiA/IChcbiAgICAgICAgICAgICAgICAgICAgPFBkZkljb24gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCB0ZXh0LXdoaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgICkgOiBmaWxlLnR5cGUgPT09IFwiaW1hZ2UvcG5nXCIgPyAoXG4gICAgICAgICAgICAgICAgICAgIDxQbmdJY29uIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgdGV4dC13aGl0ZVwiIC8+XG4gICAgICAgICAgICAgICAgICApIDogZmlsZS50eXBlID09PSBcImltYWdlL3BkZ1wiID8gKFxuICAgICAgICAgICAgICAgICAgICA8UGRnSWNvbiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIHRleHQtd2hpdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgKSA6IGZpbGUudHlwZSA9PT0gXCJ2aWRlby9tcDRcIiA/IChcbiAgICAgICAgICAgICAgICAgICAgPE1wNEljb24gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCB0ZXh0LXdoaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC13aGl0ZVwiPlxuICAgICAgICAgICAgICAgICAgICAgIHtmaWxlLnR5cGUuc3BsaXQoXCIvXCIpWzFdLnRvVXBwZXJDYXNlKCl9XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiZm9udC1tZWRpdW0gIXRleHQtd2hpdGVcIj57ZmlsZS5uYW1lfTwvcD5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtICF0ZXh0LXdoaXRlLzgwXCI+XG4gICAgICAgICAgICAgICAgICB7KGZpbGUuc2l6ZSAvIDEwMjQgLyAxMDI0KS50b0ZpeGVkKDIpfSBNQlxuICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgdmFyaWFudD1cImljb25cIlxuICAgICAgICAgICAgICBvbkNsaWNrPXtyZW1vdmVGaWxlfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIGhvdmVyOmJnLXdoaXRlLzEwXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e3ByZXBhcmF0aW9uLmN1cnJlbnRTdGVwICE9IFwicHJlcGFyZS9jb25zdHJ1Y3RcIn1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPENsb3NlSWNvbiBjbGFzc05hbWU9XCJ3LTYgaC02XCIgLz5cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIEJhcnJhIGRlIHByb2dyZXNvIHZpc2libGUgZHVyYW50ZSBsYSBldGFwYSBcInByZXBhcmUvY29uc3RydWN0XCIgKi99XG4gICAgICAgICAge2lzUHJvY2Vzc2luZyAmJiBjdXJyZW50U3RlcCA9PT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwiICYmIHByb2dyZXNzICYmIChcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0xXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC0xIGJnLXdoaXRlLzEwIHJvdW5kZWQtZnVsbCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaC1mdWxsIGJnLXByaW1hcnktdHdcIlxuICAgICAgICAgICAgICAgICAgaW5pdGlhbD17eyB3aWR0aDogMCB9fVxuICAgICAgICAgICAgICAgICAgYW5pbWF0ZT17eyB3aWR0aDogYCR7cHJvZ3Jlc3MucHJvZ3Jlc3N9JWAgfX1cbiAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuNSB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC13aGl0ZS82MFwiPlxuICAgICAgICAgICAgICAgIHtwcm9ncmVzcy5zdGF0dXMgPT09IFwiY29uc3RydWN0aW5nXCJcbiAgICAgICAgICAgICAgICAgID8gXCJDb25zdHJ1Y3RpbmcgdHJhbnNhY3Rpb24uLi5cIlxuICAgICAgICAgICAgICAgICAgOiBwcm9ncmVzcy5zdGF0dXMgPT09IFwidW5zaWduZWRcIlxuICAgICAgICAgICAgICAgICAgPyBcIlJldHJpZXZpbmcgdW5zaWduZWQgdHJhbnNhY3Rpb24uLi5cIlxuICAgICAgICAgICAgICAgICAgOiBcIlByb2Nlc3NpbmcuLi5cIn1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L21vdGlvbi5kaXY+XG4gICAgICA8L0FuaW1hdGVQcmVzZW5jZT5cbiAgICA8L21vdGlvbi5kaXY+XG4gIClcbn1cbiIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtb3Rpb24gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiO1xuaW1wb3J0IHsgdXNlVHhTdGF0dXMgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeFN0YXR1c0NvbnRleHRcIjtcblxuaW50ZXJmYWNlIERlbGVnYXRlVmlld1Byb3BzIHtcbiAgdGV4dDogc3RyaW5nO1xuICBzZXRUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xuICBpc1Byb2Nlc3Npbmc6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBEZWxlZ2F0ZVZpZXcoe1xuICB0ZXh0LFxuICBzZXRUZXh0LFxuICBpc1Byb2Nlc3NpbmcsXG59OiBEZWxlZ2F0ZVZpZXdQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIGNvbnN0IHsgcHJlcGFyYXRpb24gfSA9IHVzZVR4U3RhdHVzKCk7XG4gIHJldHVybiAoXG4gICAgPG1vdGlvbi5kaXZcbiAgICAgIGNsYXNzTmFtZT1cInNwYWNlLXktNFwiXG4gICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4zIH19XG4gICAgPlxuICAgICAgPHRleHRhcmVhXG4gICAgICAgIHZhbHVlPXt0ZXh0fVxuICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldFRleHQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgdGV4dCBoZXJlLi4uXCJcbiAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtNDggcC00IGJnLXdoaXRlLzUgcm91bmRlZC14bCB0ZXh0LXdoaXRlIHBsYWNlaG9sZGVyOnRleHQtd2hpdGUvNDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLVsjNDQ3QkY0XVwiXG4gICAgICAgIGRpc2FibGVkPXtwcmVwYXJhdGlvbi5jdXJyZW50U3RlcCAhPSBcInByZXBhcmUvY29uc3RydWN0XCJ9XG4gICAgICAvPlxuICAgIDwvbW90aW9uLmRpdj5cbiAgKTtcbn1cbiIsIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNvbnRleHQsXG4gIHVzZVN0YXRlLFxuICB1c2VDYWxsYmFjayxcbiAgdXNlRWZmZWN0LFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFRXYWxsZXRBUEkgfSBmcm9tIFwiLi4vdHlwZXMvY2FyZGFub1wiO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIi4vV2FsbGV0Q29udGV4dFwiO1xuaW1wb3J0IHtcbiAgRmlsZVByb2dyZXNzLFxuICBDb25zdHJ1Y3RUeFJlc3BvbnNlLFxuICBSZXRyaWV2ZVVuc2lnbmVkSW5zY3JpcHRpb25UeFJlc3BvbnNlLFxuICBQcmVwYXJlZFVUWE9zLFxuICBURGF0YVR5cGVzLFxuICBDb25zdHJ1Y3RUeEluc2NyaWJlUmVxdWVzdCxcbiAgVEluc2NyaXB0aW9uU3VibWlzc2lvblN0YXR1cyxcbn0gZnJvbSBcIi4uL3R5cGVzL3RyYW5zYWN0aW9uXCI7XG5pbXBvcnQgeyBBUElfS0VZLCBiYXNlNjRUb0hleCwgYnVpbGRBcGlVcmwgfSBmcm9tIFwiLi4vdXRpbHMvYXBpQ29uc3VtcHRpb25cIjtcbmltcG9ydCB7IHVzZVR4U3RhdHVzIH0gZnJvbSBcIi4vVHhTdGF0dXNDb250ZXh0XCI7XG5cbmV4cG9ydCB0eXBlIFR4SW5zY3JpcHRpb25TdGVwID1cbiAgfCBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiXG4gIHwgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiXG4gIHwgXCJpbnNjcmlwdGlvbi9zdWJtaXRcIlxuICB8IFwiaW5zY3JpcHRpb24vcmV0cmlldmUtc3VibWlzc2lvblwiXG4gIHwgXCJlbmRcIjtcblxuaW50ZXJmYWNlIFR4SW5zY3JpcHRpb25Db250ZXh0VHlwZSB7XG4gIGZpbGVQcm9ncmVzczogRmlsZVByb2dyZXNzW107XG4gIGluc2NyaWJlRmlsZXM6IChmaWxlczogRmlsZVtdKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBpbnNjcmliZVRleHQ6ICh0ZXh0OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHNpZ25BbmRTdWJtaXQ6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIGlzUHJvY2Vzc2luZzogYm9vbGVhbjtcbiAgY3VycmVudFN0ZXA6IFR4SW5zY3JpcHRpb25TdGVwO1xuICBuZXh0U3RlcDogVHhJbnNjcmlwdGlvblN0ZXAgfCBudWxsO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgY2xlYXJFcnJvcjogKCkgPT4gdm9pZDtcbiAgcmVzZXQ6ICgpID0+IHZvaWQ7XG4gIHN1Ym1pc3Npb25TdGF0dXM/OiBUSW5zY3JpcHRpb25TdWJtaXNzaW9uU3RhdHVzO1xuICB1bnNpZ25lZFR4PzogUmV0cmlldmVVbnNpZ25lZEluc2NyaXB0aW9uVHhSZXNwb25zZTtcbiAgc2V0VW5zaWduZWRUeDogKFxuICAgIHR4OiBSZXRyaWV2ZVVuc2lnbmVkSW5zY3JpcHRpb25UeFJlc3BvbnNlIHwgdW5kZWZpbmVkXG4gICkgPT4gdm9pZDtcbn1cblxuY29uc3QgVHhJbnNjcmlwdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0PFR4SW5zY3JpcHRpb25Db250ZXh0VHlwZT4oe1xuICBmaWxlUHJvZ3Jlc3M6IFtdLFxuICBpbnNjcmliZUZpbGVzOiBhc3luYyAoKSA9PiB7fSxcbiAgaW5zY3JpYmVUZXh0OiBhc3luYyAoKSA9PiB7fSxcbiAgc2lnbkFuZFN1Ym1pdDogYXN5bmMgKCkgPT4ge30sXG4gIGlzUHJvY2Vzc2luZzogZmFsc2UsXG4gIGN1cnJlbnRTdGVwOiBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiLFxuICBuZXh0U3RlcDogbnVsbCxcbiAgZXJyb3I6IG51bGwsXG4gIGNsZWFyRXJyb3I6ICgpID0+IHt9LFxuICByZXNldDogKCkgPT4ge30sXG4gIHN1Ym1pc3Npb25TdGF0dXM6IHVuZGVmaW5lZCxcbiAgdW5zaWduZWRUeDogdW5kZWZpbmVkLFxuICBzZXRVbnNpZ25lZFR4OiAoKSA9PiB7fSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHhJbnNjcmlwdGlvbigpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVHhJbnNjcmlwdGlvbkNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInVzZVR4SW5zY3JpcHRpb24gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFR4SW5zY3JpcHRpb25Qcm92aWRlclwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFR4SW5zY3JpcHRpb25Qcm92aWRlcih7XG4gIGNoaWxkcmVuLFxufToge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufSkge1xuICBjb25zdCBbZmlsZVByb2dyZXNzLCBzZXRGaWxlUHJvZ3Jlc3NdID0gdXNlU3RhdGU8RmlsZVByb2dyZXNzW10+KFtdKTtcbiAgY29uc3QgW2lzUHJvY2Vzc2luZywgc2V0SXNQcm9jZXNzaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3N1Ym1pc3Npb25TdGF0dXMsIHNldFN1Ym1pc3Npb25TdGF0dXNdID0gdXNlU3RhdGU8XG4gICAgVEluc2NyaXB0aW9uU3VibWlzc2lvblN0YXR1cyB8IHVuZGVmaW5lZFxuICA+KCk7XG4gIGNvbnN0IFt1bnNpZ25lZFR4LCBzZXRVbnNpZ25lZFR4XSA9IHVzZVN0YXRlPFxuICAgIFJldHJpZXZlVW5zaWduZWRJbnNjcmlwdGlvblR4UmVzcG9uc2UgfCB1bmRlZmluZWRcbiAgPigpO1xuICBjb25zdCB7IGdldFdhbGxldEFwaSwgZGVmYXVsdFdhbGxldCB9ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHsgaW5zY3JpcHRpb24sIG1vdmVUb05leHRTdGVwIH0gPSB1c2VUeFN0YXR1cygpO1xuXG4gIGNvbnN0IHVwZGF0ZUZpbGVQcm9ncmVzcyA9IHVzZUNhbGxiYWNrKFxuICAgIChpbmRleDogbnVtYmVyLCB1cGRhdGVzOiBQYXJ0aWFsPEZpbGVQcm9ncmVzcz4pID0+IHtcbiAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgcHJldi5tYXAoKGl0ZW0sIGkpID0+IChpID09PSBpbmRleCA/IHsgLi4uaXRlbSwgLi4udXBkYXRlcyB9IDogaXRlbSkpXG4gICAgICApO1xuICAgIH0sXG4gICAgW11cbiAgKTtcblxuICBjb25zdCBjbGVhckVycm9yID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEVycm9yKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RmlsZVByb2dyZXNzKFtdKTtcbiAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIHNldFN1Ym1pc3Npb25TdGF0dXModW5kZWZpbmVkKTtcbiAgICBzZXRVbnNpZ25lZFR4KHVuZGVmaW5lZCk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjb25zdHJ1Y3RJbnNjcmlwdGlvblR4ID0gYXN5bmMgKFxuICAgIGFwaTogVFdhbGxldEFQSSxcbiAgICBkYXRhOiBzdHJpbmcsXG4gICAgZGF0YVR5cGU6IFREYXRhVHlwZXNcbiAgKTogUHJvbWlzZTxDb25zdHJ1Y3RUeFJlc3BvbnNlPiA9PiB7XG4gICAgY29uc3QgcmV3YXJkQWRkcmVzc2VzID0gKGF3YWl0IGFwaS5nZXRSZXdhcmRBZGRyZXNzZXMoKSkgYXMgc3RyaW5nW107XG4gICAgY29uc3QgdXR4b3MgPSAoYXdhaXQgYXBpLmdldFV0eG9zKCkpIHx8IFtdO1xuICAgIGNvbnNvbGUubG9nKFwiVVRYT3M6XCIsIHV0eG9zKTtcbiAgICBjb25zdCB0YXJnZXRBZGRyZXNzID0gKGF3YWl0IGFwaS5nZXRVc2VkQWRkcmVzc2VzKCkpWzBdO1xuICAgIGlmICghdXR4b3MgfHwgdXR4b3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRFcnJvcihcIk5vIGhheSBVVFhPcyBkaXNwb25pYmxlc1wiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFVUWE9zIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5OiBDb25zdHJ1Y3RUeEluc2NyaWJlUmVxdWVzdCA9IHtcbiAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICBwYXlsb2FkVHlwZTogZGF0YVR5cGUsXG4gICAgICByZXdhcmRBZGRyZXNzZXMsXG4gICAgICBjaGFuZ2VBZGRyZXNzOiB0YXJnZXRBZGRyZXNzLFxuICAgICAgdXR4b3MsXG4gICAgICBtaW50VG9rZW5Gb3JQYXlsb2FkOiBcIk5vTWludGluZ1wiLFxuICAgIH07XG4gICAgY29uc29sZS5sb2coXCJCb2R5OlwiLCBib2R5KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYnVpbGRBcGlVcmwoXCIvaW5zY3JpcHRpb25zL2NvbnN0cnVjdC10eFwiKSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIFwieC1hcGkta2V5XCI6IEFQSV9LRVkgfHwgXCJcIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3JSZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICBlbmRwb2ludDogXCIvaW5zY3JpcHRpb25zL2NvbnN0cnVjdC10eFwiLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gQXZhbnphbW9zIGVuIGVsIGZsdWpvIGRlIGluc2NyaXBjacOzblxuICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgY29uc3QgY29uc3RydWN0ZWRUeCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zb2xlLmxvZyhcIkNvbnN0cnVjdGVkIFRYOlwiLCBjb25zdHJ1Y3RlZFR4KTtcbiAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIHJldHVybiBjb25zdHJ1Y3RlZFR4O1xuICB9O1xuXG4gIGNvbnN0IGluc2NyaWJlRmlsZXMgPSBhc3luYyAoZmlsZXM6IEZpbGVbXSkgPT4ge1xuICAgIGlmICghZGVmYXVsdFdhbGxldCkgdGhyb3cgbmV3IEVycm9yKFwiTm8gd2FsbGV0IGNvbm5lY3RlZFwiKTtcbiAgICBjb25zdCBhcGkgPSBnZXRXYWxsZXRBcGkoZGVmYXVsdFdhbGxldCkgYXMgVFdhbGxldEFQSTtcbiAgICBzZXRJc1Byb2Nlc3NpbmcodHJ1ZSk7XG5cbiAgICB0cnkge1xuICAgICAgc2V0RmlsZVByb2dyZXNzKFxuICAgICAgICBmaWxlcy5tYXAoKGZpbGUpID0+ICh7XG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICB9KSlcbiAgICAgICk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHsgc3RhdHVzOiBcImNvbnN0cnVjdGluZ1wiLCBwcm9ncmVzczogMjUgfSk7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGZpbGVBc0Jhc2U2NCA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHJlYWRlci5yZXN1bHQgYXMgc3RyaW5nKTtcbiAgICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlc1tpXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBiYXNlNjRDb250ZW50ID0gZmlsZUFzQmFzZTY0LnNwbGl0KFwiLFwiKVsxXTtcbiAgICAgICAgY29uc3QgY29uc3RydWN0ZWRUeCA9IGF3YWl0IGNvbnN0cnVjdEluc2NyaXB0aW9uVHgoXG4gICAgICAgICAgYXBpLFxuICAgICAgICAgIGJhc2U2NENvbnRlbnQsXG4gICAgICAgICAgZmlsZXNbaV0udHlwZSBhcyBURGF0YVR5cGVzXG4gICAgICAgICk7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgc3RhdHVzOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDUwLFxuICAgICAgICAgIHR4SW5mbzogeyBjb25zdHJ1Y3RlZFR4IH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluc2NyaWJpbmcgZmlsZXM6XCIsIGVycm9yKTtcbiAgICAgIHNldEVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGluc2NyaWJlVGV4dCA9IGFzeW5jICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBjb25uZWN0ZWRcIik7XG4gICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHRleHRGaWxlID0gbmV3IEZpbGUoW3RleHRdLCBcImluc2NyaXB0aW9uLnR4dFwiLCB7XG4gICAgICAgIHR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgICAgfSk7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoW1xuICAgICAgICB7XG4gICAgICAgICAgZmlsZTogdGV4dEZpbGUsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgfSxcbiAgICAgIF0pO1xuXG4gICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoMCwgeyBzdGF0dXM6IFwiY29uc3RydWN0aW5nXCIsIHByb2dyZXNzOiAyNSB9KTtcbiAgICAgIGNvbnNvbGUubG9nKFwidGV4dFwiLCB0ZXh0KTtcbiAgICAgIGNvbnN0IGJhc2U2NENvbnRlbnQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSkpO1xuICAgICAgY29uc29sZS5sb2coXCJiYXNlNjRDb250ZW50XCIsIGJhc2U2NENvbnRlbnQpO1xuICAgICAgY29uc3QgY29uc3RydWN0ZWRUeCA9IGF3YWl0IGNvbnN0cnVjdEluc2NyaXB0aW9uVHgoXG4gICAgICAgIGFwaSxcbiAgICAgICAgYmFzZTY0Q29udGVudCxcbiAgICAgICAgXCJ0ZXh0L3BsYWluXCIgYXMgVERhdGFUeXBlc1xuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiY29uc3RydWN0ZWRUeFwiLCBjb25zdHJ1Y3RlZFR4KTtcblxuICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKDAsIHtcbiAgICAgICAgc3RhdHVzOiBcInVuc2lnbmVkXCIsXG4gICAgICAgIHByb2dyZXNzOiA1MCxcbiAgICAgICAgdHhJbmZvOiB7IGNvbnN0cnVjdGVkVHggfSxcbiAgICAgIH0pO1xuXG4gICAgICBtb3ZlVG9OZXh0U3RlcChcImluc2NyaXB0aW9uXCIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW5zY3JpYmluZyB0ZXh0OlwiLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwb2xsRm9yQ29uZmlybWF0aW9uID0gYXN5bmMgKFxuICAgIHByZXBhcmVkVHg6IFByZXBhcmVkVVRYT3NcbiAgKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDkwMDA7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICAgIGJ1aWxkQXBpVXJsKFwiL2luc2NyaXB0aW9ucy9yZXRyaWV2ZS1zdWJtaXNzaW9uLXN0YXR1c1wiKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSB8fCBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByZXBhcmVkVHguZXhlY3V0aW9uQXJuKSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gU2kgZWwgc2Vydmlkb3IgcmVzcG9uZGUgY29uIHVuIGVycm9yIDUwMCwgc2UgaW50ZXJydW1wZSBlbCBsb29wXG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IGVycm9yUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL2luc2NyaXB0aW9ucy9yZXRyaWV2ZS1zdWJtaXNzaW9uLXN0YXR1c1wiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUGFyc2UgdGhlIHJlc3BvbnNlIGNhcmVmdWxseSB0byBoYW5kbGUgcG90ZW50aWFsIEpTT04gZGVjb2RpbmcgZXJyb3JzXG4gICAgICAgIGxldCBzdGF0dXM6IFRJbnNjcmlwdGlvblN1Ym1pc3Npb25TdGF0dXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIFN0YXRlcy5UaW1lb3V0IGVycm9yXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcmVzcG9uc2VUZXh0LmluY2x1ZGVzKFwiU3RhdGVzLlRpbWVvdXRcIikgfHxcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dC5pbmNsdWRlcyhcIkpzb25EZWNvZGVFcnJvclwiKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgXCJUaW1lb3V0IG9yIEpTT04gZGVjb2RlIGVycm9yIGRldGVjdGVkOlwiLFxuICAgICAgICAgICAgICByZXNwb25zZVRleHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgICAgICBcIlRyYW5zYWN0aW9uIHByb2Nlc3NpbmcgdGltZWQgb3V0IG9yIGVuY291bnRlcmVkIGEgZGVjb2RpbmcgZXJyb3IuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCI7XG4gICAgICAgICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGF0dXMgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCk7XG4gICAgICAgIH0gY2F0Y2ggKHBhcnNlRXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyByZXNwb25zZTpcIiwgcGFyc2VFcnJvcik7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwYXJzZSBzdWJtaXNzaW9uIHN0YXR1cyByZXNwb25zZVwiLFxuICAgICAgICAgICAgICBlcnJvcjpcbiAgICAgICAgICAgICAgICBwYXJzZUVycm9yIGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAgID8gcGFyc2VFcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICA6IFN0cmluZyhwYXJzZUVycm9yKSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL2luc2NyaXB0aW9ucy9yZXRyaWV2ZS1zdWJtaXNzaW9uLXN0YXR1c1wiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2UgZXNwZXJhIHF1ZSBlbCBlbmRwb2ludCByZXRvcm5lIHsgaW5Qcm9ncmVzczogXCJzdHJpbmdcIiB9IG1pZW50cmFzIG5vIGVzdMOpIG9uLWNoYWluXG4gICAgICAgIC8vIHkgZW4gY2FzbyBkZSDDqXhpdG8gcmV0b3JuZSB7IHN1Y2Nlc3M6IHsgb25jaGFpbjogXCJvbi1jaGFpblwiLCAuLi4gfSB9XG4gICAgICAgIGlmIChzdGF0dXMuc3VjY2VzcyAmJiBzdGF0dXMuc3VjY2Vzcy5vbmNoYWluKSB7XG4gICAgICAgICAgc2V0U3VibWlzc2lvblN0YXR1cyhzdGF0dXMpO1xuICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zYWN0aW9uIHJldHJpZXZlZDpcIiwgc3RhdHVzKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzLmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zYWN0aW9uIHN0aWxsIGluIHByb2dyZXNzLi4uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJVbmV4cGVjdGVkIHN1Ym1pc3Npb24gc3RhdHVzIHJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL2luc2NyaXB0aW9ucy9yZXRyaWV2ZS1zdWJtaXNzaW9uLXN0YXR1c1wiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCByZXRyeUludGVydmFsKSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiUG9sbGluZyBhdHRlbXB0IGZhaWxlZDpcIiwgZXJyb3IpO1xuXG4gICAgICAgIC8vIEZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZSBmb3IgYmV0dGVyIHJlYWRhYmlsaXR5XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2U6IHN0cmluZztcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBlcnJvciBtZXNzYWdlIGFzIEpTT04gZm9yIGJldHRlciBmb3JtYXR0aW5nXG4gICAgICAgICAgICBjb25zdCBwYXJzZWRFcnJvciA9IEpTT04ucGFyc2UoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkRXJyb3IuZXJyb3IgJiYgdHlwZW9mIHBhcnNlZEVycm9yLmVycm9yID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgc3BlY2lmaWMgSnNvbkRlY29kZUVycm9yIGNhc2VcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHBhcnNlZEVycm9yLmVycm9yLm1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICBwYXJzZWRFcnJvci5lcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdrZXkgXCJvbmNoYWluXCIgbm90IGZvdW5kJylcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICAgICAgICAgIFwiVHJhbnNhY3Rpb24gcHJvY2Vzc2luZyBlcnJvcjogVGhlIHRyYW5zYWN0aW9uIGRhdGEgaXMgaW5jb21wbGV0ZS4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci5cIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgRXJyb3I6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBwYXJzZWRFcnJvci5lcnJvcixcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgKX1gO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHVzZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcblxuICAgICAgICAvLyBVcGRhdGUgZmlsZSBwcm9ncmVzcyB0byBmYWlsZWRcbiAgICAgICAgc2V0RmlsZVByb2dyZXNzKChwcmV2KSA9PlxuICAgICAgICAgIHByZXYubWFwKChmaWxlKSA9PiAoeyAuLi5maWxlLCBzdGF0dXM6IFwiZmFpbGVkXCIsIHByb2dyZXNzOiAwIH0pKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlU2lnbkFuZFN1Ym1pdEVycm9yID0gKGVycm9yOiBhbnkpID0+IHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gc2lnbiBhbmQgc3VibWl0IGZvciBpbnNjcmlwdGlvbjpcIiwgZXJyb3IpO1xuXG4gICAgLy8gRm9ybWF0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIHRoZSBlcnJvciB0eXBlXG4gICAgbGV0IGVycm9yTWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLy8gSGFuZGxlIFR4U2lnbkVycm9yIGZyb20gd2FsbGV0XG4gICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiVHhTaWduRXJyb3JcIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYFdhbGxldCBzaWduaW5nIGVycm9yOiAke1xuICAgICAgICBlcnJvci5pbmZvIHx8IGVycm9yLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvblwiXG4gICAgICB9YDtcbiAgICAgIC8vIE5vIGFjdHVhbGl6YW1vcyBlbCBlc3RhZG8gZGUgbG9zIGFyY2hpdm9zIGFxdcOtIHlhIHF1ZSBsbyBoYWNlbW9zIGVuIGVsIGNhdGNoIGRlbCBzaWduXG4gICAgICAvLyBTb2xvIGxpbXBpYW1vcyBlbCBlcnJvciB5IHBlcm1pdGltb3MgcmVpbnRlbnRhclxuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgXCJXYWxsZXQgc2lnbmluZyBlcnJvciBkZXRlY3RlZCwga2VlcGluZyBjdXJyZW50IHN0ZXAgZm9yIHJldHJ5XCJcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBFcnJvciBvYmplY3RzXG4gICAgZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVHJ5IHRvIHBhcnNlIHRoZSBlcnJvciBtZXNzYWdlIGFzIEpTT05cbiAgICAgICAgY29uc3QgcGFyc2VkRXJyb3IgPSBKU09OLnBhcnNlKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvck1lc3NhZ2UgPVxuICAgICAgICAgIHBhcnNlZEVycm9yLmVycm9yPy5tZXNzYWdlIHx8IHBhcnNlZEVycm9yLm1lc3NhZ2UgfHwgZXJyb3IubWVzc2FnZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgcGFyc2luZyBmYWlscywgdXNlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlXG4gICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHwgXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICB9XG5cbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChmaWxlKSA9PiAoeyAuLi5maWxlLCBzdGF0dXM6IFwiZmFpbGVkXCIsIHByb2dyZXNzOiAwIH0pKVxuICAgICAgKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAvLyBGb3Igb3RoZXIgZXJyb3JzLCByZXNldCB0byB0aGUgYmVnaW5uaW5nXG4gICAgICBjb25zb2xlLmxvZyhcIk90aGVyIGVycm9yIGRldGVjdGVkLCBtb3ZpbmcgdG8gZW5kOiBcIiwgZXJyb3IpO1xuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJlbmRcIik7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBvdGhlciBlcnJvciB0eXBlc1xuICAgIGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIlVua25vd24gZXJyb3Igb2NjdXJyZWRcIjtcbiAgICAgIH1cblxuICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgcHJldi5tYXAoKGZpbGUpID0+ICh7IC4uLmZpbGUsIHN0YXR1czogXCJmYWlsZWRcIiwgcHJvZ3Jlc3M6IDAgfSkpXG4gICAgICApO1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgIC8vIEZvciBvdGhlciBlcnJvcnMsIHJlc2V0IHRvIHRoZSBiZWdpbm5pbmdcbiAgICAgIGNvbnNvbGUubG9nKFwiT3RoZXIgZXJyb3IgZGV0ZWN0ZWQsIG1vdmluZyB0byBlbmQ6IFwiLCBlcnJvcik7XG4gICAgICBtb3ZlVG9OZXh0U3RlcChcImVuZFwiKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3Qgc2lnbkFuZFN1Ym1pdCA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBjb25uZWN0ZWRcIik7XG4gICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZVByb2dyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlUHJvZ3Jlc3NbaV07XG4gICAgICAgIGlmICghZmlsZS50eEluZm8/LmNvbnN0cnVjdGVkVHgpIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB7IGV4ZWN1dGlvbkFybiB9ID0gZmlsZS50eEluZm8uY29uc3RydWN0ZWRUeDtcbiAgICAgICAgY29uc29sZS5sb2coXCJleGVjdXRpb25Bcm5cIiwgZXhlY3V0aW9uQXJuKTtcblxuICAgICAgICAvLyBTb2xvIG9idGVuZXIgdW5zaWduZWRUeCBzaSBubyBsbyB0ZW5lbW9zIHlhXG4gICAgICAgIGxldCB1bnNpZ25lZFR4ID0gZmlsZS50eEluZm9cbiAgICAgICAgICAudW5zaWduZWRUeCBhcyBSZXRyaWV2ZVVuc2lnbmVkSW5zY3JpcHRpb25UeFJlc3BvbnNlO1xuICAgICAgICBpZiAoIXVuc2lnbmVkVHgpIHtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRUeFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgICAgIGJ1aWxkQXBpVXJsKFwiL2luc2NyaXB0aW9ucy9yZXRyaWV2ZS11bnNpZ25lZC10eFwiKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShleGVjdXRpb25Bcm4pLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoIXVuc2lnbmVkVHhSZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSB1bnNpZ25lZFR4UmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBlcnJvclJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHVuc2lnbmVkVHhSZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgIHN0YXR1czogdW5zaWduZWRUeFJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHVuc2lnbmVkVHhSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9pbnNjcmlwdGlvbnMvcmV0cmlldmUtdW5zaWduZWQtdHhcIixcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1bnNpZ25lZFR4ID0gYXdhaXQgdW5zaWduZWRUeFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5zaWduZWQgVFg6XCIsIHVuc2lnbmVkVHgpO1xuXG4gICAgICAgICAgICBpZiAodW5zaWduZWRUeC5zdWNjZXNzICYmIHVuc2lnbmVkVHguc3VjY2Vzcy5pbmRleGluZ1R4KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5zaWduZWQgdHJhbnNhY3Rpb24gcmV0cmlldmVkOlwiLCB1bnNpZ25lZFR4KTtcbiAgICAgICAgICAgICAgc2V0VW5zaWduZWRUeCh1bnNpZ25lZFR4KTtcbiAgICAgICAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh1bnNpZ25lZFR4LmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbnNpZ25lZCB0cmFuc2FjdGlvbiBzdGlsbCBpbiBwcm9ncmVzcy4uLlwiKTtcbiAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIDUwMDApKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgICBcIlVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgcmV0cmlldmluZyB1bnNpZ25lZCB0cmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHVuc2lnbmVkVHgsXG4gICAgICAgICAgICAgICAgICBlbmRwb2ludDogXCIvaW5zY3JpcHRpb25zL3JldHJpZXZlLXVuc2lnbmVkLXR4XCIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoaSwge1xuICAgICAgICAgIHByb2dyZXNzOiA3NSxcbiAgICAgICAgICB0eEluZm86IHsgLi4uZmlsZS50eEluZm8sIHVuc2lnbmVkVHggfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbGV0IHNpZ25lZFR4O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBlcnJvciBzdGF0ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBzaWduIGFnYWluXG4gICAgICAgICAgY2xlYXJFcnJvcigpO1xuXG4gICAgICAgICAgLy8gR2V0IGEgZnJlc2ggd2FsbGV0IEFQSSBpbnN0YW5jZSB0byBlbnN1cmUgdGhlIHBvcHVwIGFwcGVhcnMgYWdhaW5cbiAgICAgICAgICBjb25zdCBhcGkgPSBnZXRXYWxsZXRBcGkoZGVmYXVsdFdhbGxldCkgYXMgVFdhbGxldEFQSTtcblxuICAgICAgICAgIHNpZ25lZFR4ID0gYXdhaXQgYXBpLnNpZ25UeChcbiAgICAgICAgICAgIGJhc2U2NFRvSGV4KHVuc2lnbmVkVHguc3VjY2Vzcy5pbmRleGluZ1R4KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTaWduZWQgVFg6XCIsIHNpZ25lZFR4KTtcbiAgICAgICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoaSwge1xuICAgICAgICAgICAgc3RhdHVzOiBcInNpZ25lZFwiLFxuICAgICAgICAgICAgcHJvZ3Jlc3M6IDg1LFxuICAgICAgICAgICAgdHhJbmZvOiB7IC4uLmZpbGUudHhJbmZvLCB1bnNpZ25lZFR4LCBzaWduZWRUeCB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2lnbmluZyB0cmFuc2FjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgIC8vIERvbid0IG1vdmUgdG8gdGhlIG5leHQgc3RlcCBpZiB0aGVyZSdzIGEgc2lnbmluZyBlcnJvclxuICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSB1c2VyIHRvIHJldHJ5IHNpZ25pbmcgZnJvbSB0aGUgc2FtZSBzdGVwXG4gICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiVHhTaWduRXJyb3JcIikge1xuICAgICAgICAgICAgLy8gTWFudGVuZXIgZWwgZXN0YWRvIGFjdHVhbCB5IHBlcm1pdGlyIHJlaW50ZW50YXJcbiAgICAgICAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgICAgICAgcHJldi5tYXAoKGl0ZW0sIGlkeCkgPT5cbiAgICAgICAgICAgICAgICBpZHggPT09IGlcbiAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDc1LFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA6IGl0ZW1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBMZXQgdGhlIGhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciBmdW5jdGlvbiBoYW5kbGUgdGhpcyBzcGVjaWZpYyBlcnJvclxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBGYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvbjogJHtcbiAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlIHx8IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICAgICAgICB9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzaWduZWRTaGFyZFR4cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHVuc2lnbmVkVHguc3VjY2Vzcy5zaGFyZFR4cy5tYXAoYXN5bmMgKHNoYXJkVHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleFNoYXJkVHggPSBiYXNlNjRUb0hleChzaGFyZFR4KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSGV4IFNoYXJkIFRYOlwiLCBoZXhTaGFyZFR4KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEdldCBhIGZyZXNoIHdhbGxldCBBUEkgaW5zdGFuY2UgZm9yIGVhY2ggc2hhcmQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG4gICAgICAgICAgICAgIHJldHVybiBhd2FpdCBhcGkuc2lnblR4KGhleFNoYXJkVHgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igc2lnbmluZyBzaGFyZCB0cmFuc2FjdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgICAvLyBNYW50ZW5lciBlbCBlc3RhZG8gYWN0dWFsIHkgcGVybWl0aXIgcmVpbnRlbnRhclxuICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJUeFNpZ25FcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgc2V0RmlsZVByb2dyZXNzKChwcmV2KSA9PlxuICAgICAgICAgICAgICAgICAgcHJldi5tYXAoKGl0ZW0sIGlkeCkgPT5cbiAgICAgICAgICAgICAgICAgICAgaWR4ID09PSBpXG4gICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC4uLml0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzczogNzUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIDogaXRlbVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7IC8vIExldCB0aGUgaGFuZGxlU2lnbkFuZFN1Ym1pdEVycm9yIGZ1bmN0aW9uIGhhbmRsZSB0aGlzIHNwZWNpZmljIGVycm9yXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgYEZhaWxlZCB0byBzaWduIHNoYXJkIHRyYW5zYWN0aW9uOiAke1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlIHx8IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJTaWduZWQgU2hhcmQgVFhzOlwiLCBzaWduZWRTaGFyZFR4cyk7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgc3RhdHVzOiBcInNpZ25lZFwiLFxuICAgICAgICAgIHByb2dyZXNzOiA5MCxcbiAgICAgICAgICB0eEluZm86IHtcbiAgICAgICAgICAgIC4uLmZpbGUudHhJbmZvLFxuICAgICAgICAgICAgdW5zaWduZWRUeCxcbiAgICAgICAgICAgIHNpZ25lZFR4LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0ZXAgYWZ0ZXIgc3VjY2Vzc2Z1bCBzaWduaW5nIG9mIGFsbCB0cmFuc2FjdGlvbnNcbiAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcblxuICAgICAgICBjb25zdCBpbnNjcmliZVN1Ym1pdEJvZHkgPSB7XG4gICAgICAgICAgaW5kZXhpbmdUeFRvU3VibWl0OiBbdW5zaWduZWRUeC5zdWNjZXNzLmluZGV4aW5nVHgsIHNpZ25lZFR4XSxcbiAgICAgICAgICB0eHNUb1N1Ym1pdDogdW5zaWduZWRUeC5zdWNjZXNzLnNoYXJkVHhzLm1hcCgoc2hhcmRUeCwgaW5kZXgpID0+IFtcbiAgICAgICAgICAgIHNoYXJkVHgsXG4gICAgICAgICAgICBzaWduZWRTaGFyZFR4c1tpbmRleF0sXG4gICAgICAgICAgXSksXG4gICAgICAgICAgdWxpZE9mT2JqZWN0OiB1bnNpZ25lZFR4LnN1Y2Nlc3Mub2JqZWN0VWxpZCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc29sZS5sb2coXCJJbnNjcmliZSBzdWJtaXQgYm9keTpcIiwgaW5zY3JpYmVTdWJtaXRCb2R5KTtcblxuICAgICAgICBjb25zdCBzdWJtaXRSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICAgIGJ1aWxkQXBpVXJsKFwiL2luc2NyaXB0aW9ucy9zdWJtaXRcIiksXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgIFwieC1hcGkta2V5XCI6IEFQSV9LRVkgfHwgXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShpbnNjcmliZVN1Ym1pdEJvZHkpLFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXN1Ym1pdFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHN1Ym1pdFJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBlcnJvclJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBzdWJtaXRSZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBzdWJtaXRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHN1Ym1pdFJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGEsXG4gICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9pbnNjcmlwdGlvbnMvc3VibWl0XCIsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VibWl0dGVkVHg6IFByZXBhcmVkVVRYT3MgPSBhd2FpdCBzdWJtaXRSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3VibWl0dGVkIFRYOlwiLCBzdWJtaXR0ZWRUeCk7XG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgc3RlcCBhZnRlciBzdWNjZXNzZnVsIHN1Ym1pc3Npb25cbiAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICBzdGF0dXM6IFwic3VibWl0dGVkXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDk1LFxuICAgICAgICAgIHR4SW5mbzoge1xuICAgICAgICAgICAgLi4uZmlsZS50eEluZm8sXG4gICAgICAgICAgICB1bnNpZ25lZFR4LFxuICAgICAgICAgICAgc2lnbmVkVHgsXG4gICAgICAgICAgICBzdWJtaXR0ZWRUeCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBwb2xsRm9yQ29uZmlybWF0aW9uKHN1Ym1pdHRlZFR4KTtcbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICBzdGF0dXM6IGNvbmZpcm1lZCA/IFwiY29uZmlybWVkXCIgOiBcImZhaWxlZFwiLFxuICAgICAgICAgIHByb2dyZXNzOiBjb25maXJtZWQgPyAxMDAgOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIC8vIEFsIGZpbmFsaXphciwgc2UgZXN0YWJsZWNlIGVsIGVzdGFkbyBmaW5hbCBcImVuZFwiXG4gICAgICBtb3ZlVG9OZXh0U3RlcChcImVuZFwiKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb2NjdXJyZWQ6XCIsIGVycm9yKTtcbiAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgcHJldi5tYXAoKGZpbGUpID0+ICh7IC4uLmZpbGUsIHN0YXR1czogXCJmYWlsZWRcIiwgcHJvZ3Jlc3M6IDAgfSkpXG4gICAgICApO1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtlcnJvcl0pO1xuXG4gIHJldHVybiAoXG4gICAgPFR4SW5zY3JpcHRpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBmaWxlUHJvZ3Jlc3MsXG4gICAgICAgIGluc2NyaWJlRmlsZXMsXG4gICAgICAgIGluc2NyaWJlVGV4dCxcbiAgICAgICAgc2lnbkFuZFN1Ym1pdCxcbiAgICAgICAgaXNQcm9jZXNzaW5nLFxuICAgICAgICBjdXJyZW50U3RlcDogaW5zY3JpcHRpb24uY3VycmVudFN0ZXAgYXMgVHhJbnNjcmlwdGlvblN0ZXAsXG4gICAgICAgIG5leHRTdGVwOiBpbnNjcmlwdGlvbi5uZXh0U3RlcCBhcyBUeEluc2NyaXB0aW9uU3RlcCB8IG51bGwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBjbGVhckVycm9yLFxuICAgICAgICByZXNldCxcbiAgICAgICAgc3VibWlzc2lvblN0YXR1cyxcbiAgICAgICAgdW5zaWduZWRUeCxcbiAgICAgICAgc2V0VW5zaWduZWRUeCxcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVHhJbnNjcmlwdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIjtcblxuaW50ZXJmYWNlIExvYWRpbmdTY3JlZW5Qcm9wcyB7XG4gIHRleHQ/OiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExvYWRpbmdTY3JlZW4oe1xuICB0ZXh0ID0gXCJMb2FkaW5nLi4uXCIsXG4gIGNsYXNzTmFtZSA9IFwiXCIsXG59OiBMb2FkaW5nU2NyZWVuUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICByZXR1cm4gKFxuICAgIDxtb3Rpb24uZGl2XG4gICAgICBjbGFzc05hbWU9e2B3LWZ1bGwgaC1mdWxsICB6LTUwIGZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHJvdW5kZWQtNHhsICF0ZXh0LXdoaXRlICR7Y2xhc3NOYW1lfSBweS04IGB9XG4gICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICAgICAgZXhpdD17eyBvcGFjaXR5OiAwIH19XG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBnYXAtNlwiPlxuICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cInctMjAgaC0yMFwiXG4gICAgICAgICAgYW5pbWF0ZT17e1xuICAgICAgICAgICAgcm90YXRlWTogMzYwLFxuICAgICAgICAgIH19XG4gICAgICAgICAgdHJhbnNpdGlvbj17e1xuICAgICAgICAgICAgZHVyYXRpb246IDIuNSxcbiAgICAgICAgICAgIHJlcGVhdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgICAgZWFzZTogXCJsaW5lYXJcIi8vXCJlYXNlSW5PdXRcIixcbiAgICAgICAgICB9fVxuICAgICAgICA+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgc3JjPVwiaHR0cHM6Ly9jZG4ucHJvZC53ZWJzaXRlLWZpbGVzLmNvbS82NmMzYjc3OTY3NDkxNWMyODhjYTk5OTgvNjZjNjNmYTYzMDczMzJlMjM5MTA2MDQ0X0xvZ28lMjAoMTEpLnBuZ1wiXG4gICAgICAgICAgICBhbHQ9XCJMb2FkaW5nIHNwaW5uZXJcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbFwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICA8bW90aW9uLnBcbiAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHg6IC0xMCB9fVxuICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeDogMCB9fVxuICAgICAgICAgIHRyYW5zaXRpb249e3sgZGVsYXk6IDAuMiB9fVxuICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtWzEuMjVyZW1dIGZvbnQtbWVkaXVtICF0ZXh0LXdoaXRlXCJcbiAgICAgICAgPlxuICAgICAgICAgIHt0ZXh0fVxuICAgICAgICA8L21vdGlvbi5wPlxuICAgICAgICA8bW90aW9uLnBcbiAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHg6IC0xMCB9fVxuICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeDogMCB9fVxuICAgICAgICAgIHRyYW5zaXRpb249e3sgZGVsYXk6IDAuMiB9fVxuICAgICAgICAgIGNsYXNzTmFtZT1cIiB0ZXh0LVswLjg3NXJlbV0gIXRleHQtd2hpdGVcIlxuICAgICAgICA+XG4gICAgICAgICAgwr9IYXZlIHF1ZXN0aW9ucz8gU2VlIG91cntcIiBcIn1cbiAgICAgICAgICA8YSBjbGFzc05hbWU9XCJ1bmRlcmxpbmUgIXRleHQtd2hpdGVcIiBocmVmPVwiL2ZhcVwiPlxuICAgICAgICAgICAgRkFRc1xuICAgICAgICAgIDwvYT5cbiAgICAgICAgICAuXG4gICAgICAgIDwvbW90aW9uLnA+XG4gICAgICA8L2Rpdj5cbiAgICA8L21vdGlvbi5kaXY+XG4gICk7XG59XG4iLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIjtcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuL0J1dHRvblwiO1xuaW1wb3J0IHsgdXNlRmlsZVVwbG9hZCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L0ZpbGVVcGxvYWRDb250ZXh0XCI7XG5pbXBvcnQgeyB1c2VUeFN0YXR1cyB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1R4U3RhdHVzQ29udGV4dFwiO1xuaW1wb3J0IHsgdXNlVHhJbnNjcmlwdGlvbiB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1R4SW5zY3JpcHRpb25Db250ZXh0XCI7XG5pbXBvcnQgeyB1c2VUeFByZXBhcmF0aW9uIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhQcmVwYXJhdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IFRJbnNjcmlwdGlvblN1Ym1pc3Npb25TdGF0dXMgfSBmcm9tIFwiLi4vLi4vdHlwZXMvdHJhbnNhY3Rpb25cIjtcblxuaW50ZXJmYWNlIEZpbmlzaFNjcmVlblByb3BzIHtcbiAgdGV4dD86IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBzZXRJc1ByZXBhcmVkOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxib29sZWFuPj47XG4gIHNldElzSW5zY3JpYmVkOiBSZWFjdC5EaXNwYXRjaDxSZWFjdC5TZXRTdGF0ZUFjdGlvbjxib29sZWFuPj47XG4gIHNldERlbGVnYXRlVGV4dDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPj47XG4gIHN1Ym1pc3Npb25TdGF0dXM/OiBUSW5zY3JpcHRpb25TdWJtaXNzaW9uU3RhdHVzO1xuICBwcmVwYXJhdGlvblR4SWQ/OiBzdHJpbmc7XG4gIHVuc2lnbmVkVHhJZD86IHN0cmluZztcbiAgaW5kZXhpbmdUeElkPzogc3RyaW5nO1xuICBzaGFyZFR4SWRzPzogc3RyaW5nW107XG59XG5cbmV4cG9ydCBjb25zdCBFeHBsb3JlckxpbmsgPSAoeyB0eElkIH06IHsgdHhJZDogc3RyaW5nIH0pID0+IChcbiAgPGFcbiAgICBocmVmPXtgaHR0cHM6Ly9wcmVwcm9kLmNhcmRhbm9zY2FuLmlvL3RyYW5zYWN0aW9uLyR7dHhJZH1gfVxuICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgIGhvdmVyOm9wYWNpdHktODAgdHJhbnNpdGlvbi1jb2xvcnMgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgdy1mdWxsXCJcbiAgPlxuICAgIDxzdmdcbiAgICAgIGNsYXNzTmFtZT1cInctNCBoLTRcIlxuICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTkgNUg3QzUuODk1NDMgNSA1IDUuODk1NDMgNSA3VjE5QzUgMjAuMTA0NiA1Ljg5NTQzIDIxIDcgMjFIMTdDMTguMTA0NiAyMSAxOSAyMC4xMDQ2IDE5IDE5VjdDMTkgNS44OTU0MyAxOC4xMDQ2IDUgMTcgNUgxNVwiXG4gICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xMiAxMlYzTTEyIDNMOSA2TTEyIDNMMTUgNlwiXG4gICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgICB7dHhJZH1cbiAgPC9hPlxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEZpbmlzaFNjcmVlbih7XG4gIHRleHQgPSBcIllvdXIgc3VibWlzc2lvbnMgYXJlIG5vdyBpbnNjcmliZWQgT25jaGFpbi5cIixcbiAgY2xhc3NOYW1lID0gXCJcIixcbiAgc2V0SXNQcmVwYXJlZCxcbiAgc2V0SXNJbnNjcmliZWQsXG4gIHNldERlbGVnYXRlVGV4dCxcbiAgc3VibWlzc2lvblN0YXR1cyxcbiAgcHJlcGFyYXRpb25UeElkLFxuICB1bnNpZ25lZFR4SWQsXG4gIGluZGV4aW5nVHhJZCxcbiAgc2hhcmRUeElkcyxcbn06IEZpbmlzaFNjcmVlblByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgY29uc3QgeyByZXNldFN0YXR1cywgc2V0SW5zY3JpcHRpb25TdGF0dXMsIHNldFByZXBhcmF0aW9uU3RhdHVzIH0gPVxuICAgIHVzZVR4U3RhdHVzKCk7XG4gIGNvbnN0IHsgY2xlYXJGaWxlIH0gPSB1c2VGaWxlVXBsb2FkKCk7XG4gIGNvbnN0IHsgcmVzZXQgfSA9IHVzZVR4SW5zY3JpcHRpb24oKTtcbiAgY29uc3QgeyByZXNldDogcmVzZXRQcmVwYXJhdGlvbiB9ID0gdXNlVHhQcmVwYXJhdGlvbigpO1xuXG4gIHJldHVybiAoXG4gICAgPG1vdGlvbi5kaXZcbiAgICAgIGNsYXNzTmFtZT17YHctZnVsbCBoLWZ1bGwgei01MCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLTR4bCAhdGV4dC13aGl0ZSAke2NsYXNzTmFtZX1gfVxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCB9fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLTZcIj5cbiAgICAgICAgPG1vdGlvbi5kaXYgY2xhc3NOYW1lPVwidy1bMS40NTQ1NnJlbV0gaC1bMXJlbV1cIj5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgICAgICBoZWlnaHQ9XCIxMDAlXCJcbiAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjggMjBcIlxuICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgIGQ9XCJNMjUuNjM2NCAyTDkuNjM2MzcgMThMMi4zNjM2NSAxMC43MjczXCJcbiAgICAgICAgICAgICAgc3Ryb2tlPVwiIzJCODBGRlwiXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMi45MDkwOVwiXG4gICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciB0ZXh0LVsxLjI1cmVtXVwiPnt0ZXh0fTwvcD5cblxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTQgaXRlbXMtY2VudGVyIHRleHQtc20gdy1mdWxsIG10LTRcIj5cbiAgICAgICAgICB7LyogUHJlcGFyYXRpb24gVHJhbnNhY3Rpb24gU2VjdGlvbiAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdy1mdWxsXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGZvbnQtc2VtaWJvbGRcIj5QcmVwYXJhdGlvbiBQaGFzZTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXItdCBib3JkZXItd2hpdGUvMjAgbXktMVwiPjwvZGl2PlxuXG4gICAgICAgICAgICB7cHJlcGFyYXRpb25UeElkICYmIChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIG10LTJcIj5cbiAgICAgICAgICAgICAgICAgIFByZXBhcmF0aW9uIFRyYW5zYWN0aW9uOlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxFeHBsb3JlckxpbmsgdHhJZD17cHJlcGFyYXRpb25UeElkfSAvPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICB7LyogSW5zY3JpcHRpb24gVHJhbnNhY3Rpb24gU2VjdGlvbiAqL31cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdy1mdWxsIG10LTRcIj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgZm9udC1zZW1pYm9sZFwiPkluc2NyaXB0aW9uIFBoYXNlPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvcmRlci10IGJvcmRlci13aGl0ZS8yMCBteS0xXCI+PC9kaXY+XG5cbiAgICAgICAgICAgIHtpbmRleGluZ1R4SWQgJiYgKFxuICAgICAgICAgICAgICA8PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgbXQtMlwiPkluZGV4aW5nIFRyYW5zYWN0aW9uOjwvZGl2PlxuICAgICAgICAgICAgICAgIDxFeHBsb3JlckxpbmsgdHhJZD17aW5kZXhpbmdUeElkfSAvPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHsvKiBTaGFyZCBUcmFuc2FjdGlvbnMgU2VjdGlvbiAqL31cbiAgICAgICAgICAgIHtzaGFyZFR4SWRzICYmIHNoYXJkVHhJZHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMiB3LWZ1bGwgbXQtMlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODBcIj5TaGFyZCBUcmFuc2FjdGlvbnM6PC9kaXY+XG4gICAgICAgICAgICAgICAge3NoYXJkVHhJZHMubWFwKChzaGFyZFR4SWQsIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICA8RXhwbG9yZXJMaW5rIGtleT17aW5kZXh9IHR4SWQ9e3NoYXJkVHhJZH0gLz5cbiAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApfVxuXG4gICAgICAgICAgICB7LyogRmFsbGJhY2sgdG8gc3VibWlzc2lvblN0YXR1cyBpZiBwcm9wcyBub3QgcHJvdmlkZWQgKi99XG4gICAgICAgICAgICB7c3VibWlzc2lvblN0YXR1cz8uc3VjY2VzcyAmJiAhaW5kZXhpbmdUeElkICYmIChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIG10LTJcIj5JbmRleGluZyBUcmFuc2FjdGlvbjo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8RXhwbG9yZXJMaW5rIHR4SWQ9e3N1Ym1pc3Npb25TdGF0dXMuc3VjY2Vzcy5pbmRleGluZ1R4SWR9IC8+XG4gICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAge3N1Ym1pc3Npb25TdGF0dXM/LnN1Y2Nlc3MgJiZcbiAgICAgICAgICAgICAgc3VibWlzc2lvblN0YXR1cy5zdWNjZXNzLmFsbFNoYXJkU3VibWlzc2lvbnMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAhc2hhcmRUeElkcyAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yIHctZnVsbCBtdC0yXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwXCI+U2hhcmQgVHJhbnNhY3Rpb25zOjwvZGl2PlxuICAgICAgICAgICAgICAgICAge3N1Ym1pc3Npb25TdGF0dXMuc3VjY2Vzcy5hbGxTaGFyZFN1Ym1pc3Npb25zLm1hcChcbiAgICAgICAgICAgICAgICAgICAgKHNoYXJkLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxFeHBsb3JlckxpbmtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgICB0eElkPXtzaGFyZC5zaGFyZFN1Ym1pdHRlZFR4aWR9XG4gICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPEJ1dHRvblxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgIHJlc2V0U3RhdHVzKFwicHJlcGFyYXRpb25cIik7XG4gICAgICAgICAgICByZXNldFN0YXR1cyhcImluc2NyaXB0aW9uXCIpO1xuICAgICAgICAgICAgc2V0SW5zY3JpcHRpb25TdGF0dXMoe30pO1xuICAgICAgICAgICAgc2V0UHJlcGFyYXRpb25TdGF0dXMoe30pO1xuICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgIHJlc2V0UHJlcGFyYXRpb24oKTtcbiAgICAgICAgICAgIGNsZWFyRmlsZSgpO1xuICAgICAgICAgICAgc2V0SXNQcmVwYXJlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXRJc0luc2NyaWJlZChmYWxzZSk7XG4gICAgICAgICAgICBzZXREZWxlZ2F0ZVRleHQoXCJcIik7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJtdC00XCJcbiAgICAgICAgPlxuICAgICAgICAgIEluc2NyaWJlIG1vcmVcbiAgICAgICAgPC9CdXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L21vdGlvbi5kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBQcm9ncmVzc0JhclByb3BzIHtcbiAgY3VycmVudFN0ZXA6IG51bWJlcjtcbiAgdG90YWxTdGVwczogbnVtYmVyO1xuICBzdGVwVGV4dDogc3RyaW5nO1xuICBwaGFzZTogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgUHJvZ3Jlc3NCYXI6IFJlYWN0LkZDPFByb2dyZXNzQmFyUHJvcHM+ID0gKHtcbiAgY3VycmVudFN0ZXAsXG4gIHRvdGFsU3RlcHMsXG4gIHN0ZXBUZXh0LFxuICBwaGFzZSxcbn0pID0+IHtcbiAgY29uc3QgcHJvZ3Jlc3MgPSAoY3VycmVudFN0ZXAgLyB0b3RhbFN0ZXBzKSAqIDEwMDtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlciBtYi0yXCI+XG4gICAgICAgIDxzcGFuXG4gICAgICAgICAgY2xhc3NOYW1lPXtgdGV4dC1zbSB0ZXh0LXdoaXRlLzgwIGZvbnQtYm9sZGB9XG4gICAgICAgID5cbiAgICAgICAgICBTdGVwIHtjdXJyZW50U3RlcH0gb2Yge3RvdGFsU3RlcHN9OiB7c3RlcFRleHR9XG4gICAgICAgIDwvc3Bhbj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXdoaXRlLzgwXCI+e3BoYXNlfTwvc3Bhbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC0yIGJnLXdoaXRlLzIwIHJvdW5kZWQtZnVsbCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cImgtZnVsbCBiZy1ibHVlLTUwMCByb3VuZGVkLWZ1bGwgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0XCJcbiAgICAgICAgICBzdHlsZT17eyB3aWR0aDogYCR7cHJvZ3Jlc3N9JWAgfX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApO1xufTtcbiIsIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIjtcbmltcG9ydCB7IFVwbG9hZEJveCB9IGZyb20gXCIuL3VwbG9hZC1ib3hcIjtcbmltcG9ydCB7IEZpbGVMaXN0IH0gZnJvbSBcIi4vZmlsZS1saXN0XCI7XG5pbXBvcnQgeyBEZWxlZ2F0ZVZpZXcgfSBmcm9tIFwiLi9kZWxlZ2F0ZS12aWV3XCI7XG5pbXBvcnQgeyB1c2VUeFByZXBhcmF0aW9uIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhQcmVwYXJhdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IHVzZVR4SW5zY3JpcHRpb24gfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeEluc2NyaXB0aW9uQ29udGV4dFwiO1xuaW1wb3J0IHsgTG9hZGluZ1NjcmVlbiB9IGZyb20gXCIuLi91aS9Mb2FkaW5nU2NyZWVuXCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi4vdWkvQnV0dG9uXCI7XG5pbXBvcnQgeyB1c2VGaWxlVXBsb2FkIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvRmlsZVVwbG9hZENvbnRleHRcIjtcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1dhbGxldENvbnRleHRcIjtcbmltcG9ydCB7IEZpbmlzaFNjcmVlbiB9IGZyb20gXCIuLi91aS9GaW5pc2hTY3JlZW5cIjtcbmltcG9ydCB7IHVzZVR4U3RhdHVzIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhTdGF0dXNDb250ZXh0XCI7XG5pbXBvcnQgeyBQcm9ncmVzc0JhciB9IGZyb20gXCIuLi91aS9Qcm9ncmVzc0JhclwiO1xuXG50eXBlIFZpZXcgPSBcImZpbGVzXCIgfCBcImRlbGVnYXRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1haW5VcGxvYWRlcigpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBjb25zdCBbYWN0aXZlVmlldywgc2V0QWN0aXZlVmlld10gPSB1c2VTdGF0ZTxWaWV3PihcImZpbGVzXCIpO1xuICAvLyBTZSB1c2EgZWwgbnVldm8gY29udGV4dG8gcXVlIG1hbmVqYSB1biBzb2xvIGFyY2hpdm9cbiAgY29uc3QgeyBmaWxlLCBjbGVhckZpbGUgfSA9IHVzZUZpbGVVcGxvYWQoKTtcbiAgY29uc3QgeyBkZWZhdWx0V2FsbGV0IH0gPSB1c2VXYWxsZXQoKTtcblxuICBjb25zdCB7XG4gICAgaXNQcm9jZXNzaW5nOiBpc1ByZXBhcmluZyxcbiAgICBjdXJyZW50U3RlcDogcHJlcGFyZVN0ZXAsXG4gICAgbmV4dFN0ZXA6IHByZXBhcmVOZXh0U3RlcCxcbiAgICBlcnJvcjogcHJlcGFyZUVycm9yLFxuICAgIGNsZWFyRXJyb3I6IGNsZWFyUHJlcGFyZUVycm9yLFxuICAgIHByZXBhcmVGaWxlcyxcbiAgICBwcmVwYXJlVGV4dCxcbiAgICBzaWduQW5kU3VibWl0OiBzaWduQW5kU3VibWl0UHJlcGFyYXRpb24sXG4gICAgcmVzZXQ6IHJlc2V0UHJlcGFyYXRpb24sXG4gICAgc3VibWlzc2lvblN0YXR1czogcHJlcGFyYXRpb25TdWJtaXNzaW9uU3RhdHVzLFxuICAgIHVuc2lnbmVkVHhJZCxcbiAgfSA9IHVzZVR4UHJlcGFyYXRpb24oKTtcblxuICBjb25zdCB7XG4gICAgaXNQcm9jZXNzaW5nOiBpc0luc2NyaWJlUHJlcGFyaW5nLFxuICAgIGN1cnJlbnRTdGVwOiBpbnNjcmliZVN0ZXAsXG4gICAgbmV4dFN0ZXA6IGluc2NyaWJlTmV4dFN0ZXAsXG4gICAgZXJyb3I6IGluc2NyaWJlRXJyb3IsXG4gICAgY2xlYXJFcnJvcjogY2xlYXJJbnNjcmliZUVycm9yLFxuICAgIGluc2NyaWJlRmlsZXMsXG4gICAgc2lnbkFuZFN1Ym1pdDogc2lnbkFuZFN1Ym1pdEluc2NyaXB0aW9uLFxuICAgIHJlc2V0OiByZXNldEluc2NyaXB0aW9uLFxuICAgIHN1Ym1pc3Npb25TdGF0dXMsXG4gICAgdW5zaWduZWRUeCxcbiAgfSA9IHVzZVR4SW5zY3JpcHRpb24oKTtcblxuICBjb25zdCBbaXNQcmVwYXJlZCwgc2V0SXNQcmVwYXJlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0luc2NyaWJlZCwgc2V0SXNJbnNjcmliZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZGVsZWdhdGVUZXh0LCBzZXREZWxlZ2F0ZVRleHRdID0gdXNlU3RhdGUoXCJcIik7XG4gIGNvbnN0IHsgcmVzZXRTdGF0dXMgfSA9IHVzZVR4U3RhdHVzKCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcInByZXBhcmVFcnJvclwiLCBwcmVwYXJlRXJyb3IpO1xuICAgIGNvbnNvbGUubG9nKFwiaW5zY3JpYmVFcnJvclwiLCBpbnNjcmliZUVycm9yKTtcbiAgfSwgW3ByZXBhcmVFcnJvciwgaW5zY3JpYmVFcnJvciwgY2xlYXJQcmVwYXJlRXJyb3IsIGNsZWFySW5zY3JpYmVFcnJvcl0pO1xuXG4gIC8vIENvbnNvbGlkYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IGxvZ2ljXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHByZXBhcmVFcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJSZXNldHRpbmcgaXNQcmVwYXJlZCBkdWUgdG8gZXJyb3I6XCIsIHByZXBhcmVFcnJvcik7XG4gICAgICBzZXRJc1ByZXBhcmVkKGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKHByZXBhcmVTdGVwID09PSBcInByZXBhcmUvcmV0cmlldmUtc3VibWlzc2lvblwiIHx8IHByZXBhcmF0aW9uU3VibWlzc2lvblN0YXR1cz8uc3VjY2Vzcz8ub25jaGFpbiA9PT0gXCJvbi1jaGFpblwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkZpbmFsIHByZXBhcmF0aW9uIHN0ZXAgcmVhY2hlZCB3aXRoIG5vIGVycm9ycyBvciB0cmFuc2FjdGlvbiBpcyBvbi1jaGFpbiwgc2V0dGluZyBpc1ByZXBhcmVkIHRvIHRydWVcIik7XG4gICAgICBzZXRJc1ByZXBhcmVkKHRydWUpO1xuICAgIH1cblxuICAgIGlmIChpbnNjcmliZUVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlc2V0dGluZyBpc0luc2NyaWJlZCBkdWUgdG8gZXJyb3I6XCIsIGluc2NyaWJlRXJyb3IpO1xuICAgICAgc2V0SXNJbnNjcmliZWQoZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKFwicHJlcGFyZVN0ZXBcIiwgcHJlcGFyZVN0ZXApO1xuICAgIGNvbnNvbGUubG9nKFwiaW5zY3JpYmVTdGVwXCIsIGluc2NyaWJlU3RlcCk7XG4gICAgY29uc29sZS5sb2coXCJpc1ByZXBhcmVkXCIsIGlzUHJlcGFyZWQpO1xuICAgIGNvbnNvbGUubG9nKFwiaXNJbnNjcmliZWRcIiwgaXNJbnNjcmliZWQpO1xuICB9LCBbcHJlcGFyZUVycm9yLCBwcmVwYXJlU3RlcCwgcHJlcGFyYXRpb25TdWJtaXNzaW9uU3RhdHVzLCBpbnNjcmliZUVycm9yXSk7XG5cbiAgY29uc3QgZ2V0TG9hZGluZ1RleHQgPSAoKSA9PiB7XG4gICAgaWYgKCFpc1ByZXBhcmVkKSB7XG4gICAgICBzd2l0Y2ggKHByZXBhcmVTdGVwKSB7XG4gICAgICAgIGNhc2UgXCJwcmVwYXJlL2NvbnN0cnVjdFwiOlxuICAgICAgICAgIHJldHVybiBcIlByZXBhcmluZyBhbmQgY29uc3RydWN0aW5nIHRyYW5zYWN0aW9uLi4uXCI7XG4gICAgICAgIGNhc2UgXCJwcmVwYXJlL3JldHJpZXZlXCI6XG4gICAgICAgICAgcmV0dXJuIFwiUmV0cmlldmluZyB1dHhvIHByZXBhcmF0aW9uIHRyYW5zYWN0aW9uIGZvciBzaWduaW5nLi4uXCI7XG4gICAgICAgIGNhc2UgXCJwcmVwYXJlL3N1Ym1pdFwiOlxuICAgICAgICAgIHJldHVybiBcIlN1Ym1pdHRpbmcgc2lnbmVkIHRyYW5zYWN0aW9uLi4uXCI7XG4gICAgICAgIGNhc2UgXCJwcmVwYXJlL3JldHJpZXZlLXN1Ym1pc3Npb25cIjpcbiAgICAgICAgICByZXR1cm4gXCJSZXRyaWV2aW5nIHByZXBhcmF0aW9uIHN1Ym1pc3Npb24gc3RhdHVzLi4uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvY2Vzc2luZy4uLlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGluc2NyaWJlU3RlcCkge1xuICAgICAgICBjYXNlIFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiQ29uc3RydWN0aW5nIGluc2NyaXB0aW9uIHRyYW5zYWN0aW9uLi4uXCI7XG4gICAgICAgIGNhc2UgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiOlxuICAgICAgICAgIHJldHVybiBcIlJldHJpZXZpbmcgdXR4byBpbnNjcmlwdGlvbiB0cmFuc2FjdGlvbiBmb3Igc2lnbmluZy4uLlwiO1xuICAgICAgICBjYXNlIFwiaW5zY3JpcHRpb24vc3VibWl0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiU3VibWl0dGluZyBzaWduZWQgdHJhbnNhY3Rpb24uLi5cIjtcbiAgICAgICAgY2FzZSBcImluc2NyaXB0aW9uL3JldHJpZXZlLXN1Ym1pc3Npb25cIjpcbiAgICAgICAgICByZXR1cm4gXCJSZXRyaWV2aW5nIGluc2NyaXB0aW9uIHN1Ym1pc3Npb24gc3RhdHVzLi4uXCI7XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gXCJUcmFuc2FjdGlvbiBzdWJtaXR0ZWQhXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvY2Vzc2luZy4uLlwiO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRQcm9ncmVzc1RleHQgPSAoKSA9PiB7XG4gICAgaWYgKGlzSW5zY3JpYmVkKSB7XG4gICAgICByZXR1cm4gXCJJbnNjcmlwdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IVwiO1xuICAgIH1cblxuICAgIGlmICghaXNQcmVwYXJlZCkge1xuICAgICAgc3dpdGNoIChwcmVwYXJlU3RlcCkge1xuICAgICAgICBjYXNlIFwicHJlcGFyZS9jb25zdHJ1Y3RcIjpcbiAgICAgICAgICByZXR1cm4gXCJTZWxlY3QgY29udGVudCB0byB1cGxvYWRcIjtcbiAgICAgICAgY2FzZSBcInByZXBhcmUvcmV0cmlldmVcIjpcbiAgICAgICAgICByZXR1cm4gXCJTaWduIHlvdXIgdHJhbnNhY3Rpb24ocylcIjtcbiAgICAgICAgY2FzZSBcInByZXBhcmUvc3VibWl0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiU3VibWl0dGluZyB5b3VyIHNpZ25lZCB0cmFuc2FjdGlvbihzKS4uLlwiO1xuICAgICAgICBjYXNlIFwicHJlcGFyZS9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwiVmFsaWRhdGluZyB5b3VyIHRyYW5zYWN0aW9uKHMpIG9uIGNoYWluLi4uXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvY2Vzc2luZy4uLlwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGluc2NyaWJlU3RlcCkge1xuICAgICAgICBjYXNlIFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiQ29uZmlybSB5b3VyIGluc2NyaXB0aW9uIGNvbnRlbnRcIjtcbiAgICAgICAgY2FzZSBcImluc2NyaXB0aW9uL3JldHJpZXZlXCI6XG4gICAgICAgICAgcmV0dXJuIFwiU2lnbiB5b3VyIHRyYW5zYWN0aW9uKHMpXCI7XG4gICAgICAgIGNhc2UgXCJpbnNjcmlwdGlvbi9zdWJtaXRcIjpcbiAgICAgICAgICByZXR1cm4gXCJTdWJtaXR0aW5nIHlvdXIgc2lnbmVkIHRyYW5zYWN0aW9uKHMpLi4uXCI7XG4gICAgICAgIGNhc2UgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwiVmFsaWRhdGluZyB5b3VyIHRyYW5zYWN0aW9uKHMpIG9uIGNoYWluLi4uXCI7XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gXCJUcmFuc2FjdGlvbiBzdWJtaXR0ZWQhXCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvY2Vzc2luZy4uLlwiO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRCdXR0b25UZXh0ID0gKCkgPT4ge1xuICAgIC8vIElmIHRoZXJlJ3MgYSB3YWxsZXQgc2lnbmluZyBlcnJvciwgc2hvdyBcIlJldHJ5IFNpZ25pbmdcIiBidXR0b25cbiAgICBpZiAoaW5zY3JpYmVFcnJvciAmJiBpbnNjcmliZUVycm9yLmluY2x1ZGVzKFwiV2FsbGV0IHNpZ25pbmcgZXJyb3JcIikpIHtcbiAgICAgIHJldHVybiBcIlJldHJ5IFNpZ25pbmdcIjtcbiAgICB9XG4gICAgaWYgKHByZXBhcmVFcnJvciAmJiBwcmVwYXJlRXJyb3IuaW5jbHVkZXMoXCJXYWxsZXQgc2lnbmluZyBlcnJvclwiKSkge1xuICAgICAgcmV0dXJuIFwiUmV0cnkgU2lnbmluZ1wiO1xuICAgIH1cblxuICAgIGlmICghaXNQcmVwYXJlZCkge1xuICAgICAgaWYgKHByZXBhcmVTdGVwID09PSBcInByZXBhcmUvY29uc3RydWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiUHJlcGFyZSBVVHhPcyBmb3IgaW5zY3JpcHRpb25cIjtcbiAgICAgIH0gZWxzZSBpZiAocHJlcGFyZVN0ZXAgPT09IFwicHJlcGFyZS9yZXRyaWV2ZVwiKSB7XG4gICAgICAgIHJldHVybiBcIlNpZ24gYW5kIHN1Ym1pdCB1dHhvIHByZXBhcmF0aW9uIHRyYW5zYWN0aW9uXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByZXBhcmVkICYmICFpc0luc2NyaWJlZCkge1xuICAgICAgaWYgKGluc2NyaWJlU3RlcCA9PT0gXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIikge1xuICAgICAgICByZXR1cm4gXCJJbnNjcmliZSBPbmNoYWluXCI7XG4gICAgICB9IGVsc2UgaWYgKGluc2NyaWJlU3RlcCA9PT0gXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiKSB7XG4gICAgICAgIHJldHVybiBcIlNpZ24gYW5kIEluc2NyaWJlXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlByb2Nlc3NpbmcuLi5cIjtcbiAgfTtcblxuICBjb25zdCBpc0luRmluYWxTdGVwID0gKCkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICBpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vcmV0cmlldmUtc3VibWlzc2lvblwiIHx8IGlzSW5zY3JpYmVQcmVwYXJpbmdcbiAgICApO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVByZXBhcmUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZVZpZXcgPT09IFwiZmlsZXNcIikge1xuICAgICAgaWYgKCFmaWxlKSByZXR1cm47XG4gICAgICBhd2FpdCBwcmVwYXJlRmlsZXMoW2ZpbGVdKTsgLy8gc2UgcGFzYSBlbCBhcmNoaXZvIGNvbW8gYXJyYXkgZGUgdW4gc29sbyBlbGVtZW50b1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBwcmVwYXJlVGV4dChkZWxlZ2F0ZVRleHQpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVJbnNjcmliZSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoYWN0aXZlVmlldyA9PT0gXCJmaWxlc1wiKSB7XG4gICAgICBpZiAoIWZpbGUpIHJldHVybjtcbiAgICAgIGF3YWl0IGluc2NyaWJlRmlsZXMoW2ZpbGVdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgaW5zY3JpYmVGaWxlcyhbXG4gICAgICAgIG5ldyBGaWxlKFtkZWxlZ2F0ZVRleHRdLCBcImluc2NyaXB0aW9uLnR4dFwiLCB7IHR5cGU6IFwidGV4dC9wbGFpblwiIH0pLFxuICAgICAgXSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNpZ25BbmRTdWJtaXRQcmVwYXJhdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgc2V0SXNQcmVwYXJlZChmYWxzZSk7IC8vIFJlc2V0IHRoZSBzdGF0ZSBiZWZvcmUgc3RhcnRpbmdcbiAgICAgIGF3YWl0IHNpZ25BbmRTdWJtaXRQcmVwYXJhdGlvbigpO1xuICAgICAgLy8gV2UnbGwgbGV0IHRoZSB1c2VFZmZlY3QgaGFuZGxlIHNldHRpbmcgaXNQcmVwYXJlZCBiYXNlZCBvbiB0aGUgc3RlcCBhbmQgZXJyb3Igc3RhdGVcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBwcmVwYXJhdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgLy8gTWFrZSBzdXJlIGlzUHJlcGFyZWQgaXMgZmFsc2UgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgc2V0SXNQcmVwYXJlZChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNpZ25BbmRTdWJtaXRJbnNjcmlwdGlvbiA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2lnbkFuZFN1Ym1pdEluc2NyaXB0aW9uKCk7XG4gICAgICAvLyBPbmx5IHNldCBpc0luc2NyaWJlZCB0byB0cnVlIGlmIHRoZXJlIHdhcyBubyBlcnJvclxuICAgICAgaWYgKCFpbnNjcmliZUVycm9yKSB7XG4gICAgICAgIHNldElzSW5zY3JpYmVkKHRydWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIGluc2NyaXB0aW9uOlwiLCBlcnJvcik7XG4gICAgICAvLyBNYWtlIHN1cmUgaXNJbnNjcmliZWQgaXMgZmFsc2UgaW4gY2FzZSBvZiBlcnJvclxuICAgICAgc2V0SXNJbnNjcmliZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVCYWNrID0gKCkgPT4ge1xuICAgIHJlc2V0UHJlcGFyYXRpb24oKTtcbiAgICBzZXRJc1ByZXBhcmVkKGZhbHNlKTtcbiAgICAvLyBTb2xvIHJlaW5pY2lhbW9zIGVsIGVzdGFkbyBkZSBwcmVwYXJhY2nDs25cbiAgICByZXNldFN0YXR1cyhcInByZXBhcmF0aW9uXCIpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNhbmNlbCA9ICgpID0+IHtcbiAgICByZXNldFByZXBhcmF0aW9uKCk7XG4gICAgcmVzZXRJbnNjcmlwdGlvbigpO1xuICAgIHNldElzUHJlcGFyZWQoZmFsc2UpO1xuICAgIHNldElzSW5zY3JpYmVkKGZhbHNlKTtcbiAgICBjbGVhckZpbGUoKTtcbiAgICBzZXREZWxlZ2F0ZVRleHQoXCJcIik7XG4gICAgcmVzZXRTdGF0dXMoXCJwcmVwYXJhdGlvblwiKTtcbiAgICByZXNldFN0YXR1cyhcImluc2NyaXB0aW9uXCIpO1xuICAgIHNldERlbGVnYXRlVGV4dChcIlwiKTtcbiAgICBcbiAgfTtcblxuICBjb25zdCBzaG93TG9hZGVyID0gaXNQcmVwYXJpbmcgfHwgaXNJbkZpbmFsU3RlcCgpO1xuXG4gIGNvbnN0IGhhbmRsZU1haW5CdXR0b25DbGljayA9IGFzeW5jICgpID0+IHtcbiAgICAvLyBJZiB0aGVyZSdzIGEgd2FsbGV0IHNpZ25pbmcgZXJyb3IsIHJldHJ5IHRoZSBhcHByb3ByaWF0ZSBzaWduaW5nIHByb2Nlc3NcbiAgICBpZiAocHJlcGFyZUVycm9yICYmIHByZXBhcmVFcnJvci5pbmNsdWRlcyhcIldhbGxldCBzaWduaW5nIGVycm9yXCIpKSB7XG4gICAgICBhd2FpdCBoYW5kbGVTaWduQW5kU3VibWl0UHJlcGFyYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgaWYgKGluc2NyaWJlRXJyb3IgJiYgaW5zY3JpYmVFcnJvci5pbmNsdWRlcyhcIldhbGxldCBzaWduaW5nIGVycm9yXCIpKSB7XG4gICAgICBhd2FpdCBoYW5kbGVTaWduQW5kU3VibWl0SW5zY3JpcHRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUHJlcGFyZWQpIHtcbiAgICAgIGlmIChwcmVwYXJlU3RlcCA9PT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwiKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVByZXBhcmUoKTtcbiAgICAgIH0gZWxzZSBpZiAocHJlcGFyZVN0ZXAgPT09IFwicHJlcGFyZS9yZXRyaWV2ZVwiKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVNpZ25BbmRTdWJtaXRQcmVwYXJhdGlvbigpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmVwYXJlZCAmJiAhaXNJbnNjcmliZWQpIHtcbiAgICAgIGlmIChpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCIpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlSW5zY3JpYmUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5zY3JpYmVTdGVwID09PSBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIpIHtcbiAgICAgICAgYXdhaXQgaGFuZGxlU2lnbkFuZFN1Ym1pdEluc2NyaXB0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldFRvdGFsU3RlcHMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIDg7IC8vIDQgcHJlcGFyZSBzdGVwcyArIDQgaW5zY3JpcHRpb24gc3RlcHNcbiAgfTtcblxuICBjb25zdCBnZXRDdXJyZW50U3RlcCA9ICgpID0+IHtcbiAgICBpZiAoaXNJbnNjcmliZWQpIHtcbiAgICAgIHJldHVybiA4OyAvLyBTdGF5IGF0IGZpbmFsIHN0ZXAgd2hlbiBpbnNjcmlwdGlvbiBpcyBjb21wbGV0ZVxuICAgIH1cblxuICAgIGNvbnN0IHByZXBhcmVTdGVwczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgIFwicHJlcGFyZS9jb25zdHJ1Y3RcIjogMSxcbiAgICAgIFwicHJlcGFyZS9yZXRyaWV2ZVwiOiAyLFxuICAgICAgXCJwcmVwYXJlL3N1Ym1pdFwiOiAzLFxuICAgICAgXCJwcmVwYXJlL3JldHJpZXZlLXN1Ym1pc3Npb25cIjogNCxcbiAgICB9O1xuXG4gICAgY29uc3QgaW5zY3JpYmVTdGVwczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHtcbiAgICAgIFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCI6IDUsXG4gICAgICBcImluc2NyaXB0aW9uL3JldHJpZXZlXCI6IDYsXG4gICAgICBcImluc2NyaXB0aW9uL3N1Ym1pdFwiOiA3LFxuICAgICAgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6IDgsXG4gICAgICBlbmQ6IDgsXG4gICAgfTtcblxuICAgIGlmICghaXNQcmVwYXJlZCkge1xuICAgICAgcmV0dXJuIHByZXBhcmVTdGVwc1twcmVwYXJlU3RlcF0gfHwgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluc2NyaWJlU3RlcHNbaW5zY3JpYmVTdGVwXSB8fCA1O1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRTdGVwUGhhc2UgPSAoKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFN0ZXAgPSBnZXRDdXJyZW50U3RlcCgpO1xuICAgIHJldHVybiBjdXJyZW50U3RlcCA8PSA0ID8gXCJQcmVwYXJhdGlvblwiIDogXCJJbnNjcmlwdGlvblwiO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPG1vdGlvbi5kaXZcbiAgICAgIGNsYXNzTmFtZT1cImJnLXdoaXRlLzEwIHJvdW5kZWQtNHhsIGJhY2tkcm9wLWJsdXItWzEwcHhdIHAtOCBtYXgtdy01eGwgdy1mdWxsIG14LWF1dG8gdGV4dC13aGl0ZVwiXG4gICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHNjYWxlOiAwLjkgfX1cbiAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgc2NhbGU6IDEgfX1cbiAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuNSB9fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNlwiPlxuICAgICAgICA8UHJvZ3Jlc3NCYXJcbiAgICAgICAgICBjdXJyZW50U3RlcD17Z2V0Q3VycmVudFN0ZXAoKX1cbiAgICAgICAgICB0b3RhbFN0ZXBzPXtnZXRUb3RhbFN0ZXBzKCl9XG4gICAgICAgICAgc3RlcFRleHQ9e2dldFByb2dyZXNzVGV4dCgpfVxuICAgICAgICAgIHBoYXNlPXtnZXRTdGVwUGhhc2UoKX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICAgeyFzaG93TG9hZGVyICYmICFpc0luc2NyaWJlZCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS02XCI+XG4gICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiXG4gICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAsIHk6IC0yMCB9fVxuICAgICAgICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxLCB5OiAwIH19XG4gICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjUsIGRlbGF5OiAwLjIgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtWzEuMjVyZW1dXCI+XG4gICAgICAgICAgICAgIHtwcmVwYXJlU3RlcCA9PSBcInByZXBhcmUvY29uc3RydWN0XCIgPyAoXG4gICAgICAgICAgICAgICAgXCJBZGQgRmlsZSBvciBUZXh0IHRvIGluc2NyaWJlXCJcbiAgICAgICAgICAgICAgKSA6IHByZXBhcmVTdGVwID09IFwicHJlcGFyZS9yZXRyaWV2ZVwiID8gKFxuICAgICAgICAgICAgICAgIFwiUHJlcGFyaW5nIHlvdXIgVVR4T3MuXCJcbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8c3Ryb25nPlxuICAgICAgICAgICAgICAgICAgUGxlYXNlIGRvdWJsZSBjaGVjayB0aGUgdGV4dCBpdGVtcyBiZWxvdyBiZWZvcmUgY29udGludWluZzpcbiAgICAgICAgICAgICAgICA8L3N0cm9uZz5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IFwiPlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcHgtMiBweS1bMC4xMjVyZW1dICR7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVWaWV3ID09PSBcImZpbGVzXCJcbiAgICAgICAgICAgICAgICAgICAgPyBcImJnLVsjMDUxMDIzXSB0ZXh0LXdoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImJnLVsjMDUxMDIzXS8yMCB0ZXh0LXdoaXRlLzYwXCJcbiAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBY3RpdmVWaWV3KFwiZmlsZXNcIil9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgYm9yZGVyUmFkaXVzOiBcIjAuMjVyZW1cIiB9fVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtwcmVwYXJlU3RlcCAhPT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwifVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgRmlsZXNcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2BweC0yIHB5LVswLjEyNXJlbV0gJHtcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZVZpZXcgPT09IFwiZGVsZWdhdGVcIlxuICAgICAgICAgICAgICAgICAgICA/IFwiYmctWyMwNTEwMjNdIHRleHQtd2hpdGVcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiYmctWyMwNTEwMjNdLzIwIHRleHQtd2hpdGUvNjBcIlxuICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEFjdGl2ZVZpZXcoXCJkZWxlZ2F0ZVwiKX1cbiAgICAgICAgICAgICAgICBzdHlsZT17eyBib3JkZXJSYWRpdXM6IFwiMC4yNXJlbVwiIH19XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ9e3ByZXBhcmVTdGVwICE9PSBcInByZXBhcmUvY29uc3RydWN0XCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBUZXh0XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtNFwiPlxuICAgICAgICAgICAgeyhwcmVwYXJlRXJyb3IgfHwgaW5zY3JpYmVFcnJvcikgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1yZWQtNjAwIGJnLXdoaXRlIHAtNCByb3VuZGVkLW1kIG92ZXJmbG93LWF1dG9cIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTIgZm9udC1zZW1pYm9sZFwiPkVycm9yIG9jY3VycmVkOjwvZGl2PlxuICAgICAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPVwid2hpdGVzcGFjZS1wcmUtd3JhcFwiPlxuICAgICAgICAgICAgICAgICAge0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICB7IGVycm9yOiBwcmVwYXJlRXJyb3IgfHwgaW5zY3JpYmVFcnJvciB9LFxuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlRXJyb3IgPyBjbGVhclByZXBhcmVFcnJvciA6IGNsZWFySW5zY3JpYmVFcnJvclxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiIW10LTQgcHgtMyBweS0xIGJnLWJsdWUtNjAwICF0ZXh0LXdoaXRlIHJvdW5kZWQgaG92ZXI6YmctYmx1ZS03MDBcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENsZWFyIEVycm9yXG4gICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHtpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIiB8fFxuICAgICAgICAgICAgICBpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vc3VibWl0XCIgfHxcbiAgICAgICAgICAgICAgKGluc2NyaWJlU3RlcCA9PT0gXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIiAmJiBpc1ByZXBhcmVkICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdGV4dC1bMS4yNXJlbV1cIj5cbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIFdlIHRha2Ugbm8gcmVzcG9uc2liaWxpdHkgZm9yIHR5cG9zIG9yIHdyb25nIHB1bmN0dWF0aW9uLiBXZVxuICAgICAgICAgICAgICAgICAgICBhcmUgYWxzbyBub3QgY2hlY2tpbmcgZm9yIGFueSBwcmV2aW91cyBpbnNjcmlwdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmluZyB0aGUgc2FtZSB0ZXh0LlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAge2FjdGl2ZVZpZXcgPT09IFwiZmlsZXNcIiA/IChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICB7cHJlcGFyZVN0ZXAgPT09IFwicHJlcGFyZS9jb25zdHJ1Y3RcIiAmJiA8VXBsb2FkQm94IC8+fVxuICAgICAgICAgICAgICAgIHtmaWxlICYmIDxGaWxlTGlzdCAvPn1cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICA8RGVsZWdhdGVWaWV3XG4gICAgICAgICAgICAgICAgdGV4dD17ZGVsZWdhdGVUZXh0fVxuICAgICAgICAgICAgICAgIHNldFRleHQ9eyh0ZXh0OiBzdHJpbmcpID0+IHNldERlbGVnYXRlVGV4dCh0ZXh0KX1cbiAgICAgICAgICAgICAgICBpc1Byb2Nlc3Npbmc9e2lzUHJlcGFyaW5nIHx8IGlzSW5GaW5hbFN0ZXAoKX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGdhcC00XCI+XG4gICAgICAgICAgICB7KHByZXBhcmVTdGVwID09PSBcInByZXBhcmUvcmV0cmlldmVcIiB8fFxuICAgICAgICAgICAgICBpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIikgJiYgKFxuICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQmFja31cbiAgICAgICAgICAgICAgICBhbmltYXRlPXtmYWxzZX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTEvNFwiXG4gICAgICAgICAgICAgICAgdmFyaWFudD1cInNlY29uZGFyeVwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBCYWNrXG4gICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlTWFpbkJ1dHRvbkNsaWNrfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxuICAgICAgICAgICAgICBkaXNhYmxlZD17XG4gICAgICAgICAgICAgICAgKGFjdGl2ZVZpZXcgPT09IFwiZmlsZXNcIiAmJiAhZmlsZSkgfHxcbiAgICAgICAgICAgICAgICAoYWN0aXZlVmlldyA9PT0gXCJkZWxlZ2F0ZVwiICYmICFkZWxlZ2F0ZVRleHQudHJpbSgpKSB8fFxuICAgICAgICAgICAgICAgICFkZWZhdWx0V2FsbGV0IHx8XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgZGlzYWJsZSB0aGUgYnV0dG9uIHdoZW4gdGhlcmUncyBhIHdhbGxldCBzaWduaW5nIGVycm9yXG4gICAgICAgICAgICAgICAgKGlzUHJlcGFyaW5nICYmIFxuICAgICAgICAgICAgICAgICAgIShwcmVwYXJlRXJyb3IgJiYgcHJlcGFyZUVycm9yLmluY2x1ZGVzKFwiV2FsbGV0IHNpZ25pbmcgZXJyb3JcIikpICYmIFxuICAgICAgICAgICAgICAgICAgIShpbnNjcmliZUVycm9yICYmIGluc2NyaWJlRXJyb3IuaW5jbHVkZXMoXCJXYWxsZXQgc2lnbmluZyBlcnJvclwiKSlcbiAgICAgICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAgICAgaXNJbkZpbmFsU3RlcCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge2dldEJ1dHRvblRleHQoKX1cbiAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICB7c2hvd0xvYWRlciAmJiA8TG9hZGluZ1NjcmVlbiB0ZXh0PXtnZXRMb2FkaW5nVGV4dCgpfSAvPn1cblxuICAgICAge3Vuc2lnbmVkVHhJZCAmJiAhaXNJbnNjcmliZWQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTQgaXRlbXMtY2VudGVyIHRleHQtc20gdy1mdWxsIG10LThcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGZvbnQtc2VtaWJvbGQgc2VsZi1zdGFydFwiPlxuICAgICAgICAgICAgUHJlcGFyYXRpb24gUGhhc2VcbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdy1mdWxsXCI+XG4gICAgICAgICAgICB7dW5zaWduZWRUeElkICYmIChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIFwiPlByZXBhcmF0aW9uIFRyYW5zYWN0aW9uOjwvZGl2PlxuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICBocmVmPXtgaHR0cHM6Ly9wcmVwcm9kLmNhcmRhbm9zY2FuLmlvL3RyYW5zYWN0aW9uLyR7dW5zaWduZWRUeElkfWB9XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBob3ZlcjpvcGFjaXR5LTgwIHRyYW5zaXRpb24tY29sb3JzIGZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHctZnVsbFwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTQgaC00XCJcbiAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgZD1cIk05IDVIN0M1Ljg5NTQzIDUgNSA1Ljg5NTQzIDUgN1YxOUM1IDIwLjEwNDYgNS44OTU0MyAyMSA3IDIxSDE3QzE4LjEwNDYgMjEgMTkgMjAuMTA0NiAxOSAxOVY3QzE5IDUuODk1NDMgMTguMTA0NiA1IDE3IDVIMTVcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNMTIgMTJWM00xMiAzTDkgNk0xMiAzTDE1IDZcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgICB7dW5zaWduZWRUeElkfVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgey8qIDxhXG4gICAgICAgICAgICAgICAgaHJlZj17YGh0dHBzOi8vcHJlcHJvZC5jYXJkYW5vc2Nhbi5pby90cmFuc2FjdGlvbi8ke3ByZXBhcmF0aW9uU3VibWlzc2lvblN0YXR1cy5zdWNjZXNzLnR4aWR9YH1cbiAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGhvdmVyOm9wYWNpdHktODAgdHJhbnNpdGlvbi1jb2xvcnMgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgdy1mdWxsXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNCBoLTRcIlxuICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICBkPVwiTTkgNUg3QzUuODk1NDMgNSA1IDUuODk1NDMgNSA3VjE5QzUgMjAuMTA0NiA1Ljg5NTQzIDIxIDcgMjFIMTdDMTguMTA0NiAyMSAxOSAyMC4xMDQ2IDE5IDE5VjdDMTkgNS44OTU0MyAxOC4xMDQ2IDUgMTcgNUgxNVwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZD1cIk0xMiAxMlYzTTEyIDNMOSA2TTEyIDNMMTUgNlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICB7cHJlcGFyYXRpb25TdWJtaXNzaW9uU3RhdHVzLnN1Y2Nlc3MudHhpZH1cbiAgICAgICAgICAgICAgPC9hPiAqL31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuXG4gICAgICB7KGluc2NyaWJlU3RlcCA9PT0gXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiIHx8XG4gICAgICAgIGluc2NyaWJlU3RlcCA9PT0gXCJpbnNjcmlwdGlvbi9zdWJtaXRcIikgJiZcbiAgICAgICAgdW5zaWduZWRUeD8uc3VjY2VzcyAmJiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IGl0ZW1zLWNlbnRlciB0ZXh0LXNtIHctZnVsbCBtdC04XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdy1mdWxsXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgZm9udC1zZW1pYm9sZFwiPlxuICAgICAgICAgICAgICAgIEluc2NyaXB0aW9uIFBoYXNlXG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvcmRlci10IGJvcmRlci13aGl0ZS8yMCBteS0xXCI+PC9kaXY+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgbXQtMlwiPlxuICAgICAgICAgICAgICAgIEluc2NyaXB0aW9uIEluZGV4aW5nIFRyYW5zYWN0aW9uOlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICBocmVmPXtgaHR0cHM6Ly9wcmVwcm9kLmNhcmRhbm9zY2FuLmlvL3RyYW5zYWN0aW9uLyR7dW5zaWduZWRUeC5zdWNjZXNzLmluZGV4aW5nVHhJZH1gfVxuICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgaG92ZXI6b3BhY2l0eS04MCB0cmFuc2l0aW9uLWNvbG9ycyBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiB3LWZ1bGxcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy00IGgtNFwiXG4gICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgIGQ9XCJNOSA1SDdDNS44OTU0MyA1IDUgNS44OTU0MyA1IDdWMTlDNSAyMC4xMDQ2IDUuODk1NDMgMjEgNyAyMUgxN0MxOC4xMDQ2IDIxIDE5IDIwLjEwNDYgMTkgMTlWN0MxOSA1Ljg5NTQzIDE4LjEwNDYgNSAxNyA1SDE1XCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICBkPVwiTTEyIDEyVjNNMTIgM0w5IDZNMTIgM0wxNSA2XCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgIHt1bnNpZ25lZFR4LnN1Y2Nlc3MuaW5kZXhpbmdUeElkfVxuICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAge3Vuc2lnbmVkVHguc3VjY2Vzcy5zaGFyZFR4SWRzICYmXG4gICAgICAgICAgICAgIHVuc2lnbmVkVHguc3VjY2Vzcy5zaGFyZFR4SWRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMiB3LWZ1bGwgbXQtMlwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBmb250LXNlbWlib2xkXCI+XG4gICAgICAgICAgICAgICAgICAgIFNoYXJkIFRyYW5zYWN0aW9uczpcbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAge3Vuc2lnbmVkVHguc3VjY2Vzcy5zaGFyZFR4SWRzLm1hcCgoc2hhcmRUeElkLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgICAgIGtleT17aW5kZXh9XG4gICAgICAgICAgICAgICAgICAgICAgaHJlZj17YGh0dHBzOi8vcHJlcHJvZC5jYXJkYW5vc2Nhbi5pby90cmFuc2FjdGlvbi8ke3NoYXJkVHhJZH1gfVxuICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgaG92ZXI6b3BhY2l0eS04MCB0cmFuc2l0aW9uLWNvbG9ycyBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy00IGgtNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNOSA1SDdDNS44OTU0MyA1IDUgNS44OTU0MyA1IDdWMTlDNSAyMC4xMDQ2IDUuODk1NDMgMjEgNyAyMUgxN0MxOC4xMDQ2IDIxIDE5IDIwLjEwNDYgMTkgMTlWN0MxOSA1Ljg5NTQzIDE4LjEwNDYgNSAxNyA1SDE1XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTEyIDEyVjNNMTIgM0w5IDZNMTIgM0wxNSA2XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlPVwiY3VycmVudENvbG9yXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg9XCIyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAgICAgIHtzaGFyZFR4SWR9XG4gICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICApfVxuXG4gICAgICB7aXNJbnNjcmliZWQgJiYgKFxuICAgICAgICA8RmluaXNoU2NyZWVuXG4gICAgICAgICAgc2V0SXNQcmVwYXJlZD17c2V0SXNQcmVwYXJlZH1cbiAgICAgICAgICBzZXRJc0luc2NyaWJlZD17c2V0SXNJbnNjcmliZWR9XG4gICAgICAgICAgc2V0RGVsZWdhdGVUZXh0PXtzZXREZWxlZ2F0ZVRleHR9XG4gICAgICAgICAgc3VibWlzc2lvblN0YXR1cz17c3VibWlzc2lvblN0YXR1c31cbiAgICAgICAgICBwcmVwYXJhdGlvblR4SWQ9e3ByZXBhcmF0aW9uU3VibWlzc2lvblN0YXR1cz8uc3VjY2Vzcz8udHhpZH1cbiAgICAgICAgICB1bnNpZ25lZFR4SWQ9e3Vuc2lnbmVkVHhJZCA/PyB1bmRlZmluZWR9XG4gICAgICAgICAgaW5kZXhpbmdUeElkPXt1bnNpZ25lZFR4Py5zdWNjZXNzPy5pbmRleGluZ1R4SWR9XG4gICAgICAgICAgc2hhcmRUeElkcz17dW5zaWduZWRUeD8uc3VjY2Vzcz8uc2hhcmRUeElkc31cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7LyogIHsocHJlcGFyZU5leHRTdGVwIHx8IGluc2NyaWJlTmV4dFN0ZXApICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtd2hpdGUvNjBcIj5cbiAgICAgICAgICBOZXh0IHN0ZXA6IHtwcmVwYXJlTmV4dFN0ZXAgfHwgaW5zY3JpYmVOZXh0U3RlcH1cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgeyhwcmVwYXJlU3RlcCB8fCBpbnNjcmliZVN0ZXApICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtd2hpdGUvNjBcIj5cbiAgICAgICAgICBDdXJyZW50IHN0ZXA6IHtwcmVwYXJlU3RlcCB8fCBpbnNjcmliZVN0ZXB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX0gKi99XG4gICAgICB7LyogeyhwcmVwYXJlRXJyb3IgfHwgaW5zY3JpYmVFcnJvcikgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1yZWQtNTAwXCI+XG4gICAgICAgICAgRXJyb3I6IHtwcmVwYXJlRXJyb3IgfHwgaW5zY3JpYmVFcnJvcn1cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtwcmVwYXJlRXJyb3IgPyBjbGVhclByZXBhcmVFcnJvciA6IGNsZWFySW5zY3JpYmVFcnJvcn1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1sLTIgdGV4dC1ibHVlLTUwMFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgQ2xlYXJcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfSAqL31cbiAgICA8L21vdGlvbi5kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi4vdWkvQnV0dG9uXCI7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9XYWxsZXRDb250ZXh0XCI7XG5pbXBvcnQgeyBXYWxsZXRNZW51IH0gZnJvbSBcIi4vV2FsbGV0TWVudVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb25uZWN0V2FsbGV0KCk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIGNvbnN0IHsgb3Blbk1lbnUsIGRlZmF1bHRXYWxsZXQgfSA9IHVzZVdhbGxldCgpO1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxCdXR0b24gb25DbGljaz17b3Blbk1lbnV9IGFuaW1hdGU9e2ZhbHNlfT5cbiAgICAgICAge2RlZmF1bHRXYWxsZXQgPyBgQ29ubmVjdGVkIHRvICR7ZGVmYXVsdFdhbGxldH1gIDogXCJDb25uZWN0IFdhbGxldFwifVxuICAgICAgPC9CdXR0b24+XG4gICAgPC8+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBDbG9zZUljb25Qcm9wcyB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IENsb3NlSWNvblNlY29uZGFyeTogUmVhY3QuRkM8Q2xvc2VJY29uUHJvcHM+ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPVwiMzBcIlxuICAgICAgaGVpZ2h0PVwiMzBcIlxuICAgICAgdmlld0JveD1cIjAgMCAyMCAyMFwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTE4LjA1NTMgMC4zMzM4MzFDMTguNTAwMiAtMC4xMTEwNDcgMTkuMjIxNSAtMC4xMTEwNDcgMTkuNjY2MyAwLjMzMzgzQzIwLjExMTIgMC43Nzg3MDggMjAuMTExMiAxLjUgMTkuNjY2MyAxLjk0NDg3TDEuOTQ0ODYgMTkuNjY2NEMxLjQ5OTk4IDIwLjExMTIgMC43Nzg2OTUgMjAuMTExMiAwLjMzMzgxOCAxOS42NjY0Qy0wLjExMTA1OSAxOS4yMjE1IC0wLjExMTA1OSAxOC41MDAyIDAuMzMzODE4IDE4LjA1NTNMMTguMDU1MyAwLjMzMzgzMVpcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTAuMzMzNjU4IDEuOTQ0N0MtMC4xMTEyMTkgMS40OTk4MiAtMC4xMTEyMiAwLjc3ODUzNSAwLjMzMzY1OCAwLjMzMzY1OEMwLjc3ODUzNSAtMC4xMTEyMTkgMS40OTk4MiAtMC4xMTEyMTkgMS45NDQ3IDAuMzMzNjU4TDE5LjY2NjIgMTguMDU1MUMyMC4xMTExIDE4LjUgMjAuMTExMSAxOS4yMjEzIDE5LjY2NjIgMTkuNjY2MkMxOS4yMjEzIDIwLjExMTEgMTguNSAyMC4xMTExIDE4LjA1NTEgMTkuNjY2MkwwLjMzMzY1OCAxLjk0NDdaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgIDwvc3ZnPlxuICApO1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIjtcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1dhbGxldENvbnRleHRcIjtcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuLi91aS9CdXR0b25cIjtcbmltcG9ydCB7IENsb3NlSWNvblNlY29uZGFyeSB9IGZyb20gXCIuLi8uLi9pY29ucy9DbG9zZUljb25TZWNvbmRhcnlcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIFdhbGxldE1lbnUoKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGNvbnN0IHtcbiAgICBpc01lbnVPcGVuLFxuICAgIGNsb3NlTWVudSxcbiAgICB3YWxsZXRzLFxuICAgIGNvbm5lY3RlZFdhbGxldHMsXG4gICAgZGVmYXVsdFdhbGxldCxcbiAgICBjb25uZWN0V2FsbGV0LFxuICAgIGRpc2Nvbm5lY3RXYWxsZXQsXG4gICAgc2V0RGVmYXVsdFdhbGxldCxcbiAgICBpbnN0YWxsZWRXYWxsZXRzLFxuICB9ID0gdXNlV2FsbGV0KCk7XG5cbiAgY29uc3QgYXZhaWxhYmxlV2FsbGV0cyA9IE9iamVjdC5lbnRyaWVzKHdhbGxldHMpLmZpbHRlcihcbiAgICAoW2tleSwgX10pID0+XG4gICAgICBpbnN0YWxsZWRXYWxsZXRzLmluY2x1ZGVzKGtleSkgJiZcbiAgICAgICFjb25uZWN0ZWRXYWxsZXRzLnNvbWUoKHcpID0+IHcubmFtZS50b0xvd2VyQ2FzZSgpID09PSBrZXkpXG4gICk7XG5cbiAgY29uc3Qgd2FsbGV0c1RvSW5zdGFsbCA9IE9iamVjdC5lbnRyaWVzKHdhbGxldHMpLmZpbHRlcihcbiAgICAoW2tleSwgX10pID0+ICFpbnN0YWxsZWRXYWxsZXRzLmluY2x1ZGVzKGtleSlcbiAgKTtcblxuICByZXR1cm4gKFxuICAgIDxBbmltYXRlUHJlc2VuY2U+XG4gICAgICB7aXNNZW51T3BlbiAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImZpeGVkIGluc2V0LTAgIGJhY2tkcm9wLWJsdXItWzJweF0gei00MFwiXG4gICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICAgICAgICAgICAgZXhpdD17eyBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgICBvbkNsaWNrPXtjbG9zZU1lbnV9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiZml4ZWQgdG9wLTAgcmlnaHQtMCBoLWZ1bGwgdy1mdWxsIG1heC13LW1kIGJnLXdoaXRlLzEwIGJhY2tkcm9wLWJsdXIteGwgcC02IHotNTAgdGV4dC13aGl0ZSBvdmVyZmxvdy15LWF1dG9cIlxuICAgICAgICAgICAgaW5pdGlhbD17eyB4OiBcIjEwMCVcIiB9fVxuICAgICAgICAgICAgYW5pbWF0ZT17eyB4OiAwIH19XG4gICAgICAgICAgICBleGl0PXt7IHg6IFwiMTAwJVwiIH19XG4gICAgICAgICAgICB0cmFuc2l0aW9uPXt7IHR5cGU6IFwic3ByaW5nXCIsIGRhbXBpbmc6IDIwLCBzdGlmZm5lc3M6IDEwMCB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1mdWxsIGZsZXggZmxleC1jb2xcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gbWItMlwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1bMnJlbV0gZm9udC1tZWRpdW1cIj5Db25uZWN0IHdhbGxldDwvZGl2PlxuICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJwLTEgaG92ZXI6Ymctd2hpdGUvMTAgcm91bmRlZC1mdWxsXCJcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2Nsb3NlTWVudX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8Q2xvc2VJY29uU2Vjb25kYXJ5IGNsYXNzTmFtZT1cInctNiBoLTZcIiAvPlxuICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCIhdGV4dC1zbSAhdGV4dC1saWdodCAhbWItNlwiPlxuICAgICAgICAgICAgICAgIEJ5IGNvbm5lY3RpbmcgeW91ciB3YWxsZXQgeW91IGFncmVlIHRvIG91cntcIiBcIn1cbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzTmFtZT1cIiF0ZXh0LWxpZ2h0IHVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgVGVybXNcbiAgICAgICAgICAgICAgICA8L2E+e1wiIFwifVxuICAgICAgICAgICAgICAgIGFuZHtcIiBcIn1cbiAgICAgICAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzTmFtZT1cIiF0ZXh0LWxpZ2h0IHVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgUHJpdmFjeSBQb2xpY3lcbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgLlxuICAgICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJvdmVyZmxvdy15LWF1dG8gZmxleCBmbGV4LWNvbCBnYXAtOFwiPlxuICAgICAgICAgICAgICAgIHsvKiBDb25uZWN0ZWQgV2FsbGV0cyBTZWN0aW9uICovfVxuICAgICAgICAgICAgICAgIHtjb25uZWN0ZWRXYWxsZXRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtbWVkaXVtIG1iLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICBDb25uZWN0ZWQgd2FsbGV0c1xuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICB7Y29ubmVjdGVkV2FsbGV0cy5tYXAoKGNvbm5lY3RlZFdhbGxldCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0c1tjb25uZWN0ZWRXYWxsZXQubmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzRGVmYXVsdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRXYWxsZXQ/LnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZFdhbGxldC5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2Nvbm5lY3RlZFdhbGxldC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHctZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcC0zIHJvdW5kZWQteGwgdHJhbnNpdGlvbi1jb2xvcnMgJHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRGVmYXVsdCA/IFwiYmctYmx1ZS01MDAvMjBcIiA6IFwiYmctd2hpdGUvNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctOCBoLTggYmctd2hpdGUvMTAgcm91bmRlZC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3dhbGxldC5pY29uIHx8IFwiL3BsYWNlaG9sZGVyLnN2Z1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD17d2FsbGV0Lm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy01IGgtNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnt3YWxsZXQubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyFpc0RlZmF1bHQgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudD1cImdob3N0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXNtIGhvdmVyOmJnLXdoaXRlLzEwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXREZWZhdWx0V2FsbGV0KHdhbGxldC5uYW1lKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1ha2UgZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1yZWQtNDAwIGhvdmVyOmJnLXJlZC01MDAvMTAgIWhpZGRlblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGRpc2Nvbm5lY3RXYWxsZXQod2FsbGV0Lm5hbWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBEaXNjb25uZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgICAgICB7LyogSW5zdGFsbGVkIGJ1dCBub3QgY29ubmVjdGVkIFdhbGxldHMgU2VjdGlvbiAqL31cbiAgICAgICAgICAgICAgICB7YXZhaWxhYmxlV2FsbGV0cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LW1lZGl1bSBtYi0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgQXZhaWxhYmxlIHdhbGxldHNcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAge2F2YWlsYWJsZVdhbGxldHMubWFwKChba2V5LCB3YWxsZXRdKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHAtMyBiZy13aGl0ZS81IGhvdmVyOmJnLXdoaXRlLzEwIHJvdW5kZWQteGwgdHJhbnNpdGlvbi1jb2xvcnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTggaC04IGJnLXdoaXRlLzEwIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3dhbGxldC5pY29uIHx8IFwiL3BsYWNlaG9sZGVyLnN2Z1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9e3dhbGxldC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3dhbGxldC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwiZ2hvc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtc20gaG92ZXI6Ymctd2hpdGUvMTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGNvbm5lY3RXYWxsZXQod2FsbGV0Lm5hbWUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3NUZXh0PVwiQ29ubmVjdGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIENvbm5lY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAgey8qIE5vdCBJbnN0YWxsZWQgV2FsbGV0cyBTZWN0aW9uICovfVxuICAgICAgICAgICAgICAgIHt3YWxsZXRzVG9JbnN0YWxsLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhsIGZvbnQtbWVkaXVtIG1iLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICBTZWxlY3QgYSB3YWxsZXQgdG8gaW5zdGFsbFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICB7d2FsbGV0c1RvSW5zdGFsbC5tYXAoKFtrZXksIHdhbGxldF0pID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtrZXl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gcC0zIGJnLXdoaXRlLzUgaG92ZXI6Ymctd2hpdGUvMTAgcm91bmRlZC14bCB0cmFuc2l0aW9uLWNvbG9yc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctOCBoLTggYmctd2hpdGUvMTAgcm91bmRlZC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyYz17d2FsbGV0Lmljb24gfHwgXCIvcGxhY2Vob2xkZXIuc3ZnXCJ9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdD17d2FsbGV0Lm5hbWV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNSBoLTVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57d2FsbGV0Lm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBob3ZlcjpiZy13aGl0ZS8xMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3Blbih3YWxsZXQudXJsLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5zdGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC9BbmltYXRlUHJlc2VuY2U+XG4gICk7XG59XG4iLCIvLyBzcmMvdXRpbHMvZGVjb2Rlci50c1xuLy8gTm8gbmVlZCBmb3IgV0FTSSBpbXBvcnRzIGFueW1vcmVcblxuLyoqXG4gKiBUeXBlIGRlZmluaXRpb24gZm9yIHRoZSBXQVNNIGluc3RhbmNlIHdpdGggZXhwb3J0ZWQgZnVuY3Rpb25zXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgV2FzbURlY29kZXJJbnN0YW5jZSB7XG4gIGV4cG9ydHM6IHtcbiAgICBtZW1vcnk6IFdlYkFzc2VtYmx5Lk1lbW9yeTtcbiAgICBoc19pbml0OiAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgaHNfZXhpdDogKCkgPT4gdm9pZDtcbiAgICBtYWxsb2NfYnl0ZXNfaHM6IChzaXplOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICBmcmVlX2hzOiAocHRyOiBudW1iZXIpID0+IHZvaWQ7XG4gICAgcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzQzogKGNvdW50OiBudW1iZXIsIHB0ckFycmF5OiBudW1iZXIpID0+IG51bWJlcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBXQVNNIGRlY29kZXIgYnkgZmV0Y2hpbmcgYW5kIGluc3RhbnRpYXRpbmcgdGhlIFdBU00gbW9kdWxlXG4gKiBAcGFyYW0gd2FzbU1vZHVsZVVybCBPcHRpb25hbCBVUkwgdG8gdGhlIFdBU00gbW9kdWxlLCBkZWZhdWx0cyB0byB0aGUgUzMgVVJMXG4gKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyB0aGUgaW5zdGFudGlhdGVkIFdBU00gbW9kdWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplV2FzbURlY29kZXIod2FzbU1vZHVsZVVybD86IHN0cmluZyk6IFByb21pc2U8eyB3YXNtSW5zdGFuY2U6IFdhc21EZWNvZGVySW5zdGFuY2UgfT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHdhc21VcmwgPSB3YXNtTW9kdWxlVXJsIHx8ICdodHRwczovL21ldGFkYXRhLWRlY29kZXItd2FzbS5zMy51cy1lYXN0LTEuYW1hem9uYXdzLmNvbS93YXNtLWRlY29kZXIud2FzbSc7XG4gICAgY29uc29sZS5sb2coXCJMb2FkaW5nIFdBU00gZnJvbSBVUkw6XCIsIHdhc21VcmwpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB0aGUgc3RyZWFtaW5nIGFwcHJvYWNoXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2god2FzbVVybCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlOlwiLCByZXNwb25zZSk7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgcmVzcG9uc2UgaXMgb2tcbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBUcnkgY29tcGlsZVN0cmVhbWluZyBmaXJzdCAobW9yZSBlZmZpY2llbnQpXG4gICAgICBjb25zdCBjb21waWxlZFdhc21EZWNvZGVyID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZVN0cmVhbWluZyhyZXNwb25zZSk7XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSBhIGR5bmFtaWMgV0FTSSBpbXBvcnQgb2JqZWN0IHdpdGggYSBQcm94eVxuICAgICAgLy8gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHkgaGFuZGxlIGFueSBXQVNJIGZ1bmN0aW9uIHRoYXQgdGhlIG1vZHVsZSByZXF1aXJlc1xuICAgICAgY29uc3Qgd2FzaUhhbmRsZXIgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24odGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZykge1xuICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuIGl0XG4gICAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyAwIChzdWNjZXNzIGluIFdBU0kpXG4gICAgICAgICAgY29uc29sZS5sb2coYEF1dG8tY3JlYXRpbmcgV0FTSSBmdW5jdGlvbjogJHtwcm9wfWApO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYENhbGxlZCBhdXRvLWNyZWF0ZWQgV0FTSSBmdW5jdGlvbjogJHtwcm9wfSB3aXRoICR7YXJncy5sZW5ndGh9IGFyZ3NgKTtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBSZXR1cm4gc3VjY2VzcyBmb3IgYW55IGZ1bmN0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQmFzZSBXQVNJIGZ1bmN0aW9ucyB3aXRoIGV4cGxpY2l0IGltcGxlbWVudGF0aW9uc1xuICAgICAgY29uc3QgYmFzZVdhc2kgPSB7XG4gICAgICAgIHByb2NfZXhpdDogKGNvZGU6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBwcm9jX2V4aXQgY2FsbGVkIHdpdGggY29kZTogJHtjb2RlfWApO1xuICAgICAgICB9LFxuICAgICAgICBmZF93cml0ZTogKGZkOiBudW1iZXIsIGlvdnM6IG51bWJlciwgaW92c0xlbjogbnVtYmVyLCBud3JpdHRlbjogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGZkX3dyaXRlIGNhbGxlZDogZmQ9JHtmZH0sIGlvdnM9JHtpb3ZzfSwgaW92c0xlbj0ke2lvdnNMZW59LCBud3JpdHRlbj0ke253cml0dGVufWApO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGhlIGltcG9ydCBvYmplY3Qgd2l0aCBhIFByb3h5IGZvciB3YXNpX3NuYXBzaG90X3ByZXZpZXcxXG4gICAgICBjb25zdCBpbXBvcnRPYmplY3QgPSB7XG4gICAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IG5ldyBQcm94eShiYXNlV2FzaSwgd2FzaUhhbmRsZXIpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB3YXNtSW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShjb21waWxlZFdhc21EZWNvZGVyLCBpbXBvcnRPYmplY3QpO1xuICAgICAgY29uc29sZS5sb2coXCJXQVNNIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSB2aWEgc3RyZWFtaW5nXCIpO1xuICAgICAgcmV0dXJuIHsgd2FzbUluc3RhbmNlOiB3YXNtSW5zdGFuY2UgYXMgdW5rbm93biBhcyBXYXNtRGVjb2Rlckluc3RhbmNlIH07XG4gICAgfSBjYXRjaCAoc3RyZWFtaW5nRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlN0cmVhbWluZyBjb21waWxhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBhcHByb2FjaDpcIiwgc3RyZWFtaW5nRXJyb3IpO1xuICAgICAgXG4gICAgICAvLyBGYWxsYmFjayB0byBBcnJheUJ1ZmZlciBhcHByb2FjaCBpZiBzdHJlYW1pbmcgZmFpbHNcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2god2FzbVVybCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlOlwiLCByZXNwb25zZSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgd2FzbUJ5dGVzID0gYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNvbnN0IHdhc21Nb2R1bGUgPSBhd2FpdCBXZWJBc3NlbWJseS5jb21waWxlKHdhc21CeXRlcyk7XG4gICAgICBcbiAgICAgIC8vIFJldXNlIHRoZSBzYW1lIGR5bmFtaWMgV0FTSSBoYW5kbGVyIGFwcHJvYWNoXG4gICAgICBjb25zdCB3YXNpSGFuZGxlciA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbih0YXJnZXQ6IGFueSwgcHJvcDogc3RyaW5nKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGFscmVhZHkgZXhpc3RzLCByZXR1cm4gaXRcbiAgICAgICAgICBpZiAocHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIDAgKHN1Y2Nlc3MgaW4gV0FTSSlcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQXV0by1jcmVhdGluZyBXQVNJIGZ1bmN0aW9uOiAke3Byb3B9YCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKC4uLmFyZ3M6IGFueVtdKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FsbGVkIGF1dG8tY3JlYXRlZCBXQVNJIGZ1bmN0aW9uOiAke3Byb3B9IHdpdGggJHthcmdzLmxlbmd0aH0gYXJnc2ApO1xuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIFJldHVybiBzdWNjZXNzIGZvciBhbnkgZnVuY3Rpb25cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBCYXNlIFdBU0kgZnVuY3Rpb25zIHdpdGggZXhwbGljaXQgaW1wbGVtZW50YXRpb25zXG4gICAgICBjb25zdCBiYXNlV2FzaSA9IHtcbiAgICAgICAgcHJvY19leGl0OiAoY29kZTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYHByb2NfZXhpdCBjYWxsZWQgd2l0aCBjb2RlOiAke2NvZGV9YCk7XG4gICAgICAgIH0sXG4gICAgICAgIGZkX3dyaXRlOiAoZmQ6IG51bWJlciwgaW92czogbnVtYmVyLCBpb3ZzTGVuOiBudW1iZXIsIG53cml0dGVuOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgZmRfd3JpdGUgY2FsbGVkOiBmZD0ke2ZkfSwgaW92cz0ke2lvdnN9LCBpb3ZzTGVuPSR7aW92c0xlbn0sIG53cml0dGVuPSR7bndyaXR0ZW59YCk7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIENyZWF0ZSB0aGUgaW1wb3J0IG9iamVjdCB3aXRoIGEgUHJveHkgZm9yIHdhc2lfc25hcHNob3RfcHJldmlldzFcbiAgICAgIGNvbnN0IGltcG9ydE9iamVjdCA9IHtcbiAgICAgICAgd2FzaV9zbmFwc2hvdF9wcmV2aWV3MTogbmV3IFByb3h5KGJhc2VXYXNpLCB3YXNpSGFuZGxlcilcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnN0IHdhc21JbnN0YW5jZSA9IGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc21Nb2R1bGUsIGltcG9ydE9iamVjdCk7XG4gICAgICBjb25zb2xlLmxvZyhcIldBU00gaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5IHZpYSBBcnJheUJ1ZmZlclwiKTtcbiAgICAgIHJldHVybiB7IHdhc21JbnN0YW5jZTogd2FzbUluc3RhbmNlIGFzIHVua25vd24gYXMgV2FzbURlY29kZXJJbnN0YW5jZSB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiV0FTTSBpbml0aWFsaXphdGlvbiBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBpZiBhIHN0cmluZyBpcyBhIHZhbGlkIGhleGFkZWNpbWFsIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleFN0cmluZyhoZXg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIC9eWzAtOUEtRmEtZl0qJC8udGVzdChoZXgpO1xufVxuXG4vKipcbiAqIFB1cmUgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBmb3IgcmVjb25zdHJ1Y3RpbmcgYnl0ZXMgZnJvbSBoZXggc3RyaW5nc1xuICogVGhpcyBpcyB1c2VkIGFzIGEgZmFsbGJhY2sgd2hlbiBXQVNNIGluaXRpYWxpemF0aW9uIGZhaWxzXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgLy8gUmVtb3ZlIGFueSBub24taGV4IGNoYXJhY3RlcnMgKGxpa2Ugc3BhY2VzIG9yIGxpbmUgYnJlYWtzKVxuICBoZXggPSBoZXgucmVwbGFjZSgvW14wLTlBLUZhLWZdL2csICcnKTtcbiAgXG4gIC8vIEVuc3VyZSB3ZSBoYXZlIGFuIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgaWYgKGhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgaGV4ID0gJzAnICsgaGV4O1xuICB9XG4gIFxuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgYnl0ZXNbaSAvIDJdID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KTtcbiAgfVxuICBcbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBieXRlc1RvQmFzZTY0KGJ5dGVzOiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgY29uc3QgYmluU3RyaW5nID0gQXJyYXkuZnJvbShieXRlcylcbiAgICAubWFwKGJ5dGUgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlKSlcbiAgICAuam9pbignJyk7XG4gIFxuICByZXR1cm4gYnRvYShiaW5TdHJpbmcpO1xufVxuXG4vKipcbiAqIFJlY29uc3RydWN0cyB0aGUgb3JpZ2luYWwgYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBoZXggc3RyaW5nc1xuICogRmlyc3QgdHJpZXMgdG8gdXNlIHRoZSBXQVNNIGltcGxlbWVudGF0aW9uLCBmYWxscyBiYWNrIHRvIHB1cmUgSlMgaWYgdGhhdCBmYWlsc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzKFxuICB3SW5zdGFuY2U6IFdhc21EZWNvZGVySW5zdGFuY2UgfCBudWxsLFxuICBoZXhTdHJpbmdBcnJheTogc3RyaW5nW11cbik6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnNvbGUubG9nKCdSZWNvbnN0cnVjdGluZyBieXRlcyBmcm9tIGhleCBzdHJpbmdzOicsIGhleFN0cmluZ0FycmF5KTtcbiAgXG4gIHRyeSB7XG4gICAgLy8gVmFsaWRhdGUgaGV4IHN0cmluZ3NcbiAgICBjb25zdCB2YWxpZEhleFN0cmluZ3MgPSBoZXhTdHJpbmdBcnJheS5maWx0ZXIoaGV4ID0+IGlzVmFsaWRIZXhTdHJpbmcoaGV4KSk7XG4gICAgaWYgKHZhbGlkSGV4U3RyaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgaGV4IHN0cmluZ3MgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgXG4gICAgY29uc29sZS5sb2coJ1ZhbGlkIGhleCBzdHJpbmdzOicsIHZhbGlkSGV4U3RyaW5ncyk7XG4gICAgXG4gICAgLy8gVHJ5IFdBU00gaW1wbGVtZW50YXRpb24gZmlyc3QgaWYgYXZhaWxhYmxlXG4gICAgaWYgKHdJbnN0YW5jZSAmJiB3SW5zdGFuY2UuZXhwb3J0cyAmJiB3SW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBdHRlbXB0aW5nIHRvIHVzZSBXQVNNIGltcGxlbWVudGF0aW9uLi4uJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBIYXNrZWxsIHJ1bnRpbWVcbiAgICAgICAgd0luc3RhbmNlLmV4cG9ydHMuaHNfaW5pdCgwLCAwKTtcbiAgICAgICAgXG4gICAgICAgIGxldCBoZXhTdHJpbmdQdHJzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBsZXQgaGV4U3RyaW5nQXJyYXlQdHJBZGRyID0gMDtcbiAgICAgICAgbGV0IGJhc2U2NFB0ciA9IDA7XG4gICAgICAgIFxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEFsbG9jYXRlIGFuZCB3cml0ZSBlYWNoIGhleCBzdHJpbmcgdG8gV0FTTSBtZW1vcnlcbiAgICAgICAgICBoZXhTdHJpbmdQdHJzID0gdmFsaWRIZXhTdHJpbmdzLm1hcChzdHIgPT4gd3JpdGVDU3RyaW5nKHN0ciwgd0luc3RhbmNlKSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWxsb2NhdGUgbWVtb3J5IGZvciB0aGUgYXJyYXkgb2YgcG9pbnRlcnNcbiAgICAgICAgICBoZXhTdHJpbmdBcnJheVB0ckFkZHIgPSB3SW5zdGFuY2UuZXhwb3J0cy5tYWxsb2NfYnl0ZXNfaHMoaGV4U3RyaW5nUHRycy5sZW5ndGggKiA0KTsgLy8gNCBieXRlcyBwZXIgcG9pbnRlclxuICAgICAgICAgIFxuICAgICAgICAgIC8vIFdyaXRlIHRoZSBhcnJheSBvZiBwb2ludGVycyB0byBXQVNNIG1lbW9yeVxuICAgICAgICAgIGNvbnN0IG1lbSA9IG5ldyBVaW50OEFycmF5KHdJbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcod0luc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXhTdHJpbmdQdHJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMihoZXhTdHJpbmdBcnJheVB0ckFkZHIgKyBpICogNCwgaGV4U3RyaW5nUHRyc1tpXSwgdHJ1ZSk7IC8vIHRydWUgZm9yIGxpdHRsZS1lbmRpYW5cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2FsbCB0aGUgV0FTTSBmdW5jdGlvbiB0byByZWNvbnN0cnVjdCB0aGUgYnl0ZXNcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ2FsbGluZyByZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXNDIHdpdGggY291bnQ9JHtoZXhTdHJpbmdQdHJzLmxlbmd0aH0sIHB0ckFycmF5PSR7aGV4U3RyaW5nQXJyYXlQdHJBZGRyfWApO1xuICAgICAgICAgIGJhc2U2NFB0ciA9IHdJbnN0YW5jZS5leHBvcnRzLnJlY29uc3RydWN0T3JpZ2luYWxCeXRlc0MoaGV4U3RyaW5nUHRycy5sZW5ndGgsIGhleFN0cmluZ0FycmF5UHRyQWRkcik7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGJhc2U2NFB0ciA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXQVNNIGZ1bmN0aW9uIHJldHVybmVkIG51bGwgcG9pbnRlcicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBSZWFkIHRoZSByZXN1bHQgZnJvbSBXQVNNIG1lbW9yeVxuICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IHJlYWRDU3RyaW5nKHdJbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIsIGJhc2U2NFB0cik7XG4gICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZWNvbnN0cnVjdGVkIGJ5dGVzLCBiYXNlNjQgbGVuZ3RoOiAke2Jhc2U2NC5sZW5ndGh9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRnJlZSB0aGUgYWxsb2NhdGVkIG1lbW9yeVxuICAgICAgICAgIHdJbnN0YW5jZS5leHBvcnRzLmZyZWVfaHMoYmFzZTY0UHRyKTtcbiAgICAgICAgICB3SW5zdGFuY2UuZXhwb3J0cy5mcmVlX2hzKGhleFN0cmluZ0FycmF5UHRyQWRkcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRnJlZSBpbmRpdmlkdWFsIGhleCBzdHJpbmdzXG4gICAgICAgICAgaGV4U3RyaW5nUHRycy5mb3JFYWNoKHB0ciA9PiB7XG4gICAgICAgICAgICBpZiAocHRyICE9PSAwKSB3SW5zdGFuY2UuZXhwb3J0cy5mcmVlX2hzKHB0cik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2h1dCBkb3duIHRoZSBIYXNrZWxsIHJ1bnRpbWVcbiAgICAgICAgICB3SW5zdGFuY2UuZXhwb3J0cy5oc19leGl0KCk7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICAgICAgfSBjYXRjaCAoaW5uZXJFcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciBkdXJpbmcgV0FTTSBleGVjdXRpb246JywgaW5uZXJFcnJvcik7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ2xlYW4gdXAgYW55IGFsbG9jYXRlZCBtZW1vcnkgaWYgcG9zc2libGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGJhc2U2NFB0ciAhPT0gMCkgd0luc3RhbmNlLmV4cG9ydHMuZnJlZV9ocyhiYXNlNjRQdHIpO1xuICAgICAgICAgICAgaWYgKGhleFN0cmluZ0FycmF5UHRyQWRkciAhPT0gMCkgd0luc3RhbmNlLmV4cG9ydHMuZnJlZV9ocyhoZXhTdHJpbmdBcnJheVB0ckFkZHIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBGcmVlIGluZGl2aWR1YWwgaGV4IHN0cmluZ3NcbiAgICAgICAgICAgIGhleFN0cmluZ1B0cnMuZm9yRWFjaChwdHIgPT4ge1xuICAgICAgICAgICAgICBpZiAocHRyICE9PSAwKSB3SW5zdGFuY2UuZXhwb3J0cy5mcmVlX2hzKHB0cik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gU2h1dCBkb3duIHRoZSBIYXNrZWxsIHJ1bnRpbWVcbiAgICAgICAgICAgIHdJbnN0YW5jZS5leHBvcnRzLmhzX2V4aXQoKTtcbiAgICAgICAgICB9IGNhdGNoIChjbGVhbnVwRXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZHVyaW5nIGNsZWFudXA6JywgY2xlYW51cEVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdGhyb3cgaW5uZXJFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAod2FzbUVycm9yOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdXQVNNIGltcGxlbWVudGF0aW9uIGZhaWxlZCwgZmFsbGluZyBiYWNrIHRvIEpTOicsIHdhc21FcnJvcik7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byBKUyBpbXBsZW1lbnRhdGlvblxuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBKYXZhU2NyaXB0IGZhbGxiYWNrIGltcGxlbWVudGF0aW9uXG4gICAgY29uc29sZS5sb2coJ1VzaW5nIEphdmFTY3JpcHQgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24nKTtcbiAgICBcbiAgICAvLyBDb25jYXRlbmF0ZSBhbGwgaGV4IHN0cmluZ3NcbiAgICBjb25zdCBjb21iaW5lZEhleCA9IHZhbGlkSGV4U3RyaW5ncy5qb2luKCcnKTtcbiAgICBjb25zb2xlLmxvZygnQ29tYmluZWQgaGV4OicsIGNvbWJpbmVkSGV4KTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGJ5dGVzXG4gICAgY29uc3QgYnl0ZXMgPSBoZXhUb0J5dGVzKGNvbWJpbmVkSGV4KTtcbiAgICBjb25zb2xlLmxvZygnQ29udmVydGVkIHRvIGJ5dGVzLCBsZW5ndGg6JywgYnl0ZXMubGVuZ3RoKTtcbiAgICBcbiAgICAvLyBDb252ZXJ0IHRvIGJhc2U2NFxuICAgIGNvbnN0IGJhc2U2NCA9IGJ5dGVzVG9CYXNlNjQoYnl0ZXMpO1xuICAgIGNvbnNvbGUubG9nKCdDb252ZXJ0ZWQgdG8gYmFzZTY0LCBsZW5ndGg6JywgYmFzZTY0Lmxlbmd0aCk7XG4gICAgXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJlY29uc3RydWN0T3JpZ2luYWxCeXRlczonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcmVjb25zdHJ1Y3QgYnl0ZXM6ICR7ZXJyb3IubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpfWApO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyOiBSZWFkIGEgbnVsbC10ZXJtaW5hdGVkIEMgc3RyaW5nIGZyb20gV0FTTSBtZW1vcnlcbiAqL1xuZnVuY3Rpb24gcmVhZENTdHJpbmcobWVtb3J5OiBBcnJheUJ1ZmZlciwgcHRyOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoIW1lbW9yeSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWVtb3J5IGJ1ZmZlciBpcyB1bmRlZmluZWQgaW4gcmVhZENTdHJpbmcnKTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZyhgUmVhZGluZyBDIHN0cmluZyBmcm9tIG1lbW9yeSBhdCBwb2ludGVyOiAke3B0cn1gKTtcbiAgICBjb25zb2xlLmxvZyhgTWVtb3J5IGJ1ZmZlciBzaXplOiAke21lbW9yeS5ieXRlTGVuZ3RofWApO1xuICAgIFxuICAgIGNvbnN0IG1lbSA9IG5ldyBVaW50OEFycmF5KG1lbW9yeSk7XG4gICAgbGV0IGVuZCA9IHB0cjtcbiAgICBjb25zdCBtZW1MZW5ndGggPSBtZW0ubGVuZ3RoO1xuICAgIFxuICAgIC8vIENoZWNrIGZvciBvdXQtb2YtYm91bmRzIGFjY2Vzc1xuICAgIGlmIChwdHIgPj0gbWVtTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHJlYWRDU3RyaW5nOiBQb2ludGVyICR7cHRyfSBpcyBvdXRzaWRlIFdBU00gbWVtb3J5IGJvdW5kcy5gKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIG51bGwgdGVybWluYXRvciwgYnV0IHN0b3AgYXQgbWVtb3J5IGJvdW5kYXJ5XG4gICAgd2hpbGUgKGVuZCA8IG1lbUxlbmd0aCAmJiBtZW1bZW5kXSAhPT0gMCkge1xuICAgICAgZW5kKys7XG4gICAgfSAgICBcbiAgICBpZiAoZW5kID49IG1lbS5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJlYWRDU3RyaW5nOiBVbnRlcm1pbmF0ZWQgc3RyaW5nIChubyBudWxsIGJ5dGUgZm91bmQpLlwiKTtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgdGhlIHN0cmluZ1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtZW0uc3ViYXJyYXkocHRyLCBlbmQpKTtcbiAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IHJlYWQgc3RyaW5nIG9mIGxlbmd0aCAke2VuZCAtIHB0cn1gKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gcmVhZENTdHJpbmc6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gcmVhZENTdHJpbmc6ICR7ZXJyb3IubWVzc2FnZSB8fCBTdHJpbmcoZXJyb3IpfWApO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyOiBXcml0ZSBhIEpTIHN0cmluZyB0byBXQVNNIG1lbW9yeSAocmV0dXJucyBwb2ludGVyKVxuICovXG5mdW5jdGlvbiB3cml0ZUNTdHJpbmcoc3RyOiBzdHJpbmcsIHdJbnN0YW5jZTogV2FzbURlY29kZXJJbnN0YW5jZSk6IG51bWJlciB7XG4gIGlmICghd0luc3RhbmNlIHx8ICF3SW5zdGFuY2UuZXhwb3J0cyB8fCAhd0luc3RhbmNlLmV4cG9ydHMubWVtb3J5IHx8ICF3SW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKSB7XG4gICAgY29uc29sZS5lcnJvcignV0FTTSBpbnN0YW5jZSBzdHJ1Y3R1cmU6Jywgd0luc3RhbmNlKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgV0FTTSBpbnN0YW5jZSBzdHJ1Y3R1cmUgaW4gd3JpdGVDU3RyaW5nJyk7XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgY29uc3QgbGVuZ3RoTmVlZGVkID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY29uc3QgcHRyID0gd0luc3RhbmNlLmV4cG9ydHMubWFsbG9jX2J5dGVzX2hzKHN0ci5sZW5ndGggKyAxKTsgIC8vICsxIGZvciBudWxsIHRlcm1pbmF0b3JcbiAgICBjb25zb2xlLmxvZyhgQWxsb2NhdGVkIG1lbW9yeSBhdCBwb2ludGVyOiAke3B0cn0gZm9yIHN0cmluZyBsZW5ndGg6ICR7c3RyLmxlbmd0aH1gKTtcbiAgICBcbiAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheSh3SW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICBjb25zb2xlLmxvZyhgTWVtb3J5IGJ1ZmZlciBzaXplOiAke21lbS5sZW5ndGh9YCk7XG5cbiAgICAvLyBDaGVjayBpZiBwb2ludGVyIGlzIHZhbGlkIGFuZCBzcGFjZSBpcyBzdWZmaWNpZW50XG4gICAgaWYgKHB0ciArIGxlbmd0aE5lZWRlZCA+PSBtZW0ubGVuZ3RoKSB7XG4gICAgICB3SW5zdGFuY2UuZXhwb3J0cy5mcmVlX2hzKHB0cik7ICAvLyBBdm9pZCBsZWFraW5nIG1lbW9yeVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB3cml0ZUNTdHJpbmc6IFN0cmluZyAnJHtzdHJ9JyBleGNlZWRzIGFsbG9jYXRlZCBXQVNNIG1lbW9yeS5gKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgbWVtW3B0ciArIGldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIG1lbVtwdHIgKyBzdHIubGVuZ3RoXSA9IDA7ICAvLyBOdWxsLXRlcm1pbmF0ZVxuICAgIHJldHVybiBwdHI7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiB3cml0ZUNTdHJpbmc6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgaW4gd3JpdGVDU3RyaW5nOiAke2Vycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlcjogQ29udmVydCBiYXNlNjQgc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoYmFzZTY0OiBzdHJpbmcpOiBVaW50OEFycmF5IHtcbiAgY29uc3QgYmluU3RyID0gYXRvYihiYXNlNjQpO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpblN0ci5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJpblN0ci5sZW5ndGg7IGkrKykge1xuICAgIGJ5dGVzW2ldID0gYmluU3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbi8vIEltcG9ydCBmcm9tIG91ciBuZXcgVHlwZVNjcmlwdCBpbXBsZW1lbnRhdGlvblxuaW1wb3J0IHtcbiAgaW5pdGlhbGl6ZVdhc21EZWNvZGVyLFxuICByZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXMsXG4gIFdhc21EZWNvZGVySW5zdGFuY2Vcbn0gZnJvbSBcIi4uLy4uL3V0aWxzL2RlY29kZXJcIjtcblxuZXhwb3J0IGNvbnN0IEhleERlY29kZXI6IFJlYWN0LkZDID0gKCkgPT4ge1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbZm9ybWF0LCBzZXRGb3JtYXRdID0gdXNlU3RhdGU8XG4gICAgXCJ1dGY4XCIgfCBcImJhc2U2NFwiIHwgXCJwbmdcIiB8IFwianBlZ1wiIHwgXCJwZGZcIlxuICA+KFwidXRmOFwiKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG5cbiAgY29uc3Qgd2FzbUluc3RhbmNlID0gdXNlUmVmPFdhc21EZWNvZGVySW5zdGFuY2UgfCBudWxsPihudWxsKTtcbiAgY29uc3QgbGFzdEhleElucHV0ID0gdXNlUmVmPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IGxhc3RCYXNlNjQgPSB1c2VSZWY8c3RyaW5nPihcIlwiKTtcblxuICBjb25zdCBpbml0V2FzbSA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXdhc21JbnN0YW5jZS5jdXJyZW50KSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBObyBuZWVkIGZvciB3YXNtUGF0aCBwYXJhbWV0ZXIgYW55bW9yZVxuICAgICAgICBjb25zdCB7IHdhc21JbnN0YW5jZTogaW5zdCB9ID0gYXdhaXQgaW5pdGlhbGl6ZVdhc21EZWNvZGVyKCk7XG4gICAgICAgIHdhc21JbnN0YW5jZS5jdXJyZW50ID0gaW5zdDtcbiAgICAgICAgY29uc29sZS5sb2coXCJXQVNNIGRlY29kZXIgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5XCIpO1xuICAgICAgfSBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGluaXRpYWxpemUgV0FTTSBkZWNvZGVyLCB3aWxsIHVzZSBKUyBmYWxsYmFjazpcIiwgZXJyKTtcbiAgICAgICAgLy8gV2UnbGwgY29udGludWUgd2l0aG91dCBhIFdBU00gaW5zdGFuY2UgYW5kIHVzZSB0aGUgSlMgZmFsbGJhY2tcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdhc21JbnN0YW5jZS5jdXJyZW50OyAvLyBUaGlzIG1pZ2h0IGJlIG51bGwsIGJ1dCBvdXIgaW1wbGVtZW50YXRpb24gY2FuIGhhbmRsZSBpdFxuICB9O1xuXG4gIGNvbnN0IGRlY29kZSA9IGFzeW5jICgpID0+IHtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgICBzZXRSZXN1bHQobnVsbCk7XG4gICAgaWYgKCFpbnB1dC50cmltKCkpIHtcbiAgICAgIHNldEVycm9yKFwiUGxlYXNlIHBhc3RlIHNvbWUgaGV4YWRlY2ltYWwgc3RyaW5ncyBmaXJzdC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEluaXRpYWxpemUgV0FTTSAobWlnaHQgcmV0dXJuIG51bGwgaWYgaW5pdGlhbGl6YXRpb24gZmFpbHMpXG4gICAgICBjb25zdCBpbnN0ID0gYXdhaXQgaW5pdFdhc20oKTtcbiAgICAgIFxuICAgICAgLy8gUGFyc2UgbGluZXMgb3IgSlNPTiBhcnJheVxuICAgICAgbGV0IGhleHM6IHN0cmluZ1tdO1xuICAgICAgY29uc3QgdHh0ID0gaW5wdXQudHJpbSgpO1xuICAgICAgXG4gICAgICBpZiAodHh0LnN0YXJ0c1dpdGgoXCJbXCIpICYmIHR4dC5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBhcnIgPSBKU09OLnBhcnNlKHR4dCk7XG4gICAgICAgICAgaGV4cyA9IEFycmF5LmlzQXJyYXkoYXJyKSA/IGFyciA6IFtTdHJpbmcoYXJyKV07XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGhleHMgPSB0eHQuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsKSA9PiBsLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhleHMgPSB0eHRcbiAgICAgICAgICAuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAubWFwKChsKSA9PiBsLnRyaW0oKSlcbiAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBPbmx5IHByb2Nlc3MgaWYgaW5wdXQgaGFzIGNoYW5nZWRcbiAgICAgIGlmICh0eHQgIT09IGxhc3RIZXhJbnB1dC5jdXJyZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiUHJvY2Vzc2luZyBuZXcgaGV4IGlucHV0XCIpO1xuICAgICAgICAvLyBPdXIgcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzIGZ1bmN0aW9uIGNhbiBub3cgaGFuZGxlIGEgbnVsbCBXQVNNIGluc3RhbmNlXG4gICAgICAgIGxhc3RCYXNlNjQuY3VycmVudCA9IGF3YWl0IHJlY29uc3RydWN0T3JpZ2luYWxCeXRlcyhpbnN0LCBoZXhzKTtcbiAgICAgICAgbGFzdEhleElucHV0LmN1cnJlbnQgPSB0eHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlVzaW5nIGNhY2hlZCByZXN1bHRcIik7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEZvcm1hdCB0aGUgb3V0cHV0IGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBmb3JtYXRcbiAgICAgIGxldCBvdXQ6IHN0cmluZztcbiAgICAgIGlmIChmb3JtYXQgPT09IFwidXRmOFwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0ID0gYXRvYihsYXN0QmFzZTY0LmN1cnJlbnQpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ29udmVydGVkIGJhc2U2NCB0byBVVEYtOCB0ZXh0XCIpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJGYWlsZWQgdG8gZGVjb2RlIGJhc2U2NCBhcyBVVEYtOCwgdXNpbmcgcmF3IGJhc2U2NDpcIiwgZXJyKTtcbiAgICAgICAgICBvdXQgPSBsYXN0QmFzZTY0LmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBiaW5hcnkgZm9ybWF0cyB3ZSBzdGlsbCBob2xkIGJhc2U2NDsgdXNlciBjYW4gZG93bmxvYWQgb3IgcHJldmlldyBlbHNld2hlcmVcbiAgICAgICAgb3V0ID0gbGFzdEJhc2U2NC5jdXJyZW50O1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZXRSZXN1bHQob3V0KTtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJEZWNvZGluZyBlcnJvcjpcIiwgZSk7XG4gICAgICBzZXRFcnJvcihcIkRlY29kaW5nIGVycm9yOiBcIiArIChlLm1lc3NhZ2UgfHwgZS50b1N0cmluZygpKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB0YWJzOiB7IGtleTogdHlwZW9mIGZvcm1hdDsgbGFiZWw6IHN0cmluZyB9W10gPSBbXG4gICAgeyBrZXk6IFwidXRmOFwiLCBsYWJlbDogXCJUZXh0IChVVEbigJE4KVwiIH0sXG4gICAgeyBrZXk6IFwiYmFzZTY0XCIsIGxhYmVsOiBcIkJhc2U2NFwiIH0sXG4gICAgeyBrZXk6IFwicG5nXCIsIGxhYmVsOiBcIlBOR1wiIH0sXG4gICAgeyBrZXk6IFwianBlZ1wiLCBsYWJlbDogXCJKUEVHXCIgfSxcbiAgICB7IGtleTogXCJwZGZcIiwgbGFiZWw6IFwiUERGXCIgfSxcbiAgXTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiYmctd2hpdGUvMTAgcm91bmRlZC00eGwgYmFja2Ryb3AtYmx1ci1bMTBweF0gcC04IG1heC13LTV4bCB3LWZ1bGwgbXgtYXV0byB0ZXh0LXdoaXRlXCI+XG4gICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1ib2xkIHRleHQtd2hpdGUgbWItNFwiPk1ldGFkYXRhOjwvaDI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTZcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3VuZGVkLTN4bCBiZy13aGl0ZS8xMCBiYWNrZHJvcC1ibHVyLVsxMHB4XSBmbGV4IGZsZXgtY29sIGdhcC0yIHJlbGF0aXZlXCI+XG4gICAgICAgICAge2lucHV0LnRyaW0oKSA9PT0gXCJcIiAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZvbnQtbW9ubyB0ZXh0LWJhc2UgdGV4dC1bI0MzRDVGN10gbWItMSBhYnNvbHV0ZSBpbnNldC0wIHAtOCBmbGV4IGZsZXgtY29sIHBvaW50ZXItZXZlbnRzLW5vbmVcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYmxvY2sgbWItMVwiPlxuICAgICAgICAgICAgICAgIFBhc3RlIHlvdXIgaGV4IHN0cmluZ3MgaGVyZSwgb25lIHBlciBsaW5lIG9yIGFzIGFuIGFycmF5OlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIml0YWxpYyBtdC02XCI+RXhhbXBsZSAobGluZSBieSBsaW5lKTo8L3NwYW4+XG4gICAgICAgICAgICAgIDxwcmUgY2xhc3NOYW1lPVwibWItMVwiPlxuICAgICAgICAgICAgICAgIDQ4NjU2QzZDNkYyMDU3NkY3MjZDNjR7YFxcbmB9NEQ3NTZDNzQ2OTRDNjk2RTY1XG4gICAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpdGFsaWMgbXQtNlwiPk9yIChhcnJheSBmb3JtYXQpOjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHByZT5bXCI0ODY1NkM2QzZGXCIsIFwiNTc2RjcyNkM2NFwiXTwvcHJlPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgICA8dGV4dGFyZWFcbiAgICAgICAgICAgIHZhbHVlPXtpbnB1dH1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIG1pbi1oLVsyMHJlbV0gcC04IGZvbnQtbW9ubyB0ZXh0LXNtIHRleHQtZ3JheS0yMDAgYmctdHJhbnNwYXJlbnQgcm91bmRlZC1sZyByZXNpemUteSBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6Ym9yZGVyLWJsdWUtNDAwXCJcbiAgICAgICAgICAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTZcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIGZvbnQtbWVkaXVtIG1iLTJcIj5PdXRwdXQ6PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW5saW5lLWZsZXggcm91bmRlZC1sZyBwLTEgZ2FwLTJcIj5cbiAgICAgICAgICB7dGFicy5tYXAoKHRhYikgPT4gKFxuICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICBrZXk9e3RhYi5rZXl9XG4gICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldEZvcm1hdCh0YWIua2V5KX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcHgtMiBweS0xIHRleHQtc20gZm9udC1tZWRpdW0gcm91bmRlZC1sZyB0cmFuc2l0aW9uICR7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSB0YWIua2V5XG4gICAgICAgICAgICAgICAgICA/IFwiYmctWyMwNTEwMjNdIGJnLW9wYWNpdHktNTAgdGV4dC13aGl0ZVwiXG4gICAgICAgICAgICAgICAgICA6IFwidGV4dC1ncmF5LTIwMCBiZy13aGl0ZS8xMFwiXG4gICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7dGFiLmxhYmVsfVxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxidXR0b25cbiAgICAgICAgb25DbGljaz17ZGVjb2RlfVxuICAgICAgICBkaXNhYmxlZD17bG9hZGluZ31cbiAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIHB5LTMgcm91bmRlZC1mdWxsIGJnLWJsdWUtNjAwIGhvdmVyOmJnLWJsdWUtNzAwIHRleHQtd2hpdGUgZm9udC1zZW1pYm9sZCB0cmFuc2l0aW9uIGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkXCJcbiAgICAgID5cbiAgICAgICAge2xvYWRpbmcgPyBcIkRlY29kaW5n4oCmXCIgOiBcIkRlY29kZVwifVxuICAgICAgPC9idXR0b24+XG5cbiAgICAgIHsocmVzdWx0IHx8IGVycm9yKSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtOFwiPlxuICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtc2VtaWJvbGQgdGV4dC13aGl0ZSBtYi0yXCI+XG4gICAgICAgICAgICB7ZXJyb3IgPyBcIkVycm9yXCIgOiBcIkRlY29kZWQgUmVzdWx0XCJ9XG4gICAgICAgICAgPC9oMz5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTQgYmctd2hpdGUvMTAgcm91bmRlZC00eGwgYmFja2Ryb3AtYmx1ci1bMTBweF0gYm9yZGVyLWwtNCBib3JkZXItYmx1ZS01MDAgcC01IGZvbnQtbW9ubyB0ZXh0LXNtIHRleHQtZ3JheS0xMDAgbWF4LWgtNjQgb3ZlcmZsb3cteS1hdXRvIHdoaXRlc3BhY2UtcHJlLXdyYXBcIj5cbiAgICAgICAgICAgIHtlcnJvciA/IChcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICkgOiBmb3JtYXQgPT09IFwicG5nXCIgfHwgZm9ybWF0ID09PSBcImpwZWdcIiA/IChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICAgICAgICAgIDxpbWcgXG4gICAgICAgICAgICAgICAgICBzcmM9e2BkYXRhOmltYWdlLyR7Zm9ybWF0fTtiYXNlNjQsJHtyZXN1bHR9YH0gXG4gICAgICAgICAgICAgICAgICBhbHQ9XCJEZWNvZGVkIGltYWdlXCIgXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtYXgtdy1mdWxsIG1heC1oLTU2IG9iamVjdC1jb250YWluXCJcbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxhIFxuICAgICAgICAgICAgICAgICAgaHJlZj17YGRhdGE6aW1hZ2UvJHtmb3JtYXR9O2Jhc2U2NCwke3Jlc3VsdH1gfSBcbiAgICAgICAgICAgICAgICAgIGRvd25sb2FkPXtgZGVjb2RlZC4ke2Zvcm1hdH1gfVxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyB0ZXh0LWJsdWUtNDAwIGhvdmVyOnRleHQtYmx1ZS0zMDAgdW5kZXJsaW5lIHRleHQtc21cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIERvd25sb2FkIEltYWdlXG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICkgOiBmb3JtYXQgPT09IFwicGRmXCIgPyAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8aWZyYW1lXG4gICAgICAgICAgICAgICAgICBzcmM9e2BkYXRhOmFwcGxpY2F0aW9uL3BkZjtiYXNlNjQsJHtyZXN1bHR9YH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLTU2IGJvcmRlci0wXCJcbiAgICAgICAgICAgICAgICAgIHRpdGxlPVwiUERGIFZpZXdlclwiXG4gICAgICAgICAgICAgICAgPjwvaWZyYW1lPlxuICAgICAgICAgICAgICAgIDxhIFxuICAgICAgICAgICAgICAgICAgaHJlZj17YGRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwke3Jlc3VsdH1gfSBcbiAgICAgICAgICAgICAgICAgIGRvd25sb2FkPVwiZGVjb2RlZC5wZGZcIlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyB0ZXh0LWJsdWUtNDAwIGhvdmVyOnRleHQtYmx1ZS0zMDAgdW5kZXJsaW5lIHRleHQtc21cIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIERvd25sb2FkIFBERlxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICByZXN1bHRcbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhleERlY29kZXI7XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9XYWxsZXRDb250ZXh0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZXdhcmRBY2NvdW50cygpIHtcbiAgY29uc3QgW3Jld2FyZEFjY291bnRzLCBzZXRSZXdhcmRBY2NvdW50c10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuICBjb25zdCB7IGRlZmF1bHRXYWxsZXQsIGdldFdhbGxldEFwaSwgY29ubmVjdGVkV2FsbGV0cyB9ID0gdXNlV2FsbGV0KCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaFJld2FyZEFjY291bnRzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjb25uZWN0ZWRXYWxsZXRzLmxlbmd0aCB8fCAhZGVmYXVsdFdhbGxldCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBhcGkgPSBnZXRXYWxsZXRBcGkoZGVmYXVsdFdhbGxldCk7XG4gICAgICAgIGlmICghYXBpKSB0aHJvdyBuZXcgRXJyb3IoXCJXYWxsZXQgQVBJIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgY29uc3QgcmV3YXJkQWRkcmVzc2VzID0gYXdhaXQgYXBpLmdldFJld2FyZEFkZHJlc3NlcygpO1xuICAgICAgICBzZXRSZXdhcmRBY2NvdW50cyhyZXdhcmRBZGRyZXNzZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyByZXdhcmQgYWNjb3VudHM6XCIsIGVycik7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoY29ubmVjdGVkV2FsbGV0cy5sZW5ndGggPiAwKSBmZXRjaFJld2FyZEFjY291bnRzKCk7XG4gIH0sIFtkZWZhdWx0V2FsbGV0LCBjb25uZWN0ZWRXYWxsZXRzLCBnZXRXYWxsZXRBcGldKTtcblxuICByZXR1cm4gcmV3YXJkQWNjb3VudHM7XG59XG4iLCJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgYnVpbGRBcGlVcmwsIEFQSV9LRVkgfSBmcm9tIFwiLi4vLi4vdXRpbHMvYXBpQ29uc3VtcHRpb25cIjtcblxuZXhwb3J0IGludGVyZmFjZSBVcGxvYWQge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRhdGVVcGxvYWRlZDogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgdGh1bWJuYWlsVXJsPzogc3RyaW5nO1xuICBmaWxlVHlwZT86IHN0cmluZztcbiAgb2JqZWN0RGF0YT86IHN0cmluZztcbiAgb2JqZWN0VHlwZT86IHN0cmluZztcbiAgaW5kZXhpbmdUeElkPzogc3RyaW5nO1xuICBpbmRleGluZ1R4U3VibWl0dGVkQXQ/OiBzdHJpbmc7XG4gIHNoYXJkVHhJZHM/OiBzdHJpbmdbXTtcbiAgb2JqZWN0VWxpZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VVcGxvYWRzUHJvcHMge1xuICBsaW1pdD86IG51bWJlcjtcbiAgcmV3YXJkQWNjb3VudHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVXBsb2Fkcyh7IGxpbWl0ID0gOSwgcmV3YXJkQWNjb3VudHMgfTogVXNlVXBsb2Fkc1Byb3BzKSB7XG4gIGNvbnN0IFthbGxVcGxvYWRzLCBzZXRBbGxVcGxvYWRzXSA9IHVzZVN0YXRlPFVwbG9hZFtdPihbXSk7XG4gIGNvbnN0IFtmaWx0ZXJlZFVwbG9hZHMsIHNldEZpbHRlcmVkVXBsb2Fkc10gPSB1c2VTdGF0ZTxVcGxvYWRbXT4oW10pO1xuICBjb25zdCBbZGlzcGxheWVkVXBsb2Fkcywgc2V0RGlzcGxheWVkVXBsb2Fkc10gPSB1c2VTdGF0ZTxVcGxvYWRbXT4oW10pO1xuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW3BhZ2VzRGF0YSwgc2V0UGFnZXNEYXRhXSA9IHVzZVN0YXRlPHsgW3BhZ2U6IG51bWJlcl06IFVwbG9hZFtdIH0+KHt9KTtcbiAgY29uc3QgW2xhc3RPYmplY3RVbGlkcywgc2V0TGFzdE9iamVjdFVsaWRzXSA9IHVzZVN0YXRlPHtcbiAgICBbcGFnZTogbnVtYmVyXTogc3RyaW5nO1xuICB9Pih7fSk7XG4gIGNvbnN0IFtjdXJyZW50UGFnZSwgc2V0Q3VycmVudFBhZ2VdID0gdXNlU3RhdGUoMSk7XG4gIGNvbnN0IFtoYXNNb3JlUGFnZXMsIHNldEhhc01vcmVQYWdlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBmZXRjaEluaXRpYWxVcGxvYWRzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHJld2FyZEFjY291bnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcihudWxsKTtcbiAgICAgICAgY29uc3QgYm9keSA9IHsgbGltaXQsIHJld2FyZEFjY291bnRzIH07XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYnVpbGRBcGlVcmwoXCIvYWNjb3VudC11cGxvYWRzXCIpLCB7XG4gICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgIFwieC1hcGkta2V5XCI6IEFQSV9LRVksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkVXBsb2FkczogVXBsb2FkW10gPSBkYXRhLm9iamVjdHM7XG4gICAgICAgIHNldEFsbFVwbG9hZHMoZm9ybWF0dGVkVXBsb2Fkcyk7XG4gICAgICAgIHNldEZpbHRlcmVkVXBsb2Fkcyhmb3JtYXR0ZWRVcGxvYWRzKTtcbiAgICAgICAgc2V0RGlzcGxheWVkVXBsb2Fkcyhmb3JtYXR0ZWRVcGxvYWRzKTtcbiAgICAgICAgc2V0UGFnZXNEYXRhKHsgMTogZm9ybWF0dGVkVXBsb2FkcyB9KTtcbiAgICAgICAgY29uc3QgbGFzdFVsaWQgPSBkYXRhLm1MYXN0T2JqZWN0VWxpZDtcbiAgICAgICAgc2V0TGFzdE9iamVjdFVsaWRzKHsgMTogbGFzdFVsaWQgfSk7XG4gICAgICAgIHNldEhhc01vcmVQYWdlcyhsYXN0VWxpZCAhPT0gbnVsbCk7XG4gICAgICAgIHNldEN1cnJlbnRQYWdlKDEpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldEVycm9yKFxuICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgaW5pdGlhbCB1cGxvYWRzOlwiLCBlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmZXRjaEluaXRpYWxVcGxvYWRzKCk7XG4gIH0sIFtyZXdhcmRBY2NvdW50cywgbGltaXRdKTtcblxuICBjb25zdCBmZXRjaE5leHRQYWdlID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHBhZ2VOdW1iZXI6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKHBhZ2VzRGF0YVtwYWdlTnVtYmVyXSkge1xuICAgICAgICBzZXREaXNwbGF5ZWRVcGxvYWRzKHBhZ2VzRGF0YVtwYWdlTnVtYmVyXSk7XG4gICAgICAgIHNldEN1cnJlbnRQYWdlKHBhZ2VOdW1iZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBsYXN0VWxpZCA9IGxhc3RPYmplY3RVbGlkc1twYWdlTnVtYmVyIC0gMV07XG4gICAgICBpZiAoIWxhc3RVbGlkKSByZXR1cm47XG4gICAgICB0cnkge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICBjb25zdCBib2R5ID0geyBsYXN0T2JqZWN0VWxpZDogbGFzdFVsaWQsIGxpbWl0LCByZXdhcmRBY2NvdW50cyB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGJ1aWxkQXBpVXJsKFwiL2FjY291bnQtdXBsb2Fkc1wiKSwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFVwbG9hZHM6IFVwbG9hZFtdID0gZGF0YS5vYmplY3RzO1xuICAgICAgICBzZXRBbGxVcGxvYWRzKChwcmV2KSA9PiBbLi4ucHJldiwgLi4uZm9ybWF0dGVkVXBsb2Fkc10pO1xuICAgICAgICBzZXRQYWdlc0RhdGEoKHByZXYpID0+ICh7IC4uLnByZXYsIFtwYWdlTnVtYmVyXTogZm9ybWF0dGVkVXBsb2FkcyB9KSk7XG4gICAgICAgIGNvbnN0IG5ld0xhc3RVbGlkID0gZGF0YS5tTGFzdE9iamVjdFVsaWQ7XG4gICAgICAgIHNldExhc3RPYmplY3RVbGlkcygocHJldikgPT4gKHsgLi4ucHJldiwgW3BhZ2VOdW1iZXJdOiBuZXdMYXN0VWxpZCB9KSk7XG4gICAgICAgIHNldEhhc01vcmVQYWdlcyhuZXdMYXN0VWxpZCAhPT0gbnVsbCk7XG4gICAgICAgIHNldERpc3BsYXllZFVwbG9hZHMoZm9ybWF0dGVkVXBsb2Fkcyk7XG4gICAgICAgIHNldEN1cnJlbnRQYWdlKHBhZ2VOdW1iZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNldEVycm9yKFxuICAgICAgICAgIGVyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBcIkFuIHVua25vd24gZXJyb3Igb2NjdXJyZWRcIlxuICAgICAgICApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBwYWdlICR7cGFnZU51bWJlcn06YCwgZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW3BhZ2VzRGF0YSwgbGFzdE9iamVjdFVsaWRzLCBsaW1pdCwgcmV3YXJkQWNjb3VudHNdXG4gICk7XG5cbiAgcmV0dXJuIHtcbiAgICBhbGxVcGxvYWRzLFxuICAgIGZpbHRlcmVkVXBsb2FkcyxcbiAgICBkaXNwbGF5ZWRVcGxvYWRzLFxuICAgIHNldEZpbHRlcmVkVXBsb2FkcyxcbiAgICBzZXREaXNwbGF5ZWRVcGxvYWRzLFxuICAgIGxvYWRpbmcsXG4gICAgZXJyb3IsXG4gICAgcGFnZXNEYXRhLFxuICAgIGxhc3RPYmplY3RVbGlkcyxcbiAgICBjdXJyZW50UGFnZSxcbiAgICBzZXRDdXJyZW50UGFnZSxcbiAgICBoYXNNb3JlUGFnZXMsXG4gICAgc2V0QWxsVXBsb2FkcyxcbiAgICBzZXRQYWdlc0RhdGEsXG4gICAgc2V0TGFzdE9iamVjdFVsaWRzLFxuICAgIHNldEhhc01vcmVQYWdlcyxcbiAgICBmZXRjaE5leHRQYWdlLFxuICB9O1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVXBsb2FkIH0gZnJvbSBcIi4vdXNlVXBsb2Fkc1wiO1xuaW1wb3J0IHsgRXhwbG9yZXJMaW5rIH0gZnJvbSBcIi4uL3VpL0ZpbmlzaFNjcmVlblwiO1xuXG5pbnRlcmZhY2UgVXBsb2FkQ2FyZFByb3BzIHtcbiAgdXBsb2FkOiBVcGxvYWQ7XG4gIG9uQ29weVRleHQ6ICh0ZXh0OiBzdHJpbmcpID0+IHZvaWQ7XG59XG5cbmNvbnN0IGdldEltYWdlU3JjID0gKHVwbG9hZDogVXBsb2FkKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHVwbG9hZC50aHVtYm5haWxVcmwpIHJldHVybiB1cGxvYWQudGh1bWJuYWlsVXJsO1xuICBpZiAodXBsb2FkLm9iamVjdERhdGEgJiYgdXBsb2FkLm9iamVjdFR5cGUgJiYgdXBsb2FkLm9iamVjdFR5cGUuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgIHJldHVybiBgZGF0YToke3VwbG9hZC5vYmplY3RUeXBlfTtiYXNlNjQsJHt1cGxvYWQub2JqZWN0RGF0YX1gO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5jb25zdCBmb3JtYXREYXRlID0gKGRhdGVTdHJpbmc/OiBzdHJpbmcgfCBudWxsKSA9PiB7XG4gIGlmICghZGF0ZVN0cmluZykgcmV0dXJuIFwiVW5jb21wbGV0ZWRcIjtcbiAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKGRhdGVTdHJpbmcpO1xuICBpZiAoaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSByZXR1cm4gXCJVbmNvbXBsZXRlZFwiO1xuICByZXR1cm4gZGF0ZS50b0xvY2FsZURhdGVTdHJpbmcoKTtcbn07XG5cbmNvbnN0IFVwbG9hZENhcmQ6IFJlYWN0LkZDPFVwbG9hZENhcmRQcm9wcz4gPSAoeyB1cGxvYWQsIG9uQ29weVRleHQgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYWRpZW50LXRvLWIgZnJvbS1bcmdiYSgzMCwzMCw2MCwwLjcpXSB0by1bcmdiYSgyMCwyMCw0MCwwLjcpXSByb3VuZGVkLWxnIHAtNCBmbGV4IGZsZXgtY29sIGgtZnVsbCBib3JkZXIgYm9yZGVyLVtyZ2JhKDI1NSwyNTUsMjU1LDAuMSldIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBob3Zlcjp0cmFuc2Zvcm0gaG92ZXI6LXRyYW5zbGF0ZS15LTEuNSBob3ZlcjpzaGFkb3ctbGdcIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1bdmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpXSBtYi0xLjVcIj57Zm9ybWF0RGF0ZSh1cGxvYWQuaW5kZXhpbmdUeFN1Ym1pdHRlZEF0IHx8IFwiXCIpfTwvZGl2PlxuICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LWJvbGQgbWItMi41IHRleHQtW3ZhcigtLWNvbG9yLXByaW1hcnktdHcpXVwiPnt1cGxvYWQubmFtZX08L2Rpdj5cbiAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtW3ZhcigtLWNvbG9yLWxpZ2h0KV0gbWItNCBmbGV4LWdyb3cgb3ZlcmZsb3ctaGlkZGVuIHRleHQtZWxsaXBzaXMgbGluZS1jbGFtcC0zXCI+e3VwbG9hZC5kZXNjcmlwdGlvbn08L3A+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1bMTUwcHhdIGJnLVt2YXIoLS1jb2xvci1iZy1jYXJkKV0gcm91bmRlZC1tZCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtYi00IG92ZXJmbG93LWhpZGRlblwiPlxuICAgICAge3VwbG9hZC5vYmplY3RUeXBlID09PSBcInRleHQvcGxhaW5cIiAmJiB1cGxvYWQub2JqZWN0RGF0YSA/IChcbiAgICAgICAgPHByZSBjbGFzc05hbWU9XCJ3aGl0ZXNwYWNlLXByZS13cmFwIGJyZWFrLWFsbCBiZy1bI2Y2ZjZmNl0gcC0zIHJvdW5kZWQtbWQgbWF4LWgtWzMwMHB4XSBvdmVyZmxvdy1hdXRvIHctZnVsbCBoLWZ1bGxcIj57YXRvYih1cGxvYWQub2JqZWN0RGF0YSl9PC9wcmU+XG4gICAgICApIDogdXBsb2FkLmZpbGVUeXBlICYmIHVwbG9hZC5maWxlVHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwicGRmXCIpICYmIHVwbG9hZC5vYmplY3REYXRhID8gKFxuICAgICAgICA8aWZyYW1lIHNyYz17YGRhdGE6YXBwbGljYXRpb24vcGRmO2Jhc2U2NCwke3VwbG9hZC5vYmplY3REYXRhfWB9IHRpdGxlPXt1cGxvYWQubmFtZX0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBvYmplY3QtY292ZXJcIiAvPlxuICAgICAgKSA6IGdldEltYWdlU3JjKHVwbG9hZCkgPyAoXG4gICAgICAgIDxpbWcgc3JjPXtnZXRJbWFnZVNyYyh1cGxvYWQpfSBhbHQ9e3VwbG9hZC5uYW1lfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIG9iamVjdC1jb3ZlclwiIC8+XG4gICAgICApIDogKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctW3ZhcigtLWNvbG9yLWJnLWNhcmQpXVwiPjxzcGFuIGNsYXNzTmFtZT1cInRleHQtM3hsIHRleHQtW3ZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KV1cIj7wn5a877iPPC9zcGFuPjwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgICB7dXBsb2FkLmZpbGVUeXBlICYmIHVwbG9hZC5maWxlVHlwZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwidGV4dFwiKSAmJiAoXG4gICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJnLXRyYW5zcGFyZW50IGJvcmRlciBib3JkZXItW3JnYmEoMjU1LDI1NSwyNTUsMC4yKV0gdGV4dC1bdmFyKC0tY29sb3ItcHJpbWFyeS10dyldIHB5LTIgcHgtMyByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBob3ZlcjpiZy1bcmdiYSgyNTUsMjU1LDI1NSwwLjEpXSB0ZXh0LXNtXCIgb25DbGljaz17KCkgPT4gb25Db3B5VGV4dCh1cGxvYWQuZGVzY3JpcHRpb24gfHwgXCJcIil9PkNvcHkgdGV4dDwvYnV0dG9uPlxuICAgICl9XG4gICAge3VwbG9hZC5pbmRleGluZ1R4SWQgJiYgPEV4cGxvcmVyTGluayB0eElkPXt1cGxvYWQuaW5kZXhpbmdUeElkfSAvPn1cbiAgICB7dXBsb2FkLnNoYXJkVHhJZHMgJiYgdXBsb2FkLnNoYXJkVHhJZHMubGVuZ3RoID4gMCAmJiB1cGxvYWQuc2hhcmRUeElkcy5tYXAoKHR4SWQsIGluZGV4KSA9PiAoXG4gICAgICA8RXhwbG9yZXJMaW5rIHR4SWQ9e3R4SWR9IGtleT17aW5kZXh9IC8+XG4gICAgKSl9XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkQ2FyZDtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFVwbG9hZCB9IGZyb20gXCIuL3VzZVVwbG9hZHNcIjtcbmltcG9ydCBVcGxvYWRDYXJkIGZyb20gXCIuL1VwbG9hZENhcmRcIjtcblxuXG5pbnRlcmZhY2UgVXBsb2Fkc0dyaWRQcm9wcyB7XG4gIHVwbG9hZHM6IFVwbG9hZFtdO1xuICBvbkNvcHlUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBVcGxvYWRzR3JpZDogUmVhY3QuRkM8VXBsb2Fkc0dyaWRQcm9wcz4gPSAoeyB1cGxvYWRzLCBvbkNvcHlUZXh0IH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0zIGdhcC01IG1iLTggbWQ6Z3JpZC1jb2xzLTIgc206Z3JpZC1jb2xzLTFcIj5cbiAgICB7dXBsb2Fkcy5tYXAoKHVwbG9hZCkgPT4gKFxuICAgICAgPFVwbG9hZENhcmQga2V5PXt1cGxvYWQuaWR9IHVwbG9hZD17dXBsb2FkfSBvbkNvcHlUZXh0PXtvbkNvcHlUZXh0fSAvPlxuICAgICkpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZHNHcmlkO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVXBsb2FkIH0gZnJvbSBcIi4vdXNlVXBsb2Fkc1wiO1xuaW1wb3J0IHsgRXhwbG9yZXJMaW5rIH0gZnJvbSBcIi4uL3VpL0ZpbmlzaFNjcmVlblwiO1xuXG5pbnRlcmZhY2UgVXBsb2FkTGlzdEl0ZW1Qcm9wcyB7XG4gIHVwbG9hZDogVXBsb2FkO1xuICBvbkNvcHlUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBnZXRJbWFnZVNyYyA9ICh1cGxvYWQ6IFVwbG9hZCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh1cGxvYWQudGh1bWJuYWlsVXJsKSByZXR1cm4gdXBsb2FkLnRodW1ibmFpbFVybDtcbiAgaWYgKHVwbG9hZC5vYmplY3REYXRhICYmIHVwbG9hZC5vYmplY3RUeXBlICYmIHVwbG9hZC5vYmplY3RUeXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICByZXR1cm4gYGRhdGE6JHt1cGxvYWQub2JqZWN0VHlwZX07YmFzZTY0LCR7dXBsb2FkLm9iamVjdERhdGF9YDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgZm9ybWF0RGF0ZSA9IChkYXRlU3RyaW5nPzogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICBpZiAoIWRhdGVTdHJpbmcpIHJldHVybiBcIlVuY29tcGxldGVkXCI7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkgcmV0dXJuIFwiVW5jb21wbGV0ZWRcIjtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG59O1xuXG5jb25zdCBVcGxvYWRMaXN0SXRlbTogUmVhY3QuRkM8VXBsb2FkTGlzdEl0ZW1Qcm9wcz4gPSAoeyB1cGxvYWQsIG9uQ29weVRleHQgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cImJnLWdyYWRpZW50LXRvLXIgZnJvbS1bcmdiYSgzMCwzMCw2MCwwLjcpXSB0by1bcmdiYSgyMCwyMCw0MCwwLjcpXSByb3VuZGVkLWxnIHAtNCBncmlkIGdyaWQtY29scy1bMWZyXzJmcl8xMDBweF0gZ2FwLTQgYm9yZGVyIGJvcmRlci1bcmdiYSgyNTUsMjU1LDI1NSwwLjEpXSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgaG92ZXI6dHJhbnNmb3JtIGhvdmVyOi10cmFuc2xhdGUteS0wLjUgaG92ZXI6c2hhZG93LWxnIGl0ZW1zLWNlbnRlciBtZDpncmlkLWNvbHMtMSBtZDpncmlkLXJvd3MtW2F1dG9fYXV0b19hdXRvXVwiPlxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMS41XCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC1bdmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpXVwiPntmb3JtYXREYXRlKHVwbG9hZC5pbmRleGluZ1R4U3VibWl0dGVkQXQgfHwgXCJcIil9PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtbGcgZm9udC1ib2xkIHRleHQtW3ZhcigtLWNvbG9yLXByaW1hcnktdHcpXVwiPnt1cGxvYWQubmFtZX08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIuNVwiPlxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LVt2YXIoLS1jb2xvci1saWdodCldIG92ZXJmbG93LWhpZGRlbiB0ZXh0LWVsbGlwc2lzIGxpbmUtY2xhbXAtMlwiPnt1cGxvYWQuZGVzY3JpcHRpb259PC9wPlxuICAgICAge3VwbG9hZC5maWxlVHlwZSAmJiB1cGxvYWQuZmlsZVR5cGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRleHRcIikgJiYgKFxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJnLXRyYW5zcGFyZW50IGJvcmRlciBib3JkZXItW3JnYmEoMjU1LDI1NSwyNTUsMC4yKV0gdGV4dC1bdmFyKC0tY29sb3ItcHJpbWFyeS10dyldIHB5LTIgcHgtMyByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBob3ZlcjpiZy1bcmdiYSgyNTUsMjU1LDI1NSwwLjEpXSB0ZXh0LXNtXCIgb25DbGljaz17KCkgPT4gb25Db3B5VGV4dCh1cGxvYWQuZGVzY3JpcHRpb24gfHwgXCJcIil9PkNvcHkgdGV4dDwvYnV0dG9uPlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInctWzEwMHB4XSBoLVsxMDBweF0gYmctW3ZhcigtLWNvbG9yLWJnLWNhcmQpXSByb3VuZGVkLW1kIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG92ZXJmbG93LWhpZGRlbiBtZDp3LWZ1bGwgbWQ6aC1bMTUwcHhdIG1kOm9yZGVyLWZpcnN0XCI+XG4gICAgICB7dXBsb2FkLm9iamVjdFR5cGUgPT09IFwidGV4dC9wbGFpblwiICYmIHVwbG9hZC5vYmplY3REYXRhID8gKFxuICAgICAgICA8cHJlIGNsYXNzTmFtZT1cIndoaXRlc3BhY2UtcHJlLXdyYXAgYnJlYWstYWxsIGJnLVsjZjZmNmY2XSBwLTMgcm91bmRlZC1tZCBtYXgtaC1bMzAwcHhdIG92ZXJmbG93LWF1dG8gdy1mdWxsIGgtZnVsbFwiPnthdG9iKHVwbG9hZC5vYmplY3REYXRhKX08L3ByZT5cbiAgICAgICkgOiB1cGxvYWQuZmlsZVR5cGUgJiYgdXBsb2FkLmZpbGVUeXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJwZGZcIikgJiYgdXBsb2FkLm9iamVjdERhdGEgPyAoXG4gICAgICAgIDxpZnJhbWUgc3JjPXtgZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LCR7dXBsb2FkLm9iamVjdERhdGF9YH0gdGl0bGU9e3VwbG9hZC5uYW1lfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIG9iamVjdC1jb3ZlclwiIC8+XG4gICAgICApIDogZ2V0SW1hZ2VTcmModXBsb2FkKSA/IChcbiAgICAgICAgPGltZyBzcmM9e2dldEltYWdlU3JjKHVwbG9hZCl9IGFsdD17dXBsb2FkLm5hbWV9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgb2JqZWN0LWNvdmVyXCIgLz5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1bdmFyKC0tY29sb3ItYmctY2FyZCldXCI+PHNwYW4gY2xhc3NOYW1lPVwidGV4dC0zeGwgdGV4dC1bdmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpXVwiPvCflrzvuI88L3NwYW4+PC9kaXY+XG4gICAgICApfVxuICAgICAge3VwbG9hZC5pbmRleGluZ1R4SWQgJiYgPEV4cGxvcmVyTGluayB0eElkPXt1cGxvYWQuaW5kZXhpbmdUeElkfSAvPn1cbiAgICAgIHt1cGxvYWQuc2hhcmRUeElkcyAmJiB1cGxvYWQuc2hhcmRUeElkcy5sZW5ndGggPiAwICYmIHVwbG9hZC5zaGFyZFR4SWRzLm1hcCgodHhJZCwgaWR4KSA9PiAoXG4gICAgICAgIDxFeHBsb3JlckxpbmsgdHhJZD17dHhJZH0ga2V5PXtpZHh9IC8+XG4gICAgICApKX1cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBVcGxvYWRMaXN0SXRlbTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFVwbG9hZCB9IGZyb20gXCIuL3VzZVVwbG9hZHNcIjtcbmltcG9ydCBVcGxvYWRMaXN0SXRlbSBmcm9tIFwiLi9VcGxvYWRMaXN0SXRlbVwiO1xuXG5pbnRlcmZhY2UgVXBsb2Fkc0xpc3RQcm9wcyB7XG4gIHVwbG9hZHM6IFVwbG9hZFtdO1xuICBvbkNvcHlUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBVcGxvYWRzTGlzdDogUmVhY3QuRkM8VXBsb2Fkc0xpc3RQcm9wcz4gPSAoeyB1cGxvYWRzLCBvbkNvcHlUZXh0IH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IG1iLThcIj5cbiAgICB7dXBsb2Fkcy5tYXAoKHVwbG9hZCwgaWR4KSA9PiAoXG4gICAgICA8VXBsb2FkTGlzdEl0ZW0ga2V5PXt1cGxvYWQuaWQgfHwgaWR4fSB1cGxvYWQ9e3VwbG9hZH0gb25Db3B5VGV4dD17b25Db3B5VGV4dH0gLz5cbiAgICApKX1cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBVcGxvYWRzTGlzdDtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIEZpbHRlck9wdGlvbiB7XG4gIGlkOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBVcGxvYWRzRmlsdGVyc1Byb3BzIHtcbiAgZGF0ZUZpbHRlcjogc3RyaW5nO1xuICBzZXREYXRlRmlsdGVyOiAodjogc3RyaW5nKSA9PiB2b2lkO1xuICB0eXBlRmlsdGVyOiBzdHJpbmc7XG4gIHNldFR5cGVGaWx0ZXI6ICh2OiBzdHJpbmcpID0+IHZvaWQ7XG4gIHNlYXJjaFF1ZXJ5OiBzdHJpbmc7XG4gIHNldFNlYXJjaFF1ZXJ5OiAodjogc3RyaW5nKSA9PiB2b2lkO1xuICBvblNlYXJjaDogKGU6IFJlYWN0LkZvcm1FdmVudCkgPT4gdm9pZDtcbiAgZGF0ZUZpbHRlck9wdGlvbnM6IEZpbHRlck9wdGlvbltdO1xuICB0eXBlRmlsdGVyT3B0aW9uczogRmlsdGVyT3B0aW9uW107XG4gIHZpZXdNb2RlOiBcImdyaWRcIiB8IFwibGlzdFwiO1xuICBzZXRWaWV3TW9kZTogKHY6IFwiZ3JpZFwiIHwgXCJsaXN0XCIpID0+IHZvaWQ7XG59XG5cbmNvbnN0IFVwbG9hZHNGaWx0ZXJzOiBSZWFjdC5GQzxVcGxvYWRzRmlsdGVyc1Byb3BzPiA9ICh7XG4gIGRhdGVGaWx0ZXIsXG4gIHNldERhdGVGaWx0ZXIsXG4gIHR5cGVGaWx0ZXIsXG4gIHNldFR5cGVGaWx0ZXIsXG4gIHNlYXJjaFF1ZXJ5LFxuICBzZXRTZWFyY2hRdWVyeSxcbiAgb25TZWFyY2gsXG4gIGRhdGVGaWx0ZXJPcHRpb25zLFxuICB0eXBlRmlsdGVyT3B0aW9ucyxcbiAgdmlld01vZGUsXG4gIHNldFZpZXdNb2RlLFxufSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTQgdy1mdWxsXCI+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciB3LWZ1bGwgZmxleC13cmFwIGdhcC04IGZvbnQtdGhpblwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBib3JkZXIgYm9yZGVyLXdoaXRlIHJvdW5kZWQtZnVsbCBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFZpZXdNb2RlKFwiZ3JpZFwiKX1cbiAgICAgICAgICBjbGFzc05hbWU9e2BwLTQgY3Vyc29yLXBvaW50ZXIgJHtcbiAgICAgICAgICAgIHZpZXdNb2RlID09PSBcImdyaWRcIiA/IFwiYmctW3JnYmEoMjU1LDI1NSwyNTUsMC4xNSldXCIgOiBcIlwiXG4gICAgICAgICAgfWB9XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIkdyaWQgdmlld1wiXG4gICAgICAgID5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgIHdpZHRoPVwiMTZcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMTZcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAxNiAxNlwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgZD1cIk0wLjg4ODg4OSA3LjExMTExSDYuMjIyMjJDNi40NTc5NyA3LjExMTExIDYuNjg0MDYgNy4wMTc0NiA2Ljg1MDc2IDYuODUwNzZDNy4wMTc0NiA2LjY4NDA2IDcuMTExMTEgNi40NTc5NyA3LjExMTExIDYuMjIyMjJWMC44ODg4ODlDNy4xMTExMSAwLjY1MzE0MSA3LjAxNzQ2IDAuNDI3MDQ4IDYuODUwNzYgMC4yNjAzNDlDNi42ODQwNiAwLjA5MzY1MDUgNi40NTc5NyAwIDYuMjIyMjIgMEgwLjg4ODg4OUMwLjY1MzE0MSAwIDAuNDI3MDQ4IDAuMDkzNjUwNSAwLjI2MDM0OSAwLjI2MDM0OUMwLjA5MzY1MDUgMC40MjcwNDggMCAwLjY1MzE0MSAwIDAuODg4ODg5VjYuMjIyMjJDMCA2LjQ1Nzk3IDAuMDkzNjUwNSA2LjY4NDA2IDAuMjYwMzQ5IDYuODUwNzZDMC40MjcwNDggNy4wMTc0NiAwLjY1MzE0MSA3LjExMTExIDAuODg4ODg5IDcuMTExMTFaTTkuNzc3NzggNy4xMTExMUgxNS4xMTExQzE1LjM0NjkgNy4xMTExMSAxNS41NzMgNy4wMTc0NiAxNS43Mzk3IDYuODUwNzZDMTUuOTA2NCA2LjY4NDA2IDE2IDYuNDU3OTcgMTYgNi4yMjIyMlYwLjg4ODg4OUMxNiAwLjY1MzE0MSAxNS45MDY0IDAuNDI3MDQ4IDE1LjczOTcgMC4yNjAzNDlDMTUuNTczIDAuMDkzNjUwNSAxNS4zNDY5IDAgMTUuMTExMSAwSDkuNzc3NzhDOS41NDIwMyAwIDkuMzE1OTQgMC4wOTM2NTA1IDkuMTQ5MjQgMC4yNjAzNDlDOC45ODI1NCAwLjQyNzA0OCA4Ljg4ODg5IDAuNjUzMTQxIDguODg4ODkgMC44ODg4ODlWNi4yMjIyMkM4Ljg4ODg5IDYuNDU3OTcgOC45ODI1NCA2LjY4NDA2IDkuMTQ5MjQgNi44NTA3NkM5LjMxNTk0IDcuMDE3NDYgOS41NDIwMyA3LjExMTExIDkuNzc3NzggNy4xMTExMVpNMC44ODg4ODkgMTZINi4yMjIyMkM2LjQ1Nzk3IDE2IDYuNjg0MDYgMTUuOTA2NCA2Ljg1MDc2IDE1LjczOTdDNy4wMTc0NiAxNS41NzMgNy4xMTExMSAxNS4zNDY5IDcuMTExMTEgMTUuMTExMVY5Ljc3Nzc4QzcuMTExMTEgOS41NDIwMyA3LjAxNzQ2IDkuMzE1OTQgNi44NTA3NiA5LjE0OTI0QzYuNjg0MDYgOC45ODI1NCA2LjQ1Nzk3IDguODg4ODkgNi4yMjIyMiA4Ljg4ODg5SDAuODg4ODg5QzAuNjUzMTQxIDguODg4ODkgMC40MjcwNDggOC45ODI1NCAwLjI2MDM0OSA5LjE0OTI0QzAuMDkzNjUwNSA5LjMxNTk0IDAgOS41NDIwMyAwIDkuNzc3NzhWMTUuMTExMUMwIDE1LjM0NjkgMC4wOTM2NTA1IDE1LjU3MyAwLjI2MDM0OSAxNS43Mzk3QzAuNDI3MDQ4IDE1LjkwNjQgMC42NTMxNDEgMTYgMC44ODg4ODkgMTZaTTkuNzc3NzggMTZIMTUuMTExMUMxNS4zNDY5IDE2IDE1LjU3MyAxNS45MDY0IDE1LjczOTcgMTUuNzM5N0MxNS45MDY0IDE1LjU3MyAxNiAxNS4zNDY5IDE2IDE1LjExMTFWOS43Nzc3OEMxNiA5LjU0MjAzIDE1LjkwNjQgOS4zMTU5NCAxNS43Mzk3IDkuMTQ5MjRDMTUuNTczIDguOTgyNTQgMTUuMzQ2OSA4Ljg4ODg5IDE1LjExMTEgOC44ODg4OUg5Ljc3Nzc4QzkuNTQyMDMgOC44ODg4OSA5LjMxNTk0IDguOTgyNTQgOS4xNDkyNCA5LjE0OTI0QzguOTgyNTQgOS4zMTU5NCA4Ljg4ODg5IDkuNTQyMDMgOC44ODg4OSA5Ljc3Nzc4VjE1LjExMTFDOC44ODg4OSAxNS4zNDY5IDguOTgyNTQgMTUuNTczIDkuMTQ5MjQgMTUuNzM5N0M5LjMxNTk0IDE1LjkwNjQgOS41NDIwMyAxNiA5Ljc3Nzc4IDE2WlwiXG4gICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFZpZXdNb2RlKFwibGlzdFwiKX1cbiAgICAgICAgICBjbGFzc05hbWU9e2BwLTQgY3Vyc29yLXBvaW50ZXIgJHtcbiAgICAgICAgICAgIHZpZXdNb2RlID09PSBcImxpc3RcIiA/IFwiYmctW3JnYmEoMjU1LDI1NSwyNTUsMC4xNSldXCIgOiBcIlwiXG4gICAgICAgICAgfWB9XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIkxpc3Qgdmlld1wiXG4gICAgICAgID5cbiAgICAgICAgICA8c3ZnIHdpZHRoPVwiMjBcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjAgMTZcIiBmaWxsPVwibm9uZVwiPlxuICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgZD1cIk0xLjczMzc5IDYuNEMwLjg0ODQ1NiA2LjQgMC4xMzM3ODkgNy4xMTQ2NyAwLjEzMzc4OSA4QzAuMTMzNzg5IDguODg1MzMgMC44NDg0NTYgOS42IDEuNzMzNzkgOS42QzIuNjE5MTIgOS42IDMuMzMzNzkgOC44ODUzMyAzLjMzMzc5IDhDMy4zMzM3OSA3LjExNDY3IDIuNjE5MTIgNi40IDEuNzMzNzkgNi40Wk0xLjczMzc5IDBDMC44NDg0NTYgMCAwLjEzMzc4OSAwLjcxNDY2NyAwLjEzMzc4OSAxLjZDMC4xMzM3ODkgMi40ODUzMyAwLjg0ODQ1NiAzLjIgMS43MzM3OSAzLjJDMi42MTkxMiAzLjIgMy4zMzM3OSAyLjQ4NTMzIDMuMzMzNzkgMS42QzMuMzMzNzkgMC43MTQ2NjcgMi42MTkxMiAwIDEuNzMzNzkgMFpNMS43MzM3OSAxMi44QzAuODQ4NDU2IDEyLjggMC4xMzM3ODkgMTMuNTI1MyAwLjEzMzc4OSAxNC40QzAuMTMzNzg5IDE1LjI3NDcgMC44NTkxMjIgMTYgMS43MzM3OSAxNkMyLjYwODQ2IDE2IDMuMzMzNzkgMTUuMjc0NyAzLjMzMzc5IDE0LjRDMy4zMzM3OSAxMy41MjUzIDIuNjE5MTIgMTIuOCAxLjczMzc5IDEyLjhaTTYuMDAwNDYgMTUuNDY2N0gxOC44MDA1QzE5LjM4NzEgMTUuNDY2NyAxOS44NjcxIDE0Ljk4NjcgMTkuODY3MSAxNC40QzE5Ljg2NzEgMTMuODEzMyAxOS4zODcxIDEzLjMzMzMgMTguODAwNSAxMy4zMzMzSDYuMDAwNDZDNS40MTM3OSAxMy4zMzMzIDQuOTMzNzkgMTMuODEzMyA0LjkzMzc5IDE0LjRDNC45MzM3OSAxNC45ODY3IDUuNDEzNzkgMTUuNDY2NyA2LjAwMDQ2IDE1LjQ2NjdaTTYuMDAwNDYgOS4wNjY2N0gxOC44MDA1QzE5LjM4NzEgOS4wNjY2NyAxOS44NjcxIDguNTg2NjcgMTkuODY3MSA4QzE5Ljg2NzEgNy40MTMzMyAxOS4zODcxIDYuOTMzMzMgMTguODAwNSA2LjkzMzMzSDYuMDAwNDZDNS40MTM3OSA2LjkzMzMzIDQuOTMzNzkgNy40MTMzMyA0LjkzMzc5IDhDNC45MzM3OSA4LjU4NjY3IDUuNDEzNzkgOS4wNjY2NyA2LjAwMDQ2IDkuMDY2NjdaTTQuOTMzNzkgMS42QzQuOTMzNzkgMi4xODY2NyA1LjQxMzc5IDIuNjY2NjcgNi4wMDA0NiAyLjY2NjY3SDE4LjgwMDVDMTkuMzg3MSAyLjY2NjY3IDE5Ljg2NzEgMi4xODY2NyAxOS44NjcxIDEuNkMxOS44NjcxIDEuMDEzMzMgMTkuMzg3MSAwLjUzMzMzMyAxOC44MDA1IDAuNTMzMzMzSDYuMDAwNDZDNS40MTM3OSAwLjUzMzMzMyA0LjkzMzc5IDEuMDEzMzMgNC45MzM3OSAxLjZaXCJcbiAgICAgICAgICAgICAgZmlsbD1cIndoaXRlXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmUgZmxleC1ncm93IG1heC13LW1kIG14LTJcIj5cbiAgICAgICAgPGZvcm0gb25TdWJtaXQ9e29uU2VhcmNofSBjbGFzc05hbWU9XCJmbGV4IHctZnVsbCByZWxhdGl2ZVwiPlxuICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgIHdpZHRoPVwiMTZcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMTZcIlxuICAgICAgICAgICAgdmlld0JveD1cIjAgMCAxNiAxNlwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBsZWZ0LTMgdG9wLTEvMiAtdHJhbnNsYXRlLXktMS8yXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBmaWxsLXJ1bGU9XCJldmVub2RkXCJcbiAgICAgICAgICAgICAgY2xpcC1ydWxlPVwiZXZlbm9kZFwiXG4gICAgICAgICAgICAgIGQ9XCJNMTMuODc1IDEyLjQ1NTRMMTcuODc1IDE2LjQ2MDJDMTguMDUzNiAxNi42NTg5IDE4LjA0NDggMTYuOTYzMSAxNy44NTUgMTcuMTUxMUwxNy4xNTUgMTcuODUxOUMxNy4wNjExIDE3Ljk0NjcgMTYuOTMzMyAxOCAxNi44IDE4QzE2LjY2NjcgMTggMTYuNTM4OSAxNy45NDY3IDE2LjQ0NSAxNy44NTE5TDEyLjQ0NSAxMy44NDcxQzEyLjMzNDQgMTMuNzM2MiAxMi4yMzQgMTMuNjE1NiAxMi4xNDUgMTMuNDg2N0wxMS4zOTUgMTIuNDg1NUMxMC4xNTQxIDEzLjQ3NzYgOC42MTMgMTQuMDE3OCA3LjAyNSAxNC4wMTczQzMuNzUyNjEgMTQuMDI4NyAwLjkwOTAyMSAxMS43Njg2IDAuMTc3NzMxIDguNTc1MUMtMC41NTM1NjkgNS4zODE2MSAxLjAyMjYgMi4xMDY5OSAzLjk3MzEgMC42ODk5MTJDNi45MjM1OSAtMC43MjcxNTggMTAuNDYxIDAuMDkxNTEyNyAxMi40OTEgMi42NjEyNUMxNC41MjEgNS4yMzA5OSAxNC41MDE5IDguODY2IDEyLjQ0NSAxMS40MTQyTDEzLjQ0NSAxMi4xMDVDMTMuNjAxMiAxMi4yMDUxIDEzLjc0NTQgMTIuMzIyNiAxMy44NzUgMTIuNDU1NFpNMi4wMjUgNy4wMDg5QzIuMDI1IDkuNzczNiA0LjI2MzU3IDEyLjAxNDkgNy4wMjUgMTIuMDE0OUM4LjM1MTEgMTIuMDE0OSA5LjYyMjkgMTEuNDg3NSAxMC41NjA1IDEwLjU0ODdDMTEuNDk4MiA5LjYwOTkgMTIuMDI1IDguMzM2NiAxMi4wMjUgNy4wMDg5QzEyLjAyNSA0LjI0NDEyIDkuNzg2NCAyLjAwMjg1IDcuMDI1IDIuMDAyODVDNC4yNjM1NyAyLjAwMjg1IDIuMDI1IDQuMjQ0MTIgMi4wMjUgNy4wMDg5WlwiXG4gICAgICAgICAgICAgIGZpbGw9XCJ3aGl0ZVwiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJTZWFyY2hcIlxuICAgICAgICAgICAgdmFsdWU9e3NlYXJjaFF1ZXJ5fVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRTZWFyY2hRdWVyeShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgcHktMiBweC00IHJvdW5kZWQtZnVsbCBiZy1bcmdiYSgyNTUsMjU1LDI1NSwwLjEpXSB0ZXh0LXdoaXRlIGJvcmRlciBib3JkZXItd2hpdGUgcGwtMTBcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvZm9ybT5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0yXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC13aGl0ZVwiPkZpbHRlciBieSBEYXRlPC9zcGFuPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgdmFsdWU9e2RhdGVGaWx0ZXJ9XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXREYXRlRmlsdGVyKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJweS0xIHB4LTMgcm91bmRlZC1mdWxsIGJnLVtyZ2JhKDI1NSwyNTUsMjU1LDAuMSldIHRleHQtd2hpdGUgYm9yZGVyIGJvcmRlci13aGl0ZVwiXG4gICAgICAgID5cbiAgICAgICAgICB7ZGF0ZUZpbHRlck9wdGlvbnMubWFwKChvcHRpb24pID0+IChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtvcHRpb24uaWR9IHZhbHVlPXtvcHRpb24uaWR9PlxuICAgICAgICAgICAgICB7b3B0aW9uLmxhYmVsfVxuICAgICAgICAgICAgPC9vcHRpb24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXdoaXRlXCI+RmlsdGVyIGJ5IFR5cGU8L3NwYW4+XG4gICAgICAgIHt0eXBlRmlsdGVyT3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gKFxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIGtleT17b3B0aW9uLmlkfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0VHlwZUZpbHRlcihvcHRpb24uaWQpfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgcHktMS41IHB4LTYgcm91bmRlZC1mdWxsIGJvcmRlciAke1xuICAgICAgICAgICAgICB0eXBlRmlsdGVyID09PSBvcHRpb24uaWRcbiAgICAgICAgICAgICAgICA/IFwiIWJnLVt2YXIoLS1jb2xvci1iZy1hY3RpdmUpXSAhdGV4dC1ibGFja1wiXG4gICAgICAgICAgICAgICAgOiBcImJnLXRyYW5zcGFyZW50IFwiXG4gICAgICAgICAgICB9IGJvcmRlci13aGl0ZSB0ZXh0LXdoaXRlIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBob3ZlcjpiZy1bdmFyKC0tY29sb3ItYmctaG92ZXIpXSBjdXJzb3ItcG9pbnRlcmB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge29wdGlvbi5sYWJlbH1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgKSl9XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4pO1xuXG5leHBvcnQgZGVmYXVsdCBVcGxvYWRzRmlsdGVycztcbiIsImltcG9ydCB7IFVwbG9hZCB9IGZyb20gXCIuL3VzZVVwbG9hZHNcIjtcblxuZXhwb3J0IGNvbnN0IG1vY2tVcGxvYWRzOiBVcGxvYWRbXSA9IFtcbiAge1xuICAgIGlkOiBcIjFcIixcbiAgICBuYW1lOiBcIkNoYXJ0IEltYWdlXCIsXG4gICAgZGF0ZVVwbG9hZGVkOiBcIjIwMjUtMDMtMTVUMTA6MzA6MDBaXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBjaGFydCBzaG93aW5nIGRhdGEgdmlzdWFsaXphdGlvblwiLFxuICAgIGZpbGVUeXBlOiBcInBuZ1wiLFxuICAgIGluZGV4aW5nVHhJZDogdW5kZWZpbmVkLFxuICAgIGluZGV4aW5nVHhTdWJtaXR0ZWRBdDogdW5kZWZpbmVkLFxuICAgIG9iamVjdERhdGE6XG4gICAgICBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUEra0FBQUlqQ0FZQUFBQi9PVm9aQUFBQU9uUkZXSFJUYjJaMGQyRnlaUUJOWVhSd2JHOTBiR2xpSUhabGNuTnBiMjR6TGpFd0xqRXNJR2gwZEhCek9pOHZiV0YwY0d4dmRHeHBZaTV2Y21jdmMyLys1UUFBQUFsd1NGbHpBQUFQWVFBQUQyRUJxRCtuYVFBQVdtbEpSRUZVZUp6dDNRbWMzUFA5UC9CUDdrTVNFWW1FQ0NIdSt5YW9vdzFSU3VtRkhrSmJXa1cxanBLMlJMUkZWZEZEMFFPOUhiK2kvNWFxaUp1NHFhdW9NNjRjam9qSXRjbk8vL0grcmxtem04M0tzYnZ6blpubjgvR1k3TTUzdmp2em1mbCtaakt2NytmcVZDZ1VDZ2tBQUFBb3U4N2xMZ0FBQUFEUVFFZ0hBQUNBbkJEU0FRQUFJQ2VFZEFBQUFNZ0pJUjBBQUFCeVFrZ0hBQUNBbkJEU0FRQUFJQ2VFZEFBQUFNZ0pJUjBBQUFCeVFrZ0hhR09kT25WS3A1MTJXcHZlNTJXWFhaYmQ3NHN2dnBqeTdDYy8rVWxhZSsyMVU1Y3VYZElXVzJ4Ujd1SkFFL0graWZkUnZKK3F4YTIzM3BvOXAvaTVwUHYrMy8vOVh5cUhTdmtjNitqUGQ0RG1oSFNnS2hXL0RDN3Vjczg5OTZROE91T01NOUsxMTE2Ykt0R05OOTZZdnZPZDc2U2RkdG9wWFhycHBkbHpXWnhERHoxMHNjZm1oaHR1U0xYazlkZGZUeWVmZkhMYWZmZmRVOSsrZlQ4MGNOMTk5OTFwNTUxM1RyMTc5MDVEaGd4SjMvem1OOU9zV2JNNnRNeDU5NWUvL0NXZGYvNzVxVmJWOHZOLzdiWFhzaEQ5eUNPUExQTjlYSC85OVlJNFVGWmR5L3Z3QU8zcjlOTlBUMnV0dGRZaTI5ZFpaNTJVUnhGc1AvT1p6NlQ5OTkrL3lmWXZmZWxMNmFDRERrbzlldlJJZVhYenpUZW56cDA3cDkvOTduZXBlL2Z1SDdwL1BKZmYvdmEzaTJ6ZmZQUE5VeTE1K3VtbjA0OS8vT08wN3JycnBrMDMzVFJObWpScHNmdEc4UGpZeHo2V050eHd3M1R1dWVlbVYxNTVKWjF6empucGYvLzdYL3JYdi83Vm9lWE9lMGg5L1BISDA3ZSs5YTBtMjlkY2M4MDBaODZjMUsxYnQxUXRkdGxsbCt3NWxiN25GdmY4YXlXa2p4OC9QZzBmUG55WmUvTkVTTC9nZ2d0YURPcnhXbmZ0NnVzejBMNTh5Z0JWN2VNZi8zamFacHR0VXFXTDd1Tnh5Yk5wMDZhbFhyMTZMVkZBRC9GRjk0dGYvR0txWk8rOTkxNWFZWVVWbHVzK3R0NTY2L1RtbTIrbUFRTUdaTjJRUC92Wnp5NTIzKzkrOTd0cHBaVld5bHJhKy9YcmwyMkxNSEw0NFlkblBSbjIzSFBQVkkxbXo1NmQ5UnhZWHRGTG9XZlBucW1heElteGFudE9lZWExQmpxQzd1NUF6YXFycTh1QzBXR0hIYmJJYlRObnpzeStqSjF3d2dsTlF1aFh2dktWTkhqdzRPeTJhUEg5L2U5Ly82R1BFMTI3STBnMUY2MDBFUnFLNHZjSWZYR2Z4YTdmOGJldGplWDgxYTkrbFRiZWVPT3NWWHExMVZaTFJ4MTFWSm94WTBhVGZYYmJiYmUweVNhYnBDZWZmRExyVWgxaForalFvZW5zczg5ZW90ZHB3WUlGNlFjLytFRWFNV0pFOWpqeFhDSXN6cHMzcjBuWm80dDdsTDlZOXZZYzkvdW5QLzBwQzdkeFVpQ09ZZlF5ZVBubGx4dHZQL3JvbzFPZlBuMnljTmZjd1FjZm5IVVRYN2h3WWVPMmFJWCt5RWMra2dYdTZISyt6ejc3cENlZWVLTEozOFd4aVB0ODdybm4wdDU3NzUzdDk0VXZmQ0dOR3pjdWE1bWRQbjM2SW85MXhCRkhwUDc5KzZlNWMrY3U5cm5FL2NSeitEQlJKeWRNbUpDZDJDZ0c5SERJSVlkazVicnl5aXMvOUQ1ZWV1bWx0TjkrKzJYUGM1VlZWa25mL3ZhMzA3Ly8vZThXdTlqZmUrKzlhYSs5OWtvcnJyaGlWbWQyM1hYWGROZGRkN1ZZaDU5OTl0bnM5WW5uR3Z2SGU2cWwxLzdEamx0cGZYM3d3UWV6VnVKNDdLaHY0ZTkvLzN0MmJLS3VSMTJNT2hsMXMvUll4dDlmZDkxMTJYTXQxc1hpKzI5eFk5S2pGMGp4K01keitPUW5QNW4rKzkvL0x2TnpqZU1VUXhKaW56ZzI2NisvZnVOeldKeFBmZXBUYWF1dHRtcXliZDk5OTgwZTgvLzl2Ly9YNUxqRXRtTFBpZVpqMGx0Ny9rWDE5ZlhwUnovNlVWcDk5ZFd6ejdMb25SSFA2OFBFZlg3akc5L0luazhjdzVWWFhqazdxZFRTR1BONC8zejBveC9OOW92SCtlRVBmNWc5Ym5OTGNreWIxNHNkZDl3eHU5L29KWFhSUlJjMTdoT3Z3YmJiYnB2OUhzZWwrV2ZSSFhmY2taVjNqVFhXeUI1cjJMQmgyWHNnV3NlTDR0aEdLM29vSFliVDJwajBoeDkrT0RzaEhPL0xPTjd4ZWpZZlVsWDhESS8zMEhISEhaY0dEUnFVMWJjRERqaWd4YzhPb0xacFNRZXEyanZ2dkpQZWVPT05KdHZpaTFKOHVZeGdGVitRcnI3NjZuVHh4UmMzYVFHT2NlRVJRaU5FaFBnU0YxOFM0NHRzQk1ENGNualZWVmRsWCtnaUZCOTc3TEhMWGRZLy92R1A2YXRmL1dyYWJydnRzbkFYNGd2cjRzUVh4ZWpXT1dyVXFIVGtrVWRtM2FZdnZQRENkUC85OTJkZkJFdTc5TDc5OXR0WjRJb2c4TG5QZlM1cnNUM3BwSk95N3RYeDViSTFVYVk0Y1JEZDhJOC8vdmdzSkp4NTVwbFppTG5tbW1zYXkvN3JYLzg2M1hmZmZZMWQyT09MOUlkcGZteWl6QkY4V2hQaDRwUlRUc21lUjVRdHZ1RCs0aGUveUFKZGZGbU9ZSFRnZ1FkbVg3UWpySlMyVEVlWStzYy8vcEVkdDJMUGhDajdtREZqMHVqUm83TnU1N0ZQdkk0UnN1TCtTZ05PbkxDSS9lSzI2R1llQVhMa3lKSFpzSW9ycnJnaXF4dEY4K2ZQejE3blQzLzYwMjNTK3ZiWVk0OWxqOSs4WjBqVTIraldHMlZ0VFp4QWlkQVVZK0NqdnNhSml1Z1dmY3N0dHl5eWI0VFdxQmNScU9Na1JMVFd4a21ZK1BzSU9sRkhTOFd4aVBkRTFJdUhIbm9vcXdOeEVpQmV6NlU1YmtYUnN5QWVQOTUvY1ZJaVRvd1ZnMDZFb0FnNThUUEtlZXFwcDJZbk1HTFN3dkM5NzMwdmU5L0hVSUR6empzdjJ4YjdMczVOTjkyVVBWWk1lQmp2cVhpdlI3bGlib1Y0THMwRDdvYzkxd2lubi9qRUo5Sm1tMjJXMVlzSWcvRzUwZndFUjNOeGtpQUNhenlYQ0h1RlFpSDdtM2p0NHpXUGt5c2hmbzl0VWI2V0xNbnpQK3VzczdMN2lKT1FzVytjc0lzVFR2SGViazE4dHNTY0NIRmNJbmhIT0kvM1NudzJ4a25BWW0rSEtWT21aQ2NFbzc3R2ZBc1JSdVB6SVlKMWMwdHlURXMveCtJRVdSeURPTmtXSjZiaXN5L2VBMS8rOHBlellTRHhtc2ZmeDJkb3ZLYWxuMFh4bVIzdjcvaWIrRDhnUHEvaVdNZHJGYmVGcjMzdGExbVgrVGpSRXA4Tkh5YU9kenhPSExPWWt5TSt3K0wvazNoTmJydnR0clQ5OXRzMzJmK1lZNDdKZXNQRSt5cGV2NWc3SUQ0MzR2TURvRkVCb0FwZGV1bWxoZmlJYStuU28wZVB4djMrL2U5L1o5dis4WTkvTlBuN3ZmZmV1N0QyMm1zM1hqLy8vUE96L2Y3MHB6ODFicHMvZjM1aDVNaVJoVDU5K2hSbXpwelp1RDMyR3pkdVhPUDFNV1BHRk5aY2M4MUZ5aGo3TlA4WVhtR0ZGYkw5Ri9kOFhuamhoZXo2dEduVEN0MjdkeS9zdWVlZWhZVUxGemJ1OTh0Zi9qTGI3NUpMTG1uY3R1dXV1MmJiL3ZDSFB6UnVtemR2WG1ISWtDR0ZUMy82MDYyK2pvODg4a2oydDEvOTZsZWJiRC9oaEJPeTdUZmZmSE9UNXhubFh4S3hiMHZISnNyYW1oZGZmTEhRcFV1WHdvOSs5S01tMng5NzdMRkMxNjVkRzdmWDE5Y1hoZzRkdXNqenUvTEtLN1BIdWYzMjI3UHI3Nzc3YnFGLy8vNkZ3dzgvdk1sK1U2Wk1LYXk0NG9wTnRoZkxmUExKSnk5U3JxZ0gyMisvZlpOdFYxOTlkYmIvTGJmY1VsaFNWMTExMVdML3BuaGJzZXlsUHZ2WnoyYkhzelUvL2VsUHM3Ky85dHByRzdmTm1UT25zTUVHR3pSNXpIanQxbDEzM2NMbzBhT3ozNHRtejU1ZFdHdXR0UXA3N0xISEluWDR5MS8rY3BQSE91Q0FBd29ycjd6eVVoKzMwdnA2MFVVWExmSWNvZ3pOZmUxclh5djA3dDI3TUhmdTNNWnQrK3l6VDR2dnVYai94SDNIKzZsb2l5MjJLS3l5eWlxRk45OThzM0hiZi83em4wTG56cDBMaHh4eXlGSS8xL1BPT3kvYmIvcjA2WVdsY2YvOTkyZC9kLzMxMTJmWEgzMzAwZXg2SE52U3VyWGZmdnNWdHR4eXk4YnJjZHlhMTVuRlBmL2l2aHR1dUdIMkdWRDBzNS85TE5zZXg2TTFMYjMra3laTld1VHo1VnZmK2xhMjdkNTc3MjNjRnA5WjhaNHEvUnhibW1OYXJCZFJqNHZpT1JTUFgzd2VsNzZPcGNlNHRjYzY4OHd6QzUwNmRTcTg5TkpMamR1T091cW9SVDZiRi9mNXZ2LysrMmVmeGM4OTkxemp0dGRlZTYzUXQyL2Z3aTY3N0xMSVovaW9VYU9hdksrKy9lMXZaKytOR1RObXRQaDRRRzNTM1Iyb2F0R2FHaTBpcFpmU0NiYWlaWERnd0lGTldqR2l0U2IyaTliWTBvbUVvdVV4V20rS29zV2tPTE4ydEpoMHBHajlpNWJhbUJncVdzU0tZbXh5dE9oRUMzS3BhS0VxSGY4ZExVL1JHdnI4ODgrMytqanh2RU8wY3BXS0Z2WFEvSEdXUnJRdU56ODJQLzNwVDF2OW0rajFFRjFtb3lVdFd1R0xsemcyTWZGYXNWVTRla3RFQzNxVXYzVG04empPMGRVL1dzSkRQR2IwaElqalducC8wY29lTFdBdHRUSkhLMXh6MGVVOFdpR2pLM3pSbi8vODU2dzdiWFFUYnd2Rkxya3RUUjRZcjJWcGw5Mld4S3o1OGR5TExiTEZ2NHM2MDN4eXVwaUk3dk9mLzN6V29sMThUYUlsUHJyeDNuNzc3WXQwVy83NjE3L2U1SHEwTE1iZlJtdm8waHkzb25pT0xRMURLVzJKZmZmZGQ3UDdpTWVLMXRHbm5ub3FMYTNvVlJEUE4zcFdsQTQ1aUZid1BmYllvN0grTDgxekxmWUlpRmJ4bHJwM0w4NldXMjZadlUvajlTMjJtRWRyZGRTdGFMR1A1eGdaOGM0NzcyeHNJVjVXOGRxVzlod3EzdCtIZlI2VXZ2NHhYQ2llZDB6Q0djODV5bGdVcjlzT08relFwTWRGZE8rTzF2cmxPYVl4ajBXMGRCZkZjNGpyTVJRcHVzRi9tTkxIaXZvY2p4V3Q3UEc2ZmxoUGxKWkVsL3lZQ3lJbStveWVHRVdycnJwcTl2NkpZMVdzRjBYUndsL2FmVDZlYTl4UERDVUFLTkxkSGFocThTV3h0WW5qNGt0ZmRFZU9ici9SdlQzQ1FRU0srQUphR3RMakMxU0VpZEpBSEtKN1pmSDJqbFI4dkJnYldpcSt0TWFYeGVibGlTLzdwVjhNUTNTNWZQVFJSei8wY2VJNU41OE5QOEpWZkRGZm51Y2RRVGk2NmkrTkNJL3hoVHFPUlV0S3Uvakg4WXV1cERHZU43NHdSMWlQOEJCZjZvdXZSZHhmOFdSTlMwckhmaGZyUzd5V3pjVmp4UW1UQ09iUjFUYTZFUC96bi8vTXhyczJmOTJYVlRGZ2xNNEZVQlJqM2x2cVNsd3FqbFVNbjJoZW51Ykh0dmlheEJDQXhZbm5GL1duS01iNGxpcmVGaWU4NGpWY211TVc0bVJDU3hNUVJ0Zmk3My8vKzFtWDZPYmhKOHJVVnUrajRuczd4dXMzbnh6d3c1NXIxSVhvQWg5ZCtxT3JkNXpZaUdFbU1WeWsrZWRIOC9kRERKMkljQjdpWndTNE9LRVVJUzdHT0VlMy83ZmVlbXU1UTNwcno2RTFjU0lvdXZuSDBJZFhYMzAxTzZZdHZmN3h1amJ2NXIyNDEzbHBqbW1NVzI4K1VlTjY2NjJYL1l5dTQzRmlvRFdUSjAvTzNwL3htZEQ4dVM1TC9Za2hHM0V5WVhIMUowN1N4SndMTVcvSThyNzJRRzBSMG9HYUYrTXJZd3hodExCSGkwaU1jOXhnZ3czYWJDbXd4WVcwNWhNanRhZkZ6UXhmK2lXN05XMFZOSmRYZk9rdFRwclYwbk1xSFhzYlg5aGpQSEVjendqcE1SWTlRa2JweVpkaVMyZU1QWTBURDgwMVgyb3BUdUswRkxUaWkzYU1ReTZHOUJpTEhtRzZMV2V2ajlhNVl1dHZjN0V0QWt4YktMNG1NUjU0Y1V0WU5SL2ovR0gxYTJtT1cyanBoRVAwZUloZUNSR0VZOXh4bkhDSW5nRFJnaHZ6S3l4TnEvWHkrTERuR21XUDF2RG9IUkE5VGFJSFEvVGdpQk5CMGVyYTJpb05FY2hqN0g2Y2RJbVFIdVBMNDJSWVRKZ1cxNHRqODVjM3BDL3I1MEdNcDQ2QUhpZWs0b1JDekI4Unh6VStRNWZsOWUvSVl4cWZ0OUU3SWs1eXhIM0haM3dFL2pqWkVEMHA4bEovQUlLUUR0UzhtTGdxQWxCOGtZNHZ5ZEdpRTErT202K3ZISzNPOFVXdU5LUVZ1MlBHN1lzVEFhNzVqT3VocFZib0pRM0R4Y2VMeWVKS3UxbEdGL2dYWG5oaHFWdW9XM3VjZU03UkVscnNOUkNtVHAyYVBhZldubmQ3aUMveDhXVTJKdTRxdHFDMUpycFgvK3huUDh0YTZPTDRSbWd2YlcwclRzd1hFMzh0NzJzVzNaSmpWdkNZWEN2Q2VuUmZMbTFCVzE0UjFPS2t3UU1QUEpBOXI5SmpIbDIyUzdlMUpJNVZUTzRWcjE5cFBXcytxM2Z4TlluZzFGYjFhR21QVzB0aTV1N29YaDA5WGVJOVd4VDF2UzNlUjgzRmV6dUd3aXpMRW52eEdSRXQ2SEdKOWV6UE9PT003RE1sZ250cnIybUU3emllZi8zclg3UHdXQXpqOFh5TElUMWV2MkpZNytpVGFuSHlLWHBZbEE1TGlSTUt6VC9mNG5VdDlzZ28xZngxWHBwakdtSkN0K1k5RzU1NTVwbnNaM0dDdjhVOTk1aDRNZmFOU1REanZWb1VRMTZXOWZXTEx2d3hXZDdpNmsvVWd4anlBckMwakVrSGFsNThrWXF1cU5IU0dpMnFNU054YVd0cmlCbUZZOGJpMHJIcnNWL01EQnl0Z0syTk80NkFFbDBwUzd1V1I4dG5jV2IwVXZIbHM2VkEzMXg4MFkvdXdELy8rYytidE1EODduZS95eDRybGpScUMvRzhRM1FiTHhYQkk3VFY0eXlwNkRZY0xWRXhxMzN6bHFlNEhsLzRTOFZ4akJidCtHSWVMWnJOZzJ6TTFCNWhORUpVREhGb2JtbVdSb29ad2lQVXhTemZNVWRCVzY4Qkg2MldjZHhqR2JNWXUxc1VkVGE2OHJlMnZucnh1VWJ3SzEzT0t3TFdiMzd6bXliN3hZenVVV2RqOXZyUzhmeEZ5N0pjMU5JZXQ5WmFJRXYvUGdKdExFUFkwdnRvU2Jvdng4bTU2QzBROWFQMGZmZjQ0NDlucmQ3RityODBvcVcydVdLUGhKYUdLcFNLTHVMUjlUL3FVSXlSTDU3a2liQWUzZDJqWGkxSksvcVNQditsRmNlZytmR0x6OERtdllMaWRZdnl4dXpwcGZVbVRsNDF2NzhsUGFiRno5em85VlM2YjF5UHNCejFOaFFEZlBQUDBaWWVLMzZQazNqTkxlNCttb3Y3M0hQUFBiUDVCMHFYb1l1VG1ER0VLazc2Tmg4eUE3QWt0S1FEVlMyNjE3WTBvVlJNRmxUYUFoMWhMcjVzeHJJNHNTeFphYXR4Y2JLZitESVkzU0pqZ3FKb3RZbFdwVmdpS1FKc3JIVzlPTkVWTkxwWHhuSnZNZEZjY1ltdmFCRXJuV3dweEJmTm1CUXVRbkIwWDQ2V3g1Ykdkc2FYMHJGangyYWhKNVpXaThuQW9qVW52dHpHT3NGdEZSQ2p5Myswbk1YeVNjV3VxZkhGTzBKTkRBMklaWlk2VW9USFdHODVubnQ4S1k0eXhHc2ZMVzl4MGlPT1UrbmE5ckh1ZEl5NWpsYk1DRWpOVDc3RUYrZzRGbC82MHBleWZlTll4V3NiWTFlanEzSXNjL1hMWC81eWljb1c0U3IrUHZhUEwrK2xrd3grbUhoT29iZzJld1R2bUhRcXhIamRvdWdLSFhVM2prTTgxMWc2S2xvMUl5aEVQV2hOak1XUHNrVzVZZ20yQ0tnUm1vckx3eFZiRCtPa1ZZeXBqcE1PRVJKamtyRVlJeDRCUDFxQzR6V0xFMXJ0ZWR4YUVzODdlcVZFZll6M1VaUTNYcWVXdWduSCt5aE9xTVdFaC9GK2lCTnBzZVo0UzZKYmZ6elg2TDc5bGE5OHBYRUp0amdwMG53OTdDVVIzYmFqdTN1Y3dJb1c1WmpVTE42WE1aZEJjY0xDeFlsVzJTaDdCTnppR3VraFdwbWpCVGt1U3hMU2wrYjVMNDBZMGhHdmVidzJHMjIwVVpvMGFWTDJlUlhMbVpXS3BjaGl2NmlUVWRlS1M3QVZleVF0eXpFTjhaa1lKekNpRHNYblp6ekg2RVVTOTEyYzF5RHFXZ3dSaVBYVG80N0ZZOGRuYUhSdmo5dWlua1Zkam5yOHQ3LzlyY1d4NE1YQUgyV0trMXZ4Zmk0dXg5bGMxT3Rvalk5akcydklSMitYK0w4aVBtOWlhVHVBWlZMdTZlVUJPbm9KdHBhVzU0a2xjWVlORzViZDlzTWYvckRGKzV3NmRXcmhzTU1PS3d3Y09EQmJjbWZUVFRkdGNabWY1a3YwaEJ0dnZMR3d5U2FiWkgrMy92cnJaMHU1dGJRRTIxTlBQWlV0MjlPclY2L3N0dUp5Yk0yWFlDdGRjaTJXME9yV3JWdGg4T0RCaFNPUFBMTHc5dHR2TjlrbmxpN2FlT09ORnlubjRwYUdhNjZ1cnE0d2Z2ejRiUG10ZUp4NG5jYU9IZHRrZWFSbFdZSnRTZmR0eWQvKzlyZkN6anZ2bk4xSFhPSTFpR1dUbm43NjZVWDIvZDczdnBlOWR1dXNzODVpN3krV3Bvb2x4MktKcUo0OWV4WkdqQmhST1BUUVF3c1BQUERBVXBYNXZ2dnV5eDRybHNaYkdxM1YxZWJ1dU9PT3dvNDc3cGlWYzlDZ1FkbnpMbDBDc0RYUFAvOTh0anhYMUsvNDIrT1BQejU3TGVOeDdybm5uaWI3UHZ6d3c0VlBmZXBUMmZKaXNXeGgxSlhQZmU1emhZa1RKemJ1VTZ6RHpaY2JXMXg5WFpManRyajZHdTY2NjY3Q0RqdnNrSlYvdGRWV0szem5POTlwWEVheGRBbXlXYk5tRlQ3LytjOW55K3ZGYmNWNjN0SVNiT0dtbTI0cTdMVFRUdG45OXV2WHI3RHZ2dnNXbm56eXlTYjdMT2x6amRmbms1LzhaRmErZUwvSHo0TVBQcmp3ekRQUEZKYkVpU2VlbU4zZmozLzg0eWJiby83Rzl0S2x2aGEzQk52aW5uOXgzMWpPcjlUaVhwZm00ck9sK0JrWVMwL0dleVkrcytMK215OGRHVXZJeGJHTWVockxJZjdnQno4by9PNTN2MXVrWGl6cE1TM1dpM2hQeHBLSGNiL3h1UEVaMk56Zi8vNzN3a1liYlpRdDcxZjZ2T0tZeGhKb1VmWjREckhFWWl5MzEveTVMMWl3b0hETU1jZGs3NUZZbnEzMGZkalM1L3RERHoyVXZSWnh2N0YwM082NzcxNjQrKzY3VzZ3bnNVVGNoeDAvZ0U3eHo3TEZld0NnMUgvKzg1K3NhL01mL3ZDSHJIVytFa1JQa0ppRlBscmxvOFVjOG1pMzNYYkxsa3lMb1FnQTFjNllkQUJvSXpHK083b1d4eGpzUEdxK2xucU1TWSt1dWJFMG1vQU9BUGxnVERvQUxLY1lveDB6cDhmWTJLT1BQbnFaWmdUdkNISHlJTlpwanRiK21GZ3NKcUdMT1J1YVQrZ0ZBSlNQa0E0QXl5bldqNDRabldOVzY1ak1MNjlpRXF5WUZDNUNlY3pJSFpOL1hYNzU1WXRNcUFjQWxJOHg2UUFBQUpBVHhxUURBQUJBVGdqcEFBQUFrQk0xTnlhOXZyNCt2ZmJhYTZsdjM3NnBVNmRPNVM0T0FBQUFWYTVRS0tSMzMzMDNyYmJhYXFsejU5YmJ5bXN1cEVkQUh6WnNXTG1MQVFBQVFJMTUrZVdYMCtxcnI5N3FQalVYMHFNRnZmamk5T3ZYTCtWVlhWMWR1dkhHRzlPZWUrNlp1blhyVnU3aXdDTFVVU3FCZWtyZXFhUGtuVHBLM3RWVlNCMmRPWE5tMWxoY3pLT3RxYm1RWHV6aUhnRTk3eUc5ZCsvZVdSbnpYTm1vWGVvb2xVQTlKZS9VVWZKT0hTWHY2aXFzamk3SmtHc1R4d0VBQUVCT0NPa0FBQUNRRTBJNkFBQUE1RVROalVrSEFBQ29GZ3NYTHN6R1pkZXF1cnE2MUxWcjF6UjM3dHpzdFNpbkdCUGZwVXVYNWI0ZklSMEFBS0FDelpvMUs3M3l5aXZaR3R5MXFsQW9wQ0ZEaG1TcmR5M0pwR3p0S1I0L2xsZnIwNmZQY3QyUGtBNEFBRkJob3RVNEFuck1iRDVvMEtDeUI5UnlxYSt2ejA1V1JERHUzTGx6V1U4V1RKOCtQVHNtNjY2NzduSzFxQXZwQUFBQUZkak5PNEpoQlBSZXZYcWxXbFZmWDUvbXo1K2ZldmJzV2RhUUh1Sll2UGppaTlteFdaNlFidUk0QUFDQUNsV3JMZWpWZkN5RWRBQUFBTWdKSVIwQUFBQnlRa2dIQUFDQW5CRFNBUUFBNkJDSEhucG9ObmE3K2VYWlo1OHRkOUZ5dyt6dUFBQUFkSmk5OXRvclhYcnBwWXZNakU0RExla0FBQUIwbUI0OWVxUWhRNFkwdVN4dXliTExMcnNzOWUvZlAvM3puLzlNNjYrL2ZyWXUvR2MrODVrMGUvYnM5UHZmL3o2dHZmYmFhZmp3NGVuWVk0L04xbzR2bWpkdlhqcmhoQlBTMEtGRDB3b3JySkMyMzM3N2RPdXR0emJlL3VhYmI2YUREejQ0dXozdWM5Tk5OMDEvL2V0Zm16ejJicnZ0bHI3NXpXK203M3puTzJuQWdBRlpPVTg3N2JSVUV5M3BGMXh3UWZySlQzNlNwa3laa2piZmZQUDBpMS84SW0yMzNYYUxQVWlISFhiWUlnZDU3dHk1SFZSYUFBQ0EvTmxtbTIyeVROWFJJcncrOE1BRDdYYi9zMmZQVGovLytjL1Q1WmRmbnQ1OTk5MzBxVTk5S2gxd3dBR040ZjN4eHg5UFk4YU1TVHZ2dkhNNjhNQURzNzg1K3VpajA1TlBQcG45eldxcnJaYXV1ZWFhckFYL3NjY2VTK3V1dTI2V0g3ZmVldXQwMGtrbnBYNzkrcVhycnJzdWZlbExYMG9qUm94b2trWGpSTUJ4eHgyWDdyMzMzalJwMHFTc3UvNU9PKzJVOXRoamorb042VmRjY1VYMnBDKzY2S0xzN01iNTU1K2ZSbzhlblo1Kyt1bTB5aXFydFBnMzhTTEc3VVhXQmdRQUFHcGRCUFJYWDMwMTVWMEU2ejU5K2pSZS8vakhQNTZ1dXVxcXhlNWZWMWVYTHJ6d3dpeEFoMmhKLytNZi81aW1UcDJhdFlLdnZ2cnFXYXYzTGJmY2tvWDB5Wk1uWjkzcDQyY0U5QkN0NmpmY2NFTzIvWXd6enNoYTBHTmIwVEhISEpQKy9lOS9weXV2dkxKSlNOOXNzODNTdUhIanN0OGozUC95bDc5TUV5ZE9yTzZRZnU2NTU2YkREeis4c1hVOHducWN4Ympra2t2U3lTZWYzT0xmUkNpUHN6VlZiZGFzMU9PdHQxSjYvZldVdW5WTEticC9EQnlZVW1jakZBQUFnRVdWS3lNdDdlUHV2dnZ1V2VndWl1N29yZW5kdTNkalFBK0RCdy9PdXJoSDBLK3ZyMi9jTm0zYXRPejNhQzJQcnUvcnJiZGVrL3VKTHZBcnI3eHk5bnZjSG1FOVFubWMySmcvZjM1MmV6eFdxUWpwcFZaZGRkWEd4Nm5La0I0dnhJTVBQcGpHamgzYnVLMXo1ODVwMUtoUldWZUN4WmsxYTFaYWM4MDFzd095MVZaYlpTL3V4aHR2M09LKzhVTEhwV2ptekptTloyUGlrbGNMSms5Ty9aOTlOdFgzN1pzV3ZEOCtveEFWYzhNTnkxMDB5QlRmUDNsK0g0RjZTdDZwbytTZE9wcGZjVXdLaFVLV2lZcEI5Yjc3N2l0YmVZcGwrREJSNWdqQ01aWjhTZjYrdnI0K2RldldiWkhiaTl2aS9vb051Ukc4WTF0a3Zoampmdi85OXk4eTFyMFk3TTgrKyt6MHM1LzlMR3MwanZIb2NhTGcyOS8rZHBZZFN4K3JhOWV1aXp4MjhYRmFLbXVVSjQ1Tjg4ZGRtdmRRV1VQNkcyKzhrVDNCT090UktxNC85ZFJUTGY1TlRCWVFyZXh4UnVPZGQ5NUo1NXh6VHRweHh4M1RFMDg4a1hWemFPN01NODlNNDhlUFgyVDdqVGZldU1oWmtqenBPWDE2NnQyM2I3cnYyV2RUNS9uelU1ZDU4OUxjRjE1STc3endRcm1MQmsxTW1EQ2gzRVdBRDZXZWtuZnFLSG1uanVaUGhNZG93WTRHekdqOHJCUVJWaGNzV05EWWVQcGg1czZkbXdYZjB2MGpTRWVPTE4xV2VyL1JMVDF1ZitHRkY3S3MyRnpzYzl0dHQyWGQ3UGZiYjcvR2dCMURxaU52RnU4MzdpOWUyOUxIaVczeFdDMlZQL2FkTTJkT3V2MzIyN1A5bW8rcnI1anU3a3RyNU1pUjJhVW9YdlFOTjl3d1hYenh4ZWtIUC9qQkl2dEhLMzJNZVMrS0YzUFlzR0ZwenozM3pNYTI1MVVjK1Bnd2pMRU8zVjUrT1hWNjhzbFVHRG8wcFMyM0xIZlJZTkU2R2tNeUlJZlVVL0pPSFNYdjFOSDhpdkQ2OHNzdlp5M0RQWHYyVEpVaTZsR2NZRmpTTE5helo4K3NsYngwLzVnNFBGcXFZMXNFK0poTXJ2UitvN2YxNXovLytYVFVVVWRsRTVSdnVlV1dhZnIwNmVubW0yL09XczMzMldlZkxFUCs3VzkveXlhZFcybWxsZEo1NTUyWDdSTTl0SXVQRmZmWHZYdjNKbzhkMitLeFdpcC9ISk5ldlhxbFhYYlpaWkZqc3FRbkpiTEhTR1UwY09EQTdNV05BZitsNHZxU2ptdUlGeWhlOUdlZmZiYkYyK01BeHFXbHY2dUVENXJHY25idDJuQ3BnREpUV3lybHZVUnRVMC9KTzNXVXZGTkg4eWRhaWlPOHhuRGh1RlNLS0hPeDNFdWk4L3Y3bGU1Zm5EZzh0cFYyT3krOTMxZ1Y3SWMvL0dFNjhjUVRzekhua1QxMzJHR0h0TysrKzJiN25ITEtLVmxMZTdTbVJ3L3JJNDQ0SXUyLy8vNVpiKzNtajlYOCt1TEtIOXZpdHBiZUwwdnovaWxyU0krekVqSHRmY3lPRnk5SWlCYzVyc2VVK1V0YU9XTmlnTDMzM3J1ZFN3c0FBTUR5aVBDOE5BNDk5TkRzVWlyV0ttKytYbm5NMmw0YW5DTVV4N0RubG9ZK2gxajMvTnBycjIzMXNVdlhWUy82c0w5cEMyWHY3aDVkMFdOTnUxalRMNmE2anlYWTNudnZ2Y2JaM2c4NTVKQnNldndZV3g1T1AvMzA3QXpJT3V1c2syYk1tSkYxWDNqcHBaZlNWNy82MVZTMWlrdk12VDhwQWdBQUFOV3A3Q0U5MXJHTHZ2K25ubnBxdHE3ZkZsdHNrYTFmVjV4TUx0YTJLejBqOHZiYmIyZEx0c1crTVhZZ1d1THZ2dnZ1dE5GR0c1WHhXUUFBQUVBVmhQUVFYZHNYMTcyOWVSZURHTkFmbDVxaUpSMEFBS0FtVk00TUF3QUFBRkRsaEhRQUFJQUtGVXVRVVYzSFFraXZCTHE3QXdBQUpXSXA2ekIvL3Z4eUY0WDNGWTlGOGRoVTlKaDBBQUFBbGx6WHJsMno5YjFqRXU1WWJxeVMxa3B2Uy9YMTlWazRuanQzYmxsZmd5aEhISXM0Sm5Gc2xvZVFEZ0FBVUdFNmRlcVVWbDExMWZUQ0N5OWtTMUxYY2hmek9YUG1wRjY5ZW1XdlNUbkZTWUkxMWxoanVjc2hwRmVDTWxjMkFBQWdmN3AzNzU3V1hYZmRtdTd5WGxkWGwyNi8vZmEweXk2N1pEMEt5bjA4MnFJMVgwaXZKTWFrQXdBQUpTSVU5dXpaTTlXcUxsMjZwQVVMRm1TdlFibERlbHVwellFTEFBQUFrRU5DZWlVd3V6c0FBRUJORU5JQkFBQWdKNFIwQUFBQXlBa2h2UkxvN2c0QUFGQVRoSFFBQUFESUNTRWRBQUFBY2tKSXJ3UzZ1d01BQU5RRUlSMEFBQUJ5UWtnSEFBQ0FuQkRTSzRIdTdnQUFBRFZCU0FjQUFJQ2NFTklCQUFBZ0o0VDBTcUM3T3dBQVFFMFEwZ0VBQUNBbmhQUktha2tIQUFDZ3FnbnBsVVIzZHdBQWdLb21wQU1BQUVCT0NPa0FBQUNRRTBKNkpUQzdPd0FBUUUwUTBnRUFBQ0FuaFBSS29pVWRBQUNncWducGxjQVNiQUFBQURWQlNBY0FBSUNjRU5JcmdZbmpBQUFBYW9LUURnQUFBRGtocEFNQUFFQk9DT2tBQUFDUUUwSjZKVEFtSFFBQW9DWUk2UUFBQUpBVFFub2wwSklPQUFCUUU0UjBBQUFBeUFraEhRQUFBSEpDU0s4RXVyc0RBQURVQkNFZEFBQUFja0pJQndBQWdKd1EwaXVKN3U0QUFBQlZUVWl2cERIcEFBQUFWRFVoSFFBQUFISkNTSzhFWm5jSEFBQ29DVUk2QUFBQTVJU1FEZ0FBQURraHBGY0MzZDBCQUFCcWdwQU9BQUFBT1NHa1Z3SkxzQUVBQU5RRUliMlM2TzRPQUFCUTFZUjBBQUFBeUFraEhRQUFBSEpDU0s4RVpuY0hBQUNvQ1VJNkFBQUE1SVNRRGdBQUFEa2hwRmNDM2QwQkFBQnFncEFPQUFBQU9TR2tWMUpMT2dBQUFGVk5TSzhrdXJzREFBQlVOU0VkQUFBQWNrSklCd0FBZ0p3UTBpdUIyZDBCQUFCcWdwQU9BQUFBT1NHa1Z3SXQ2UUFBQURWQlNBY0FBSUNjNkZydUFyQVVvaVg5MldjYmZoOHdvT0VDQUFCQTFSRFNLMEdYTGgrRTlQLyt0K0gzcmwxVDJtdXZEN3JDQXdBQVVQR0U5RXJRdlh0S20yNmEwb3daS2RYWHAvVHFxeWt0V05BUTJvVjBBQUNBcWlHa1Y0cmh3eHQrUmppUGtBNEFBRURWTVhGY0pUUGJPd0FBUUZYSlJVaS80SUlMMHZEaHcxUFBuajNUOXR0dm4rNjc3NzRsK3J2TEw3ODhkZXJVS2UyLy8vNnBadWplRGdBQVVMWEtIdEt2dU9LS2ROeHh4NlZ4NDhhbGh4NTZLRzIrK2VacDlPalJhZHEwYWEzKzNZc3Z2cGhPT09HRTlKR1BmQ1RWTEMzcEFBQUFWYVhzSWYzY2M4OU5oeDkrZURyc3NNUFNSaHR0bEM2NjZLTFV1M2Z2ZE1rbGx5ejJieFl1WEppKzhJVXZwUEhqeDZlMTExNDcxUlF0NlFBQUFGV3JyQlBIelo4L1B6MzQ0SU5wN05peGpkczZkKzZjUm8wYWxTWk5tclRZdnp2OTlOUFRLcXVza3I3eWxhK2tPKzY0bzlYSG1EZHZYbllwbWpselp2YXpycTR1dStSVnNXeUxsTEcrUG5XS3llT2lJWDMrZkszcDVLK09RbzZvcCtTZE9rcmVxYVBrWFYyRjFOR2xLVjlaUS9vYmI3eVJ0WW9QSGp5NHlmYTQvdFJUVDdYNE4zZmVlV2Y2M2U5K2x4NTU1SkVsZW93enp6d3phM0Z2N3NZYmI4eGE3UE51d29RSlRUZlUxNmZCRHp5US9UcXR2ajRWWXIxMHlGTWRoUnhTVDhrN2RaUzhVMGZKdXdrNXI2T3paODllNG4wckt1RzkrKzY3NlV0ZitsTDZ6Vzkra3dZT0hMaEVmeE90OURIbXZiUWxmZGl3WVduUFBmZE0vZnIxUzNrKzB4SVZiWTg5OWtqZHVuWDc0SVpDSVJVN3ZCZEdqMDZwOURiSVF4MkZIRkZQeVR0MWxMeFRSOG03dWdxcG84VWUzYmtQNlJHMHUzVHBrcVpPbmRwa2Uxd2ZNbVRJSXZzLzk5eHoyWVJ4Kys2N2IrTzIrdnI2N0dmWHJsM1QwMDgvblVhTUdOSGtiM3IwNkpGZG1vc0RtT2VEdU5oeVJ2ZjJZdXQ1L0t5QTUwQjFxNVQzRXJWTlBTWHYxRkh5VGgwbDc3cmx2STR1VGRuS09uRmM5KzdkMDlaYmI1MG1UcHpZSkhUSDlaRWpSeTZ5L3dZYmJKQWVlK3l4ckt0NzhiTGZmdnVsM1hmZlBmczlXc2lybm9uakFBQUFxbGJadTd0SFYvUXhZOGFrYmJiWkptMjMzWGJwL1BQUFQrKzk5MTQyMjNzNDVKQkQwdENoUTdPeDViR08raWFiYk5MazcvdjM3NS85Ykw2OUpwZzBEZ0FBb0txVVBhUWZlT0NCYWZyMDZlblVVMDlOVTZaTVNWdHNzVVc2NFlZYkdpZVRteng1Y2piak93QUFBRlM3c29mMGNQVFJSMmVYbHR4NjY2MnQvdTFsbDEyV2FrNTBlWTlXZEMzcEFBQUFWVVVUTlFBQUFPU0VrRjZKVEI0SEFBQlFsWVQwU3FhN093QUFRRlVSMGdFQUFDQW5oUFJLN3U2dUpSMEFBS0NxQ09rQUFBQ1FFMEo2SmRLU0RnQUFVSldFZEFBQUFNZ0pJUjBBQUFCeVFraXZSTHE3QXdBQVZDVWhIUUFBQUhKQ1NBY0FBSUNjRU5JcmtlN3VBQUFBVlVsSUJ3QUFnSndRMGl1UmxuUUFBSUNxSktRREFBQkFUZ2pwbGR5U0RnQUFRRlVSMGl1Wjd1NEFBQUJWUlVnSEFBQ0FuQkRTSzVHSjR3QUFBS3FTa0E0QUFBQTVJYVJYSWkzcEFBQUFWVWxJQndBQWdKd1EwaXVSbG5RQUFJQ3FKS1FEQUFCQVRnanBBQUFBa0JOQ2VpWFMzUjBBQUtBcUNla0FBQUNRRTBKNkpkS1NEZ0FBVUpXRWRBQUFBTWdKSWIwU2FVa0hBQUNvU2tJNkFBQUE1SVNRRGdBQUFEa2hwRmNpM2QwQkFBQ3FrcEFPQUFBQU9TR2tWekl0NlFBQUFGVkZTSy9rN3U0QUFBQlVGU0VkQUFBQWNrSklyMFFtamdNQUFLaEtRam9BQUFEa2hKQmVpWXhKQndBQXFFcENlaVhUM1IwQUFLQ3FDT2tBQUFDUUUwSjZKVEp4SEFBQVFGVVMwZ0VBQUNBbmhQUktwQ1VkQUFDZ0tnbnBBQUFBa0JOZHkxMEFscU1sL2ZublU1b3lKYVh1M1ZQYVlJT1V1blVyZDhrQUFBQllEa0o2SllwUUhtYk1hTGlFL3YxVEdqYXNyTVVDQUFCZytRanBsV2pqalZOYWVlV0dNZWt2dlpUU3pKa3BMVnhZN2xJQkFBQ3duSVQwU3RTalIwcHJydG53KzV0dk5vUjBBQUFBS3A2SjQ2cUZtZDRCQUFBcW5wQmU2U3pIQmdBQVVEV0VkQUFBQU1nSkliMWFXdElCQUFDb2VFSjZ0ZERkSFFBQW9PSUo2WlZPU3pvQUFFRFZFTktyaFpaMEFBQ0FpaWVrVnpxenV3TUFBRlFOSVIwQUFBQnlRa2l2ZE1ha0F3QUFWQTBodlZybzdnNEFBRkR4aFBSS1owdzZBQUJBMVJEU0FRQUFJQ2VFOUVxbkpSMEFBS0JxQ09tVnpzUnhBQUFBVlVOSUJ3QUFnSndRMHF1Rjd1NEFBQUFWVDBpdmRNYWtBd0FBVkEwaEhRQUFBSEpDU0s5MFd0SUJBQUNxaHBCZTZjenVEZ0FBVURXRWRBQUFBTWlKWElUMEN5NjRJQTBmUGp6MTdOa3piYi85OXVtKysrNWI3TDVYWDMxMTJtYWJiVkwvL3YzVENpdXNrTGJZWW92MHh6LytzVVBMbTB1NnV3TUFBRlM4c29mMEs2NjRJaDEzM0hGcDNMaHg2YUdISGtxYmI3NTVHajE2ZEpvMmJWcUwrdzhZTUNCOTczdmZTNU1tVFVxUFB2cG9PdXl3dzdMTHYvLzk3MVNUakVrSEFBQ29HbVVQNmVlZWUyNDYvUEREczZDOTBVWWJwWXN1dWlqMTd0MDdYWExKSlMzdXY5dHV1NlVERGpnZ2JiamhobW5FaUJIcDJHT1BUWnR0dGxtNjg4NDdPN3pzQUFBQTBKYTZwakthUDM5K2V2REJCOVBZc1dNYnQzWHUzRG1OR2pVcWF5bi9NSVZDSWQxODg4M3A2YWVmVGovKzhZOWIzR2ZldkhuWnBXam16Sm5aejdxNnV1eVNWOFd5ZldnWkZ5eEluUllzU0lYNTgyUG5qaWtjTEUwZGhUSlNUOGs3ZFpTOFUwZkp1N29LcWFOTFU3NnlodlEzM25nakxWeTRNQTBlUExqSjlyaisxRk5QTGZidjNubm5uVFIwNk5Bc2ZIZnAwaVg5NmxlL1NudnNzVWVMKzU1NTVwbHAvUGp4aTJ5LzhjWWJzeGI3dkpzd1lVS3J0Ni93Mm11cHp5dXZwRG1USjZlWnI3elNZZVdDSmEyamtBZnFLWG1uanBKMzZpaDVOeUhuZFhUMjdObVZFZEtYVmQrK2ZkTWpqenlTWnMyYWxTWk9uSmlOYVY5NzdiV3pydkROUlN0OTNGN2FrajVzMkxDMDU1NTdwbjc5K3FVOG4ybUppaFluSDdwMTY3YjRIZi8zdjlUcDZhZFRZZGl3bERiZnZDT0xTSTFiNGpvS1phU2VrbmZxS0htbmpwSjNkUlZTUjRzOXVuTWYwZ2NPSEppMWhFK2RPclhKOXJnK1pNaVF4ZjVkZElsZlo1MTFzdDlqZHZmLy92ZS9XWXQ1U3lHOVI0OGUyYVc1T0lCNVBvaExYTTY0cld2WGhwOFY4SHlvUHBYeVhxSzJxYWZrblRwSzNxbWo1RjIzbk5mUnBTbGJXU2VPNjk2OWU5cDY2NjJ6MXZDaSt2cjY3UHJJa1NPWCtIN2liMHJIbmRjVXM3c0RBQUJVamJKM2Q0K3U2R1BHak1uV1B0OXV1KzNTK2VlZm45NTc3NzFzdHZkd3lDR0haT1BQbzZVOHhNL1lOMloyajJCKy9mWFhaK3VrWDNqaGhhbW1Rem9BQUFBVnIrd2gvY0FERDB6VHAwOVBwNTU2YXBveVpVcldmZjJHRzI1b25FeHU4dVRKV2ZmMm9nanczL2pHTjlJcnI3eVNldlhxbFRiWVlJUDBwei85S2J1Zm1xWWxIUUFBb09LVlBhU0hvNDgrT3J1MDVOWmJiMjF5L1ljLy9HRjI0WDFhMGdFQUFLcEdXY2VrMDRhMHBBTUFBRlE4SVIwQUFBQnlRa2l2ZEdaM0J3QUFxQnBDZXFVekpoMEFBS0JxQ09uVlFrczZBQUJBeFJQU0s1MldkQUFBZ0tvaHBGY0xMZWtBQUFBVlQwaXZkRnJTQVFBQXFvYVFYaTIwcEFNQUFGUThJYjNTYVVrSEFBQ29Ha0o2dGRDU0RnQUFVUEdFOUVxbkpSMEFBS0MyUS9wenp6Mlh2di85NzZlRER6NDRUWnMyTGR2MnIzLzlLejN4eEJOdFhUNldsSlowQUFDQTJndnB0OTEyVzlwMDAwM1R2ZmZlbTY2Kyt1bzBhOWFzYlB0Ly92T2ZORzdjdVBZb0k2M1JrZzRBQUZDN0lmM2trMDlPUC96aEQ5T0VDUk5TOSs3ZEc3ZC85S01mVGZmY2MwOWJsNDhsTlhkdVNxKzhrdEtycjZZMGYzNjVTd01BQU1BeTZMcTBmL0RZWTQrbHYvemxMNHRzWDJXVlZkSWJiN3l4TEdWZ2VYUisvenpMdSsrbTlQREREYjhQSHB6U2R0dVZ0VmdBQUFCMFFFdDYvLzc5MCt1dnY3N0k5b2NmZmpnTkhUcDBHWXJBY2hrMEtLVmh3eHArcnJqaUI2M3FBQUFBVkg5SVAraWdnOUpKSjUyVXBreVpranAxNnBUcTYrdlRYWGZkbFU0NDRZUjB5Q0dIdEU4cFdieXVYVlBhWW91VWR0Z2hwUTAzTEhkcEFBQUE2TWlRZnNZWlo2UU5OdGdnRFJzMkxKczBicU9OTmtxNzdMSkwybkhISGJNWjM4a0JNNzBEQUFEVXhwajBtQ3p1TjcvNVRUcmxsRlBTNDQ4L25nWDFMYmZjTXEyNzdycnRVMEtXbkpuZUFRQUFhaXVrRjYyeHhoclpoUnpTa2c0QUFGQWJJZjNMWC81eXE3ZGZjc2tseTFNZTJxSWxYVWdIQUFDb2paRCs5dHR2TjdsZVYxZVhkWHVmTVdOR3RsWTZaU1NrQXdBQTFGWkl2K2FhYXhiWkZqTzhIM25ra1duRWlCRnRWUzRBQUFDb09aM2I1RTQ2ZDA3SEhYZGNPdSs4ODlyaTdsaFdXdElCQUFBcVdwdUU5UERjYzgrbEJRc1d0Tlhkc1N6TTdnNEFBRkJiM2QyanhieFVvVkJJcjcvK2VycnV1dXZTbURGajJySnNMQ3N0NlFBQUFMVVIwaDkrK09GRnVyb1BHalFvL2ZTblAvM1FtZDlwWjdxN0F3QUExRlpJditXV1c5cW5KQ3cvM2QwQkFBQXFXcHVOU1NkSHRLUURBQUJVYjB2NmxsdHVtVG90WVN2dFF3ODl0THhsWWxscFNRY0FBS2ora0w3Ly92dTNmMGxvTzFyU0FRQUFxamVranhzM3J2MUx3dkl6Y1J3QUFFQkZNeWE5bXVqdURnQUFVRnV6dXk5Y3VEQ2RkOTU1NmNvcnIweVRKMDlPOCtmUGIzTDdXMis5MVpibFkxbG9TUWNBQUtpTmx2VHg0OGVuYzg4OU54MTQ0SUhwblhmZVNjY2RkMXo2MUtjK2xhMlhmdHBwcDdWUEtWa3lXdElCQUFCcUs2VC8rYzkvVHIvNXpXL1M4Y2NmbjdwMjdab09QdmpnOU52Zi9qYWRldXFwNlo1NzdtbWZVckowdEtRREFBRFVSa2lmTW1WSzJuVFRUYlBmKy9UcGs3V21oMDk4NGhQcHV1dXVhL3NTc3VSTUhBY0FBRkJiSVgzMTFWZFByNy8rZXZiN2lCRWowbzAzM3BqOWZ2Lzk5NmNlUFhxMGZRbFpjcnE3QXdBQTFGWklQK0NBQTlMRWlST3ozNDg1NXBoMHlpbW5wSFhYWFRjZGNzZ2g2Y3RmL25KN2xKR2xwU1VkQUFDZ05tWjNQK3Vzc3hwL2o4bmoxbHh6elhUMzNYZG5RWDNmZmZkdDYvS3hOSFIzQndBQXFLMlFQbmZ1M05Telo4L0c2enZzc0VOMkFRQUFBRHE0dS9zcXE2eVN4b3daa3laTW1KRHE2K3ZicDFRcy81aDByZWtBQUFEVkg5Si8vL3ZmcDltelo2ZFBmdktUYWVqUW9lbGIzL3BXZXVDQkI5cW5kQ3dkRThjQkFBRFUzc1J4VjExMVZabzZkV282NDR3ejBwTlBQcGwxZDE5dnZmWFM2YWVmM2o2bFpPbHBTUWNBQUtqK2tGN1V0Mi9mZE5oaGgyVkxzRDM2NktOcGhSVldTT1BIajIvYjByRjB0S1FEQUFEVVpraVBDZVN1dlBMS3RQLysrNmV0dHRvcXZmWFdXK25FRTA5czI5S3hkSXhKQndBQXFLM1ozZi85NzMrbnYvemxMK25hYTY5TlhidDJUWi81ekdleTF2UmRkdG1sZlVySXNoSFNBUUFBcWora3g1ajBUM3ppRStrUGYvaEQybnZ2dlZPM2J0M2FwMlFzUGQzZEFRQUFhaXVreDRSeE1SNmRuTk9TRGdBQVVQMWowZ1gwSE5PU0RnQUFVSnNUeDVGREpvNERBQUNvYUVKNnRSTFNBUUFBS282UVhtMTBlUWNBQUtqK2tQNzg4OCtuZ3RiWnl1RllBUUFBVkc5SVgzZmRkZFAwNmRNYnJ4OTQ0SUhaVE8va2pKWjBBQUNBNmcvcHpWdlJyNy8rK3ZUZWUrKzFSNWxvQ3krK0dOMGZVcG8ycmR3bEFRQUFvTDNXU1NmbnVuUkpxYjQrcGYvOTc0TnRvMGFsMUt0WE9Vc0ZBQUJBVzdha2QrclVLYnMwMzBiT2JMNTVTcXV2M25EcC9QN2hyYXNyZDZrQUFBQm95NWIwNk81KzZLR0hwaDQ5ZW1UWDU4NmRtNzcrOWErbkZWWllvY2wrVjE5OTlaTGVKZTFoMVZVYkx1R05OK0pBbVVRT0FBQ2cya0w2bURGam1sei80aGUvMkI3bG9TMFZlem9JNlFBQUFOVVYwaSs5OU5MMkxRbnRSMGdIQUFDb3JqSHBWQ0J6QmdBQUFGUVVJYjJhNmU0T0FBQlFVWVQwYWlha0F3QUFWQlFodlpvSjZRQUFBQlZGU0FjQUFJQ2NFTktybVpaMEFBQ0FpaUtrVnpNaEhRQUFvS0lJNmRWTVNBY0FBS2dvUWpvQUFBRGtoSkJlemJTa0F3QUFWQlFodlpvSjZRQUFBQlVsRnlIOWdnc3VTTU9IRDA4OWUvWk0yMisvZmJydnZ2c1d1Kzl2ZnZPYjlKR1BmQ1N0dE5KSzJXWFVxRkd0N2wvVGhIUUFBSUNLVXZhUWZzVVZWNlRqampzdWpSczNMajMwMEVOcDg4MDNUNk5IajA3VHBrMXJjZjliYjcwMUhYend3ZW1XVzI1Smt5Wk5Tc09HRFV0NzdybG5ldlhWVnp1ODdCVkRTQWNBQUtnSVpRL3A1NTU3YmpyODhNUFRZWWNkbGpiYWFLTjAwVVVYcGQ2OWU2ZExMcm1reGYzLy9PYy9wMjk4NHh0cGl5MjJTQnRzc0VINjdXOS9tK3JyNjlQRWlSTTd2T3dWMDVJT0FBQkFSZWhhemdlZlAzOStldkRCQjlQWXNXTWJ0M1h1M0RucndoNnQ1RXRpOXV6WnFhNnVMZzBZTUtERjIrZk5tNWRkaW1iT25KbjlqTCtKUzE0Vnk3WThaZXkwY0dGS0N4YWt3dno1Y1VkdFdEcG9tem9LN1UwOUplL1VVZkpPSFNYdjZpcWtqaTVOK2NvYTB0OTQ0NDIwY09IQ05Ianc0Q2JiNC9wVFR6MjFSUGR4MGtrbnBkVldXeTBMOWkwNTg4d3owL2p4NHhmWmZ1T05OMll0OW5rM1ljS0VaZjdibFo1NUpuV2ZNU085OCthYmFlNmdRVzFhTG1pTE9nb2RSVDBsNzlSUjhrNGRKZThtNUx5T1J1TnlSWVQwNVhYV1dXZWx5eSsvUEJ1bkhwUE90U1JhNldQTWUybExlbkVjZTc5Ky9WS2V6N1JFUmR0amp6MVN0MjdkbHVrK09nMGNtTkswYWFtdzJXWXByYkZHbTVlUjJ0WVdkUlRhbTNwSzNxbWo1SjA2U3Q3VlZVZ2RMZmJvem4xSUh6aHdZT3JTcFV1YU9uVnFrKzF4ZmNpUUlhMys3VG5ubkpPRjlKdHV1aWx0RmlGME1YcjA2SkZkbW9zRG1PZUQyQ2JsakwvcjJyWGhad1U4VnlwVHBieVhxRzNxS1htbmpwSjM2aWg1MXkzbmRYUnB5bGJXaWVPNmQrK2V0dDU2NnlhVHZoVW5nUnM1Y3VSaS8rN3NzODlPUC9qQkQ5SU5OOXlRdHRsbW13NHFiUVd5QkJzQUFFQkZLWHQzOStpS1BtYk1tQ3hzYjdmZGR1bjg4ODlQNzczM1hqYmJlempra0VQUzBLRkRzN0hsNGNjLy9uRTY5ZFJUMDEvKzhwZHNiZlVwVTZaazIvdjA2Wk5kS0NHa0F3QUFWSlN5aC9RRER6d3dUWjgrUFF2ZUViaGphYlZvSVM5T0pqZDU4dVJzeHZlaUN5KzhNSnNWL2pPZitVeVQrNGwxMWs4NzdiUU9MMyt1Q2VrQUFBQVZwZXdoUFJ4OTlOSFpwU1V4S1Z5cEYxOThzWU5LQlFBQUFCMnJyR1BTYVdkYTBnRUFBQ3FLa0Y3TmhIUUFBSUNLSXFSWE15RWRBQUNnb2dqcEFBQUFrQk5DZWpYVGtnNEFBRkJSaFBScUpxUURBQUJVRkNHOUZrTDZuRGtwelppUjBxeFo1UzRSQUFBQWVWOG5uWFlPNlpNbk4xekNacHVsdE9hYVpTMFdBQUFBTGRPU1hzMVdXeTJsUG4xUzZ0VXJwYTd2bjQ5NTk5MXlsd29BQUlERjBKSmV6UVlNU0duMzNSdCtmL3JwbEo1NXh2aDBBQUNBSE5PU1hpdE1JZ2NBQUpCN1FucXRFTklCQUFCeVQwaXZOVUk2QUFCQWJnbnB0VUpMT2dBQVFPNEo2YldpOC91SFdrZ0hBQURJTFNHOTFnanBBQUFBdVNXazF3cmQzUUVBQUhKUFNLOFZRam9BQUVEdUNlbTFGdElCQUFESUxTRzlWbWhKQndBQXlEMGh2VllJNlFBQUFMa25wTmNLSVIwQUFDRDNoUFJhSWFRREFBRGtucEJlSzRSMEFBQ0EzQlBTYTRXUURnQUFrSHRDZXEwUTBnRUFBSEpQU0s4VlFqb0FBRUR1Q2VtMVFrZ0hBQURJUFNHOVZnanBBQUFBdVNlazF4b2hIUUFBSUxlRTlGcWhKUjBBQUNEM2hQUmEwZm45UXkya0F3QUE1SmFRRGdBQUFEa2hwTmNLM2QwQkFBQnlyMnU1QzBBSGgvU0ZDMU42NjYyRzMxZGNNYVV1WGNwYUxBQUFBRDRncE5mYW1QUjU4MUs2NjY0UFF2b3V1NVMxV0FBQUFIeEFkL2RhMGJkdlNvTUhwN1RDQ2luMTZ0V3diZGFzY3BjS0FBQ0FFbHJTYTZtNyszYmJOZncrWjA1S045MWtmRG9BQUVET2FFbXZSU2FSQXdBQXlDVWh2UllKNlFBQUFMa2twTmZ5SkhKQlVBY0FBTWdOSWIyV1c5S0RrQTRBQUpBYlFub3RFdElCQUFCeVNVaXY5WkJlWDEvT2tnQUFBRkJDU0s5Rld0SUJBQUJ5U1VpdlJVSTZBQUJBTGducHRjb3liQUFBQUxranBOY3FJUjBBQUNCM2hQUmFKYVFEQUFEa2pwQmVxenEvZitpRmRBQUFnTndRMG11VmxuUUFBSURjRWRKclBhUmJKeDBBQUNBM2hQUmFwU1VkQUFBZ2Q0VDBXaVdrQXdBQTVJNlFYcXVFZEFBQWdOd1IwbXVWa0E0QUFKQTdRbnF0RXRJQkFBQnlwMnU1QzBDWjEwbWZOaTJsT1hOUzZ0RWpwVUdEeWwwcUFBQ0FtaWFrMTNwSWYvYlpEN2J0dEZOS0F3YVVyVWdBQUFDMVRuZjNXclhlZWlrTkhwelNLcXVrMUsxYnc3Wm9VUWNBQUtCc3RLVFhxZ2pvY1FuMzNKUFM5T25HcHdNQUFKU1psblJNSWdjQUFKQVRRam9makUrdnJ5OTNTUUFBQUdxYWtJNldkQUFBZ0p3UTB0R1NEZ0FBa0JOQ09sclNBUUFBY2tKSTU0T1dkQ0VkQUFDZ3JJUjBQbWhKMTkwZEFBQ2dySVIwZEhjSEFBRElDU0VkM2QwQkFBQnlRa2hIZDNjQUFJQ2NFTkxSa2c0QUFKQVRRanBhMGdFQUFIS2k3Q0g5Z2dzdVNNT0hEMDg5ZS9aTTIyKy9mYnJ2dnZzV3UrOFRUenlSUHYzcFQyZjdkK3JVS1oxLy92a2RXdGFxWmVJNEFBQ0FYQ2hyU0wvaWlpdlNjY2NkbDhhTkc1Y2VldWlodFBubW02ZlJvMGVuYWRPbXRiai83Tm16MDlwcnI1M09PdXVzTkdUSWtBNHZiOVhTM1IwQUFDQVh5aHJTenozMzNIVDQ0WWVud3c0N0xHMjAwVWJwb29zdVNyMTc5MDZYWEhKSmkvdHZ1KzIyNlNjLytVazY2S0NEVW84ZVBUcTh2RlZMZDNjQUFJQmM2RnF1QjU0L2YzNTY4TUVIMDlpeFl4dTNkZTdjT1kwYU5TcE5talNwelI1bjNyeDUyYVZvNXN5WjJjKzZ1cnJza2xmRnNuVklHUmNzU0owV0xFaHB5cFNVNHJYdjFDa1YxbG9ycFFFRDJ2K3hxVmdkV2tkaEdhbW41SjA2U3Q2cG8rUmRYWVhVMGFVcFg5bEMraHR2dkpFV0xseVlCZzhlM0dSN1hIL3FxYWZhN0hIT1BQUE1OSDc4K0VXMjMzampqVm1yZmQ1Tm1EQ2gzUitqNTF0dnBSV2ZmYmJKdG5uOSs2Y1o2NjNYN285TjVldUlPZ3JMU3owbDc5UlI4azRkSmU4bTVMeU94dER0M0lmMGpoSXQ5VEh1dmJRbGZkaXdZV25QUGZkTS9mcjFTM2srMHhJVmJZODk5a2pkdW5WcjN3ZUxzZWhUcDBiM2hwVGVmanQxZXZubGxBWU9USVVkZG1qZng2V2lkV2dkaFdXa25wSjM2aWg1cDQ2U2QzVVZVa2VMUGJwekhkSUhEaHlZdW5UcGtxWkdPQ3dSMTl0eVVyZ1l1OTdTK1BVNGdIaytpQjFlem1IREduNisvbnJESlNhVHE0RFhoL0tybFBjU3RVMDlKZS9VVWZKT0hTWHZ1dVc4amk1TjJjbzJjVnozN3QzVDFsdHZuU1pPbk5pNHJiNitQcnMrY3VUSWNoVUxrOGdCQUFDVVRWbTd1MGMzOURGanhxUnR0dGttYmJmZGR0bTY1Kys5OTE0MjIzczQ1SkJEMHRDaFE3Tng1Y1hKNXA1ODhzbkczMTk5OWRYMHlDT1BwRDU5K3FSMTFsbW5uRStsZWxpT0RRQUFvRFpEK29FSEhwaW1UNStlVGozMTFEUmx5cFMweFJaYnBCdHV1S0Z4TXJuSmt5ZG5NNzRYdmZiYWEybkxMYmRzdkg3T09lZGtsMTEzM1RYZGV1dXRaWGtPVmFmNGVtdEpCd0FBNkhCbG56anU2S09Qemk0dGFSNjhodzhmbmdwYWVOdVhrQTRBQUZBMlpSdVRUczdIcERzWkFnQUEwT0dFZEpyU2tnNEFBRkEyUWpwTkNla0FBQUJsSTZUVGxKQU9BQUJRTmtJNlRSbVREZ0FBVURaQ09rMXBTUWNBQUNnYklaMldRM3EwcEd0TkJ3QUFxSzExMHNscGQvZncvUE1OMS92M1QybkFnSEtXQ2dBQW9DWUk2VFRWcFV0RE1JOVc5Q2VmL0tCMWZmVG9sTHFxTGdBQUFPMUo2cUtwQ09TYmJaYlNHMjgwWEgvdHRZYng2WFYxUWpvQUFFQTdrN3BZMUJwck5GekN0R2tOQWQxRWNnQUFBTzNPeEhFczJVUnlDeGVXdXlRQUFBQlZUMGluZFpaa0F3QUE2REJDT3EwVDBnRUFBRHFNa0U3cmhIUUFBSUFPSTZUVE9pRWRBQUNnd3dqcHRFNUlCd0FBNkRCQ09xMFQwZ0VBQURxTWtFN3JoSFFBQUlBT0k2VFR1aTVkR240SzZRQUFBTzJ1YS9zL0JGWFJrdjdvb3lrOTlsaEszYnFsdE8yMkthMjBVcmxMQmdBQVVIVzBwTk82WWhndkZCcGEwK2ZOUzJuYXRIS1hDZ0FBb0NwcFNhZDFhNitkMHRDaERRSDltV2RTbWp4WjEzY0FBSUIySXFUejRYcjBhUHB6NGNLeUZnY0FBS0JhNmU3T2tqUFRPd0FBUUxzUzBsbjZtZDYxcEFNQUFMUUxJWjBscHlVZEFBQ2dYUW5wTERrdDZRQUFBTzFLU0dmcFE3cVdkQUFBZ0hZaHBMUDAzZDIxcEFNQUFMUUxTN0N4OUMzcDc3eVQwaDEzcE5TcFUwcHJyTkZ3QVFBQVlMa0o2U3k1M3IwL2FFbWZNYVBoOTNuemhIUUFBSUEySXFTejVQcjBTV25YWFZPYU02Zmg4dGhqS1MxWVVPNVNBUUFBVkEwaG5hWFRyMS9EWmZic2h1dkdwd01BQUxRWkU4ZXgvTXV4RlFybExnMEFBRUJWRU5KWk5sMUxPbUZZa2cwQUFLQk5DT2tzMzNKc1FaZDNBQUNBTmlHa3MyeGkrVFhycGdNQUFMUXBFOGV4ZkYzZTU4OVA2WVVYVXVyZXZXR0p0dFZXSzNlcEFBQUFLcGFRenJMcjFxMGhwRC8zM0FmYlZsZ2hwUlZYTEdlcEFBQUFLcGJ1N2l5N1RUZE5hWTAxVWhvMnJLRWxQY3lkVys1U0FRQUFWQ3d0NlN5N1FZTWFMbUhTcEpUZWVDT2xCUXZLWFNvQUFJQ0twU1dkdGwyU1RVZ0hBQUJZWmtJNmJhTkxsNGFmUWpvQUFNQXlFOUpwMjVaMHk3RUJBQUFzTTJQU2FkdVEvdXFyS2MyYzJkQ3lQbUpFU3YzNmxidGtBQUFBRlVOSXAyMzA2dFh3Yzlhc2hrdlJsbHVXclVnQUFBQ1ZSa2luYmNSU2JMRU1XMTFkU20rL25kSXJyelNzb1E0QUFNQVNFOUpwRzlHOWZlalFodDk3OUdnSTZTYVJBd0FBV0NvbWpxUHRkZXZXOEROYTFRRUFBRmhpV3RKcHY1QWUzZDNuekduNHZXZlBsRHAxS211eEFBQUE4azVJcC8xbWVwODNMNldiYm1yNFBXWjUzM1hYc2hZTEFBQWc3M1IzcCszMTdwM1NnQUVwZGU3Y2NBbXhMSnZ1N3dBQUFLM1NrazdiaTI3dE8rMzB3ZlhycjA5cDRjS0c3dS9GcnZBQUFBQXNRa3M2N1MrV1pndVdaQU1BQUdpVmxuUTZKcVRIQkhMUFB0c3dnVnhjSHpIaWc3SHJBQUFBWktRazJsK3ZYaW05ODA1S1U2WTAzYmJHR3VVc0ZRQUFRTzRJNmJTL2pUZE9hY1VWVXlvVVVwbzJMYVVaTXo1WW1nMEFBSUJHUWpvZE05djdldXQ5Y0QxQ2VpelBCZ0FBUUJOQ09oMnJSNCtHbjYrOGt0TDA2UTB6d2NmNDlEWFhMSGZKQUFBQXlrNUl6NmtYWDN3eHZmcnFxK21aWjU1SjNicDFTejE2OUVoclZrT1E3ZCsvNFdjc3lUWjdkc1B2eno4dnBBTUFBQWpwK2JYdnZ2dW1wNTkrdXNtMkwzN3hpK21QZi94anF2aVEvckdQTlhSM256czNwUWNlYVBnSkFBQ0FkZElyeVovKzlLYzBweG9tWElzeDZpdXRsTktnUVEzWEZ5eEk2WlpiR2k3MzM1OVNmWDI1U3dnQUFGQVdXdEp6M0pLKzJtcXJwYUZEaDZaNzdya25QUnRyaktlVXhvNGRtL3IzNzUrMjNucnJiSitLRnV1azkrbVQwcXhaRFpjUVAyTzV0Z2p4QUFBQU5VWkl6Nmt6empnalhYLzk5V252dmZkTzQ4ZVBUei82MFkreTdULzcyYzhhOTduampqdlN6anZ2bkNwYWxIL216SWJmbjN5eVllYjNtRlR1dmZkUzZ0SWxwVlZXYWZnSkFBQlFBM1IzcndDTGF6Ry8rT0tMMDFWWFhaVW1UcHlZRmtTWDhVclVyVnRLSzYvY2NJbTExTU9MTDZiMDhNTU40OVdmZTY3Y0pRUUFBT2d3UW5vRjJINzc3ZE1MTDd5UWJyamhodlRiMy82MnlSajF6MzN1YzJuVXFGSHBwSk5PU2hWdnJiVlNHaktrWWF4NnYzNE4yNlpPVGVuVlZ4c3V4ZG5nQVFBQXFwVHU3aFZpK1BEaDJXWCsvUG5wdE5OT1M2OUVsL0FTNTU1N2J0YWEzcmx6NTdUZmZ2dWwzWGZmUFZXY3ZuMVQybmJiaHQvZmVpdWx1KzVxNlA3KzBFTU4yM3IxU21uVXFMSVdFUUFBb0QwSjZSV21lL2Z1NmJiYmJrdi8vT2MvczFCKy9QSEhOOTcyODUvL1BQdDUvdm5ucDN2dnZUY05Ianc0RFJvMEtQV08yZFFyVFV3Y04zejRCeFBLdmZsbVNqR3ovYjMzcHRTNWM3d1FLVzI4Y2NQa2N3QUFBRlZDd3FsQWE2KzlkdnJtTjcrWi9SNEIvTWdqajJ5eGkzeng5aGl6dnNNT082U0swcWxUU3B0dStzSDFhRldQMXZWcDB6N1lGbUY5d0lDR253TUhOb3h2QndBQXFHREdwRmU0cjMvOTYrbjU1NS9QbG1rNzg4d3pGN2w5OXV6WmFlVElrZG15YmF1dXVtcjYxYTkrbFNyUzFsdW50UG5tRFpkVlYvMWdncm5vQ2g4VHpOMStlME5yZTF6bXppMTNhUUVBQUphSmx2UXFzTlphYTJXWDdiYmJMdlhwMHlkYm1xMnVyaTVkYzgwMWpmdTg4ODQ3MmVXb280N0tMdEZ0ZnZYVlYwK1hYWFpaNnR1M2J4b3dZRUJhWTQwMVVtNzE3SmxTc1h5eExGdW9xMnVZVEs1NHVmdnVEL2FQVnZqb0VsOWN4aTFhNWdFQUFISk9TSzhpblRwMVNrY2ZmWFIyQ1ZkZWVXVTY2Nnl6MHB3NWM5SlRUejNWWk4rWWdDNWE0SGZaWlpmR2JSSGFEenJvb05TbFM1ZHMyYmRpbC9tNEh2ZWRxOEMrelRZZlhILzAwWVlXOUZBY3cvN1lZeC9jSG1FOVpvMFAwUXBmRFBrQUFBQTVrNHVRZnNFRkY2U2YvT1FuYWNxVUtXbnp6VGRQdi9qRkw3Slc0Y1dKdGNGUE9lV1U5T0tMTDZaMTExMDMvZmpIUDA1Nzc3MTNoNWE1RXNUeWJIRUowNlpOUzBjY2NVU2FQSGx5ZG5tekdHcEx4SXp4NTV4elR2Wjd2S1pGUFhyMFNQdnNzMDgyRVYyL2Z2M1NsbHR1bVlZT0hab0Y5eTIyMkNLdHNNSUtxYXcyMit5RDMyUGMralBQcEZRb1JQZUJodGIyK2ZOVG1qeTU0ZmJpenhDdDdLdXYva0dMZXl6OUZpY0FRbzhlV3Q4QkFJRGFDK2xYWEhGRk91NjQ0OUpGRjEyVXRkekd6T1NqUjQ5T1R6LzlkRnFsaFJiUHUrKytPeDE4OE1IWitPdFBmT0lUNlM5LytVdmFmLy85MDBNUFBaUTIyV1NUc2p5SFNoQ3Y1YlhYWHR0NC9mcnJyODltaUsrdnIwOFhYM3h4cTM4N2I5NjhkUFhWVnkvMjlnanBFZGhYV21tbDdLUkpkS1h2MXExYnRtUmNkTDh2UHY3S0s2L2NHUG9qNU1jK1hidDJiYnpFOWRnL1RnUkU2MzN4RXN2S0xiR1lTSzUwa3J5WFgvNWdqUHJ6enpjRTlxS0ZDMU42NmFVUHJwZjJOb2pRSGt2Q1JWQ1BHZVJqM2ZZb1IxeVA1MVNjVlQ0Q2ZqSFl4KzBSN2dFQUFKWlJwMElobWh6TEo0TDV0dHR1bTM3NXkxOW0xeU0wRGhzMkxCMXp6REhwNUpOUFhtVC9Bdzg4TUwzMzNudFp3Q3lLbWN1alJUZUMvb2VaT1hObVduSEZGYlB4MlJFRzg2cHV4eDFUM1FNUHBHNFJYdHY1c2VvTGhmUjRvWkJtRmdwcGRrcnBGd3NXcEJrcHBhZ1lkOVhYcHp6b0VpY0RJaE8vLzN2bjl5OWRPblg2NFBmM2YwWjhqdGVzVThubHdmSldjd0FBb0oyYzFxMWJPbW5tek5TejJIaVdRMHVUUTh2YWtoN2pvaDk4OE1FMGR1ell4bTNSYWpwcTFLZzBhZEtrRnY4bXRrZkxlNmxvZVM5dEpXN2VDaHlYMGhjbnhNUnFjY21yd3FSSktXdVRyYXRMQ3p2ZzhUWXUrZjFqSmIvSEt4VHR5d3RTU3UrbGxPNU5LVTE5UDhEL0w2WDB3dnUveDZ2NjZ2dS90NGQ0RFJxT1hEUENOd0FBMUxUVDZ1clNsbi8rYy9yNElZZWt2RnFhN0ZuV2tQN0dHMitraFFzWFptT2RTOFgxNWhPZEZjVzQ5WmIyaiswdGlXN3g0OGVQWDJUN2pUZmVtSzBobmxlak8zZE9uWFBRaWgwVnBIUVF3VTZ0N0J1dDhNWFRJYS9GT1BqM2Y1OFQ0OTNmRDlvUnFhZkgvRzd2Qi8rNjkzOFdMelBldjUrRkxWeUtmMVAvL3ZYNmtrdnA5YnIzTDRXU1MwZWM2QUFBQURyZWFqRTFWWmN1MlpEZXZJcWxzU3RtVEhwN2kxYjYwcGIzYUVtUDd2Ujc3cmxudnJ1N3YvdHV1bTdDaExUSEhudGtZN1VyUWEvM0w2Ri9TbW1qbEI4elpzeElzNG96djJjTjhJVnNhRVg4WE41TDhmNUtsWGtVU1lkWXNHQkJ1dWVlZTdMaEpqR25BTzJqRnVwU2U5ZlRlKys5Tnh0YVZldjFWRjNLcDBxc28rcFNiV25QT3FvdTBWWjE5TTAzMzB4NzdiVlhybk5Uc1VmM2tpanIvd1lEQnc3TUpnYWJPalU2VUg4Z3JnOHBMcG5WVEd4Zm12MWprcks0TkJjSE1NOEhzZExLbVhlREJnM0tMclJ0bDUzb0RSTXJNYWlqNUxtZXhuL2M4ZVZTUFNXdmRmU3R0OTdLVG5pcW8rUzFqcjc5OXR0cDVNaVI2aWk1cmFQWFgzOTk3blBUMHBSdEthYk5ibnN4Qy9qV1cyK2RKazZjMkxndFdqZmplbndRdENTMmwrNGZKa3lZc05qOUFRQUFvRktVdlY5VmRFVWZNMlpNMm1hYmJiSVd1VmlDTFdadlAreXd3N0xiRHpua2tHeTVyaGhiSG80OTl0aTA2NjY3cHAvKzlLZloydDJYWDM1NWV1Q0JCOUt2Zi8zck1qOFRBQUFBcVBDUUhrdXFUWjgrUFoxNjZxblo1Ryt4bE5vTk45elFPRG5jNU1tVG02eVR2ZU9PTzJacm8zLy8rOTlQMy8zdWQ3TjF1V05tZDJ1a0F3QUFVT25LSHRMRDBVY2ZuVjFhY3V1dHR5Nnk3Yk9mL1d4MkFRQUFnR3BTMWpIcEFBQUF3QWVFZEFBQUFNZ0pJUjBBQUFCeVFrZ0hBQUNBbkJEU0FRQUFJQ2VFZEFBQUFNZ0pJUjBBQUFCeVFrZ0hBQUNBbkJEU0FRQUFJQ2VFZEFBQUFNZ0pJUjBBQUFCeVFrZ0hBQUNBbkJEU0FRQUFJQ2U2cGhwVEtCU3luek5uemt4NVZsZFhsMmJQbnAyVnMxdTNidVV1RGl4Q0hhVVNxS2ZrblRwSzNxbWo1RjFkaGRUUll2NHM1dEhXMUZ4SWYvZmRkN09mdzRZTkszZFJBQUFBcUxFOHV1S0tLN2E2VDZmQ2trVDVLbEpmWDU5ZWUrMjExTGR2MzlTcFU2ZVU1ek10Y1NMaDVaZGZUdjM2OVN0M2NXQVI2aWlWUUQwbDc5UlI4azRkSmU5bVZrZ2RqZGdkQVgyMTFWWkxuVHUzUHVxODVsclM0d1ZaZmZYVlU2V0lpcGJueWdicUtKVkFQU1h2MUZIeVRoMGw3L3BWUUIzOXNCYjBJaFBIQVFBQVFFNEk2UUFBQUpBVFFucE85ZWpSSTQwYk55NzdDWG1ramxJSjFGUHlUaDBsNzlSUjhxNUhGZGJSbXBzNERnQUFBUEpLU3pvQUFBRGtoSkFPQUFBQU9TR2tBd0FBUUU0STZRQUFBSkFUUW5wT1hYREJCV240OE9HcFo4K2VhZnZ0dDAvMzNYZGZ1WXRFRlRydHROTlNwMDZkbWx3MjJHQ0R4dHZuenAyYmpqcnFxTFR5eWl1blBuMzZwRTkvK3ROcDZ0U3BUZTVqOHVUSmFaOTk5a205ZS9kT3E2eXlTanJ4eEJQVGdnVUxtdXh6NjYyM3BxMjIyaXFiZFhPZGRkWkpsMTEyV1ljOVJ5ckw3YmZmbnZiZGQ5KzAybXFyWmZYeDJtdXZiWEo3ekhWNjZxbW5wbFZYWFRYMTZ0VXJqUm8xS3YzdmYvOXJzczliYjcyVnZ2Q0ZMNlIrL2ZxbC92MzdwNjk4NVN0cDFxeFpUZlo1OU5GSDAwYys4cEhzTTNiWXNHSHA3TFBQWHFRc1YxMTFWZloraUgwMjNYVFRkUDMxMTdmVHM2YmE2dW1oaHg2NnlHZnJYbnZ0MVdRZjlaVDJjdWFaWjZadHQ5MDI5ZTNiTi90L2VmLzk5MDlQUC8xMGszMDY4djkzMzJsWmxqcTYyMjY3TGZJNSt2V3ZmNzEyNm1qTTdrNitYSDc1NVlYdTNic1hMcm5ra3NJVFR6eFJPUHp3d3d2OSsvY3ZUSjA2dGR4Rm84cU1HemV1c1BIR0d4ZGVmLzMxeHN2MDZkTWJiLy82MTc5ZUdEWnNXR0hpeEltRkJ4NTRvTERERGpzVWR0eHh4OGJiRnl4WVVOaGtrMDBLbzBhTktqejg4TU9GNjYrL3ZqQnc0TURDMkxGakcvZDUvdm5uQzcxNzl5NGNkOXh4aFNlZmZMTHdpMS84b3RDbFM1ZkNEVGZjME9IUGwveUxPdlM5NzMydmNQWFZWOGZLSTRWcnJybW15ZTFublhWV1ljVVZWeXhjZSsyMWhmLzg1eitGL2ZiYnI3RFdXbXNWNXN5WjA3alBYbnZ0VmRoODg4MEw5OXh6VCtHT08rNG9yTFBPT29XRER6NjQ4ZlozM25tbk1Ianc0TUlYdnZDRnd1T1BQMTc0NjEvL1d1alZxMWZoNG9zdmJ0em5ycnZ1eXVycDJXZWZuZFhiNzMvLys0VnUzYm9WSG52c3NRNTZKYWprZWpwbXpKaXNIcFordHI3MTFsdE45bEZQYVMralI0OHVYSHJwcFZtOWVlU1JSd3A3NzcxM1lZMDExaWpNbWpXcncvOS85NTJXWmEyanUrNjZhMVpmU2o5SDQzT3hWdXFva0o1RDIyMjNYZUdvbzQ1cXZMNXc0Y0xDYXF1dFZqanp6RFBMV2k2cVQ0VDArSkxZa2hrelptUmY5cTY2NnFyR2JmLzk3Myt6TDZTVEprM0tyc2NIWXVmT25RdFRwa3hwM09mQ0N5OHM5T3ZYcnpCdjNyenMrbmUrODUzc1JFQ3BBdzg4TVB1QWh0WTBEei8xOWZXRklVT0dGSDd5azU4MHFhYzlldlRJQWt5SS80VGo3KzYvLy83R2ZmNzFyMzhWT25YcVZIajExVmV6NjcvNjFhOEtLNjIwVW1NZERTZWRkRkpoL2ZYWGI3eit1Yzk5cnJEUFB2czBLYy8yMjI5ZitOclh2dFpPejVaS3RiaVEvc2xQZm5LeGY2T2UwcEdtVFp1VzFiZmJicnV0dy85Lzk1MldaYW1qeFpCKzdMSEhGaGFuMnV1bzd1NDVNMy8rL1BUZ2d3OW1YVGlMT25mdW5GMmZOR2xTV2N0R2RZcXV3dEZsYysyMTE4NjZYa2JYb1JEMXNLNnVya2xkakM2VmE2eXhSbU5kakovUnZYTHc0TUdOKzR3ZVBUck5uRGt6UGZIRUU0MzdsTjVIY1IvMW1hWDF3Z3N2cENsVHBqU3BUeXV1dUdMV05hMjBUa2JYNFcyMjJhWnhuOWcvUGtmdnZmZmV4bjEyMldXWDFMMTc5eVoxTXJyYXZmMzIyNDM3cUxjc2oraGlHZDB2MTE5Ly9YVGtrVWVtTjk5OHMvRTI5WlNPOU00NzcyUS9Cd3dZMEtIL3YvdE95N0xXMGFJLy8vblBhZURBZ1dtVFRUWkpZOGVPVGJObnoyNjhyZHJyYU5leVBqcUxlT09OTjlMQ2hRdWJWTGdRMTU5NjZxbXlsWXZxRk9FbXh1YkVsOGpYWDM4OWpSOC9QaHYvK1BqamoyZGhLTDRjeGhmSjVuVXhiZ3Z4czZXNldyeXR0WDNpUTNUT25Eblp1R0pZRXNVNjFWSjlLcTF2RVl4S2RlM2FOZnVQdjNTZnRkWmFhNUg3S042MjBrb3JMYmJlRnU4RFdoUGp6ei8xcVU5bDlleTU1NTVMMy8zdWQ5UEhQLzd4N0V0Zmx5NWQxRk02VEgxOWZmcld0NzZWZHRwcHB5em9oSTc2L3oxT0p2bE95N0xVMGZENXozOCtyYm5tbWxsRFVzelBjZEpKSjJVbkthKysrdXFhcUtOQ090U3crTkpZdE5sbW0yV2hQVDRRcjd6eVN1RVpZQmtkZE5CQmpiOUhTMDk4dm80WU1TSnJYZi9ZeHo1VzFySlJXMkp5dURqeGZ1ZWRkNWE3S0xCVWRmU0lJNDVvOGprYUU4Ykc1MmVjK0l6UDAycW51M3ZPUkplT09NdmVmSWJOdUQ1a3lKQ3lsWXZhRUdmVjExdHZ2ZlRzczg5bTlTMjZBYzJZTVdPeGRURit0bFJYaTdlMXRrL01hT3hFQUV1aldLZGErM3lNbjlPbVRXdHllOHowR2pOcHQwVzk5VG5Nc29qaFJQSC9lM3kyQnZXVWpuRDAwVWVuZi83em4rbVdXMjVKcTYrK2V1UDJqdnIvM1hkYWxyV090aVFha2tMcDUyZzExMUVoUFdlaSs5SFdXMitkSms2YzJLUWJTRndmT1hKa1djdEc5WXZsZitJTVpaeXRqSHJZclZ1M0puVXh1aG5GbVBWaVhZeWZqejMyV0pNdm14TW1UTWcrL0RiYWFLUEdmVXJ2bzdpUCtzelNpcTYvOFo5bWFYMktMbXN4aHJlMFRzWVh6eGhqVm5UenpUZG5uNlBGLytCam4xaENLOFprbHRiSkdQWVJYWWlMKzZpM3RKVlhYbmtsRzVNZW42MUJQYVU5eFh5R0VYNnV1ZWFhckY0MUh6YlJVZisvKzA3THN0YlJsanp5eUNQWno5TFAwYXF1bzJXZHRvNFd4VklBTVZ2eFpaZGRsczBBZThRUlIyUkxBWlRPWGdodDRmampqeS9jZXV1dGhSZGVlQ0ZieWllV3NZamxLMktXemVJU0xiRWt4czAzMzV3dDBUSnk1TWpzMG56NWl6MzMzRE5iUWlPV3RCZzBhRkNMeTErY2VPS0oyZXl4RjF4d2dTWFlXS3gzMzMwM1cwb2xMdkZmMUxubm5wdjkvdEpMTHpVdXdSYWZoMy8vKzk4TGp6NzZhRGFEZGt0THNHMjU1WmFGZSsrOXQzRG5uWGNXMWwxMzNTWkxXOFhNeHJHMDFaZSs5S1ZzK1pmNHpJMDYybnhwcTY1ZHV4Yk9PZWVjck43R1NnaVd0bUpKNm1uY2RzSUpKMlN6Wk1kbjYwMDMzVlRZYXF1dHNubzRkKzdjeHZ0UVQya3ZSeDU1WkxaVVpmei9YcnA4MWV6WnN4djM2YWovMzMyblpWbnE2TFBQUGxzNC9mVFRzN29abjZQeGYvN2FhNjlkMkdXWFhXcW1qZ3JwT1JYcitNV0haNnpiRjBzRHhEcXEwTlppR1lwVlYxMDFxMmREaHc3TnJzY0hZMUVFbjI5ODR4dlpNa0R4SVhmQUFRZGtINktsWG56eHhjTEhQLzd4YlAzZUNQZ1IvT3ZxNnByc2M4c3R0eFMyMkdLTDdISGlRemJXeG9TV1JGMkowTlA4RWt0YUZaZGhPK1dVVTdMd0V2K3BmdXhqSHlzOC9mVFRUZTdqelRmZnpNSk9uejU5c3FWWURqdnNzQ3c0bFlvMTFuZmVlZWZzUHFMdVIvaHY3c29ycnl5c3Q5NTZXYjJOSlZ5dXUrNjZkbjcyVkVNOWpTK1o4YVV4dml4R1lGNXp6VFd6ZFhlYmYrRlRUMmt2TGRYTnVKVCszOXVSLzcvN1RzdlMxdEhKa3lkbmdYekFnQUhaNTk4NjY2eVRCZTNTZGRLcnZZNTJpbi9LMjVZUEFBQUFCR1BTQVFBQUlDZUVkQUFBQU1nSklSMEFBQUJ5UWtnSEFBQ0FuQkRTQVFBQUlDZUVkQUFBQU1nSklSMEFBQUJ5UWtnSEFBQ0FuQkRTQVlBT2Q5bGxsNlgrL2Z1WHV4Z0FrRHRDT2dEazJKUXBVOUt4eHg2YjFsbG5uZFN6Wjg4MGVQRGd0Tk5PTzZVTEw3d3d6WjQ5TzFXQzRjT0hwL1BQUDcvSnRnTVBQREE5ODh3elpTc1RBT1JWMTNJWEFBQm8yZlBQUDU4RjhtaHhQdU9NTTlLbW0yNmFldlRva1I1NzdMSDA2MS8vT2cwZE9qVHR0OTkrWlNsYm9WQklDeGN1VEYyN0x0dFhpVjY5ZW1VWEFLQXBMZWtBa0ZQZitNWTNzaEQ4d0FNUHBNOTk3bk5wd3cwM1RHdXZ2WGI2NUNjL21hNjc3cnEwNzc3N1p2dk5tREVqZmZXclgwMkRCZzFLL2ZyMVN4Lzk2RWZUZi83em44YjdPZTIwMDlJV1cyeVIvdmpIUDJhdDJpdXV1R0k2NktDRDBydnZ2dHU0VDMxOWZUcnp6RFBUV211dGxZWG56VGZmUFAzZi8vMWY0KzIzM25wcjZ0U3BVL3JYdi82VnR0NTY2K3hrd1oxMzNwbWVlKzY1ckR6Und0K25UNSswN2JiYnBwdHV1cW54NzNiYmJiZjAwa3N2cFc5Lys5dlozOGRsY2QzZG8zZkFpQkVqVXZmdTNkUDY2NitmbGJkVS9PMXZmL3ZiZE1BQkI2VGV2WHVuZGRkZE4vMi8vL2YvMnVHVkI0RHlFZElCSUlmZWZQUE5kT09OTjZhampqb3FyYkRDQ2kzdVV3eThuLzNzWjlPMGFkT3lBUDNnZ3crbXJiYmFLbjNzWXg5TGI3MzFWdU8rRWFhdnZmYmE5TTkvL2pPNzNIYmJiZW1zczg1cXZEMEMraC8rOElkMDBVVVhwU2VlZUNJTDFWLzg0aGV6L1VxZGZQTEoyZC85OTcvL1RadHR0bG1hTld0VzJudnZ2ZFBFaVJQVHd3OC9uUGJhYTYvczVNSGt5Wk96L2ErKyt1cTArdXFycDlOUFB6MjkvdnJyMmFVbDExeHpUZGF0Ly9qamowK1BQLzU0K3RyWHZwWU9PK3l3ZE1zdHR6VFpiL3o0OGRrSmkwY2ZmVFI3M0M5ODRRdE5uaWNBVkx3Q0FKQTc5OXh6VHlIK203NzY2cXViYkY5NTVaVUxLNnl3UW5iNXpuZStVN2pqampzSy9mcjFLOHlkTzdmSmZpTkdqQ2hjZlBIRjJlL2p4bzByOU83ZHV6Qno1c3pHMjA4ODhjVEM5dHR2bi8wZWZ4dTMzMzMzM1UzdTR5dGYrVXJoNElNUHpuNi81Wlpic3ZKY2UrMjFIMXIyalRmZXVQQ0xYL3lpOGZxYWE2NVpPTys4ODVyc2MrbWxseFpXWEhIRnh1czc3cmhqNGZEREQyK3l6MmMvKzluQzNudnYzWGc5SHYvNzMvOSs0L1ZaczJabDIvNzFyMzk5YUprQW9GSVlrdzRBRmVTKysrN0x1cVpIQy9LOGVmT3lidTNSbXIzeXlpczMyVy9PbkRsWjYzbFJkSFB2MjdkdjQvVlZWMTAxYTMwUHp6NzdiRFlKM1I1NzdOSGtQdWJQbjUrMjNITExKdHUyMldhYkp0ZmpzYU03ZlhTL2oxYnlCUXNXWkk5ZGJFbGZVdEV5ZjhRUlJ6VFpGdVB4Zi9hem56WFpGcTMzUmRIRElMcjNGNThIQUZRRElSMEFjaWhtYzQvdTdFOC8vWFNUN1RFbVBSUW5YWXVRSElFN3hvdzNWenJtdTF1M2JrMXVpL3VPc0YrOGp4QkJPeWFqS3hWanowczE3M3Avd2drbnBBa1RKcVJ6emprbkszT1U2ek9mK1V3VzhOdERhODhEQUtxQmtBNEFPUlF0NDlHeS9jdGYvaklkYzh3eGl4MlhIdVBQWTVtMm1HQXVXc3VYeFVZYmJaU0Y4V2o5M25YWFhaZnFiKys2NjY1MDZLR0hacE81RlFQL2l5KysyR1NmbUFndVpvSnZUVXlLRi9jMVpzeVlKdmNkWlFPQVdpS2tBMEJPL2VwWHY4cTZmRWNYOCtoU0hsMjlPM2Z1bk82Ly8vNzAxRk5QWmJPc2p4bzFLbzBjT1RMdHYvLys2ZXl6ejA3cnJiZGVldTIxMTdKVzhRak96YnVudHlTNndVZUxlRXdXRjYzU08rKzhjM3JublhleWtCemR5VXVEYzNNeHczcE1EaGVUeFVXcjlpbW5uTEpJeTNhY1BMajk5dHV6R2VYalpNREFnUU1YdVo4VFR6d3hteEF1dXRmSGMvckhQLzZSM1cvcFRQRUFVQXVFZEFESXFWaU9MR1pNanpYU3g0NGRtMTU1NVpVczVFYnJjb1RxV0tJdGd2SDExMStmdnZlOTcyV3pvVStmUGowTkdUSWs3YkxMTHRteWFFdnFCei80UWJhRVc4enlIdXV6UjFmNWFLWC83bmUvMityZm5YdnV1ZW5MWC81eTJuSEhIYlB3ZmRKSko2V1pNMmMyMlNkbWRvL1oydVA1eERqNmhqbmdtb3FURERIK1BMck54eXp2c1JUY3BaZGVtaTNoQmdDMXBGUE1IbGZ1UWdBQUFBRFdTUWNBQUlEY0VOSUJBQUFnSjRSMEFBQUF5QWtoSFFBQUFISkNTQWNBQUlDY0VOSUJBQUFnSjRSMEFBQUF5QWtoSFFBQUFISkNTQWNBQUlDY0VOSUJBQUFnSjRSMEFBQUFTUG53L3dHaGc1blU5Vyt2YXdBQUFBQkpSVTVFcmtKZ2dnPT1cIixcbiAgICBvYmplY3RUeXBlOiBcImltYWdlL3BuZ1wiLFxuICAgIG9iamVjdFVsaWQ6IFwiMDFKVEhSVDJSTllUUUhORE5TMFZQWDQ0MlNcIixcbiAgICBzaGFyZFR4SWRzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiBcIjJcIixcbiAgICBuYW1lOiBcIkdyYXBoIFZpc3VhbGl6YXRpb25cIixcbiAgICBkYXRlVXBsb2FkZWQ6IFwiMjAyNS0wMy0xOFQxMTo0NTowMFpcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDb21wbGV4IGdyYXBoIGRhdGEgdmlzdWFsaXphdGlvblwiLFxuICAgIGZpbGVUeXBlOiBcInBuZ1wiLFxuICAgIGluZGV4aW5nVHhJZDogdW5kZWZpbmVkLFxuICAgIGluZGV4aW5nVHhTdWJtaXR0ZWRBdDogdW5kZWZpbmVkLFxuICAgIG9iamVjdERhdGE6XG4gICAgICBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUE2NEFBQUZHQ0FZQUFBQnFqc0swQUFBQUJITkNTVlFJQ0FnSWZBaGtpQUFBSUFCSlJFRlVlSnpzM1hkY1ZGZjZQL0NQU0psWUFJY0JLNHBFRVZUS1doSVRVYkd4bGtSUk44YXlkbzBtYWpTSjBheitKQWEvdW1yY1JEZWFhTVFlUzB3Z0dGZk5XckVsbHVncUtHS0pvRmh4UUxGbHBQbjc0ekxEOUhxSEdlRHpmcjE0S2NPZGM1ODdkd2J1Yzg4NXo2bnk0c1VMRUJFUkVSRVJFVGtyRjBjSFFFUkVSRVJFUkdRTUUxY2lJaUlpSWlKeWFreGNpWWlJaUlpSXlLa3hjU1VpSWlJaUlpS254c1NWaUlpSWlJaUluQm9UVnlJaUlpSWlJbkpxVEZ5SmlJaUlpSWpJcVRGeEpTSWlJaUlpSXFmR3hKV0lpSWlJaUlpY0doTlhJaUlpSWlJaWNtcE1YSW1JaUlpSWlNaXBNWEVsSWlJaUlpSWlwOGJFbFlpSWlJaUlpSndhRTFjaUlpSWlJaUp5YWt4Y2lZaUlpSWlJeUtreGNTVWlJaUlpSWlLbnhzU1ZpSWlJaUlpSW5Cb1RWeUlpSWlJaUluSnFURnlKaUlpSWlJaklxVEZ4SlNJaUlpSWlJcWZHeEpXSWlJaUlpSWljR2hOWElpSWlJaUlpY21wTVhJbUlpSWlJaU1pcE1YRWxJaUlpSWlJaXA4YkVsWWlJaUlpSWlKd2FFMWNpSWlJaUlpSnlha3hjaVlpSWlJaUl5S2t4Y1NVaUlpSWlJaUtueHNTVmlJaUlpSWlJbkJvVFZ5SWlJaUlpSW5KcVRGeUppSWlJaUlqSXFURnhKU0lpSWlJaUlxZkd4SldJaUlpSWlJaWNHaE5YSWlJaUlpSWljbXBNWEltSWlJaUlpTWlwTVhFbElpSWlJaUlpcDhiRWxZaUlpSWlJaUp3YUUxY2lJaUlpSWlKeWFxNk9Eb0NJaUlpSWlNb05DWUE2SmY4UE1MSHR3NUl2QllDN2RveUpLZ0VtcmtSRVJFUkVwRThBZ0NnQUVRQWlpb3VMLytMaTR1SnBRM3ZYQVp3dCtVb3UrU0l5UzVVWEwxNDRPZ1lpSWlJaUluSU9NUkNTMVJnQWpmUnRrTEF0RVFCdzh1VHZlUGp3b2NHRzJyUnBCYWxVaW1ZaHdXZ1oydHpRWm9jQUpKVjhaVm9iTkZWOFRGeUppSWlJaUNxM0NBQlRpNHVMKzJuM3FDWnNTOFNlUGZ0dzR0UXAzTTIraTl6YysxYnZwS0YvWXdRMWFZTFFscUhvMmFzSG9ycDAxTjdrSElBbEVKSll3eGt4VlVwTVhJbUlpSWlJS3FlUkFLWUNDRmMrY0Q0MURSdlhmNGYvN3QyTHRQUlV1KzVjS3ZWRnEvQUk5SXZwaTNFVHhxb2VMeW9xZWx5MWF0VkVBSFBBWGxncXdjU1ZpSWlJaUtoeUdWbFVWQlJYdFdwVmZ3Q1FaOHNSdjJvTjR0ZXV4WTJzREljRUpKRlVRK1JyN1RGOStzZmFQYkhiSVNTd1p4MFNHRGtOSnE1RVJFUkVSSldEUnNKNlBqVU4vemQzSG5iOWR6Y1VpbWVPamsybG9YOWpqQjAxQ3AvTW1xNys4SHFVd3g1WVZ6ZjNDSlRPRzFhWENhRTRWVkpoUVQ2SFJadUJpU3NSRVJFUlVjVVdBV0h1YUNkQVNGaW5mendEK3c3dWRXeFVKa2lsdnBnNmFiSjJBdnNaaEFUV3FaVWtyS3JYM0lpOGt1MldNSUUxam9rckVSRVJFVkhGTlFmQXA0QXdKSGpXekZpczNiakdzUkZaU0NyMXhmS2xTekZnWUgvbFE5Y2h6TTlOZGxSTXhyaTZ1VThGOEtYYVEza1FZbFVmN2h3RHRibkZFQXBUalN3c3lPZVFhQU9ZdUJJUkVSRlJGSVJlT1c4SWEzY0dsRHllV2ZMMUVLVnJiMUw1RUFGZ0hVcVNvMVVyNHZIUmpPbE9OU1RZVXErMGZRMHJ2bG11dnJTTzAvVyt1cnE1THdFd1JlMmh6MkNnTjlYVnpUMEF3amxTOXNybUFZaGk4cW9mRTFjaUlpS2l5c2NiUW85UERJQytGajUzTzRUbFN0YUpIQk9KWjJSeGNmRlNGeGNYVDNtMkhESDkzOExKVTc4NU9pWlJTQ1RWTUhQNkorckRodzlCZUI4N2ZKaXRxNXQ3RElDZlNyNDFPd2wxZFhOZkIyQkV5YmZuU3A3bjhPTnhOa3hjaVlpSWlDb1Bid2pyZFg2Z3ZsNW44b0hET1A3YmNXUmtaQ0xyWmhadTM3a0xBS2hYdHc3OEcvaWpUWnRXZUszOTYrbzlYU2d1TG43azR1THlKWVQ1ZWJ6SWRoNnFIcitFYllrWU5XNXN1ZTVsTmVTVnRxOGhLZkVIeVB4a3l2ZGlKeml3OHJDcm03czNoTkVKWGlVUGRTNHN5RTh1R1Ric3JiWnBCSVRQU3lhRXdreG5TNTZmaE5LYlNKOFZGdVRQS1lPd3l4VW1ya1JFUkVTVnc1eWlvcUlQcTFhdFdoTVFrdFVWSzFZaStjaGg1T2JlTjZzQnFkUVhVUjA2NHYvTm5xVktZa3VTaGlsZ0Q2eWplVU5JV2tjQXdQaXg3NVc3dWF5V2trcDlzWFhUSmtSMTZhaGMrL1Y5T09oOXFEV3ZkWDFoUWY3SWtzZE5KVnVqQ2d2eTEya2x2bmtBR2hRVzVEK3hVN2psRWhOWElpSWlvb290QU1MUTNuQkE2SVdiTysrZlNFdFB0YWxSUGZNTm5XYklaaVhrRFdIK2NiZzhXNDdodzBmWnBXSnd5eWIxOFdxSUp3SnF1NkJKdldJRStUOUQ4MGI2VDNmYWRXOWN6cXFHcTdkZGtIbXZHQ2N1UHNMNXE3ZEVqMGtpcVlaL0xWeUVjUlBHS2g4YUJRY2tyNjV1N3BrQUdwVjgyN2l3SUQrejVISDFaT3NjaE0ramw5cGoxd3NMOGdOS3RsV2ZIOXV6c0NEL0YvdEZYUDR3Y1NVaUlpS3F1Q0tLaTRzUEtlYzYyaU9oNmQ5M0FKWXRXd3Fabnd4RlJVVlpWYXRXN1FNSER0bXNoRFNTMW5hdmQ4Q05yQXhSR3ZhcDVZbk9mNm1MQVpFdWlJbThMVXFiU1VmckllRm9NUTcrN3c1eUhqd1NwVTBBaUl1TlU1LzNXcWJKYTBtUkplV0xya3BFUzM2bW5teDFSc2tRWVdoV0ZHNWNXSkNmNmVybUhnWGdZTWxqL3lnc3lGOWdwNURMSlZkSEIwQkVSRVJFZGpFU3dGb1hGeGNrSHppTVB2MWk3RExYTVhGN0FuNC9jd2J4MzY1RVZKZU8vaVdKc2tQbkcxWXlTUkF4YVpWSVBOQXh3aC9UL2xZRkhjS3lBZHdWSlVpbG1NamJpSWtFZ0NvNGt0SVVpMzk4Z2NObnM2QlFQTGVwM2RpNFdBQlFKcTlyU3g1ZVoxT2o1Z3RRKzMrbWtlMGl0TFlGaEdIRnl1ZW9QN2V1alRGVk9PeHhKU0lpSXFwNElnRDhEd0FXekZ1a3VxaTNKNG1rR243K0tRbFJYVG82UmJHY1NtSUpnQ2xpSkswU2lRZUdkZy9Fbk9FNWtIblpsa1JhU3A3bmdUa2JmTEJwN3pXYkUxaGx6MnZKbk5lT0tJUDNvRlpQNmFIQ2d2d290WjhaUzdhMkZ4Ymt4MmkxcGR6KzM0VUYrVlAwUEtmU2NuRjBBRVJFUkVRa3FvRGk0dUpEUU5rbHJRQ2dVRHhEbjM0eFNENXdHQzR1THA1RlJVVS9RN09hS29rckFpWHpJWWNQSDJWVDB2cTNMczF3WmFNWGxrMitYZVpKS3dESXZKNWoyZVRidUxMUkMyUGVETEdwcmRpNFdLeGFFWStTSW1UclJBblFmdnFXRkhVQ0FMaTZ1VWM0TWhobnh4NVhJaUlpb29ybExJRHc1QU9IRWQwenVzeDNydDd6Q3FGZ1UxU1pCMUU1SkFQb1pNdk5pWlpONnVPTENkVktoZ1E3ajdUcjNoaXhzTkRxWWs0U1NUVmN1M0laTWo4WlVFYnpYZFY2U3ZNS0MvSzk5VHdPQ0hOY0ExQTZsQm5RTE02a3ZnN3M1TUtDL0dWMkM3Z2NZbzhyRVJFUlVjVXhCeVh6SGZ2MGl6RzFyVjBvRk04dzlwM3hrR2ZMQWFBVGhMbTJKSzRvQUozazJYTE1YMlJkL1o0eGI0YmcxTmRQUkVsYTA2NTdJK2xvUFNRZHJZY2pLWDQydDllODBVT2MrdnFKMWIydkNzVXpEQjgrQ2dCUVZGUVVaM05BNXRsZThxOVh5ZEJodlFvTDh0Y0JXS3IyVUtPUzRrNkFVSlZiaWNQc3RiREhsWWlJaUtoaUNDZ3FLa3FwV3JWcXpjakl6amg1NmplSEJ0Ty83d0JzM2JaSk9kKzFFYmhNanBqV0FSaGhUVytyUk9LQm4vK3ZvVlVKYTlwMWIrdzZVUU5IemovSGJmbWZKbnRFV3phcGozcXlsOUNocFFkNnZmckU0Tkk1eGh4SjhVT2YvM2ZEcXJtdlozNC9vMXl1eWU2OXJxNXU3aU5SMnBPcW11ZXEzZU5hV0pDZlhESWsrSDlxajQrQ2tLZ3FIOU9vVEV3Q0pxNUVSRVJFRmNNNkFDTVN0aVZpOExBaFZqY2lsZnFpamw4ZFBIbjZ4T1lLdFdxSncyY1Flb05KQk1YRnhYa3VMaTZlVFpxRVdIU09BdXI3NHNpU0toYk5ZMDI3N28ydmY2NkdwS08zYkY2K3hxZVdKMklpNitPOVBvYlhmOVZIbnVlQkRsTmZJUFBXZll2Mk4ycllhS3lNL3hvUWVrUHRQZ1RCMWMwOUdjSW9Bd0Q0b0xBZ2Y0bFc3K3Zad29MOGh5WGJxai8rRU1MblY3bEVUci9DZ3Z3a2U4WmFIakZ4SlNJaUlpci92QUU4QUlDSThMWklTMCsxNk1sU3FTK21UcHFNc2VOR0srY0ZxcXhhRVkvMTMyMnlxZ2UzVytmdTJQWExEbVd2cTVmRkRaQStFUUQrZHo0MURhM2F0REw3U1pZbXJVbEg2MkhwVDMvaWVHcW1kVkdhMEM0MEFGUDZ2V1QyK3JEV0pLOE4vUnZqNnRXTHl2ZmZweERtQmR0dENHN0prTit6QUpUdjlROEtDL0tYbUhpT2FoM2Vrb2ZXRnhia2o3UlRpT1VhNTdnU0VSRVJsWDhqQVNCaFc2TEZTZXVvWWFOeDkwNFdQcGsxWFNkcEJZQnhFOGJpNk5HRDJMSnhNeVNTYWhhMXZlL2dYcHhQVFlPTGk0c255cURIcTVLSUFvRC8vUHdmczU5Z1NkS2FkdDBiYmQrcmdjRnhGKzJXdEFMQThkUk1ESTY3aUxidjFVRGFkZFBGcDJWZXozRmtTUlVFMVBjMWV4ODNzaklnejVZcjMzOWZRaGlLbXdsaEdhRUFxd0kzb21ROTFpZ0FlU1VQZmVucTVwNnNiODZycTV1N3Q2dWIrNXlTZUppMG1xRlM5TGkrU0tuaURlRVhlaFJZbHAySWlLZzhlZ2dncVVyWWkzV09Ec1JKblFVUTNxdkhtOWgzY0svWlQxS3VlV211NUFPSDBhZGZEQlNLWjJZL3A2eUhhMVlDY3dCOE9uN3NlMWk3Y1kxWlQ1Zzd0Z1dtRGJ4cGNydEpYOVhENmgwWHpXclRwNVluNnZyVVJJMlgzTkFpNENYVjQxbjNDM0JiL2llZS9KbHZVZS9vbURkRHNHeXk2ZDdYSXlsK2lKNTJ4ZXgyRy9vM1JwdFdyZEMxUzJmMDZ4K2pmWE5tTzRUWFU5UmUySkk1ck90UW1wQUNRaktyM0krMzFzOEFZR2xoUWY1VWtFRVZQbkV0U1ZxVG9mdm1JQ0lpb3ZMbkVJQ1lLbUV2V09pblZBMEFqd0hBMDB0cWRsS3BMSjVrS1V2bjBHb04xK1J3WWR2TmdZV0o2NWJZRUtORGN0T3VlMlBBbkdkR0U4MkErcjdvMmtxR2JuK0IyY043QVNIUi9PL3Y3amgyNGFuSkh0eUErcjVJbUZQTjVQelhsNkx6alA3Y21GZmF2b1kzZXZiVXZtR3pGTUxyS3VydmxaS0NUWE1BTkRLeTJYWUFjd29MOGxsRjJJVEtrTGl1QXpEQzBYRVFFUkdSYUpaV0NYdkJub2xTRVFEK1o4bTZyVnJyWEZyTTBwNWR0U0pOZndHWCtiRFZIRmlZdUM3L29BVkc5OVRmNDVwMHRCNUdMYnFtdDJxdlJPS0JvZDBETFM2bVpJZzh6d1ByL3V1TEpRbFpCZ3M5U1NRZVdEczkwR2h5YkV2aXFxU2MxNjJXd0Y2SE1DSkE5UGRuU1E5c0JEU0hKeWREclZnVG1WYWg1N2lXOUxZeWFTVWlJcXBZUmpvNkFDY1RBUUM3ZC8xaTloTjYvYlduMVVrckFFeWYvckZGMi85MjdGZmxmeU9zM2lsWjdac2Qrbk9qeGRzYVlIRGNSWjJrVlNMeHdOeXhMZkRnWndtV1RiNHRTdElLQ1BOVXB3MjhpWnZmVjhHVzJCQzk4MVVWaXVjWUhIY1JpN2MxTUJpekdISno3eU0yTGhZUjRXMXhQalVOQUJvVkZSVWRoaDErdnhRVzVKOHRMTWhmVjFpUVAwZnRLNWxKcTJVcWRPSUsvbklrSWlLcWlMeGMzZHpuR1BpYVdsTFpzektwQVFEWGIxdzMrd2x2L1cyQVRUdU02dExSb2tKTnYvOStSdm5mQUp0MlRDcmUzdWFYYlRsLzlSWTZmMVJMVlFSSm51ZUJTVi9Wdyt6NEN6cmIvcTFMTTF6WjZHWFduRmhieEVUZXhzVzErWmc3dGdVa0VnK2RuOCtPdjRDK3NiNnFtTk91ZTJQU1YvVXc3N3Vyb3NhUmxwNksxeU1qc1dwRlBLcFdyVm9Ud2xxc0kwWGRDWW1pUWc4VmZwRlNKUXJBUVVmSFFVUkVST0p5YSsxbWFwUHRBS2FXVlBtczZKWUNlTitTWlhCdVo5MjBxY2NWc0d6WkhiVUNUVnpQMVhaUkFBNWFNalRjSEQ2MVBMRmxWbTEwQ01zV3JVMXp5Zk04MFBNZmJqaC85WmJlbndmVTk3VjREVmRyYUJVcjZ3ZUFhNms2RVZkSEIwRGlpMXNaaXR4SFZWVGZML2s0eFlIUmlHdEViRXVjLzZPMDZNVHBUZGNjR0UwcFo0MkxpS2dDNjJ6ZzhRZ0FVd0gwQlJEbDZ1WStzckFnbnhlZldteE5XaTExSVYxVnFUYWdUSGRjTVowRlNudTlMYW53YkVpNzBBRDhFUHNNTXEreVQxb0JZUWp4cWErZlk5SlhJWHFyR3BkRjBnb0FzWEd4QUlCUFprMUhjWEh4ZWhjWGwzQUl5OVdRRTJEaWFvVDIzZHlDMHdVNjI3UWVHb2lVOUN5cjk3RmhibU1NN25YWjZ1ZnJzLzN3VTQyWWx1aVpobUxPc1lsQjdQMmMvK09aVGErM3ZUaHJYR1Q1alp5eStteFVWaFg1eHBwWXNuTWtXUEZqVXh3OC9SeS9YN2dEaFVJQkFKQklKQWdLOEVYTGw2dGhlSzhuNk5vdTAyQWIrdjQyNlhzdjYrdTFuRGdveE96ejB2bWRJQnc5bmFIeFdGaXd2ODdOTzF2M28wOWhRWDZ5Z1I4bEExamk2dVkrRmNLNmpUKzV1cm4vaFJVN0hldko0eWZLL3dZNE1JeUs0aUdFRVFWOWUvMjFKeEszSjlqVVdIUzdKdGdlWjNsaW1IYmRHNWV6cW1IZi8zUi8xcXFKQzVyV3o3ZTQ5M2JaNU5zSXFOMUM3eERtc2hJYkY0dDJyN1ZEVkplT25oQjZYRG4xMEVrd2NTV2lDczJjR3psVWRuZytqTnV5S3dqdnpMc0RoU0pkNTJjS2hRSXA2VmxJU1FjMjd3UmtQakxNR2xVYmt3YUxlNEczT2lrRG8vdElFZFlzMTJTczJrbXJNeWtzeUYvaTZ1YitFTUo4dFNRd1lhS0tKUWxBMy84M2U1Wk5pYXVsU2V1UkZEOTh1OHNGQi85M0J6a1BETStwWGwzeXIwVGlnWTRSL3VqN21vZkJxc2JhaExtMWprMWUrL1NMVVZiZERvY3d0SDJPdzRJaGxZcGVuSW1JaUtoY1dMYWxCWWJQemxEMXNKb2l6OG5EQjRzdm8vTTdRYUxHb1ZBb01Dck9lTkdYN0J3SlBseGlQTEZWRnhic3IvUFlxeTNNTzA1YkZCYmtyNFBRTTlXb1pEMUZvb3BpWFZGUlVWYkwwT2JvMzlmNlFsdXJQOUsvSkkyMnBLUDEwUGE5R29pZWRnVS9IcmhrY0NrYmJRckZjK3c1ZmhVVHY3eUFCbSsvd0tTdjZwbjF2R2tEYnlLNlhST3p0clVIaGVJWmhnOGZCUUFvTGk3K0FJRDVsYkRJYnRqaktyS0pnMElzMnI3RnkvYXQyR2FJYnB6MkdhNVhWdnNoRWd2ZnMrUUkyVGtTL0dQWkRhdWUyN0NPdThqUkFDbnBXVmkycFlYQjN0ejVhNElnejlHZGgrYWtsUE5kUndKWTU5QklpRVJVdFdyVldBQnJseTFiaXVRamg1R2JhOWx3MzRENnZwQjU2YTdkcWk3dHVqZEdMQ3pFK2F1MmY5NXpIanpDNmgyUGtIVFVFOHNtMXplNlRpc0ErUHVhTE1DbW82Ri9ZOVNwVXdjdGdrTndJZjBpbmp4K1luWUJNVzM3RHU1RndyWkVEQmpZM3hQQzc1RTVWalZFb21IaWFzU0d1WTIxSGpFOUY3Vzh6TmNxcXpqTHkrdEJwTVQzTERuQ2loK2I2Z3dQbHZsNDRkMEJkZEhVWDdpd3ZKTGxnWU9ubjJzTXp3M3c5OFA2dVBOMmlXbmUybnNZR0MyQm40OW16MmpLSlNtV2I3WHNJdGF6dXU3bGh0ajFIUXdwTE1qUGRIVnpQd2VnVTVuc2tLanNyQU13VXVZbjY3UjEweWIwNlJkalVhR211em1QQUVnTS9uenh0Z2FZOTkxVm5UVmViWlh6NEJFR3h6M0MzN28wdzhaUDdvclNacmZPM2JIbzg0Vm9HZHBjNTJmeWJEbG16WXpGbGgrMldseklhdTY4ZjJMQXdQNG9MaTcrd01YRlpRbUUrY1hrSUV4Y2pTaXJQNnI2Wk9kSU1IOU5FSTZjZmFLYUR5Yno4Y0tyTFgzeGRyY2ltMk5UTDVTaHI1Q0d0cmlWb1RoNCtqblNNM01oejhrRElGd3d2UjVXeTJpUkVFdjJzLzk0QUw3YTloSk9uTCt2MmtkWXNELzZkcXlPMlBIbTN5MVRGalk1YzZrUVdmZWVhOHlucytZMUZDc3U5ZmpFT0xkVFB3L1RhRU1pa2FCTmk3cm8zTm9ERS81MlJlZGkwMVpUUHcvVHVGZzFWVmdsTzBlQyt0RkZxdThEL1Axd0phbTB6SDNLSlNuVy9Od0E1NjRvY0RQN0tUS3pzalcyZlQyc0ZqNGFldHZrUER0RFNvdlRhQmFvMFM0U28xMGd6WkwzckszblV0KytsRzN1UEphamVrMEMvUDNRdTcwUFpvNitiUEs4T3V2N3k5cnpvVjFreUZpeExFdC9yNW1TY2ttSzJKVzFjZUhhSTlXNUVQUDNzTG96bHdwMUh2dnZWOFVJYTZiNU95WldMYTZkaDY1aXhTZVc5MGlZUzU2VGg0K1hOdE5KaklWaHhJOHRhaXU4cVFSSFQ0c1luT1Y0c1VrVjFjamk0dUp6VVYwNmVxNWRGWTlSNDhhYW5ad3BGTStSZERSUWI4L25zQVYxOE9NQnczTk1BK3I3b2swektScjV1YUpOVUxIT3o2L2Vka0htdldLY3VQakk0QkkzUHg2NGhQUWI5Ykg3bndWNmUzNVBYRFE5SEZraXFZYTFxK0l4WUdCL2c5dkkvR1JZR2Y4MUprK1poSmgrQTNBankveTUrV25wcVRpZm1vYVdvYzA5QWNTQW96WWNpb21yQ2Z1UEJ5QTcxeDFkWDcwaGVpSmdTTnpLVUh5K0lSTUtoZVlkYlhsT0huWWV5c1BPUThDM1NVSDQvcC8yajJuLzhRRDhQZllKNURtNmhVSXlzN0tSbVpXTnpUdUIzcDFDOE8yc0RLdmpHUkhiRXB0M1h0SjVYRm1JWk9QdStraFkrS2ZKZGxJdVNkRitkSUhld2lhQTVtdTRlRk1nZHYvN3R0R1l4WXBMU1l4em01MGpRZnN4UHNqTTBteERvVkRnNk9rTUhEME5mTDVCZ2pFeFFhTDJIbzd1Y3hQTHQ1Wit2L05ZanRIQ09pdCtiQXFnOUR3TTZ5a0ZJUHp4V3JhbEJUNVlmQm1BL2w0YjlmZldrTjR0N2RhalpBdDdmRTczSHcvQWhBVUZPdWMyTXlzYnk3ZG1ZK2N4UHh4Ym5XT3d2Zkw4L25JMnBaOTl6UVROWHIrSHMrN3BYclRWa2VtLytBeHJsb3VrTDNLUmNrbUtzR2FaTnUvYm1NMDdMMkY0cndEVnpjbTRsYUZJU2RmLys5VVNNaDh2QUhLYjI2RnlLUUpDNVdkVFBlQ0hTdjVOaHJBY3lkbVNyL0ltb09UTEc3clZhWlUvVTByVyt2bERDTWVzL0ZlZlRCY1hsMDdGeGNXSEJnenM3K2tqazFuVTh6cHEwVFVBcGNtclBNOERZLzdsaVQzSGRhOTlmR3A1SWlheVB0N3I4d3pOR3owRVlGNXZxVHpQRCt2KzY0dlZ1N04xbHJVNWYvVVdPa3oxeGNjREc2aUtONlZkOThiRWYxZkIrYXVaUnR1VlNLcmg1NStTRU5XbG8xbHh0QXh0anVPL0hrRzcxenRZbEx6KzM5eDUyTHB0RThERTFlR1l1SnJRWTZKd29XMlBaV3YwaVZzWmlybmZtcjRvT0hvNkErM0hHTCtJdGRXeUxTM3dqMlUzekNvVXN2UFFWYlMvWmwwOE1SK0dZT2NoM1YrUTZqS3pzakZnaGg4QTQ4TlZ3cHJsb2taMW1Wa3hwNlJuNGUxL05NYkJiL1dmVnpIakFzUTd0ejNmcjRmTUxPTkw3eWdVQ2h3NSs4VG9OcFlLYTVhTHlOYWxWVVF6czdLeC8zaUF3ZDcyZzZjMVg1TUpmN3VpK24vSFZuZk0zdS9tblpkUXEyYVlVeVZKOXZpY1BucjZISCtQZmE3cTFkY25NeXNiUGQvWDM1TlkzdDlmenFScFRIMWtaaG4vN0FQaS9oN1dONVQyblhtTkVUZituc0ZSQjlhT1JyRFU5SzljY0xxZGNGUGo4dzJaR2orVFNDUm1GNU5TVjgvWEUweGNLeTB2bURkc3U1UFd2eWd1TG43azR1SnlFRUpGM1NRNFYwOTZBSVRFTkFKQVZNbjNqU3hzdzlUcmNnNUNFcDljOHFWTVpzOHFrOWVvTGgwOUkxOXJqMzBIOTVxMVE0WGlPUWJIWFlSRTRvRTZQcDdJdkpVTlFITUpHNG5FQXhOam11RC9SdDhFWUh4ZXFqNHlyK2VZTnZBbXBnMEVrbzZHWU5KWHR6U0tPMlhldW8rSlg5NUg3RHBQMUt6bWdjeGJocXNWcTVzNS9ST3prMVpWTEg0eXhIKzdFdEU5bzgxK1R2S1J3d0NBNHVMaXppNHVMaEVvbnpkUUtnUW1yazVrLy9FQWpRdFBpVVNDajRjSHFJYmxMZHZTQWt1L2Y2Z2FzcGFabGExM0dKZFlzV2duclRJZkw3emR2WjZxRXVUMys2cGkvNG1icW0xYUJIckN6MGYvY0JCRDRsYUdZdWNoell0dDVURGNwdjdQa1pQbmhuMm5pckh6MEZXTm9hVEdSTGVyZzgwNzh4RFp1akhDbTBwVThWN0o4dEJaaXVQbzZReHMyUldrYzFOQzdMakVPcmY3andkb3hLOCtYRmM1OVBiN3ZiY2h6OG5Eb3NtNlEzZHMxYm0xaDhad3Z3MjdhcUJyTzkzdHNuTWtHdlB3SWxzM2hwOVA2V3NjMWl3WEFmNzFjZmYrSTNSOXRRRmFOWE5WemVNN2NVR2lPZ2FsMVVrWm1EbGFkNjZkTWNya3p2UlFVOHR1U05ucmM2cmNYaUtSb0gvWFJxaFYwd1VQSGhjamNmOTFqYzloU25xV3pudTJQTHkvN0hVK3hEWWl0cVhlcEZWWkZWZDdiVlN4ZmcvckcwcTc4OUJWN0R3RVJMWU9RbmhUQ2Q3czhNam8ycTFpMEhlY0tlbFptUHA1R0I0OExvWkNvZm5haklscGJOWjgxMWRiS0xCYzNGQ3BuTG1iZlJmang3NW5kc0djNXNHaHFGR3pCbG9FaDZCTm0xWjRyZjNyeXVHYWZVdSsxa0tvR0owRXgvU0NCVUJJVUpWZmVwUFU4NmxwdUhReEhibTV1Zmo5OXpPcXgvTWU1U0g5a3U3dnUxZmJ0bFg5djNIakFEUnQyZ1ROUW9LVmN6ZkRTNzc2QXJxSnZJdUx5NmNBdnV6WW9ZUFppYXVTUXZGY3B6Y1VBTnFGQnVDSDJHZVFlWWxUVERRbThqWmlJcXRnMGxjaFdMMUQ4M2RIem9OSHlIbGdYanNOL1J2amsxblRyWW9ocWt0SGRPdmMzZXpYS0RmM3Z2cHc0ZjhCdUE3aFBiY093bzBFS2lOVlhyeDQ0ZWdZN09aRlNwVW9BQWR0YVVNNVo4cFFqNnNsODY5TTBXN3JsK1gxZFM1U1NvZnhsU1pMcHpmWDFManpiazVNcHVhQ2FiZlJ1MU1USkgyaGUzR2lITnJZSXRCVDc4OU43YWR1dEV3alFSblNXLzhGb0tIZUpIM0hsbkpKaWpxeVp3YVRITzNodi9xT1RleTR4RHEzMnZOTURiM2ZqRlVEdFZYTjlqVlZpWlRNeHd0Mzl1ajJtbWkvTGw5T0M5S0p4MWh2YlhhT0JEM2ZyNmZ4bXMxK0o5aXFPY1dXZmtZdC9XeFlleTYxOXdVSWMxbTFlKyt5Y3lRSUgxeEQ0LzJvUGIrNFBMMi9MRDBmWlRuSE5lV1NGSzJIYUE0TmptemRXR000c0w3WEVkQi9maTJSblNQQnkzM2NUUFplbWp2SFZ2dDFBMHovTFFDRTEyM1I1R0xWYUNNbGZUMnJ5bm5yK3RyUWZ1MjM3QXJDOE5tbE43Tk16WkUzUjVXd0YxWE0zZGJWelQwWlFLZkNnbnl6bjFQT0xBWHdma1I0VzdNcnFPWS90MzIwbGlYN0U0TlU2b3VvRGgzUnRVdG5qSnN3VnZWNFNRTDNKUUI3Rjg4SmdEQmNkQ1NFQkZKRHdyWkU3Tm16RHhmU0wrTHUzYnNXRFVjMVIvUGdVQVEzQzBKRWVEamU2UE9HdmtKRTV3Q0V5N1BsQ0d3YVpIRWhJbTBmRFdwUjBzdHFIMGxINjJIVW9tdFdGWC82WVBLSFdMaDR2dFg3VGo1dzJLSmUxMjZkdTZOamh3NFlPMjQwWkg0eTlSK3RoMUJ4MkpsNi95c3NydU5xeFA3akFhci9uN2hndU9xYU9yZldibVo5dFI0YXFMTXY5WXVNSWIyYjZiMm85L05SSU82ZDZocVByZm01Z2ZrSFpRYnRXQUw4L2ZRbXBRRFF0VjBtanEzT01maHpZN2JzQ3RLNEdBOEw5amZZYXhFN1B0WHNwWWJDbXVVYTdabjdmTXBWU0NTbDUxTjdicG5ZY2RuejNNYXRETlg3dUwyU1ZnRG8zN1gwcHJJOEp3L0x0clRRMlVaOW1MQkVJdEViajdHZUl6OGZCYVlOMVJ3UWt2dkk4ZGViOXY2Y0ppejhVK2U5NitlandMc0Q2bW84cGo1TXQ2Szl2eHdwZG1WdGplOWxQbDQ2YzFqOWZCUTR0anBINDNjSW9QbGFUdjA4ekt5L0ErcjhmQlQ0NTZTR091MXFFK2JZWHNYdzJSbG9QVFJRNCsrVVdMcTJ5OVQ1dmFZdm9iYWtNSlNmTk4vbXVJaHljKzhqY1hzQ0prNlpCRTh2S1FZTkhJcnpxV2x3Y1hIeEJQQnBVVkhSRFFoTGxvaTU1cVkzaE1Ua0xJQU1BRitpSkdsTjJKYUlRUU9Ib2ttVEVMaDdTREI0MkJDczNiZ0dKMC85Sm5yU0NnaUZnaEszSnlBMkxoYXQyclJDbmJyK0dEUndLSklQSEZadUVnNEl3MkVqWDJ0djA3N21qclZ2MGdvSXZhOC8vMTlEU0NRZUZqKzNaNjhlTnUwN3FrdEhTQ1RWek41KzM4RzlpSTJMUlQzL0JvaU03SXlFYlluS0g0MG9MaTYrRHVHR0J0a1pFMWNqc25QRlh4dlBrQjFIUERXK0g5N0w4UHl4d2IwdWx4UzJFSnk3SXU0Y1YrMVlwcnh0L1BlL3RYTzd0RzhHakhyakphUGJ6eHd0emhCQ1B4OEZnZ0o4VmQ5cjkwcUlIWmVZNS9iTkRwb1Y5dVorbTQ3V1F3TVJ0eklVMlRubTNWeXgxVWRETmVlMzdEdWxPV1JVZTVpd2VxSnJDZTNlSkdlWVUyblB6Mm1BdjUvQkhqdjErY0gyak1rWjNsK09kT0s4NWpDNTZIWjE5UDUrOC9OUjZMeXZ4WGgvVGhwOEFjZld1S21HNjVxU2twNkZIaE55aERBM0FBQWdBRWxFUVZSdkdiekJZSXNsSDZjZ3dOL1A0TThuRGdxeGFOaXk5clpTejRvNzJvdktoa0x4REluYkU5Q3FUU3RFaExkRndyWkVWSzFhdFNhQVQwc1NpWkVpN0daT1NWdGZvcVFuYzhHOFJZaU03QXhQTHlrR0R4dUN4TzBKZGtsU3phRk01S043UnFOT1hYK01IL3NlNU5uQ0tLZ05HOVphbEppcEcvTm1DS1lOdEcvU3F0UWhMQnRycHdlYTNsQ0xwWE5iOVFrTWVObXE1NTA4OVJzR0R4dUNpUEMyU0Q1d1dIbmo1Q2V3Y0pQZGNZNnJrOUMrZ054eHhCTTdqb1FaZVVacDhwQ2VLVzZCRHUxWUJrYi9JV3I3U3RvWGVxYjI0K2VqUUZpdzd2QTNiY3JsY0xTWDc1RklKQWdLOEVYTGw2dmg5bjNEbGZERWprdk1jOXUxWGFaR2dTU2d0TUx4NXhzazZQcHFZOUdYNmRBVzFpeFg0M2ozbjdpSjdKelMrYWZhMVlRTkpWTEtPWk5Iemo3QjVjejdHc09QNi9sNm9rTkVEUmlxT3V3bzl2eWNlbFkzZk1kWmVHMzE5MjVWdFBlWEkya1h4dHE4OHhJMjd6VFVxNmc1MS9OeXB1N2NNR3VFTmN2RjZVMjVHcDhQVTcvelB0K1FpUWwvczJ3T3VEbFdmT0tHSGhOMUh3L3c5N041bUs5eVRqdVJHTkxTVXpGNDJCQTBueGVLSlYvK0MxRmRPbnBDbUFNN3N1UXIwOEltb3lBa0lZMWNYRnh3UGpVTjB6K2VnYU8vSGJONStLMjk1T2JleDlxTmE3QjI0eHJWbXFidmpwdUFMNy82d3VLMnV2M0Z2TzJPcFBqaDIxMHVTTC94UkdQSm00RDZ2Z2p5OTBMZjF6eFVsWUtOaVltOERaOWFuaG9GbThxRHRQUlVSUGVNeHFoaG83RXkvbXNBR0lIUzRsd2NPbXdIVEZ5TlVPOTVNL2R1dXJuRFdiWHZOajk2cXJtR255V0x1eHVyUW1vTjdWakthaGtnTWZaamJQa2VoVUtodWdndnk3akVQcmNIdjcyc2Q1a2VoVUtoS3VaaTcrV1MrbmFzcm5vZEZRb0ZWdnhZT3Y5VWZaaHdnTCtmM2w0WlE4dTJBTUl4eTNQeUxENVBaY0daUHFkS0ZmSDlWUjVaVTFuWG1MQm11Vmp5c1hCaklUdEhnbTE3WHNhK1U4VWFCZkhVOXoxL2plMXpSclVKUTRiRGRONVQxcTRkSy9QeFVyM25PSFNZN0VHWlNQVHZPd0RMbGkyRnpFL1dxYWlvS0tWcTFhcnZ3L3plc0trUWVsaFZDYXVsaFk0Y2JkL0J2V2pWWmk5R0RSdU5odjZOUmU4UlRqcGFyNlF5c1A3UlFKbTM3aVB6MW4zc09RN0VydlBFeUwvNm14eDJYTE9haDltRm1aek4ybzFyY09MVUtlemJ1eHN5UDFrNGhJclBVV0R5S2pvbXJpSnpwaVU3eEtMZW0rYk0rOG5Pa1NEbW94eU5pN3JlblpxZ1cxc1grSGdKUlVtdVpIbmdqMXN2c09mNFhiTVRpYkk2Zmt1c2p6dVBqNFpLOGE5TjlmUWV5OUhUR1FhWFRSRkQ3UGhVZkw2aHRFalR3ZFBQRVF2ZFljSzkyL3RBdVhhcjBwWmRRVG9WY1B0M2JZUWU3VW92WkU5Y2tDRHpUb0hlaTNTeVAwZS92OHE3VjFzb0FMTnVZcHIzOThMUFI0RkpneTlnMG1EaE0vYk92Q2JZZWVpcXhqWmlUeGxSV3ZKeENyN2ZXMXFzVHBoRGJWMEY1WGNIMUVYdW8zb0FnSzd0S3Q3ZlNuSWVpZHNUa0h6a01KWXZYWW9CQS92WGhORDdHZ1hUdzRmWFFlZzF3NEo1aXpCLzBRS243V0UxeDlxTmE2eDYzdStYWFJBVHFmdDQ2UnF2NXQ4Z3pYbndDUC9hZWdFSlIzeVJNS2RheWZxdnV1MEt5L0NVWDJucHFXajNlZ2NjLy9XSU1ubGRCODU3RlIwVFZ5ZlJJYUtHUmcrVHJSVXF4WXhsMjU2WDdWS014ZEw5Wk9kSWpBNlptNzhtU0tNSHoxalZTcUY2cXY3RVZleTQ3SFZ1dzVybFluMmMwTTcrNHdIWXNLdUdSaTlaU25xVzBjcTl0dXJmdFpGcWYwZFBaeURsa2hSSnlmV2hQa3g0ZEIvZE82emZKbWwrbi9Rdkg1MEw0Y0c5aEgvMVZVWjFKR2Y2bkNwVjFQZVhJWVp1SkFsemNJdHNhbHU3Y3E2aGF1S21ETzUxV2ZVZXRrUjJqZ1FmTDIxaWRKOStQZ29rZlhGUnA3aVRkcys3bUw2WUtzWHcyWG1RK1hqaDh5bFhUVC9CQUd1cWdoTlpLemYzUGdZUEc0TCtQdzdBMW0yYkFOUERPTmVWYklOZVBkNHNkNzJzWWxxZWRCVi9iZE1RSGNKS2swbDVuZ2M2VEgyQnpGdlcvUTdJdkhVZjdTZDdZTzMwUU1SRWxrNVpVU2JEMm12SGxrYzNzakxVazllK0VBcUZ6WEZzVkJVTGl6TVprWG1uZE9rQXNlWXZHZEtrZ2VZRmw5aVZnaTJoWGFCbDZmZW1SenBZVTdoRis1algvdWRQbzl2UFh4Tms5T2ZhUFE3R2VyK05EZjBXTzY2eU9MZGQyMlZpZmR4NS9MSzh2c2JqMm9WN3hLUmRwR25OencwMGhnbEh0bTZzTjRINi9jSWQxZi9EZ3YyTkpqN09sTFFDenZVNVZhcW83eTlEdHUzUlgweERtRnR0bTY2dmFyNTJpZnV2Ry8zZHRtV1g4YysrSlpUTDdHemVlUWxOWStvYmJWdGZKV0gvMnBaWDVUVFg0RjZYTWFSM00zd3hWZXAwbzArSVRFbmNub0NJOExiS29rWEtZWnphVlNlbmdrbXJpa0x4SE5IVHJxQnZyQzhtZlZVUHd4YlVRZE5oZVhyWGViVzAzY0Z4RnhFeXloMkx0elZBMzFoZk5CMldoejNIcmI4aDVteHVaR1ZnK1BCUnltOC9oWEN6aEVUQ3hOVUk5V1ZTN0QxY2NkTGdDeHJWUGxjblpSaGQ1aUJ1WlNoR3hMYTBTeXhkMjJWcVZMWE16TXBHeklmNmg3MWw1MGpRZW1nZzJvL3hzVGg1blRUNGdzYlNEeW5wV1FiM0U3Y3kxT1RjUGUwZUIwUHhwRnlTR2sySXhJNUx6SE9yZkwwTlhkU2E2djNhc2l0STQ4c1dRcEdtMHZmSnptTTVHc09FTzdmV2Z5R3QvbGw2OU5Sd2dSWjdWRW9GaFBOdkxXZjZuTm9qSmx2Zlg5WXdkVDZFSWwybGxuNy9VT2V6dmY5NEFEN2ZrR2x6TEc5MzA3d0pvRkFvMEg2TWo4N3JtWEpKaXM3dkNPdVNpblYrMy81SFE5WGFzSmxaMlJnK093Tk5ZK3BqNnVkaEdwL1pxWitISWVhakhKM250MnBtM3dGVTYrUE8yMVNVeTlSeVFFVDJwQnpHZVQ0MURRREM4L01ManFBMGVZMUN5WnhXSnEyYTloeS9pdFU3THVMSEE1ZXNXbXZWa014Yjl6RTcvZ0wySEw4cWFydk9ZdC9CdlZpMUlsNzU3UkpIeGxMUmNLaXdFNWsxcWpZK1dDd01YMVVvRklqNUtBZGpZc0l3dXM5TlZjL1ZzaTB0c1BZL2Z5SWxYUmdibVBja0JOL095aEQ5THJpd0FIM3A5enNQWFVYZGFCbmU3bDVQbUw4RjRKZmo3a2pjZngwS2haQUV0aC9qaDJPcmN5eUs1ZVBoQVJyekhYY2V1b3JXUXdQUnQyTjFOUFYvanB3OE4rdzdWWXlkaDB4WDZ0RWVNdm5Pdk1ZNnI4MldYVUdJL2ZZcGdNZGxGaGNnM3JuOWVHa1RwS1Jmd3ZEWndPSk5RandUL25ZRmZqNktrcmx2alFHVTNyblU3ajBmUGx1elFJTTF3eG5WcVJkcFVsNTBBOEtRUzBQREFzT0MvVlUzRGpLenNqSDE4ekNkM25GbDhTWXgrTmYyMEhoZkRKanhFcWE4M1FJK1hnWDQ1Ymc3aHZkNllsRkM1a3lmVTdGanN2WDlaUTVMejhlckxSUllydmI4ekt4c3ZOeEhndjVkbTZCV1RSZFI1MElQN25VWjMrOEwwWmcvbXBtVmpSNFRnUUQvK3ZDczdvRkhUNStYdk5lRjN5R2JkMTZ5K2Z6R3JRekYwZE82djBzeXM3S3hmR3UyeHZIckkvUHhNcnBrRXBFemtVaXFJVERnWlFRM0M0S1hwNWZlYlU2Y09vVW5UNStJV2xUb1JsWUdYbytNeE04L0pTR3FTOGVXRUhwZVkxQlN0R25CdkVWbG1yUXFYd2VsYTVsL2xPdjV0S1JwOW1lZm9WLy9HTWo4WkowZzNCeEpkbXhFRlFNVFZ5TnUzOWU4S0V1NUpMWHJmTFpKZ3k4ZzkxR29LbUZTS0JSWXZ2VWlsbThGU3BmQzBMM2piWStMNGE3dE1qSDduVkNONUUyZWs0ZmxXL01NWGtRMThLc09RTGNud0pqWThhazRjMG56UXRGUTVWL2xtb0xxQ1pLNjBYMXVZblZTNlJ5MW5ZZXU0dVVURWdRRkNNVkFidDkvQkhtTzhFZFFleTZiUGVNQ3hEbTNLWmVrU054L1hTZWV1ZDhxMnlpQ2VsSWhETU8xYi9FYzdTSk5Tc0tRUy8wOTBhUGVlQWtmcUwyT3k3ZGV4UGQ3WmFqbkt3dzdGWmJHU2RmbzliWkZxMmF1MkhtbzlQdk1yR3g4c0xqMFhQVm8xOWlpOXB6cGN5cG1UR1gxL3JMMGZBenVkUm1MTjJuT2RWWW9GRHBWanlOYk45Ym84YmZXdDdNeTBQNmFuODduMmRqbkc3RHQvTWFPVDBYdW96Q3NUc3F3S2dHZk5hbzIvSHprVnUrZnlONGEramZHZ0poKzZObXJoOFhyYnlac1M4UVBQd3JGbG5KemJSMnErZ3g5K3NVb2s5ZHdBR2NCZUoxUFRjUDhSUXRzYWx0YjgrQlFWWEllSGQwTkFEQmdZSCt6bnkvUGx1TlE4bUZjdVhJVkdSbVpPSEhxRk5MU25XdWV1RlRxaTZtVEptUHN1TkdRK2NsVWo4dXo1WWhmdFFieGE5ZUtldk9ob1g5anRHblZ5dUFORDBzTkd2Z1dNakxhR3Z4NTNxTTgvSDdtakZYSGtKdDdIN05teGlxWHlaa0tKcTZpWU9KcWhIWWx6UXQveU94ZWlFWG9wVkl1RldMOEFzYmF3aUdXeE5MVVB3Z2ZMc2sxV1lIWGxsaVN2cmlvZC9rTmRXSEIvdGo5Nzl2bytYNDl3OXMweThXM3M0THd6cnc3cXRkT3VRU09ra1Fpd2NmREE3RDk4Rk9UOHlmRmlrdkoxbk1iMWl3WHg5WklNU3JPMTJUc0FmNSsyUDN2MjBhM0VZdDZrU1lsN1NHWDZpWU52b0NyTnpXWDJGQXVnYU1rOC9IQ2QzRTEwR1BpTFgxTldDUjJmQ28yN3E1dk12R3d0RTFuK1p5S0ZWTlp2YitzT1IrNy8zMGI3Y2ZvSnBOS1ljSCsrUDZmTjFBLzJxcVFOUGo1S0hBbDZaYkp6ejRnL0Q0WkU5TllsR3J5U3o1T3dlZytVc1N1YktCVE1kZ1FtWThYdnBncXhlQmU0aGZQSXhKRHQ4N2RNV2IwS0lzU05tMERCdlpYUFQ5aFd5SldyMWxyVTgrb1F2RU1nNFlPeGZsei80UE1UK1lGQUJQZW5XaFRiNmRFVWcxaG9lRm8zKzQxcTVKemZXUitNcjJ2bXpLUjMvWGYzUTd0b2YxZzhvZFl1SGkrM3AvSi9HVDRaTlowZkRKck9tWk1tMm5WV3JMcW1nZUg0cnZ2MXFObGFIT2IydEgyeWF6cFptMW43YkpJMjNmdXdFcDhEUUI5QVFUQTh2V0VTUXZudURxaDJQR3ArT1BuQWt3Y0ZJTEkxbzAxZXA3Q2d2MHhwSGN6bk41Y3Mwd3VoZ2YzdW93N2UrU1kvVTZ3WFdOUkZuN3AzYW1KeG55OXNHQi96SDRuR0tjM1hUT3JSMk53cjh2NDQrY0NET25kVE5VVENnZ1hlTDA3TmNHeE5XNFdWYllVS3k0bFc4OXRXTE5jbk41MERhYzMxOFNRM3MwMDVwaXF4M1VsNlZhWkZWSFJMdElrOC9FeU9SZHV5Y2NwZWwvWEFIOC9UQndVZ25OYkxCdSthOHF4MVRtWU9DaEU0ejBSRnV5UGlZTkMwUFhWRzFhMTZVeWZVN0ZpS3F2M2w2WG53ODlIb2ZjNXl2ZUxwWjlEYzZ5UE80L1RtMnRpNHFBUWpkZEJJcEdvWWoyMnhrM1VKZERDbXVVaTZZdUx1TFduS21hL0U0emVuWnBvSEM4Z2ZMNGlXemZHN0hlQ2NXZVAzS1o1cDBUMjB0Qy9NYlpzM0l4ZHYreXdLV25WTm1CZ2YrejZaUWZPL0g0RzNUcDN0N3FkM056N2FQZDZCOGl6NVVnK2NCZ25ULzFtY1JzU1NUVjA2OXdkeTVjdXc2TzhYQnc5ZWhBTEY4OFhKV2sxWnNEQS90aTZiUk1lNWVVaUxqWU96WVB0VXcvQ21MallPSU5KcTdhRmkrZGp6KzQ5VnUrclcrZnVPSHZ1bE9oSnF5VmFoamJIcmw5MklDNDJ6cUxuNWViZVY1L3J5cVZ4UkZEbHhZc1hqbzdCYmw2a1ZJa0NjTkRSY1JBNUUyRXBvSXVRU0NSNGZNejRYRjl6cEZ5U292V1EwbmFNTFVORVJDU1dLbUV2cXBpN3JhdWJlektBVG9VRitXWS9wNXhaQ3VEOWlQQzJaZzhuelg5dSs4MGVmZnNiTld5MGNuaWszU1ZzUzhTTW1iT3NIbzZxVEg0dDZVbVRTS3JoM1hFVHpFN2N5a0xDdGtSTW5ETEY1cUhVNWpEVzAycU1OVDJ2M1RwM3g2NWZkbGk4TDNzYVAvWTlpOWJIVlR1RzdXRHlhalAydUJKVk1zcWxnTnEwcUd2VjgrTldocXFxenFaY2ttTEFqSmMwZnE1djdWWWlJcXJZSkpKcVdMNTBXWmtscllEUSszajgxeVBvMzNlQVZjL2ZkM0N2eFVucnp6OGxPVlhTQ2dpdnc5MDdXVmEvRHVhU1NuMnRQdmFGaStkREt2VTFlM3VKcEJvMmJGaHIxYjdzYVdYODF4WWR4NWx6WndFQXhjWEZuZTBWVTJYQ3hKV29rbGkycFFWYUR5MHRjdk9PRmZmOXNuTWsrSHhESm9iUHpvQmJhemUwSHZKWVk5N2h4RUVoZHA4SFRrUkV6a1daMEkyYk1MYk05eTN6azJIcnRrMFdEK08wUmtsUko3dnZ4MXBidDIzQzhxWExJSkZVczB2N1V5ZE5MclBuUjc3V1hxUGdrek1aTVhTWTJkc3FlOEZkWEZ3OG9idCtNRm1JaVN0UkpURnY3VDJrcEdkQklwRmc5anZCVnMyTm03OG15R0RobndCL1B3NFJKaUtxWkpSSnE2TVR1azltVGNlZTNYdnNsclQxN3p2QTRjZG9qbkVUeHVMbm41THM4anE4MGVjTm01NC9kdHhvczdmdEY5UFhwbjNaMHl1dnRMRm8rNFJ0aWNyL1JvZ2VUQ1ZUb1JQWEttRXZrZ0VZTDRkTFZFbThPNkF1TnN4dGpNZkhIbHRVb0VyZDZENDNkWXIyS0F2a1hFbXl2UUl3RVpHWnJwdmVoTXJDdnhZdWNwcUVMcXBMUjdzbGJmOXY5aXpSMjdTWHFDNGRzWFpWdk9rTkxXUnJnU1JMZWxDbFVxbE4rN0luTVF1T2tXVXF3M0k0Y3dCODZlZ2dpQnpOMm1SVlhWaXpYS3lQMHg0S2ZLdmtpNGlvekV5MWNQc0Fld1JSMmMyZTlRK251NGlQNnRJUi8xcTRDQk9uVEJLMVhVZFd0YlhHZ0lIOThjSEpEMjFlaW9iSW1WVG9IbGNBcUJMMllnbUF6NTQrcS9yYzBiRVFFUkdSVGZJQWpLb1M5aUxKM0NlNHVybEhBV2dFb2FvbmljalprbGFsY1JQRzRvUEpINHJXbmlPV25CSER3c1h6eTIzc1Y2Nll0NTYxSTZnTi9hVXlWaGw2WEZFbDdNV2NEcUdCKzR1S1h4eDJjM1c1OS9YMHAyTmZDYjMzeE5GeEVSRVJrVVhPVmdsNzhkREM1OHdwK2Rmc1pKZkt2NFdMNStPL2UvZWF2VHlRTVhlejc0b1FrV044OTkxNnRHclR5dEZoV096d2tTUDRCTk1kSFlaZVAveVk0T2dRS3EwS3ZZNnJObGMzOXlRQWZRR3NMeXpJSCtuZ2NJaUlpTWlPWE4zYzF3RVlBZUJjWVVGK1JTNk00cEIxWEoyZFBGdU93S1pCVUNpZTJkelc3YXliVGx2bDFoUkwxeDQxUkl6M2pMdUh4T3h0ei94K3h1bUdhRnZ6bmxKNzNXb0JzUFRHRzZtcDhFT0Z0WXdFY0E3QUNGYzM5MlJYTi9jQXg0WkRSRVJFWW5OMWMvY3V1Vms5QXNMdzRwR09qWWdjUWVZbnc3dmpKb2pTVnZ3cTJ4TS9SNWtzOG56ZnN2TDN2NDl3ZEFnNmhnOGZaVkhTcXJibWF4Nll0TnFzVXZXNEFzSWZNd0RKQU1KTEh0cGU4djFaQjRWRVJFUkU0b2dvK1lvQjRBV2grbkJNWVVGK1JmOGJ6eDVYSStyVTlWZXRwMmt0cWRRWDU4LzlyOXoydXZicThTYjJIZHhyVXh0bDNlTUtBTjA2ZDhlR0RXdWQ0blczNWpYczFyazdkdjJ5QXhEeWpSaDd4RldaVklvNXJ1b0tDL0lmQW9od2RYT2ZBK0VPYk4rU0x5SWlJcW9ZOGdCOEJtQkp5ZDk5Y2hCNXRoenhxOWJnOEpFanVIM25McTVsL2dHRjRoa2trbW9JREhnWndjMkMwTFZMWjR5Yk1OWnVNVXlkTkJteGNiRTJ0WkdiZXgvRGg0OVNKaUVXU3o1d0dEbHl1ZXI3UFh2MndkdmJXN1VtYUxPUVlMc09pKzBYMDlmbXhOVVI5aDNjaTViaGY4SFVTWlB4eVN6SHpIbGR0U0llQ3hmL0N6ZXlNaXgrcnRwNnRNbGl4bFJaVmJvZVYyMnVidTdLdTdNQkRnNkZpSWlJYlBNUXdObkNndnhrUndkU3hweXV4MVdlTGNlc21iSFk4c05XczRaV1NxVys2TnY3VGN5YkgyZVgzalV4ZWwwQm9jTHdkOSt0TjVwa0pteEx4SjQ5KzNBaC9TS3UvbkhWN1AxS0pOVVFGaHFPTjNyMnRFdVM1dWtsdFdtK3J5TjZYTFVwcXlTZlBYZks1bGdHRFJ5SzlFdVhqVzZqdk5GaURhblVGM2Z2WkNtL2JRd2cwNnFHU0tYU0o2NUVSRVJFNVp4VEphNnJWc1Rqb3huVHJicmdsMHA5c1h6cFV0R1gycGt4YmFhb2E1cDI2OXdkSFR0MFFOT21UWkNibTR2ZmZ6K0RFNmRPaVZMRkdCQmVoN21mZmlwcVQzUmtaR2VjUFBXYjFjOTNoc1JWU1l4WUxQbThXR1BVc05GWUdmODFBQndDRUdXM0hWVWlURnlKaUlpSXlqZW5TVnpGbUVzSkFIR3hjYUwyT3NxejVham4zMEMwOXNxSzJoeEptOWxhWFppSnEvbTA1a1IzQm9jS2k2S3lWUlVtSWlJaUlqc1FLMmtGZ05pNFdDeVl0MGlVdGdDaHd2QXJiVjhUcmIyeXN1L2dYdlRxOGFZb2JVVkhkeE9sSFRKdDdxZWZLcFBXUTJEU0tob21ya1JFUkVSa2t4blRab3BlL0NjMkxoYXJWc1NMMWw3N2R1VXZjUVdFNUZXTTE2RlRWRWNSb2lGVHVuWHVyajdFZTZvalk2bG9tTGdTRVJFUmtkV1NEeHdXZGY2b3VvOW1USWM4VzI1NlF6TU1HL0YzVWRweGhObWZmV1p6Rzg2d3BFeEYxOUMvTVRac1dLdjg5ak53dVUxUk1YRWxJaUlpSXF0Ti9lQWp1N1d0VUR6RDhPR2pSR21yWldoelNLVytvclJWMW5Kejd5UDV3R0diMjJubzMxaUVhRWlmaHY2TmNmelhJK3BEaE9jNE5xS0toNGtyRVJFUkVWa2xZVnVpWFN1ekFzSlEyZk9wYWFLMDFlVGxKcUswNHdoYk5tKzF1WTBhMVd1SUVBbHAwMHBhendHSWNYQklGUklUVnlJaUlpS3l5cGYvL3FwTTlqUDk0eG1pdE5NaU9FU1VkcXdobGZxaWVYQ282c3ZTM3Q4VHAyeGZ1NVRFMTcvdkFGeTllbEU5YVkyQ3NLWTBpY3pWMFFFUUVSRVJVZmtqejViYnRDNm9KWTcrZGt5VWR0cTBhV1hUa2pDbU5BOE94YXR0MjZKTm0xYVFTcVhvRk5YUnJMbWw4bXc1RGlVZnhwVXJWNUdSa1lrVHAwN2hXdVlmVnEyRlMyV2plWEFvWnMvNmgvcWF3K3NoRkdOaTBtb25URnlKaUlpSXlHTHhxK3lYQUdwVEtKNGhZVnVpZXBKZ0ZhbFVLbEpFQW9ta0dpSmZhNDkrTVgzVks4bGFUT1luMDN0c3lRY09ZL2V1WDVDUTlKTXRZWktJWG1uN0dqNTRmN0xxZkJVWEZ6OXljWEg1Rk1BU3gwWlc4VEZ4SlNJaUlpS0xuVDEzcmt6M3QyZlBQcHNUVjdHV2hKRktmVEYxMG1SOE1tdTZLTzBaRXRXbEk2SzZkTVRDeGZORnE2NU1sbXNlSElwQkE5L0NHMzNlUU12UTV1by9XdS9pNGpJSFFLWkRBcXRrbUxnU0VSRVJrY1hTTDEwdTAvMWRTTDlvY3h1Mkxna2prVlREdStNbVlPSGkrVGJIWWlrdVorTTRyN1p0cTM2VDRqcUFKQWc5ckptT2lxa3lZdUpLUkVSRVJCYTdtMzIzVFBmMzVQR1RNdDJmdG9iK2paSDBVNEoyanh0Vkxrc2h6R01sQjJEaVNrUkVSRVFXeTgyOTcrZ1F5a3kzenQyeDY1Y2RqZzZESEkrRmx4eUl5K0VRRVJFUkVSbkFwSlhJT1RCeEpTSWlJaUxTbzNsd0tKTldJaWZCeEpXSWlJaUlMQ2FWK2pvNkJMdVNTS3BoMzk3ZGpnNkRpRW93Y1NVaUlpSWlpOVh4cTFPbSs2dFJzMGFaN3UvZGNSTll5WmZJaWJBNEV4RVJFUkZaTExoWkVOTFNVOHRzZnkyQ1EyeHV3OXkxVUtWU1g3c3NlWk44NERCMjcvb0ZEeDgreElsVHAzUitIdHdzQ0Y2ZVhvaU83b1pPVVIyWk9EdWZDQUFCNERJNERzSEVsWWlJaUlnc0ZoRWVqc1R0Q1dXMnYram9iamEzY1NqNXNGbmJqUmc2ek9aOUtjbXo1WmcxTXhiYmQrNHdXWWxaZVNOZzdjWTFBSVFsZUxwR2RjYmtLWk80REk5ejZGdnlkUWpBdXBJdktpTWNLa3hFUkVSRUZudWp6eHRsdGkrSnBCb0dET3h2Y3p1NXVibG1iVGRzeE45dDNoY0FyRm9SajhDbVFWaTdjWTFWeXdmZHlNckEybzFyMEtwTkswU0V0eFVsSnJMYzlwMDcwS3ZIbTFnd2I1R3kxNzRUZ0xVQXpnS0ljbVJzbFFrVFZ5SWlJaUt5V012UTVtZ2VIRm9tKzRwOHJiMG83ZnorK3htVDJ6VDBieXhLNythQ2VZc3djY29rS0JUUGJHNExRSmtPeXlaTnVibjNzZS9nWHNUR3hTS3dhUkFHRFJ5cVRHRERBUndFc0FTQXQwT0RyQVNZdUJJUkVSR1JWUVlOZkt0TTlqTm05Q2hSMnJtUWZ0SGtObTFhdGJKNVArZFQweEFiRjJ0ek8rUjhGSXBuU055ZWdNQ21RUmcvOWozbHcxTUFKSVBKcTEweGNTVWlJaUlpcTN3eWF6b2EramUyNno2YUI0ZUtNa3dZQUs3K2NkWGtObzBhTnJKNVA5TS9ubUZ6RytUY0ZJcG5XTHR4RFpvMENjSDUxRFFBQ0M4cUtrcUJVTUNKN0tCU0ZHY0tXWERTRzBJWGZnd0FMd2VIUTBSRTRyb09JQW5Bbkl1ZnZQTFEwY0VRVlRZTDU4L0Q0R0ZEN05LMlJGSU4zMzIzWHBTMnpxZW1tVFhQOUpWWDJ0aThyMzBIOTlyY0JwVVBON0l5OEhwa0pINytLUWxSWFRyNlEvaDdGQUdBZjQ5RVZ1RjdYRXVTMW1RQUk4Q2tsWWlvSW1xRTBtRmFSRlRHQmd6c2oxSERSdHVsN1puVFB4R3RtdTUvZnY2UEtPMllrbnpBdk1yRmxpcXIrY1JrT1lYaUdmcjBpMUdlKzBiZzN5TzdxUENKSzRDUkVDWk9FeEZSeFJZZXN1RGtTRWNIUVZRWnJZei9HdDA2ZHhlMXpXNmR1K09UV2RORmErOC91M2VMMXBZeE9YTHoxb3ExMUYrN2kvdjZWbmIxNnRZUnRUMWw4cXBXdEdtSnFEdWdTcEc0eGpnNkFDSWlLak1Camc2QXFMTGE5Y3NPMFpMWC9uMEhZTmN2TzBScEN4RFdVajE1NmpmUjJqT21XVWl3NkcxS0pOVkVXNktIQkIwN2RCQzlUWVhpR2JwMTc2bjhkZ280MzFWVWxTRnhKYXFVWkI2dUdCSWtjM1FZUkdVcWY4L1NUMTNkM0Yrb2ZaMTFkWE5mNStybUh1WG8ySWdxZzEyLzdNQUhreiswK3ZrU1NUVXNYN29NVzdkdEVqRXFJSDdWR2xIYk02WmxhSE5JSk5WRWJYUHdXNE5FR3pKTkFuc1ZGa3RMVDhXTWFUT1YzN0xYVlVSTVhDdUkzZzI5TmI2YWUzazRPaVJ5c0lYUmdaamRQeERKNHlQd2JtaHR5RHdxUlMwMktnUE52VHgwZnVjNEMxZS9nRU1BUGxQN2VnaWh4c0ZCVnpkM1hrQVFsWUdGaStmanpPOW5MT3A5bFVpcW9Wdm43cmgyNVRMR1RSZ3Jla3p4YTllSzNxWXhnOThhSkZwYjNUcDN4OHI0cjBWcmowb2QvL1dJNkVQY0FlQ2JWU3VVUTRZN0FZZ1NmUWVWVktXK2t1M2QwQnVMaHdUWjFFYkt0Y2Q0ZTV2cE5jSHNUZnM0MXUyL2hiUlR0eHdVVGFrWmJldGpaTmY2R28rRkxEanBvR2dxajk0TnZmRjZDeUdacUYzTEhlLzNGa3I3ZjVONno1RmhFU3JHWitMTklKbk9NZXgwa21Od2llaWJYTGgxM2h6MXgxemQzQU1nM1BXZTR1cm03bDFZa0QvU0FhRVJWU290UTV0ajF5ODdjRDQxRFJ2WGY0ZGp4My9EMVQrdWFsVDFsVXA5MGVUbEpuaWpaMCtNSFRjYU1qLzdqQkpLMkphSUcxa1pabTkvNVlycEpYTk1tVGMvRHR0MzdqQ3JpckV4M1RwM0YzWElkRVdSZk9Bd29ycDB0TGtkbVo5TTlUNjlkREZkNStkNzl1eXo2andxRk04d2EyYXM4b2JEVkxCWWt5Z3FkZUpLVkJISlBGenhjYzhBamNmK3ZmTTZrMVk3cXdnSmFVVlZXSkNmQ1NERzFjMTlIWUFScm03dVp3c0w4dG43U2xRR1dvWTJ4OExGOHgwYXc5eDUvN1JvKzdQbnp0bThUNW1mREZzM2JjTFlkOFpibERRclNTVFY4TzY0Q1E1LzdaeVYyQVd3V29ZMjF6c1VlOERBL2xpSnJ6Rmoya3g4czJvRkZJcG5acmU1ZmVjT3JNVFhBTkFYZ0RlNFBJN05PRlNZcUlJWkUxWWJ0V3U1QXdDZUtvb3dkczBGSnExRUFFcDZXcThEbU9QWVNJaW9yS3hhRVkrMDlGU0xudlA3bVRPaTdEdXFTMGNjLy9VSVJnMGJiZmFjVjZuVUZ4OU0vaERYcmx4bTBtcUVHTDNpbGxpNGVENSsvaW5Kb3JuTHVibjMxWmRHWXJGWUViREhsYWdDVWM1alhiZGZHQ1orOVBwREhNdCs2c2lRaUp6TkhBQnJYZDNjb3dvTDhwTWRIQXNSMlpFOFc0N1puMzFtOGZOdVpHWGdmR3FhS01XUVpINHlySXovR2l2anYwYkN0a1RzMmJNUFdUZXpjUHZPWFFCQWpabzEwQ0k0QkkwYkIrQ05QbSt3QUpPWk1qSXl5M3lmVVYwNjR0MXhFL0RsVjErWS9ad3RtN2NxaHpSSEFWaG5uOGdxajBxZHVPNjg4ZERndkt5TG43eWk4ZjI2L2JldzBBbm1qSlkzQzAveGRTdEw4dWVGZkwyZEhEOFREcGRjOG04RU9PZUlxRUtiTkdtSzFYTk12MXE2VFBTQ1NBTUc5c2VBZ2YxRmJiT3lPbkhxbEVQMnUzRHhmS3pmdE5Iczk1VmFuQUgyaXFreXFkU0pxNWg2Ti9SR2RETXB3Z005VmNNMFU2NDl4cG1NUjFpZGNnL3k1NFZXdHkzemNNV1lzTnBvMWRnVFlZRTFBUURYN3Z5Sk05Y2VZZW5KV3hhMUxVYWNRNEprZUxXUnAwMXhxNllBQUNBQVNVUkJWRTRiZHg4OHg1NUx1ZGg1bzNRSXY2bDVmNFp1RUF3SmtxRnZoQy9DQW12aXFhSUk1LzU0alAyWGNySDVjdW1jQnUxanVmY2dIMy9jZm9iRWM5a2FNV2hUdnA1QmRhb2ovT1dhcUM2cHF0ckg1YnRQelhvZGVqZjBSdjl3UDFVQnBIc1A4bkh1MmlPY3VQNUlJMFpMTlBmeXdKdEJNbzN6Zk85QlB1NDllRzd5L05oeVRPWDFIQmpTM3E4NklodDVvMVZqVDlTdTVhRXhiUHFQMjgvTWZxK2JlejZNRlhsVGYyMlZyNnVoejRUTXd4VkhQbWlsOGZpZTAzSk0yWHROYjlzN1I0UWlzTzVMcXUrdjNma1R2ZGVuMm5UOGh0NEx5dmY3eS9XcVlmY1o4LzVZV3h2SDl3TkRWSyszK3VzamxzS0MvRXhYTjNkQW1HOUVSQlhVZ25tTGtMZzl3ZXJucTgxUEpDZVVscDRLZWJiY2JnVzlqSW5xME5Iczk5YTF6RCtVLysxa3Q0QXFFU2F1TnBKNXVHSmhkS0FxZ1ZFWEZsZ1RZWUUxOFZiN092aGkxM1dyRXByMmZ0VXhyMTlUMVVXZlVtRGRseEJZOXlYMGJDM0RsTTI2VmREc0VXZDd2K3FZMlROUTQySlpvdzNVUkhSckdhSlB5ekgzOEEyckU0K2wzUU1SM2JyMEYxRjFTVlc4M2tLb2t1dS8zd01MVDkzQzNBNk44TGYydFRXZVY3dVdPMnJYY3NmckxielIwa0FQK1l5MjlmRlcrenFvTHFtcThiajZQdDVxWHdjL0hMdHJzRmRNT3o3bHZxTmJ5eERkV29aM0hqVEE1N3N6alNadSt1TFNUbWJVanlrc3NDWjZ0dkxGdHdkdjZwd2ZNWTdKMURFNjJ6a3d4TkRycUd6ZjNQZTZKZWNqVDJIOVRTbDE4dWVGMkhOYXJ2RzZod2Q2NnQxVzV1R3E4em44ejVsczBZNWYzYnVodFZWVnFjMWxqemlJaU15VmZPQXc1aTlhWUZNYnVibjNNV1BhVE00emRXTHhxOWJnazFuVHkzeS9YYnQwTmp0eHRhU1lFNW5HNGt3MmtIbTRZdjJnRUwzSm9McnFrcXFZM1Q4UVE0SXN1eXZVM3E4NmxnNEoxa2xhdGR0ZU9pVFk3bkgyYnVpTnBVT0M5U2F0MnFKYnk3QzhiMU9UMituelZ2czZPa21odXBGZDYrUDdnU0U2Q1pPKzdiVFhsbHphUFJBanU5YlhTWmkwVlpkVXhjaXU5YkcwZTZET3o0WUV5WXpHQjhEbytkSm45WnRCQmkveXRkdWQzVDlRNDdqRU9DWnR6bjRPak1uS2UyN1dkdFVsVmZGaHIwWm83MWRkNTJlV25nOHhuYmorU0djZittSjhLOGhINTdFZkx1ZUljdnpxNm5sN1lFelhCbWExcVU3c09JaElmQ1ZyVE5wa3dieEZJa1FpcnVRRGg5R25YNHdvQ2NNM3ExYmdmR3FhQ0ZHUlBXemQ5b05EOWl1VlNoMnlYMkxpYXBNcHI5VFhTZVJTcmozR3V2MjNzT2UwSEU4VlJSby8rN0JYSTFYeEhIUE03Qm1vOXdMLzJwMC9rWEx0c2FwOVUwbUFyWEUyOS9MQVovMWYxdG5QVTBVUlVxNDl4clU3ZitvOC91L2tHNllQVUE5VHh3SkFaeGloSWRITlNuK3h6R2hiWDI4eWR1OUJQbEt1UGNhOUIvbTZ6Mjh0dzR5Mm1nbk0wTmZxYW56LzY0V0hXTGYvRm42OVVOcTdtbkx0c2RtOXJYTTdOTko3UTBIN0hDdnRPUzFYdFMzV01XbHo5bk5nek9iTG11L25sR3VQOWI1SEFlRTRCNFpySnQvV25JK0hpZ0tEOFN2M24zTHRNUjZaMFRPNytiSmNwNTBlelhSZnN6WUJYanB4eUo4WDJuejgycUpieTh4NlAyZ1RPdzRpRXQraDVNT21OekpoL3FJRkdEUndxQWpSaUVQTXBCVVFlc3RpK2cwUXBTMHhxRldvZFFoYmszZ3hicGFvUzB0UFJjSzJSRkhiTkVkWlZ6U21VaHdxYktYbVhoNDZQVTdhQlp6YW54TjZUSlVYZnRVbFZURW1yTFpad3grSEJNbDBrczE3RC9KMWhxQWFHNUluVnB6alg5SHRJZHVqTlJ5NHVaY0hQdjFySUY2dVZ3MVROcWZiVk1sMjNmNWJXSjBpTE44eUpxeTIzdU43cWloU0RURnM3dVdCOGEvb0prWEtZWmJOdlR4MDJuaXFLTUtuaVg5b3ZKWkRnbVQ0c0ZjampXTWQyYlUrZGx5V0k2MmtCMG43bkl6WmNWbjEvK2FIaFRoV25qUnZlS3UrYzZNdkx1WFEybU1YSHFqbU80cDVUUG80OHprd1pmWCttN2lSOTF6bjVrRnpMdzk4SGhPa2NRNmpXOHNBdGRmVTJ2TnhiTnRGdlovRnQ3ZGROQ3RtZGJ2UDNOZG9wMFB6V3NDUjY2cnZaUjZ1T3NuMW5rdTVxdjliZS95bUtPZlZuNy8zRkMxcm0rNGh0VGFPeTNjNHJJcklDbmNBb0Y3ZE9tWXYvZkxEandrMkZRcEtQbkFZQ3NVekpHNVBRSzhlajdEcmx4MVd0eVVHc1pOV3BSdFpHZWpWNDAySEg5K0NlWXV3Wk5sWHVIc255K28yNU5seWk1Y0dVdmVmbi85alU5WGorRlZyckg2dUlST25URUducUk1bE90ZjE4SkVqWmJZdjBzUWVWeXNORHF1ajhmMjFPMy9xSktUSHNwOWk5ZjZiR285MWJHN2U4SUpYRytuT2JadjEweFdkaThDRnA0UmVVM3ZGS2ZOdzFVbEdmcjN3RUZQMlh0T1l3NXFXOXh4dmI3dG9jOUtxakUvK3ZGQlZJVGZsMm1PZDdkVG54YVhsUGNlVXZkZDBlbk9VUTNhMVh3TUFtTEk1WGVlMTNIeFpqazhULzlEWlZ0L3psWloyRDFUMVRpdmpNRGZCTWpldWhhZHVZY3JtZEkwaVBmWThwdkoyRHJSOWszcFBiNDkzV3Q1emZKeDBXZWR4NVRCVlc4NkhtSFpvemZmVUhpNnNQVXo0M29OOGpSaXRQWDVEbmlxS01HM3paZlJlbjRyWlI2NmJQWnJBMmpobUg3bU90N2RkMVBnaUlwUHVBb0IvQTMrem43RHJ2N3R0NmdGYnRPaHoxZi8zSGR5TFhqM2VGTDFIelZ3enBzMUVkTTlvdTgwblZCNmZvd3dhT0JTeGNiSEl6YjF2VTYrbnJZbGovTnExTmozZkhrTjdjM1B2WS9qd1VhSzNhNGc4VzQ2anZ4MHplM3VwMU5lTzBWUStURnl0RkZSWGN3SGl3Mm01ZXJmNzRYS094dmZtekJFRmdDYjFOQzhtZjcxZ2VEMU9ZejE4dHNZWjNVaDMyT1NhRTRiM1ordWFvZnJpTzVQeFNPY3hmY1ZjREIyYjltdGc3TFhjZWVPaFRwTFdTcTFBanZxUVlFRG9LVHJ5UVNzczdSNW84VHk5VmxxRmQ0ekZwZjI0bU1la3pkblBnVG1HQk1rd3QwTWpmRDh3Qk44UERNSFM3b0dZMGJZK2F1a1pxdTh0Y2RPN0Qwdk9oNWpTOHA3ckhMLzZjR0h0WWNMNnF2eGFjL3lHZkxITC9HVFZubkVRa1ZGWEFTQTZ1cHZaVDFBb25tSFNwQ2xXN1N4aFd5TDJIZHlyOGRpK2czdlI3dlVPWlRxYzlYeHFHaUxDMjFxMHJxYTE5aDNjaXlaTlFzcDB6cXZ5K05RTEFVMTRkNkpWYmNtejVWaXk3Q3ViNHJtUmxZRVowMlphOWR4VksrSnQ2dTAxcGl4dkxBd2ZQc3FpR3lSMS9GUTN4US9aSmFCS2hrT0ZyZlJ5UGMwTDhaRmRqUS9aVmRlN29iZkpDMEh0QlBmeVhjTVh5c1o2K0d5TjA5L0xRK2R4ZTE2MDI0UDJmRXhqcnlVZ0pHbnF6MUUvRjJ0TzNGSXQzNkpPV1ZFNDVkcGpmUFpmODNwZExUbkgyc1E4cHJKUVZ2RWFxc0lkQnFHdGtURDgzcmZsZklndCtXS3V4dkVyaHd2ckd5YXMza05yeS9IcmMrOUJ2cWpWMEsyTmc0aE11Z29JNjRSaW1QbFBTdHllZ0FYendpMnF6SnA4NERCR2pSdXI5MmMzc2pJUTNUTWFvNGFOeHJ6NWNYWWJ2aW5QbG1QV3pGaHMrV0ZybVZadHZaR1ZnZGNqSS9IdXVBbDJyelk4WTlwTWZMTnFoYzd4blR6MUd4Yk1XMlJ4TmQyWS9tOVp2YWF0dW05V3JVRFBYajBRMWFXajJjOUpQbkFZSDgyd2IvWGZmUWYzSWpLeU01SVNmN0RiKzI3R3RKazZOMnhNK1d2Mzdzci9uaFU5b0VxSVBhNVdzcVpnaVNPVWx6akxpMlBaVHpGbGM3cmVJak9Ba0tCdEdOV1NWVklkd0p3cTNPWEZENWR6TklvYktZY0xhdzhUVHJuMldIV1R4QjdIZis2YWJrKzdLUlhwUEJDVkkzY0JYQWVBVjlxK1p0RVRZK05pTVg3c2UyWnRtN0F0MGF4NXBHczNya0ZnMHlDTUgvdWVxTU9IejZlbVlmelk5eERZTkFock42NXh5RklqQ3NVemZQblZGNmhUMTEvMHFzcnliRGtXekZ1RU9uWDk4ZVZYWHhnOFBrdk9tVHhiam9qd3RqaDU2amRSWWxRb25xRlB2eGlzV2hGdjF2YXJWc1JiTmZkWUlxbG1laU10SjAvOWhzQ21RYUtmbC9PcGFZaU03R3hWejM3UFhqMlUvMDBXTTZiS2lvbXJsYlFyZnlvcm81cno5VkJSWUhIN1FYVU1KMExOOWZTS2loV252bVV0eWx0U3BwMWt0bXBzZk5pcDltdXRQV3p6V1BaVDlGNmZpbW1iTCt1dHlseGRVaFdqWHpYZG82UWRsN0Z6Yk9xNXRoNlR2WlZGdkFQRGEydmNxSG1xS01MY3hHc0lXWEFTSVF0T29zT1haekEzMGZDOFZGdk9oOWprend0eDdNSURqY2Q2TkpQcERCTk92bGc2Tk52VzQ5Zm45a1B6NW11cnMwY2NSR1NXSkFCNG8yZFBpNSs0ZHVNYVZTS21MOUZjdFNJZXZYcThpY0hEaHBpZGdDZ1V6N0IyNHhyVTgyK0FYajNleEtvVjhWWWxzY2tIRG1QR3RKbG8waVFFcmRxMEVpMWhYYjUwR2ZyM3RiNWljRzd1ZmNUR3hjTFRTNm82UG12SXMrV3ExemV3YVpCcUxxc3BwczZaZXBJdjloQmRoZUlaSms2WmhJand0Z2FQZTlXS2VFU0V0OFhFS1pPc09sKy9IajFxVmZLcVVEeFRuWmRCQTRkYVhYVlkrMzFuVGVMZjBMK3hlczkwc2xXQmtBWU9GYmJTdVd1UE5Jb1duYnYyU05SaUxkcnR2OTdDRysxUFZOYzdUSGY4SzRhVEpGdmp2SlQzSExPMUhodjlhbjBjMjZGYlhBVVFrbHBuRzBwODV0b2pqV0dnWVlFMURRN1hidTlYWFdjb3BuYVZVNW1ISytUUEM3SHp4a1BzdlBFUXNzT3VtUEpLZlkyS3RLKzM4QVpNRkNEVWpzdllPVzd1NVlGc1JaR3FJSmJZeDJSdlpSRnYreGExTkw1WEx4NEZRTFZjekd6b1gzdlZsdk5oRDl2TzNkUDQ3SFpvWGt1akYvT3BvZ2pmcE41VGZXL3I4WXZGV2VJZ3FvU1dBSmp5eWF6cFdMTHNLNHVIaFNvVHNkaTRXRWlsdnFqalZ3ZFBuajdCamF3TW13UGJkM0F2OWgzY2k0bFRKcUdoZjJNRU5Xa0Mvd2IrOFBiMnhpdXZ0RkZ0ZC9MazczajQ4Q0h5SHVVaC9kSmxYTXY4d3k2OXFuR3hjUmczWVN6NjlZL0I3MmZPMkhTTUNzVXpnOGNIYU00N3ZuTGxLakl5TWdFQUY5SXY0dTdkdXpidFc5ODVBNEM3MlhkRkdSWnNTbHA2S2laT21hUTY3aHJWYTZnZXQwVzN6dDNSTXJRNUJyODFDR3MzV2xkUVNsbnhPbkY3QWpBTXF2aGViZHZXNEhPeWJtYmg5cDI3b2lYNlkwZXBpa2F0QjJCZHNRalN3TVRWU25zdTVXcGNWRWEzbHVIZHUwODFMaVFCSWNtWjNiRWhiajk4YnRZeU9FcnBkNThpR3BwajlPZjFhNnAzT1J4OWEyT0tGYWY4ZVNIMm5KYnJKTkZMRllFYXkrRW9ueC9kV29aLzc3eXUwNzRqYlVtNXE3UE15V2Y5WDRhWDFnVjE3NGJlK0t6L3kzcWZyL1J1YUcyTTZkb0FxL2ZmVkIyai9Ia2haaCs1cnJNUGErSmFPaVJZWi9rVlpWejNIdVJqeE5hTGtEOHZGUFdZeWtKWnhHdk9zUGplRFhXTGpSbUwwZHp6WVlqeVJvN013eFhOdkR3c3VxbHpMUHNwN2ozSVZ5V3Iya052dFh0a2JUMStzZGdheDl3T2pYU0tlYkd5TUpGWk1pRVVnT2swZGRKa3hNYkZXdDFRYnU1OXV5VStON0l5UkVtR3JSVVhHNmVhSHlyemt5SCsyNVdpTHFPamZYeldKbDZXc3VjNU00ZVk1M1RSNXdzQkFDdmp2OGIrNUlPaXRLMXN3MTRGb3JSSnBiN3E4NURYbGNsT0t3RW1ybGJhZWVNaGhsOTdyRkZBNWYzZWpmQkdLejlWWmRXZ090VTFDdm5VOC9iUVNQYU0rU2IxSHQ1K3ZhN0d4V3J0V3U1WVBDUUk3OTM1RTAvK0xNVEw5YXFadkVnVUk4NlZKMitoZll0YUd2dFNMMFlFUUtkOTVURTRnN1M4NS9qeDJEMk5wS1M2cENyK2YzdjNIaDlGZGZjUC9DTWthUXJCSUxlTkxUY1RSUkF4QzVVVWdYQUhoVUFiRlBwd0xRRVVoSUJDZlVUYklEZWxWWDhLY3F2Vnh3SWhOeDZoUXF2SUpWQkEwQWN2d0VaRUxCaksxZXhHRkJXa01Zbk03NC9sRExPek03c3plNTBrbi9mcnRTL0k3dXljTStlY09UUGZuWmx6bnJvL0dWTXV0b1RyNGcrdzNmUVR6V2Z5MXU0Nkx6OUQyT3duTVpqY3Z5VWF4dGZISXhsdDhGL2RiOGErVHkvaWNrVjFRTGUyNnVYcmhUSHQ4UGpGU3E5OEpkLzhVK1NPNm9BSjY0K0ZiSnNpSlJMNVZRWjVBREQybnB2eGJZWDd5bml6bjhSZ1pMdW1tTnkvcGVrOEdxbVBDejlVNDdzSzcvMzZ0VWtkUGJiRDdOMEk2amxkbFY0djhkeS9ndDMrVUFrMkgrMXVidUExbUJjUkdiWUF3TzRuYytiZ3RUVnJvaG9nV3BFeWFBVXcrOGNmZi94ZG4zNjlXdjFqMCthd3pBRkw1dDMvNndjODVvcmR2T2x2Nk42elo0MnJtNmZuenhmLzNRdmVKaHd5REZ5RGtQMzNFOGdkMWNIajlzTGttMytLNUp1MVR6UjdkTHdKdDVlNGNLSGMyTzJGT1p0T1lObVk5bDdCcVhyMDArOHJmdlFad0FhYnowKy8vUUh6M3lqRnd2dFR2TkxSTzhGc245UVFpTXlQV29ZOHRlODBib3l2NzNWMTJuWlRuTzRnTWpzT1h2QzQrdnhvMnM4OXR0OTJVNXp1VlZibHM0Zis4dld6eGoveHVqVldMMSsybStKd2UrSlBjS0c4T2lUYkZFbmh6cTg2eUV1KythZDRZVXc3dkdBeWo0SFd4OTR6MytBUnRER1JtbjkvL2RpbEdiaWVMUHVQVnhBY2l1MFBCYXZrZzZpTzJnUDNiWWtUWG52MUZRd2FQQ2pLMmJHRytQZ0dlUEc1NS9IUXcvSm95Qk1CcksxZnYvNmVxMWV2N3UzVHI5ZU5ERjZqcjBtVDVsaTVjcG40Y3phQVdYZDJ1cVBObXY5NURhUEhqNGxpenN3WjBIZWdzcTFsUlRFcnRRNEhad3JDaFIrcU1XSDlNYSs1UGJXY0xQc1BIaTM4elBTdGdvOFdmdVkxd0pLUzYySWxIaTM4TE96NTNITG1HNzk1RWRidU9oL1M1MzFENWRIaWsxaTc2N3pYWUVwcTMxZjhxTGtOVCswN2JlajdPdzVlTUhXMWVmS2J4N0h4WGYvTGE5Vk5zTnNVYWVITTczTWZuc2VPZzc0SC9saTd5MzhRSEdoOWlDdTJvWFRoaDJyTi9WWnJ2dHhRYlgrd3JKSVBvanBzMXRXclY3L3IwNjhYRnMxYkZPMjhSRjNyVnJmZ0g1czI0NkdISDhTUFAvNTRDZGVDMW1zZk8rclZxOWRibE5jL05tME9hRUNnMnVMK1h6OFExSUJWd1lpUGI0RDFCUVZpS3B1OWNEK3puWG4xNnRYdkh2ak4vVFdtTGJkdWRRdldyVnNqL2x3STl5MzhGQ0s4NGhxa0N6OVVZL0tieDVGUjBoamQyaVI2M09ibXVsaUprcFBmNGYzVDN3VTBGeUxnRGw1SHJQMEVrKyt5b2NzdE44cnJQbG4ySDd6ejZkZjQ2OGN1UTdjZWh5S2Y3NVovano2dk9EQ3RrdzN0a3hvaU5mbEcrU3JVeHljdjRYalpGUlI5N0l6NGJhaG1QUGZoZWZ6MVk1ZGNudUoyNis4cmZrUko2U1VjZDM3dnMwelYzeGRsS0w2LzYxOWZCMVRYVCswN2phS1BuUmpXcnBuSGVsMFhLMUg2eFJWOGRPcGIzV0E0MkcyS3RIRG05OUhpazVqbS9CNTN0MDJVYjM4L1dmWWZmUDdGOTNpOXhJVjN5NzgzTkk5eG9QWHgxTDdUdUZ4UmpWNTNOSkh2Y0RoWjloOGNPdm1keDN5clp1ejYxOWRlVjRELytyRjJXd2pWOWdmTEt2a2dxcU8rcVZldjNxOXg3WmJoZC9idE16MzNaRzB4b085QXJGdTNCczFhTk1QVnExZS9xMSsvZm05NHo2Y3BndGU5ZmZyMXV2RzkvZnVST2Z5Qk9uZWI5WUMrQTdIKzlRSUF3SkQ3dm90NG0vbkRuQ2ZScDE4dlhMMTY5YnQ2OWVwbFhudmJvV3pMQUlKNmRqdmNXcmU2QlFmZTI2Y012aGRFTjBlMXp3MlNKRVU3RDJIVjRka1A5Z0RvSGUxOEVCRlJSQ3c4OW1UYUFsOEx4TVRHU1FBV1ZsZFYrbHlPcUliTEFyQUdBSWJjTjZ4T0JhOU5talRIMC9QbksyL1gzQXNnRTc1SGRyWERQYVZRR3dDWSt1RDBpQTJzRkcxcFhlL0I1amMyaUlBTFFHVGJqSGoyK0ZyUXF2WGpRaGF1dGVVOS8zekhrcmQwcTRMV0VnQjl3SkdFUTQ2M0NoTVJFUkhWUG12aGZ0NFZiMjk3czhiY2FobU0rUGdHbURoK0VqNHBPYXdNV2hmQ1dCRGhnRHQ0L1R2Z0h0RjJ4OVlkdUtOOXAzQmwxeElHOUIySS9mdDNpNEFyRjRvMkUrN2JodVBqRzJESDFoMTRNbWNPcXF1ckw5ZXJWMjhDdklOV3dOMldPNHRidWsrZU9JNjBydmVFTlc5bURPZzdrRUZyaERCd0pTSWlJcXFkc3VCK3BoTlA1c3pCanEwNzBLUko4NUFuMHJyVkxXRlpyMUh4OFEwd29POUF2TGQvUDE1NTdjL0tXelZ2Z2JuYk5iK0IrOHJzY0JFa09Vbyt4S0o1aTZLNmZlRVFIOThBcTVhdHhOdmI1RW5uYytGdUwxblgvby8xcnhkZzFiS1ZZWG51OTQ3Mm5YRHl4SEg1OXVDWW1KaDB1Szk0NjNIVXExY3ZGVUJKc3hiTnNILy9icXhhdGpLcTlkS2tTWE81REJWdHJnOFl0SVlOQTFjaUlpS2kybXN0RklHWXMrd3NKbzZmRkpKZ3BFbVQ1bGcwYnhFKy8vd1luR1Zuc1dyWnlvaGVvV3pTcERrbWpwK0VreWVPNCsxdGI0cHBWRTRER0E1M0FIRXF3RlZ2cmxldlhodGNDK0NlekprRFo5bFpMSnEzS0tMYkp3THlReDhkd3V5WnZ3dFpBRG1nNzBDY1BIRmNlVlY2Tmp4SHY4MENNUEhISDMrODlOREREK0xraWVNaGJUT3JscTJFbytSRCtRcWx6dTNCV2s3QmZWVjhJUUE4OVBDRGNyMUVNb0J0M2VvV0xKcTNDTTZ5czRGYzJhY2cxSVZuWEY4QzhHaTA4MEZFUkJFeCs5aVRhUy81V29EUHVGSWQxUmJ1a1ZwL0RRQVh5aS9ndGY5WkhkQjhyNjFiM1lJSEowNVV6b25xNFpNam55SXZOeDkvMjd3cDVJTWNOV25TSEgzU2UrSGhoNmVpVDc5ZXlvOU93MzExZFcxSUUzU1gyd0lBRThRYmUvNzVEdjd5bDFld1o5ODcrUHJyTDBPYVdIeDhBOXpWS1JWREJ3L1dMTjluRno4ZlVKMDFhZEljdjg0WWhwbVB6bERPazFvQ2Q1Q3FGelRhNFc0enZRRjNtOG41d3p6OGZjdWJwcmM3cmVzOVd0dTBFSUVQWU5RV2l2WU1BSDk3L1EzOGRmVWFIQ3B4aEx4ZVdyZTZCWGQzNmFMVjd2YkNYWWFuUXBvZ2Fhb0xnV3RidUhmSXhDaG5oWWlJd3V0YkFHMlBQWm1tKzR0M1RHeWNIY0JoQUxPcnF5cDlCcmhFdFZRZnVJTUZlZURLVDQ1OGlyZis4UlljSlNYNDdGL0hjZm43eTNKZzFMclZMVWhvbUlEMnQ3ZURQVFVWUTM4MVZCbjRBTmRIVHowRjkxUThFK3ZWcTNlamV0M3Y3TnVITDhxYytQUXpjNU84MzlHK0UzNTJjeEo2cGFlajJ6M2QxRUVENEg0bWRTMTgzMllhQ20wQkxMaDY5ZXB3OWZibDVlYmp5Q2RIY1B6enp3TUtLRzlOdVJVZDIzZkFvRUVEOE1CdjdsY3ZVZ0wzOW1YQ1lKM0Z4emRBY3RzVUpEUktRSTl1OTJEd2tQdUNEZkt6cmkwdlQxYSs1NS92WU92YjIzRGtreVA0b3N3Slo3bFREaGFWYmFaL3Y3NFlmbitteDhCUGNGL0pYb0RRQkh0MkFMT2crR0ZCSzM5bTJwMG9QeDl0SG5CdncxcTQ1MDZtQ0tuMWdTc0FkSGoyQXp1Ky9lSjlKUDRzTHRwNUlTS2lzQ2dCa0hYc3lUU2Z0NXZGeE1abHdUMDZaZC9xcXNvOUVjZ1hrVlgxQVpDbERzU011RGI2NnlhNHIzaHA3WE9aY00vQnFibnVUNDU4aW44ZHV6NEgvUWNmZklSYmIwMUdreVpONVBkNjkrbWxEbmFVL2c1M29Mb1prYjgxc3pHdWJSOFVWL3VVOXZ6ekhYeDF3VDBGMnRkZmY0MlBQam9FQUJnMGFJQzhUTk5temJTQ2NLRUUxN2RQV2I1MnVIOGNNRjFuMTRoeVd4dkFkd0gzTm1kQlo3djlPSDB0N1pjUW5xdVRqZUhPbTBlQXI2YXNHelZmZFhLdHplOUc5Tm9kb1k0RXJnQVFFeHUzNE1ZV2JlWTNzZmVmSFpzK3ljaDk5RVJFVkRPY092WmsyaWtqQzhiRXhwMENnT3FxeXJaaHpBOVJUZFBuMnNzT2R3RFFGdGV2cnBYQWZaSitDdTRnYWcrTVBZOG8yT0VPSnV6WFhtMThMKzdsOUxYMFJOcDdUSDQvM1Bvb1htMWhmdnUraGZmMkdRbUs3TGhlWjIzaHJyZFUxVHFCNi9WbGRMMUdLZXUwOGJWL3hkMk53YmFaVU9nRHovSko5YkdzbHIySWJ2NUpRMTBLWEJ2aitpODhiYXVyS3ZsTENSRlJIUklURzdjVzd0dkpKbFpYVmE2TmJtNkk2clQ0YXk5ZktxNjlhcUlFQURFR2x1TzVhT1ExOXZGWk5ZRExrY29JbVZkbkFsY0FpSW1OeXdTd0NlNWZvcktxcXlyRC9Ud0VFUkZGV1V4c1hGdGNIOFFqdDdxcU1pdXFHU0lpSWlMVDZsVGdDZ0F4c1hGOTRMNDNQUkdldDU4UUVWSHRJbTVmRTg4N0xhdXVxcHdWeGZ3UUVSRlJnT3BjNEFySXR3MW40ZnI5K1J4eG1JaW9kdG9MOTQrVEwxVlhWWjZLY2w2SWlJZ29RSFV5Y0NVaUlpSWlJcUthbzE2ME0wQkVSRVJFUkVUa0N3TlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBNZEhPUURURnhNWTFCcEFKb0MyQVBsSE5EQkVSRVJFUmtUWUhnRk1BOWxSWFZUcWluSmVvdUVHU3BHam5JZUt1QmF3dkFaZ1E3YndRRVJFUkVSR1pzQmZBckxvV3dOYTV3RFVtTnM0T1lBK0FSUEZlaC9aM29zUHR0K1BHR3hOMXYwZEVSRVJFUkJScDMzMzNMWTc5NjE4NGVlb2tmcWk0b3Z4b1luVlY1ZG9vWlN2aTZsVGdlaTFvM1F2Z1JnRElHajhKZi96VDAyaGhheDdkakJFUkVSRVJFZm14K09sbjhkS0tGYmg0OFV2eFZwMEpYdXRhNE9vQWtQcVQrQVo0YS9ObTlPM2ZKOXBaSWlJaUlpSWlNcXpjOVNWKzJhMEh6cDQ3SmQ3cVhCZHVHNjR6b3dySHhNWmxBVWdGZ0JlZmU1NUJLeEVSRVJFUjFUZ3RiTTN4L29GMzhaUDRCdUt0QlZITVRzVFVtY0FWd0N6QS9UenJ3OU9uUkRzdlJFUkVSRVJFQVdsaGE0NC96SGxTL1Bucm1OaTR0bEhNVGtUVWljRDEyaWpDcVFDUVBlM2hLT2VHaUlpSWlJZ29PQTlObWF6OHMwK1VzaEV4ZFNKd0JXQVgvN24vZ2VIUnpBY1JFUkVSRVZIUVd0aWFvMFA3TzhXZmJhT1lsWWlvSzRHcmpDTUlFeEVSRVJFUjFTeDFMbkFsSWlJaUlpS2ltb1dCS3hFUkVSRVJFVmthQTFjaUlpSWlJaUt5TkFhdVJFUkVSRVJFWkdrTVhJbUlpSWlJaU1qU0dMZ1NFUkVSRVJHUnBjVkVPd00xeW8rWGdTL3pJRjNJQWE1ZWpHalNOelI2Q0VpYUEvejAxb2ltUzBSRVJFUkVGRzI4NG1yVWo1ZUJ6d2RES3A4ZThhQVZBS1JML3dQcHhHM0E1Y01SVDV1SWlJaUlpQ2lhR0xnYTlXVWVwQi8yUnpzWHdKbi9pbllPaUlpSWlJaUlJb3EzQ2h2MWJhSGhSWGNkYUlzMzk5MklMZTkraFZObnl6MCtxenBZRlZRMnBPb1RlSGJ1Vk54NjUwQ01IRFVpcUhVUkVSRVJFUkhWQkx6aWFwQy9xNjByaXpwaXdydzdjZk9nWnJndit6eFdyVC9tRmJTR3l1WEwzMlA2ZXgvdUxnQUFJQUJKUkVGVUk0K2lVNmN1S0hkOUdaWTByS1o0KzA0VWI5OEpsek04WlZyVHVKemxHSll4SE1YYmQwWTdLeEZWMjlyQnVERlpLTWdyaW5ZMmFnMHJ0QStYczF6T0J3VnYrZEtWR0RjbUM0NURKZEhPQ2xHZDBkbWVocG5aczAzMXBRVjVSU2pJSzJMZlIrRWxTVkt0ZjlXUGllMVRQeVpXcWg4VEt3WHFhZ2wwWHpaYk0wbXMzOS9MMTNxTXZxUkxoeVNYczF3YU5IQ0lkT2VkblFQZUpxdXdwM2FWNnNmRVNrT0haT291SThvdmYxMWhCSFBtelo3YVZVcE9iaC8xZkF3ZGtpblZqNG1WN0tsZG81cVBTQXVtSFppcHUzazVDNlFaMDJkSmh3ODZBc21tbEwrdVVFcE9idSt6ZnBZdFdTSFZqNG1WYkxhV2tyUE1wYmtPc1cvWWJDMmxIZHVLQThwTFhXS0ZmaUovWGFFVTdQRW0zQTRmZEVnenBzK1M1dVVzOFByTVptc3AxWStKMWZ3czBnNGZkRWdORXhLbCtqR3gwb3pwczBLeVRxdjA0VVNCQ25jYm5qRjlsdHlIbWVrSHhIZVV4ejF4TEEzVi9rdmE3cnl6c3lqL0JaSUY0cTV3dm5qRk5RUUdkVXVLZUpvdGJNMlJsN2NXSjArZHhPNWRleUtlZnFnVWI5K0pJMGNkQUlEZDcreTIvSlcwSTBjZE9IMm1OS3A1S01ncnd0WWRXOUNwb3gySEhSOUVOUzgxaVptNlcvemNZcno4NmlvY1BmcHB3T21kUGxNcXQyMDFsN01jZjVnM0Y4MmEyckR0N2JkZ1Mycmg5Zm5VNmRQazcxLysvaExLeSt2RzNSVVVma2VQZm9xWFgxMkZ4Yzh0OXZyc3dsY3VBTURYRjcrSmRMYThUSnowRUNvcXJpRG5pUnlzV0xVMEpPc01kUi9lMlo2R21OZzRuNitaMmJNTnJjdmxMTWU0TVZsSVNtb2xmMWZ2eXBmeWM2MzNZMkxqTk8vbUtNZ3I4bGlHYXA1d25vY1ViOStKbDE5ZGhmajRCc2hkbll1Rno4d1BhbjMvZUdzTFhuNTFGVjUrZFZXSWNoaWNncndpRE1zWWpvUkdqVDMyb2ZsekYrcCtSMisvVGtwcVpmcXFOQVdQejdpR1FOY09FZ3EzUkQ3ZEZyYm15TGgzTUFvSzFxTnYvejZSejBBSUxGOSt2VE9ycUxpQ1o1NytVOGhPVUdxcmpoM3Z3TmEzM3NiQWV3ZEVPeXNVaEUwYk4rS3UxTHU4Z2xZQTJGbThDeFVWVndBQUg3My9JZXhkVWlPZFBhcWp6cDg5QndDYTdUTFNubi91ajJqZXZIbWRhUDh1WnptNjkranRGWkFjT2VyQWthTU9yRm0zQnZ2MzdqVlZGbzg5UGdkang0LzJlRy9lZ2tVaHlTL1ZUczJiTjBmdTZseDA3SGhIcmR2dmhtVU14OVlkM2lmclloL0xMMXFQOTk3ZGE3anZ1L0NWQ3krL3VncHZiOXRtNm5zVUhGNXhEWUhmRFBJODBMUnQxUUp0VzBXbUFkOTRZMkpFMGdrSGw3TWN1OS9aRFFBWVBDZ0RBTERoYnh2OWZtLyszSVZJU2VuZzhZdVhtdmpGdWlDdkNNdVhya1JLU2dlTUc1TWxmNzU4NlVyNWwvS2twRllZbGpFODRHZW9ISWRLTUc1TWxweW5oRWFOMGRtZVp1clp4WUs4SW5TMnB5R2hVV1A1KzhyblJKUnAzUDNMcmhnOGRBaFNVanA0L1Vvb2ZrMVBTbW9GeDZFUzlFcnZqNlNrVmg3TGlyU1NrbHBwL3RJNE0zdTIvTG12N2ZGVnhrYlg0YXRNZTZYM2w4dWpWM3Avbi9VVHF2cDBPY3M5cmtKTW5UNE5NYkZ4NkpYZTMyTVo1VldSbEpRT2hxK29pTHgyNzlFYmc0Y09RZmNldmYxK1YrdmtZV2IyYkxtOTZhV3YxeFk2MjlPd2ZPbEt6YlMwMnFHWmRpeWV2VTVLYXFWYmI0SGtTODFzK3dDTWxabXlUYy9Nbm8ya3BGWklTbXJsMFhmbzVVT3ZMMUlTKzRuWmRtTzJqMUZ1cThpL3VDb3dmKzVDVEowK1RWNVdmWFV1MWY0TC9MeFZTL252NVV0WHl1dlJTa2Q1MVMvVWZjZmdvVVBRczNkdjNXMFZaU0xTQ2ZUcWgwaFRYSVhSNmx1Tm1EWWxXL1BWclZ1YTMrOCs4L1NmNUtDMWU3ZDArYnR0V3FjQUFMcllmMkU2a0xqd2xjdWpqYzNNbm0zcVNwM29VN1hhdjJoZi9zckphSDhwMm14Q284WnllOUNxU3pQSFNsOXQwR3cvWktSdlU2Y2RTRnN5a281Wnl1T2ozaFZHeDZFU0RNc1lqdnVHRE1XRVNSTnczNUNodXNkUlVhZGlmMUhYZ1pudFZLOUQ3MDRDa1QvUmpzd2U1OGVOeVpLRDF2ajRCaGc4S0FQVHBtUmoxTWd4YU5iVUJzQjlsMVQzSHIxMTE5R3NxYzFqdnhiNzV1a3pwWGptNlQrWjJuNEtRclR2Vlk3RUs5elB1RjR0Z2ZUSXVMdWs1VTkybEp6L2pKZi9EdWN6cnNMa2lWT2x5Uk9uQnJ4ZDBTU2VvMGhPYmk4NXkxenlzMHhhejIySThrdE9icTlacnVwbkNjWDc2VDM3eWY4Zk8zcUNKRW1TTkhiMEJQazlrYVo0anREZk00MWF6OUR0MkZhcysweXprZWNTbGMrVHFGOGlIVjlwS0o4ZEVjL1hOVXhJOU5nMnJmSlF2cFl0V1NHdlErdDdXdHZqcTR5TnJrT0w4cmsyNWN0bWE2blpSb3pXcDVIbkg1MWxMbzgweGZyU2UvYVRQOWRyZzhwbnRQV2VjeFRQSm12Vml6QXZaNEhtOXVldksvU1p2dGlQakxZRlpaMUxrdTkyYU9UNUpHZVpTMzQrVWxsMkRSTVNQZXJCYkw3VXpMWVBNMldtWEplL1BrWXZIOHEwek5hOUhxTjlqSzl0RmM5UysycGZ5aklRZi92cW05WFB3MGF5N3hEbDJUQWgwYU8reEhyMGFQVURlbWthYWZmaU9YUjFmWnZsYXoxaTM5ZmFEcjFqbjNJL1BIelE0VkdQeXBjdjgzSVd5T3RRVXJaSHJlZnpCYVA5cGVoN0dpWWtlaXl2M2plQ1BWWXEyNCtaZnNobzMyYjBPTzJydkl5a285V0c5ZWoxTzhvOExWdXlRbmNmYUppUTZQV2NxMWFkS3IrdmJKTmE3VnE5bmY3V1lUWi9hb2NQT2p6NlFmVjVucnFkcXRlbnQ2OHB6eGVpUGQ1SVhYckdOZW9aaU1TcmZnUUNWNjFBVm1zblkrQjZuZWk0Uk9mcGE4QWhkV2ZyTEhOSnpqS1g3aUFDNm81dDdPZ0pVdjY2UW8rQVFubGlKanBYZnllUmVnZU1vVU15cFIzYmlpVm5tVXZhc2ExWTdnVDlyVStaSDdGZGh3ODZwS0ZETXIxT3FvY095WlJQWUE0ZmRNZ25mVFpiUzgzMXBmZnNKeDArNkpCMmJDdjJPRWhvdmE4czh4blRaMG5MbHF5UXl6aC9YYUc4bkhKNzlNcll6RHEwS0Fja0V0dXIvTDZ5L00zVXA1bUR2ZDZ5b3N5VGs5dkxCNy84ZFlWZUovWmFnYXZ5UkVtY1FPM1lWdXoxWFYrQmhkaEg5TXBHTDNqMlYrZDY3VkQ1bzRDL2NoTmxZMC90S3JkYjhaNnlIc3prUzR1WjlpRkprcWt5VTU3YzVLOHJsUGRGOGI3eWhFZmtJem01dmJ6dml4UDlRT3ZlRnlOOWpOYTJpbVcxZnVEU09pWnFsYUdvUjJWWmlaUDBoZ21KY24xSHN1OVFweTJPQjc0Q0tiM3RtekY5bHQrK1ZZL3l4RndNUXFOOEdSM2NSdG5PN0tsZHBYazVDM3oreUtkM3dxeHN3OG9mM3ZRQ2ZWLzBmclFReDExLys2clIvbExrUnl3ajZsTHJCeStqeDBwLys0cVpmc2hvM3liU0RyUXRHVTNIYUo4c0JnQVVkYkJzeVFwcDJaSVZVbkp5ZTduTWxIWGNNQ0ZSM2hlVTUxYnFmVnk5VHZVeHkxL2dxanl1cFBmc0orV3ZLNVR6cFY2SDJmeHBVUzZyOThPb3J5QlU3MzNsZDR6OEFCbE9ERnhyMmFzK0ExZkxVWjdJaVE1SCtXdWwraGN4OGI3V3lNUEt6bDY5dlBxWFNxMFRNSFhhdmpwQXN3Y01md2NydllPZkVjcE9VM2xTb0xVZHloTnF2ZmZOYm85ZUdadFpoNXJ5bDFGMUdXc0ZxV2JxMDJqZDZTMnJMRy8xQ2FVNEVJdDYxQW9NUkY3VlY0VFUzOVg3dmpKOVgyVWp0dGRmVzFCZVJmSFZEclgyTHpXOXNsSFdaeUQ1VWpQYlBzeVdtZkxFV0d2YnhEcVUrVkMzQldVQW9pNURJM1Z2bEhwLzhyV3RhbVlEVjJWL2JUYnY0ZW83eERyR2pwNWdhdlJ2STJXazFiZnFVWjZZYTcyVSs0MFl6Vm45RXA5cC9XRFZNQ0ZSR2pva1UvZVk2T3NrVytzSzVZenBzMHhkSmRicVkwV0E0ZXZ1Q0RQOXBmSkhKTDFnUFpoanBWYjdNZG9QbWVuYi9KV0RyN1prSmgyais3bnlqZ1psMmlKZ2xTVGZJd2dyUHhQdFZObDJ0Tzd3VWJkSnJiWW02bHM5b3I3eXVDM1dZVFovL3NyQkY3MzlRcnhuczdYMDJHK1ZQd0JGZXhUMnVoUzRjbkFtaW9wWFhuME5nUHU1SGZGQSs4QjdCNkJONnhTY1BsT0tGMTVZaXZ6Q3RWN2ZHelhxTjE3dmpiaC9PTjQ3c0E4blNvOTdmWlk1TE5QanVhRGpKOXpMbkR0L1h2ZTV0WjNGdTd3R3RQREhjYWdFZi8zcldseThlQkUzM1hRVG10elVHTUQxRVRyMWlQeU11SCs0NlRSdXV6VUY4ZkVOVUZGeEJWOSs2VDNpckhLZ2dIYTN0L1A3dnVCeWx1Ti9pMTdIQng5K0JBQit0MGRkeG9Hc1F4Q2orTWJITi9DcWc3SGpSMlBxOUdueW9FVkErT3BUYnoxQ2JtNCtjblB6NWIvUG5EM3JrUjh0NHJNelo4OTY1TlhJZDVYcCt5c2JyZTNWcW5PdGN0UnFoMkwvS25PVytjMGI0RjAyeW1YTTVrdk5iUHNJdE15VXp5UnFEYmloeklkNmtMU0JBL3A3RFFBU2JOMEQvdnNZWDlzYXJMSGpSK094eCtmZ3dsY3VMRis2RW8vTW5vSE5iMjRHQUV5ZDhxQzhYQ1Q3amxFangyRDloa0w1MWFaMUNoNmRrWTFIWnM4d3ZYMHVaem4rdlBKbGxKNzhOd0FncmV2ZFB2dldRSW5Sbk5WV3JGb0tlNWRVbEo0NGptZWUvaE0yL0cyanZLMFZGVmV3ZGNjVzdINW5Oelp0M0docVVMNFZxNWJpN1czYjVPZGEyN1JPd1lwVlM3MmVIL1JsNnBRSDhkNkJmZko0Rk1YYmQrTDBtVkxFeHpmQWY0MzJQaDRMWnZyTHFROCtpTVhQTGNiV0hWdXdkY2NXdEdtZGduR2pSM21NYUJ2TXNkTGZzY2RYUDJTMmJ6TjduRmF1dzB3NlJyeDNZQjhBb0ZOSHU4ZCtwdHplL2UrK0svOWZQWUx3aWxWTDVmWXFsaE1qM1hmcWFQZFl6OWp4b3pGaDBnUkQrUkwxY0hQU3pSN3IwR3JiWnZPbjVkS2xTN3FmRGN0d3Q2YzN0Mnd5bEcrdC9YZndvSXlnUjE4bTR4aTRVc1E1RHBYSUhlb2h4MEhOSWZrM3Y3a1pMbWQ1MEtPMHBYVzkyK1B2eTkrN083QVRwY2QxcHlveGEyYjJiTGt6RXdjb28wUisvSmsvZDZFOGRZWFpOTXdvM3I0VHcwZU04Rmkvdi9UVVpSeklPZ0lWanZvMFl2MkdRdFBmRVhrOTVEZ290MytyTU5vT2pRaWtiR3E3WU9zK21ENG1WRVkrTUFJdnY3b0tHOS9ZaEtiTm1xS2k0Z3FhTmJYSko5S1I3anZ5QzljaXJldmRXSk83VHA0ZTVIZHpmb2NUbjVlYUdwbStJSzlJL2dGRHBCVm9HNjZ1cWd6b2U0SXRxUVZXckZxS0ZhdVd5c0gwUDk3YWdpTkhIYWlvdUlMbHkxZVpIazMrTDM5ZWdjRkRoOGovTjB2OW84V0p6OTFCc1BKSFozLzhsZWZDWithajNlM3Q4TUtMUytXNlhQemNZcFNlL0xmOEE3YlJQaXFjKzRxLzdRalZjZHFLZldpalJvMUN0aTVSTnVvZlE0T1pWc1pYL25yMjZDR2ZINGdmM2dCM1d4RS9NcWFrZEpCLzRPblUwVzQ0M1dsVHNqa1RSb1J4VkdHS3VCZGV1TDZUNjNYc0ZSVlg4T2VWTDN1OXYzNzk2MTd2Ylh6RC9VdlpiU25lVncrYk5tdnE4YmRZSm5OWUpxcXJLalZmWm43UmREbkw1WU5rN3VwY1hMNzBEYXFyS3BHN090ZlE5MFYreERib3BTRU9oc28wenA4OWgvajRCb2J6YXNURDAyZWlvdUlLUm8wY2cvTm56Nkc2cWhLWEwzM2pjM3ZVWlJ6SU9vU09IZThBNEs1L3JWRWcxZTBsMVBWcEpHK0FlNG9hcmJTY3pyTzYzeGQ1bmZqYmlhYS9Dd0FEQnJwSE52WlhObUk1TTN5MVEvRmV1OXU4OXkvQlNObUVvaDdNdG85d2xabXZmQlR2M09XMWZEQjFiN1NQOGJXdG9UQjVjaFlBZC9BdCt1R1JENHlRUDQ5RzMvSEk3Qms0N1BnQTU4K2V3NmlSWXdBWUc1bGVhZDZDUmFpb3VJSnBVN0xEMnJjQzdpQlFxLzZCNnlPMWlsRlNiVWt0c1BDWitSNXpkWjg3Zjk1MG1nUHZIWUJSSThkZzJwVHNnS2RRRS9XODhZMU5lSHZiTmdDZVY5cTFtTzB2eDQ0ZkxkZmx0Q25aQUR3RE9LUEh5bUNPeDRGdXg5anhvNE0rVG9lakR4VUIySkdqRHEvUmQwV1EyTE5IRC9rOTlVakR5cjlUNzdvTEFPU1JkTlhyTk5QbjlPM1ZGNERucU5jdVp6bEdqdlRlUHJQNTB6SjVjcGI4L3ovTW15dVBnRHozcWQvTE0xb29SOXYrMWRBTXpmVjA2bWhIZFZVbFBuci9RN2xPZlYzcHBmQmc0RW9SSjI0eHkza2lCK2ZQbnZONmlZNGt2Mmk5MTNlMzd0Z2lUM25nY3Baalp2WnMrUXFHWG1lak5ISENiK1U4S0R2YWdyd2lwS1IwTUQya2U5a1gxMzh4Vko3OEhqandnZGJpWHY3N01YZW4vZDZCZlY3YkpZYnAxMHRET2RkbnFMakszV2tOSG55dng2L3BScmNuMkhYWXU2VEtCOXZISHArRGdyd2l1SnpsS01ncndtT1B6L0ZhUHRUMUtZaUQwb0VESDhEbExFZng5cDBlZVpzNDZTSDVvQzNxU3psbGpoYVIxelhyMW5qazFjaDNBZmVKck5nMzlNcG04S0NNZ081U1VMWkRNUTJGZXYveWRhS3FMaHR4VWxTOGZXZEFVeVVZU2NkSSt3aFhtYW56VWJ4OUoxek9jc3lmdTFCem5zQmc2dDVvSDJOTGFvSHUzZExsUElsdEZYVWdib2xUSzk2K0U0NURKWDZubFJEYkxHNWRCVHhQQ0NQZGR5aW45TEFsdGNDRUNlTU1wNk9WcHZMMjhJOUxQZzZvYjUyWlBWdno1ZStrM3VVc3gzMzNEY1g2RFlXNCs1ZGQwU3U5di94ZDVXMjl5cE40TTE1YzhueFFWNFVtVDg0QzRQN1JRdHdtN0MrSU10TmZpdTBWZDFuTmZlcjNYdXNMNWxocHBnMzYydzY5dmkzWTQzUTQrbERsT2RFREkwZGgrZEtWOHRRNDNYdjBoc3RaanNtVHMrVGozWXZMbHNydGRXYjJiTHk0ek4xbTR1TWJ5SFV5NUw3N3ZOYXBubUxMbjZlZlhpQ24rZktycXhBVEc0ZWZ0MnFwZVRlSzJmeHBzWGRKbFgvWXFxaTRndUVqUm1CWXhuQTg4L1Nma0pqb1BhV2sxaU5VNnZWTi9PMUVBTzRBWGoyOVUyZDdHanJiMDNRZlg2SWdSZnNoMjBpODZuTndKc3NRZ3lTWUhZQkYvSzAzdEw1NndBWmZneGVvcDA5UkRvZ1J5RlFLSWs4TkV4S2w5Sjc5cE9UazloN3I5TWZJRVAvS05PeXBYYjNTRUlNNTZBMjZZdlI5WmRuWVU3dEs5dFN1SHFOVEtyK3ZWOFptMXFFbDJPbHc5T3JUNklBV2t1UTVtSU95ZmVrTjR5L1M5bGNQeW9GN2xIbHRtSkNvT1JpTyt2dUJUSWRqdEMwRU94M080WU1PM2JKUjFvUFpmR21sRSs3cGNOUnRST3Y5WUtiRDhWWDNXb3oyTVVhM1ZXdHFGTDNwY0pTVW81U3FCd1dLWk4raGJDdnFLVlQ4dFZWMTJzclJka1dhV24yckhuK0RNeG5kZjN6dGY3N2FxdEVSVVBYeWJKVHlPMXFESkdveDBsK3FwNUJSdG0xMU9tYVBsYjcyRlRQOWtORyt6ZWh4V28vUmRIenRvMnBHcHNQUkc4bGViSXQ2YXFCZ3A4T1JKTWxydGdPUmp0WTZ6T1F2MExKUXZ0U0RSdW50VXlML2V0TVZSWEtLbkxvME9CT3Z1RkpFcmNsZEI4QjlhNmNlZTVkVStjcUJ1Q1ZOVEJDOWFNRTg1RHlSSTkrdUlpYUVmbWVmNSsxNVlua3QrWVZyc2VUNUpSN1BNWFRxYUVmdTZsek5BYUg4cmZlOWQvZGk4S0FNSkRSc2hPTW5qdU9POXUzeHlwOWY5cHNQWWNXcXBjaGRuWXRPSGUySWoyK0ErUGdHNk40dEhWdmZlbHYrVlZ1WnhvblM0N2l4VVNOczJyaFJkLzJCdnA5ZnVGYWVXUHZJVVFlK3UzUUpBL3IxMTl3ZXZYV1pXWWNXZTVkVTdOKzdGOTI3cGN2bE1YaFFCa29jQjVIUTBQczVGcVAxYWFRdWhPWExsc2pwTjJ0cVE5L2V2UUM0cit5VU9BNWkxTWd4SG0xdzhLQU03Tis3MSt0V1BIV2FiMjdaSk9lMW91SUtFaG8ya3IrcmRRVkQvWDFiVWd1VWxoN3ptUHk4VGVzVVRKdVNqZExTWTVwWERvMjJCYTEyS01yUnlOVWFlNWRVdVd6RXVqdDF0R1BKODBzMDl5dXpiVlNaanBuMllhYk16T1JKblEvUkZ5MWFNRS96TzJiclhzbG9IMk5MYW9IMzN0M3JzYTNObXRvd2F1UVl2UGZ1WG5sYmJVa3Q4TWRGejNpVVI0c1d6WDJXQWVDK05WZDhMcTRpQzVIc084YU9INDJ0YjcwdGw4bnBNNlZ5bmZwcnExcjFNbTFLdHR5M0F2RFp0NGJMaWxWTDhkSDdIM3IwTFNLLzZ2cUxCbVY5UC9KSXRxSHZHT2t2Qjk0N3dHTzdUNThwaGEzRnpaZzJKZHRyd0J5engwb2p4Mk1qKzd6UnZzM3NjVnJOYURwbTJ1YWJXelloNTRrY2orTmo5MjdwV1BMOEVubGZXZmpNZk96ZjY4Njd1THFwckNmbGdHZWlqeGsxY295OGJLZU9kbXphYU80Vy9ZSDNEb0RUZVJaYjMzcGJ2clc2Vis5MCtmT09kMXkvZGRwTS92eVZSZTdxWExuUFZwWkh6aE01eUYyZGkyWk5iY2pMWFdOb1gvdkRFMDhBY0YvRm5UanBJVU41b09EZElFbFN0UE1RZGpHeGNYMEE3QVlDSHp4Qit2Z0dVOHZQK245M1lkWDZZMTd2Vngyc0NpaDlwUnVTRHdFSm5RRUFEMDU2R0FEdzJ1cS9CTDFlSWlJaUlzRnhxQVQyTHFueXdFTnRXcWVndE5UNzNJYklqTTcyTlBUczBRT1RKMmZCM2lVVnhkdDM0dUhwTStWblRaYzh2eVNnRWNLREZZcEJRYU9oVTZjdU9QYlpKd0N3c0xxcWNrR1VzeE5XSEZXWWlJaUlpRHk0bk9YbzJidTN4ek9hajg0d2RyV1ZTRTlCWGhHT0hIWGd5RkdINXZReTNidWxSeVZvQmJTblB5TnI0YTNDUkVSRVJPU2g3SXN5M0piU3p1TlcrR2dGRkZSN0RCallIOU9tWktON3QzVDV0bWZ4YUVyT0V6bGVqMzRSS2ZHS0t4RVJFUkY1c0hkSjlaaU9oeWdVeEh6RlJJRmc0QnBGRStiZGlVOUt2WWRKUDFod01ncTVJU0lpSWlJaXNpWUdybEgwU2VrVmZQeVovc1R6UkVSRVJFUkV4R2RjaVlpSWlJaUl5T0o0eFpYSUl1YlBYWWl2TDM2RHVVLzluaVBiRVZsQThmYWRBSUM3VXUvaVBoa0dMbWM1UGk3NUdBQzg1a0FtSWlKUzR4VlhpcmppN1R2UjJaNkc1VXRYYXY2dFZKQlhoR0VadzVHUzBnRXhzWEZJU2VtQVlSbkRVWkJYRkpHOE9nNlZZR2IyYk15ZnU5RHJzNlNrVm9pSmpkUDhMSkIwWGx5MkZDKy91Z283aTJ2M2lIb0ZlVVZJU2VtQXp2YTBhR2VGYW9INWN4Y2lKallPU1VtdFFyN3V3VU9IWVBEUUlmSStHYzYwYXBwUTdNYzdpM2ZKWlN6VXhETFd5L1A4dVFzeE0zczJISWRLREMwZjduelZ4TElsSWxMaUZWZUtLSmV6SE1OSGpFQkN3MFpvMnF5cHg5OGQ3bWp2c2V5d2pPSFl1bU9MeDN1bno1VGk5SmxTYk4yeEJldlh2NDQzdDJ3S2EzNlBIdjFVbm1kczRUUHpQVDY3OEpVTEFQRDF4VytDVG1maXBJY0FBTG1yY3pGMi9PaWcxMmQxWXBKeG9tQ0ovVS9zajdVbHJab2dIUHR4VFN4anZUd3ZmbTR4QUtCYnR6VFl1NlQ2WFQ3YythcUpaVXRFcE1RcnJtSHkwdU1mbytwZ2xkZEw2V0RCU2IvTDFEWTdpM2Vob3VJSzhuTFhZT3o0MFI1L0syOFZVd2F0Z3dkbFlPdGJiK1A4MlhQSVhaMkxUaDN0QUlCdnYvc3VLdHNnbkQ5N0R1ZlBuZ3ZKc083YnRyMkZ5NWUrcVJOQksxRW9yVmkxVk40WGExTmFkVlZOTEdPemVZN1VObmJybG9ZMnJWTVFIOTlBODI4aW9wcUdnYXRCTnpSNElOcFp1SzUrbzJqbklHQUhEcmpuaE12TnpkZjhHM0RmZ2lhQzFtbFRzdkhtbGswWWVPOEEySkphWU96NDBUanMrQUE1VCtSZ3d3YnYyNFZuWnMvMnVLMTRadlpzcjJYRUxiNEZlVVdZbVQwYlNVbXRrSlRVQ3VQR1pIa3NOMy91UWt5ZFBrMytPeVkyVHY0ZUFLVGFmNEdmdDJycGNkdXkwWFVYNUJWNTNMSWxucDlUdncrNGJ5TWVOeVpMM2k2eGJXWnVVUzdJSzBKbmV4b1NHalZHUXFQRzZHeFBrNS9mODdlYytyWnNaUjRkaDByUUs3MC9rcEphNmQ3dWJZYVI5QVZSSm1LNW1kbXo0WEtXKzF5M3lMZkxXWTVoR2NQbGRIcWw5L2U2blU5ZDdyN3lJOXBkUXFQR1NFbnBnSEZqc2pUellxUjltbG1mbXFnUDlYWXAyNldnOVo2djk1Y3ZYWW5POWpTNURJZGxEUGNxTXoxRzZrclVTVkpTSzkwNjBWS1FWNFNmdDJxSlZQc3ZQTjR6MDBiMXlzMUlXc3JQZk8xam9kaVBqWlNSMFQ3SVh6cmp4bVRKNi9MVlZvMVN0MzI5N2RZclkzOXRTR3U3L2JXalVQVTM2ank3bk9XSWlZMlR2enQxK2pURXhNYWhWM3AvemVXWEwxMnBld3Z2ek96WmlJbU44N29sMjBoZjBySGpIUUNBTHRmU1VmOU5SRlRqU0pKVTYxLzFZMkw3MUkrSmxlckh4RW9CKzJhdmRMVUVVWDlKSng3d3lOYmtpVk9seVJPbkJyNWRFVFpqK2l4SldSZnF2eVZKa29ZT3laVHF4OFJLeWNudERhL1hXZWFTa3BQYnkrdFN2cEtUMjB2T01wZThySGpmWm12cHRhdzl0YXU4M0x5Y0JWTERoRVN2WmZMWEZYcXNSL3h0WnQzNTZ3cTl0bHZ2L1IzYmlqVzNxMzVNckRSaitpeS9aYU1zWTcxdDhiZWNNaDJSeDRZSmlacmxzMnpKQ3AvNTBkdDJvK2xMMHZVMjBqQWgwYU9zeDQ2ZTREZGQ5WGZFcTJGQ29uVDRvTU5RdWUvWVZ1eVY3NFlKaVI1dE1MMW5QM2taTSszVHlQcTBIRDdvMEt3UG02MmwvTDVXVzFXK3AvZisyTkVUUE1wSnVXNWxtV2t4VWxmT01wZkhaeUlOZFoxbzBXcFBadHFvbVhJTHBPMks3d2E3SHhzdEk2TjlrSzkwOU5ycTBDR1pQc3RkanoyMXEyN2IxNnM3NVh0RzJwRFdPdlgyYlVrS2JYK2p6ck96ek9XVnZuSWYxbHBlYXgrVkpFbE9iMTdPQXIvMW8rNUxiTGFXVW5KeWUzbmJiYmFXa2oyMXE5OTlpb2hxbGp2djdDejZnUVdTQmVLdWNMNmlub0ZJdk9xSEluQ1ZKRWs2L1VSMGc5YlBla3JTRDJVZVdhcHBnZXU4bkFYeVNaWFczNUowL1VEdEt3aFJFeWNXTmx0TEtYOWRvZVFzYzBuNTZ3cmxkU2xQdUpRbmR2bnJDcVhEQngzeTkrdkh4SG9jMUgyZG5HbWQ0QnRkdDVuQVZXeWYySzdEQngxU2VzOStYdVdtUmJtK0dkTm55ZDhmT2lUVDR5Ukhiemxsd0tKMThwN2VzNTkwK0tCRDJyR3RXQzVyZnlmSHZnSU5JK21MY202WWtDam4zMW5ta3I5bkpGMjlkcUxPKzlBaG1kS09iY1dTczh3bDdkaFdMSjh3S29OSThWMVJ0eUl2eW5aa3BuMGFXWjhXRVJ6b3BhSFhWdjBGcnNweUUrODV5MXh5ZXY0Q2FpTjFKZHF6UGJXci9MNTR6OS82L2JVbmYyM1VUTG1aYWJ2cWZVeVNBdCtQelpTUm1mN05WenJLZ0NkL1hhSGhJRjVOOVBISzhoRnRRQmwwYVpXbmNwdjh0U0hsdXVibExKRDNXYTA2RDNWL28xY1dldnVZMXZLaTNKVjlnZml4UTVtMm1iNkVpT29HQnE2MTdCV3l3RldTSk9uU0lXblB1bUhTKyt2dmRsLzlqTlNydkVDU3FpOTVaYWVtQmE1R0tFOG9qRkQrdXUzckJFRWMrTFhXcjdlT1FBTlhmK3MyRzdqNjJtWmZKNkpHVC81OUxhYzhZVmJuVVhuaUtFNVFHeVlrK2t6TDEwbWJrZlFsNlhvNWp4MDl3ZkRWQTJXNnlpdW02czk4clcvWmtoVmVnWWJ5aEZHOVhra3kzejc5clUvTDRZTU9RMmtFRXJocW5WQkxrdWNWUkY4L0dQaXJLMlg1S0xkWHVVMUdmNURRZXM5WEd6VmJibWJicmo5RzkyTXpaV1NtZnpPYWppUmR2K3F1ZDlWUWo2OGZPRVRaR1FsYy9lM3ZZaGxmN1ZSOE45VDlUU2dDVitWZEFvSzZ6TTMySlVSVU45U2x3SlhQdUpxVjBCbFhmL1k3Wk16OEFyaDFZK1JlemNjQTlSTzhzck5yOXo5eHl5MXRJMTBLWWRXc3FRMEFjUEhpUlVQTGk2a3E0dU1iZUExdU5IYjhhSGtnQ3ZVME05MjZYWDltS05Sek5JWjYzV0phbm5GanNqQXplemIrdCtoMWVidSsvUEpMM2U4ZFAzRWNBRERpL3VFKzErOXJPZkZlbWJQTTZ6UGx0clc3dlIwQW9LTGlpcyswUXBIK3FKRmpBQURyTnhUaTdsOTJSVXBLQjhQUDE4YkhOL0NhTTFMWlRvNGUvVlIrWDEzdVgzMzFGUURQVVRtblB2Z2dBR0RyamkwWVBIU0kxL043WnR1bnYvVnBFWG4ybDBZZ1JOMmNPMzhlNDhaa3lTL2xjK20rcG5EeVYxZks3K2JtNXN2cmYrR0ZwWnJMbU9XcmpZYWkzSXp1WTBEZyszRWdaUlJJSDZTWHpyZ3hXVGh6OWl5QTY5dHIxSWxTLy91MlAyYjI5MUdqZnVQeDk4QjdCM2p0MjVIc2I0d2FPMzQwbWpXMW9hTGlpcnp1elc5dUJnQk1uZUx1RXdJOTFoRVIxUmFjRGljQWZmdjNRVUxEaG5odzBzTjRiZlZmb3BhUHhVOC9pOHZmZjQrSHBreU9XaDdDb2QxdDdYRGhLeGYrNy8zM281MFZTNWcvZDZFOHJVSjhmQU5UZ2VIbDd5K0ZkTGx3TVp0K2Z1RmFwSFc5RzJ0eTErSElVUWRPbnluRjcrYjhEaWMrTHczSktNK0FlL0FUTVJXU3IzSmYrTXg4dEx1OUhWNjhnZmE2QUFBSDhrbEVRVlI0Y2FtY2w4WFBMVWJweVg4anYzQ3Q2WFJEdmI1Z2libzVVWG9jUjQ0NlRIL2ZURjJ0MzFBWWtqeEhrdEcyRzh4K3JCU3BNckpTWFlSNmY3ZGlmd01BSXg4WWdaZGZYWVdOYjJ4QzAyWk5VVkZ4QmMyYTJqamFQQkhSTmJ6aUdxRFZyNzJLb2czcjBmMmUzdGk5YTA5RTA5Njlhdy91SFpTQlB6Ny9MRjR2S2tBTFcvT0lwaDl1NHRmbDAyZEtkVWV5bkQ5M29UeFM1SUNCN3BFYUt5cXVhSTZBSzA0UXhYSldveHdaOC9pL2pudDlKazUyYzFmbjR2S2xiMUJkVlluelo4OFp1aHAwVzRyN0N0UEdOM3pQZCt0ck9mRmV1OXZhK1UwdlVJR2svOGpzR1RqcytBRG56NTZUcjRocytOdEd2Mm41YXljZE85NEJsN05jRGxxVjVaNjdPbGR6bldLMDYvTm56MkhhbEd3QTEwLzhBMm1mdnRhblJZd1c2aThOTGNvMnB6VnlzYWliekdHWnFLNnExSHo1TzdIMlZWY2k3d0R3MGZzZkJyVCtRQVZUYm9LUmZTelkvVGhTWldRa0hhZnpyS2wxR3RtM2pUQzZ2NjlmLzdySDM4WGJkM3JzMjBiekZLcit4b3pKazdNQUFJY2NCK1h0R1BuQUNQbnptbjZzSXlJS0ZnUFhBUFh0M3dmLy92d0VHalZLd0c5R2o1V25ONGpFNnplanh3SUFEdXpmajc3OSswUzNJTUpnN1BqUkdEd29Bd0R3OHF1ck1DeGpPSXEzNzRUTFdZNkN2Q0wwU3UrUHhjOHR4bjFEaHNMbExJY3RxWVc4L0dPUHowRkJYcEc4N0dPUHp3SGduZ3MyMkZ0Mmk3ZnZoT05RaWVFcFFIeFJuaUErT0hrcUhJZEtVSkJYaEZkZWU4MWp1Ykl2cnQrdXBqd1pFZlBmK3ZQZmo3a0QvL2NPN0pPbmIzQTV5K1hwSXNTMktKY1RVNitJNWQ0N3NBL0E5UjhVd3NGcytwM3RhZkx0czdha0ZwZ3dZWnlwOVBUYVNhZU9kdGk3cE9xV3U1aStTYWxYZW4rNWJHMUpMVEQzcWQ5N2ZHNjJmZnBibnhaN2wxUjVmbU85Tk5URThxKzg5cHJjdGtlTzlBNStKazc0TFFEM2JZdktrK1dDdkNLa3BIVFFuRlpKeVY5ZEtmTStjZEpEY3ZCY3ZIMm43clJOb1JKSXVha1oyY2VDM1k4alZVYnFkRVQvSUxaSFRPZGl4cStHdXR1K1Z2bUlmZHNmTS92NzFoMWJNSC91UXJpYzVTamV2aE1QVDU4SjRQcStEVVN1dnhFL1NodzQ4SUdjSDE5RStWZFVYSkduaEpzOE9VditQQnpIT25FcnVONDBRRVJFbGhMdGgyd2o4UXJwNEV3VU1jcUJPN1JlNnNGSHpFNkhZMlFhRU9VMEJlclBneG53UnBLMHA0aFFqbVFxaU8xcW1KQW8yVk83U3NuSjdUM3k1RzhBbjNCTmg2UGVuNHdPMWhMc2REaks3NnVualBFMW9KZlo2WENVNVo3ZXM1OVh1VXVTOXhRbnltV1VnOFFZYlo5RzE2ZkY3SFE0WXFBcGRSbG9MYXVlRGtlWmpwRXBpUHpWMWVHRERzMDY4YmQrZFJxKzN0TjdQMUxUNFFTN0h4c3RJek45a0JiMXREdnE5aUh5YVdZNkhMMiszTWgwT0ViYmtMTGUvTzNia2hUYS9rYXZMTlRiYldSZ0srVitxVFZDdTVsam5SRkcrazRpc3JhNk5EaFQxRE1RaVZkOUJxNDFWdjY2UWltOVp6LzVKREk1dWIwMGRFaW03c2lTTTZiUGtnL3F5Y250TlEvRzRzUkdiNzQ4OWZ2TGxxendXS2M0Y2ROYTNzeTZuV1V1YWV6b0NaTE4xbEt5MlZwS002YlBrazlvbEtQV09zdGMwdEFobVhJWjJGTzdla3p6WUdUazJmeDFoWkk5dGFzY2RLVDM3S2Y1UGZWeTl0U3V1cU5YcXFmdzBIdGZLdzI5NVl5a0wwbnVBRStVaWErNjFrcTNma3lzUEJXSnNqelViVXBaN2paYlMza3FFM1hleFRRYS90cWRKQmxybjJiV3AvVmQ1WFlOSFpMcGN5VFNaVXRXU1BiVXJwTE4xbEl1QTEvN2daRzZVVE5hVjhyOVFaeTArNXNUV0pLMDI1UFpOcXBYYnVxeU1OTjIxZnRZS1BaakkyVmt0bi96bFk1b2c2TDlhMDBWWm1RcUgwbnlidnZ6Y2hZWXJqc2piVWpaeG1kTW55V1hzOWErclV3ckZQMk5rWFpsczdXVTUyTDFWM1lpSFYvdDMwaGZZb1I2bmxnaXFubnFVdUI2Z3lSSjBiN29HM1l4c1hGOUFPd0dnT3FxeXVobWhvaWlvaUN2Q0JNbVRRQlE5L3FCbU5nNEFPN25Lem5RQzlWR2JPTkVWRmQxNnRRRnh6NzdCQUFXVmxkVkxvaHlkc0tLejdnU0VSRVJFUkdScFRGd0phSTZSY3dUWEpmVXhXMm11b1Z0bklpbzl1T3R3a1JFUkVSRVJEVVFieFVtSWlJaUlpSWlzZ2dHcmtSRVJFUkVSR1JwREZ5SmlJaUlpSWpJMGhpNEVoRVJFUkVSa2FVeGNDVWlJaUlpSWlKTFkrQktSRVJFUkVSRWxzYkFsWWlJaUlpSWlDeU5nU3NSRVJFUkVSRlpHZ05YSWlJaUlpSWlzalFHcmtSRVJFUkVSR1JwREZ5SmlJaUlpSWpJMGhpNEVoRVJFUkVSa2FYVmxjRDFsUGpQaHZVYm81Z05JaUlpSWlLaTBEaDU2cVQ0N3pmUnpFY2sxSW5BdGJxcThoU0Ewd0N3WWVQZm9wc1pJaUlpSWlLaUlHMVl2eEUvVkZ3UmYrNkpZbFlpb2s0RXJ0ZHNCb0F0MjdmaVNNa24wYzRMRVJFUkVSRlJ3Qll0L3FQNDcrbnFxa3BITlBNU0NYVXBjSDBKd0hjL1ZGekJyekx2Ujducnkyam5oNGlJaUlpSXlMUjdCMlhnMkdmeXhiZ0ZVY3hLeE5TWndQWGE3Y0tQQXNEWmM2Znd5MjQ5c0h2WG5xam1pWWlJaUlpSXlLaHkxNWU0ZDFBR2R1MHVGbS85dmJxcWNtMFVzeFF4TjBpU0ZPMDhSRlJNYk54THVCYkFBa0RhM2ZlZ3h6MzNJQzN0N2lqbWlvaUlpSWlJU052eEU1L2puWDM3c1AvLzNsVSsxMW9Db0U5MVZXV3RINWdKcUlPQkt3REV4TVpsQWxnTElESEtXU0VpSWlJaUlqSnJZWFZWNVlKb1p5S1M2bVRnQ2dBeHNYR05BV1JlZS9VQmcxZ2lJaUlpSXJLdXZRQWNBRjY2OWhoa25WSm5BMWNpSWlJaUlpS3FHZXJNNEV4RVJFUkVSRVJVTXpGd0pTSWlJaUlpSWt0ajRFcEVSRVJFUkVTV3hzQ1ZpSWlJaUlpSUxJMkJLeEVSRVJFUkVWa2FBMWNpSWlJaUlpS3lOQWF1UkVSRVJFUkVaR2tNWEltSWlJaUlpTWpTR0xnU0VSRVJFUkdScFRGd0pTSWlJaUlpSWt2Ny8yM1p0SDVWUERIRkFBQUFBRWxGVGtTdVFtQ0NcIixcbiAgICBvYmplY3RUeXBlOiBcImltYWdlL3BuZ1wiLFxuICAgIG9iamVjdFVsaWQ6IFwiMDFKVEtFVDU0MzA1UjJHSEVIRUNXMzNBMENcIixcbiAgICBzaGFyZFR4SWRzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiBcIjNcIixcbiAgICBuYW1lOiBcIkNvbXBhbnkgTG9nb1wiLFxuICAgIGRhdGVVcGxvYWRlZDogXCIyMDI1LTA1LTA2VDIzOjIwOjE1WlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk9mZmljaWFsIGNvbXBhbnkgbG9nbyBpbiBQTkcgZm9ybWF0XCIsXG4gICAgZmlsZVR5cGU6IFwicG5nXCIsXG4gICAgaW5kZXhpbmdUeElkOlxuICAgICAgXCI4ZGJjNjFiZmQ5MmY0ODMyZDdmYWM3NDRiNjYxY2E0NWJhYjhlMDg3MjZjYWUwM2JlODY2NThjNjAxNmJhYzFmXCIsXG4gICAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0OiBcIjIwMjUtMDUtMDZUMjM6MjY6MjVaXCIsXG4gICAgb2JqZWN0RGF0YTpcbiAgICAgIFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUdvQUFBQmdDQVlBQUFEMXV1ZnhBQUFBQ1hCSVdYTUFBQ0U0QUFBaE9BRkZsakZnQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFDQTZTVVJCVkhnQjdWMTlsRjFWZGQvNzNEdHZacEpNOG9ZUWNVSXdrejhRdExhZHNNQ2lWalBCZnNtSHlXRHRza2doc1ZacFZ4Y0orTkd5MnBKa3JicW9DazJ3Q2k0L21rUkVSWXZFaXNnZjJreW9YWDR2a3RwaTI2aDVTQ0NSRUdaSUdHYmV1eCtuZTUreno3bm52bm1UVEpMSjUyU3YzTG4zbmZ2eDdqdS91L2YrN1gzMnVRRTRLNmVGSUp5VmxxSzFua21yWCtmdE1ZQm5PeEYvQVNkUlRncFErN1R1U3ZmRHhScXlpd0gxcFFnNFg0TitSaW44OXN1NzQzK0ZreXlwMXRkaG5pOUR4Qms1OVZHU2dFb3lHSzJuMmE1NlEvOGt5V0hIb3BkVnRzTUpsQk1HMUZQUHZYUStacFUzNTFIK1pnVjRFYUNhQlpCRGhDcm5OWWxHVkxUQTU4K3JSbmZDU1JMU3BEL1RBTXQ0ZzRDQ1JrWWdwVnJWMHp4cUpCQ1o3UnhVSTlWUmxzSDJlcWEvTTRxVmJXL3F4VDF3SE9XNEFsVjdwdjZxS0k3ZlRGb3pRQm96WHlIOWZPb0w4OFcwclFTY0FpaGFlTC9PN3p6dm5QYjc0UVFMWVhNZTNjeG56YjNRa2hKSWFjWWdRVlJQQ0NnQ0tjbDB4S0FsdVZLTlJOTkMyM1JNSTRXZmpTWHc0OUg2Uy9mLzBldlBmUnFtV0tZY3FKMzc5OCtPRzEzWG9vTGZJVFF1TXgxUC8ranB6QWtvL2tKNlZCa01BQWJPZzhQYVpJN04rZGdETDZ2R1MrQUVDd0YxSFQxSjE0SGNjeU5EMWh4YWN0WWtBc2hxVWozUkJBNG9CaThsN2FwVEc3ZXp0aEY0VVNPSC94M0xzdnRHc3V6N055K2R1eHVtUUtZTXFGMTdHNzlGdmYrN2tPUGJNSUtacEMyTWdPbDg2bmdQbHRNa1BvY2JsVFYzRmlCdzIzUk9tN3A2M3N6amEwNmFKY3YwTFVyQkZXQzFDUW1BT0dHVFI2Q1lKYkdBR0UzS1dNTXNjSFlmbTBZQ2tiWFFnTXJIQU8zVEQwYTZzdjdtSzJjY0UyREhETlRPM1kzTFZRdzMwK1pyeStEWURsY01rdEVnRFpGQ1kvb1lLQXNTMzRCaWhQaDRhbUZ0c2o0TDIrSVREaFJwMURKYXZUdWptMHVzWnFoR0k3ZnJ4QUFrb0xFNXpBaEVCc3J1cytiUEFHU09JOEtCQXFvQk44M3d5eU1qK3E0UDMzak9MK0VvNUtpQjJybGJMOENvY1NjQmNabTlFbW1MZEw1QkJkaTBZYzRiRWZzbUxlRFJmdkZORmhEdnAxaHlJUlQ2NlhsejRyZkNDUmFtNUhRalgyS3pSa0NwZW1hMXhKbzViYzFjVW1nUUVRa21Ha3d5ckdhUjlyRjVUSExhYnJCRzZkaVlUamFoNWp4akdoK2d5L3pEeDQ0UU1BVkhLRHYzNjlrLzM1UGNycUxrTWFMVnJ6VS8wUGtoNnZOY0d5d0lFN1NrUWJUSFBCSUNrcjJTMFI3YnptUUNQVWpzdng2R2t5Qmtta2Z5REw2WVp4b1pGQ0lTU05wbHRqTzZYZlpCdEkxcG1qTVlTS1pTRWZQRExPZDIra3lHM1d4VGU2ck5PZUEvNTN3c0xWcS9jeXhKbjNqWHZiLzZ5SFVmZjJiaFpPL3RpSURhdWJkeE9SbnViMmlkcndUUlJ2WXJTaTRrNXM0RFowVkxKL2dHM3M3dGx2TkxYcVA0enpQenF2R240Q1JKSE9NWHNpVC9RcVp6Q3FYSUxodGdQR0FFUkU0QU1DZ0dDR1VBTlVEWmRXYU9vY2ZPZ0cyQnpZTDJsRFNPd2FYMm13bTNidzFzK05VTms3bXZTUUhGV3JTVHRBZ3kvU1hxK0Fzc09iQW1TNk9KTjRRd3NKbWpiUkMvaENEN3JGOXl2b21Qc3hhU3QzS3pNb0NCMnJxL0ViMFRUckxNbWhWL25oajVueVJhZjVVNisxY3BnOFRhUUNBeHlSQnRRZEVZZENCa21kM21ZOWxua1Y4aVVOQ2VRL3NTcTFIVVJteVJqMDFoRVdubnByZmU5ZXo2dzkzVFlYM1VUNTUrNllJS3RuMUs2ZnhWckFya2czSzBaMmxIdFEySmdBSVUvc2grS1RjVTNNQ1FteGdLV2Z1S21NbXNOUnlrbys1WEt2dlJ2R3JseDNBS3loTlBqVjA0bHVoM1VNZGZPcGJtQzR3ZjRuaXFJU1NpSUJrbTFqTHNUMkt1SkVWTE1nZ2NRK3NUU3pxSW9KaHpHRnorRHZwVFUrblkwaTIzTGFxMXVvZERBclZ6ajM2MXpwUFBVS2VlYjJNY3F3TktldHV4TzJGeXd2aEVnNlFkaGZFcEE2SUpibVd0ZnhoaDlNbDVWVHdsd1psSUJ2OXI1QnFpNE11bzB5K25qbWEvWlFoRFBTdmlLR1orU1lhT0JSckFoUDBKNlhDMFhpdG1XU2hQL3FIQW1oQ28vMzZ5L210UmhBOUVDcnFnQ0ZvOTliYStoYnlWNVFsQjRDcGFwUzJnaW83TGhkMXh6RVNnL1VqbitiM3o1MVYrQktleFBQaURGeTdMc3VpTzBTUi9CZE4wRXhBeldNd0dEVGhZQUdQb3ZBRlNZakEwMnBmbnVsWC9EMlU2dStLUkR5NG81UkpiQXNYVVcwUDZLUFY1bHdkSVRKV0xmNWlPUXdnUyt5ak56ZHJFVGxwTW81SjBBMmNicU9FajU1OENTZGVwbEkzYkRsNmJwTmxxTW9jTHhRU1Nsa0ZrelIwQjFqQTAzbWhSNG9OampyTzBrajRTZGFJK0U4Wk16Y05Sakl1MzNOSlRjOTh6amt5d1Q4b2grUXBac05ubU9rSVN6TFg0Qk1vTm1TOWdqK012WXRGZ1VCaWtYT3Z3a3V5SC91MUFGcjNsVEFPSlplV1NycStPMWJQcnNqUjdNQlBLYnRtZW9lTVVlMUh5MWpCRUpoTGcya3pYaFNDQjRXUk9iN0NhcDdCMStmbzl2ZTU3eGdGVmdmZ3U5a2tRbWpIUHNZT3NndzFtalNZWjNzWVBCRmdDNFRYUWFKcTZaLzY1YmFzdm5vY0g0UXlWbTYrY3UzdjFWWE52SlViM2o4VGtPWVVrRk56RVZwQUtHeVJOUTQ2L3REejhQb2JSWWdKMVlRcnBZZS9OVXR6b1BwZUErcC9kOWJmVHdhOEQ0K0RzcWJKZGdFWCtoalhJV2p2eFdXQXBPUk9JQ0QyajR6VFEzL1NjRTkwTDAwUnVXemIzTHFMZWYwZmpXUWFrMUlKbDQ2M01hUldXQURFU1dDMjNqWWFsNWYxWGZYajNhdlBaN1dlVDF3N3hBN1M1b0NBR0RxaUNSRmc2YnBRMlJ3OWVrWENWaS9MRGNzK0NjeXYzd0RTVTkzMysrWnNvbmZSaFR5Yk1VQWlZaE8wRUJLSWtKZDlGL3VwZ1hGL2tOU3JLNDk4bjQzVkJrVkVBSVFlb1cxMkt4OVVrTGVTRFhiUk1rNy9rdnVrS0VzdGQxNS96eVRUTDcyVU55cTBXR2UzS2c1NFVHbDAyZ1FCUStDbmZVcDJWZHF3cWdFTDQweUJXTXRsc2RPTkZva21GWnFHUGo5eGxPYkNWT09ycGlvN3ZnMmt1V1JyZlFlQWNTRXhXZ3JNWkdrT1R4OTFMWVlvTGRqMnB5TFVlYndZQlZodWdmcm83ZVIzMS80TGlEQTJoR25ITTVMYVZ0VzhsTFZNbU9TNmFwK0dlZWZQd0daam04cW4zbnZNQythdFAyTlFUQjdZdFFpRUpZL3huN2ZUREhtdUdIT3orcWdHS092cHlsNytEa3VZVXlWSXpWQUZhNnpENFZTajVJSnVaWUF3ck92b2huQlVqQjVQUmoxc0N3YUZsRTA2Mmo3RzVYWWQrUHdCTlNkdXZPU3BpR1p5ampWWTFkUXMvSmNOT3FJeUNvVE43UHppclRZVnN1V1hSTURHK3g0S251eUFBV3J5TW1NTWdXUzNJdVpYeC9EYndJcmk2bUJtNElYTVFkdWpqSm5CNU83dGZJY293aFIreE5hZVJBazU1VWNmcExobmw3OHhHS3gvbDNFVkpFV1RUdGNrNXl2K1JvU1J2QXNIUmJDdEtjSGNEZ3B5M1UwSTR0Q1JoM1NqVFdTbUxlL3FiZlR2Nk1iM0FMMEVaSUx1cFhjQXIxc3VkNFFZQUpRUEJnSlF5RGtaeS84VkhQRXc4allSaXptb0lDSzliQVRmZTlCWENiZExINmlrc2lJYmdaZ05iTkttNllyakNYVGNBU2VpOElSNlh3VmtwQ2RIdFByUGhHSjZRQ050a0dYU1JqRzBoWWdJRktIeWlhYWpjTTQ4U3k1T0tJai8wN2gwYURXV1lDaUxvZVdhNGNTbWNGU1BMUDdLN2p6cG9vZnRzd05BYXd4eWZhV3VaVkJBSmZSUjBSUCtpZFRBUXlPakx3RjlVT0RYaGRpNFF0b1VwOHFWYVNWdWs4WVJYRDUycW9sWGJxakFtQ2dMWVltaEQySE9KcGpjRDUxamZoWFB4QVBtdzc3bkJFTzV6NTNlMFM3NmFpMXAveGNJYXBFeWRBNS9DdzAyMk5KbitYSE5XcTBpYmFJaUMrbTZGKzF6U3BvRFJPWUNDNEJhMGJsSXdyYmNGS1NUY1VPeXg5QnQ5NUd4UGxFSEFndVhKNTZKR3o1WWx4eHJYN3R2SGc0N1RVNWF2MlZYTmFEeXAzT0VoQXc4U3M3bzg1bGRpaHRKTzBld21EOVNpbDFlK1QyZC9UNHRHZWQ4a1F4Z2dEZ3RLWDUzYjBWN05pWFBPa3Jqd1N2WGtiZGxkTUUwbG5kWHhFSzE2ZWJ2b2VHZnRtaklSMm9WUy9xZ1NMYWV6YTk5NGY4L21Fck5PNi9wRE5qYkNvZ1FNdGZOQkJzSEkxdVFaTDFod2UvQ3hsZjNDbkxWdjhmNEQyVWVuazJheEpsMXo1OTZIcUF2Nkp6NUt1NzlGWmtGYlF1M1RSWUltcjVKc2JLbHBDeTl4NGNMMkp6QlNmeTlaY2NtT1krbkNYTk5xNGlwSHk4MFZDNlpvcTEwTkJlVWI2SS9hcy90R1JuUVBuT0hDUGltZjFiNFZlRzZWQ0hkMGlYYmJ1aEliN2pURlZINC9GRnBHNjNXUFNrWFN1RmgxNGJueFpyck1WK1dMdEFwSGJQM0FJTmZuS2NmOHVDSXA5M3plQlZ0Rk1VeFBJOWYzUEQrU1hnVm5xRnp6MGIycjh3d2VwODdvYXhwT0x3VzIzc3dCRkxtNklDdFI4bDBLTnp6OGdaNTE3bVBMSUd2bnp2MnpLOVhabjZPK3Znak1FTHVyTnBKc09kTjJ4YVZmZHZaRkVJTUpzemVaZHNtd0U2QThyQm54Y2ZxeFJLdTdUL1FzamVNbGIvL1luaVZwaXJmVFVNWVZya0FsM0I5cURrQ1JMbkJBaFRUZHRlZldEdTU0K0lQekY0Zlh3b2x1Z2lla2RXU3pOeEd0dURpU3VDcVlJY2hySmhHQnRoa2dYQUkzS0NPajh4alVQT2NOcnBSbGcvcElBdXFmVDFmQWJ2ajA4Ny9SR0d2Y25LU3dnbWQ2YUFkUUUxak8velJMRTRDbHovUk1Qejd5VXYyS3dYV0xoc056RUE0alR6MlgvRFY5My9VQWJzeEpsV3NqRU55ZGFXSHpPcXl4NEIwTWxHV0l5dmsxYmIwYy9qdDV2RWRtejhEdndHa2dOMzM2MlRlU0dmL2JScUw3M1d6RVRPcnplSCtZWlhCcG9XWi81STlwU3JwS3hkZm1yNysvWjJXcjd6NHNVQ3kvZks3eEZ6SGluN3NLV1FBLzEwa1hNekpjS2d0TDVjN3N5K2lQekRJMFZLUW9sT0dnMlpZMzd5RnZ1WjBvenFPelpwM1kyZWFIay9kOTRkbmZUbE4xVlpycTZ3bVljK3djSjF0Z3lkdXR6aWxwREhlTHNvbUJadTBxZ1lpNCt1SDN2L3p1aWU1alVrQ3hQSDFBWDRSSnRvRUFtYTlNZ0N0REhJYUtFemo4QlBHSXIwOHg4WmJTYnJJYXFOQjBTcWJlMDNvL1FNS2NhQzhkdVQySGRBZWs4WTVaczNBdm5FRDUyQ012TFRqUUdIMURrc2F2YnlUWjFZMDB0K0NreFFRQW52TEpaY3QrZU4yV2NFK3FMMjJDQUVQaVVLUEdGVi8vWU0rMlE1MDNhYUJZT0NaSzIvS2JxTVBOaE9UUTVQblpHV0N6d1VxaG5XWmovSkpvbnB0UTdjclJaTnZGWTdZSUY3VWJOQWFiYTN5UktPWFBBTFAvcEV6aXovTzhNVktwVkg3T2s4N2dHR1RMZDNUWFM2cHhmajF2dkRxcHc2dnJhZmFLSk1VMzFKTzhtK2ZuOGl5TXVpM3pLb3I5VFpteWZZVkJra014RUNpbXJKVnBPNVEvb3MwTkIxK3NyMnYyUjYza2lJQnk4c3Q5ZW41SFc4NlpoMWRhaytkTm5kYzBQemxBZ1ZCNUtFd20rTHBCSHEreEp0UE1FTUhBZlBwSFZMc1JaZklIblpvcjJ6UjBaRm5lb0tkaGI1S0FUbk05UXAzWlNET0l4OFp5SGxVRmFnT2VpOHR6bU1oc1pVbXVNMXJQcHc3dm9jNmZXVS8wREROTkpzbXpzUVJ5WDhTZkdiT203TXgzTXdQZXpObmx1anc3SXdPUXo5TzZSWDFlQytaWEVqcy9sZy9ZQmxHODl1dTN6anVrRnBVdURjY2dlNS9YMTZnb2V3K1p3dk5NR2drTHNFQTBSRUg0SG9seGdObjV2TXBuTjNnMmVrZWF3OHc4eXpxVEhMdHlCa2RqQjNWTXB3a2dTNEdIWVVrRWloM1k1SFdXYVFOU3ltdENqRHJZYkpNR1FFSUhKS1pObTRVNjNiVHhtam8vWmNBSUpBSk9hd0tJd1FOYWc5R3NWR2JHcDBYdGVFdGdEZ0VXM2VJZzdWMTdPRFBYU280SktDZjdEcVJYMDUxZlRadUxNVEJuV3JraEVPVnJMendCSVQ5SFd0RlJUN0ZLblRhVE9yTXIwM29XL1pEWVpsQmsyaStEbzF5dEowaXRoLzNNUkQvUFJXdFlnM0lMQ3E4VEJpdTFBQm1nR0tCVWU1QVNCa2MrTndRMDBoaCtVd3M0Z0xpOXpxQTF0QjV6b0dVYXZiSTdVQTZsU1hhV3hyYWpCY2hmQnFaUWhrZjBKVm1lWGtWM2ZpV1dRTXFGc3Fwb3BKSE5wU0J4Tm5WQ2xiU2h3K1FNSFRBQ2dQbUkydGE0eXo1ekROcVVsa3Rna2lrMFFCbHd0UDJjaWdheGRqbFFuR1paZ0xSZk15Z0dIRHJQckFVOEJvclhERTZqWVQrYjdjUStFS0dFT2J2UVo1RU0wNk01U0tqZWZTd0FPWmxTb0p6c0d4bnBpYUI5Y1FUNEZ1cTB5MGRUT0dlc29Ra2dQY2Qxc25KankvTEhZR00wUndDVG1YaEs3Snh0aDBLYnhBYzVjNWVMRmpGWTF0d3hNSGtUU0xhdElkcmxOY3FBQXg0b1lub3dKc0R4Mm10WXFnLzcyK20ydDlKTmYrM0ZnNk9iSjBNU0ppc3hIQWY1MEpjYm8yMlZ4b1dSMHErWjNZR1h2dUxjR0M2WUc4RjVjL2pyWE40Q3dOa3pwMFdvQy8vakI5UUVKUGRJR2YwU3I4ZmdhUEZQbVFtcHJSbk14UXh5UGI3Uk9tMC9aMjZkV1VBejhXOE1acGFCOTIwR2FOSElORmdta290NjJ1Q1NSZTM2a29YdE9IZTJ3bGhGd3hDTlZidlh3WlFCTmFVYXRYcmp2bjRWNFNyU2duN1NtQ29CeFFPU1FHMDZwc2F1ZG9UdUxnVUx1bU9ZTnp1Q21lM1lCRXlvTmFKWmprQkFNZGZWQWVFNjMzUjBTQ0NNZjdMckpGelRDWWtsRGw2aldHdnFRaWpxL2pPYnVkeG8wWmpzNS9PY3pLWGY4TXFYVitEaStXMjZqOERoMzJIbktBTzYrNVJTdWswcVY1dTd1bkFRamxHbUJLaS9KSURvUW1zaUJmMXNxamlHaXBVZERvbm9EN1diTllISDQxa1ljVHY5bWRXaGRQY01oZnpENTh4UVFLa2txTVNPVUJVQXV1Ri82d1pBdEtId1NZVm1PTWFIQlduSUxLbG9CT2FQVFpzaEVBbklta21DOVZkMTU2TU1TQ2FZTnc4VlBWeDZ3ZHlZdEtjQzUzWXBHMUc0R2k3SFJPMjlDbUJnK3NFU1hCeU1ZOXpVV2NITmNKUnlURURkOU9sOS9YU0ZOYVF0L1V3ZTJ1aFg4YjE1Z0NLd0dvWFdKMFdrWXFSY1pCcHNHNEZsZ0ZNV1NONDJnTkVQb3FkVVFWY24walovQnVpb0tHdnljbDBBcFNFQXlwRUdaNzdRYWxCQUlxeFBFai9FYlVtaFRaVVlvYXVENzFsQjkweUUyUjBLZWdpY0tqMUl5bWs1eWh2UjdFT0RRb1FNR0F5S1RPNHJ3REphWmpZZG1EWHFqN1dWb3dEc3FJQjY5NzBFVUVRYWhEUXdLQm9qSFcrMUNVV2JJaDRpb2YzSW94ekJjVjdMTE9PTCtUaGxKaXVZNCtMSVZ1RWE3ZU5ZVExSekJvRVZFL2gwUExTMzRURHRHNmFPclZHLzFBeHdZTFNxM3NqTWJEOGJONlZRWVg5R3AxU0ppVlhiWStTWkViMzBoRmZiMnhSVTZIcGl1Z3F6RzVoYXRQZHJ3ZkJFU0VDRFFHdEMwRXhJWVFKMWwvQ3pRSXFtMFovdGVWb2Y2T3pzckUyMno0OElxQlViZDFXeFBuTXQzZWNxa3lLaU80M1JkRHA2czZZQ3NKVHBJSEJyQXlTdFk2TnRabERTbWtGbGYzeFVnR2pBTVZvRytnVVZLYWE1dFVvRnR1c0VkalRha3RyQTR1NWpjdFNQNzlMVk5oanBqYU9PaFJoeGtXUk9DL2JSUFN4RTBYZ3pDVUtwc0lLWXdjRXc2RllxOUszMndWT0JHUVNuWmNwTW9oQk50T0VHZ2JtQnJyZU9HcVl1aFhUOVArM3BqMksxa1F6QlF0WVFKZ2dSYTBDRTFyd1Y1c3Z1YytCWXJTZzB4d0pqUUZCZTA4eGlQdE1tYVlyYVF2SHdZUHVNcnNHM1hZSlB3Z21Vbis0WjdZMGc2bTlUYWdsUlNpSkYyR3M3M0dxMWtsZlJsTUZ5d0ZpTmlnSXRNL3NSZk5DdUF0REZCOWRvZTREV2h4dzFtQlJRNy96NDN0VjBFK3VOZG9oZjhhWXNOSFhpbDZ6WndrSlR4TXladGdnQ1RiSWcwWk0xUkxzM3Q3WGhsaHZlMUxVTlRpRjVhaWhaZ2dtdW9COUkvamp2dGNBb1cvdG96Um5JWUlEeHdXSWlqUnE1VElvOVRpYW9nMmllY3ZPai9GZXhacTJkNkQ0T0M5UTc3dDZ6aVc3Z3hoSW9vaG5XdkZsVFpiVEVhNVk5VmdBMSsySmxUWjAzaDFiYkJpTVZyWDNQNzUxYTRFd2tUdytseXlJYWtxQmVXeDZZd2lMRmhVNWpyRDlTSmMwcG04UFFaMEVSVmRJd0V0N1M2cnNuQkdyNStsM2tlR2RzSlFYcE0zR1EvV0l0WnF2d093RkpjTWRGMXNaN1JoY3JieHFGQWVLbUNrWWJidnFEV1R2Z05KUTlRNXJNWTc2R3NtTXJsQVZKT3hib1FERTFKWkNqTTVYS00wQnZDa3YxRkNDeFBDM2NKMHViL1ZaTG9CaWtOdXpjU2gzY1Z4QUNGRHF0eFd4Ulh0eWFNZkRnQ0Nqb0FBMFpYbVRUKzdIU2EyKytzdnUwMEtERENRUFdGdW4xOVB1V2xTZzZXQzBUYlFzQ1lTallaUkhBTzVDY3RBU3I1VkJ5REIwYnFJUDc3T1FOKzJYMi9hODJKakNWUmJKUDJXOFhadVRHa3lCY0dLQmhJbEMzM0hwMWRlbVpBaEpMVHpmV3pwMnRCckljMzBXZFVmT1pkR3pLWVlLZkZ3M1M3UDZHbWhRS1Q5VXB2Y052bkViOTRmbzlhd21JMjczek56R01Ma3djZ1dUMmdUQy9JTk5nWXljYjFFWkMzeW01U2s4SER0dzIwRjJETTFpR1NMdFVSVytsbjkzYlRCWUNLbTgxVG1FclU5WktzMjVGbVJOUU9wNnJQV1BBWFk0UUdET214TnhSWThRTUpnREhVblJBYXhLUkZjMVNkR1dEWE5LMkxXTUFLOWNOZEU5WmN2SlVGZ0tyR3JmcmpkUlZ5eXlaS0FMbGd0WVh3em1UbE1WTTNVdlpjMUtlclphWmFERmpKc0Mya2JZZmZnQ1RKN0kyMk5obEd3UXFTN3U1YnRyWVpvMWJicnUyZXdDbWtYUjNHNTh5OE5KWVR2MElTMXdzNWJpZGRRTjI1QW9La3hjU0NvRHhWbzVONEZMdm82NjlhODhLVHEwZ1NvMFpRR244UjhEUlNtaTJxTEI3ZDZ4RTdDZ0ZPYnBXUHpDOEVxYXAxTnR4Z0RyaFNjZTlmUm5rb2VvcHZEc3J5aEtrZlFuWDhIdWdxTk52QkVjUUpEUW9wVU5FdS93VjBmZ2Y4L3BmVHlLa1BXM1VsNjVidVdoYW1MdFcwczFzTGNlVmJoaE40aXJIQUZuS3ZHSThtVUFvYTlZYUE1UjVnWitHZnN2b1VJZnhnTHVPMHk3eFBjR1hLOGthdTFjYzRLWjFmMXk4dVhHNlNtY25EY05UdklpcWVQLzdCTFYvelNTaWxTbnNkKytaNkhjZExkcGs1c3RialVLYmVHUmcvRFFjTGNlaFQ0Zlk1Q1dTTm8ydGc3TmloQ0RhREFYcGN3OStLKzA1VkxzUkN4Ukd2K25zbXRNaVYzQUNkaHFvSVE1aUQyMTVsMzh2aFpucmhuYVdvcTZkMWFaQ0tIYzV5R05RNEVzWlcxSndKNGNrZ3ZMU2xyeFBJYUlySmxGWTJGYldIRURVUmQ3S1RNUkdkNHhpd2lkeEFkSHlVNnB1L0ZRUTZyTkJHWVZ5VGMzZzZLYjJsbXY3RWxwVVBnWHZTN09DREVOVXFLNzJ5VVdKRDBMdG9qOURjRmJHU1RnWk1KQm1PaDZ1ZGZObk1YMTVDWVJTVHNvdHlsRjJsNFJFbHlLUjNVUTBEazAvcDZVMDVlaWFTVU9yMHFabTgxaGN4d3hlZ1JuWTEyNjQyWUNsbmRMcWdMS0RyeGZBSXQ1eVd0VUxaNlZaZW1GaWdGcjVxK1kyU1R5QTBaN3REb3dpeXl2TVR5R1VLbGlEVW1NSG5KSTRpMWI5YXg0YXFzSlpNVUtCYWk4UjVYNzVHQWF6clN6UFJCcG1qaFY2bnUxUVB0M2d5ck13MUJoUE1GeEZrZGNpZ0ZLOVFMV2lWc0ZaTVpKbE51d0p4TEVLUGNFcE9ORm52M0hESjU0ZG92R2xPWEZSdnVYSG9XSnI5MHd5Tm5ieFZXUUdCdm00b3JERlp0dUhJZEdMYnBrbWlkaUpoQ3VlYVBVNHdEaDMwSXFpNDJIMjdmSytqZ0RaWUtsNFFTaUVLUWc5bElseTZGOEdncDU0Z0RPQjVqcHoyanFqTlRETkpjOWhyUzZERlBxZ2lTajZSR1RzN29LVWRNUjM4NGlpQ3N4Y2FOWUVGSzM4Y0NWSWN0YldzNG0xdE5aUTY5WDNQUHJDYXBpbWttVjZMWFVNdjFsc0lrQ2FwUlZBWHB0bytab0hhdFBLN21IcTRYVnVwTVFGdmo2NGRkdkMvbHc2cEtoZGd5S0JhK3Z5MW4vbVd3ZHVoR2ttYWFwWFVCZmNEa2NuWVpEcndHTUZxcFZvL21mZSs3SU5IRW03d0RjYzRQSWE0d05lQjFpUjc1UE1oVHVNLzJ6ODdMZGZXQXZUUkJMU0pNcW5iZFRnSCtSVzVHQ2k0ZmZtNDFoNGZORE1sQjlmTXhHbEs1VXBDdlFBK01Sc2tFYVMvNEpJM3UySHJyaFF4cXRrR040VUl5S3UrZHpnZ1kxZjNEcmFDMmVvTUhGSVV2MFFiYXdSWmp3UkNNMFpoMllKQWF6UjhpNjNZeHhRbjF6WlU4c2dINkRPSHZJK1NvR2ZEMW40TGF0am9RK1R4Q09DTHpSRWF5c1JWa0NjYlgzZ3V5K2VjYVp3dEtGWHBCbjhnbjd6Y2xkb0thODFhQjRBWk1FV2JkRGlHR2JNUzlua2hZMHRaZlhHWi92aXRtZ3JhY2FjVWxseXFVNDhxQlV2NnZuQ3FUYW1UTmtVL1JkbFowOHFuYThjZUYzWElKekdNcHJvZnZvNXBFRzZYL3gzU0xwWUpncHNKOXJuMmpoZmVrVnppZk9FUUxGODRQNW4rNmpySDRvVjlyb2l5MWhtYkFoUTZHcktwZm9WdVdUWjFQelpzb3F3K0ZKSGZzNlVPWFl3d21qVGxaZDJib2JUU0E2TzZuNktOZGRRZnEzZnNsM3QvYlJmaXNNbkd0Wm85bFh1bUJvdExldlFEd2tVeTE5dDNOTWJkMWEyUmdKV0pEVVRYck44c2IrYnNhSE0wK1cxTGF3MWQvT2hNQVFPZWM3UW9JcXp1NWUrWnRZcE9VekM0RkJrMUU4L2N4VXFYVlhCcUhZcGdRMUYzQ25TREVRb3pZRXVGMTBPaE9ZT21pNDBLVm56bGYzcnFVTlh0NXJuSkJXeVdnZ0d4cTdHcnluRDRTcG56ZkhCdEJ1am9VbzcwTFprcUwvMnhsZDFEc0pKa2lIT0tyeVk5cWxJTFNNOGxwUGk5SllxWEdYOFRXcjN3QkVuSlpWYlIvQlZ2dVljRGpQOTVrZ3VDaDk2OERtS0VkUWEwZ3pSTGxXWVBLZHRnWG1ML0FRQ2hPYmpRclBwSnJFcFBobmRlSmdoTVlNUnFPMDBncnd0d3FTMitKWEhSK1AyREkzMkttampHdnNsOUtEMFVmL1JRQ3FZNUxLU2RJMnJ4MU5OSnM0T211cVFZRGxwWmRxYTk5Vm9vVDdGYlhBWU9TS2dXTzU0YUtpWHlNRXEwb0RWem9TVmdQTEVJd1FMQy85VytLaHhNdy9Eb05tRUFBcExMSk11eis5dXFKRTVyZEdIV2dRNHJQUDBTUjFETFpZSi9oMXBXb09PNElhenFFcFBTUlZVWGlVUXFrU1E1bEI2cDVlZXNWNjZWaTlyQzdlNzhUamxuaEhKbVlXRk80N0p1c2xycGNKSzk2ZDE3cTY1allYam8wTnEwVEVCNWVTT2J3NzFkb0phUTkyendsWFdOb0hteko3WE1xTTlFTzRIbVJWaXpXSHoxRXIza0xwT0tGZWNRcXRKWVVGYkdQZUJuOElwd3pLbVNrZUYxL1lUbzhFL0lBNlF5TTNJQ08vSitTY0Fad29uQXFXNWp3ZHBXVG1STDVwSWpob29KK3NKc0k0b1drUGs0a1lWekgreTgzQjFNRVVub1BHUk40WGVWNFdPV2JrcEVRQ3VIc01jQTJIbmhKMFZhQ05BMkJhYUsvU0JPalNkSjlzR0JQL0FXQkR0dkYwM2xSUEM3eXpPZzNGV3owc0kxQ0F0YXlkajVsckpNUVBsWkNNQmxsY2lmb1hCQ2c5U0UrRm9vdXZGVk5KQW0xb3hxZkV6enMyRGk0VnAxQUZZR002NU5mRW5lZzMwSTlnb1kycE5uVzkzUmtVNkRGM3VzdENrd3V3Rm10dkt0TEc4UU1zbVdyWWNMVUJPcGd3b0p4dTNEdlZHVWRSZlViaUtwKzU0UDFiTU9nUWZUd2xkTDU1TVovWUtCeDFxd3ppVDVzR3g5WVlPMEdMeVdKTnBWR2pmWm9hQlNiWGE3aldvbFdhR1d1VTBNdEJHVnlnU0FzV2diS0ZsODJSOTBPRmt5b0VLNVl2ZkhlcXRZTnNxQW1NNWdkUHJ5UU9XWnlCRzRWell3dlFGc3lGTThTQ08xekk3Q3hJdzlGbm84NC9RWktMY2xCZTM3ZmE3cXF1UXZMaVhaRWtScW53LytPUjBKR2lxb2dkMzBiSVorRlZ2eDZnOXJlUzRBaFhLTng4ZjZrVm9YMGJLUktCeFZHOVpJUHJvSHNaVlBnVyt4ekl3OURsRTc5ZU05cGpYRElDZmF1bmVBMUYwZWtFWUVFSi9LTUM2YmFOVHdmVE53TS94ODJBbVUydC9yOE8wYnp0OVlNMWgwL1lrSEVjNVlVQTF5Mk5QSkV0UXAvMzBBMm5oQWxCVjllOFJHdWMvc0t3WmdmOG9BYUljWVdnQnVOVVlZei9SMVNRR1BnYmRvTGFiYTFzNjEvaFlUbEx2b0Nka3NLSU1NZGd4VldadE1uTFNnR3FXLy9pL0Yvc3EyTEdRQWgrZWtzb3Y1MWhJSGRoWHBHb0taaGZRYThmVXhDZmh1RW5QaFdZVzQydk41Q1VrSXZZL1RRVWFxTVB0R0hPc0J0czcyb3c1TzY0YWN6ZzVaWUNhU0I3ZjlXSmZGTGZQMGJubTJaQzlaSHVxUFAyU2JyMXFVamRJd1NzYXlzNUJhOVZwbnpPSkF0WXdaVDJHeGFRTmNlQk1jRHhKOEF6SFhJeWpWUTNhb05iUkFiWE9rd3pJUlBMLzY5aXZ0ZjQ4SFlzQUFBQUFTVVZPUks1Q1lJST1cIixcbiAgICBvYmplY3RUeXBlOiBcImltYWdlL3BuZ1wiLFxuICAgIG9iamVjdFVsaWQ6IFwiMDFKVEtZS1hKWDVDMFo3SjBRWDlKVkRCNllcIixcbiAgICBzaGFyZFR4SWRzOiBbXG4gICAgICBcIjM5MWViZDkwMmViMmQ5NTJkNDJjNzY0MjI3M2YwOGZiODlhYzdhNzg5ZGRmM2U3ZmUwZDUyNzc5YTYxNzg4MzVcIixcbiAgICBdLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiNFwiLFxuICAgIG5hbWU6IFwiU2ltcGxlIFRleHQgTm90ZVwiLFxuICAgIGRhdGVVcGxvYWRlZDogXCIyMDI1LTA1LTA3VDEwOjMwOjAwWlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgYmFzaWMgdGV4dCBub3RlXCIsXG4gICAgZmlsZVR5cGU6IFwidGV4dFwiLFxuICAgIGluZGV4aW5nVHhJZDpcbiAgICAgIFwiNGMzODg1NTA3NTk3ODRlZjQwOGNmYzE5MjQ1MzIyN2Y5OWQzNDNiZGJjZDJmM2MxZjQyOWNmODE1ZmQxMTEyNVwiLFxuICAgIGluZGV4aW5nVHhTdWJtaXR0ZWRBdDogdW5kZWZpbmVkLFxuICAgIG9iamVjdERhdGE6IFwiU0dWc2JHOGdkR2hsY21VPVwiLFxuICAgIG9iamVjdFR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgIG9iamVjdFVsaWQ6IFwiMDFKVFJGNDVOSEZHTU1EQjBGMFdIQ01DUjRcIixcbiAgICBzaGFyZFR4SWRzOiBbXG4gICAgICBcImFjNWRiNGQ5MmFlNTFlZGQ0NTgwMDhmYWUzMDA1NzBmMTAyYTY4NDZmNjk3ZmUxODFkOTZiNjJhMTk3MzZiNDFcIixcbiAgICBdLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiNVwiLFxuICAgIG5hbWU6IFwiR3JlZXRpbmcgTm90ZVwiLFxuICAgIGRhdGVVcGxvYWRlZDogXCIyMDI1LTA1LTA3VDE0OjIyOjAwWlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkEgc2ltcGxlIGdyZWV0aW5nIG1lc3NhZ2VcIixcbiAgICBmaWxlVHlwZTogXCJ0ZXh0XCIsXG4gICAgaW5kZXhpbmdUeElkOiB1bmRlZmluZWQsXG4gICAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0OiB1bmRlZmluZWQsXG4gICAgb2JqZWN0RGF0YTogXCJTR1ZzYkc4Z2RHaGxjbVVoSVNFPVwiLFxuICAgIG9iamVjdFR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgIG9iamVjdFVsaWQ6IFwiMDFKVFJGOUg0UlFKOTFITVNKNkU0VFYyS1FcIixcbiAgICBzaGFyZFR4SWRzOiBbXSxcbiAgfSxcbiAge1xuICAgIGlkOiBcIjZcIixcbiAgICBuYW1lOiBcIkltcG9ydGFudCBOb3RlXCIsXG4gICAgZGF0ZVVwbG9hZGVkOiBcIjIwMjUtMDUtMDhUMTc6NDA6MDBaXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQW4gaW1wb3J0YW50IHRleHQgbm90ZSB3aXRoIGFscGhhYmV0XCIsXG4gICAgZmlsZVR5cGU6IFwidGV4dFwiLFxuICAgIGluZGV4aW5nVHhJZDpcbiAgICAgIFwiMjM5YTE5NmQxYjRkYzEwNDhjMmVjMDIyYzcxNDc3YjY1MWJhM2FiMmVlYTVjZjI3M2Y3MjMwNGQyNTdmMGRiZFwiLFxuICAgIGluZGV4aW5nVHhTdWJtaXR0ZWRBdDogXCIyMDI1LTA1LTA4VDE3OjQ5OjMyWlwiLFxuICAgIG9iamVjdERhdGE6IFwiU0dWc2JHOGdkR2hsY21VaElFRkNRMFJGUmtkSVNVcExURTFPVHc9PVwiLFxuICAgIG9iamVjdFR5cGU6IFwidGV4dC9wbGFpblwiLFxuICAgIG9iamVjdFVsaWQ6IFwiMDFKVFJGQlRRWlhYQUJURDZLQlRWVzc1QkpcIixcbiAgICBzaGFyZFR4SWRzOiBbXG4gICAgICBcIjQ0OTE0NzhmYzg3MTQyMTNkM2Q4ZWNkM2U2NDM4ZjQ5YzJhOWNjNWQ1YjVmOGFlMzU4ODM0ZjQzOTgwZjcxMjdcIixcbiAgICBdLFxuICB9LFxuXTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gR3JhZGllbnRUZXh0KHsgdGV4dCB9OiB7IHRleHQ6IHN0cmluZyB9KSB7XG4gIHJldHVybiAoXG4gICAgPHNwYW4gY2xhc3NOYW1lPVwidGV4dC10cmFuc3BhcmVudCBiZy1jbGlwLXRleHQgYmctZ3JhZGllbnQtdG8tciBmcm9tLVt2YXIoLS1jb2xvci1saWdodCldIHRvLXdoaXRlXCI+XG4gICAgICB7dGV4dH1cbiAgICA8L3NwYW4+XG4gICk7XG59XG4iLCIvKipcbiAqIFVwbG9hZHMgY29tcG9uZW50XG4gKiBUaGlzIGNvbXBvbmVudCBmZXRjaGVzIGFjY291bnQgdXBsb2FkcyBkYXRhIGZyb20gdGhlIEFQSSBhbmQgZGlzcGxheXMgdGhlbSBpbiBhIGdyaWRcbiAqIHdpdGggZmlsdGVyaW5nIGFuZCBwYWdpbmF0aW9uIG9wdGlvbnNcbiAqL1xuXG5pbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlUmV3YXJkQWNjb3VudHMgfSBmcm9tIFwiLi91c2VSZXdhcmRBY2NvdW50c1wiO1xuaW1wb3J0IHsgdXNlVXBsb2FkcywgVXBsb2FkIH0gZnJvbSBcIi4vdXNlVXBsb2Fkc1wiO1xuaW1wb3J0IFVwbG9hZHNHcmlkIGZyb20gXCIuL1VwbG9hZHNHcmlkXCI7XG5pbXBvcnQgVXBsb2Fkc0xpc3QgZnJvbSBcIi4vVXBsb2Fkc0xpc3RcIjtcbmltcG9ydCBVcGxvYWRzRmlsdGVycyBmcm9tIFwiLi9VcGxvYWRzRmlsdGVyc1wiO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvV2FsbGV0Q29udGV4dFwiO1xuaW1wb3J0IHsgRXhwbG9yZXJMaW5rIH0gZnJvbSBcIi4uL3VpL0ZpbmlzaFNjcmVlblwiO1xuaW1wb3J0IHsgbW9ja1VwbG9hZHMgfSBmcm9tIFwiLi9tb2NrRGF0YVwiO1xuaW1wb3J0IEdyYWRpZW50VGV4dCBmcm9tIFwiLi9HcmFkaWVudFRleHRcIjtcblxuaW50ZXJmYWNlIFVwbG9hZHNQcm9wcyB7XG4gIGxpbWl0PzogbnVtYmVyO1xufVxuXG50eXBlIFZpZXdNb2RlID0gXCJncmlkXCIgfCBcImxpc3RcIjtcblxuY29uc3QgZGF0ZUZpbHRlck9wdGlvbnMgPSBbXG4gIHsgaWQ6IFwic2VsZWN0XCIsIGxhYmVsOiBcIlNlbGVjdFwiIH0sXG4gIHsgaWQ6IFwidG9kYXlcIiwgbGFiZWw6IFwiVG9kYXlcIiB9LFxuICB7IGlkOiBcIndlZWtcIiwgbGFiZWw6IFwiVGhpcyBXZWVrXCIgfSxcbiAgeyBpZDogXCJtb250aFwiLCBsYWJlbDogXCJUaGlzIE1vbnRoXCIgfSxcbiAgeyBpZDogXCJ5ZWFyXCIsIGxhYmVsOiBcIlRoaXMgWWVhclwiIH0sXG5dO1xuXG5jb25zdCB0eXBlRmlsdGVyT3B0aW9ucyA9IFtcbiAgeyBpZDogXCJhbGxcIiwgbGFiZWw6IFwiQWxsXCIgfSxcbiAgeyBpZDogXCJwZGZcIiwgbGFiZWw6IFwiUERGXCIgfSxcbiAgeyBpZDogXCJ0ZXh0XCIsIGxhYmVsOiBcIlRleHRcIiB9LFxuICB7IGlkOiBcInBuZ1wiLCBsYWJlbDogXCJQTkdcIiB9LFxuICB7IGlkOiBcImpwZWdcIiwgbGFiZWw6IFwiSlBFRy9KUEdcIiB9LFxuXTtcblxuY29uc3QgVXBsb2FkczogUmVhY3QuRkM8VXBsb2Fkc1Byb3BzPiA9ICh7IGxpbWl0ID0gOSB9KSA9PiB7XG4gIGNvbnN0IFtkYXRlRmlsdGVyLCBzZXREYXRlRmlsdGVyXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJzZWxlY3RcIik7XG4gIGNvbnN0IFt0eXBlRmlsdGVyLCBzZXRUeXBlRmlsdGVyXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJhbGxcIik7XG4gIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgY29uc3QgW3ZpZXdNb2RlLCBzZXRWaWV3TW9kZV0gPSB1c2VTdGF0ZTxWaWV3TW9kZT4oXCJncmlkXCIpO1xuXG4gIGNvbnN0IHsgZGVmYXVsdFdhbGxldCB9ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHJld2FyZEFjY291bnRzID0gdXNlUmV3YXJkQWNjb3VudHMoKTtcbiAgY29uc3Qge1xuICAgIGFsbFVwbG9hZHMsXG4gICAgZmlsdGVyZWRVcGxvYWRzLFxuICAgIGRpc3BsYXllZFVwbG9hZHMsXG4gICAgc2V0RmlsdGVyZWRVcGxvYWRzLFxuICAgIHNldERpc3BsYXllZFVwbG9hZHMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBwYWdlc0RhdGEsXG4gICAgbGFzdE9iamVjdFVsaWRzLFxuICAgIGN1cnJlbnRQYWdlLFxuICAgIHNldEN1cnJlbnRQYWdlLFxuICAgIGhhc01vcmVQYWdlcyxcbiAgICBzZXRBbGxVcGxvYWRzLFxuICAgIHNldFBhZ2VzRGF0YSxcbiAgICBzZXRMYXN0T2JqZWN0VWxpZHMsXG4gICAgc2V0SGFzTW9yZVBhZ2VzLFxuICAgIGZldGNoTmV4dFBhZ2UsXG4gIH0gPSB1c2VVcGxvYWRzKHsgbGltaXQsIHJld2FyZEFjY291bnRzIH0pO1xuXG4gIC8vIEZpbHRlcmluZyBsb2dpY1xuICAvLyBVc2UgbW9ja0RhdGEgY3VhbmRvIG5vIGhheSBkYXRvcyByZWFsZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWxsVXBsb2Fkcy5sZW5ndGggPT09IDAgJiYgIWxvYWRpbmcpIHtcbiAgICAgIHNldEFsbFVwbG9hZHMobW9ja1VwbG9hZHMpO1xuICAgIH1cbiAgfSwgW2FsbFVwbG9hZHMubGVuZ3RoLCBsb2FkaW5nLCBzZXRBbGxVcGxvYWRzXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZmlsdGVyZWQgPSBbLi4uYWxsVXBsb2Fkc107XG4gICAgLy8gRGF0ZSBmaWx0ZXJcbiAgICBpZiAoZGF0ZUZpbHRlciAhPT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpKTtcbiAgICAgIGNvbnN0IHRoaXNXZWVrID0gbmV3IERhdGUodG9kYXkpO1xuICAgICAgdGhpc1dlZWsuc2V0RGF0ZSh0b2RheS5nZXREYXRlKCkgLSA3KTtcbiAgICAgIGNvbnN0IHRoaXNNb250aCA9IG5ldyBEYXRlKHRvZGF5KTtcbiAgICAgIHRoaXNNb250aC5zZXRNb250aCh0b2RheS5nZXRNb250aCgpIC0gMSk7XG4gICAgICBjb25zdCB0aGlzWWVhciA9IG5ldyBEYXRlKHRvZGF5KTtcbiAgICAgIHRoaXNZZWFyLnNldEZ1bGxZZWFyKHRvZGF5LmdldEZ1bGxZZWFyKCkgLSAxKTtcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKCh1cGxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdXBsb2FkRGF0ZSA9IG5ldyBEYXRlKHVwbG9hZC5kYXRlVXBsb2FkZWQpO1xuICAgICAgICBzd2l0Y2ggKGRhdGVGaWx0ZXIpIHtcbiAgICAgICAgICBjYXNlIFwidG9kYXlcIjpcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWREYXRlID49IHRvZGF5O1xuICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkRGF0ZSA+PSB0aGlzV2VlaztcbiAgICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWREYXRlID49IHRoaXNNb250aDtcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZERhdGUgPj0gdGhpc1llYXI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gVHlwZSBmaWx0ZXJcbiAgICBpZiAodHlwZUZpbHRlciAhPT0gXCJhbGxcIikge1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHVwbG9hZCkgPT4ge1xuICAgICAgICBpZiAoIXVwbG9hZC5maWxlVHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBsb3dlckZpbGVUeXBlID0gdXBsb2FkLmZpbGVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZUZpbHRlcikge1xuICAgICAgICAgIGNhc2UgXCJwZGZcIjpcbiAgICAgICAgICAgIHJldHVybiBsb3dlckZpbGVUeXBlLmluY2x1ZGVzKFwicGRmXCIpO1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICByZXR1cm4gbG93ZXJGaWxlVHlwZS5pbmNsdWRlcyhcInRleHRcIik7XG4gICAgICAgICAgY2FzZSBcInBuZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGxvd2VyRmlsZVR5cGUuaW5jbHVkZXMoXCJwbmdcIik7XG4gICAgICAgICAgY2FzZSBcImpwZWdcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGxvd2VyRmlsZVR5cGUuaW5jbHVkZXMoXCJqcGVnXCIpIHx8IGxvd2VyRmlsZVR5cGUuaW5jbHVkZXMoXCJqcGdcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gU2VhcmNoXG4gICAgaWYgKHNlYXJjaFF1ZXJ5LnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hRdWVyeS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoXG4gICAgICAgICh1cGxvYWQpID0+XG4gICAgICAgICAgKHVwbG9hZC5uYW1lICYmIHVwbG9hZC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpKSB8fFxuICAgICAgICAgICh1cGxvYWQuZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgIHVwbG9hZC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSlcbiAgICAgICk7XG4gICAgfVxuICAgIHNldEZpbHRlcmVkVXBsb2FkcyhmaWx0ZXJlZCk7XG4gICAgc2V0RGlzcGxheWVkVXBsb2FkcyhmaWx0ZXJlZC5zbGljZSgwLCBsaW1pdCkpO1xuICAgIHNldEN1cnJlbnRQYWdlKDEpO1xuICB9LCBbXG4gICAgYWxsVXBsb2FkcyxcbiAgICBkYXRlRmlsdGVyLFxuICAgIHR5cGVGaWx0ZXIsXG4gICAgc2VhcmNoUXVlcnksXG4gICAgbGltaXQsXG4gICAgc2V0RmlsdGVyZWRVcGxvYWRzLFxuICAgIHNldERpc3BsYXllZFVwbG9hZHMsXG4gICAgc2V0Q3VycmVudFBhZ2UsXG4gIF0pO1xuXG4gIGNvbnN0IGhhbmRsZVNlYXJjaCA9IChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNvcHlUZXh0ID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gT3B0aW9uYWw6IHRvYXN0IG5vdGlmaWNhdGlvblxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGxvYWRNb3JlID0gKCkgPT4ge1xuICAgIGlmIChoYXNNb3JlUGFnZXMpIGZldGNoTmV4dFBhZ2UoY3VycmVudFBhZ2UgKyAxKTtcbiAgfTtcbiAgY29uc3QgZ29Ub1ByZXZpb3VzUGFnZSA9ICgpID0+IHtcbiAgICBpZiAoY3VycmVudFBhZ2UgPiAxKSB7XG4gICAgICBzZXREaXNwbGF5ZWRVcGxvYWRzKHBhZ2VzRGF0YVtjdXJyZW50UGFnZSAtIDFdIHx8IFtdKTtcbiAgICAgIHNldEN1cnJlbnRQYWdlKGN1cnJlbnRQYWdlIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnb1RvUGFnZSA9IChwYWdlOiBudW1iZXIpID0+IHtcbiAgICBpZiAocGFnZSA9PT0gY3VycmVudFBhZ2UpIHJldHVybjtcbiAgICBpZiAocGFnZSA8IGN1cnJlbnRQYWdlKSB7XG4gICAgICBzZXREaXNwbGF5ZWRVcGxvYWRzKHBhZ2VzRGF0YVtwYWdlXSB8fCBbXSk7XG4gICAgICBzZXRDdXJyZW50UGFnZShwYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmV0Y2hOZXh0UGFnZShwYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaWYgKCFkZWZhdWx0V2FsbGV0KSB7XG4gIC8vICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidXBsb2Fkcy1lcnJvclwiPlBsZWFzZSBjb25uZWN0IGEgd2FsbGV0PC9kaXY+O1xuICAvLyB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTd4bCBteC1hdXRvIHAtNSB0ZXh0LWJsYWNrIGJnLVt2YXIoLS1jb2xvci1iZy1kYXJrKV0gbWluLWgtc2NyZWVuXCI+XG4gICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC03eGwgZm9udC1ib2xkIHRleHQtY2VudGVyIG15LThcIj5cbiAgICAgICAgPEdyYWRpZW50VGV4dCB0ZXh0PVwiTXkgdXBsb2Fkc1wiIC8+XG4gICAgICA8L2gxPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi04XCI+XG4gICAgICAgIDxVcGxvYWRzRmlsdGVyc1xuICAgICAgICAgIGRhdGVGaWx0ZXI9e2RhdGVGaWx0ZXJ9XG4gICAgICAgICAgc2V0RGF0ZUZpbHRlcj17c2V0RGF0ZUZpbHRlcn1cbiAgICAgICAgICB0eXBlRmlsdGVyPXt0eXBlRmlsdGVyfVxuICAgICAgICAgIHNldFR5cGVGaWx0ZXI9e3NldFR5cGVGaWx0ZXJ9XG4gICAgICAgICAgc2VhcmNoUXVlcnk9e3NlYXJjaFF1ZXJ5fVxuICAgICAgICAgIHNldFNlYXJjaFF1ZXJ5PXtzZXRTZWFyY2hRdWVyeX1cbiAgICAgICAgICBvblNlYXJjaD17aGFuZGxlU2VhcmNofVxuICAgICAgICAgIGRhdGVGaWx0ZXJPcHRpb25zPXtkYXRlRmlsdGVyT3B0aW9uc31cbiAgICAgICAgICB0eXBlRmlsdGVyT3B0aW9ucz17dHlwZUZpbHRlck9wdGlvbnN9XG4gICAgICAgICAgdmlld01vZGU9e3ZpZXdNb2RlfVxuICAgICAgICAgIHNldFZpZXdNb2RlPXtzZXRWaWV3TW9kZX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7bG9hZGluZyA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBweS0xMiB0ZXh0LVt2YXIoLS1jb2xvci10ZXh0LXNlY29uZGFyeSldIHRleHQtbGdcIj5cbiAgICAgICAgICBMb2FkaW5nIHVwbG9hZHMuLi5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogZXJyb3IgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgcHktMTIgdGV4dC1bdmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpXSB0ZXh0LWxnXCI+XG4gICAgICAgICAgRXJyb3IgbG9hZGluZyB1cGxvYWRzLiBVc2luZyBtb2NrIGRhdGEgaW5zdGVhZC5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogZGlzcGxheWVkVXBsb2Fkcy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgcHktMTIgdGV4dC1bdmFyKC0tY29sb3ItdGV4dC1zZWNvbmRhcnkpXSB0ZXh0LWxnXCI+XG4gICAgICAgICAgTm8gdXBsb2FkcyBmb3VuZC5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogdmlld01vZGUgPT09IFwiZ3JpZFwiID8gKFxuICAgICAgICA8VXBsb2Fkc0dyaWQgdXBsb2Fkcz17ZGlzcGxheWVkVXBsb2Fkc30gb25Db3B5VGV4dD17aGFuZGxlQ29weVRleHR9IC8+XG4gICAgICApIDogKFxuICAgICAgICA8VXBsb2Fkc0xpc3QgdXBsb2Fkcz17ZGlzcGxheWVkVXBsb2Fkc30gb25Db3B5VGV4dD17aGFuZGxlQ29weVRleHR9IC8+XG4gICAgICApfVxuXG4gICAgICB7LyogT25seSBzaG93IHBhZ2luYXRpb24gaWYgd2UgaGF2ZSB1cGxvYWRzIHRvIGRpc3BsYXkgKi99XG4gICAgICB7ZGlzcGxheWVkVXBsb2Fkcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBtdC04IGdhcC0yLjVcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtnb1RvUHJldmlvdXNQYWdlfVxuICAgICAgICAgICAgZGlzYWJsZWQ9e2N1cnJlbnRQYWdlID09PSAxIHx8IGxvYWRpbmd9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1bdmFyKC0tY29sb3ItYmctY2FyZCldIGJvcmRlciBib3JkZXItW3ZhcigtLWNvbG9yLWJvcmRlcildIHRleHQtW3ZhcigtLWNvbG9yLXByaW1hcnktdHcpXSBweC00IHB5LTIgcm91bmRlZC1tZCBjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgaG92ZXI6YmctW3ZhcigtLWNvbG9yLWJnLWhvdmVyKV0gZGlzYWJsZWQ6b3BhY2l0eS01MCBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWRcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIFByZXZpb3VzXG4gICAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0xLjVcIj5cbiAgICAgICAgICAgIHtjdXJyZW50UGFnZSA+IDIgJiYgKFxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZ29Ub1BhZ2UoMSl9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1bdmFyKC0tY29sb3ItYmctY2FyZCldIGJvcmRlciBib3JkZXItW3ZhcigtLWNvbG9yLWJvcmRlcildIHRleHQtW3ZhcigtLWNvbG9yLXByaW1hcnktdHcpXSByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2N1cnJlbnRQYWdlID4gMyAmJiAoXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtW3ZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KV1cIj4uLi48L3NwYW4+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2N1cnJlbnRQYWdlID4gMSAmJiAoXG4gICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBnb1RvUGFnZShjdXJyZW50UGFnZSAtIDEpfVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctOCBoLTggZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctW3ZhcigtLWNvbG9yLWJnLWNhcmQpXSBib3JkZXIgYm9yZGVyLVt2YXIoLS1jb2xvci1ib3JkZXIpXSB0ZXh0LVt2YXIoLS1jb2xvci1wcmltYXJ5LXR3KV0gcm91bmRlZC1tZCBjdXJzb3ItcG9pbnRlclwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7Y3VycmVudFBhZ2UgLSAxfVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cInctOCBoLTggZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctW3ZhcigtLWNvbG9yLWJnLWFjdGl2ZSldIGJvcmRlciBib3JkZXItW3ZhcigtLWNvbG9yLWJvcmRlci1hY3RpdmUpXSB0ZXh0LVt2YXIoLS1jb2xvci1wcmltYXJ5LXR3KV0gcm91bmRlZC1tZCBjdXJzb3ItcG9pbnRlclwiPlxuICAgICAgICAgICAgICB7Y3VycmVudFBhZ2V9XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIHtoYXNNb3JlUGFnZXMgJiYgKFxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZ29Ub1BhZ2UoY3VycmVudFBhZ2UgKyAxKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTggaC04IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLVt2YXIoLS1jb2xvci1iZy1jYXJkKV0gYm9yZGVyIGJvcmRlci1bdmFyKC0tY29sb3ItYm9yZGVyKV0gdGV4dC1bdmFyKC0tY29sb3ItcHJpbWFyeS10dyldIHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXJcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2N1cnJlbnRQYWdlICsgMX1cbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2hhc01vcmVQYWdlcyAmJiAoXG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtW3ZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KV1cIj4uLi48L3NwYW4+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17bG9hZE1vcmV9XG4gICAgICAgICAgICBkaXNhYmxlZD17IWhhc01vcmVQYWdlcyB8fCBsb2FkaW5nfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctW3ZhcigtLWNvbG9yLWJnLWNhcmQpXSBib3JkZXIgYm9yZGVyLVt2YXIoLS1jb2xvci1ib3JkZXIpXSB0ZXh0LVt2YXIoLS1jb2xvci1wcmltYXJ5LXR3KV0gcHgtNCBweS0yIHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOmJnLVt2YXIoLS1jb2xvci1iZy1ob3ZlcildIGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBOZXh0XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZHM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbS9jbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBcIi4vc3R5bGVzLmNzc1wiO1xuaW1wb3J0IE1haW5VcGxvYWRlciBmcm9tIFwiLi9jb21wb25lbnRzL3VwbG9hZGVyL21haW5VcGxvYWRlclwiO1xuaW1wb3J0IENvbm5lY3RXYWxsZXQgZnJvbSBcIi4vY29tcG9uZW50cy93YWxsZXQvQ29ubmVjdFdhbGxldFwiO1xuaW1wb3J0IHsgV2FsbGV0UHJvdmlkZXIgfSBmcm9tIFwiLi9jb250ZXh0L1dhbGxldENvbnRleHRcIjtcbmltcG9ydCB7IEZpbGVVcGxvYWRQcm92aWRlciB9IGZyb20gXCIuL2NvbnRleHQvRmlsZVVwbG9hZENvbnRleHRcIjtcbmltcG9ydCB7IFR4UHJlcGFyYXRpb25Qcm92aWRlciB9IGZyb20gXCIuL2NvbnRleHQvVHhQcmVwYXJhdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IFR4SW5zY3JpcHRpb25Qcm92aWRlciB9IGZyb20gXCIuL2NvbnRleHQvVHhJbnNjcmlwdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IFR4U3RhdHVzUHJvdmlkZXIgfSBmcm9tIFwiLi9jb250ZXh0L1R4U3RhdHVzQ29udGV4dFwiO1xuaW1wb3J0IHsgV2FsbGV0TWVudSB9IGZyb20gXCIuL2NvbXBvbmVudHMvd2FsbGV0L1dhbGxldE1lbnVcIjtcbmltcG9ydCB7IEVOVklST05NRU5UIH0gZnJvbSBcIi4vdXRpbHMvYXBpQ29uc3VtcHRpb25cIjtcbmltcG9ydCBIZXhEZWNvZGVyIGZyb20gXCIuL2NvbXBvbmVudHMvZGVjb2Rlci9IZXhEZWNvZGVyXCI7XG5pbXBvcnQgVXBsb2FkcyBmcm9tIFwiLi9jb21wb25lbnRzL3VwbG9hZHMvdXBsb2Fkc1wiO1xuXG5jb25zdCBBcHA6IFJlYWN0LkZDID0gKCk6IFJlYWN0LlJlYWN0RWxlbWVudCA9PiB7XG4gIHJldHVybiA8TWFpblVwbG9hZGVyIC8+O1xufTtcblxuY29uc3QgQ29ubmVjdFdhbGxldEFwcDogUmVhY3QuRkMgPSAoKTogUmVhY3QuUmVhY3RFbGVtZW50ID0+IHtcbiAgcmV0dXJuIDxDb25uZWN0V2FsbGV0IC8+O1xufTtcblxuLy8gU2VsZi1leGVjdXRpbmcgZnVuY3Rpb24gdGhhdCB3b3JrcyB3aGV0aGVyIERPTSBpcyBhbHJlYWR5IGxvYWRlZCBvciBub3RcbihmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGN1cnJlbnRFeGVjdXRpbmdFbnZpcm9ubWVudCA9XG4gICAgd2luZG93LmxvY2F0aW9uLmhvc3QuaW5jbHVkZXMoXCJ3ZWJmbG93LmlvXCIpIHx8XG4gICAgd2luZG93LmxvY2F0aW9uLmhvc3QuaW5jbHVkZXMoXCJsb2NhbGhvc3RcIilcbiAgICAgID8gXCJwcmVwcm9kdWN0aW9uXCJcbiAgICAgIDogXCJwcm9kdWN0aW9uXCI7XG4gIGlmIChjdXJyZW50RXhlY3V0aW5nRW52aXJvbm1lbnQgIT09IEVOVklST05NRU5UKSB7XG4gICAgLyogY29uc29sZS5lcnJvcihgTWlzbWF0Y2hlZCBlbnZpcm9ubWVudDogRXhwZWN0ZWQgJHtFTlZJUk9OTUVOVH0sIGZvdW5kICR7Y3VycmVudEV4ZWN1dGluZ0Vudmlyb25tZW50fWApOyAqL1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBZT1UgQVJFIFdPUktJTkcgSU4gJHtjdXJyZW50RXhlY3V0aW5nRW52aXJvbm1lbnR9IEVOVklST05NRU5UYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coXCJIRUxMTyBUSEVSRSBGUk9NIFBSRVBST0RcIik7XG5cbiAgY29uc3QgcmVuZGVyQXBwID0gKCkgPT4ge1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZWFjdC10YXJnZXRcIik7XG4gICAgY29uc3QgY29ubmVjdFdhbGxldEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbm5lY3Qtd2FsbGV0XCIpO1xuICAgIC8vY29uc3QgaW5zY3JpcHRvckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluc2NyaXB0b3Itcm9vdFwiKTtcbiAgICBjb25zdCBkZWNvZGVyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVjb2RlclwiKTtcbiAgICBjb25zb2xlLmxvZyhcImRlY29kZXJFbGVtZW50XCIsIGRlY29kZXJFbGVtZW50KTtcbiAgICAvKipcbiAgICAgKiBIVE1MIGVsZW1lbnQgd2hlcmUgdGhlIDxVcGxvYWRzIC8+IGNvbXBvbmVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIFRoaXMgZWxlbWVudCBzaG91bGQgaGF2ZSBhbiBpZCBvZiBcInVwbG9hZHNcIiBhbmQgc2hvdWxkIGJlIHByZXNlbnQgaW4gdGhlXG4gICAgICogSFRNTCBkb2N1bWVudC5cbiAgICAgKi9cblxuICAgIGNvbnN0IHVwbG9hZHNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1cGxvYWRzXCIpO1xuICAgIGNvbnNvbGUubG9nKFwidXBsb2Fkc0VsZW1lbnRcIiwgdXBsb2Fkc0VsZW1lbnQpO1xuXG4gICAgaWYgKHJvb3RFbGVtZW50IC8qICYmIGluc2NyaXB0b3JFbGVtZW50ICovKSB7XG4gICAgICBjb25zdCByb290ID0gUmVhY3RET00uY3JlYXRlUm9vdChyb290RWxlbWVudCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlYWN0IHRhcmdldCBlbGVtZW50IGZvdW5kXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0IHdhbGxldCBlbGVtZW50IGZvdW5kXCIpO1xuXG4gICAgICByb290LnJlbmRlcihcbiAgICAgICAgPFJlYWN0LlN0cmljdE1vZGU+XG4gICAgICAgICAgPFdhbGxldFByb3ZpZGVyPlxuICAgICAgICAgICAgPFR4U3RhdHVzUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDxGaWxlVXBsb2FkUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPFR4UHJlcGFyYXRpb25Qcm92aWRlcj5cbiAgICAgICAgICAgICAgICAgIDxUeEluc2NyaXB0aW9uUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgICAgIHtjb25uZWN0V2FsbGV0RWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBvcnRhbCg8Q29ubmVjdFdhbGxldEFwcCAvPiwgY29ubmVjdFdhbGxldEVsZW1lbnQpfVxuICAgICAgICAgICAgICAgICAgICB7cm9vdEVsZW1lbnQgJiYgY3JlYXRlUG9ydGFsKDxBcHAgLz4sIHJvb3RFbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAge2RvY3VtZW50LmJvZHkgJiYgY3JlYXRlUG9ydGFsKDxXYWxsZXRNZW51IC8+LCBkb2N1bWVudC5ib2R5KX1cbiAgICAgICAgICAgICAgICAgICAge3VwbG9hZHNFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUG9ydGFsKDxVcGxvYWRzIC8+LCB1cGxvYWRzRWxlbWVudCl9XG4gICAgICAgICAgICAgICAgICAgIHtkZWNvZGVyRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBvcnRhbCg8SGV4RGVjb2RlciAvPiwgZGVjb2RlckVsZW1lbnQpfVxuICAgICAgICAgICAgICAgICAgICB7Lyoge2NyZWF0ZVBvcnRhbCg8TWFpcW5JbnNjcmlwdG9yIC8+LCBpbnNjcmlwdG9yRWxlbWVudCl9ICovfVxuICAgICAgICAgICAgICAgICAgPC9UeEluc2NyaXB0aW9uUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPC9UeFByZXBhcmF0aW9uUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDwvRmlsZVVwbG9hZFByb3ZpZGVyPlxuICAgICAgICAgICAgPC9UeFN0YXR1c1Byb3ZpZGVyPlxuICAgICAgICAgIDwvV2FsbGV0UHJvdmlkZXI+XG4gICAgICAgIDwvUmVhY3QuU3RyaWN0TW9kZT5cbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoZWNrIGlmIERPTSBpcyBhbHJlYWR5IGxvYWRlZFxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAvLyBJZiBub3QgbG9hZGVkIHlldCwgd2FpdCBmb3IgRE9NQ29udGVudExvYWRlZFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHJlbmRlckFwcCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYWxyZWFkeSBsb2FkZWQsIHJ1biBpbW1lZGlhdGVseVxuICAgIHJlbmRlckFwcCgpO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiRmlsZVVwbG9hZENvbnRleHQiLCJ1bmRlZmluZWQiLCJ1c2VGaWxlVXBsb2FkIiwiY29udGV4dCIsIkVycm9yIiwiRmlsZVVwbG9hZFByb3ZpZGVyIiwiX3JlZiIsImNoaWxkcmVuIiwiX3JlZiRtYXhTaXplIiwibWF4U2l6ZSIsIl91c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJfc2xpY2VkVG9BcnJheSIsImZpbGUiLCJzZXRGaWxlIiwiX3VzZVN0YXRlMyIsIl91c2VTdGF0ZTQiLCJlcnJvciIsInNldEVycm9yIiwidmFsaWRhdGVGaWxlIiwidmFsaWRUeXBlcyIsImluY2x1ZGVzIiwidHlwZSIsInNpemUiLCJhZGRGaWxlIiwibmV3RmlsZXMiLCJmaWxlVG9BZGQiLCJBcnJheSIsImZyb20iLCJmaWxlV2l0aFByZXZpZXciLCJzdGFydHNXaXRoIiwiT2JqZWN0IiwiYXNzaWduIiwicHJldmlldyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUZpbGUiLCJjbGVhckZpbGUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlVwbG9hZEljb24iLCJjbGFzc05hbWUiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwieG1sbnMiLCJkIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiYSIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJ0ZXN0IiwibiIsImwiLCJ1IiwiZiIsIm5leHQiLCJkb25lIiwiaXNBcnJheSIsIlR4U3RhdHVzQ29udGV4dCIsIlR4U3RhdHVzUHJvdmlkZXIiLCJpc1Byb2Nlc3NpbmciLCJjdXJyZW50U3RlcCIsIm5leHRTdGVwIiwicHJlcGFyYXRpb24iLCJzZXRQcmVwYXJhdGlvbiIsImluc2NyaXB0aW9uIiwic2V0SW5zY3JpcHRpb24iLCJzZXRQcmVwYXJhdGlvblN0YXR1cyIsInN0YXR1cyIsInByZXYiLCJzZXRJbnNjcmlwdGlvblN0YXR1cyIsIm1vdmVUb05leHRTdGVwIiwiZmxvdyIsIm5leHRTdGVwTWFwIiwicmVzZXRTdGF0dXMiLCJ1c2VUeFN0YXR1cyIsIm1vdGlvbiIsIkFuaW1hdGVQcmVzZW5jZSIsIlVwbG9hZEJveCIsIl91c2VGaWxlVXBsb2FkIiwiaXNEcmFnZ2luZyIsInNldElzRHJhZ2dpbmciLCJkcmFnQ291bnRlciIsInNldERyYWdDb3VudGVyIiwiX3VzZVR4U3RhdHVzIiwiaGFuZGxlRHJhZ0VudGVyIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJoYW5kbGVEcmFnTGVhdmUiLCJoYW5kbGVEcmFnT3ZlciIsImhhbmRsZURyb3AiLCJmaWxlcyIsImRhdGFUcmFuc2ZlciIsImFsZXJ0IiwiZGl2IiwiY29uY2F0Iiwib25EcmFnRW50ZXIiLCJvbkRyYWdMZWF2ZSIsIm9uRHJhZ092ZXIiLCJvbkRyb3AiLCJpbml0aWFsIiwib3BhY2l0eSIsInkiLCJhbmltYXRlIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiaWQiLCJvbkNoYW5nZSIsInRhcmdldCIsImFjY2VwdCIsImRpc2FibGVkIiwid2hpbGVIb3ZlciIsInNjYWxlIiwic3RpZmZuZXNzIiwicm90YXRlIiwibW9kZSIsInAiLCJrZXkiLCJleGl0IiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImhhc093blByb3BlcnR5IiwiYyIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZyIsImRlZmluZSIsIndyYXAiLCJHZW5lcmF0b3IiLCJjcmVhdGUiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiYXJnIiwiaCIsInMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJ2IiwidmFsdWVzIiwiZyIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsIl9pbnZva2UiLCJBc3luY0l0ZXJhdG9yIiwiaW52b2tlIiwicmVzb2x2ZSIsIl9fYXdhaXQiLCJ0aGVuIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJtZXRob2QiLCJkZWxlZ2F0ZSIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsImlzTmFOIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJyZXZlcnNlIiwicG9wIiwiY2hhckF0Iiwic3RvcCIsInJ2YWwiLCJoYW5kbGUiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9uZXh0IiwiX3Rocm93IiwidXNlRWZmZWN0IiwiYWxsU3VwcG9ydGVkV2FsbGV0cyIsImdlcm8iLCJpY29uIiwidXJsIiwibnVmaSIsImJlZ2luIiwibGFjZSIsIldhbGxldENvbnRleHQiLCJ1c2VXYWxsZXQiLCJXYWxsZXRQcm92aWRlciIsImlzTWVudU9wZW4iLCJzZXRJc01lbnVPcGVuIiwiY29ubmVjdGVkV2FsbGV0cyIsInNldENvbm5lY3RlZFdhbGxldHMiLCJfdXNlU3RhdGU1IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIl91c2VTdGF0ZTYiLCJkZWZhdWx0V2FsbGV0Iiwic2V0RGVmYXVsdFdhbGxldCIsIl91c2VTdGF0ZTciLCJfdXNlU3RhdGU4IiwiaW5zdGFsbGVkV2FsbGV0cyIsInNldEluc3RhbGxlZFdhbGxldHMiLCJkZXRlY3RDb25uZWN0ZWRXYWxsZXRzIiwiX2NhbGxlZSIsImNhcmRhbm8iLCJjb25uZWN0ZWQiLCJfaSIsIl9PYmplY3QkZW50cmllcyIsIl9PYmplY3QkZW50cmllcyRfaSIsIndhbGxldCIsImlzRW5hYmxlZCIsImFwaSIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJ3aW5kb3ciLCJlbnRyaWVzIiwiZW5hYmxlIiwidDAiLCJjb25zb2xlIiwiY29ubmVjdFdhbGxldCIsIl9yZWYzIiwiX2NhbGxlZTIiLCJ3YWxsZXROYW1lIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwidG9Mb3dlckNhc2UiLCJsb2ciLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJzZXRJdGVtIiwiX3giLCJkaXNjb25uZWN0V2FsbGV0IiwicmVtb3ZlSXRlbSIsImhhbmRsZVNldERlZmF1bHRXYWxsZXQiLCJvcGVuTWVudSIsImNsb3NlTWVudSIsImRldGVjdEluc3RhbGxlZFdhbGxldHMiLCJpbnN0YWxsZWQiLCJnZXRXYWxsZXRBcGkiLCJmaW5kIiwidyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid2FsbGV0cyIsIkFQSV9QQVRIIiwiYnVpbGRBcGlVcmwiLCJwYXRoIiwiQVBJX0tFWSIsInRvSGV4IiwiaW5wdXQiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVUb0hleCIsInN0ciIsImVuY29kZSIsIm1hcCIsImJ5dGUiLCJwYWRTdGFydCIsImpvaW4iLCJiYXNlNjRUb0hleCIsInJhdyIsImF0b2IiLCJyZXN1bHQiLCJoZXgiLCJjaGFyQ29kZUF0IiwidG9VcHBlckNhc2UiLCJFTlZJUk9OTUVOVCIsInByb2Nlc3MiLCJlbnYiLCJUeFByZXBhcmF0aW9uQ29udGV4dCIsInVzZVR4UHJlcGFyYXRpb24iLCJUeFByZXBhcmF0aW9uUHJvdmlkZXIiLCJmaWxlUHJvZ3Jlc3MiLCJzZXRGaWxlUHJvZ3Jlc3MiLCJzZXRJc1Byb2Nlc3NpbmciLCJfdXNlV2FsbGV0Iiwic3VibWlzc2lvblN0YXR1cyIsInNldFN1Ym1pc3Npb25TdGF0dXMiLCJfdXNlU3RhdGU5IiwiX3VzZVN0YXRlMTAiLCJ1bnNpZ25lZFR4SWQiLCJzZXRVbnNpZ25lZFR4SWQiLCJ1cGRhdGVGaWxlUHJvZ3Jlc3MiLCJpbmRleCIsInVwZGF0ZXMiLCJpdGVtIiwiY2xlYXJFcnJvciIsImNvbnN0cnVjdFR4IiwiX3JlZjIiLCJkYXRhIiwiZGF0YVR5cGUiLCJyZXdhcmRBZGRyZXNzZXMiLCJ1dHhvcyIsInRhcmdldEFkZHJlc3MiLCJib2R5IiwicmVzcG9uc2UiLCJlcnJvckRhdGEiLCJlcnJvclJlc3BvbnNlIiwiZ2V0UmV3YXJkQWRkcmVzc2VzIiwiZ2V0VXR4b3MiLCJnZXRVc2VkQWRkcmVzc2VzIiwiZmV0Y2giLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiY2xvbmUiLCJqc29uIiwidDEiLCJ0ZXh0Iiwic3RhdHVzVGV4dCIsImVuZHBvaW50IiwiX3gyIiwiX3gzIiwicHJlcGFyZUZpbGVzIiwiX2xvb3AiLCJfY29udGV4dDMiLCJwcm9ncmVzcyIsInJlYWRlciIsImZpbGVBc0Jhc2U2NCIsImJhc2U2NENvbnRlbnQiLCJjb25zdHJ1Y3RlZFR4IiwiX2xvb3AkIiwiRmlsZVJlYWRlciIsInJlamVjdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwic3BsaXQiLCJ0eEluZm8iLCJtZXNzYWdlIiwiX3g0IiwicHJlcGFyZVRleHQiLCJfcmVmNCIsIl9jYWxsZWUzIiwidGV4dEZpbGUiLCJfY2FsbGVlMyQiLCJfY29udGV4dDQiLCJGaWxlIiwiYnRvYSIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiX3g1IiwicG9sbEZvckNvbmZpcm1hdGlvbiIsIl9yZWY1IiwiX2NhbGxlZTQiLCJwcmVwYXJlZFR4IiwicmV0cnlJbnRlcnZhbCIsIl9jYWxsZWU0JCIsIl9jb250ZXh0NSIsImV4ZWN1dGlvbkFybiIsInN1Y2Nlc3MiLCJvbmNoYWluIiwicmVzIiwic2V0VGltZW91dCIsIl94NiIsImhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciIsImVycm9yTWVzc2FnZSIsImluZm8iLCJfcGFyc2VkRXJyb3IkZXJyb3IiLCJwYXJzZWRFcnJvciIsInBhcnNlIiwic2lnbkFuZFN1Ym1pdCIsIl9yZWY2IiwiX2NhbGxlZTUiLCJfZmlsZSR0eEluZm8iLCJ1bnNpZ25lZFR4UmVzcG9uc2UiLCJ1bnNpZ25lZFR4IiwicmV0cnlSZXNwb25zZSIsIl9lcnJvckRhdGEiLCJfZXJyb3JSZXNwb25zZSIsImhleFR4Iiwic2lnbmVkVHgiLCJzdWJtaXRSZXNwb25zZSIsIl9lcnJvckRhdGEyIiwiX2Vycm9yUmVzcG9uc2UyIiwic3VibWl0dGVkVHgiLCJjb25maXJtZWQiLCJfY2FsbGVlNSQiLCJfY29udGV4dDYiLCJ0eGlkIiwiaW5Qcm9ncmVzcyIsInR4Iiwic2lnblR4IiwidDIiLCJ1bGlkIiwid2l0bmVzc1NldCIsInQzIiwidDQiLCJDbG9zZUljb24iLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIk1vdGlvblZhbHVlIiwiQnV0dG9uIiwiX3JlZiR2YXJpYW50IiwidmFyaWFudCIsImxvYWRpbmdUZXh0Iiwic3VjY2Vzc1RleHQiLCJpY29uQmVmb3JlIiwiaWNvbkFmdGVyIiwib25DbGljayIsIl9yZWYkYW5pbWF0ZSIsIl9yZWYkY2xhc3NOYW1lIiwicHJvcHMiLCJfZXhjbHVkZWQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJpc1N1Y2Nlc3MiLCJzZXRJc1N1Y2Nlc3MiLCJoYW5kbGVDbGljayIsImV2ZW50IiwiYmFzZUNsYXNzZXMiLCJ2YXJpYW50Q2xhc3NlcyIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJnaG9zdCIsImRpc2FibGVkQ2xhc3NlcyIsInNpemVDbGFzc2VzIiwiYnV0dG9uQ2xhc3NlcyIsImJ1dHRvbiIsIl9leHRlbmRzIiwid2hpbGVUYXAiLCJGcmFnbWVudCIsInJlcGVhdCIsIlBPU0lUSVZFX0lORklOSVRZIiwiZWFzZSIsImRhbXBpbmciLCJjaGlsZCIsInNwYW4iLCJQZGZJY29uIiwiUG5nSWNvbiIsIlBkZ0ljb24iLCJNcDRJY29uIiwiRmlsZUxpc3QiLCJfdXNlVHhQcmVwYXJhdGlvbiIsIngiLCJzcmMiLCJhbHQiLCJ0b0ZpeGVkIiwiRGVsZWdhdGVWaWV3Iiwic2V0VGV4dCIsInBsYWNlaG9sZGVyIiwiVHhJbnNjcmlwdGlvbkNvbnRleHQiLCJpbnNjcmliZUZpbGVzIiwiX2luc2NyaWJlRmlsZXMiLCJpbnNjcmliZVRleHQiLCJfaW5zY3JpYmVUZXh0IiwiX3NpZ25BbmRTdWJtaXQiLCJzZXRVbnNpZ25lZFR4IiwidXNlVHhJbnNjcmlwdGlvbiIsIlR4SW5zY3JpcHRpb25Qcm92aWRlciIsImNvbnN0cnVjdEluc2NyaXB0aW9uVHgiLCJwYXlsb2FkIiwicGF5bG9hZFR5cGUiLCJjaGFuZ2VBZGRyZXNzIiwibWludFRva2VuRm9yUGF5bG9hZCIsIl9jYWxsZWU2IiwiX2NhbGxlZTYkIiwiX2NvbnRleHQ3IiwiX2NhbGxlZTciLCJyZXNwb25zZVRleHQiLCJfZXJyb3JNZXNzYWdlIiwiX2NhbGxlZTckIiwiX2NvbnRleHQ4IiwiX2NhbGxlZTkiLCJfbG9vcDIiLCJfY2FsbGVlOSQiLCJfY29udGV4dDExIiwiX2FwaSIsInNpZ25lZFNoYXJkVHhzIiwiaW5zY3JpYmVTdWJtaXRCb2R5IiwiX2xvb3AyJCIsIl9jb250ZXh0MTAiLCJpbmRleGluZ1R4IiwiaWR4IiwiYWxsIiwic2hhcmRUeHMiLCJfcmVmNyIsIl9jYWxsZWU4Iiwic2hhcmRUeCIsImhleFNoYXJkVHgiLCJfYXBpMiIsIl9jYWxsZWU4JCIsIl9jb250ZXh0OSIsIl94NyIsImluZGV4aW5nVHhUb1N1Ym1pdCIsInR4c1RvU3VibWl0IiwidWxpZE9mT2JqZWN0Iiwib2JqZWN0VWxpZCIsIkxvYWRpbmdTY3JlZW4iLCJfcmVmJHRleHQiLCJyb3RhdGVZIiwiZGVsYXkiLCJocmVmIiwiRXhwbG9yZXJMaW5rIiwidHhJZCIsInJlbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiRmluaXNoU2NyZWVuIiwiX3JlZjIkdGV4dCIsIl9yZWYyJGNsYXNzTmFtZSIsInNldElzUHJlcGFyZWQiLCJzZXRJc0luc2NyaWJlZCIsInNldERlbGVnYXRlVGV4dCIsInByZXBhcmF0aW9uVHhJZCIsImluZGV4aW5nVHhJZCIsInNoYXJkVHhJZHMiLCJfdXNlVHhJbnNjcmlwdGlvbiIsInJlc2V0UHJlcGFyYXRpb24iLCJzaGFyZFR4SWQiLCJhbGxTaGFyZFN1Ym1pc3Npb25zIiwic2hhcmQiLCJzaGFyZFN1Ym1pdHRlZFR4aWQiLCJQcm9ncmVzc0JhciIsInRvdGFsU3RlcHMiLCJzdGVwVGV4dCIsInBoYXNlIiwic3R5bGUiLCJNYWluVXBsb2FkZXIiLCJfcHJlcGFyYXRpb25TdWJtaXNzaW8yIiwiX3Vuc2lnbmVkVHgkc3VjY2VzcyIsIl91bnNpZ25lZFR4JHN1Y2Nlc3MyIiwiYWN0aXZlVmlldyIsInNldEFjdGl2ZVZpZXciLCJpc1ByZXBhcmluZyIsInByZXBhcmVTdGVwIiwicHJlcGFyZU5leHRTdGVwIiwicHJlcGFyZUVycm9yIiwiY2xlYXJQcmVwYXJlRXJyb3IiLCJzaWduQW5kU3VibWl0UHJlcGFyYXRpb24iLCJwcmVwYXJhdGlvblN1Ym1pc3Npb25TdGF0dXMiLCJpc0luc2NyaWJlUHJlcGFyaW5nIiwiaW5zY3JpYmVTdGVwIiwiaW5zY3JpYmVOZXh0U3RlcCIsImluc2NyaWJlRXJyb3IiLCJjbGVhckluc2NyaWJlRXJyb3IiLCJzaWduQW5kU3VibWl0SW5zY3JpcHRpb24iLCJyZXNldEluc2NyaXB0aW9uIiwiaXNQcmVwYXJlZCIsImlzSW5zY3JpYmVkIiwiZGVsZWdhdGVUZXh0IiwiX3ByZXBhcmF0aW9uU3VibWlzc2lvIiwiZ2V0TG9hZGluZ1RleHQiLCJnZXRQcm9ncmVzc1RleHQiLCJnZXRCdXR0b25UZXh0IiwiaXNJbkZpbmFsU3RlcCIsImhhbmRsZVByZXBhcmUiLCJoYW5kbGVJbnNjcmliZSIsImhhbmRsZVNpZ25BbmRTdWJtaXRQcmVwYXJhdGlvbiIsImhhbmRsZVNpZ25BbmRTdWJtaXRJbnNjcmlwdGlvbiIsImhhbmRsZUJhY2siLCJoYW5kbGVDYW5jZWwiLCJzaG93TG9hZGVyIiwiaGFuZGxlTWFpbkJ1dHRvbkNsaWNrIiwiZ2V0VG90YWxTdGVwcyIsImdldEN1cnJlbnRTdGVwIiwicHJlcGFyZVN0ZXBzIiwiaW5zY3JpYmVTdGVwcyIsImVuZCIsImdldFN0ZXBQaGFzZSIsImJvcmRlclJhZGl1cyIsInRyaW0iLCJDb25uZWN0V2FsbGV0IiwiQ2xvc2VJY29uU2Vjb25kYXJ5IiwiV2FsbGV0TWVudSIsImF2YWlsYWJsZVdhbGxldHMiLCJfIiwic29tZSIsIndhbGxldHNUb0luc3RhbGwiLCJjb25uZWN0ZWRXYWxsZXQiLCJpc0RlZmF1bHQiLCJfcmVmOCIsIm9wZW4iLCJpbml0aWFsaXplV2FzbURlY29kZXIiLCJfaW5pdGlhbGl6ZVdhc21EZWNvZGVyIiwid2FzbU1vZHVsZVVybCIsIndhc21VcmwiLCJjb21waWxlZFdhc21EZWNvZGVyIiwid2FzaUhhbmRsZXIiLCJiYXNlV2FzaSIsImltcG9ydE9iamVjdCIsIndhc21JbnN0YW5jZSIsIl9yZXNwb25zZSIsIndhc21CeXRlcyIsIndhc21Nb2R1bGUiLCJfd2FzaUhhbmRsZXIiLCJfYmFzZVdhc2kiLCJfaW1wb3J0T2JqZWN0IiwiX3dhc21JbnN0YW5jZSIsIldlYkFzc2VtYmx5IiwiY29tcGlsZVN0cmVhbWluZyIsImdldCIsInByb3AiLCJwcm9jX2V4aXQiLCJjb2RlIiwiZmRfd3JpdGUiLCJmZCIsImlvdnMiLCJpb3ZzTGVuIiwibndyaXR0ZW4iLCJ3YXNpX3NuYXBzaG90X3ByZXZpZXcxIiwiUHJveHkiLCJpbnN0YW50aWF0ZSIsIndhcm4iLCJhcnJheUJ1ZmZlciIsImNvbXBpbGUiLCJpc1ZhbGlkSGV4U3RyaW5nIiwiaGV4VG9CeXRlcyIsInJlcGxhY2UiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImJ5dGVzVG9CYXNlNjQiLCJiaW5TdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXMiLCJfcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzIiwid0luc3RhbmNlIiwiaGV4U3RyaW5nQXJyYXkiLCJ2YWxpZEhleFN0cmluZ3MiLCJoZXhTdHJpbmdQdHJzIiwiaGV4U3RyaW5nQXJyYXlQdHJBZGRyIiwiYmFzZTY0UHRyIiwibWVtIiwidmlldyIsIl9iYXNlIiwiY29tYmluZWRIZXgiLCJiYXNlNjQiLCJleHBvcnRzIiwibWVtb3J5IiwiaHNfaW5pdCIsIndyaXRlQ1N0cmluZyIsIm1hbGxvY19ieXRlc19ocyIsImJ1ZmZlciIsIkRhdGFWaWV3Iiwic2V0VWludDMyIiwicmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzQyIsInJlYWRDU3RyaW5nIiwiZnJlZV9ocyIsInB0ciIsImhzX2V4aXQiLCJjbGVhbnVwRXJyb3IiLCJieXRlTGVuZ3RoIiwibWVtTGVuZ3RoIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJzdWJhcnJheSIsImxlbmd0aE5lZWRlZCIsImJhc2U2NFRvQnl0ZXMiLCJiaW5TdHIiLCJ1c2VSZWYiLCJIZXhEZWNvZGVyIiwic2V0SW5wdXQiLCJmb3JtYXQiLCJzZXRGb3JtYXQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsInNldFJlc3VsdCIsImxhc3RIZXhJbnB1dCIsImxhc3RCYXNlNjQiLCJpbml0V2FzbSIsIl95aWVsZCRpbml0aWFsaXplV2FzbSIsImluc3QiLCJjdXJyZW50IiwiaGV4cyIsInR4dCIsImFyciIsIm91dCIsImVuZHNXaXRoIiwiX3VudXNlZCIsIkJvb2xlYW4iLCJlcnIiLCJ0YWJzIiwibGFiZWwiLCJ0YWIiLCJkb3dubG9hZCIsInRpdGxlIiwidXNlUmV3YXJkQWNjb3VudHMiLCJyZXdhcmRBY2NvdW50cyIsInNldFJld2FyZEFjY291bnRzIiwiZmV0Y2hSZXdhcmRBY2NvdW50cyIsInVzZVVwbG9hZHMiLCJfcmVmJGxpbWl0IiwibGltaXQiLCJhbGxVcGxvYWRzIiwic2V0QWxsVXBsb2FkcyIsImZpbHRlcmVkVXBsb2FkcyIsInNldEZpbHRlcmVkVXBsb2FkcyIsImRpc3BsYXllZFVwbG9hZHMiLCJzZXREaXNwbGF5ZWRVcGxvYWRzIiwiX3VzZVN0YXRlMTEiLCJfdXNlU3RhdGUxMiIsInBhZ2VzRGF0YSIsInNldFBhZ2VzRGF0YSIsIl91c2VTdGF0ZTEzIiwiX3VzZVN0YXRlMTQiLCJsYXN0T2JqZWN0VWxpZHMiLCJzZXRMYXN0T2JqZWN0VWxpZHMiLCJfdXNlU3RhdGUxNSIsIl91c2VTdGF0ZTE2IiwiY3VycmVudFBhZ2UiLCJzZXRDdXJyZW50UGFnZSIsIl91c2VTdGF0ZTE3IiwiX3VzZVN0YXRlMTgiLCJoYXNNb3JlUGFnZXMiLCJzZXRIYXNNb3JlUGFnZXMiLCJmZXRjaEluaXRpYWxVcGxvYWRzIiwiZm9ybWF0dGVkVXBsb2FkcyIsImxhc3RVbGlkIiwib2JqZWN0cyIsIm1MYXN0T2JqZWN0VWxpZCIsImZldGNoTmV4dFBhZ2UiLCJwYWdlTnVtYmVyIiwibmV3TGFzdFVsaWQiLCJsYXN0T2JqZWN0VWxpZCIsImdldEltYWdlU3JjIiwidXBsb2FkIiwidGh1bWJuYWlsVXJsIiwib2JqZWN0RGF0YSIsIm9iamVjdFR5cGUiLCJmb3JtYXREYXRlIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJEYXRlIiwiZ2V0VGltZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIlVwbG9hZENhcmQiLCJvbkNvcHlUZXh0IiwiaW5kZXhpbmdUeFN1Ym1pdHRlZEF0IiwiZGVzY3JpcHRpb24iLCJmaWxlVHlwZSIsIlVwbG9hZHNHcmlkIiwidXBsb2FkcyIsIlVwbG9hZExpc3RJdGVtIiwiVXBsb2Fkc0xpc3QiLCJVcGxvYWRzRmlsdGVycyIsImRhdGVGaWx0ZXIiLCJzZXREYXRlRmlsdGVyIiwidHlwZUZpbHRlciIsInNldFR5cGVGaWx0ZXIiLCJzZWFyY2hRdWVyeSIsInNldFNlYXJjaFF1ZXJ5Iiwib25TZWFyY2giLCJkYXRlRmlsdGVyT3B0aW9ucyIsInR5cGVGaWx0ZXJPcHRpb25zIiwidmlld01vZGUiLCJzZXRWaWV3TW9kZSIsIm9uU3VibWl0Iiwib3B0aW9uIiwibW9ja1VwbG9hZHMiLCJkYXRlVXBsb2FkZWQiLCJHcmFkaWVudFRleHQiLCJVcGxvYWRzIiwiX3VzZVVwbG9hZHMiLCJmaWx0ZXJlZCIsIm5vdyIsInRvZGF5IiwiZ2V0RnVsbFllYXIiLCJnZXRNb250aCIsImdldERhdGUiLCJ0aGlzV2VlayIsInNldERhdGUiLCJ0aGlzTW9udGgiLCJzZXRNb250aCIsInRoaXNZZWFyIiwic2V0RnVsbFllYXIiLCJ1cGxvYWREYXRlIiwibG93ZXJGaWxlVHlwZSIsInF1ZXJ5IiwiaGFuZGxlU2VhcmNoIiwiaGFuZGxlQ29weVRleHQiLCJuYXZpZ2F0b3IiLCJjbGlwYm9hcmQiLCJ3cml0ZVRleHQiLCJsb2FkTW9yZSIsImdvVG9QcmV2aW91c1BhZ2UiLCJnb1RvUGFnZSIsInBhZ2UiLCJSZWFjdERPTSIsImNyZWF0ZVBvcnRhbCIsIkFwcCIsIkNvbm5lY3RXYWxsZXRBcHAiLCJjdXJyZW50RXhlY3V0aW5nRW52aXJvbm1lbnQiLCJsb2NhdGlvbiIsImhvc3QiLCJyZW5kZXJBcHAiLCJyb290RWxlbWVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJjb25uZWN0V2FsbGV0RWxlbWVudCIsImRlY29kZXJFbGVtZW50IiwidXBsb2Fkc0VsZW1lbnQiLCJyb290IiwiY3JlYXRlUm9vdCIsInJlbmRlciIsIlN0cmljdE1vZGUiLCJyZWFkeVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///108\n')},408:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(354);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/*! tailwindcss v4.0.2 | MIT License | https://tailwindcss.com */\n@layer theme, base, components, utilities;\n@layer theme {\n  :root, :host {\n    --font-sans: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",\n      "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";\n    --font-serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;\n    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,\n      "Liberation Mono", "Courier New", monospace;\n    --color-red-50: oklch(0.971 0.013 17.38);\n    --color-red-100: oklch(0.936 0.032 17.717);\n    --color-red-200: oklch(0.885 0.062 18.334);\n    --color-red-300: oklch(0.808 0.114 19.571);\n    --color-red-400: oklch(0.704 0.191 22.216);\n    --color-red-500: oklch(0.637 0.237 25.331);\n    --color-red-600: oklch(0.577 0.245 27.325);\n    --color-red-700: oklch(0.505 0.213 27.518);\n    --color-red-800: oklch(0.444 0.177 26.899);\n    --color-red-900: oklch(0.396 0.141 25.723);\n    --color-red-950: oklch(0.258 0.092 26.042);\n    --color-orange-50: oklch(0.98 0.016 73.684);\n    --color-orange-100: oklch(0.954 0.038 75.164);\n    --color-orange-200: oklch(0.901 0.076 70.697);\n    --color-orange-300: oklch(0.837 0.128 66.29);\n    --color-orange-400: oklch(0.75 0.183 55.934);\n    --color-orange-500: oklch(0.705 0.213 47.604);\n    --color-orange-600: oklch(0.646 0.222 41.116);\n    --color-orange-700: oklch(0.553 0.195 38.402);\n    --color-orange-800: oklch(0.47 0.157 37.304);\n    --color-orange-900: oklch(0.408 0.123 38.172);\n    --color-orange-950: oklch(0.266 0.079 36.259);\n    --color-amber-50: oklch(0.987 0.022 95.277);\n    --color-amber-100: oklch(0.962 0.059 95.617);\n    --color-amber-200: oklch(0.924 0.12 95.746);\n    --color-amber-300: oklch(0.879 0.169 91.605);\n    --color-amber-400: oklch(0.828 0.189 84.429);\n    --color-amber-500: oklch(0.769 0.188 70.08);\n    --color-amber-600: oklch(0.666 0.179 58.318);\n    --color-amber-700: oklch(0.555 0.163 48.998);\n    --color-amber-800: oklch(0.473 0.137 46.201);\n    --color-amber-900: oklch(0.414 0.112 45.904);\n    --color-amber-950: oklch(0.279 0.077 45.635);\n    --color-yellow-50: oklch(0.987 0.026 102.212);\n    --color-yellow-100: oklch(0.973 0.071 103.193);\n    --color-yellow-200: oklch(0.945 0.129 101.54);\n    --color-yellow-300: oklch(0.905 0.182 98.111);\n    --color-yellow-400: oklch(0.852 0.199 91.936);\n    --color-yellow-500: oklch(0.795 0.184 86.047);\n    --color-yellow-600: oklch(0.681 0.162 75.834);\n    --color-yellow-700: oklch(0.554 0.135 66.442);\n    --color-yellow-800: oklch(0.476 0.114 61.907);\n    --color-yellow-900: oklch(0.421 0.095 57.708);\n    --color-yellow-950: oklch(0.286 0.066 53.813);\n    --color-lime-50: oklch(0.986 0.031 120.757);\n    --color-lime-100: oklch(0.967 0.067 122.328);\n    --color-lime-200: oklch(0.938 0.127 124.321);\n    --color-lime-300: oklch(0.897 0.196 126.665);\n    --color-lime-400: oklch(0.841 0.238 128.85);\n    --color-lime-500: oklch(0.768 0.233 130.85);\n    --color-lime-600: oklch(0.648 0.2 131.684);\n    --color-lime-700: oklch(0.532 0.157 131.589);\n    --color-lime-800: oklch(0.453 0.124 130.933);\n    --color-lime-900: oklch(0.405 0.101 131.063);\n    --color-lime-950: oklch(0.274 0.072 132.109);\n    --color-green-50: oklch(0.982 0.018 155.826);\n    --color-green-100: oklch(0.962 0.044 156.743);\n    --color-green-200: oklch(0.925 0.084 155.995);\n    --color-green-300: oklch(0.871 0.15 154.449);\n    --color-green-400: oklch(0.792 0.209 151.711);\n    --color-green-500: oklch(0.723 0.219 149.579);\n    --color-green-600: oklch(0.627 0.194 149.214);\n    --color-green-700: oklch(0.527 0.154 150.069);\n    --color-green-800: oklch(0.448 0.119 151.328);\n    --color-green-900: oklch(0.393 0.095 152.535);\n    --color-green-950: oklch(0.266 0.065 152.934);\n    --color-emerald-50: oklch(0.979 0.021 166.113);\n    --color-emerald-100: oklch(0.95 0.052 163.051);\n    --color-emerald-200: oklch(0.905 0.093 164.15);\n    --color-emerald-300: oklch(0.845 0.143 164.978);\n    --color-emerald-400: oklch(0.765 0.177 163.223);\n    --color-emerald-500: oklch(0.696 0.17 162.48);\n    --color-emerald-600: oklch(0.596 0.145 163.225);\n    --color-emerald-700: oklch(0.508 0.118 165.612);\n    --color-emerald-800: oklch(0.432 0.095 166.913);\n    --color-emerald-900: oklch(0.378 0.077 168.94);\n    --color-emerald-950: oklch(0.262 0.051 172.552);\n    --color-teal-50: oklch(0.984 0.014 180.72);\n    --color-teal-100: oklch(0.953 0.051 180.801);\n    --color-teal-200: oklch(0.91 0.096 180.426);\n    --color-teal-300: oklch(0.855 0.138 181.071);\n    --color-teal-400: oklch(0.777 0.152 181.912);\n    --color-teal-500: oklch(0.704 0.14 182.503);\n    --color-teal-600: oklch(0.6 0.118 184.704);\n    --color-teal-700: oklch(0.511 0.096 186.391);\n    --color-teal-800: oklch(0.437 0.078 188.216);\n    --color-teal-900: oklch(0.386 0.063 188.416);\n    --color-teal-950: oklch(0.277 0.046 192.524);\n    --color-cyan-50: oklch(0.984 0.019 200.873);\n    --color-cyan-100: oklch(0.956 0.045 203.388);\n    --color-cyan-200: oklch(0.917 0.08 205.041);\n    --color-cyan-300: oklch(0.865 0.127 207.078);\n    --color-cyan-400: oklch(0.789 0.154 211.53);\n    --color-cyan-500: oklch(0.715 0.143 215.221);\n    --color-cyan-600: oklch(0.609 0.126 221.723);\n    --color-cyan-700: oklch(0.52 0.105 223.128);\n    --color-cyan-800: oklch(0.45 0.085 224.283);\n    --color-cyan-900: oklch(0.398 0.07 227.392);\n    --color-cyan-950: oklch(0.302 0.056 229.695);\n    --color-sky-50: oklch(0.977 0.013 236.62);\n    --color-sky-100: oklch(0.951 0.026 236.824);\n    --color-sky-200: oklch(0.901 0.058 230.902);\n    --color-sky-300: oklch(0.828 0.111 230.318);\n    --color-sky-400: oklch(0.746 0.16 232.661);\n    --color-sky-500: oklch(0.685 0.169 237.323);\n    --color-sky-600: oklch(0.588 0.158 241.966);\n    --color-sky-700: oklch(0.5 0.134 242.749);\n    --color-sky-800: oklch(0.443 0.11 240.79);\n    --color-sky-900: oklch(0.391 0.09 240.876);\n    --color-sky-950: oklch(0.293 0.066 243.157);\n    --color-blue-50: oklch(0.97 0.014 254.604);\n    --color-blue-100: oklch(0.932 0.032 255.585);\n    --color-blue-200: oklch(0.882 0.059 254.128);\n    --color-blue-300: oklch(0.809 0.105 251.813);\n    --color-blue-400: oklch(0.707 0.165 254.624);\n    --color-blue-500: oklch(0.623 0.214 259.815);\n    --color-blue-600: oklch(0.546 0.245 262.881);\n    --color-blue-700: oklch(0.488 0.243 264.376);\n    --color-blue-800: oklch(0.424 0.199 265.638);\n    --color-blue-900: oklch(0.379 0.146 265.522);\n    --color-blue-950: oklch(0.282 0.091 267.935);\n    --color-indigo-50: oklch(0.962 0.018 272.314);\n    --color-indigo-100: oklch(0.93 0.034 272.788);\n    --color-indigo-200: oklch(0.87 0.065 274.039);\n    --color-indigo-300: oklch(0.785 0.115 274.713);\n    --color-indigo-400: oklch(0.673 0.182 276.935);\n    --color-indigo-500: oklch(0.585 0.233 277.117);\n    --color-indigo-600: oklch(0.511 0.262 276.966);\n    --color-indigo-700: oklch(0.457 0.24 277.023);\n    --color-indigo-800: oklch(0.398 0.195 277.366);\n    --color-indigo-900: oklch(0.359 0.144 278.697);\n    --color-indigo-950: oklch(0.257 0.09 281.288);\n    --color-violet-50: oklch(0.969 0.016 293.756);\n    --color-violet-100: oklch(0.943 0.029 294.588);\n    --color-violet-200: oklch(0.894 0.057 293.283);\n    --color-violet-300: oklch(0.811 0.111 293.571);\n    --color-violet-400: oklch(0.702 0.183 293.541);\n    --color-violet-500: oklch(0.606 0.25 292.717);\n    --color-violet-600: oklch(0.541 0.281 293.009);\n    --color-violet-700: oklch(0.491 0.27 292.581);\n    --color-violet-800: oklch(0.432 0.232 292.759);\n    --color-violet-900: oklch(0.38 0.189 293.745);\n    --color-violet-950: oklch(0.283 0.141 291.089);\n    --color-purple-50: oklch(0.977 0.014 308.299);\n    --color-purple-100: oklch(0.946 0.033 307.174);\n    --color-purple-200: oklch(0.902 0.063 306.703);\n    --color-purple-300: oklch(0.827 0.119 306.383);\n    --color-purple-400: oklch(0.714 0.203 305.504);\n    --color-purple-500: oklch(0.627 0.265 303.9);\n    --color-purple-600: oklch(0.558 0.288 302.321);\n    --color-purple-700: oklch(0.496 0.265 301.924);\n    --color-purple-800: oklch(0.438 0.218 303.724);\n    --color-purple-900: oklch(0.381 0.176 304.987);\n    --color-purple-950: oklch(0.291 0.149 302.717);\n    --color-fuchsia-50: oklch(0.977 0.017 320.058);\n    --color-fuchsia-100: oklch(0.952 0.037 318.852);\n    --color-fuchsia-200: oklch(0.903 0.076 319.62);\n    --color-fuchsia-300: oklch(0.833 0.145 321.434);\n    --color-fuchsia-400: oklch(0.74 0.238 322.16);\n    --color-fuchsia-500: oklch(0.667 0.295 322.15);\n    --color-fuchsia-600: oklch(0.591 0.293 322.896);\n    --color-fuchsia-700: oklch(0.518 0.253 323.949);\n    --color-fuchsia-800: oklch(0.452 0.211 324.591);\n    --color-fuchsia-900: oklch(0.401 0.17 325.612);\n    --color-fuchsia-950: oklch(0.293 0.136 325.661);\n    --color-pink-50: oklch(0.971 0.014 343.198);\n    --color-pink-100: oklch(0.948 0.028 342.258);\n    --color-pink-200: oklch(0.899 0.061 343.231);\n    --color-pink-300: oklch(0.823 0.12 346.018);\n    --color-pink-400: oklch(0.718 0.202 349.761);\n    --color-pink-500: oklch(0.656 0.241 354.308);\n    --color-pink-600: oklch(0.592 0.249 0.584);\n    --color-pink-700: oklch(0.525 0.223 3.958);\n    --color-pink-800: oklch(0.459 0.187 3.815);\n    --color-pink-900: oklch(0.408 0.153 2.432);\n    --color-pink-950: oklch(0.284 0.109 3.907);\n    --color-rose-50: oklch(0.969 0.015 12.422);\n    --color-rose-100: oklch(0.941 0.03 12.58);\n    --color-rose-200: oklch(0.892 0.058 10.001);\n    --color-rose-300: oklch(0.81 0.117 11.638);\n    --color-rose-400: oklch(0.712 0.194 13.428);\n    --color-rose-500: oklch(0.645 0.246 16.439);\n    --color-rose-600: oklch(0.586 0.253 17.585);\n    --color-rose-700: oklch(0.514 0.222 16.935);\n    --color-rose-800: oklch(0.455 0.188 13.697);\n    --color-rose-900: oklch(0.41 0.159 10.272);\n    --color-rose-950: oklch(0.271 0.105 12.094);\n    --color-slate-50: oklch(0.984 0.003 247.858);\n    --color-slate-100: oklch(0.968 0.007 247.896);\n    --color-slate-200: oklch(0.929 0.013 255.508);\n    --color-slate-300: oklch(0.869 0.022 252.894);\n    --color-slate-400: oklch(0.704 0.04 256.788);\n    --color-slate-500: oklch(0.554 0.046 257.417);\n    --color-slate-600: oklch(0.446 0.043 257.281);\n    --color-slate-700: oklch(0.372 0.044 257.287);\n    --color-slate-800: oklch(0.279 0.041 260.031);\n    --color-slate-900: oklch(0.208 0.042 265.755);\n    --color-slate-950: oklch(0.129 0.042 264.695);\n    --color-gray-50: oklch(0.985 0.002 247.839);\n    --color-gray-100: oklch(0.967 0.003 264.542);\n    --color-gray-200: oklch(0.928 0.006 264.531);\n    --color-gray-300: oklch(0.872 0.01 258.338);\n    --color-gray-400: oklch(0.707 0.022 261.325);\n    --color-gray-500: oklch(0.551 0.027 264.364);\n    --color-gray-600: oklch(0.446 0.03 256.802);\n    --color-gray-700: oklch(0.373 0.034 259.733);\n    --color-gray-800: oklch(0.278 0.033 256.848);\n    --color-gray-900: oklch(0.21 0.034 264.665);\n    --color-gray-950: oklch(0.13 0.028 261.692);\n    --color-zinc-50: oklch(0.985 0 0);\n    --color-zinc-100: oklch(0.967 0.001 286.375);\n    --color-zinc-200: oklch(0.92 0.004 286.32);\n    --color-zinc-300: oklch(0.871 0.006 286.286);\n    --color-zinc-400: oklch(0.705 0.015 286.067);\n    --color-zinc-500: oklch(0.552 0.016 285.938);\n    --color-zinc-600: oklch(0.442 0.017 285.786);\n    --color-zinc-700: oklch(0.37 0.013 285.805);\n    --color-zinc-800: oklch(0.274 0.006 286.033);\n    --color-zinc-900: oklch(0.21 0.006 285.885);\n    --color-zinc-950: oklch(0.141 0.005 285.823);\n    --color-neutral-50: oklch(0.985 0 0);\n    --color-neutral-100: oklch(0.97 0 0);\n    --color-neutral-200: oklch(0.922 0 0);\n    --color-neutral-300: oklch(0.87 0 0);\n    --color-neutral-400: oklch(0.708 0 0);\n    --color-neutral-500: oklch(0.556 0 0);\n    --color-neutral-600: oklch(0.439 0 0);\n    --color-neutral-700: oklch(0.371 0 0);\n    --color-neutral-800: oklch(0.269 0 0);\n    --color-neutral-900: oklch(0.205 0 0);\n    --color-neutral-950: oklch(0.145 0 0);\n    --color-stone-50: oklch(0.985 0.001 106.423);\n    --color-stone-100: oklch(0.97 0.001 106.424);\n    --color-stone-200: oklch(0.923 0.003 48.717);\n    --color-stone-300: oklch(0.869 0.005 56.366);\n    --color-stone-400: oklch(0.709 0.01 56.259);\n    --color-stone-500: oklch(0.553 0.013 58.071);\n    --color-stone-600: oklch(0.444 0.011 73.639);\n    --color-stone-700: oklch(0.374 0.01 67.558);\n    --color-stone-800: oklch(0.268 0.007 34.298);\n    --color-stone-900: oklch(0.216 0.006 56.043);\n    --color-stone-950: oklch(0.147 0.004 49.25);\n    --color-black: #000;\n    --color-white: #fff;\n    --spacing: 0.25rem;\n    --breakpoint-sm: 40rem;\n    --breakpoint-md: 48rem;\n    --breakpoint-lg: 64rem;\n    --breakpoint-xl: 80rem;\n    --breakpoint-2xl: 96rem;\n    --container-3xs: 16rem;\n    --container-2xs: 18rem;\n    --container-xs: 20rem;\n    --container-sm: 24rem;\n    --container-md: 28rem;\n    --container-lg: 32rem;\n    --container-xl: 36rem;\n    --container-2xl: 42rem;\n    --container-3xl: 48rem;\n    --container-4xl: 56rem;\n    --container-5xl: 64rem;\n    --container-6xl: 72rem;\n    --container-7xl: 80rem;\n    --text-xs: 0.75rem;\n    --text-xs--line-height: calc(1 / 0.75);\n    --text-sm: 0.875rem;\n    --text-sm--line-height: calc(1.25 / 0.875);\n    --text-base: 1rem;\n    --text-base--line-height: calc(1.5 / 1);\n    --text-lg: 1.125rem;\n    --text-lg--line-height: calc(1.75 / 1.125);\n    --text-xl: 1.25rem;\n    --text-xl--line-height: calc(1.75 / 1.25);\n    --text-2xl: 1.5rem;\n    --text-2xl--line-height: calc(2 / 1.5);\n    --text-3xl: 1.875rem;\n    --text-3xl--line-height: calc(2.25 / 1.875);\n    --text-4xl: 2.25rem;\n    --text-4xl--line-height: calc(2.5 / 2.25);\n    --text-5xl: 3rem;\n    --text-5xl--line-height: 1;\n    --text-6xl: 3.75rem;\n    --text-6xl--line-height: 1;\n    --text-7xl: 4.5rem;\n    --text-7xl--line-height: 1;\n    --text-8xl: 6rem;\n    --text-8xl--line-height: 1;\n    --text-9xl: 8rem;\n    --text-9xl--line-height: 1;\n    --font-weight-thin: 100;\n    --font-weight-extralight: 200;\n    --font-weight-light: 300;\n    --font-weight-normal: 400;\n    --font-weight-medium: 500;\n    --font-weight-semibold: 600;\n    --font-weight-bold: 700;\n    --font-weight-extrabold: 800;\n    --font-weight-black: 900;\n    --tracking-tighter: -0.05em;\n    --tracking-tight: -0.025em;\n    --tracking-normal: 0em;\n    --tracking-wide: 0.025em;\n    --tracking-wider: 0.05em;\n    --tracking-widest: 0.1em;\n    --leading-tight: 1.25;\n    --leading-snug: 1.375;\n    --leading-normal: 1.5;\n    --leading-relaxed: 1.625;\n    --leading-loose: 2;\n    --radius-xs: 0.125rem;\n    --radius-sm: 0.25rem;\n    --radius-md: 0.375rem;\n    --radius-lg: 0.5rem;\n    --radius-xl: 0.75rem;\n    --radius-2xl: 1rem;\n    --radius-3xl: 1.5rem;\n    --radius-4xl: 2rem;\n    --shadow-2xs: 0 1px rgb(0 0 0 / 0.05);\n    --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n    --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1),\n      0 2px 4px -2px rgb(0 0 0 / 0.1);\n    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),\n      0 4px 6px -4px rgb(0 0 0 / 0.1);\n    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1),\n      0 8px 10px -6px rgb(0 0 0 / 0.1);\n    --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);\n    --inset-shadow-2xs: inset 0 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-xs: inset 0 1px 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-sm: inset 0 2px 4px rgb(0 0 0 / 0.05);\n    --drop-shadow-xs: 0 1px 1px rgb(0 0 0 / 0.05);\n    --drop-shadow-sm: 0 1px 2px rgb(0 0 0 / 0.15);\n    --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);\n    --drop-shadow-lg: 0 4px 4px rgb(0 0 0 / 0.15);\n    --drop-shadow-xl: 0 9px 7px rgb(0 0 0 / 0.1);\n    --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);\n    --ease-in: cubic-bezier(0.4, 0, 1, 1);\n    --ease-out: cubic-bezier(0, 0, 0.2, 1);\n    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\n    --animate-spin: spin 1s linear infinite;\n    --animate-ping: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;\n    --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n    --animate-bounce: bounce 1s infinite;\n    --blur-xs: 4px;\n    --blur-sm: 8px;\n    --blur-md: 12px;\n    --blur-lg: 16px;\n    --blur-xl: 24px;\n    --blur-2xl: 40px;\n    --blur-3xl: 64px;\n    --perspective-dramatic: 100px;\n    --perspective-near: 300px;\n    --perspective-normal: 500px;\n    --perspective-midrange: 800px;\n    --perspective-distant: 1200px;\n    --aspect-video: 16 / 9;\n    --default-transition-duration: 150ms;\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    --default-font-family: var(--font-sans);\n    --default-font-feature-settings: var(--font-sans--font-feature-settings);\n    --default-font-variation-settings: var(\n      --font-sans--font-variation-settings\n    );\n    --default-mono-font-family: var(--font-mono);\n    --default-mono-font-feature-settings: var(\n      --font-mono--font-feature-settings\n    );\n    --default-mono-font-variation-settings: var(\n      --font-mono--font-variation-settings\n    );\n    --color-primary-tw: #2b80ff;\n    --color-light: #c3d5f7;\n    --color-bg-dark: #0a0a1a;\n    --color-bg-card: #1a1a2a;\n    --color-bg-hover: #2a2a3a;\n    --color-bg-active: #fff;\n    --color-border: #333;\n    --color-border-active: #5a5a7a;\n    --color-text-secondary: #aaa;\n  }\n}\n@layer base {\n  *, ::after, ::before, ::backdrop, ::file-selector-button {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n    border: 0 solid;\n  }\n  html, :host {\n    line-height: 1.5;\n    -webkit-text-size-adjust: 100%;\n    tab-size: 4;\n    font-family: var( --default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji" );\n    font-feature-settings: var(--default-font-feature-settings, normal);\n    font-variation-settings: var( --default-font-variation-settings, normal );\n    -webkit-tap-highlight-color: transparent;\n  }\n  body {\n    line-height: inherit;\n  }\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n  abbr:where([title]) {\n    -webkit-text-decoration: underline dotted;\n    text-decoration: underline dotted;\n  }\n  h1, h2, h3, h4, h5, h6 {\n    font-size: inherit;\n    font-weight: inherit;\n  }\n  a {\n    color: inherit;\n    -webkit-text-decoration: inherit;\n    text-decoration: inherit;\n  }\n  b, strong {\n    font-weight: bolder;\n  }\n  code, kbd, samp, pre {\n    font-family: var( --default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace );\n    font-feature-settings: var( --default-mono-font-feature-settings, normal );\n    font-variation-settings: var( --default-mono-font-variation-settings, normal );\n    font-size: 1em;\n  }\n  small {\n    font-size: 80%;\n  }\n  sub, sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n  sub {\n    bottom: -0.25em;\n  }\n  sup {\n    top: -0.5em;\n  }\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n  :-moz-focusring {\n    outline: auto;\n  }\n  progress {\n    vertical-align: baseline;\n  }\n  summary {\n    display: list-item;\n  }\n  ol, ul, menu {\n    list-style: none;\n  }\n  img, svg, video, canvas, audio, iframe, embed, object {\n    display: block;\n    vertical-align: middle;\n  }\n  img, video {\n    max-width: 100%;\n    height: auto;\n  }\n  button, input, select, optgroup, textarea, ::file-selector-button {\n    font: inherit;\n    font-feature-settings: inherit;\n    font-variation-settings: inherit;\n    letter-spacing: inherit;\n    color: inherit;\n    border-radius: 0;\n    background-color: transparent;\n    opacity: 1;\n  }\n  :where(select:is([multiple], [size])) optgroup {\n    font-weight: bolder;\n  }\n  :where(select:is([multiple], [size])) optgroup option {\n    padding-inline-start: 20px;\n  }\n  ::file-selector-button {\n    margin-inline-end: 4px;\n  }\n  ::placeholder {\n    opacity: 1;\n    color: color-mix(in oklab, currentColor 50%, transparent);\n  }\n  textarea {\n    resize: vertical;\n  }\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n  ::-webkit-date-and-time-value {\n    min-height: 1lh;\n    text-align: inherit;\n  }\n  ::-webkit-datetime-edit {\n    display: inline-flex;\n  }\n  ::-webkit-datetime-edit-fields-wrapper {\n    padding: 0;\n  }\n  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {\n    padding-block: 0;\n  }\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n  button, input:where([type="button"], [type="reset"], [type="submit"]), ::file-selector-button {\n    appearance: button;\n  }\n  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {\n    height: auto;\n  }\n  [hidden]:where(:not([hidden="until-found"])) {\n    display: none !important;\n  }\n}\n@layer utilities {\n  .pointer-events-none {\n    pointer-events: none;\n  }\n  .collapse {\n    visibility: collapse;\n  }\n  .visible {\n    visibility: visible;\n  }\n  .absolute {\n    position: absolute;\n  }\n  .fixed {\n    position: fixed;\n  }\n  .relative {\n    position: relative;\n  }\n  .static {\n    position: static;\n  }\n  .inset-0 {\n    inset: calc(var(--spacing) * 0);\n  }\n  .top-0 {\n    top: calc(var(--spacing) * 0);\n  }\n  .top-1\\\\/2 {\n    top: calc(1/2 * 100%);\n  }\n  .top-4 {\n    top: calc(var(--spacing) * 4);\n  }\n  .right-0 {\n    right: calc(var(--spacing) * 0);\n  }\n  .right-4 {\n    right: calc(var(--spacing) * 4);\n  }\n  .left-3 {\n    left: calc(var(--spacing) * 3);\n  }\n  .z-40 {\n    z-index: 40;\n  }\n  .z-50 {\n    z-index: 50;\n  }\n  .\\\\!container {\n    width: 100% !important;\n    @media (width >= 40rem) {\n      max-width: 40rem !important;\n    }\n    @media (width >= 48rem) {\n      max-width: 48rem !important;\n    }\n    @media (width >= 64rem) {\n      max-width: 64rem !important;\n    }\n    @media (width >= 80rem) {\n      max-width: 80rem !important;\n    }\n    @media (width >= 96rem) {\n      max-width: 96rem !important;\n    }\n  }\n  .container {\n    width: 100%;\n    @media (width >= 40rem) {\n      max-width: 40rem;\n    }\n    @media (width >= 48rem) {\n      max-width: 48rem;\n    }\n    @media (width >= 64rem) {\n      max-width: 64rem;\n    }\n    @media (width >= 80rem) {\n      max-width: 80rem;\n    }\n    @media (width >= 96rem) {\n      max-width: 96rem;\n    }\n  }\n  .m-0 {\n    margin: calc(var(--spacing) * 0);\n  }\n  .m-1 {\n    margin: calc(var(--spacing) * 1);\n  }\n  .mx-2 {\n    margin-inline: calc(var(--spacing) * 2);\n  }\n  .mx-auto {\n    margin-inline: auto;\n  }\n  .my-1 {\n    margin-block: calc(var(--spacing) * 1);\n  }\n  .my-8 {\n    margin-block: calc(var(--spacing) * 8);\n  }\n  .\\\\!mt-4 {\n    margin-top: calc(var(--spacing) * 4) !important;\n  }\n  .mt-2 {\n    margin-top: calc(var(--spacing) * 2);\n  }\n  .mt-3 {\n    margin-top: calc(var(--spacing) * 3);\n  }\n  .mt-4 {\n    margin-top: calc(var(--spacing) * 4);\n  }\n  .mt-6 {\n    margin-top: calc(var(--spacing) * 6);\n  }\n  .mt-8 {\n    margin-top: calc(var(--spacing) * 8);\n  }\n  .mr-4 {\n    margin-right: calc(var(--spacing) * 4);\n  }\n  .\\\\!mb-6 {\n    margin-bottom: calc(var(--spacing) * 6) !important;\n  }\n  .mb-1 {\n    margin-bottom: calc(var(--spacing) * 1);\n  }\n  .mb-1\\\\.5 {\n    margin-bottom: calc(var(--spacing) * 1.5);\n  }\n  .mb-2 {\n    margin-bottom: calc(var(--spacing) * 2);\n  }\n  .mb-2\\\\.5 {\n    margin-bottom: calc(var(--spacing) * 2.5);\n  }\n  .mb-3 {\n    margin-bottom: calc(var(--spacing) * 3);\n  }\n  .mb-4 {\n    margin-bottom: calc(var(--spacing) * 4);\n  }\n  .mb-6 {\n    margin-bottom: calc(var(--spacing) * 6);\n  }\n  .mb-8 {\n    margin-bottom: calc(var(--spacing) * 8);\n  }\n  .ml-2 {\n    margin-left: calc(var(--spacing) * 2);\n  }\n  .line-clamp-2 {\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 2;\n  }\n  .line-clamp-3 {\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 3;\n  }\n  .\\\\!flex {\n    display: flex !important;\n  }\n  .\\\\!hidden {\n    display: none !important;\n  }\n  .block {\n    display: block;\n  }\n  .contents {\n    display: contents;\n  }\n  .flex {\n    display: flex;\n  }\n  .grid {\n    display: grid;\n  }\n  .hidden {\n    display: none;\n  }\n  .inline-flex {\n    display: inline-flex;\n  }\n  .list-item {\n    display: list-item;\n  }\n  .table {\n    display: table;\n  }\n  .size-1 {\n    width: calc(var(--spacing) * 1);\n    height: calc(var(--spacing) * 1);\n  }\n  .\\\\!h-10 {\n    height: calc(var(--spacing) * 10) !important;\n  }\n  .h-1 {\n    height: calc(var(--spacing) * 1);\n  }\n  .h-2 {\n    height: calc(var(--spacing) * 2);\n  }\n  .h-4 {\n    height: calc(var(--spacing) * 4);\n  }\n  .h-5 {\n    height: calc(var(--spacing) * 5);\n  }\n  .h-6 {\n    height: calc(var(--spacing) * 6);\n  }\n  .h-8 {\n    height: calc(var(--spacing) * 8);\n  }\n  .h-10 {\n    height: calc(var(--spacing) * 10);\n  }\n  .h-12 {\n    height: calc(var(--spacing) * 12);\n  }\n  .h-20 {\n    height: calc(var(--spacing) * 20);\n  }\n  .h-48 {\n    height: calc(var(--spacing) * 48);\n  }\n  .h-56 {\n    height: calc(var(--spacing) * 56);\n  }\n  .h-\\\\[100px\\\\] {\n    height: 100px;\n  }\n  .h-\\\\[150px\\\\] {\n    height: 150px;\n  }\n  .h-\\\\[1rem\\\\] {\n    height: 1rem;\n  }\n  .h-\\\\[2\\\\.875rem\\\\] {\n    height: 2.875rem;\n  }\n  .h-full {\n    height: 100%;\n  }\n  .max-h-56 {\n    max-height: calc(var(--spacing) * 56);\n  }\n  .max-h-64 {\n    max-height: calc(var(--spacing) * 64);\n  }\n  .max-h-\\\\[300px\\\\] {\n    max-height: 300px;\n  }\n  .min-h-\\\\[20rem\\\\] {\n    min-height: 20rem;\n  }\n  .min-h-screen {\n    min-height: 100vh;\n  }\n  .\\\\!w-10 {\n    width: calc(var(--spacing) * 10) !important;\n  }\n  .w-1 {\n    width: calc(var(--spacing) * 1);\n  }\n  .w-1\\\\/4 {\n    width: calc(1/4 * 100%);\n  }\n  .w-4 {\n    width: calc(var(--spacing) * 4);\n  }\n  .w-5 {\n    width: calc(var(--spacing) * 5);\n  }\n  .w-6 {\n    width: calc(var(--spacing) * 6);\n  }\n  .w-8 {\n    width: calc(var(--spacing) * 8);\n  }\n  .w-10 {\n    width: calc(var(--spacing) * 10);\n  }\n  .w-12 {\n    width: calc(var(--spacing) * 12);\n  }\n  .w-20 {\n    width: calc(var(--spacing) * 20);\n  }\n  .w-\\\\[1\\\\.45456rem\\\\] {\n    width: 1.45456rem;\n  }\n  .w-\\\\[2\\\\.875rem\\\\] {\n    width: 2.875rem;\n  }\n  .w-\\\\[100px\\\\] {\n    width: 100px;\n  }\n  .w-full {\n    width: 100%;\n  }\n  .max-w-5xl {\n    max-width: var(--container-5xl);\n  }\n  .max-w-7xl {\n    max-width: var(--container-7xl);\n  }\n  .max-w-full {\n    max-width: 100%;\n  }\n  .max-w-md {\n    max-width: var(--container-md);\n  }\n  .flex-grow {\n    flex-grow: 1;\n  }\n  .border-collapse {\n    border-collapse: collapse;\n  }\n  .-translate-y-1\\\\/2 {\n    --tw-translate-y: calc(calc(1/2 * 100%) * -1);\n    translate: var(--tw-translate-x) var(--tw-translate-y);\n  }\n  .\\\\!transform {\n    transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y) !important;\n  }\n  .transform {\n    transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\n  }\n  .\\\\!cursor-not-allowed {\n    cursor: not-allowed !important;\n  }\n  .cursor-not-allowed {\n    cursor: not-allowed;\n  }\n  .cursor-pointer {\n    cursor: pointer;\n  }\n  .resize {\n    resize: both;\n  }\n  .resize-y {\n    resize: vertical;\n  }\n  .grid-cols-3 {\n    grid-template-columns: repeat(3, minmax(0, 1fr));\n  }\n  .grid-cols-\\\\[1fr_2fr_100px\\\\] {\n    grid-template-columns: 1fr 2fr 100px;\n  }\n  .flex-col {\n    flex-direction: column;\n  }\n  .flex-wrap {\n    flex-wrap: wrap;\n  }\n  .\\\\!items-center {\n    align-items: center !important;\n  }\n  .items-center {\n    align-items: center;\n  }\n  .\\\\!justify-center {\n    justify-content: center !important;\n  }\n  .justify-between {\n    justify-content: space-between;\n  }\n  .justify-center {\n    justify-content: center;\n  }\n  .\\\\!gap-2 {\n    gap: calc(var(--spacing) * 2) !important;\n  }\n  .gap-1 {\n    gap: calc(var(--spacing) * 1);\n  }\n  .gap-1\\\\.5 {\n    gap: calc(var(--spacing) * 1.5);\n  }\n  .gap-2 {\n    gap: calc(var(--spacing) * 2);\n  }\n  .gap-2\\\\.5 {\n    gap: calc(var(--spacing) * 2.5);\n  }\n  .gap-3 {\n    gap: calc(var(--spacing) * 3);\n  }\n  .gap-4 {\n    gap: calc(var(--spacing) * 4);\n  }\n  .gap-5 {\n    gap: calc(var(--spacing) * 5);\n  }\n  .gap-6 {\n    gap: calc(var(--spacing) * 6);\n  }\n  .gap-8 {\n    gap: calc(var(--spacing) * 8);\n  }\n  .space-y-1 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 1) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .space-y-2 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .space-y-4 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .space-y-6 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 6) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 6) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .self-start {\n    align-self: flex-start;\n  }\n  .overflow-auto {\n    overflow: auto;\n  }\n  .overflow-hidden {\n    overflow: hidden;\n  }\n  .overflow-y-auto {\n    overflow-y: auto;\n  }\n  .\\\\!rounded-full {\n    border-radius: calc(infinity * 1px) !important;\n  }\n  .rounded {\n    border-radius: 0.25rem;\n  }\n  .rounded-3xl {\n    border-radius: var(--radius-3xl);\n  }\n  .rounded-4xl {\n    border-radius: var(--radius-4xl);\n  }\n  .rounded-full {\n    border-radius: calc(infinity * 1px);\n  }\n  .rounded-lg {\n    border-radius: var(--radius-lg);\n  }\n  .rounded-md {\n    border-radius: var(--radius-md);\n  }\n  .rounded-xl {\n    border-radius: var(--radius-xl);\n  }\n  .rounded-l-md {\n    border-top-left-radius: var(--radius-md);\n    border-bottom-left-radius: var(--radius-md);\n  }\n  .rounded-r-md {\n    border-top-right-radius: var(--radius-md);\n    border-bottom-right-radius: var(--radius-md);\n  }\n  .\\\\!border {\n    border-style: var(--tw-border-style) !important;\n    border-width: 1px !important;\n  }\n  .border {\n    border-style: var(--tw-border-style);\n    border-width: 1px;\n  }\n  .border-0 {\n    border-style: var(--tw-border-style);\n    border-width: 0px;\n  }\n  .border-2 {\n    border-style: var(--tw-border-style);\n    border-width: 2px;\n  }\n  .border-t {\n    border-top-style: var(--tw-border-style);\n    border-top-width: 1px;\n  }\n  .border-t-2 {\n    border-top-style: var(--tw-border-style);\n    border-top-width: 2px;\n  }\n  .border-r-0 {\n    border-right-style: var(--tw-border-style);\n    border-right-width: 0px;\n  }\n  .border-b-2 {\n    border-bottom-style: var(--tw-border-style);\n    border-bottom-width: 2px;\n  }\n  .border-l-4 {\n    border-left-style: var(--tw-border-style);\n    border-left-width: 4px;\n  }\n  .border-dashed {\n    --tw-border-style: dashed;\n    border-style: dashed;\n  }\n  .border-none {\n    --tw-border-style: none;\n    border-style: none;\n  }\n  .\\\\!border-white {\n    border-color: var(--color-white) !important;\n  }\n  .border-\\\\[rgba\\\\(255\\\\,255\\\\,255\\\\,0\\\\.1\\\\)\\\\] {\n    border-color: rgba(255,255,255,0.1);\n  }\n  .border-\\\\[rgba\\\\(255\\\\,255\\\\,255\\\\,0\\\\.2\\\\)\\\\] {\n    border-color: rgba(255,255,255,0.2);\n  }\n  .border-\\\\[var\\\\(--color-border\\\\)\\\\] {\n    border-color: var(--color-border);\n  }\n  .border-\\\\[var\\\\(--color-border-active\\\\)\\\\] {\n    border-color: var(--color-border-active);\n  }\n  .border-blue-500 {\n    border-color: var(--color-blue-500);\n  }\n  .border-border {\n    border-color: var(--color-border);\n  }\n  .border-border-active {\n    border-color: var(--color-border-active);\n  }\n  .border-current {\n    border-color: currentColor;\n  }\n  .border-white {\n    border-color: var(--color-white);\n  }\n  .border-white\\\\/20 {\n    border-color: color-mix(in oklab, var(--color-white) 20%, transparent);\n  }\n  .\\\\!bg-\\\\[var\\\\(--color-bg-active\\\\)\\\\] {\n    background-color: var(--color-bg-active) !important;\n  }\n  .\\\\!bg-transparent {\n    background-color: transparent !important;\n  }\n  .\\\\!bg-white {\n    background-color: var(--color-white) !important;\n  }\n  .bg-\\\\[\\\\#051023\\\\] {\n    background-color: #051023;\n  }\n  .bg-\\\\[\\\\#051023\\\\]\\\\/20 {\n    background-color: color-mix(in oklab, #051023 20%, transparent);\n  }\n  .bg-\\\\[\\\\#f6f6f6\\\\] {\n    background-color: #f6f6f6;\n  }\n  .bg-\\\\[rgba\\\\(255\\\\,255\\\\,255\\\\,0\\\\.1\\\\)\\\\] {\n    background-color: rgba(255,255,255,0.1);\n  }\n  .bg-\\\\[rgba\\\\(255\\\\,255\\\\,255\\\\,0\\\\.15\\\\)\\\\] {\n    background-color: rgba(255,255,255,0.15);\n  }\n  .bg-\\\\[var\\\\(--color-bg-active\\\\)\\\\] {\n    background-color: var(--color-bg-active);\n  }\n  .bg-\\\\[var\\\\(--color-bg-card\\\\)\\\\] {\n    background-color: var(--color-bg-card);\n  }\n  .bg-\\\\[var\\\\(--color-bg-dark\\\\)\\\\] {\n    background-color: var(--color-bg-dark);\n  }\n  .bg-black {\n    background-color: var(--color-black);\n  }\n  .bg-black\\\\/20 {\n    background-color: color-mix(in oklab, var(--color-black) 20%, transparent);\n  }\n  .bg-blue-500 {\n    background-color: var(--color-blue-500);\n  }\n  .bg-blue-500\\\\/20 {\n    background-color: color-mix(in oklab, var(--color-blue-500) 20%, transparent);\n  }\n  .bg-blue-600 {\n    background-color: var(--color-blue-600);\n  }\n  .bg-primary-tw {\n    background-color: var(--color-primary-tw);\n  }\n  .bg-red-500 {\n    background-color: var(--color-red-500);\n  }\n  .bg-transparent {\n    background-color: transparent;\n  }\n  .bg-white {\n    background-color: var(--color-white);\n  }\n  .bg-white\\\\/5 {\n    background-color: color-mix(in oklab, var(--color-white) 5%, transparent);\n  }\n  .bg-white\\\\/10 {\n    background-color: color-mix(in oklab, var(--color-white) 10%, transparent);\n  }\n  .bg-white\\\\/20 {\n    background-color: color-mix(in oklab, var(--color-white) 20%, transparent);\n  }\n  .bg-gradient-to-b {\n    --tw-gradient-position: to bottom in oklab;\n    background-image: linear-gradient(var(--tw-gradient-stops));\n  }\n  .bg-gradient-to-r {\n    --tw-gradient-position: to right in oklab;\n    background-image: linear-gradient(var(--tw-gradient-stops));\n  }\n  .from-\\\\[rgba\\\\(30\\\\,30\\\\,60\\\\,0\\\\.7\\\\)\\\\] {\n    --tw-gradient-from: rgba(30,30,60,0.7);\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\n  }\n  .from-\\\\[var\\\\(--color-light\\\\)\\\\] {\n    --tw-gradient-from: var(--color-light);\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\n  }\n  .to-\\\\[rgba\\\\(20\\\\,20\\\\,40\\\\,0\\\\.7\\\\)\\\\] {\n    --tw-gradient-to: rgba(20,20,40,0.7);\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\n  }\n  .to-white {\n    --tw-gradient-to: var(--color-white);\n    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));\n  }\n  .bg-clip-text {\n    background-clip: text;\n  }\n  .object-contain {\n    object-fit: contain;\n  }\n  .object-cover {\n    object-fit: cover;\n  }\n  .\\\\!p-2 {\n    padding: calc(var(--spacing) * 2) !important;\n  }\n  .p-1 {\n    padding: calc(var(--spacing) * 1);\n  }\n  .p-3 {\n    padding: calc(var(--spacing) * 3);\n  }\n  .p-4 {\n    padding: calc(var(--spacing) * 4);\n  }\n  .p-5 {\n    padding: calc(var(--spacing) * 5);\n  }\n  .p-6 {\n    padding: calc(var(--spacing) * 6);\n  }\n  .p-8 {\n    padding: calc(var(--spacing) * 8);\n  }\n  .p-12 {\n    padding: calc(var(--spacing) * 12);\n  }\n  .px-2 {\n    padding-inline: calc(var(--spacing) * 2);\n  }\n  .px-3 {\n    padding-inline: calc(var(--spacing) * 3);\n  }\n  .px-4 {\n    padding-inline: calc(var(--spacing) * 4);\n  }\n  .px-5 {\n    padding-inline: calc(var(--spacing) * 5);\n  }\n  .px-6 {\n    padding-inline: calc(var(--spacing) * 6);\n  }\n  .py-1 {\n    padding-block: calc(var(--spacing) * 1);\n  }\n  .py-1\\\\.5 {\n    padding-block: calc(var(--spacing) * 1.5);\n  }\n  .py-2 {\n    padding-block: calc(var(--spacing) * 2);\n  }\n  .py-3 {\n    padding-block: calc(var(--spacing) * 3);\n  }\n  .py-8 {\n    padding-block: calc(var(--spacing) * 8);\n  }\n  .py-12 {\n    padding-block: calc(var(--spacing) * 12);\n  }\n  .py-\\\\[0\\\\.125rem\\\\] {\n    padding-block: 0.125rem;\n  }\n  .pt-4 {\n    padding-top: calc(var(--spacing) * 4);\n  }\n  .pr-10 {\n    padding-right: calc(var(--spacing) * 10);\n  }\n  .pl-10 {\n    padding-left: calc(var(--spacing) * 10);\n  }\n  .text-center {\n    text-align: center;\n  }\n  .font-mono {\n    font-family: var(--font-mono);\n  }\n  .\\\\!text-sm {\n    font-size: var(--text-sm) !important;\n    line-height: var(--tw-leading, var(--text-sm--line-height)) !important;\n  }\n  .text-2xl {\n    font-size: var(--text-2xl);\n    line-height: var(--tw-leading, var(--text-2xl--line-height));\n  }\n  .text-3xl {\n    font-size: var(--text-3xl);\n    line-height: var(--tw-leading, var(--text-3xl--line-height));\n  }\n  .text-7xl {\n    font-size: var(--text-7xl);\n    line-height: var(--tw-leading, var(--text-7xl--line-height));\n  }\n  .text-base {\n    font-size: var(--text-base);\n    line-height: var(--tw-leading, var(--text-base--line-height));\n  }\n  .text-lg {\n    font-size: var(--text-lg);\n    line-height: var(--tw-leading, var(--text-lg--line-height));\n  }\n  .text-sm {\n    font-size: var(--text-sm);\n    line-height: var(--tw-leading, var(--text-sm--line-height));\n  }\n  .text-xl {\n    font-size: var(--text-xl);\n    line-height: var(--tw-leading, var(--text-xl--line-height));\n  }\n  .text-xs {\n    font-size: var(--text-xs);\n    line-height: var(--tw-leading, var(--text-xs--line-height));\n  }\n  .text-\\\\[0\\\\.875rem\\\\] {\n    font-size: 0.875rem;\n  }\n  .text-\\\\[1\\\\.25rem\\\\] {\n    font-size: 1.25rem;\n  }\n  .text-\\\\[2rem\\\\] {\n    font-size: 2rem;\n  }\n  .\\\\!font-bold {\n    --tw-font-weight: var(--font-weight-bold) !important;\n    font-weight: var(--font-weight-bold) !important;\n  }\n  .font-bold {\n    --tw-font-weight: var(--font-weight-bold);\n    font-weight: var(--font-weight-bold);\n  }\n  .font-medium {\n    --tw-font-weight: var(--font-weight-medium);\n    font-weight: var(--font-weight-medium);\n  }\n  .font-semibold {\n    --tw-font-weight: var(--font-weight-semibold);\n    font-weight: var(--font-weight-semibold);\n  }\n  .font-thin {\n    --tw-font-weight: var(--font-weight-thin);\n    font-weight: var(--font-weight-thin);\n  }\n  .break-all {\n    word-break: break-all;\n  }\n  .text-ellipsis {\n    text-overflow: ellipsis;\n  }\n  .whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n  .\\\\!text-black {\n    color: var(--color-black) !important;\n  }\n  .\\\\!text-light {\n    color: var(--color-light) !important;\n  }\n  .\\\\!text-primary-tw {\n    color: var(--color-primary-tw) !important;\n  }\n  .\\\\!text-white {\n    color: var(--color-white) !important;\n  }\n  .\\\\!text-white\\\\/80 {\n    color: color-mix(in oklab, var(--color-white) 80%, transparent) !important;\n  }\n  .text-\\\\[\\\\#C3D5F7\\\\] {\n    color: #C3D5F7;\n  }\n  .text-\\\\[var\\\\(--color-light\\\\)\\\\] {\n    color: var(--color-light);\n  }\n  .text-\\\\[var\\\\(--color-primary-tw\\\\)\\\\] {\n    color: var(--color-primary-tw);\n  }\n  .text-\\\\[var\\\\(--color-text-secondary\\\\)\\\\] {\n    color: var(--color-text-secondary);\n  }\n  .text-black {\n    color: var(--color-black);\n  }\n  .text-blue-400 {\n    color: var(--color-blue-400);\n  }\n  .text-blue-500 {\n    color: var(--color-blue-500);\n  }\n  .text-gray-100 {\n    color: var(--color-gray-100);\n  }\n  .text-gray-200 {\n    color: var(--color-gray-200);\n  }\n  .text-gray-500 {\n    color: var(--color-gray-500);\n  }\n  .text-light {\n    color: var(--color-light);\n  }\n  .text-red-400 {\n    color: var(--color-red-400);\n  }\n  .text-red-500 {\n    color: var(--color-red-500);\n  }\n  .text-red-600 {\n    color: var(--color-red-600);\n  }\n  .text-text-secondary {\n    color: var(--color-text-secondary);\n  }\n  .text-transparent {\n    color: transparent;\n  }\n  .text-white {\n    color: var(--color-white);\n  }\n  .text-white\\\\/60 {\n    color: color-mix(in oklab, var(--color-white) 60%, transparent);\n  }\n  .text-white\\\\/80 {\n    color: color-mix(in oklab, var(--color-white) 80%, transparent);\n  }\n  .lowercase {\n    text-transform: lowercase;\n  }\n  .italic {\n    font-style: italic;\n  }\n  .underline {\n    text-decoration-line: underline;\n  }\n  .\\\\!opacity-50 {\n    opacity: 50% !important;\n  }\n  .opacity-0 {\n    opacity: 0%;\n  }\n  .shadow {\n    --tw-shadow: 0 1px 3px 0 var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 1px 2px -1px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n  .shadow-lg {\n    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n  .outline {\n    outline-style: var(--tw-outline-style);\n    outline-width: 1px;\n  }\n  .blur {\n    --tw-blur: blur(8px);\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .drop-shadow {\n    --tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / 0.1)) drop-shadow( 0 1px 1px rgb(0 0 0 / 0.06));\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .filter {\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .backdrop-blur-\\\\[2px\\\\] {\n    --tw-backdrop-blur: blur(2px);\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .backdrop-blur-\\\\[10px\\\\] {\n    --tw-backdrop-blur: blur(10px);\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .backdrop-blur-xl {\n    --tw-backdrop-blur: blur(var(--blur-xl));\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .backdrop-filter {\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .\\\\!transition-colors {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to !important;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function)) !important;\n    transition-duration: var(--tw-duration, var(--default-transition-duration)) !important;\n  }\n  .transition {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .transition-all {\n    transition-property: all;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .transition-colors {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .\\\\!duration-300 {\n    --tw-duration: 300ms !important;\n    transition-duration: 300ms !important;\n  }\n  .duration-200 {\n    --tw-duration: 200ms;\n    transition-duration: 200ms;\n  }\n  .duration-300 {\n    --tw-duration: 300ms;\n    transition-duration: 300ms;\n  }\n  .ease-in {\n    --tw-ease: var(--ease-in);\n    transition-timing-function: var(--ease-in);\n  }\n  .ease-in-out {\n    --tw-ease: var(--ease-in-out);\n    transition-timing-function: var(--ease-in-out);\n  }\n  .ease-out {\n    --tw-ease: var(--ease-out);\n    transition-timing-function: var(--ease-out);\n  }\n  .placeholder\\\\:text-white\\\\/40 {\n    &::placeholder {\n      color: color-mix(in oklab, var(--color-white) 40%, transparent);\n    }\n  }\n  .hover\\\\:-translate-y-0\\\\.5 {\n    &:hover {\n      @media (hover: hover) {\n        --tw-translate-y: calc(var(--spacing) * -0.5);\n        translate: var(--tw-translate-x) var(--tw-translate-y);\n      }\n    }\n  }\n  .hover\\\\:-translate-y-1\\\\.5 {\n    &:hover {\n      @media (hover: hover) {\n        --tw-translate-y: calc(var(--spacing) * -1.5);\n        translate: var(--tw-translate-x) var(--tw-translate-y);\n      }\n    }\n  }\n  .hover\\\\:transform {\n    &:hover {\n      @media (hover: hover) {\n        transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\n      }\n    }\n  }\n  .hover\\\\:\\\\!bg-transparent {\n    &:hover {\n      @media (hover: hover) {\n        background-color: transparent !important;\n      }\n    }\n  }\n  .hover\\\\:\\\\!bg-white\\\\/10 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: color-mix(in oklab, var(--color-white) 10%, transparent) !important;\n      }\n    }\n  }\n  .hover\\\\:bg-\\\\[rgba\\\\(255\\\\,255\\\\,255\\\\,0\\\\.1\\\\)\\\\] {\n    &:hover {\n      @media (hover: hover) {\n        background-color: rgba(255,255,255,0.1);\n      }\n    }\n  }\n  .hover\\\\:bg-\\\\[var\\\\(--color-bg-hover\\\\)\\\\] {\n    &:hover {\n      @media (hover: hover) {\n        background-color: var(--color-bg-hover);\n      }\n    }\n  }\n  .hover\\\\:bg-blue-700 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: var(--color-blue-700);\n      }\n    }\n  }\n  .hover\\\\:bg-red-500\\\\/10 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: color-mix(in oklab, var(--color-red-500) 10%, transparent);\n      }\n    }\n  }\n  .hover\\\\:bg-white\\\\/10 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: color-mix(in oklab, var(--color-white) 10%, transparent);\n      }\n    }\n  }\n  .hover\\\\:\\\\!text-white {\n    &:hover {\n      @media (hover: hover) {\n        color: var(--color-white) !important;\n      }\n    }\n  }\n  .hover\\\\:text-blue-300 {\n    &:hover {\n      @media (hover: hover) {\n        color: var(--color-blue-300);\n      }\n    }\n  }\n  .hover\\\\:text-gray-200 {\n    &:hover {\n      @media (hover: hover) {\n        color: var(--color-gray-200);\n      }\n    }\n  }\n  .hover\\\\:opacity-80 {\n    &:hover {\n      @media (hover: hover) {\n        opacity: 80%;\n      }\n    }\n  }\n  .hover\\\\:shadow-lg {\n    &:hover {\n      @media (hover: hover) {\n        --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\n        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n      }\n    }\n  }\n  .focus\\\\:border-blue-400 {\n    &:focus {\n      border-color: var(--color-blue-400);\n    }\n  }\n  .focus\\\\:ring-2 {\n    &:focus {\n      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentColor);\n      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n    }\n  }\n  .focus\\\\:ring-\\\\[\\\\#447BF4\\\\] {\n    &:focus {\n      --tw-ring-color: #447BF4;\n    }\n  }\n  .focus\\\\:outline-none {\n    &:focus {\n      --tw-outline-style: none;\n      outline-style: none;\n    }\n  }\n  .disabled\\\\:cursor-not-allowed {\n    &:disabled {\n      cursor: not-allowed;\n    }\n  }\n  .disabled\\\\:opacity-50 {\n    &:disabled {\n      opacity: 50%;\n    }\n  }\n  .sm\\\\:grid-cols-1 {\n    @media (width >= 40rem) {\n      grid-template-columns: repeat(1, minmax(0, 1fr));\n    }\n  }\n  .md\\\\:order-first {\n    @media (width >= 48rem) {\n      order: calc(-infinity);\n    }\n  }\n  .md\\\\:h-\\\\[150px\\\\] {\n    @media (width >= 48rem) {\n      height: 150px;\n    }\n  }\n  .md\\\\:w-full {\n    @media (width >= 48rem) {\n      width: 100%;\n    }\n  }\n  .md\\\\:grid-cols-1 {\n    @media (width >= 48rem) {\n      grid-template-columns: repeat(1, minmax(0, 1fr));\n    }\n  }\n  .md\\\\:grid-cols-2 {\n    @media (width >= 48rem) {\n      grid-template-columns: repeat(2, minmax(0, 1fr));\n    }\n  }\n  .md\\\\:grid-rows-\\\\[auto_auto_auto\\\\] {\n    @media (width >= 48rem) {\n      grid-template-rows: auto auto auto;\n    }\n  }\n}\n@layer base {\n  :root {\n    --tw-important:   !important;\n  }\n}\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0;\n  }\n}\n@keyframes pulse {\n  50% {\n    opacity: 0.5;\n  }\n}\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8, 0, 1, 1);\n  }\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  }\n}\n@property --tw-translate-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-translate-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-translate-z {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-rotate-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateX(0);\n}\n@property --tw-rotate-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateY(0);\n}\n@property --tw-rotate-z {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateZ(0);\n}\n@property --tw-skew-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: skewX(0);\n}\n@property --tw-skew-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: skewY(0);\n}\n@property --tw-space-y-reverse {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-border-style {\n  syntax: "*";\n  inherits: false;\n  initial-value: solid;\n}\n@property --tw-gradient-position {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-gradient-from {\n  syntax: "<color>";\n  inherits: false;\n  initial-value: #0000;\n}\n@property --tw-gradient-via {\n  syntax: "<color>";\n  inherits: false;\n  initial-value: #0000;\n}\n@property --tw-gradient-to {\n  syntax: "<color>";\n  inherits: false;\n  initial-value: #0000;\n}\n@property --tw-gradient-stops {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-gradient-via-stops {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-gradient-from-position {\n  syntax: "<length-percentage>";\n  inherits: false;\n  initial-value: 0%;\n}\n@property --tw-gradient-via-position {\n  syntax: "<length-percentage>";\n  inherits: false;\n  initial-value: 50%;\n}\n@property --tw-gradient-to-position {\n  syntax: "<length-percentage>";\n  inherits: false;\n  initial-value: 100%;\n}\n@property --tw-font-weight {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-shadow-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-inset-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-inset-shadow-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ring-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ring-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-inset-ring-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-inset-ring-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-ring-inset {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ring-offset-width {\n  syntax: "<length>";\n  inherits: false;\n  initial-value: 0px;\n}\n@property --tw-ring-offset-color {\n  syntax: "*";\n  inherits: false;\n  initial-value: #fff;\n}\n@property --tw-ring-offset-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-outline-style {\n  syntax: "*";\n  inherits: false;\n  initial-value: solid;\n}\n@property --tw-blur {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-brightness {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-contrast {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-grayscale {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-hue-rotate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-invert {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-opacity {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-saturate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-sepia {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-blur {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-brightness {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-contrast {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-grayscale {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-hue-rotate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-invert {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-opacity {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-saturate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-sepia {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-duration {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ease {\n  syntax: "*";\n  inherits: false;\n}\n`, "",{"version":3,"sources":["webpack://./src/styles.css"],"names":[],"mappings":"AAAA,gEAmBA;AAnBA,yCAmBA;AAnBA;EAAA;IAAA;6DAmBA;IAnBA,yEAmBA;IAnBA;iDAmBA;IAnBA,wCAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,2CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,4CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,2CAmBA;IAnBA,0CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,4CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,+CAmBA;IAnBA,+CAmBA;IAnBA,6CAmBA;IAnBA,+CAmBA;IAnBA,+CAmBA;IAnBA,+CAmBA;IAnBA,8CAmBA;IAnBA,+CAmBA;IAnBA,0CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,0CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,2CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,yCAmBA;IAnBA,2CAmBA;IAnBA,2CAmBA;IAnBA,2CAmBA;IAnBA,0CAmBA;IAnBA,2CAmBA;IAnBA,2CAmBA;IAnBA,yCAmBA;IAnBA,yCAmBA;IAnBA,0CAmBA;IAnBA,2CAmBA;IAnBA,0CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,4CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,8CAmBA;IAnBA,+CAmBA;IAnBA,8CAmBA;IAnBA,+CAmBA;IAnBA,6CAmBA;IAnBA,8CAmBA;IAnBA,+CAmBA;IAnBA,+CAmBA;IAnBA,+CAmBA;IAnBA,8CAmBA;IAnBA,+CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,2CAmBA;IAnBA,4CAmBA;IAnBA,4CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,0CAmBA;IAnBA,yCAmBA;IAnBA,2CAmBA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;EAnBA,eAmBA;EAnBA,oBAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA;AAnBA;EAAA,WAmBA;EAnBA,eAmBA;AAAA","sourcesContent":["@import \\"tailwindcss\\";\\n\\n@theme {\\n  --color-primary-tw: #2b80ff;\\n  --color-light: #c3d5f7;\\n  --color-bg-dark: #0a0a1a;\\n  --color-bg-card: #1a1a2a;\\n  --color-bg-hover: #2a2a3a;\\n  --color-bg-active: #fff;\\n  --color-border: #333;\\n  --color-border-active: #5a5a7a;\\n  --color-text-secondary: #aaa;\\n}\\n\\n@layer base {\\n  :root {\\n    --tw-important: !important;\\n  }\\n}\\n"],"sourceRoot":""}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUMwRztBQUNqQjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHdGQUF3RixhQUFhLE1BQU0sS0FBSyxLQUFLLE9BQU8sYUFBYSxNQUFNLE9BQU8sYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLE1BQU0sT0FBTyxNQUFNLE9BQU8sTUFBTSxPQUFPLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxZQUFZLFlBQVksWUFBWSxZQUFZLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxNQUFNLGFBQWEsT0FBTyxNQUFNLE9BQU8sTUFBTSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksWUFBWSxZQUFZLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsYUFBYSxhQUFhLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxhQUFhLGFBQWEsYUFBYSxZQUFZLGFBQWEsYUFBYSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLGFBQWEsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssS0FBSyxNQUFNLFdBQVcsTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxXQUFXLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLGFBQWEsYUFBYSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksYUFBYSxhQUFhLEtBQUssS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sWUFBWSxLQUFLLE1BQU0sV0FBVyxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFlBQVksS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksYUFBYSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLGFBQWEsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFlBQVksS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxZQUFZLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssWUFBWSxhQUFhLEtBQUssS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxhQUFhLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksYUFBYSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssS0FBSyxNQUFNLEtBQUssV0FBVyxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxLQUFLLEtBQUssTUFBTSxLQUFLLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxZQUFZLFlBQVksS0FBSyxLQUFLLE1BQU0sS0FBSyxXQUFXLEtBQUssS0FBSyxNQUFNLEtBQUssWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLGFBQWEsS0FBSyxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sWUFBWSxZQUFZLGFBQWEsS0FBSyxNQUFNLFlBQVksWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFlBQVksWUFBWSxhQUFhLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxZQUFZLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLGFBQWEsS0FBSyxNQUFNLFdBQVcsWUFBWSxhQUFhLEtBQUssTUFBTSxXQUFXLFlBQVksYUFBYSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNLFdBQVcsWUFBWSxLQUFLLE1BQU0sV0FBVyxZQUFZLEtBQUssTUFBTSxXQUFXLFlBQVksaURBQWlELFlBQVksZ0NBQWdDLDJCQUEyQiw2QkFBNkIsNkJBQTZCLDhCQUE4Qiw0QkFBNEIseUJBQXlCLG1DQUFtQyxpQ0FBaUMsR0FBRyxpQkFBaUIsV0FBVyxpQ0FBaUMsS0FBSyxHQUFHLHFCQUFxQjtBQUMzbGpCO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL3N0eWxlcy5jc3M/MTRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLyohIHRhaWx3aW5kY3NzIHY0LjAuMiB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20gKi9cbkBsYXllciB0aGVtZSwgYmFzZSwgY29tcG9uZW50cywgdXRpbGl0aWVzO1xuQGxheWVyIHRoZW1lIHtcbiAgOnJvb3QsIDpob3N0IHtcbiAgICAtLWZvbnQtc2FuczogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsXG4gICAgICBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiO1xuICAgIC0tZm9udC1zZXJpZjogdWktc2VyaWYsIEdlb3JnaWEsIENhbWJyaWEsIFwiVGltZXMgTmV3IFJvbWFuXCIsIFRpbWVzLCBzZXJpZjtcbiAgICAtLWZvbnQtbW9ubzogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsXG4gICAgICBcIkxpYmVyYXRpb24gTW9ub1wiLCBcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZTtcbiAgICAtLWNvbG9yLXJlZC01MDogb2tsY2goMC45NzEgMC4wMTMgMTcuMzgpO1xuICAgIC0tY29sb3ItcmVkLTEwMDogb2tsY2goMC45MzYgMC4wMzIgMTcuNzE3KTtcbiAgICAtLWNvbG9yLXJlZC0yMDA6IG9rbGNoKDAuODg1IDAuMDYyIDE4LjMzNCk7XG4gICAgLS1jb2xvci1yZWQtMzAwOiBva2xjaCgwLjgwOCAwLjExNCAxOS41NzEpO1xuICAgIC0tY29sb3ItcmVkLTQwMDogb2tsY2goMC43MDQgMC4xOTEgMjIuMjE2KTtcbiAgICAtLWNvbG9yLXJlZC01MDA6IG9rbGNoKDAuNjM3IDAuMjM3IDI1LjMzMSk7XG4gICAgLS1jb2xvci1yZWQtNjAwOiBva2xjaCgwLjU3NyAwLjI0NSAyNy4zMjUpO1xuICAgIC0tY29sb3ItcmVkLTcwMDogb2tsY2goMC41MDUgMC4yMTMgMjcuNTE4KTtcbiAgICAtLWNvbG9yLXJlZC04MDA6IG9rbGNoKDAuNDQ0IDAuMTc3IDI2Ljg5OSk7XG4gICAgLS1jb2xvci1yZWQtOTAwOiBva2xjaCgwLjM5NiAwLjE0MSAyNS43MjMpO1xuICAgIC0tY29sb3ItcmVkLTk1MDogb2tsY2goMC4yNTggMC4wOTIgMjYuMDQyKTtcbiAgICAtLWNvbG9yLW9yYW5nZS01MDogb2tsY2goMC45OCAwLjAxNiA3My42ODQpO1xuICAgIC0tY29sb3Itb3JhbmdlLTEwMDogb2tsY2goMC45NTQgMC4wMzggNzUuMTY0KTtcbiAgICAtLWNvbG9yLW9yYW5nZS0yMDA6IG9rbGNoKDAuOTAxIDAuMDc2IDcwLjY5Nyk7XG4gICAgLS1jb2xvci1vcmFuZ2UtMzAwOiBva2xjaCgwLjgzNyAwLjEyOCA2Ni4yOSk7XG4gICAgLS1jb2xvci1vcmFuZ2UtNDAwOiBva2xjaCgwLjc1IDAuMTgzIDU1LjkzNCk7XG4gICAgLS1jb2xvci1vcmFuZ2UtNTAwOiBva2xjaCgwLjcwNSAwLjIxMyA0Ny42MDQpO1xuICAgIC0tY29sb3Itb3JhbmdlLTYwMDogb2tsY2goMC42NDYgMC4yMjIgNDEuMTE2KTtcbiAgICAtLWNvbG9yLW9yYW5nZS03MDA6IG9rbGNoKDAuNTUzIDAuMTk1IDM4LjQwMik7XG4gICAgLS1jb2xvci1vcmFuZ2UtODAwOiBva2xjaCgwLjQ3IDAuMTU3IDM3LjMwNCk7XG4gICAgLS1jb2xvci1vcmFuZ2UtOTAwOiBva2xjaCgwLjQwOCAwLjEyMyAzOC4xNzIpO1xuICAgIC0tY29sb3Itb3JhbmdlLTk1MDogb2tsY2goMC4yNjYgMC4wNzkgMzYuMjU5KTtcbiAgICAtLWNvbG9yLWFtYmVyLTUwOiBva2xjaCgwLjk4NyAwLjAyMiA5NS4yNzcpO1xuICAgIC0tY29sb3ItYW1iZXItMTAwOiBva2xjaCgwLjk2MiAwLjA1OSA5NS42MTcpO1xuICAgIC0tY29sb3ItYW1iZXItMjAwOiBva2xjaCgwLjkyNCAwLjEyIDk1Ljc0Nik7XG4gICAgLS1jb2xvci1hbWJlci0zMDA6IG9rbGNoKDAuODc5IDAuMTY5IDkxLjYwNSk7XG4gICAgLS1jb2xvci1hbWJlci00MDA6IG9rbGNoKDAuODI4IDAuMTg5IDg0LjQyOSk7XG4gICAgLS1jb2xvci1hbWJlci01MDA6IG9rbGNoKDAuNzY5IDAuMTg4IDcwLjA4KTtcbiAgICAtLWNvbG9yLWFtYmVyLTYwMDogb2tsY2goMC42NjYgMC4xNzkgNTguMzE4KTtcbiAgICAtLWNvbG9yLWFtYmVyLTcwMDogb2tsY2goMC41NTUgMC4xNjMgNDguOTk4KTtcbiAgICAtLWNvbG9yLWFtYmVyLTgwMDogb2tsY2goMC40NzMgMC4xMzcgNDYuMjAxKTtcbiAgICAtLWNvbG9yLWFtYmVyLTkwMDogb2tsY2goMC40MTQgMC4xMTIgNDUuOTA0KTtcbiAgICAtLWNvbG9yLWFtYmVyLTk1MDogb2tsY2goMC4yNzkgMC4wNzcgNDUuNjM1KTtcbiAgICAtLWNvbG9yLXllbGxvdy01MDogb2tsY2goMC45ODcgMC4wMjYgMTAyLjIxMik7XG4gICAgLS1jb2xvci15ZWxsb3ctMTAwOiBva2xjaCgwLjk3MyAwLjA3MSAxMDMuMTkzKTtcbiAgICAtLWNvbG9yLXllbGxvdy0yMDA6IG9rbGNoKDAuOTQ1IDAuMTI5IDEwMS41NCk7XG4gICAgLS1jb2xvci15ZWxsb3ctMzAwOiBva2xjaCgwLjkwNSAwLjE4MiA5OC4xMTEpO1xuICAgIC0tY29sb3IteWVsbG93LTQwMDogb2tsY2goMC44NTIgMC4xOTkgOTEuOTM2KTtcbiAgICAtLWNvbG9yLXllbGxvdy01MDA6IG9rbGNoKDAuNzk1IDAuMTg0IDg2LjA0Nyk7XG4gICAgLS1jb2xvci15ZWxsb3ctNjAwOiBva2xjaCgwLjY4MSAwLjE2MiA3NS44MzQpO1xuICAgIC0tY29sb3IteWVsbG93LTcwMDogb2tsY2goMC41NTQgMC4xMzUgNjYuNDQyKTtcbiAgICAtLWNvbG9yLXllbGxvdy04MDA6IG9rbGNoKDAuNDc2IDAuMTE0IDYxLjkwNyk7XG4gICAgLS1jb2xvci15ZWxsb3ctOTAwOiBva2xjaCgwLjQyMSAwLjA5NSA1Ny43MDgpO1xuICAgIC0tY29sb3IteWVsbG93LTk1MDogb2tsY2goMC4yODYgMC4wNjYgNTMuODEzKTtcbiAgICAtLWNvbG9yLWxpbWUtNTA6IG9rbGNoKDAuOTg2IDAuMDMxIDEyMC43NTcpO1xuICAgIC0tY29sb3ItbGltZS0xMDA6IG9rbGNoKDAuOTY3IDAuMDY3IDEyMi4zMjgpO1xuICAgIC0tY29sb3ItbGltZS0yMDA6IG9rbGNoKDAuOTM4IDAuMTI3IDEyNC4zMjEpO1xuICAgIC0tY29sb3ItbGltZS0zMDA6IG9rbGNoKDAuODk3IDAuMTk2IDEyNi42NjUpO1xuICAgIC0tY29sb3ItbGltZS00MDA6IG9rbGNoKDAuODQxIDAuMjM4IDEyOC44NSk7XG4gICAgLS1jb2xvci1saW1lLTUwMDogb2tsY2goMC43NjggMC4yMzMgMTMwLjg1KTtcbiAgICAtLWNvbG9yLWxpbWUtNjAwOiBva2xjaCgwLjY0OCAwLjIgMTMxLjY4NCk7XG4gICAgLS1jb2xvci1saW1lLTcwMDogb2tsY2goMC41MzIgMC4xNTcgMTMxLjU4OSk7XG4gICAgLS1jb2xvci1saW1lLTgwMDogb2tsY2goMC40NTMgMC4xMjQgMTMwLjkzMyk7XG4gICAgLS1jb2xvci1saW1lLTkwMDogb2tsY2goMC40MDUgMC4xMDEgMTMxLjA2Myk7XG4gICAgLS1jb2xvci1saW1lLTk1MDogb2tsY2goMC4yNzQgMC4wNzIgMTMyLjEwOSk7XG4gICAgLS1jb2xvci1ncmVlbi01MDogb2tsY2goMC45ODIgMC4wMTggMTU1LjgyNik7XG4gICAgLS1jb2xvci1ncmVlbi0xMDA6IG9rbGNoKDAuOTYyIDAuMDQ0IDE1Ni43NDMpO1xuICAgIC0tY29sb3ItZ3JlZW4tMjAwOiBva2xjaCgwLjkyNSAwLjA4NCAxNTUuOTk1KTtcbiAgICAtLWNvbG9yLWdyZWVuLTMwMDogb2tsY2goMC44NzEgMC4xNSAxNTQuNDQ5KTtcbiAgICAtLWNvbG9yLWdyZWVuLTQwMDogb2tsY2goMC43OTIgMC4yMDkgMTUxLjcxMSk7XG4gICAgLS1jb2xvci1ncmVlbi01MDA6IG9rbGNoKDAuNzIzIDAuMjE5IDE0OS41NzkpO1xuICAgIC0tY29sb3ItZ3JlZW4tNjAwOiBva2xjaCgwLjYyNyAwLjE5NCAxNDkuMjE0KTtcbiAgICAtLWNvbG9yLWdyZWVuLTcwMDogb2tsY2goMC41MjcgMC4xNTQgMTUwLjA2OSk7XG4gICAgLS1jb2xvci1ncmVlbi04MDA6IG9rbGNoKDAuNDQ4IDAuMTE5IDE1MS4zMjgpO1xuICAgIC0tY29sb3ItZ3JlZW4tOTAwOiBva2xjaCgwLjM5MyAwLjA5NSAxNTIuNTM1KTtcbiAgICAtLWNvbG9yLWdyZWVuLTk1MDogb2tsY2goMC4yNjYgMC4wNjUgMTUyLjkzNCk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTUwOiBva2xjaCgwLjk3OSAwLjAyMSAxNjYuMTEzKTtcbiAgICAtLWNvbG9yLWVtZXJhbGQtMTAwOiBva2xjaCgwLjk1IDAuMDUyIDE2My4wNTEpO1xuICAgIC0tY29sb3ItZW1lcmFsZC0yMDA6IG9rbGNoKDAuOTA1IDAuMDkzIDE2NC4xNSk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTMwMDogb2tsY2goMC44NDUgMC4xNDMgMTY0Ljk3OCk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTQwMDogb2tsY2goMC43NjUgMC4xNzcgMTYzLjIyMyk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTUwMDogb2tsY2goMC42OTYgMC4xNyAxNjIuNDgpO1xuICAgIC0tY29sb3ItZW1lcmFsZC02MDA6IG9rbGNoKDAuNTk2IDAuMTQ1IDE2My4yMjUpO1xuICAgIC0tY29sb3ItZW1lcmFsZC03MDA6IG9rbGNoKDAuNTA4IDAuMTE4IDE2NS42MTIpO1xuICAgIC0tY29sb3ItZW1lcmFsZC04MDA6IG9rbGNoKDAuNDMyIDAuMDk1IDE2Ni45MTMpO1xuICAgIC0tY29sb3ItZW1lcmFsZC05MDA6IG9rbGNoKDAuMzc4IDAuMDc3IDE2OC45NCk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTk1MDogb2tsY2goMC4yNjIgMC4wNTEgMTcyLjU1Mik7XG4gICAgLS1jb2xvci10ZWFsLTUwOiBva2xjaCgwLjk4NCAwLjAxNCAxODAuNzIpO1xuICAgIC0tY29sb3ItdGVhbC0xMDA6IG9rbGNoKDAuOTUzIDAuMDUxIDE4MC44MDEpO1xuICAgIC0tY29sb3ItdGVhbC0yMDA6IG9rbGNoKDAuOTEgMC4wOTYgMTgwLjQyNik7XG4gICAgLS1jb2xvci10ZWFsLTMwMDogb2tsY2goMC44NTUgMC4xMzggMTgxLjA3MSk7XG4gICAgLS1jb2xvci10ZWFsLTQwMDogb2tsY2goMC43NzcgMC4xNTIgMTgxLjkxMik7XG4gICAgLS1jb2xvci10ZWFsLTUwMDogb2tsY2goMC43MDQgMC4xNCAxODIuNTAzKTtcbiAgICAtLWNvbG9yLXRlYWwtNjAwOiBva2xjaCgwLjYgMC4xMTggMTg0LjcwNCk7XG4gICAgLS1jb2xvci10ZWFsLTcwMDogb2tsY2goMC41MTEgMC4wOTYgMTg2LjM5MSk7XG4gICAgLS1jb2xvci10ZWFsLTgwMDogb2tsY2goMC40MzcgMC4wNzggMTg4LjIxNik7XG4gICAgLS1jb2xvci10ZWFsLTkwMDogb2tsY2goMC4zODYgMC4wNjMgMTg4LjQxNik7XG4gICAgLS1jb2xvci10ZWFsLTk1MDogb2tsY2goMC4yNzcgMC4wNDYgMTkyLjUyNCk7XG4gICAgLS1jb2xvci1jeWFuLTUwOiBva2xjaCgwLjk4NCAwLjAxOSAyMDAuODczKTtcbiAgICAtLWNvbG9yLWN5YW4tMTAwOiBva2xjaCgwLjk1NiAwLjA0NSAyMDMuMzg4KTtcbiAgICAtLWNvbG9yLWN5YW4tMjAwOiBva2xjaCgwLjkxNyAwLjA4IDIwNS4wNDEpO1xuICAgIC0tY29sb3ItY3lhbi0zMDA6IG9rbGNoKDAuODY1IDAuMTI3IDIwNy4wNzgpO1xuICAgIC0tY29sb3ItY3lhbi00MDA6IG9rbGNoKDAuNzg5IDAuMTU0IDIxMS41Myk7XG4gICAgLS1jb2xvci1jeWFuLTUwMDogb2tsY2goMC43MTUgMC4xNDMgMjE1LjIyMSk7XG4gICAgLS1jb2xvci1jeWFuLTYwMDogb2tsY2goMC42MDkgMC4xMjYgMjIxLjcyMyk7XG4gICAgLS1jb2xvci1jeWFuLTcwMDogb2tsY2goMC41MiAwLjEwNSAyMjMuMTI4KTtcbiAgICAtLWNvbG9yLWN5YW4tODAwOiBva2xjaCgwLjQ1IDAuMDg1IDIyNC4yODMpO1xuICAgIC0tY29sb3ItY3lhbi05MDA6IG9rbGNoKDAuMzk4IDAuMDcgMjI3LjM5Mik7XG4gICAgLS1jb2xvci1jeWFuLTk1MDogb2tsY2goMC4zMDIgMC4wNTYgMjI5LjY5NSk7XG4gICAgLS1jb2xvci1za3ktNTA6IG9rbGNoKDAuOTc3IDAuMDEzIDIzNi42Mik7XG4gICAgLS1jb2xvci1za3ktMTAwOiBva2xjaCgwLjk1MSAwLjAyNiAyMzYuODI0KTtcbiAgICAtLWNvbG9yLXNreS0yMDA6IG9rbGNoKDAuOTAxIDAuMDU4IDIzMC45MDIpO1xuICAgIC0tY29sb3Itc2t5LTMwMDogb2tsY2goMC44MjggMC4xMTEgMjMwLjMxOCk7XG4gICAgLS1jb2xvci1za3ktNDAwOiBva2xjaCgwLjc0NiAwLjE2IDIzMi42NjEpO1xuICAgIC0tY29sb3Itc2t5LTUwMDogb2tsY2goMC42ODUgMC4xNjkgMjM3LjMyMyk7XG4gICAgLS1jb2xvci1za3ktNjAwOiBva2xjaCgwLjU4OCAwLjE1OCAyNDEuOTY2KTtcbiAgICAtLWNvbG9yLXNreS03MDA6IG9rbGNoKDAuNSAwLjEzNCAyNDIuNzQ5KTtcbiAgICAtLWNvbG9yLXNreS04MDA6IG9rbGNoKDAuNDQzIDAuMTEgMjQwLjc5KTtcbiAgICAtLWNvbG9yLXNreS05MDA6IG9rbGNoKDAuMzkxIDAuMDkgMjQwLjg3Nik7XG4gICAgLS1jb2xvci1za3ktOTUwOiBva2xjaCgwLjI5MyAwLjA2NiAyNDMuMTU3KTtcbiAgICAtLWNvbG9yLWJsdWUtNTA6IG9rbGNoKDAuOTcgMC4wMTQgMjU0LjYwNCk7XG4gICAgLS1jb2xvci1ibHVlLTEwMDogb2tsY2goMC45MzIgMC4wMzIgMjU1LjU4NSk7XG4gICAgLS1jb2xvci1ibHVlLTIwMDogb2tsY2goMC44ODIgMC4wNTkgMjU0LjEyOCk7XG4gICAgLS1jb2xvci1ibHVlLTMwMDogb2tsY2goMC44MDkgMC4xMDUgMjUxLjgxMyk7XG4gICAgLS1jb2xvci1ibHVlLTQwMDogb2tsY2goMC43MDcgMC4xNjUgMjU0LjYyNCk7XG4gICAgLS1jb2xvci1ibHVlLTUwMDogb2tsY2goMC42MjMgMC4yMTQgMjU5LjgxNSk7XG4gICAgLS1jb2xvci1ibHVlLTYwMDogb2tsY2goMC41NDYgMC4yNDUgMjYyLjg4MSk7XG4gICAgLS1jb2xvci1ibHVlLTcwMDogb2tsY2goMC40ODggMC4yNDMgMjY0LjM3Nik7XG4gICAgLS1jb2xvci1ibHVlLTgwMDogb2tsY2goMC40MjQgMC4xOTkgMjY1LjYzOCk7XG4gICAgLS1jb2xvci1ibHVlLTkwMDogb2tsY2goMC4zNzkgMC4xNDYgMjY1LjUyMik7XG4gICAgLS1jb2xvci1ibHVlLTk1MDogb2tsY2goMC4yODIgMC4wOTEgMjY3LjkzNSk7XG4gICAgLS1jb2xvci1pbmRpZ28tNTA6IG9rbGNoKDAuOTYyIDAuMDE4IDI3Mi4zMTQpO1xuICAgIC0tY29sb3ItaW5kaWdvLTEwMDogb2tsY2goMC45MyAwLjAzNCAyNzIuNzg4KTtcbiAgICAtLWNvbG9yLWluZGlnby0yMDA6IG9rbGNoKDAuODcgMC4wNjUgMjc0LjAzOSk7XG4gICAgLS1jb2xvci1pbmRpZ28tMzAwOiBva2xjaCgwLjc4NSAwLjExNSAyNzQuNzEzKTtcbiAgICAtLWNvbG9yLWluZGlnby00MDA6IG9rbGNoKDAuNjczIDAuMTgyIDI3Ni45MzUpO1xuICAgIC0tY29sb3ItaW5kaWdvLTUwMDogb2tsY2goMC41ODUgMC4yMzMgMjc3LjExNyk7XG4gICAgLS1jb2xvci1pbmRpZ28tNjAwOiBva2xjaCgwLjUxMSAwLjI2MiAyNzYuOTY2KTtcbiAgICAtLWNvbG9yLWluZGlnby03MDA6IG9rbGNoKDAuNDU3IDAuMjQgMjc3LjAyMyk7XG4gICAgLS1jb2xvci1pbmRpZ28tODAwOiBva2xjaCgwLjM5OCAwLjE5NSAyNzcuMzY2KTtcbiAgICAtLWNvbG9yLWluZGlnby05MDA6IG9rbGNoKDAuMzU5IDAuMTQ0IDI3OC42OTcpO1xuICAgIC0tY29sb3ItaW5kaWdvLTk1MDogb2tsY2goMC4yNTcgMC4wOSAyODEuMjg4KTtcbiAgICAtLWNvbG9yLXZpb2xldC01MDogb2tsY2goMC45NjkgMC4wMTYgMjkzLjc1Nik7XG4gICAgLS1jb2xvci12aW9sZXQtMTAwOiBva2xjaCgwLjk0MyAwLjAyOSAyOTQuNTg4KTtcbiAgICAtLWNvbG9yLXZpb2xldC0yMDA6IG9rbGNoKDAuODk0IDAuMDU3IDI5My4yODMpO1xuICAgIC0tY29sb3ItdmlvbGV0LTMwMDogb2tsY2goMC44MTEgMC4xMTEgMjkzLjU3MSk7XG4gICAgLS1jb2xvci12aW9sZXQtNDAwOiBva2xjaCgwLjcwMiAwLjE4MyAyOTMuNTQxKTtcbiAgICAtLWNvbG9yLXZpb2xldC01MDA6IG9rbGNoKDAuNjA2IDAuMjUgMjkyLjcxNyk7XG4gICAgLS1jb2xvci12aW9sZXQtNjAwOiBva2xjaCgwLjU0MSAwLjI4MSAyOTMuMDA5KTtcbiAgICAtLWNvbG9yLXZpb2xldC03MDA6IG9rbGNoKDAuNDkxIDAuMjcgMjkyLjU4MSk7XG4gICAgLS1jb2xvci12aW9sZXQtODAwOiBva2xjaCgwLjQzMiAwLjIzMiAyOTIuNzU5KTtcbiAgICAtLWNvbG9yLXZpb2xldC05MDA6IG9rbGNoKDAuMzggMC4xODkgMjkzLjc0NSk7XG4gICAgLS1jb2xvci12aW9sZXQtOTUwOiBva2xjaCgwLjI4MyAwLjE0MSAyOTEuMDg5KTtcbiAgICAtLWNvbG9yLXB1cnBsZS01MDogb2tsY2goMC45NzcgMC4wMTQgMzA4LjI5OSk7XG4gICAgLS1jb2xvci1wdXJwbGUtMTAwOiBva2xjaCgwLjk0NiAwLjAzMyAzMDcuMTc0KTtcbiAgICAtLWNvbG9yLXB1cnBsZS0yMDA6IG9rbGNoKDAuOTAyIDAuMDYzIDMwNi43MDMpO1xuICAgIC0tY29sb3ItcHVycGxlLTMwMDogb2tsY2goMC44MjcgMC4xMTkgMzA2LjM4Myk7XG4gICAgLS1jb2xvci1wdXJwbGUtNDAwOiBva2xjaCgwLjcxNCAwLjIwMyAzMDUuNTA0KTtcbiAgICAtLWNvbG9yLXB1cnBsZS01MDA6IG9rbGNoKDAuNjI3IDAuMjY1IDMwMy45KTtcbiAgICAtLWNvbG9yLXB1cnBsZS02MDA6IG9rbGNoKDAuNTU4IDAuMjg4IDMwMi4zMjEpO1xuICAgIC0tY29sb3ItcHVycGxlLTcwMDogb2tsY2goMC40OTYgMC4yNjUgMzAxLjkyNCk7XG4gICAgLS1jb2xvci1wdXJwbGUtODAwOiBva2xjaCgwLjQzOCAwLjIxOCAzMDMuNzI0KTtcbiAgICAtLWNvbG9yLXB1cnBsZS05MDA6IG9rbGNoKDAuMzgxIDAuMTc2IDMwNC45ODcpO1xuICAgIC0tY29sb3ItcHVycGxlLTk1MDogb2tsY2goMC4yOTEgMC4xNDkgMzAyLjcxNyk7XG4gICAgLS1jb2xvci1mdWNoc2lhLTUwOiBva2xjaCgwLjk3NyAwLjAxNyAzMjAuMDU4KTtcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtMTAwOiBva2xjaCgwLjk1MiAwLjAzNyAzMTguODUyKTtcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtMjAwOiBva2xjaCgwLjkwMyAwLjA3NiAzMTkuNjIpO1xuICAgIC0tY29sb3ItZnVjaHNpYS0zMDA6IG9rbGNoKDAuODMzIDAuMTQ1IDMyMS40MzQpO1xuICAgIC0tY29sb3ItZnVjaHNpYS00MDA6IG9rbGNoKDAuNzQgMC4yMzggMzIyLjE2KTtcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtNTAwOiBva2xjaCgwLjY2NyAwLjI5NSAzMjIuMTUpO1xuICAgIC0tY29sb3ItZnVjaHNpYS02MDA6IG9rbGNoKDAuNTkxIDAuMjkzIDMyMi44OTYpO1xuICAgIC0tY29sb3ItZnVjaHNpYS03MDA6IG9rbGNoKDAuNTE4IDAuMjUzIDMyMy45NDkpO1xuICAgIC0tY29sb3ItZnVjaHNpYS04MDA6IG9rbGNoKDAuNDUyIDAuMjExIDMyNC41OTEpO1xuICAgIC0tY29sb3ItZnVjaHNpYS05MDA6IG9rbGNoKDAuNDAxIDAuMTcgMzI1LjYxMik7XG4gICAgLS1jb2xvci1mdWNoc2lhLTk1MDogb2tsY2goMC4yOTMgMC4xMzYgMzI1LjY2MSk7XG4gICAgLS1jb2xvci1waW5rLTUwOiBva2xjaCgwLjk3MSAwLjAxNCAzNDMuMTk4KTtcbiAgICAtLWNvbG9yLXBpbmstMTAwOiBva2xjaCgwLjk0OCAwLjAyOCAzNDIuMjU4KTtcbiAgICAtLWNvbG9yLXBpbmstMjAwOiBva2xjaCgwLjg5OSAwLjA2MSAzNDMuMjMxKTtcbiAgICAtLWNvbG9yLXBpbmstMzAwOiBva2xjaCgwLjgyMyAwLjEyIDM0Ni4wMTgpO1xuICAgIC0tY29sb3ItcGluay00MDA6IG9rbGNoKDAuNzE4IDAuMjAyIDM0OS43NjEpO1xuICAgIC0tY29sb3ItcGluay01MDA6IG9rbGNoKDAuNjU2IDAuMjQxIDM1NC4zMDgpO1xuICAgIC0tY29sb3ItcGluay02MDA6IG9rbGNoKDAuNTkyIDAuMjQ5IDAuNTg0KTtcbiAgICAtLWNvbG9yLXBpbmstNzAwOiBva2xjaCgwLjUyNSAwLjIyMyAzLjk1OCk7XG4gICAgLS1jb2xvci1waW5rLTgwMDogb2tsY2goMC40NTkgMC4xODcgMy44MTUpO1xuICAgIC0tY29sb3ItcGluay05MDA6IG9rbGNoKDAuNDA4IDAuMTUzIDIuNDMyKTtcbiAgICAtLWNvbG9yLXBpbmstOTUwOiBva2xjaCgwLjI4NCAwLjEwOSAzLjkwNyk7XG4gICAgLS1jb2xvci1yb3NlLTUwOiBva2xjaCgwLjk2OSAwLjAxNSAxMi40MjIpO1xuICAgIC0tY29sb3Itcm9zZS0xMDA6IG9rbGNoKDAuOTQxIDAuMDMgMTIuNTgpO1xuICAgIC0tY29sb3Itcm9zZS0yMDA6IG9rbGNoKDAuODkyIDAuMDU4IDEwLjAwMSk7XG4gICAgLS1jb2xvci1yb3NlLTMwMDogb2tsY2goMC44MSAwLjExNyAxMS42MzgpO1xuICAgIC0tY29sb3Itcm9zZS00MDA6IG9rbGNoKDAuNzEyIDAuMTk0IDEzLjQyOCk7XG4gICAgLS1jb2xvci1yb3NlLTUwMDogb2tsY2goMC42NDUgMC4yNDYgMTYuNDM5KTtcbiAgICAtLWNvbG9yLXJvc2UtNjAwOiBva2xjaCgwLjU4NiAwLjI1MyAxNy41ODUpO1xuICAgIC0tY29sb3Itcm9zZS03MDA6IG9rbGNoKDAuNTE0IDAuMjIyIDE2LjkzNSk7XG4gICAgLS1jb2xvci1yb3NlLTgwMDogb2tsY2goMC40NTUgMC4xODggMTMuNjk3KTtcbiAgICAtLWNvbG9yLXJvc2UtOTAwOiBva2xjaCgwLjQxIDAuMTU5IDEwLjI3Mik7XG4gICAgLS1jb2xvci1yb3NlLTk1MDogb2tsY2goMC4yNzEgMC4xMDUgMTIuMDk0KTtcbiAgICAtLWNvbG9yLXNsYXRlLTUwOiBva2xjaCgwLjk4NCAwLjAwMyAyNDcuODU4KTtcbiAgICAtLWNvbG9yLXNsYXRlLTEwMDogb2tsY2goMC45NjggMC4wMDcgMjQ3Ljg5Nik7XG4gICAgLS1jb2xvci1zbGF0ZS0yMDA6IG9rbGNoKDAuOTI5IDAuMDEzIDI1NS41MDgpO1xuICAgIC0tY29sb3Itc2xhdGUtMzAwOiBva2xjaCgwLjg2OSAwLjAyMiAyNTIuODk0KTtcbiAgICAtLWNvbG9yLXNsYXRlLTQwMDogb2tsY2goMC43MDQgMC4wNCAyNTYuNzg4KTtcbiAgICAtLWNvbG9yLXNsYXRlLTUwMDogb2tsY2goMC41NTQgMC4wNDYgMjU3LjQxNyk7XG4gICAgLS1jb2xvci1zbGF0ZS02MDA6IG9rbGNoKDAuNDQ2IDAuMDQzIDI1Ny4yODEpO1xuICAgIC0tY29sb3Itc2xhdGUtNzAwOiBva2xjaCgwLjM3MiAwLjA0NCAyNTcuMjg3KTtcbiAgICAtLWNvbG9yLXNsYXRlLTgwMDogb2tsY2goMC4yNzkgMC4wNDEgMjYwLjAzMSk7XG4gICAgLS1jb2xvci1zbGF0ZS05MDA6IG9rbGNoKDAuMjA4IDAuMDQyIDI2NS43NTUpO1xuICAgIC0tY29sb3Itc2xhdGUtOTUwOiBva2xjaCgwLjEyOSAwLjA0MiAyNjQuNjk1KTtcbiAgICAtLWNvbG9yLWdyYXktNTA6IG9rbGNoKDAuOTg1IDAuMDAyIDI0Ny44MzkpO1xuICAgIC0tY29sb3ItZ3JheS0xMDA6IG9rbGNoKDAuOTY3IDAuMDAzIDI2NC41NDIpO1xuICAgIC0tY29sb3ItZ3JheS0yMDA6IG9rbGNoKDAuOTI4IDAuMDA2IDI2NC41MzEpO1xuICAgIC0tY29sb3ItZ3JheS0zMDA6IG9rbGNoKDAuODcyIDAuMDEgMjU4LjMzOCk7XG4gICAgLS1jb2xvci1ncmF5LTQwMDogb2tsY2goMC43MDcgMC4wMjIgMjYxLjMyNSk7XG4gICAgLS1jb2xvci1ncmF5LTUwMDogb2tsY2goMC41NTEgMC4wMjcgMjY0LjM2NCk7XG4gICAgLS1jb2xvci1ncmF5LTYwMDogb2tsY2goMC40NDYgMC4wMyAyNTYuODAyKTtcbiAgICAtLWNvbG9yLWdyYXktNzAwOiBva2xjaCgwLjM3MyAwLjAzNCAyNTkuNzMzKTtcbiAgICAtLWNvbG9yLWdyYXktODAwOiBva2xjaCgwLjI3OCAwLjAzMyAyNTYuODQ4KTtcbiAgICAtLWNvbG9yLWdyYXktOTAwOiBva2xjaCgwLjIxIDAuMDM0IDI2NC42NjUpO1xuICAgIC0tY29sb3ItZ3JheS05NTA6IG9rbGNoKDAuMTMgMC4wMjggMjYxLjY5Mik7XG4gICAgLS1jb2xvci16aW5jLTUwOiBva2xjaCgwLjk4NSAwIDApO1xuICAgIC0tY29sb3ItemluYy0xMDA6IG9rbGNoKDAuOTY3IDAuMDAxIDI4Ni4zNzUpO1xuICAgIC0tY29sb3ItemluYy0yMDA6IG9rbGNoKDAuOTIgMC4wMDQgMjg2LjMyKTtcbiAgICAtLWNvbG9yLXppbmMtMzAwOiBva2xjaCgwLjg3MSAwLjAwNiAyODYuMjg2KTtcbiAgICAtLWNvbG9yLXppbmMtNDAwOiBva2xjaCgwLjcwNSAwLjAxNSAyODYuMDY3KTtcbiAgICAtLWNvbG9yLXppbmMtNTAwOiBva2xjaCgwLjU1MiAwLjAxNiAyODUuOTM4KTtcbiAgICAtLWNvbG9yLXppbmMtNjAwOiBva2xjaCgwLjQ0MiAwLjAxNyAyODUuNzg2KTtcbiAgICAtLWNvbG9yLXppbmMtNzAwOiBva2xjaCgwLjM3IDAuMDEzIDI4NS44MDUpO1xuICAgIC0tY29sb3ItemluYy04MDA6IG9rbGNoKDAuMjc0IDAuMDA2IDI4Ni4wMzMpO1xuICAgIC0tY29sb3ItemluYy05MDA6IG9rbGNoKDAuMjEgMC4wMDYgMjg1Ljg4NSk7XG4gICAgLS1jb2xvci16aW5jLTk1MDogb2tsY2goMC4xNDEgMC4wMDUgMjg1LjgyMyk7XG4gICAgLS1jb2xvci1uZXV0cmFsLTUwOiBva2xjaCgwLjk4NSAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC0xMDA6IG9rbGNoKDAuOTcgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtMjAwOiBva2xjaCgwLjkyMiAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC0zMDA6IG9rbGNoKDAuODcgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtNDAwOiBva2xjaCgwLjcwOCAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC01MDA6IG9rbGNoKDAuNTU2IDAgMCk7XG4gICAgLS1jb2xvci1uZXV0cmFsLTYwMDogb2tsY2goMC40MzkgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtNzAwOiBva2xjaCgwLjM3MSAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC04MDA6IG9rbGNoKDAuMjY5IDAgMCk7XG4gICAgLS1jb2xvci1uZXV0cmFsLTkwMDogb2tsY2goMC4yMDUgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtOTUwOiBva2xjaCgwLjE0NSAwIDApO1xuICAgIC0tY29sb3Itc3RvbmUtNTA6IG9rbGNoKDAuOTg1IDAuMDAxIDEwNi40MjMpO1xuICAgIC0tY29sb3Itc3RvbmUtMTAwOiBva2xjaCgwLjk3IDAuMDAxIDEwNi40MjQpO1xuICAgIC0tY29sb3Itc3RvbmUtMjAwOiBva2xjaCgwLjkyMyAwLjAwMyA0OC43MTcpO1xuICAgIC0tY29sb3Itc3RvbmUtMzAwOiBva2xjaCgwLjg2OSAwLjAwNSA1Ni4zNjYpO1xuICAgIC0tY29sb3Itc3RvbmUtNDAwOiBva2xjaCgwLjcwOSAwLjAxIDU2LjI1OSk7XG4gICAgLS1jb2xvci1zdG9uZS01MDA6IG9rbGNoKDAuNTUzIDAuMDEzIDU4LjA3MSk7XG4gICAgLS1jb2xvci1zdG9uZS02MDA6IG9rbGNoKDAuNDQ0IDAuMDExIDczLjYzOSk7XG4gICAgLS1jb2xvci1zdG9uZS03MDA6IG9rbGNoKDAuMzc0IDAuMDEgNjcuNTU4KTtcbiAgICAtLWNvbG9yLXN0b25lLTgwMDogb2tsY2goMC4yNjggMC4wMDcgMzQuMjk4KTtcbiAgICAtLWNvbG9yLXN0b25lLTkwMDogb2tsY2goMC4yMTYgMC4wMDYgNTYuMDQzKTtcbiAgICAtLWNvbG9yLXN0b25lLTk1MDogb2tsY2goMC4xNDcgMC4wMDQgNDkuMjUpO1xuICAgIC0tY29sb3ItYmxhY2s6ICMwMDA7XG4gICAgLS1jb2xvci13aGl0ZTogI2ZmZjtcbiAgICAtLXNwYWNpbmc6IDAuMjVyZW07XG4gICAgLS1icmVha3BvaW50LXNtOiA0MHJlbTtcbiAgICAtLWJyZWFrcG9pbnQtbWQ6IDQ4cmVtO1xuICAgIC0tYnJlYWtwb2ludC1sZzogNjRyZW07XG4gICAgLS1icmVha3BvaW50LXhsOiA4MHJlbTtcbiAgICAtLWJyZWFrcG9pbnQtMnhsOiA5NnJlbTtcbiAgICAtLWNvbnRhaW5lci0zeHM6IDE2cmVtO1xuICAgIC0tY29udGFpbmVyLTJ4czogMThyZW07XG4gICAgLS1jb250YWluZXIteHM6IDIwcmVtO1xuICAgIC0tY29udGFpbmVyLXNtOiAyNHJlbTtcbiAgICAtLWNvbnRhaW5lci1tZDogMjhyZW07XG4gICAgLS1jb250YWluZXItbGc6IDMycmVtO1xuICAgIC0tY29udGFpbmVyLXhsOiAzNnJlbTtcbiAgICAtLWNvbnRhaW5lci0yeGw6IDQycmVtO1xuICAgIC0tY29udGFpbmVyLTN4bDogNDhyZW07XG4gICAgLS1jb250YWluZXItNHhsOiA1NnJlbTtcbiAgICAtLWNvbnRhaW5lci01eGw6IDY0cmVtO1xuICAgIC0tY29udGFpbmVyLTZ4bDogNzJyZW07XG4gICAgLS1jb250YWluZXItN3hsOiA4MHJlbTtcbiAgICAtLXRleHQteHM6IDAuNzVyZW07XG4gICAgLS10ZXh0LXhzLS1saW5lLWhlaWdodDogY2FsYygxIC8gMC43NSk7XG4gICAgLS10ZXh0LXNtOiAwLjg3NXJlbTtcbiAgICAtLXRleHQtc20tLWxpbmUtaGVpZ2h0OiBjYWxjKDEuMjUgLyAwLjg3NSk7XG4gICAgLS10ZXh0LWJhc2U6IDFyZW07XG4gICAgLS10ZXh0LWJhc2UtLWxpbmUtaGVpZ2h0OiBjYWxjKDEuNSAvIDEpO1xuICAgIC0tdGV4dC1sZzogMS4xMjVyZW07XG4gICAgLS10ZXh0LWxnLS1saW5lLWhlaWdodDogY2FsYygxLjc1IC8gMS4xMjUpO1xuICAgIC0tdGV4dC14bDogMS4yNXJlbTtcbiAgICAtLXRleHQteGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDEuNzUgLyAxLjI1KTtcbiAgICAtLXRleHQtMnhsOiAxLjVyZW07XG4gICAgLS10ZXh0LTJ4bC0tbGluZS1oZWlnaHQ6IGNhbGMoMiAvIDEuNSk7XG4gICAgLS10ZXh0LTN4bDogMS44NzVyZW07XG4gICAgLS10ZXh0LTN4bC0tbGluZS1oZWlnaHQ6IGNhbGMoMi4yNSAvIDEuODc1KTtcbiAgICAtLXRleHQtNHhsOiAyLjI1cmVtO1xuICAgIC0tdGV4dC00eGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDIuNSAvIDIuMjUpO1xuICAgIC0tdGV4dC01eGw6IDNyZW07XG4gICAgLS10ZXh0LTV4bC0tbGluZS1oZWlnaHQ6IDE7XG4gICAgLS10ZXh0LTZ4bDogMy43NXJlbTtcbiAgICAtLXRleHQtNnhsLS1saW5lLWhlaWdodDogMTtcbiAgICAtLXRleHQtN3hsOiA0LjVyZW07XG4gICAgLS10ZXh0LTd4bC0tbGluZS1oZWlnaHQ6IDE7XG4gICAgLS10ZXh0LTh4bDogNnJlbTtcbiAgICAtLXRleHQtOHhsLS1saW5lLWhlaWdodDogMTtcbiAgICAtLXRleHQtOXhsOiA4cmVtO1xuICAgIC0tdGV4dC05eGwtLWxpbmUtaGVpZ2h0OiAxO1xuICAgIC0tZm9udC13ZWlnaHQtdGhpbjogMTAwO1xuICAgIC0tZm9udC13ZWlnaHQtZXh0cmFsaWdodDogMjAwO1xuICAgIC0tZm9udC13ZWlnaHQtbGlnaHQ6IDMwMDtcbiAgICAtLWZvbnQtd2VpZ2h0LW5vcm1hbDogNDAwO1xuICAgIC0tZm9udC13ZWlnaHQtbWVkaXVtOiA1MDA7XG4gICAgLS1mb250LXdlaWdodC1zZW1pYm9sZDogNjAwO1xuICAgIC0tZm9udC13ZWlnaHQtYm9sZDogNzAwO1xuICAgIC0tZm9udC13ZWlnaHQtZXh0cmFib2xkOiA4MDA7XG4gICAgLS1mb250LXdlaWdodC1ibGFjazogOTAwO1xuICAgIC0tdHJhY2tpbmctdGlnaHRlcjogLTAuMDVlbTtcbiAgICAtLXRyYWNraW5nLXRpZ2h0OiAtMC4wMjVlbTtcbiAgICAtLXRyYWNraW5nLW5vcm1hbDogMGVtO1xuICAgIC0tdHJhY2tpbmctd2lkZTogMC4wMjVlbTtcbiAgICAtLXRyYWNraW5nLXdpZGVyOiAwLjA1ZW07XG4gICAgLS10cmFja2luZy13aWRlc3Q6IDAuMWVtO1xuICAgIC0tbGVhZGluZy10aWdodDogMS4yNTtcbiAgICAtLWxlYWRpbmctc251ZzogMS4zNzU7XG4gICAgLS1sZWFkaW5nLW5vcm1hbDogMS41O1xuICAgIC0tbGVhZGluZy1yZWxheGVkOiAxLjYyNTtcbiAgICAtLWxlYWRpbmctbG9vc2U6IDI7XG4gICAgLS1yYWRpdXMteHM6IDAuMTI1cmVtO1xuICAgIC0tcmFkaXVzLXNtOiAwLjI1cmVtO1xuICAgIC0tcmFkaXVzLW1kOiAwLjM3NXJlbTtcbiAgICAtLXJhZGl1cy1sZzogMC41cmVtO1xuICAgIC0tcmFkaXVzLXhsOiAwLjc1cmVtO1xuICAgIC0tcmFkaXVzLTJ4bDogMXJlbTtcbiAgICAtLXJhZGl1cy0zeGw6IDEuNXJlbTtcbiAgICAtLXJhZGl1cy00eGw6IDJyZW07XG4gICAgLS1zaGFkb3ctMnhzOiAwIDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcbiAgICAtLXNoYWRvdy14czogMCAxcHggMnB4IDAgcmdiKDAgMCAwIC8gMC4wNSk7XG4gICAgLS1zaGFkb3ctc206IDAgMXB4IDNweCAwIHJnYigwIDAgMCAvIDAuMSksIDAgMXB4IDJweCAtMXB4IHJnYigwIDAgMCAvIDAuMSk7XG4gICAgLS1zaGFkb3ctbWQ6IDAgNHB4IDZweCAtMXB4IHJnYigwIDAgMCAvIDAuMSksXG4gICAgICAwIDJweCA0cHggLTJweCByZ2IoMCAwIDAgLyAwLjEpO1xuICAgIC0tc2hhZG93LWxnOiAwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksXG4gICAgICAwIDRweCA2cHggLTRweCByZ2IoMCAwIDAgLyAwLjEpO1xuICAgIC0tc2hhZG93LXhsOiAwIDIwcHggMjVweCAtNXB4IHJnYigwIDAgMCAvIDAuMSksXG4gICAgICAwIDhweCAxMHB4IC02cHggcmdiKDAgMCAwIC8gMC4xKTtcbiAgICAtLXNoYWRvdy0yeGw6IDAgMjVweCA1MHB4IC0xMnB4IHJnYigwIDAgMCAvIDAuMjUpO1xuICAgIC0taW5zZXQtc2hhZG93LTJ4czogaW5zZXQgMCAxcHggcmdiKDAgMCAwIC8gMC4wNSk7XG4gICAgLS1pbnNldC1zaGFkb3cteHM6IGluc2V0IDAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcbiAgICAtLWluc2V0LXNoYWRvdy1zbTogaW5zZXQgMCAycHggNHB4IHJnYigwIDAgMCAvIDAuMDUpO1xuICAgIC0tZHJvcC1zaGFkb3cteHM6IDAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcbiAgICAtLWRyb3Atc2hhZG93LXNtOiAwIDFweCAycHggcmdiKDAgMCAwIC8gMC4xNSk7XG4gICAgLS1kcm9wLXNoYWRvdy1tZDogMCAzcHggM3B4IHJnYigwIDAgMCAvIDAuMTIpO1xuICAgIC0tZHJvcC1zaGFkb3ctbGc6IDAgNHB4IDRweCByZ2IoMCAwIDAgLyAwLjE1KTtcbiAgICAtLWRyb3Atc2hhZG93LXhsOiAwIDlweCA3cHggcmdiKDAgMCAwIC8gMC4xKTtcbiAgICAtLWRyb3Atc2hhZG93LTJ4bDogMCAyNXB4IDI1cHggcmdiKDAgMCAwIC8gMC4xNSk7XG4gICAgLS1lYXNlLWluOiBjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKTtcbiAgICAtLWVhc2Utb3V0OiBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAxKTtcbiAgICAtLWVhc2UtaW4tb3V0OiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xuICAgIC0tYW5pbWF0ZS1zcGluOiBzcGluIDFzIGxpbmVhciBpbmZpbml0ZTtcbiAgICAtLWFuaW1hdGUtcGluZzogcGluZyAxcyBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAxKSBpbmZpbml0ZTtcbiAgICAtLWFuaW1hdGUtcHVsc2U6IHB1bHNlIDJzIGN1YmljLWJlemllcigwLjQsIDAsIDAuNiwgMSkgaW5maW5pdGU7XG4gICAgLS1hbmltYXRlLWJvdW5jZTogYm91bmNlIDFzIGluZmluaXRlO1xuICAgIC0tYmx1ci14czogNHB4O1xuICAgIC0tYmx1ci1zbTogOHB4O1xuICAgIC0tYmx1ci1tZDogMTJweDtcbiAgICAtLWJsdXItbGc6IDE2cHg7XG4gICAgLS1ibHVyLXhsOiAyNHB4O1xuICAgIC0tYmx1ci0yeGw6IDQwcHg7XG4gICAgLS1ibHVyLTN4bDogNjRweDtcbiAgICAtLXBlcnNwZWN0aXZlLWRyYW1hdGljOiAxMDBweDtcbiAgICAtLXBlcnNwZWN0aXZlLW5lYXI6IDMwMHB4O1xuICAgIC0tcGVyc3BlY3RpdmUtbm9ybWFsOiA1MDBweDtcbiAgICAtLXBlcnNwZWN0aXZlLW1pZHJhbmdlOiA4MDBweDtcbiAgICAtLXBlcnNwZWN0aXZlLWRpc3RhbnQ6IDEyMDBweDtcbiAgICAtLWFzcGVjdC12aWRlbzogMTYgLyA5O1xuICAgIC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcbiAgICAtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gICAgLS1kZWZhdWx0LWZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXNhbnMpO1xuICAgIC0tZGVmYXVsdC1mb250LWZlYXR1cmUtc2V0dGluZ3M6IHZhcigtLWZvbnQtc2Fucy0tZm9udC1mZWF0dXJlLXNldHRpbmdzKTtcbiAgICAtLWRlZmF1bHQtZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IHZhcihcbiAgICAgIC0tZm9udC1zYW5zLS1mb250LXZhcmlhdGlvbi1zZXR0aW5nc1xuICAgICk7XG4gICAgLS1kZWZhdWx0LW1vbm8tZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtbW9ubyk7XG4gICAgLS1kZWZhdWx0LW1vbm8tZm9udC1mZWF0dXJlLXNldHRpbmdzOiB2YXIoXG4gICAgICAtLWZvbnQtbW9uby0tZm9udC1mZWF0dXJlLXNldHRpbmdzXG4gICAgKTtcbiAgICAtLWRlZmF1bHQtbW9uby1mb250LXZhcmlhdGlvbi1zZXR0aW5nczogdmFyKFxuICAgICAgLS1mb250LW1vbm8tLWZvbnQtdmFyaWF0aW9uLXNldHRpbmdzXG4gICAgKTtcbiAgICAtLWNvbG9yLXByaW1hcnktdHc6ICMyYjgwZmY7XG4gICAgLS1jb2xvci1saWdodDogI2MzZDVmNztcbiAgICAtLWNvbG9yLWJnLWRhcms6ICMwYTBhMWE7XG4gICAgLS1jb2xvci1iZy1jYXJkOiAjMWExYTJhO1xuICAgIC0tY29sb3ItYmctaG92ZXI6ICMyYTJhM2E7XG4gICAgLS1jb2xvci1iZy1hY3RpdmU6ICNmZmY7XG4gICAgLS1jb2xvci1ib3JkZXI6ICMzMzM7XG4gICAgLS1jb2xvci1ib3JkZXItYWN0aXZlOiAjNWE1YTdhO1xuICAgIC0tY29sb3ItdGV4dC1zZWNvbmRhcnk6ICNhYWE7XG4gIH1cbn1cbkBsYXllciBiYXNlIHtcbiAgKiwgOjphZnRlciwgOjpiZWZvcmUsIDo6YmFja2Ryb3AsIDo6ZmlsZS1zZWxlY3Rvci1idXR0b24ge1xuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgbWFyZ2luOiAwO1xuICAgIHBhZGRpbmc6IDA7XG4gICAgYm9yZGVyOiAwIHNvbGlkO1xuICB9XG4gIGh0bWwsIDpob3N0IHtcbiAgICBsaW5lLWhlaWdodDogMS41O1xuICAgIC13ZWJraXQtdGV4dC1zaXplLWFkanVzdDogMTAwJTtcbiAgICB0YWItc2l6ZTogNDtcbiAgICBmb250LWZhbWlseTogdmFyKCAtLWRlZmF1bHQtZm9udC1mYW1pbHksIHVpLXNhbnMtc2VyaWYsIHN5c3RlbS11aSwgc2Fucy1zZXJpZiwgXCJBcHBsZSBDb2xvciBFbW9qaVwiLCBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiICk7XG4gICAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiB2YXIoLS1kZWZhdWx0LWZvbnQtZmVhdHVyZS1zZXR0aW5ncywgbm9ybWFsKTtcbiAgICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogdmFyKCAtLWRlZmF1bHQtZm9udC12YXJpYXRpb24tc2V0dGluZ3MsIG5vcm1hbCApO1xuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIH1cbiAgYm9keSB7XG4gICAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7XG4gIH1cbiAgaHIge1xuICAgIGhlaWdodDogMDtcbiAgICBjb2xvcjogaW5oZXJpdDtcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XG4gIH1cbiAgYWJicjp3aGVyZShbdGl0bGVdKSB7XG4gICAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gICAgdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmUgZG90dGVkO1xuICB9XG4gIGgxLCBoMiwgaDMsIGg0LCBoNSwgaDYge1xuICAgIGZvbnQtc2l6ZTogaW5oZXJpdDtcbiAgICBmb250LXdlaWdodDogaW5oZXJpdDtcbiAgfVxuICBhIHtcbiAgICBjb2xvcjogaW5oZXJpdDtcbiAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcbiAgICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XG4gIH1cbiAgYiwgc3Ryb25nIHtcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xuICB9XG4gIGNvZGUsIGtiZCwgc2FtcCwgcHJlIHtcbiAgICBmb250LWZhbWlseTogdmFyKCAtLWRlZmF1bHQtbW9uby1mb250LWZhbWlseSwgdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFwiTGliZXJhdGlvbiBNb25vXCIsIFwiQ291cmllciBOZXdcIiwgbW9ub3NwYWNlICk7XG4gICAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiB2YXIoIC0tZGVmYXVsdC1tb25vLWZvbnQtZmVhdHVyZS1zZXR0aW5ncywgbm9ybWFsICk7XG4gICAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IHZhciggLS1kZWZhdWx0LW1vbm8tZm9udC12YXJpYXRpb24tc2V0dGluZ3MsIG5vcm1hbCApO1xuICAgIGZvbnQtc2l6ZTogMWVtO1xuICB9XG4gIHNtYWxsIHtcbiAgICBmb250LXNpemU6IDgwJTtcbiAgfVxuICBzdWIsIHN1cCB7XG4gICAgZm9udC1zaXplOiA3NSU7XG4gICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbiAgfVxuICBzdWIge1xuICAgIGJvdHRvbTogLTAuMjVlbTtcbiAgfVxuICBzdXAge1xuICAgIHRvcDogLTAuNWVtO1xuICB9XG4gIHRhYmxlIHtcbiAgICB0ZXh0LWluZGVudDogMDtcbiAgICBib3JkZXItY29sb3I6IGluaGVyaXQ7XG4gICAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbiAgfVxuICA6LW1vei1mb2N1c3Jpbmcge1xuICAgIG91dGxpbmU6IGF1dG87XG4gIH1cbiAgcHJvZ3Jlc3Mge1xuICAgIHZlcnRpY2FsLWFsaWduOiBiYXNlbGluZTtcbiAgfVxuICBzdW1tYXJ5IHtcbiAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XG4gIH1cbiAgb2wsIHVsLCBtZW51IHtcbiAgICBsaXN0LXN0eWxlOiBub25lO1xuICB9XG4gIGltZywgc3ZnLCB2aWRlbywgY2FudmFzLCBhdWRpbywgaWZyYW1lLCBlbWJlZCwgb2JqZWN0IHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICB9XG4gIGltZywgdmlkZW8ge1xuICAgIG1heC13aWR0aDogMTAwJTtcbiAgICBoZWlnaHQ6IGF1dG87XG4gIH1cbiAgYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCBvcHRncm91cCwgdGV4dGFyZWEsIDo6ZmlsZS1zZWxlY3Rvci1idXR0b24ge1xuICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgZm9udC1mZWF0dXJlLXNldHRpbmdzOiBpbmhlcml0O1xuICAgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiBpbmhlcml0O1xuICAgIGxldHRlci1zcGFjaW5nOiBpbmhlcml0O1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIGJvcmRlci1yYWRpdXM6IDA7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgb3BhY2l0eTogMTtcbiAgfVxuICA6d2hlcmUoc2VsZWN0OmlzKFttdWx0aXBsZV0sIFtzaXplXSkpIG9wdGdyb3VwIHtcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xuICB9XG4gIDp3aGVyZShzZWxlY3Q6aXMoW211bHRpcGxlXSwgW3NpemVdKSkgb3B0Z3JvdXAgb3B0aW9uIHtcbiAgICBwYWRkaW5nLWlubGluZS1zdGFydDogMjBweDtcbiAgfVxuICA6OmZpbGUtc2VsZWN0b3ItYnV0dG9uIHtcbiAgICBtYXJnaW4taW5saW5lLWVuZDogNHB4O1xuICB9XG4gIDo6cGxhY2Vob2xkZXIge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgY3VycmVudENvbG9yIDUwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIHRleHRhcmVhIHtcbiAgICByZXNpemU6IHZlcnRpY2FsO1xuICB9XG4gIDo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XG4gICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICB9XG4gIDo6LXdlYmtpdC1kYXRlLWFuZC10aW1lLXZhbHVlIHtcbiAgICBtaW4taGVpZ2h0OiAxbGg7XG4gICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcbiAgfVxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdCB7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIH1cbiAgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtZmllbGRzLXdyYXBwZXIge1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbiAgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LXllYXItZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LW1vbnRoLWZpZWxkLCA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1kYXktZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWhvdXItZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LW1pbnV0ZS1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtc2Vjb25kLWZpZWxkLCA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1taWxsaXNlY29uZC1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtbWVyaWRpZW0tZmllbGQge1xuICAgIHBhZGRpbmctYmxvY2s6IDA7XG4gIH1cbiAgOi1tb3otdWktaW52YWxpZCB7XG4gICAgYm94LXNoYWRvdzogbm9uZTtcbiAgfVxuICBidXR0b24sIGlucHV0OndoZXJlKFt0eXBlPVwiYnV0dG9uXCJdLCBbdHlwZT1cInJlc2V0XCJdLCBbdHlwZT1cInN1Ym1pdFwiXSksIDo6ZmlsZS1zZWxlY3Rvci1idXR0b24ge1xuICAgIGFwcGVhcmFuY2U6IGJ1dHRvbjtcbiAgfVxuICA6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24sIDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbiB7XG4gICAgaGVpZ2h0OiBhdXRvO1xuICB9XG4gIFtoaWRkZW5dOndoZXJlKDpub3QoW2hpZGRlbj1cInVudGlsLWZvdW5kXCJdKSkge1xuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgfVxufVxuQGxheWVyIHV0aWxpdGllcyB7XG4gIC5wb2ludGVyLWV2ZW50cy1ub25lIHtcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgfVxuICAuY29sbGFwc2Uge1xuICAgIHZpc2liaWxpdHk6IGNvbGxhcHNlO1xuICB9XG4gIC52aXNpYmxlIHtcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICB9XG4gIC5hYnNvbHV0ZSB7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICB9XG4gIC5maXhlZCB7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICB9XG4gIC5yZWxhdGl2ZSB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB9XG4gIC5zdGF0aWMge1xuICAgIHBvc2l0aW9uOiBzdGF0aWM7XG4gIH1cbiAgLmluc2V0LTAge1xuICAgIGluc2V0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMCk7XG4gIH1cbiAgLnRvcC0wIHtcbiAgICB0b3A6IGNhbGModmFyKC0tc3BhY2luZykgKiAwKTtcbiAgfVxuICAudG9wLTFcXFxcLzIge1xuICAgIHRvcDogY2FsYygxLzIgKiAxMDAlKTtcbiAgfVxuICAudG9wLTQge1xuICAgIHRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5yaWdodC0wIHtcbiAgICByaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDApO1xuICB9XG4gIC5yaWdodC00IHtcbiAgICByaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5sZWZ0LTMge1xuICAgIGxlZnQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAzKTtcbiAgfVxuICAuei00MCB7XG4gICAgei1pbmRleDogNDA7XG4gIH1cbiAgLnotNTAge1xuICAgIHotaW5kZXg6IDUwO1xuICB9XG4gIC5cXFxcIWNvbnRhaW5lciB7XG4gICAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcbiAgICBAbWVkaWEgKHdpZHRoID49IDQwcmVtKSB7XG4gICAgICBtYXgtd2lkdGg6IDQwcmVtICFpbXBvcnRhbnQ7XG4gICAgfVxuICAgIEBtZWRpYSAod2lkdGggPj0gNDhyZW0pIHtcbiAgICAgIG1heC13aWR0aDogNDhyZW0gIWltcG9ydGFudDtcbiAgICB9XG4gICAgQG1lZGlhICh3aWR0aCA+PSA2NHJlbSkge1xuICAgICAgbWF4LXdpZHRoOiA2NHJlbSAhaW1wb3J0YW50O1xuICAgIH1cbiAgICBAbWVkaWEgKHdpZHRoID49IDgwcmVtKSB7XG4gICAgICBtYXgtd2lkdGg6IDgwcmVtICFpbXBvcnRhbnQ7XG4gICAgfVxuICAgIEBtZWRpYSAod2lkdGggPj0gOTZyZW0pIHtcbiAgICAgIG1heC13aWR0aDogOTZyZW0gIWltcG9ydGFudDtcbiAgICB9XG4gIH1cbiAgLmNvbnRhaW5lciB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0MHJlbSkge1xuICAgICAgbWF4LXdpZHRoOiA0MHJlbTtcbiAgICB9XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0OHJlbSkge1xuICAgICAgbWF4LXdpZHRoOiA0OHJlbTtcbiAgICB9XG4gICAgQG1lZGlhICh3aWR0aCA+PSA2NHJlbSkge1xuICAgICAgbWF4LXdpZHRoOiA2NHJlbTtcbiAgICB9XG4gICAgQG1lZGlhICh3aWR0aCA+PSA4MHJlbSkge1xuICAgICAgbWF4LXdpZHRoOiA4MHJlbTtcbiAgICB9XG4gICAgQG1lZGlhICh3aWR0aCA+PSA5NnJlbSkge1xuICAgICAgbWF4LXdpZHRoOiA5NnJlbTtcbiAgICB9XG4gIH1cbiAgLm0tMCB7XG4gICAgbWFyZ2luOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMCk7XG4gIH1cbiAgLm0tMSB7XG4gICAgbWFyZ2luOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMSk7XG4gIH1cbiAgLm14LTIge1xuICAgIG1hcmdpbi1pbmxpbmU6IGNhbGModmFyKC0tc3BhY2luZykgKiAyKTtcbiAgfVxuICAubXgtYXV0byB7XG4gICAgbWFyZ2luLWlubGluZTogYXV0bztcbiAgfVxuICAubXktMSB7XG4gICAgbWFyZ2luLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMSk7XG4gIH1cbiAgLm15LTgge1xuICAgIG1hcmdpbi1ibG9jazogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDgpO1xuICB9XG4gIC5cXFxcIW10LTQge1xuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KSAhaW1wb3J0YW50O1xuICB9XG4gIC5tdC0yIHtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMik7XG4gIH1cbiAgLm10LTMge1xuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc3BhY2luZykgKiAzKTtcbiAgfVxuICAubXQtNCB7XG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5tdC02IHtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNik7XG4gIH1cbiAgLm10LTgge1xuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAubXItNCB7XG4gICAgbWFyZ2luLXJpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLlxcXFwhbWItNiB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLm1iLTEge1xuICAgIG1hcmdpbi1ib3R0b206IGNhbGModmFyKC0tc3BhY2luZykgKiAxKTtcbiAgfVxuICAubWItMVxcXFwuNSB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEuNSk7XG4gIH1cbiAgLm1iLTIge1xuICAgIG1hcmdpbi1ib3R0b206IGNhbGModmFyKC0tc3BhY2luZykgKiAyKTtcbiAgfVxuICAubWItMlxcXFwuNSB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIuNSk7XG4gIH1cbiAgLm1iLTMge1xuICAgIG1hcmdpbi1ib3R0b206IGNhbGModmFyKC0tc3BhY2luZykgKiAzKTtcbiAgfVxuICAubWItNCB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5tYi02IHtcbiAgICBtYXJnaW4tYm90dG9tOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNik7XG4gIH1cbiAgLm1iLTgge1xuICAgIG1hcmdpbi1ib3R0b206IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAubWwtMiB7XG4gICAgbWFyZ2luLWxlZnQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAyKTtcbiAgfVxuICAubGluZS1jbGFtcC0yIHtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGRpc3BsYXk6IC13ZWJraXQtYm94O1xuICAgIC13ZWJraXQtYm94LW9yaWVudDogdmVydGljYWw7XG4gICAgLXdlYmtpdC1saW5lLWNsYW1wOiAyO1xuICB9XG4gIC5saW5lLWNsYW1wLTMge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWxpbmUtY2xhbXA6IDM7XG4gIH1cbiAgLlxcXFwhZmxleCB7XG4gICAgZGlzcGxheTogZmxleCAhaW1wb3J0YW50O1xuICB9XG4gIC5cXFxcIWhpZGRlbiB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICB9XG4gIC5ibG9jayB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cbiAgLmNvbnRlbnRzIHtcbiAgICBkaXNwbGF5OiBjb250ZW50cztcbiAgfVxuICAuZmxleCB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgfVxuICAuZ3JpZCB7XG4gICAgZGlzcGxheTogZ3JpZDtcbiAgfVxuICAuaGlkZGVuIHtcbiAgICBkaXNwbGF5OiBub25lO1xuICB9XG4gIC5pbmxpbmUtZmxleCB7XG4gICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gIH1cbiAgLmxpc3QtaXRlbSB7XG4gICAgZGlzcGxheTogbGlzdC1pdGVtO1xuICB9XG4gIC50YWJsZSB7XG4gICAgZGlzcGxheTogdGFibGU7XG4gIH1cbiAgLnNpemUtMSB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiAxKTtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAxKTtcbiAgfVxuICAuXFxcXCFoLTEwIHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAxMCkgIWltcG9ydGFudDtcbiAgfVxuICAuaC0xIHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAxKTtcbiAgfVxuICAuaC0yIHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAyKTtcbiAgfVxuICAuaC00IHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KTtcbiAgfVxuICAuaC01IHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA1KTtcbiAgfVxuICAuaC02IHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA2KTtcbiAgfVxuICAuaC04IHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAuaC0xMCB7XG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMTApO1xuICB9XG4gIC5oLTEyIHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAxMik7XG4gIH1cbiAgLmgtMjAge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIwKTtcbiAgfVxuICAuaC00OCB7XG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogNDgpO1xuICB9XG4gIC5oLTU2IHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA1Nik7XG4gIH1cbiAgLmgtXFxcXFsxMDBweFxcXFxdIHtcbiAgICBoZWlnaHQ6IDEwMHB4O1xuICB9XG4gIC5oLVxcXFxbMTUwcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiAxNTBweDtcbiAgfVxuICAuaC1cXFxcWzFyZW1cXFxcXSB7XG4gICAgaGVpZ2h0OiAxcmVtO1xuICB9XG4gIC5oLVxcXFxbMlxcXFwuODc1cmVtXFxcXF0ge1xuICAgIGhlaWdodDogMi44NzVyZW07XG4gIH1cbiAgLmgtZnVsbCB7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICB9XG4gIC5tYXgtaC01NiB7XG4gICAgbWF4LWhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDU2KTtcbiAgfVxuICAubWF4LWgtNjQge1xuICAgIG1heC1oZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA2NCk7XG4gIH1cbiAgLm1heC1oLVxcXFxbMzAwcHhcXFxcXSB7XG4gICAgbWF4LWhlaWdodDogMzAwcHg7XG4gIH1cbiAgLm1pbi1oLVxcXFxbMjByZW1cXFxcXSB7XG4gICAgbWluLWhlaWdodDogMjByZW07XG4gIH1cbiAgLm1pbi1oLXNjcmVlbiB7XG4gICAgbWluLWhlaWdodDogMTAwdmg7XG4gIH1cbiAgLlxcXFwhdy0xMCB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiAxMCkgIWltcG9ydGFudDtcbiAgfVxuICAudy0xIHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICB9XG4gIC53LTFcXFxcLzQge1xuICAgIHdpZHRoOiBjYWxjKDEvNCAqIDEwMCUpO1xuICB9XG4gIC53LTQge1xuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLnctNSB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiA1KTtcbiAgfVxuICAudy02IHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpO1xuICB9XG4gIC53LTgge1xuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNwYWNpbmcpICogOCk7XG4gIH1cbiAgLnctMTAge1xuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMTApO1xuICB9XG4gIC53LTEyIHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEyKTtcbiAgfVxuICAudy0yMCB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiAyMCk7XG4gIH1cbiAgLnctXFxcXFsxXFxcXC40NTQ1NnJlbVxcXFxdIHtcbiAgICB3aWR0aDogMS40NTQ1NnJlbTtcbiAgfVxuICAudy1cXFxcWzJcXFxcLjg3NXJlbVxcXFxdIHtcbiAgICB3aWR0aDogMi44NzVyZW07XG4gIH1cbiAgLnctXFxcXFsxMDBweFxcXFxdIHtcbiAgICB3aWR0aDogMTAwcHg7XG4gIH1cbiAgLnctZnVsbCB7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH1cbiAgLm1heC13LTV4bCB7XG4gICAgbWF4LXdpZHRoOiB2YXIoLS1jb250YWluZXItNXhsKTtcbiAgfVxuICAubWF4LXctN3hsIHtcbiAgICBtYXgtd2lkdGg6IHZhcigtLWNvbnRhaW5lci03eGwpO1xuICB9XG4gIC5tYXgtdy1mdWxsIHtcbiAgICBtYXgtd2lkdGg6IDEwMCU7XG4gIH1cbiAgLm1heC13LW1kIHtcbiAgICBtYXgtd2lkdGg6IHZhcigtLWNvbnRhaW5lci1tZCk7XG4gIH1cbiAgLmZsZXgtZ3JvdyB7XG4gICAgZmxleC1ncm93OiAxO1xuICB9XG4gIC5ib3JkZXItY29sbGFwc2Uge1xuICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG4gIH1cbiAgLi10cmFuc2xhdGUteS0xXFxcXC8yIHtcbiAgICAtLXR3LXRyYW5zbGF0ZS15OiBjYWxjKGNhbGMoMS8yICogMTAwJSkgKiAtMSk7XG4gICAgdHJhbnNsYXRlOiB2YXIoLS10dy10cmFuc2xhdGUteCkgdmFyKC0tdHctdHJhbnNsYXRlLXkpO1xuICB9XG4gIC5cXFxcIXRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtOiB2YXIoLS10dy1yb3RhdGUteCkgdmFyKC0tdHctcm90YXRlLXkpIHZhcigtLXR3LXJvdGF0ZS16KSB2YXIoLS10dy1za2V3LXgpIHZhcigtLXR3LXNrZXcteSkgIWltcG9ydGFudDtcbiAgfVxuICAudHJhbnNmb3JtIHtcbiAgICB0cmFuc2Zvcm06IHZhcigtLXR3LXJvdGF0ZS14KSB2YXIoLS10dy1yb3RhdGUteSkgdmFyKC0tdHctcm90YXRlLXopIHZhcigtLXR3LXNrZXcteCkgdmFyKC0tdHctc2tldy15KTtcbiAgfVxuICAuXFxcXCFjdXJzb3Itbm90LWFsbG93ZWQge1xuICAgIGN1cnNvcjogbm90LWFsbG93ZWQgIWltcG9ydGFudDtcbiAgfVxuICAuY3Vyc29yLW5vdC1hbGxvd2VkIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkO1xuICB9XG4gIC5jdXJzb3ItcG9pbnRlciB7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICB9XG4gIC5yZXNpemUge1xuICAgIHJlc2l6ZTogYm90aDtcbiAgfVxuICAucmVzaXplLXkge1xuICAgIHJlc2l6ZTogdmVydGljYWw7XG4gIH1cbiAgLmdyaWQtY29scy0zIHtcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCBtaW5tYXgoMCwgMWZyKSk7XG4gIH1cbiAgLmdyaWQtY29scy1cXFxcWzFmcl8yZnJfMTAwcHhcXFxcXSB7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiAxZnIgMmZyIDEwMHB4O1xuICB9XG4gIC5mbGV4LWNvbCB7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgfVxuICAuZmxleC13cmFwIHtcbiAgICBmbGV4LXdyYXA6IHdyYXA7XG4gIH1cbiAgLlxcXFwhaXRlbXMtY2VudGVyIHtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyICFpbXBvcnRhbnQ7XG4gIH1cbiAgLml0ZW1zLWNlbnRlciB7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgfVxuICAuXFxcXCFqdXN0aWZ5LWNlbnRlciB7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXIgIWltcG9ydGFudDtcbiAgfVxuICAuanVzdGlmeS1iZXR3ZWVuIHtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gIH1cbiAgLmp1c3RpZnktY2VudGVyIHtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgfVxuICAuXFxcXCFnYXAtMiB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMikgIWltcG9ydGFudDtcbiAgfVxuICAuZ2FwLTEge1xuICAgIGdhcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICB9XG4gIC5nYXAtMVxcXFwuNSB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMS41KTtcbiAgfVxuICAuZ2FwLTIge1xuICAgIGdhcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpO1xuICB9XG4gIC5nYXAtMlxcXFwuNSB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMi41KTtcbiAgfVxuICAuZ2FwLTMge1xuICAgIGdhcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDMpO1xuICB9XG4gIC5nYXAtNCB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLmdhcC01IHtcbiAgICBnYXA6IGNhbGModmFyKC0tc3BhY2luZykgKiA1KTtcbiAgfVxuICAuZ2FwLTYge1xuICAgIGdhcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpO1xuICB9XG4gIC5nYXAtOCB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogOCk7XG4gIH1cbiAgLnNwYWNlLXktMSB7XG4gICAgOndoZXJlKCYgPiA6bm90KDpsYXN0LWNoaWxkKSkge1xuICAgICAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XG4gICAgICBtYXJnaW4tYmxvY2stZW5kOiBjYWxjKGNhbGModmFyKC0tc3BhY2luZykgKiAxKSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcbiAgICB9XG4gIH1cbiAgLnNwYWNlLXktMiB7XG4gICAgOndoZXJlKCYgPiA6bm90KDpsYXN0LWNoaWxkKSkge1xuICAgICAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XG4gICAgICBtYXJnaW4tYmxvY2stZW5kOiBjYWxjKGNhbGModmFyKC0tc3BhY2luZykgKiAyKSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcbiAgICB9XG4gIH1cbiAgLnNwYWNlLXktNCB7XG4gICAgOndoZXJlKCYgPiA6bm90KDpsYXN0LWNoaWxkKSkge1xuICAgICAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XG4gICAgICBtYXJnaW4tYmxvY2stZW5kOiBjYWxjKGNhbGModmFyKC0tc3BhY2luZykgKiA0KSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcbiAgICB9XG4gIH1cbiAgLnNwYWNlLXktNiB7XG4gICAgOndoZXJlKCYgPiA6bm90KDpsYXN0LWNoaWxkKSkge1xuICAgICAgLS10dy1zcGFjZS15LXJldmVyc2U6IDA7XG4gICAgICBtYXJnaW4tYmxvY2stc3RhcnQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpICogdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSk7XG4gICAgICBtYXJnaW4tYmxvY2stZW5kOiBjYWxjKGNhbGModmFyKC0tc3BhY2luZykgKiA2KSAqIGNhbGMoMSAtIHZhcigtLXR3LXNwYWNlLXktcmV2ZXJzZSkpKTtcbiAgICB9XG4gIH1cbiAgLnNlbGYtc3RhcnQge1xuICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gIH1cbiAgLm92ZXJmbG93LWF1dG8ge1xuICAgIG92ZXJmbG93OiBhdXRvO1xuICB9XG4gIC5vdmVyZmxvdy1oaWRkZW4ge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIH1cbiAgLm92ZXJmbG93LXktYXV0byB7XG4gICAgb3ZlcmZsb3cteTogYXV0bztcbiAgfVxuICAuXFxcXCFyb3VuZGVkLWZ1bGwge1xuICAgIGJvcmRlci1yYWRpdXM6IGNhbGMoaW5maW5pdHkgKiAxcHgpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLnJvdW5kZWQge1xuICAgIGJvcmRlci1yYWRpdXM6IDAuMjVyZW07XG4gIH1cbiAgLnJvdW5kZWQtM3hsIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1yYWRpdXMtM3hsKTtcbiAgfVxuICAucm91bmRlZC00eGwge1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy00eGwpO1xuICB9XG4gIC5yb3VuZGVkLWZ1bGwge1xuICAgIGJvcmRlci1yYWRpdXM6IGNhbGMoaW5maW5pdHkgKiAxcHgpO1xuICB9XG4gIC5yb3VuZGVkLWxnIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1yYWRpdXMtbGcpO1xuICB9XG4gIC5yb3VuZGVkLW1kIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1yYWRpdXMtbWQpO1xuICB9XG4gIC5yb3VuZGVkLXhsIHtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1yYWRpdXMteGwpO1xuICB9XG4gIC5yb3VuZGVkLWwtbWQge1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IHZhcigtLXJhZGl1cy1tZCk7XG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcbiAgfVxuICAucm91bmRlZC1yLW1kIHtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcbiAgICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcbiAgfVxuICAuXFxcXCFib3JkZXIge1xuICAgIGJvcmRlci1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKSAhaW1wb3J0YW50O1xuICAgIGJvcmRlci13aWR0aDogMXB4ICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmJvcmRlciB7XG4gICAgYm9yZGVyLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xuICAgIGJvcmRlci13aWR0aDogMXB4O1xuICB9XG4gIC5ib3JkZXItMCB7XG4gICAgYm9yZGVyLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xuICAgIGJvcmRlci13aWR0aDogMHB4O1xuICB9XG4gIC5ib3JkZXItMiB7XG4gICAgYm9yZGVyLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xuICAgIGJvcmRlci13aWR0aDogMnB4O1xuICB9XG4gIC5ib3JkZXItdCB7XG4gICAgYm9yZGVyLXRvcC1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcbiAgICBib3JkZXItdG9wLXdpZHRoOiAxcHg7XG4gIH1cbiAgLmJvcmRlci10LTIge1xuICAgIGJvcmRlci10b3Atc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XG4gICAgYm9yZGVyLXRvcC13aWR0aDogMnB4O1xuICB9XG4gIC5ib3JkZXItci0wIHtcbiAgICBib3JkZXItcmlnaHQtc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAwcHg7XG4gIH1cbiAgLmJvcmRlci1iLTIge1xuICAgIGJvcmRlci1ib3R0b20tc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XG4gICAgYm9yZGVyLWJvdHRvbS13aWR0aDogMnB4O1xuICB9XG4gIC5ib3JkZXItbC00IHtcbiAgICBib3JkZXItbGVmdC1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcbiAgICBib3JkZXItbGVmdC13aWR0aDogNHB4O1xuICB9XG4gIC5ib3JkZXItZGFzaGVkIHtcbiAgICAtLXR3LWJvcmRlci1zdHlsZTogZGFzaGVkO1xuICAgIGJvcmRlci1zdHlsZTogZGFzaGVkO1xuICB9XG4gIC5ib3JkZXItbm9uZSB7XG4gICAgLS10dy1ib3JkZXItc3R5bGU6IG5vbmU7XG4gICAgYm9yZGVyLXN0eWxlOiBub25lO1xuICB9XG4gIC5cXFxcIWJvcmRlci13aGl0ZSB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSkgIWltcG9ydGFudDtcbiAgfVxuICAuYm9yZGVyLVxcXFxbcmdiYVxcXFwoMjU1XFxcXCwyNTVcXFxcLDI1NVxcXFwsMFxcXFwuMVxcXFwpXFxcXF0ge1xuICAgIGJvcmRlci1jb2xvcjogcmdiYSgyNTUsMjU1LDI1NSwwLjEpO1xuICB9XG4gIC5ib3JkZXItXFxcXFtyZ2JhXFxcXCgyNTVcXFxcLDI1NVxcXFwsMjU1XFxcXCwwXFxcXC4yXFxcXClcXFxcXSB7XG4gICAgYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwyNTUsMjU1LDAuMik7XG4gIH1cbiAgLmJvcmRlci1cXFxcW3ZhclxcXFwoLS1jb2xvci1ib3JkZXJcXFxcKVxcXFxdIHtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJvcmRlcik7XG4gIH1cbiAgLmJvcmRlci1cXFxcW3ZhclxcXFwoLS1jb2xvci1ib3JkZXItYWN0aXZlXFxcXClcXFxcXSB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1ib3JkZXItYWN0aXZlKTtcbiAgfVxuICAuYm9yZGVyLWJsdWUtNTAwIHtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcbiAgfVxuICAuYm9yZGVyLWJvcmRlciB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1ib3JkZXIpO1xuICB9XG4gIC5ib3JkZXItYm9yZGVyLWFjdGl2ZSB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1ib3JkZXItYWN0aXZlKTtcbiAgfVxuICAuYm9yZGVyLWN1cnJlbnQge1xuICAgIGJvcmRlci1jb2xvcjogY3VycmVudENvbG9yO1xuICB9XG4gIC5ib3JkZXItd2hpdGUge1xuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3Itd2hpdGUpO1xuICB9XG4gIC5ib3JkZXItd2hpdGVcXFxcLzIwIHtcbiAgICBib3JkZXItY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDIwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC5cXFxcIWJnLVxcXFxbdmFyXFxcXCgtLWNvbG9yLWJnLWFjdGl2ZVxcXFwpXFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJnLWFjdGl2ZSkgIWltcG9ydGFudDtcbiAgfVxuICAuXFxcXCFiZy10cmFuc3BhcmVudCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbiAgfVxuICAuXFxcXCFiZy13aGl0ZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3Itd2hpdGUpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmJnLVxcXFxbXFxcXCMwNTEwMjNcXFxcXSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzA1MTAyMztcbiAgfVxuICAuYmctXFxcXFtcXFxcIzA1MTAyM1xcXFxdXFxcXC8yMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCAjMDUxMDIzIDIwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC5iZy1cXFxcW1xcXFwjZjZmNmY2XFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNmY2ZjY7XG4gIH1cbiAgLmJnLVxcXFxbcmdiYVxcXFwoMjU1XFxcXCwyNTVcXFxcLDI1NVxcXFwsMFxcXFwuMVxcXFwpXFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC4xKTtcbiAgfVxuICAuYmctXFxcXFtyZ2JhXFxcXCgyNTVcXFxcLDI1NVxcXFwsMjU1XFxcXCwwXFxcXC4xNVxcXFwpXFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LDI1NSwyNTUsMC4xNSk7XG4gIH1cbiAgLmJnLVxcXFxbdmFyXFxcXCgtLWNvbG9yLWJnLWFjdGl2ZVxcXFwpXFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJnLWFjdGl2ZSk7XG4gIH1cbiAgLmJnLVxcXFxbdmFyXFxcXCgtLWNvbG9yLWJnLWNhcmRcXFxcKVxcXFxdIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1iZy1jYXJkKTtcbiAgfVxuICAuYmctXFxcXFt2YXJcXFxcKC0tY29sb3ItYmctZGFya1xcXFwpXFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJnLWRhcmspO1xuICB9XG4gIC5iZy1ibGFjayB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmxhY2spO1xuICB9XG4gIC5iZy1ibGFja1xcXFwvMjAge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3ItYmxhY2spIDIwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC5iZy1ibHVlLTUwMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmx1ZS01MDApO1xuICB9XG4gIC5iZy1ibHVlLTUwMFxcXFwvMjAge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3ItYmx1ZS01MDApIDIwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC5iZy1ibHVlLTYwMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmx1ZS02MDApO1xuICB9XG4gIC5iZy1wcmltYXJ5LXR3IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1wcmltYXJ5LXR3KTtcbiAgfVxuICAuYmctcmVkLTUwMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItcmVkLTUwMCk7XG4gIH1cbiAgLmJnLXRyYW5zcGFyZW50IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgfVxuICAuYmctd2hpdGUge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLXdoaXRlKTtcbiAgfVxuICAuYmctd2hpdGVcXFxcLzUge1xuICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDUlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgLmJnLXdoaXRlXFxcXC8xMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgMTAlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgLmJnLXdoaXRlXFxcXC8yMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgMjAlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgLmJnLWdyYWRpZW50LXRvLWIge1xuICAgIC0tdHctZ3JhZGllbnQtcG9zaXRpb246IHRvIGJvdHRvbSBpbiBva2xhYjtcbiAgICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodmFyKC0tdHctZ3JhZGllbnQtc3RvcHMpKTtcbiAgfVxuICAuYmctZ3JhZGllbnQtdG8tciB7XG4gICAgLS10dy1ncmFkaWVudC1wb3NpdGlvbjogdG8gcmlnaHQgaW4gb2tsYWI7XG4gICAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHZhcigtLXR3LWdyYWRpZW50LXN0b3BzKSk7XG4gIH1cbiAgLmZyb20tXFxcXFtyZ2JhXFxcXCgzMFxcXFwsMzBcXFxcLDYwXFxcXCwwXFxcXC43XFxcXClcXFxcXSB7XG4gICAgLS10dy1ncmFkaWVudC1mcm9tOiByZ2JhKDMwLDMwLDYwLDAuNyk7XG4gICAgLS10dy1ncmFkaWVudC1zdG9wczogdmFyKC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzLCB2YXIoLS10dy1ncmFkaWVudC1wb3NpdGlvbiksIHZhcigtLXR3LWdyYWRpZW50LWZyb20pIHZhcigtLXR3LWdyYWRpZW50LWZyb20tcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC10bykgdmFyKC0tdHctZ3JhZGllbnQtdG8tcG9zaXRpb24pKTtcbiAgfVxuICAuZnJvbS1cXFxcW3ZhclxcXFwoLS1jb2xvci1saWdodFxcXFwpXFxcXF0ge1xuICAgIC0tdHctZ3JhZGllbnQtZnJvbTogdmFyKC0tY29sb3ItbGlnaHQpO1xuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XG4gIH1cbiAgLnRvLVxcXFxbcmdiYVxcXFwoMjBcXFxcLDIwXFxcXCw0MFxcXFwsMFxcXFwuN1xcXFwpXFxcXF0ge1xuICAgIC0tdHctZ3JhZGllbnQtdG86IHJnYmEoMjAsMjAsNDAsMC43KTtcbiAgICAtLXR3LWdyYWRpZW50LXN0b3BzOiB2YXIoLS10dy1ncmFkaWVudC12aWEtc3RvcHMsIHZhcigtLXR3LWdyYWRpZW50LXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtZnJvbSkgdmFyKC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiksIHZhcigtLXR3LWdyYWRpZW50LXRvKSB2YXIoLS10dy1ncmFkaWVudC10by1wb3NpdGlvbikpO1xuICB9XG4gIC50by13aGl0ZSB7XG4gICAgLS10dy1ncmFkaWVudC10bzogdmFyKC0tY29sb3Itd2hpdGUpO1xuICAgIC0tdHctZ3JhZGllbnQtc3RvcHM6IHZhcigtLXR3LWdyYWRpZW50LXZpYS1zdG9wcywgdmFyKC0tdHctZ3JhZGllbnQtcG9zaXRpb24pLCB2YXIoLS10dy1ncmFkaWVudC1mcm9tKSB2YXIoLS10dy1ncmFkaWVudC1mcm9tLXBvc2l0aW9uKSwgdmFyKC0tdHctZ3JhZGllbnQtdG8pIHZhcigtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uKSk7XG4gIH1cbiAgLmJnLWNsaXAtdGV4dCB7XG4gICAgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xuICB9XG4gIC5vYmplY3QtY29udGFpbiB7XG4gICAgb2JqZWN0LWZpdDogY29udGFpbjtcbiAgfVxuICAub2JqZWN0LWNvdmVyIHtcbiAgICBvYmplY3QtZml0OiBjb3ZlcjtcbiAgfVxuICAuXFxcXCFwLTIge1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc3BhY2luZykgKiAyKSAhaW1wb3J0YW50O1xuICB9XG4gIC5wLTEge1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc3BhY2luZykgKiAxKTtcbiAgfVxuICAucC0zIHtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMyk7XG4gIH1cbiAgLnAtNCB7XG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5wLTUge1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc3BhY2luZykgKiA1KTtcbiAgfVxuICAucC02IHtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNik7XG4gIH1cbiAgLnAtOCB7XG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDgpO1xuICB9XG4gIC5wLTEyIHtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMTIpO1xuICB9XG4gIC5weC0yIHtcbiAgICBwYWRkaW5nLWlubGluZTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpO1xuICB9XG4gIC5weC0zIHtcbiAgICBwYWRkaW5nLWlubGluZTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDMpO1xuICB9XG4gIC5weC00IHtcbiAgICBwYWRkaW5nLWlubGluZTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5weC01IHtcbiAgICBwYWRkaW5nLWlubGluZTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDUpO1xuICB9XG4gIC5weC02IHtcbiAgICBwYWRkaW5nLWlubGluZTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpO1xuICB9XG4gIC5weS0xIHtcbiAgICBwYWRkaW5nLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMSk7XG4gIH1cbiAgLnB5LTFcXFxcLjUge1xuICAgIHBhZGRpbmctYmxvY2s6IGNhbGModmFyKC0tc3BhY2luZykgKiAxLjUpO1xuICB9XG4gIC5weS0yIHtcbiAgICBwYWRkaW5nLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMik7XG4gIH1cbiAgLnB5LTMge1xuICAgIHBhZGRpbmctYmxvY2s6IGNhbGModmFyKC0tc3BhY2luZykgKiAzKTtcbiAgfVxuICAucHktOCB7XG4gICAgcGFkZGluZy1ibG9jazogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDgpO1xuICB9XG4gIC5weS0xMiB7XG4gICAgcGFkZGluZy1ibG9jazogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEyKTtcbiAgfVxuICAucHktXFxcXFswXFxcXC4xMjVyZW1cXFxcXSB7XG4gICAgcGFkZGluZy1ibG9jazogMC4xMjVyZW07XG4gIH1cbiAgLnB0LTQge1xuICAgIHBhZGRpbmctdG9wOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLnByLTEwIHtcbiAgICBwYWRkaW5nLXJpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMTApO1xuICB9XG4gIC5wbC0xMCB7XG4gICAgcGFkZGluZy1sZWZ0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMTApO1xuICB9XG4gIC50ZXh0LWNlbnRlciB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG4gIC5mb250LW1vbm8ge1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LW1vbm8pO1xuICB9XG4gIC5cXFxcIXRleHQtc20ge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tdGV4dC1zbSkgIWltcG9ydGFudDtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tdHctbGVhZGluZywgdmFyKC0tdGV4dC1zbS0tbGluZS1oZWlnaHQpKSAhaW1wb3J0YW50O1xuICB9XG4gIC50ZXh0LTJ4bCB7XG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LTJ4bCk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtMnhsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LTN4bCB7XG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LTN4bCk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtM3hsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LTd4bCB7XG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LTd4bCk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtN3hsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LWJhc2Uge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tdGV4dC1iYXNlKTtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tdHctbGVhZGluZywgdmFyKC0tdGV4dC1iYXNlLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LWxnIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQtbGcpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LWxnLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LXNtIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQtc20pO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXNtLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LXhsIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQteGwpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXhsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LXhzIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQteHMpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXhzLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LVxcXFxbMFxcXFwuODc1cmVtXFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMC44NzVyZW07XG4gIH1cbiAgLnRleHQtXFxcXFsxXFxcXC4yNXJlbVxcXFxdIHtcbiAgICBmb250LXNpemU6IDEuMjVyZW07XG4gIH1cbiAgLnRleHQtXFxcXFsycmVtXFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMnJlbTtcbiAgfVxuICAuXFxcXCFmb250LWJvbGQge1xuICAgIC0tdHctZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpICFpbXBvcnRhbnQ7XG4gICAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmZvbnQtYm9sZCB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtYm9sZCk7XG4gICAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpO1xuICB9XG4gIC5mb250LW1lZGl1bSB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtbWVkaXVtKTtcbiAgICBmb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtbWVkaXVtKTtcbiAgfVxuICAuZm9udC1zZW1pYm9sZCB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtc2VtaWJvbGQpO1xuICAgIGZvbnQtd2VpZ2h0OiB2YXIoLS1mb250LXdlaWdodC1zZW1pYm9sZCk7XG4gIH1cbiAgLmZvbnQtdGhpbiB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtdGhpbik7XG4gICAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LXRoaW4pO1xuICB9XG4gIC5icmVhay1hbGwge1xuICAgIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDtcbiAgfVxuICAudGV4dC1lbGxpcHNpcyB7XG4gICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gIH1cbiAgLndoaXRlc3BhY2UtcHJlLXdyYXAge1xuICAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgfVxuICAuXFxcXCF0ZXh0LWJsYWNrIHtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItYmxhY2spICFpbXBvcnRhbnQ7XG4gIH1cbiAgLlxcXFwhdGV4dC1saWdodCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWxpZ2h0KSAhaW1wb3J0YW50O1xuICB9XG4gIC5cXFxcIXRleHQtcHJpbWFyeS10dyB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXByaW1hcnktdHcpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLlxcXFwhdGV4dC13aGl0ZSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXdoaXRlKSAhaW1wb3J0YW50O1xuICB9XG4gIC5cXFxcIXRleHQtd2hpdGVcXFxcLzgwIHtcbiAgICBjb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgODAlLCB0cmFuc3BhcmVudCkgIWltcG9ydGFudDtcbiAgfVxuICAudGV4dC1cXFxcW1xcXFwjQzNENUY3XFxcXF0ge1xuICAgIGNvbG9yOiAjQzNENUY3O1xuICB9XG4gIC50ZXh0LVxcXFxbdmFyXFxcXCgtLWNvbG9yLWxpZ2h0XFxcXClcXFxcXSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWxpZ2h0KTtcbiAgfVxuICAudGV4dC1cXFxcW3ZhclxcXFwoLS1jb2xvci1wcmltYXJ5LXR3XFxcXClcXFxcXSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXByaW1hcnktdHcpO1xuICB9XG4gIC50ZXh0LVxcXFxbdmFyXFxcXCgtLWNvbG9yLXRleHQtc2Vjb25kYXJ5XFxcXClcXFxcXSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KTtcbiAgfVxuICAudGV4dC1ibGFjayB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsYWNrKTtcbiAgfVxuICAudGV4dC1ibHVlLTQwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNDAwKTtcbiAgfVxuICAudGV4dC1ibHVlLTUwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcbiAgfVxuICAudGV4dC1ncmF5LTEwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMTAwKTtcbiAgfVxuICAudGV4dC1ncmF5LTIwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMjAwKTtcbiAgfVxuICAudGV4dC1ncmF5LTUwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNTAwKTtcbiAgfVxuICAudGV4dC1saWdodCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWxpZ2h0KTtcbiAgfVxuICAudGV4dC1yZWQtNDAwIHtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItcmVkLTQwMCk7XG4gIH1cbiAgLnRleHQtcmVkLTUwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXJlZC01MDApO1xuICB9XG4gIC50ZXh0LXJlZC02MDAge1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNjAwKTtcbiAgfVxuICAudGV4dC10ZXh0LXNlY29uZGFyeSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXRleHQtc2Vjb25kYXJ5KTtcbiAgfVxuICAudGV4dC10cmFuc3BhcmVudCB7XG4gICAgY29sb3I6IHRyYW5zcGFyZW50O1xuICB9XG4gIC50ZXh0LXdoaXRlIHtcbiAgICBjb2xvcjogdmFyKC0tY29sb3Itd2hpdGUpO1xuICB9XG4gIC50ZXh0LXdoaXRlXFxcXC82MCB7XG4gICAgY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDYwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC50ZXh0LXdoaXRlXFxcXC84MCB7XG4gICAgY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDgwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC5sb3dlcmNhc2Uge1xuICAgIHRleHQtdHJhbnNmb3JtOiBsb3dlcmNhc2U7XG4gIH1cbiAgLml0YWxpYyB7XG4gICAgZm9udC1zdHlsZTogaXRhbGljO1xuICB9XG4gIC51bmRlcmxpbmUge1xuICAgIHRleHQtZGVjb3JhdGlvbi1saW5lOiB1bmRlcmxpbmU7XG4gIH1cbiAgLlxcXFwhb3BhY2l0eS01MCB7XG4gICAgb3BhY2l0eTogNTAlICFpbXBvcnRhbnQ7XG4gIH1cbiAgLm9wYWNpdHktMCB7XG4gICAgb3BhY2l0eTogMCU7XG4gIH1cbiAgLnNoYWRvdyB7XG4gICAgLS10dy1zaGFkb3c6IDAgMXB4IDNweCAwIHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSksIDAgMXB4IDJweCAtMXB4IHZhcigtLXR3LXNoYWRvdy1jb2xvciwgcmdiKDAgMCAwIC8gMC4xKSk7XG4gICAgYm94LXNoYWRvdzogdmFyKC0tdHctaW5zZXQtc2hhZG93KSwgdmFyKC0tdHctaW5zZXQtcmluZy1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLW9mZnNldC1zaGFkb3cpLCB2YXIoLS10dy1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXNoYWRvdyk7XG4gIH1cbiAgLnNoYWRvdy1sZyB7XG4gICAgLS10dy1zaGFkb3c6IDAgMTBweCAxNXB4IC0zcHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKSwgMCA0cHggNnB4IC00cHggdmFyKC0tdHctc2hhZG93LWNvbG9yLCByZ2IoMCAwIDAgLyAwLjEpKTtcbiAgICBib3gtc2hhZG93OiB2YXIoLS10dy1pbnNldC1zaGFkb3cpLCB2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93KTtcbiAgfVxuICAub3V0bGluZSB7XG4gICAgb3V0bGluZS1zdHlsZTogdmFyKC0tdHctb3V0bGluZS1zdHlsZSk7XG4gICAgb3V0bGluZS13aWR0aDogMXB4O1xuICB9XG4gIC5ibHVyIHtcbiAgICAtLXR3LWJsdXI6IGJsdXIoOHB4KTtcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIsKSB2YXIoLS10dy1icmlnaHRuZXNzLCkgdmFyKC0tdHctY29udHJhc3QsKSB2YXIoLS10dy1ncmF5c2NhbGUsKSB2YXIoLS10dy1odWUtcm90YXRlLCkgdmFyKC0tdHctaW52ZXJ0LCkgdmFyKC0tdHctc2F0dXJhdGUsKSB2YXIoLS10dy1zZXBpYSwpIHZhcigtLXR3LWRyb3Atc2hhZG93LCk7XG4gIH1cbiAgLmRyb3Atc2hhZG93IHtcbiAgICAtLXR3LWRyb3Atc2hhZG93OiBkcm9wLXNoYWRvdygwIDFweCAycHggcmdiKDAgMCAwIC8gMC4xKSkgZHJvcC1zaGFkb3coIDAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA2KSk7XG4gICAgZmlsdGVyOiB2YXIoLS10dy1ibHVyLCkgdmFyKC0tdHctYnJpZ2h0bmVzcywpIHZhcigtLXR3LWNvbnRyYXN0LCkgdmFyKC0tdHctZ3JheXNjYWxlLCkgdmFyKC0tdHctaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWludmVydCwpIHZhcigtLXR3LXNhdHVyYXRlLCkgdmFyKC0tdHctc2VwaWEsKSB2YXIoLS10dy1kcm9wLXNoYWRvdywpO1xuICB9XG4gIC5maWx0ZXIge1xuICAgIGZpbHRlcjogdmFyKC0tdHctYmx1ciwpIHZhcigtLXR3LWJyaWdodG5lc3MsKSB2YXIoLS10dy1jb250cmFzdCwpIHZhcigtLXR3LWdyYXlzY2FsZSwpIHZhcigtLXR3LWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1pbnZlcnQsKSB2YXIoLS10dy1zYXR1cmF0ZSwpIHZhcigtLXR3LXNlcGlhLCkgdmFyKC0tdHctZHJvcC1zaGFkb3csKTtcbiAgfVxuICAuYmFja2Ryb3AtYmx1ci1cXFxcWzJweFxcXFxdIHtcbiAgICAtLXR3LWJhY2tkcm9wLWJsdXI6IGJsdXIoMnB4KTtcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xuICB9XG4gIC5iYWNrZHJvcC1ibHVyLVxcXFxbMTBweFxcXFxdIHtcbiAgICAtLXR3LWJhY2tkcm9wLWJsdXI6IGJsdXIoMTBweCk7XG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIsKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzLCkgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUsKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlLCkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSwpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlLCkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIsKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzLCkgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUsKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlLCkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSwpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlLCkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKTtcbiAgfVxuICAuYmFja2Ryb3AtYmx1ci14bCB7XG4gICAgLS10dy1iYWNrZHJvcC1ibHVyOiBibHVyKHZhcigtLWJsdXIteGwpKTtcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xuICB9XG4gIC5iYWNrZHJvcC1maWx0ZXIge1xuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XG4gIH1cbiAgLlxcXFwhdHJhbnNpdGlvbi1jb2xvcnMge1xuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIG91dGxpbmUtY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCAtLXR3LWdyYWRpZW50LWZyb20sIC0tdHctZ3JhZGllbnQtdmlhLCAtLXR3LWdyYWRpZW50LXRvICFpbXBvcnRhbnQ7XG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLXR3LWVhc2UsIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pKSAhaW1wb3J0YW50O1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IHZhcigtLXR3LWR1cmF0aW9uLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb24pKSAhaW1wb3J0YW50O1xuICB9XG4gIC50cmFuc2l0aW9uIHtcbiAgICB0cmFuc2l0aW9uLXByb3BlcnR5OiBjb2xvciwgYmFja2dyb3VuZC1jb2xvciwgYm9yZGVyLWNvbG9yLCBvdXRsaW5lLWNvbG9yLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGZpbGwsIHN0cm9rZSwgLS10dy1ncmFkaWVudC1mcm9tLCAtLXR3LWdyYWRpZW50LXZpYSwgLS10dy1ncmFkaWVudC10bywgb3BhY2l0eSwgYm94LXNoYWRvdywgdHJhbnNmb3JtLCB0cmFuc2xhdGUsIHNjYWxlLCByb3RhdGUsIGZpbHRlciwgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXIsIGJhY2tkcm9wLWZpbHRlcjtcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tdHctZWFzZSwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbikpO1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IHZhcigtLXR3LWR1cmF0aW9uLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb24pKTtcbiAgfVxuICAudHJhbnNpdGlvbi1hbGwge1xuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IGFsbDtcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tdHctZWFzZSwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbikpO1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IHZhcigtLXR3LWR1cmF0aW9uLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tZHVyYXRpb24pKTtcbiAgfVxuICAudHJhbnNpdGlvbi1jb2xvcnMge1xuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIG91dGxpbmUtY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCAtLXR3LWdyYWRpZW50LWZyb20sIC0tdHctZ3JhZGllbnQtdmlhLCAtLXR3LWdyYWRpZW50LXRvO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS10dy1lYXNlLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSk7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHctZHVyYXRpb24sIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpO1xuICB9XG4gIC5cXFxcIWR1cmF0aW9uLTMwMCB7XG4gICAgLS10dy1kdXJhdGlvbjogMzAwbXMgIWltcG9ydGFudDtcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiAzMDBtcyAhaW1wb3J0YW50O1xuICB9XG4gIC5kdXJhdGlvbi0yMDAge1xuICAgIC0tdHctZHVyYXRpb246IDIwMG1zO1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDIwMG1zO1xuICB9XG4gIC5kdXJhdGlvbi0zMDAge1xuICAgIC0tdHctZHVyYXRpb246IDMwMG1zO1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDMwMG1zO1xuICB9XG4gIC5lYXNlLWluIHtcbiAgICAtLXR3LWVhc2U6IHZhcigtLWVhc2UtaW4pO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1lYXNlLWluKTtcbiAgfVxuICAuZWFzZS1pbi1vdXQge1xuICAgIC0tdHctZWFzZTogdmFyKC0tZWFzZS1pbi1vdXQpO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1lYXNlLWluLW91dCk7XG4gIH1cbiAgLmVhc2Utb3V0IHtcbiAgICAtLXR3LWVhc2U6IHZhcigtLWVhc2Utb3V0KTtcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tZWFzZS1vdXQpO1xuICB9XG4gIC5wbGFjZWhvbGRlclxcXFw6dGV4dC13aGl0ZVxcXFwvNDAge1xuICAgICY6OnBsYWNlaG9sZGVyIHtcbiAgICAgIGNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSA0MCUsIHRyYW5zcGFyZW50KTtcbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDotdHJhbnNsYXRlLXktMFxcXFwuNSB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICAtLXR3LXRyYW5zbGF0ZS15OiBjYWxjKHZhcigtLXNwYWNpbmcpICogLTAuNSk7XG4gICAgICAgIHRyYW5zbGF0ZTogdmFyKC0tdHctdHJhbnNsYXRlLXgpIHZhcigtLXR3LXRyYW5zbGF0ZS15KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDotdHJhbnNsYXRlLXktMVxcXFwuNSB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICAtLXR3LXRyYW5zbGF0ZS15OiBjYWxjKHZhcigtLXNwYWNpbmcpICogLTEuNSk7XG4gICAgICAgIHRyYW5zbGF0ZTogdmFyKC0tdHctdHJhbnNsYXRlLXgpIHZhcigtLXR3LXRyYW5zbGF0ZS15KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDp0cmFuc2Zvcm0ge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgdHJhbnNmb3JtOiB2YXIoLS10dy1yb3RhdGUteCkgdmFyKC0tdHctcm90YXRlLXkpIHZhcigtLXR3LXJvdGF0ZS16KSB2YXIoLS10dy1za2V3LXgpIHZhcigtLXR3LXNrZXcteSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6XFxcXCFiZy10cmFuc3BhcmVudCB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOlxcXFwhYmctd2hpdGVcXFxcLzEwIHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDEwJSwgdHJhbnNwYXJlbnQpICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6YmctXFxcXFtyZ2JhXFxcXCgyNTVcXFxcLDI1NVxcXFwsMjU1XFxcXCwwXFxcXC4xXFxcXClcXFxcXSB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwyNTUsMjU1LDAuMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6YmctXFxcXFt2YXJcXFxcKC0tY29sb3ItYmctaG92ZXJcXFxcKVxcXFxdIHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJnLWhvdmVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDpiZy1ibHVlLTcwMCB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTcwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6YmctcmVkLTUwMFxcXFwvMTAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci1yZWQtNTAwKSAxMCUsIHRyYW5zcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDpiZy13aGl0ZVxcXFwvMTAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgMTAlLCB0cmFuc3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6XFxcXCF0ZXh0LXdoaXRlIHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSkgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDp0ZXh0LWJsdWUtMzAwIHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTMwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6dGV4dC1ncmF5LTIwMCB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICBjb2xvcjogdmFyKC0tY29sb3ItZ3JheS0yMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOm9wYWNpdHktODAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgb3BhY2l0eTogODAlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOnNoYWRvdy1sZyB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICAtLXR3LXNoYWRvdzogMCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpLCAwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpO1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS10dy1pbnNldC1zaGFkb3cpLCB2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmZvY3VzXFxcXDpib3JkZXItYmx1ZS00MDAge1xuICAgICY6Zm9jdXMge1xuICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTQwMCk7XG4gICAgfVxuICB9XG4gIC5mb2N1c1xcXFw6cmluZy0yIHtcbiAgICAmOmZvY3VzIHtcbiAgICAgIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQsKSAwIDAgMCBjYWxjKDJweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvciwgY3VycmVudENvbG9yKTtcbiAgICAgIGJveC1zaGFkb3c6IHZhcigtLXR3LWluc2V0LXNoYWRvdyksIHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSwgdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3cpO1xuICAgIH1cbiAgfVxuICAuZm9jdXNcXFxcOnJpbmctXFxcXFtcXFxcIzQ0N0JGNFxcXFxdIHtcbiAgICAmOmZvY3VzIHtcbiAgICAgIC0tdHctcmluZy1jb2xvcjogIzQ0N0JGNDtcbiAgICB9XG4gIH1cbiAgLmZvY3VzXFxcXDpvdXRsaW5lLW5vbmUge1xuICAgICY6Zm9jdXMge1xuICAgICAgLS10dy1vdXRsaW5lLXN0eWxlOiBub25lO1xuICAgICAgb3V0bGluZS1zdHlsZTogbm9uZTtcbiAgICB9XG4gIH1cbiAgLmRpc2FibGVkXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQge1xuICAgICY6ZGlzYWJsZWQge1xuICAgICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgICB9XG4gIH1cbiAgLmRpc2FibGVkXFxcXDpvcGFjaXR5LTUwIHtcbiAgICAmOmRpc2FibGVkIHtcbiAgICAgIG9wYWNpdHk6IDUwJTtcbiAgICB9XG4gIH1cbiAgLnNtXFxcXDpncmlkLWNvbHMtMSB7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0MHJlbSkge1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xuICAgIH1cbiAgfVxuICAubWRcXFxcOm9yZGVyLWZpcnN0IHtcbiAgICBAbWVkaWEgKHdpZHRoID49IDQ4cmVtKSB7XG4gICAgICBvcmRlcjogY2FsYygtaW5maW5pdHkpO1xuICAgIH1cbiAgfVxuICAubWRcXFxcOmgtXFxcXFsxNTBweFxcXFxdIHtcbiAgICBAbWVkaWEgKHdpZHRoID49IDQ4cmVtKSB7XG4gICAgICBoZWlnaHQ6IDE1MHB4O1xuICAgIH1cbiAgfVxuICAubWRcXFxcOnctZnVsbCB7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0OHJlbSkge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuICB9XG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTEge1xuICAgIEBtZWRpYSAod2lkdGggPj0gNDhyZW0pIHtcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEsIG1pbm1heCgwLCAxZnIpKTtcbiAgICB9XG4gIH1cbiAgLm1kXFxcXDpncmlkLWNvbHMtMiB7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0OHJlbSkge1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xuICAgIH1cbiAgfVxuICAubWRcXFxcOmdyaWQtcm93cy1cXFxcW2F1dG9fYXV0b19hdXRvXFxcXF0ge1xuICAgIEBtZWRpYSAod2lkdGggPj0gNDhyZW0pIHtcbiAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogYXV0byBhdXRvIGF1dG87XG4gICAgfVxuICB9XG59XG5AbGF5ZXIgYmFzZSB7XG4gIDpyb290IHtcbiAgICAtLXR3LWltcG9ydGFudDogICAhaW1wb3J0YW50O1xuICB9XG59XG5Aa2V5ZnJhbWVzIHNwaW4ge1xuICB0byB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgfVxufVxuQGtleWZyYW1lcyBwaW5nIHtcbiAgNzUlLCAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDIpO1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cbn1cbkBrZXlmcmFtZXMgcHVsc2Uge1xuICA1MCUge1xuICAgIG9wYWNpdHk6IDAuNTtcbiAgfVxufVxuQGtleWZyYW1lcyBib3VuY2Uge1xuICAwJSwgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0yNSUpO1xuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjgsIDAsIDEsIDEpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBub25lO1xuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xuICB9XG59XG5AcHJvcGVydHkgLS10dy10cmFuc2xhdGUteCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LXRyYW5zbGF0ZS15IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAwO1xufVxuQHByb3BlcnR5IC0tdHctdHJhbnNsYXRlLXoge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDA7XG59XG5AcHJvcGVydHkgLS10dy1yb3RhdGUteCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogcm90YXRlWCgwKTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXJvdGF0ZS15IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiByb3RhdGVZKDApO1xufVxuQHByb3BlcnR5IC0tdHctcm90YXRlLXoge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IHJvdGF0ZVooMCk7XG59XG5AcHJvcGVydHkgLS10dy1za2V3LXgge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IHNrZXdYKDApO1xufVxuQHByb3BlcnR5IC0tdHctc2tldy15IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiBza2V3WSgwKTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXNwYWNlLXktcmV2ZXJzZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJvcmRlci1zdHlsZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogc29saWQ7XG59XG5AcHJvcGVydHkgLS10dy1ncmFkaWVudC1wb3NpdGlvbiB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LWZyb20ge1xuICBzeW50YXg6IFwiPGNvbG9yPlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6ICMwMDAwO1xufVxuQHByb3BlcnR5IC0tdHctZ3JhZGllbnQtdmlhIHtcbiAgc3ludGF4OiBcIjxjb2xvcj5cIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAjMDAwMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXRvIHtcbiAgc3ludGF4OiBcIjxjb2xvcj5cIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAjMDAwMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXN0b3BzIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctZ3JhZGllbnQtdmlhLXN0b3BzIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctZ3JhZGllbnQtZnJvbS1wb3NpdGlvbiB7XG4gIHN5bnRheDogXCI8bGVuZ3RoLXBlcmNlbnRhZ2U+XCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMCU7XG59XG5AcHJvcGVydHkgLS10dy1ncmFkaWVudC12aWEtcG9zaXRpb24ge1xuICBzeW50YXg6IFwiPGxlbmd0aC1wZXJjZW50YWdlPlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDUwJTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWdyYWRpZW50LXRvLXBvc2l0aW9uIHtcbiAgc3ludGF4OiBcIjxsZW5ndGgtcGVyY2VudGFnZT5cIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAxMDAlO1xufVxuQHByb3BlcnR5IC0tdHctZm9udC13ZWlnaHQge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1zaGFkb3cge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LXNoYWRvdy1jb2xvciB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWluc2V0LXNoYWRvdyB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMCAwICMwMDAwO1xufVxuQHByb3BlcnR5IC0tdHctaW5zZXQtc2hhZG93LWNvbG9yIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctcmluZy1jb2xvciB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXJpbmctc2hhZG93IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAwIDAgIzAwMDA7XG59XG5AcHJvcGVydHkgLS10dy1pbnNldC1yaW5nLWNvbG9yIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctaW5zZXQtcmluZy1zaGFkb3cge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LXJpbmctaW5zZXQge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1yaW5nLW9mZnNldC13aWR0aCB7XG4gIHN5bnRheDogXCI8bGVuZ3RoPlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDBweDtcbn1cbkBwcm9wZXJ0eSAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAjZmZmO1xufVxuQHByb3BlcnR5IC0tdHctcmluZy1vZmZzZXQtc2hhZG93IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAwIDAgIzAwMDA7XG59XG5AcHJvcGVydHkgLS10dy1vdXRsaW5lLXN0eWxlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiBzb2xpZDtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJsdXIge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1icmlnaHRuZXNzIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctY29udHJhc3Qge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1ncmF5c2NhbGUge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1odWUtcm90YXRlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctaW52ZXJ0IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctb3BhY2l0eSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXNhdHVyYXRlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctc2VwaWEge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1ibHVyIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcyB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWNvbnRyYXN0IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWludmVydCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLW9wYWNpdHkge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLXNlcGlhIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctZHVyYXRpb24ge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1lYXNlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuYCwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGVzLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxnRUFtQkE7QUFuQkEseUNBbUJBO0FBbkJBO0VBQUE7SUFBQTs2REFtQkE7SUFuQkEseUVBbUJBO0lBbkJBO2lEQW1CQTtJQW5CQSx3Q0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSwwQ0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSwwQ0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSwwQ0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSwrQ0FtQkE7SUFuQkEsK0NBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSwrQ0FtQkE7SUFuQkEsK0NBbUJBO0lBbkJBLCtDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsK0NBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSx5Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEseUNBbUJBO0lBbkJBLHlDQW1CQTtJQW5CQSwwQ0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLDhDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLCtDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsK0NBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw4Q0FtQkE7SUFuQkEsK0NBbUJBO0lBbkJBLCtDQW1CQTtJQW5CQSwrQ0FtQkE7SUFuQkEsOENBbUJBO0lBbkJBLCtDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwwQ0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSwwQ0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSx5Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDBDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSw2Q0FtQkE7SUFuQkEsNkNBbUJBO0lBbkJBLDZDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLGlDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsMENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSwyQ0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDJDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsb0NBbUJBO0lBbkJBLG9DQW1CQTtJQW5CQSxxQ0FtQkE7SUFuQkEsb0NBbUJBO0lBbkJBLHFDQW1CQTtJQW5CQSxxQ0FtQkE7SUFuQkEscUNBbUJBO0lBbkJBLHFDQW1CQTtJQW5CQSxxQ0FtQkE7SUFuQkEscUNBbUJBO0lBbkJBLHFDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsNENBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDRDQW1CQTtJQW5CQSw0Q0FtQkE7SUFuQkEsMkNBbUJBO0lBbkJBLDRDQW1C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QUFBLGlDQW1CQTtFQUFBO0VBbkJBO0lBQUEsd0NBbUJBO0VBQUE7RUFuQkE7SUFBQSwwQkFtQkE7RUFBQTtFQW5CQTtJQUFBLGdDQW1CQTtFQUFBO0VBbkJBO0lBQUEsc0VBbUJBO0VBQUE7RUFuQkE7SUFBQSxtREFtQkE7RUFBQTtFQW5CQTtJQUFBLHdDQW1CQTtFQUFBO0VBbkJBO0lBQUEsK0NBbUJBO0VBQUE7RUFuQkE7SUFBQSx5QkFtQkE7RUFBQTtFQW5CQTtJQUFBLCtEQW1CQTtFQUFBO0VBbkJBO0lBQUEseUJBbUJBO0VBQUE7RUFuQkE7SUFBQSx1Q0FtQkE7RUFBQTtFQW5CQTtJQUFBLHdDQW1CQTtFQUFBO0VBbkJBO0lBQUEsd0NBbUJBO0VBQUE7RUFuQkE7SUFBQSxzQ0FtQkE7RUFBQTtFQW5CQTtJQUFBLHNDQW1CQTtFQUFBO0VBbkJBO0lBQUEsb0NBbUJBO0VBQUE7RUFuQkE7SUFBQSwwRUFtQkE7RUFBQTtFQW5CQTtJQUFBLHVDQW1CQTtFQUFBO0VBbkJBO0lBQUEsNkVBbUJBO0VBQUE7RUFuQkE7SUFBQSx1Q0FtQkE7RUFBQTtFQW5CQTtJQUFBLHlDQW1CQTtFQUFBO0VBbkJBO0lBQUEsc0NBbUJBO0VBQUE7RUFuQkE7SUFBQSw2QkFtQkE7RUFBQTtFQW5CQTtJQUFBLG9DQW1CQTtFQUFBO0VBbkJBO0lBQUEseUVBbUJBO0VBQUE7RUFuQkE7SUFBQSwwRUFtQkE7RUFBQTtFQW5CQTtJQUFBLDBFQW1CQTtFQUFBO0VBbkJBO0lBQUEsMENBbUJBO0lBbkJBLDJEQW1CQTtFQUFBO0VBbkJBO0lBQUEseUNBbUJBO0lBbkJBLDJEQW1CQTtFQUFBO0VBbkJBO0lBQUEsc0NBbUJBO0lBbkJBLDhMQW1CQTtFQUFBO0VBbkJBO0lBQUEsc0NBbUJBO0lBbkJBLDhMQW1CQTtFQUFBO0VBbkJBO0lBQUEsb0NBbUJBO0lBbkJBLDhMQW1CQTtFQUFBO0VBbkJBO0lBQUEsb0NBbUJBO0lBbkJBLDhMQW1CQTtFQUFBO0VBbkJBO0lBQUEscUJBbUJBO0VBQUE7RUFuQkE7SUFBQSxtQkFtQkE7RUFBQTtFQW5CQTtJQUFBLGlCQW1CQTtFQUFBO0VBbkJBO0lBQUEsNENBbUJBO0VBQUE7RUFuQkE7SUFBQSxpQ0FtQkE7RUFBQTtFQW5CQTtJQUFBLGlDQW1CQTtFQUFBO0VBbkJBO0lBQUEsaUNBbUJBO0VBQUE7RUFuQkE7SUFBQSxpQ0FtQkE7RUFBQTtFQW5CQTtJQUFBLGlDQW1CQTtFQUFBO0VBbkJBO0lBQUEsaUNBbUJBO0VBQUE7RUFuQkE7SUFBQSxrQ0FtQkE7RUFBQTtFQW5CQTtJQUFBLHdDQW1CQTtFQUFBO0VBbkJBO0lBQUEsd0NBbUJBO0VBQUE7RUFuQkE7SUFBQSx3Q0FtQkE7RUFBQTtFQW5CQTtJQUFBLHdDQW1CQTtFQUFBO0VBbkJBO0lBQUEsd0NBbUJBO0VBQUE7RUFuQkE7SUFBQSx1Q0FtQkE7RUFBQTtFQW5CQTtJQUFBLHlDQW1CQTtFQUFBO0VBbkJBO0lBQUEsdUNBbUJBO0VBQUE7RUFuQkE7SUFBQSx1Q0FtQkE7RUFBQTtFQW5CQTtJQUFBLHVDQW1CQTtFQUFBO0VBbkJBO0lBQUEsd0NBbUJBO0VBQUE7RUFuQkE7SUFBQSx1QkFtQkE7RUFBQTtFQW5CQTtJQUFBLHFDQW1CQTtFQUFBO0VBbkJBO0lBQUEsd0NBbUJBO0VBQUE7RUFuQkE7SUFBQSx1Q0FtQkE7RUFBQTtFQW5CQTtJQUFBLGtCQW1CQTtFQUFBO0VBbkJBO0lBQUEsNkJBbUJBO0VBQUE7RUFuQkE7SUFBQSxvQ0FtQkE7SUFuQkEsc0VBbUJBO0VBQUE7RUFuQkE7SUFBQSwwQkFtQkE7SUFuQkEsNERBbUJBO0VBQUE7RUFuQkE7SUFBQSwwQkFtQkE7SUFuQkEsNERBbUJBO0VBQUE7RUFuQkE7SUFBQSwwQkFtQkE7SUFuQkEsNERBbUJBO0VBQUE7RUFuQkE7SUFBQSwyQkFtQkE7SUFuQkEsNkRBbUJBO0VBQUE7RUFuQkE7SUFBQSx5QkFtQkE7SUFuQkEsMkRBbUJBO0VBQUE7RUFuQkE7SUFBQSx5QkFtQkE7SUFuQkEsMkRBbUJBO0VBQUE7RUFuQkE7SUFBQSx5QkFtQkE7SUFuQkEsMkRBbUJBO0VBQUE7RUFuQkE7SUFBQSx5QkFt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O0VBbkJBO0lBQUE7TUFBQSwrREFtQkE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQTtRQUFBLDZDQW1CQTtRQW5CQSxzREFtQkE7TUFBQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBO1FBQUEsNkNBbUJBO1FBbkJBLHNEQW1CQTtNQUFBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUE7UUFBQSxxR0FtQkE7TUFBQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBO1FBQUEsd0NBbUJBO01BQUE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQTtRQUFBLHFGQW1CQTtNQUFBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUE7UUFBQSx1Q0FtQkE7TUFBQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBO1FBQUEsdUNBbUJBO01BQUE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQTtRQUFBLHVDQW1CQTtNQUFBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUE7UUFBQSw0RUFtQkE7TUFBQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBO1FBQUEsMEVBbUJBO01BQUE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQTtRQUFBLG9DQW1CQTtNQUFBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUE7UUFBQSw0QkFtQkE7TUFBQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBO1FBQUEsNEJBbUJBO01BQUE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQTtRQUFBLFlBbUJBO01BQUE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQTtRQUFBLCtIQW1CQTtRQW5CQSxzSUFtQkE7TUFBQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBLG1DQW1CQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBLHdIQW1CQTtNQW5CQSxzSUFtQkE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQSx3QkFtQkE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQSx3QkFtQkE7TUFuQkEsbUJBbUJBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUEsbUJBbUJBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUEsWUFtQkE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQSxnREFtQkE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQSxzQkFtQkE7SUFBQTtFQUFBO0VBbkJBO0lBQUE7TUFBQSxhQW1CQTtJQUFBO0VBQUE7RUFuQkE7SUFBQTtNQUFBLFdBbUJBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUEsZ0RBbUJBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUEsZ0RBbUJBO0lBQUE7RUFBQTtFQW5CQTtJQUFBO01BQUEsa0NBbUJBO0lBQUE7RUFBQTtBQUFBO0FBbkJBO0VBQUE7SUFBQSw0QkFtQkE7RUFBQTtBQUFBO0FBbkJBO0VBQUE7SUFBQSx5QkFtQkE7RUFBQTtBQUFBO0FBbkJBO0VBQUE7SUFBQSxtQkFtQkE7SUFuQkEsVUFtQkE7RUFBQTtBQUFBO0FBbkJBO0VBQUE7SUFBQSxZQW1CQTtFQUFBO0FBQUE7QUFuQkE7RUFBQTtJQUFBLDJCQW1CQTtJQW5CQSxxREFtQkE7RUFBQTtFQW5CQTtJQUFBLGVBbUJBO0lBbkJBLHFEQW1CQTtFQUFBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSxnQkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0VBbkJBLGdCQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7RUFuQkEsZ0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSx5QkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0VBbkJBLHlCQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7RUFuQkEseUJBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSx1QkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0VBbkJBLHVCQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7RUFuQkEsZ0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSxvQkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxpQkFtQkE7RUFuQkEsZUFtQkE7RUFuQkEsb0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxpQkFtQkE7RUFuQkEsZUFtQkE7RUFuQkEsb0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxpQkFtQkE7RUFuQkEsZUFtQkE7RUFuQkEsb0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLDZCQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSxpQkFtQkE7QUFBQTtBQW5CQTtFQUFBLDZCQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSxrQkFtQkE7QUFBQTtBQW5CQTtFQUFBLDZCQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSxtQkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSx3QkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSx3QkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7RUFuQkEsd0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7RUFuQkEsd0JBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsa0JBbUJBO0VBbkJBLGVBbUJBO0VBbkJBLGtCQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7RUFuQkEsbUJBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtFQW5CQSx3QkFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0VBbkJBLG9CQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUE7QUFuQkE7RUFBQSxXQW1CQTtFQW5CQSxlQW1CQTtBQUFBO0FBbkJBO0VBQUEsV0FtQkE7RUFuQkEsZUFtQkE7QUFBQTtBQW5CQTtFQUFBLFdBbUJBO0VBbkJBLGVBbUJBO0FBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGltcG9ydCBcXFwidGFpbHdpbmRjc3NcXFwiO1xcblxcbkB0aGVtZSB7XFxuICAtLWNvbG9yLXByaW1hcnktdHc6ICMyYjgwZmY7XFxuICAtLWNvbG9yLWxpZ2h0OiAjYzNkNWY3O1xcbiAgLS1jb2xvci1iZy1kYXJrOiAjMGEwYTFhO1xcbiAgLS1jb2xvci1iZy1jYXJkOiAjMWExYTJhO1xcbiAgLS1jb2xvci1iZy1ob3ZlcjogIzJhMmEzYTtcXG4gIC0tY29sb3ItYmctYWN0aXZlOiAjZmZmO1xcbiAgLS1jb2xvci1ib3JkZXI6ICMzMzM7XFxuICAtLWNvbG9yLWJvcmRlci1hY3RpdmU6ICM1YTVhN2E7XFxuICAtLWNvbG9yLXRleHQtc2Vjb25kYXJ5OiAjYWFhO1xcbn1cXG5cXG5AbGF5ZXIgYmFzZSB7XFxuICA6cm9vdCB7XFxuICAgIC0tdHctaW1wb3J0YW50OiAhaW1wb3J0YW50O1xcbiAgfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///408\n')},314:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += "}";\n      }\n      if (item[2]) {\n        content += "}";\n      }\n      if (item[4]) {\n        content += "}";\n      }\n      return content;\n    }).join("");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///314\n')},354:module=>{"use strict";eval('\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === "function") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    return [content].concat([sourceMapping]).join("\\n");\n  }\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///354\n')},606:module=>{eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/ZjI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///606\n")},247:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(606);\n/**\n * @license React\n * react-dom-client.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n\nvar Scheduler = __webpack_require__(982),\n  React = __webpack_require__(540),\n  ReactDOM = __webpack_require__(961);\nfunction formatProdErrorMessage(code) {\n  var url = "https://react.dev/errors/" + code;\n  if (1 < arguments.length) {\n    url += "?args[]=" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += "&args[]=" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    "Minified React error #" +\n    code +\n    "; visit " +\n    url +\n    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."\n  );\n}\nfunction isValidContainer(node) {\n  return !(\n    !node ||\n    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)\n  );\n}\nvar REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),\n  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_PORTAL_TYPE = Symbol.for("react.portal"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),\n  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),\n  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),\n  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),\n  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),\n  REACT_CONTEXT_TYPE = Symbol.for("react.context"),\n  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),\n  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),\n  REACT_MEMO_TYPE = Symbol.for("react.memo"),\n  REACT_LAZY_TYPE = Symbol.for("react.lazy");\nSymbol.for("react.scope");\nSymbol.for("react.debug_trace_mode");\nvar REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");\nSymbol.for("react.legacy_hidden");\nSymbol.for("react.tracing_marker");\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable["@@iterator"];\n  return "function" === typeof maybeIterable ? maybeIterable : null;\n}\nvar REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");\nfunction getComponentNameFromType(type) {\n  if (null == type) return null;\n  if ("function" === typeof type)\n    return type.$$typeof === REACT_CLIENT_REFERENCE\n      ? null\n      : type.displayName || type.name || null;\n  if ("string" === typeof type) return type;\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return "Fragment";\n    case REACT_PORTAL_TYPE:\n      return "Portal";\n    case REACT_PROFILER_TYPE:\n      return "Profiler";\n    case REACT_STRICT_MODE_TYPE:\n      return "StrictMode";\n    case REACT_SUSPENSE_TYPE:\n      return "Suspense";\n    case REACT_SUSPENSE_LIST_TYPE:\n      return "SuspenseList";\n  }\n  if ("object" === typeof type)\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return (type.displayName || "Context") + ".Provider";\n      case REACT_CONSUMER_TYPE:\n        return (type._context.displayName || "Context") + ".Consumer";\n      case REACT_FORWARD_REF_TYPE:\n        var innerType = type.render;\n        type = type.displayName;\n        type ||\n          ((type = innerType.displayName || innerType.name || ""),\n          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));\n        return type;\n      case REACT_MEMO_TYPE:\n        return (\n          (innerType = type.displayName || null),\n          null !== innerType\n            ? innerType\n            : getComponentNameFromType(type.type) || "Memo"\n        );\n      case REACT_LAZY_TYPE:\n        innerType = type._payload;\n        type = type._init;\n        try {\n          return getComponentNameFromType(type(innerType));\n        } catch (x) {}\n    }\n  return null;\n}\nvar ReactSharedInternals =\n    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  assign = Object.assign,\n  prefix,\n  suffix;\nfunction describeBuiltInComponentFrame(name) {\n  if (void 0 === prefix)\n    try {\n      throw Error();\n    } catch (x) {\n      var match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = (match && match[1]) || "";\n      suffix =\n        -1 < x.stack.indexOf("\\n    at")\n          ? " (<anonymous>)"\n          : -1 < x.stack.indexOf("@")\n            ? "@unknown:0:0"\n            : "";\n    }\n  return "\\n" + prefix + name + suffix;\n}\nvar reentry = !1;\nfunction describeNativeComponentFrame(fn, construct) {\n  if (!fn || reentry) return "";\n  reentry = !0;\n  var previousPrepareStackTrace = Error.prepareStackTrace;\n  Error.prepareStackTrace = void 0;\n  try {\n    var RunInRootFrame = {\n      DetermineComponentFrameRoot: function () {\n        try {\n          if (construct) {\n            var Fake = function () {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, "props", {\n              set: function () {\n                throw Error();\n              }\n            });\n            if ("object" === typeof Reflect && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                var control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x$0) {\n                control = x$0;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x$1) {\n              control = x$1;\n            }\n            (Fake = fn()) &&\n              "function" === typeof Fake.catch &&\n              Fake.catch(function () {});\n          }\n        } catch (sample) {\n          if (sample && control && "string" === typeof sample.stack)\n            return [sample.stack, control.stack];\n        }\n        return [null, null];\n      }\n    };\n    RunInRootFrame.DetermineComponentFrameRoot.displayName =\n      "DetermineComponentFrameRoot";\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(\n      RunInRootFrame.DetermineComponentFrameRoot,\n      "name"\n    );\n    namePropDescriptor &&\n      namePropDescriptor.configurable &&\n      Object.defineProperty(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        "name",\n        { value: "DetermineComponentFrameRoot" }\n      );\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n      sampleStack = _RunInRootFrame$Deter[0],\n      controlStack = _RunInRootFrame$Deter[1];\n    if (sampleStack && controlStack) {\n      var sampleLines = sampleStack.split("\\n"),\n        controlLines = controlStack.split("\\n");\n      for (\n        namePropDescriptor = RunInRootFrame = 0;\n        RunInRootFrame < sampleLines.length &&\n        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");\n\n      )\n        RunInRootFrame++;\n      for (\n        ;\n        namePropDescriptor < controlLines.length &&\n        !controlLines[namePropDescriptor].includes(\n          "DetermineComponentFrameRoot"\n        );\n\n      )\n        namePropDescriptor++;\n      if (\n        RunInRootFrame === sampleLines.length ||\n        namePropDescriptor === controlLines.length\n      )\n        for (\n          RunInRootFrame = sampleLines.length - 1,\n            namePropDescriptor = controlLines.length - 1;\n          1 <= RunInRootFrame &&\n          0 <= namePropDescriptor &&\n          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];\n\n        )\n          namePropDescriptor--;\n      for (\n        ;\n        1 <= RunInRootFrame && 0 <= namePropDescriptor;\n        RunInRootFrame--, namePropDescriptor--\n      )\n        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\n            do\n              if (\n                (RunInRootFrame--,\n                namePropDescriptor--,\n                0 > namePropDescriptor ||\n                  sampleLines[RunInRootFrame] !==\n                    controlLines[namePropDescriptor])\n              ) {\n                var frame =\n                  "\\n" +\n                  sampleLines[RunInRootFrame].replace(" at new ", " at ");\n                fn.displayName &&\n                  frame.includes("<anonymous>") &&\n                  (frame = frame.replace("<anonymous>", fn.displayName));\n                return frame;\n              }\n            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\n          }\n          break;\n        }\n    }\n  } finally {\n    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);\n  }\n  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")\n    ? describeBuiltInComponentFrame(previousPrepareStackTrace)\n    : "";\n}\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n    case 27:\n    case 5:\n      return describeBuiltInComponentFrame(fiber.type);\n    case 16:\n      return describeBuiltInComponentFrame("Lazy");\n    case 13:\n      return describeBuiltInComponentFrame("Suspense");\n    case 19:\n      return describeBuiltInComponentFrame("SuspenseList");\n    case 0:\n    case 15:\n      return (fiber = describeNativeComponentFrame(fiber.type, !1)), fiber;\n    case 11:\n      return (\n        (fiber = describeNativeComponentFrame(fiber.type.render, !1)), fiber\n      );\n    case 1:\n      return (fiber = describeNativeComponentFrame(fiber.type, !0)), fiber;\n    default:\n      return "";\n  }\n}\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = "";\n    do\n      (info += describeFiber(workInProgress)),\n        (workInProgress = workInProgress.return);\n    while (workInProgress);\n    return info;\n  } catch (x) {\n    return "\\nError generating stack: " + x.message + "\\n" + x.stack;\n  }\n}\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber,\n    nearestMounted = fiber;\n  if (fiber.alternate) for (; node.return; ) node = node.return;\n  else {\n    fiber = node;\n    do\n      (node = fiber),\n        0 !== (node.flags & 4098) && (nearestMounted = node.return),\n        (fiber = node.return);\n    while (fiber);\n  }\n  return 3 === node.tag ? nearestMounted : null;\n}\nfunction getSuspenseInstanceFromFiber(fiber) {\n  if (13 === fiber.tag) {\n    var suspenseState = fiber.memoizedState;\n    null === suspenseState &&\n      ((fiber = fiber.alternate),\n      null !== fiber && (suspenseState = fiber.memoizedState));\n    if (null !== suspenseState) return suspenseState.dehydrated;\n  }\n  return null;\n}\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber)\n    throw Error(formatProdErrorMessage(188));\n}\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    alternate = getNearestMountedFiber(fiber);\n    if (null === alternate) throw Error(formatProdErrorMessage(188));\n    return alternate !== fiber ? null : fiber;\n  }\n  for (var a = fiber, b = alternate; ; ) {\n    var parentA = a.return;\n    if (null === parentA) break;\n    var parentB = parentA.alternate;\n    if (null === parentB) {\n      b = parentA.return;\n      if (null !== b) {\n        a = b;\n        continue;\n      }\n      break;\n    }\n    if (parentA.child === parentB.child) {\n      for (parentB = parentA.child; parentB; ) {\n        if (parentB === a) return assertIsMounted(parentA), fiber;\n        if (parentB === b) return assertIsMounted(parentA), alternate;\n        parentB = parentB.sibling;\n      }\n      throw Error(formatProdErrorMessage(188));\n    }\n    if (a.return !== b.return) (a = parentA), (b = parentB);\n    else {\n      for (var didFindChild = !1, child$2 = parentA.child; child$2; ) {\n        if (child$2 === a) {\n          didFindChild = !0;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child$2 === b) {\n          didFindChild = !0;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child$2 = child$2.sibling;\n      }\n      if (!didFindChild) {\n        for (child$2 = parentB.child; child$2; ) {\n          if (child$2 === a) {\n            didFindChild = !0;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child$2 === b) {\n            didFindChild = !0;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child$2 = child$2.sibling;\n        }\n        if (!didFindChild) throw Error(formatProdErrorMessage(189));\n      }\n    }\n    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));\n  }\n  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));\n  return a.stateNode.current === a ? fiber : alternate;\n}\nfunction findCurrentHostFiberImpl(node) {\n  var tag = node.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n  for (node = node.child; null !== node; ) {\n    tag = findCurrentHostFiberImpl(node);\n    if (null !== tag) return tag;\n    node = node.sibling;\n  }\n  return null;\n}\nvar isArrayImpl = Array.isArray,\n  ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  sharedNotPendingObject = {\n    pending: !1,\n    data: null,\n    method: null,\n    action: null\n  },\n  valueStack = [],\n  index = -1;\nfunction createCursor(defaultValue) {\n  return { current: defaultValue };\n}\nfunction pop(cursor) {\n  0 > index ||\n    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);\n}\nfunction push(cursor, value) {\n  index++;\n  valueStack[index] = cursor.current;\n  cursor.current = value;\n}\nvar contextStackCursor = createCursor(null),\n  contextFiberStackCursor = createCursor(null),\n  rootInstanceStackCursor = createCursor(null),\n  hostTransitionProviderCursor = createCursor(null);\nfunction pushHostContainer(fiber, nextRootInstance) {\n  push(rootInstanceStackCursor, nextRootInstance);\n  push(contextFiberStackCursor, fiber);\n  push(contextStackCursor, null);\n  fiber = nextRootInstance.nodeType;\n  switch (fiber) {\n    case 9:\n    case 11:\n      nextRootInstance = (nextRootInstance = nextRootInstance.documentElement)\n        ? (nextRootInstance = nextRootInstance.namespaceURI)\n          ? getOwnHostContext(nextRootInstance)\n          : 0\n        : 0;\n      break;\n    default:\n      if (\n        ((fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance),\n        (nextRootInstance = fiber.tagName),\n        (fiber = fiber.namespaceURI))\n      )\n        (fiber = getOwnHostContext(fiber)),\n          (nextRootInstance = getChildHostContextProd(fiber, nextRootInstance));\n      else\n        switch (nextRootInstance) {\n          case "svg":\n            nextRootInstance = 1;\n            break;\n          case "math":\n            nextRootInstance = 2;\n            break;\n          default:\n            nextRootInstance = 0;\n        }\n  }\n  pop(contextStackCursor);\n  push(contextStackCursor, nextRootInstance);\n}\nfunction popHostContainer() {\n  pop(contextStackCursor);\n  pop(contextFiberStackCursor);\n  pop(rootInstanceStackCursor);\n}\nfunction pushHostContext(fiber) {\n  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);\n  var context = contextStackCursor.current;\n  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);\n  context !== JSCompiler_inline_result &&\n    (push(contextFiberStackCursor, fiber),\n    push(contextStackCursor, JSCompiler_inline_result));\n}\nfunction popHostContext(fiber) {\n  contextFiberStackCursor.current === fiber &&\n    (pop(contextStackCursor), pop(contextFiberStackCursor));\n  hostTransitionProviderCursor.current === fiber &&\n    (pop(hostTransitionProviderCursor),\n    (HostTransitionContext._currentValue = sharedNotPendingObject));\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\n  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,\n  cancelCallback$1 = Scheduler.unstable_cancelCallback,\n  shouldYield = Scheduler.unstable_shouldYield,\n  requestPaint = Scheduler.unstable_requestPaint,\n  now = Scheduler.unstable_now,\n  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,\n  ImmediatePriority = Scheduler.unstable_ImmediatePriority,\n  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,\n  NormalPriority$1 = Scheduler.unstable_NormalPriority,\n  LowPriority = Scheduler.unstable_LowPriority,\n  IdlePriority = Scheduler.unstable_IdlePriority,\n  log$1 = Scheduler.log,\n  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,\n  rendererID = null,\n  injectedHook = null;\nfunction onCommitRoot(root) {\n  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)\n    try {\n      injectedHook.onCommitFiberRoot(\n        rendererID,\n        root,\n        void 0,\n        128 === (root.current.flags & 128)\n      );\n    } catch (err) {}\n}\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\n  if (injectedHook && "function" === typeof injectedHook.setStrictMode)\n    try {\n      injectedHook.setStrictMode(rendererID, newIsStrictMode);\n    } catch (err) {}\n}\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n  log = Math.log,\n  LN2 = Math.LN2;\nfunction clz32Fallback(x) {\n  x >>>= 0;\n  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n}\nvar nextTransitionLane = 128,\n  nextRetryLane = 4194304;\nfunction getHighestPriorityLanes(lanes) {\n  var pendingSyncLanes = lanes & 42;\n  if (0 !== pendingSyncLanes) return pendingSyncLanes;\n  switch (lanes & -lanes) {\n    case 1:\n      return 1;\n    case 2:\n      return 2;\n    case 4:\n      return 4;\n    case 8:\n      return 8;\n    case 16:\n      return 16;\n    case 32:\n      return 32;\n    case 64:\n      return 64;\n    case 128:\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return lanes & 4194176;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return lanes & 62914560;\n    case 67108864:\n      return 67108864;\n    case 134217728:\n      return 134217728;\n    case 268435456:\n      return 268435456;\n    case 536870912:\n      return 536870912;\n    case 1073741824:\n      return 0;\n    default:\n      return lanes;\n  }\n}\nfunction getNextLanes(root, wipLanes) {\n  var pendingLanes = root.pendingLanes;\n  if (0 === pendingLanes) return 0;\n  var nextLanes = 0,\n    suspendedLanes = root.suspendedLanes,\n    pingedLanes = root.pingedLanes,\n    warmLanes = root.warmLanes;\n  root = 0 !== root.finishedLanes;\n  var nonIdlePendingLanes = pendingLanes & 134217727;\n  0 !== nonIdlePendingLanes\n    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),\n      0 !== pendingLanes\n        ? (nextLanes = getHighestPriorityLanes(pendingLanes))\n        : ((pingedLanes &= nonIdlePendingLanes),\n          0 !== pingedLanes\n            ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n            : root ||\n              ((warmLanes = nonIdlePendingLanes & ~warmLanes),\n              0 !== warmLanes &&\n                (nextLanes = getHighestPriorityLanes(warmLanes)))))\n    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),\n      0 !== nonIdlePendingLanes\n        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))\n        : 0 !== pingedLanes\n          ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n          : root ||\n            ((warmLanes = pendingLanes & ~warmLanes),\n            0 !== warmLanes &&\n              (nextLanes = getHighestPriorityLanes(warmLanes))));\n  return 0 === nextLanes\n    ? 0\n    : 0 !== wipLanes &&\n        wipLanes !== nextLanes &&\n        0 === (wipLanes & suspendedLanes) &&\n        ((suspendedLanes = nextLanes & -nextLanes),\n        (warmLanes = wipLanes & -wipLanes),\n        suspendedLanes >= warmLanes ||\n          (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))\n      ? wipLanes\n      : nextLanes;\n}\nfunction checkIfRootIsPrerendering(root, renderLanes) {\n  return (\n    0 ===\n    (root.pendingLanes &\n      ~(root.suspendedLanes & ~root.pingedLanes) &\n      renderLanes)\n  );\n}\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case 1:\n    case 2:\n    case 4:\n    case 8:\n      return currentTime + 250;\n    case 16:\n    case 32:\n    case 64:\n    case 128:\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return currentTime + 5e3;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return -1;\n    case 67108864:\n    case 134217728:\n    case 268435456:\n    case 536870912:\n    case 1073741824:\n      return -1;\n    default:\n      return -1;\n  }\n}\nfunction claimNextTransitionLane() {\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n  return lane;\n}\nfunction createLaneMap(initial) {\n  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);\n  return laneMap;\n}\nfunction markRootUpdated$1(root, updateLane) {\n  root.pendingLanes |= updateLane;\n  268435456 !== updateLane &&\n    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));\n}\nfunction markRootFinished(\n  root,\n  finishedLanes,\n  remainingLanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  var previouslyPendingLanes = root.pendingLanes;\n  root.pendingLanes = remainingLanes;\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n  root.warmLanes = 0;\n  root.expiredLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n  root.shellSuspendCounter = 0;\n  var entanglements = root.entanglements,\n    expirationTimes = root.expirationTimes,\n    hiddenUpdates = root.hiddenUpdates;\n  for (\n    remainingLanes = previouslyPendingLanes & ~remainingLanes;\n    0 < remainingLanes;\n\n  ) {\n    var index$7 = 31 - clz32(remainingLanes),\n      lane = 1 << index$7;\n    entanglements[index$7] = 0;\n    expirationTimes[index$7] = -1;\n    var hiddenUpdatesForLane = hiddenUpdates[index$7];\n    if (null !== hiddenUpdatesForLane)\n      for (\n        hiddenUpdates[index$7] = null, index$7 = 0;\n        index$7 < hiddenUpdatesForLane.length;\n        index$7++\n      ) {\n        var update = hiddenUpdatesForLane[index$7];\n        null !== update && (update.lane &= -536870913);\n      }\n    remainingLanes &= ~lane;\n  }\n  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n  0 !== suspendedRetryLanes &&\n    0 === updatedLanes &&\n    0 !== root.tag &&\n    (root.suspendedLanes |=\n      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n}\nfunction markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n  root.pendingLanes |= spawnedLane;\n  root.suspendedLanes &= ~spawnedLane;\n  var spawnedLaneIndex = 31 - clz32(spawnedLane);\n  root.entangledLanes |= spawnedLane;\n  root.entanglements[spawnedLaneIndex] =\n    root.entanglements[spawnedLaneIndex] |\n    1073741824 |\n    (entangledLanes & 4194218);\n}\nfunction markRootEntangled(root, entangledLanes) {\n  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  for (root = root.entanglements; rootEntangledLanes; ) {\n    var index$8 = 31 - clz32(rootEntangledLanes),\n      lane = 1 << index$8;\n    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&\n      (root[index$8] |= entangledLanes);\n    rootEntangledLanes &= ~lane;\n  }\n}\nfunction lanesToEventPriority(lanes) {\n  lanes &= -lanes;\n  return 2 < lanes\n    ? 8 < lanes\n      ? 0 !== (lanes & 134217727)\n        ? 32\n        : 268435456\n      : 8\n    : 2;\n}\nfunction resolveUpdatePriority() {\n  var updatePriority = ReactDOMSharedInternals.p;\n  if (0 !== updatePriority) return updatePriority;\n  updatePriority = window.event;\n  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    return (ReactDOMSharedInternals.p = priority), fn();\n  } finally {\n    ReactDOMSharedInternals.p = previousPriority;\n  }\n}\nvar randomKey = Math.random().toString(36).slice(2),\n  internalInstanceKey = "__reactFiber$" + randomKey,\n  internalPropsKey = "__reactProps$" + randomKey,\n  internalContainerInstanceKey = "__reactContainer$" + randomKey,\n  internalEventHandlersKey = "__reactEvents$" + randomKey,\n  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,\n  internalEventHandlesSetKey = "__reactHandles$" + randomKey,\n  internalRootNodeResourcesKey = "__reactResources$" + randomKey,\n  internalHoistableMarker = "__reactMarker$" + randomKey;\nfunction detachDeletedInstance(node) {\n  delete node[internalInstanceKey];\n  delete node[internalPropsKey];\n  delete node[internalEventHandlersKey];\n  delete node[internalEventHandlerListenersKey];\n  delete node[internalEventHandlesSetKey];\n}\nfunction getClosestInstanceFromNode(targetNode) {\n  var targetInst = targetNode[internalInstanceKey];\n  if (targetInst) return targetInst;\n  for (var parentNode = targetNode.parentNode; parentNode; ) {\n    if (\n      (targetInst =\n        parentNode[internalContainerInstanceKey] ||\n        parentNode[internalInstanceKey])\n    ) {\n      parentNode = targetInst.alternate;\n      if (\n        null !== targetInst.child ||\n        (null !== parentNode && null !== parentNode.child)\n      )\n        for (\n          targetNode = getParentSuspenseInstance(targetNode);\n          null !== targetNode;\n\n        ) {\n          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;\n          targetNode = getParentSuspenseInstance(targetNode);\n        }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\nfunction getInstanceFromNode(node) {\n  if (\n    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])\n  ) {\n    var tag = node.tag;\n    if (\n      5 === tag ||\n      6 === tag ||\n      13 === tag ||\n      26 === tag ||\n      27 === tag ||\n      3 === tag\n    )\n      return node;\n  }\n  return null;\n}\nfunction getNodeFromInstance(inst) {\n  var tag = inst.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\n  throw Error(formatProdErrorMessage(33));\n}\nfunction getResourcesFromRoot(root) {\n  var resources = root[internalRootNodeResourcesKey];\n  resources ||\n    (resources = root[internalRootNodeResourcesKey] =\n      { hoistableStyles: new Map(), hoistableScripts: new Map() });\n  return resources;\n}\nfunction markNodeAsHoistable(node) {\n  node[internalHoistableMarker] = !0;\n}\nvar allNativeEvents = new Set(),\n  registrationNameDependencies = {};\nfunction registerTwoPhaseEvent(registrationName, dependencies) {\n  registerDirectEvent(registrationName, dependencies);\n  registerDirectEvent(registrationName + "Capture", dependencies);\n}\nfunction registerDirectEvent(registrationName, dependencies) {\n  registrationNameDependencies[registrationName] = dependencies;\n  for (\n    registrationName = 0;\n    registrationName < dependencies.length;\n    registrationName++\n  )\n    allNativeEvents.add(dependencies[registrationName]);\n}\nvar canUseDOM = !(\n    "undefined" === typeof window ||\n    "undefined" === typeof window.document ||\n    "undefined" === typeof window.document.createElement\n  ),\n  VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n    "^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$"\n  ),\n  illegalAttributeNameCache = {},\n  validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n    return !0;\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n    return (validatedAttributeNameCache[attributeName] = !0);\n  illegalAttributeNameCache[attributeName] = !0;\n  return !1;\n}\nfunction setValueForAttribute(node, name, value) {\n  if (isAttributeNameSafe(name))\n    if (null === value) node.removeAttribute(name);\n    else {\n      switch (typeof value) {\n        case "undefined":\n        case "function":\n        case "symbol":\n          node.removeAttribute(name);\n          return;\n        case "boolean":\n          var prefix$10 = name.toLowerCase().slice(0, 5);\n          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {\n            node.removeAttribute(name);\n            return;\n          }\n      }\n      node.setAttribute(name, "" + value);\n    }\n}\nfunction setValueForKnownAttribute(node, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case "undefined":\n      case "function":\n      case "symbol":\n      case "boolean":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttribute(name, "" + value);\n  }\n}\nfunction setValueForNamespacedAttribute(node, namespace, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case "undefined":\n      case "function":\n      case "symbol":\n      case "boolean":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttributeNS(namespace, name, "" + value);\n  }\n}\nfunction getToStringValue(value) {\n  switch (typeof value) {\n    case "bigint":\n    case "boolean":\n    case "number":\n    case "string":\n    case "undefined":\n      return value;\n    case "object":\n      return value;\n    default:\n      return "";\n  }\n}\nfunction isCheckable(elem) {\n  var type = elem.type;\n  return (\n    (elem = elem.nodeName) &&\n    "input" === elem.toLowerCase() &&\n    ("checkbox" === type || "radio" === type)\n  );\n}\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? "checked" : "value",\n    descriptor = Object.getOwnPropertyDescriptor(\n      node.constructor.prototype,\n      valueField\n    ),\n    currentValue = "" + node[valueField];\n  if (\n    !node.hasOwnProperty(valueField) &&\n    "undefined" !== typeof descriptor &&\n    "function" === typeof descriptor.get &&\n    "function" === typeof descriptor.set\n  ) {\n    var get = descriptor.get,\n      set = descriptor.set;\n    Object.defineProperty(node, valueField, {\n      configurable: !0,\n      get: function () {\n        return get.call(this);\n      },\n      set: function (value) {\n        currentValue = "" + value;\n        set.call(this, value);\n      }\n    });\n    Object.defineProperty(node, valueField, {\n      enumerable: descriptor.enumerable\n    });\n    return {\n      getValue: function () {\n        return currentValue;\n      },\n      setValue: function (value) {\n        currentValue = "" + value;\n      },\n      stopTracking: function () {\n        node._valueTracker = null;\n        delete node[valueField];\n      }\n    };\n  }\n}\nfunction track(node) {\n  node._valueTracker || (node._valueTracker = trackValueOnNode(node));\n}\nfunction updateValueIfChanged(node) {\n  if (!node) return !1;\n  var tracker = node._valueTracker;\n  if (!tracker) return !0;\n  var lastValue = tracker.getValue();\n  var value = "";\n  node &&\n    (value = isCheckable(node)\n      ? node.checked\n        ? "true"\n        : "false"\n      : node.value);\n  node = value;\n  return node !== lastValue ? (tracker.setValue(node), !0) : !1;\n}\nfunction getActiveElement(doc) {\n  doc = doc || ("undefined" !== typeof document ? document : void 0);\n  if ("undefined" === typeof doc) return null;\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\nvar escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n"\\\\]/g;\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\n  return value.replace(\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\n    function (ch) {\n      return "\\\\" + ch.charCodeAt(0).toString(16) + " ";\n    }\n  );\n}\nfunction updateInput(\n  element,\n  value,\n  defaultValue,\n  lastDefaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name\n) {\n  element.name = "";\n  null != type &&\n  "function" !== typeof type &&\n  "symbol" !== typeof type &&\n  "boolean" !== typeof type\n    ? (element.type = type)\n    : element.removeAttribute("type");\n  if (null != value)\n    if ("number" === type) {\n      if ((0 === value && "" === element.value) || element.value != value)\n        element.value = "" + getToStringValue(value);\n    } else\n      element.value !== "" + getToStringValue(value) &&\n        (element.value = "" + getToStringValue(value));\n  else\n    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");\n  null != value\n    ? setDefaultValue(element, type, getToStringValue(value))\n    : null != defaultValue\n      ? setDefaultValue(element, type, getToStringValue(defaultValue))\n      : null != lastDefaultValue && element.removeAttribute("value");\n  null == checked &&\n    null != defaultChecked &&\n    (element.defaultChecked = !!defaultChecked);\n  null != checked &&\n    (element.checked =\n      checked && "function" !== typeof checked && "symbol" !== typeof checked);\n  null != name &&\n  "function" !== typeof name &&\n  "symbol" !== typeof name &&\n  "boolean" !== typeof name\n    ? (element.name = "" + getToStringValue(name))\n    : element.removeAttribute("name");\n}\nfunction initInput(\n  element,\n  value,\n  defaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name,\n  isHydrating\n) {\n  null != type &&\n    "function" !== typeof type &&\n    "symbol" !== typeof type &&\n    "boolean" !== typeof type &&\n    (element.type = type);\n  if (null != value || null != defaultValue) {\n    if (\n      !(\n        ("submit" !== type && "reset" !== type) ||\n        (void 0 !== value && null !== value)\n      )\n    )\n      return;\n    defaultValue =\n      null != defaultValue ? "" + getToStringValue(defaultValue) : "";\n    value = null != value ? "" + getToStringValue(value) : defaultValue;\n    isHydrating || value === element.value || (element.value = value);\n    element.defaultValue = value;\n  }\n  checked = null != checked ? checked : defaultChecked;\n  checked =\n    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;\n  element.checked = isHydrating ? element.checked : !!checked;\n  element.defaultChecked = !!checked;\n  null != name &&\n    "function" !== typeof name &&\n    "symbol" !== typeof name &&\n    "boolean" !== typeof name &&\n    (element.name = name);\n}\nfunction setDefaultValue(node, type, value) {\n  ("number" === type && getActiveElement(node.ownerDocument) === node) ||\n    node.defaultValue === "" + value ||\n    (node.defaultValue = "" + value);\n}\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  node = node.options;\n  if (multiple) {\n    multiple = {};\n    for (var i = 0; i < propValue.length; i++)\n      multiple["$" + propValue[i]] = !0;\n    for (propValue = 0; propValue < node.length; propValue++)\n      (i = multiple.hasOwnProperty("$" + node[propValue].value)),\n        node[propValue].selected !== i && (node[propValue].selected = i),\n        i && setDefaultSelected && (node[propValue].defaultSelected = !0);\n  } else {\n    propValue = "" + getToStringValue(propValue);\n    multiple = null;\n    for (i = 0; i < node.length; i++) {\n      if (node[i].value === propValue) {\n        node[i].selected = !0;\n        setDefaultSelected && (node[i].defaultSelected = !0);\n        return;\n      }\n      null !== multiple || node[i].disabled || (multiple = node[i]);\n    }\n    null !== multiple && (multiple.selected = !0);\n  }\n}\nfunction updateTextarea(element, value, defaultValue) {\n  if (\n    null != value &&\n    ((value = "" + getToStringValue(value)),\n    value !== element.value && (element.value = value),\n    null == defaultValue)\n  ) {\n    element.defaultValue !== value && (element.defaultValue = value);\n    return;\n  }\n  element.defaultValue =\n    null != defaultValue ? "" + getToStringValue(defaultValue) : "";\n}\nfunction initTextarea(element, value, defaultValue, children) {\n  if (null == value) {\n    if (null != children) {\n      if (null != defaultValue) throw Error(formatProdErrorMessage(92));\n      if (isArrayImpl(children)) {\n        if (1 < children.length) throw Error(formatProdErrorMessage(93));\n        children = children[0];\n      }\n      defaultValue = children;\n    }\n    null == defaultValue && (defaultValue = "");\n    value = defaultValue;\n  }\n  defaultValue = getToStringValue(value);\n  element.defaultValue = defaultValue;\n  children = element.textContent;\n  children === defaultValue &&\n    "" !== children &&\n    null !== children &&\n    (element.value = children);\n}\nfunction setTextContent(node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n    if (\n      firstChild &&\n      firstChild === node.lastChild &&\n      3 === firstChild.nodeType\n    ) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n}\nvar unitlessNumbers = new Set(\n  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(\n    " "\n  )\n);\nfunction setValueForStyle(style, styleName, value) {\n  var isCustomProperty = 0 === styleName.indexOf("--");\n  null == value || "boolean" === typeof value || "" === value\n    ? isCustomProperty\n      ? style.setProperty(styleName, "")\n      : "float" === styleName\n        ? (style.cssFloat = "")\n        : (style[styleName] = "")\n    : isCustomProperty\n      ? style.setProperty(styleName, value)\n      : "number" !== typeof value ||\n          0 === value ||\n          unitlessNumbers.has(styleName)\n        ? "float" === styleName\n          ? (style.cssFloat = value)\n          : (style[styleName] = ("" + value).trim())\n        : (style[styleName] = value + "px");\n}\nfunction setValueForStyles(node, styles, prevStyles) {\n  if (null != styles && "object" !== typeof styles)\n    throw Error(formatProdErrorMessage(62));\n  node = node.style;\n  if (null != prevStyles) {\n    for (var styleName in prevStyles)\n      !prevStyles.hasOwnProperty(styleName) ||\n        (null != styles && styles.hasOwnProperty(styleName)) ||\n        (0 === styleName.indexOf("--")\n          ? node.setProperty(styleName, "")\n          : "float" === styleName\n            ? (node.cssFloat = "")\n            : (node[styleName] = ""));\n    for (var styleName$16 in styles)\n      (styleName = styles[styleName$16]),\n        styles.hasOwnProperty(styleName$16) &&\n          prevStyles[styleName$16] !== styleName &&\n          setValueForStyle(node, styleName$16, styleName);\n  } else\n    for (var styleName$17 in styles)\n      styles.hasOwnProperty(styleName$17) &&\n        setValueForStyle(node, styleName$17, styles[styleName$17]);\n}\nfunction isCustomElement(tagName) {\n  if (-1 === tagName.indexOf("-")) return !1;\n  switch (tagName) {\n    case "annotation-xml":\n    case "color-profile":\n    case "font-face":\n    case "font-face-src":\n    case "font-face-uri":\n    case "font-face-format":\n    case "font-face-name":\n    case "missing-glyph":\n      return !1;\n    default:\n      return !0;\n  }\n}\nvar aliases = new Map([\n    ["acceptCharset", "accept-charset"],\n    ["htmlFor", "for"],\n    ["httpEquiv", "http-equiv"],\n    ["crossOrigin", "crossorigin"],\n    ["accentHeight", "accent-height"],\n    ["alignmentBaseline", "alignment-baseline"],\n    ["arabicForm", "arabic-form"],\n    ["baselineShift", "baseline-shift"],\n    ["capHeight", "cap-height"],\n    ["clipPath", "clip-path"],\n    ["clipRule", "clip-rule"],\n    ["colorInterpolation", "color-interpolation"],\n    ["colorInterpolationFilters", "color-interpolation-filters"],\n    ["colorProfile", "color-profile"],\n    ["colorRendering", "color-rendering"],\n    ["dominantBaseline", "dominant-baseline"],\n    ["enableBackground", "enable-background"],\n    ["fillOpacity", "fill-opacity"],\n    ["fillRule", "fill-rule"],\n    ["floodColor", "flood-color"],\n    ["floodOpacity", "flood-opacity"],\n    ["fontFamily", "font-family"],\n    ["fontSize", "font-size"],\n    ["fontSizeAdjust", "font-size-adjust"],\n    ["fontStretch", "font-stretch"],\n    ["fontStyle", "font-style"],\n    ["fontVariant", "font-variant"],\n    ["fontWeight", "font-weight"],\n    ["glyphName", "glyph-name"],\n    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],\n    ["glyphOrientationVertical", "glyph-orientation-vertical"],\n    ["horizAdvX", "horiz-adv-x"],\n    ["horizOriginX", "horiz-origin-x"],\n    ["imageRendering", "image-rendering"],\n    ["letterSpacing", "letter-spacing"],\n    ["lightingColor", "lighting-color"],\n    ["markerEnd", "marker-end"],\n    ["markerMid", "marker-mid"],\n    ["markerStart", "marker-start"],\n    ["overlinePosition", "overline-position"],\n    ["overlineThickness", "overline-thickness"],\n    ["paintOrder", "paint-order"],\n    ["panose-1", "panose-1"],\n    ["pointerEvents", "pointer-events"],\n    ["renderingIntent", "rendering-intent"],\n    ["shapeRendering", "shape-rendering"],\n    ["stopColor", "stop-color"],\n    ["stopOpacity", "stop-opacity"],\n    ["strikethroughPosition", "strikethrough-position"],\n    ["strikethroughThickness", "strikethrough-thickness"],\n    ["strokeDasharray", "stroke-dasharray"],\n    ["strokeDashoffset", "stroke-dashoffset"],\n    ["strokeLinecap", "stroke-linecap"],\n    ["strokeLinejoin", "stroke-linejoin"],\n    ["strokeMiterlimit", "stroke-miterlimit"],\n    ["strokeOpacity", "stroke-opacity"],\n    ["strokeWidth", "stroke-width"],\n    ["textAnchor", "text-anchor"],\n    ["textDecoration", "text-decoration"],\n    ["textRendering", "text-rendering"],\n    ["transformOrigin", "transform-origin"],\n    ["underlinePosition", "underline-position"],\n    ["underlineThickness", "underline-thickness"],\n    ["unicodeBidi", "unicode-bidi"],\n    ["unicodeRange", "unicode-range"],\n    ["unitsPerEm", "units-per-em"],\n    ["vAlphabetic", "v-alphabetic"],\n    ["vHanging", "v-hanging"],\n    ["vIdeographic", "v-ideographic"],\n    ["vMathematical", "v-mathematical"],\n    ["vectorEffect", "vector-effect"],\n    ["vertAdvY", "vert-adv-y"],\n    ["vertOriginX", "vert-origin-x"],\n    ["vertOriginY", "vert-origin-y"],\n    ["wordSpacing", "word-spacing"],\n    ["writingMode", "writing-mode"],\n    ["xmlnsXlink", "xmlns:xlink"],\n    ["xHeight", "x-height"]\n  ]),\n  isJavaScriptProtocol =\n    /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i;\nfunction sanitizeURL(url) {\n  return isJavaScriptProtocol.test("" + url)\n    ? "javascript:throw new Error(\'React has blocked a javascript: URL as a security precaution.\')"\n    : url;\n}\nvar currentReplayingEvent = null;\nfunction getEventTarget(nativeEvent) {\n  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\n  nativeEvent.correspondingUseElement &&\n    (nativeEvent = nativeEvent.correspondingUseElement);\n  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\n}\nvar restoreTarget = null,\n  restoreQueue = null;\nfunction restoreStateOfTarget(target) {\n  var internalInstance = getInstanceFromNode(target);\n  if (internalInstance && (target = internalInstance.stateNode)) {\n    var props = target[internalPropsKey] || null;\n    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {\n      case "input":\n        updateInput(\n          target,\n          props.value,\n          props.defaultValue,\n          props.defaultValue,\n          props.checked,\n          props.defaultChecked,\n          props.type,\n          props.name\n        );\n        internalInstance = props.name;\n        if ("radio" === props.type && null != internalInstance) {\n          for (props = target; props.parentNode; ) props = props.parentNode;\n          props = props.querySelectorAll(\n            \'input[name="\' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                "" + internalInstance\n              ) +\n              \'"][type="radio"]\'\n          );\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          ) {\n            var otherNode = props[internalInstance];\n            if (otherNode !== target && otherNode.form === target.form) {\n              var otherProps = otherNode[internalPropsKey] || null;\n              if (!otherProps) throw Error(formatProdErrorMessage(90));\n              updateInput(\n                otherNode,\n                otherProps.value,\n                otherProps.defaultValue,\n                otherProps.defaultValue,\n                otherProps.checked,\n                otherProps.defaultChecked,\n                otherProps.type,\n                otherProps.name\n              );\n            }\n          }\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          )\n            (otherNode = props[internalInstance]),\n              otherNode.form === target.form && updateValueIfChanged(otherNode);\n        }\n        break a;\n      case "textarea":\n        updateTextarea(target, props.value, props.defaultValue);\n        break a;\n      case "select":\n        (internalInstance = props.value),\n          null != internalInstance &&\n            updateOptions(target, !!props.multiple, internalInstance, !1);\n    }\n  }\n}\nvar isInsideEventHandler = !1;\nfunction batchedUpdates$1(fn, a, b) {\n  if (isInsideEventHandler) return fn(a, b);\n  isInsideEventHandler = !0;\n  try {\n    var JSCompiler_inline_result = fn(a);\n    return JSCompiler_inline_result;\n  } finally {\n    if (\n      ((isInsideEventHandler = !1),\n      null !== restoreTarget || null !== restoreQueue)\n    )\n      if (\n        (flushSyncWork$1(),\n        restoreTarget &&\n          ((a = restoreTarget),\n          (fn = restoreQueue),\n          (restoreQueue = restoreTarget = null),\n          restoreStateOfTarget(a),\n          fn))\n      )\n        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);\n  }\n}\nfunction getListener(inst, registrationName) {\n  var stateNode = inst.stateNode;\n  if (null === stateNode) return null;\n  var props = stateNode[internalPropsKey] || null;\n  if (null === props) return null;\n  stateNode = props[registrationName];\n  a: switch (registrationName) {\n    case "onClick":\n    case "onClickCapture":\n    case "onDoubleClick":\n    case "onDoubleClickCapture":\n    case "onMouseDown":\n    case "onMouseDownCapture":\n    case "onMouseMove":\n    case "onMouseMoveCapture":\n    case "onMouseUp":\n    case "onMouseUpCapture":\n    case "onMouseEnter":\n      (props = !props.disabled) ||\n        ((inst = inst.type),\n        (props = !(\n          "button" === inst ||\n          "input" === inst ||\n          "select" === inst ||\n          "textarea" === inst\n        )));\n      inst = !props;\n      break a;\n    default:\n      inst = !1;\n  }\n  if (inst) return null;\n  if (stateNode && "function" !== typeof stateNode)\n    throw Error(\n      formatProdErrorMessage(231, registrationName, typeof stateNode)\n    );\n  return stateNode;\n}\nvar passiveBrowserEventsSupported = !1;\nif (canUseDOM)\n  try {\n    var options = {};\n    Object.defineProperty(options, "passive", {\n      get: function () {\n        passiveBrowserEventsSupported = !0;\n      }\n    });\n    window.addEventListener("test", options, options);\n    window.removeEventListener("test", options, options);\n  } catch (e) {\n    passiveBrowserEventsSupported = !1;\n  }\nvar root = null,\n  startText = null,\n  fallbackText = null;\nfunction getData() {\n  if (fallbackText) return fallbackText;\n  var start,\n    startValue = startText,\n    startLength = startValue.length,\n    end,\n    endValue = "value" in root ? root.value : root.textContent,\n    endLength = endValue.length;\n  for (\n    start = 0;\n    start < startLength && startValue[start] === endValue[start];\n    start++\n  );\n  var minEnd = startLength - start;\n  for (\n    end = 1;\n    end <= minEnd &&\n    startValue[startLength - end] === endValue[endLength - end];\n    end++\n  );\n  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));\n}\nfunction getEventCharCode(nativeEvent) {\n  var keyCode = nativeEvent.keyCode;\n  "charCode" in nativeEvent\n    ? ((nativeEvent = nativeEvent.charCode),\n      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))\n    : (nativeEvent = keyCode);\n  10 === nativeEvent && (nativeEvent = 13);\n  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\n}\nfunction functionThatReturnsTrue() {\n  return !0;\n}\nfunction functionThatReturnsFalse() {\n  return !1;\n}\nfunction createSyntheticEvent(Interface) {\n  function SyntheticBaseEvent(\n    reactName,\n    reactEventType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    this._reactName = reactName;\n    this._targetInst = targetInst;\n    this.type = reactEventType;\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEventTarget;\n    this.currentTarget = null;\n    for (var propName in Interface)\n      Interface.hasOwnProperty(propName) &&\n        ((reactName = Interface[propName]),\n        (this[propName] = reactName\n          ? reactName(nativeEvent)\n          : nativeEvent[propName]));\n    this.isDefaultPrevented = (\n      null != nativeEvent.defaultPrevented\n        ? nativeEvent.defaultPrevented\n        : !1 === nativeEvent.returnValue\n    )\n      ? functionThatReturnsTrue\n      : functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    return this;\n  }\n  assign(SyntheticBaseEvent.prototype, {\n    preventDefault: function () {\n      this.defaultPrevented = !0;\n      var event = this.nativeEvent;\n      event &&\n        (event.preventDefault\n          ? event.preventDefault()\n          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),\n        (this.isDefaultPrevented = functionThatReturnsTrue));\n    },\n    stopPropagation: function () {\n      var event = this.nativeEvent;\n      event &&\n        (event.stopPropagation\n          ? event.stopPropagation()\n          : "unknown" !== typeof event.cancelBubble &&\n            (event.cancelBubble = !0),\n        (this.isPropagationStopped = functionThatReturnsTrue));\n    },\n    persist: function () {},\n    isPersistent: functionThatReturnsTrue\n  });\n  return SyntheticBaseEvent;\n}\nvar EventInterface = {\n    eventPhase: 0,\n    bubbles: 0,\n    cancelable: 0,\n    timeStamp: function (event) {\n      return event.timeStamp || Date.now();\n    },\n    defaultPrevented: 0,\n    isTrusted: 0\n  },\n  SyntheticEvent = createSyntheticEvent(EventInterface),\n  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),\n  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),\n  lastMovementX,\n  lastMovementY,\n  lastMouseEvent,\n  MouseEventInterface = assign({}, UIEventInterface, {\n    screenX: 0,\n    screenY: 0,\n    clientX: 0,\n    clientY: 0,\n    pageX: 0,\n    pageY: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    getModifierState: getEventModifierState,\n    button: 0,\n    buttons: 0,\n    relatedTarget: function (event) {\n      return void 0 === event.relatedTarget\n        ? event.fromElement === event.srcElement\n          ? event.toElement\n          : event.fromElement\n        : event.relatedTarget;\n    },\n    movementX: function (event) {\n      if ("movementX" in event) return event.movementX;\n      event !== lastMouseEvent &&\n        (lastMouseEvent && "mousemove" === event.type\n          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),\n            (lastMovementY = event.screenY - lastMouseEvent.screenY))\n          : (lastMovementY = lastMovementX = 0),\n        (lastMouseEvent = event));\n      return lastMovementX;\n    },\n    movementY: function (event) {\n      return "movementY" in event ? event.movementY : lastMovementY;\n    }\n  }),\n  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),\n  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),\n  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),\n  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),\n  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),\n  AnimationEventInterface = assign({}, EventInterface, {\n    animationName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),\n  ClipboardEventInterface = assign({}, EventInterface, {\n    clipboardData: function (event) {\n      return "clipboardData" in event\n        ? event.clipboardData\n        : window.clipboardData;\n    }\n  }),\n  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),\n  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),\n  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),\n  normalizeKey = {\n    Esc: "Escape",\n    Spacebar: " ",\n    Left: "ArrowLeft",\n    Up: "ArrowUp",\n    Right: "ArrowRight",\n    Down: "ArrowDown",\n    Del: "Delete",\n    Win: "OS",\n    Menu: "ContextMenu",\n    Apps: "ContextMenu",\n    Scroll: "ScrollLock",\n    MozPrintableKey: "Unidentified"\n  },\n  translateToKey = {\n    8: "Backspace",\n    9: "Tab",\n    12: "Clear",\n    13: "Enter",\n    16: "Shift",\n    17: "Control",\n    18: "Alt",\n    19: "Pause",\n    20: "CapsLock",\n    27: "Escape",\n    32: " ",\n    33: "PageUp",\n    34: "PageDown",\n    35: "End",\n    36: "Home",\n    37: "ArrowLeft",\n    38: "ArrowUp",\n    39: "ArrowRight",\n    40: "ArrowDown",\n    45: "Insert",\n    46: "Delete",\n    112: "F1",\n    113: "F2",\n    114: "F3",\n    115: "F4",\n    116: "F5",\n    117: "F6",\n    118: "F7",\n    119: "F8",\n    120: "F9",\n    121: "F10",\n    122: "F11",\n    123: "F12",\n    144: "NumLock",\n    145: "ScrollLock",\n    224: "Meta"\n  },\n  modifierKeyToProp = {\n    Alt: "altKey",\n    Control: "ctrlKey",\n    Meta: "metaKey",\n    Shift: "shiftKey"\n  };\nfunction modifierStateGetter(keyArg) {\n  var nativeEvent = this.nativeEvent;\n  return nativeEvent.getModifierState\n    ? nativeEvent.getModifierState(keyArg)\n    : (keyArg = modifierKeyToProp[keyArg])\n      ? !!nativeEvent[keyArg]\n      : !1;\n}\nfunction getEventModifierState() {\n  return modifierStateGetter;\n}\nvar KeyboardEventInterface = assign({}, UIEventInterface, {\n    key: function (nativeEvent) {\n      if (nativeEvent.key) {\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n        if ("Unidentified" !== key) return key;\n      }\n      return "keypress" === nativeEvent.type\n        ? ((nativeEvent = getEventCharCode(nativeEvent)),\n          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))\n        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type\n          ? translateToKey[nativeEvent.keyCode] || "Unidentified"\n          : "";\n    },\n    code: 0,\n    location: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    repeat: 0,\n    locale: 0,\n    getModifierState: getEventModifierState,\n    charCode: function (event) {\n      return "keypress" === event.type ? getEventCharCode(event) : 0;\n    },\n    keyCode: function (event) {\n      return "keydown" === event.type || "keyup" === event.type\n        ? event.keyCode\n        : 0;\n    },\n    which: function (event) {\n      return "keypress" === event.type\n        ? getEventCharCode(event)\n        : "keydown" === event.type || "keyup" === event.type\n          ? event.keyCode\n          : 0;\n    }\n  }),\n  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),\n  PointerEventInterface = assign({}, MouseEventInterface, {\n    pointerId: 0,\n    width: 0,\n    height: 0,\n    pressure: 0,\n    tangentialPressure: 0,\n    tiltX: 0,\n    tiltY: 0,\n    twist: 0,\n    pointerType: 0,\n    isPrimary: 0\n  }),\n  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),\n  TouchEventInterface = assign({}, UIEventInterface, {\n    touches: 0,\n    targetTouches: 0,\n    changedTouches: 0,\n    altKey: 0,\n    metaKey: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    getModifierState: getEventModifierState\n  }),\n  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),\n  TransitionEventInterface = assign({}, EventInterface, {\n    propertyName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),\n  WheelEventInterface = assign({}, MouseEventInterface, {\n    deltaX: function (event) {\n      return "deltaX" in event\n        ? event.deltaX\n        : "wheelDeltaX" in event\n          ? -event.wheelDeltaX\n          : 0;\n    },\n    deltaY: function (event) {\n      return "deltaY" in event\n        ? event.deltaY\n        : "wheelDeltaY" in event\n          ? -event.wheelDeltaY\n          : "wheelDelta" in event\n            ? -event.wheelDelta\n            : 0;\n    },\n    deltaZ: 0,\n    deltaMode: 0\n  }),\n  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),\n  ToggleEventInterface = assign({}, EventInterface, {\n    newState: 0,\n    oldState: 0\n  }),\n  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),\n  END_KEYCODES = [9, 13, 27, 32],\n  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,\n  documentMode = null;\ncanUseDOM &&\n  "documentMode" in document &&\n  (documentMode = document.documentMode);\nvar canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,\n  useFallbackCompositionData =\n    canUseDOM &&\n    (!canUseCompositionEvent ||\n      (documentMode && 8 < documentMode && 11 >= documentMode)),\n  SPACEBAR_CHAR = String.fromCharCode(32),\n  hasSpaceKeypress = !1;\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case "keyup":\n      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\n    case "keydown":\n      return 229 !== nativeEvent.keyCode;\n    case "keypress":\n    case "mousedown":\n    case "focusout":\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction getDataFromCustomEvent(nativeEvent) {\n  nativeEvent = nativeEvent.detail;\n  return "object" === typeof nativeEvent && "data" in nativeEvent\n    ? nativeEvent.data\n    : null;\n}\nvar isComposing = !1;\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case "compositionend":\n      return getDataFromCustomEvent(nativeEvent);\n    case "keypress":\n      if (32 !== nativeEvent.which) return null;\n      hasSpaceKeypress = !0;\n      return SPACEBAR_CHAR;\n    case "textInput":\n      return (\n        (domEventName = nativeEvent.data),\n        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName\n      );\n    default:\n      return null;\n  }\n}\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\n  if (isComposing)\n    return "compositionend" === domEventName ||\n      (!canUseCompositionEvent &&\n        isFallbackCompositionEnd(domEventName, nativeEvent))\n      ? ((domEventName = getData()),\n        (fallbackText = startText = root = null),\n        (isComposing = !1),\n        domEventName)\n      : null;\n  switch (domEventName) {\n    case "paste":\n      return null;\n    case "keypress":\n      if (\n        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||\n        (nativeEvent.ctrlKey && nativeEvent.altKey)\n      ) {\n        if (nativeEvent.char && 1 < nativeEvent.char.length)\n          return nativeEvent.char;\n        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\n      }\n      return null;\n    case "compositionend":\n      return useFallbackCompositionData && "ko" !== nativeEvent.locale\n        ? null\n        : nativeEvent.data;\n    default:\n      return null;\n  }\n}\nvar supportedInputTypes = {\n  color: !0,\n  date: !0,\n  datetime: !0,\n  "datetime-local": !0,\n  email: !0,\n  month: !0,\n  number: !0,\n  password: !0,\n  range: !0,\n  search: !0,\n  tel: !0,\n  text: !0,\n  time: !0,\n  url: !0,\n  week: !0\n};\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return "input" === nodeName\n    ? !!supportedInputTypes[elem.type]\n    : "textarea" === nodeName\n      ? !0\n      : !1;\n}\nfunction createAndAccumulateChangeEvent(\n  dispatchQueue,\n  inst,\n  nativeEvent,\n  target\n) {\n  restoreTarget\n    ? restoreQueue\n      ? restoreQueue.push(target)\n      : (restoreQueue = [target])\n    : (restoreTarget = target);\n  inst = accumulateTwoPhaseListeners(inst, "onChange");\n  0 < inst.length &&\n    ((nativeEvent = new SyntheticEvent(\n      "onChange",\n      "change",\n      null,\n      nativeEvent,\n      target\n    )),\n    dispatchQueue.push({ event: nativeEvent, listeners: inst }));\n}\nvar activeElement$1 = null,\n  activeElementInst$1 = null;\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance(targetInst);\n  if (updateValueIfChanged(targetNode)) return targetInst;\n}\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\n  if ("change" === domEventName) return targetInst;\n}\nvar isInputEventSupported = !1;\nif (canUseDOM) {\n  var JSCompiler_inline_result$jscomp$283;\n  if (canUseDOM) {\n    var isSupported$jscomp$inline_418 = "oninput" in document;\n    if (!isSupported$jscomp$inline_418) {\n      var element$jscomp$inline_419 = document.createElement("div");\n      element$jscomp$inline_419.setAttribute("oninput", "return;");\n      isSupported$jscomp$inline_418 =\n        "function" === typeof element$jscomp$inline_419.oninput;\n    }\n    JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;\n  } else JSCompiler_inline_result$jscomp$283 = !1;\n  isInputEventSupported =\n    JSCompiler_inline_result$jscomp$283 &&\n    (!document.documentMode || 9 < document.documentMode);\n}\nfunction stopWatchingForValueChange() {\n  activeElement$1 &&\n    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),\n    (activeElementInst$1 = activeElement$1 = null));\n}\nfunction handlePropertyChange(nativeEvent) {\n  if (\n    "value" === nativeEvent.propertyName &&\n    getInstIfValueChanged(activeElementInst$1)\n  ) {\n    var dispatchQueue = [];\n    createAndAccumulateChangeEvent(\n      dispatchQueue,\n      activeElementInst$1,\n      nativeEvent,\n      getEventTarget(nativeEvent)\n    );\n    batchedUpdates$1(runEventInBatch, dispatchQueue);\n  }\n}\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n  "focusin" === domEventName\n    ? (stopWatchingForValueChange(),\n      (activeElement$1 = target),\n      (activeElementInst$1 = targetInst),\n      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))\n    : "focusout" === domEventName && stopWatchingForValueChange();\n}\nfunction getTargetInstForInputEventPolyfill(domEventName) {\n  if (\n    "selectionchange" === domEventName ||\n    "keyup" === domEventName ||\n    "keydown" === domEventName\n  )\n    return getInstIfValueChanged(activeElementInst$1);\n}\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\n  if ("click" === domEventName) return getInstIfValueChanged(targetInst);\n}\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n  if ("input" === domEventName || "change" === domEventName)\n    return getInstIfValueChanged(targetInst);\n}\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = "function" === typeof Object.is ? Object.is : is;\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) return !0;\n  if (\n    "object" !== typeof objA ||\n    null === objA ||\n    "object" !== typeof objB ||\n    null === objB\n  )\n    return !1;\n  var keysA = Object.keys(objA),\n    keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return !1;\n  for (keysB = 0; keysB < keysA.length; keysB++) {\n    var currentKey = keysA[keysB];\n    if (\n      !hasOwnProperty.call(objB, currentKey) ||\n      !objectIs(objA[currentKey], objB[currentKey])\n    )\n      return !1;\n  }\n  return !0;\n}\nfunction getLeafNode(node) {\n  for (; node && node.firstChild; ) node = node.firstChild;\n  return node;\n}\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  root = 0;\n  for (var nodeEnd; node; ) {\n    if (3 === node.nodeType) {\n      nodeEnd = root + node.textContent.length;\n      if (root <= offset && nodeEnd >= offset)\n        return { node: node, offset: offset - root };\n      root = nodeEnd;\n    }\n    a: {\n      for (; node; ) {\n        if (node.nextSibling) {\n          node = node.nextSibling;\n          break a;\n        }\n        node = node.parentNode;\n      }\n      node = void 0;\n    }\n    node = getLeafNode(node);\n  }\n}\nfunction containsNode(outerNode, innerNode) {\n  return outerNode && innerNode\n    ? outerNode === innerNode\n      ? !0\n      : outerNode && 3 === outerNode.nodeType\n        ? !1\n        : innerNode && 3 === innerNode.nodeType\n          ? containsNode(outerNode, innerNode.parentNode)\n          : "contains" in outerNode\n            ? outerNode.contains(innerNode)\n            : outerNode.compareDocumentPosition\n              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)\n              : !1\n    : !1;\n}\nfunction getActiveElementDeep(containerInfo) {\n  containerInfo =\n    null != containerInfo &&\n    null != containerInfo.ownerDocument &&\n    null != containerInfo.ownerDocument.defaultView\n      ? containerInfo.ownerDocument.defaultView\n      : window;\n  for (\n    var element = getActiveElement(containerInfo.document);\n    element instanceof containerInfo.HTMLIFrameElement;\n\n  ) {\n    try {\n      var JSCompiler_inline_result =\n        "string" === typeof element.contentWindow.location.href;\n    } catch (err) {\n      JSCompiler_inline_result = !1;\n    }\n    if (JSCompiler_inline_result) containerInfo = element.contentWindow;\n    else break;\n    element = getActiveElement(containerInfo.document);\n  }\n  return element;\n}\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName &&\n    (("input" === nodeName &&\n      ("text" === elem.type ||\n        "search" === elem.type ||\n        "tel" === elem.type ||\n        "url" === elem.type ||\n        "password" === elem.type)) ||\n      "textarea" === nodeName ||\n      "true" === elem.contentEditable)\n  );\n}\nfunction restoreSelection(priorSelectionInformation, containerInfo) {\n  var curFocusedElem = getActiveElementDeep(containerInfo);\n  containerInfo = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (\n    curFocusedElem !== containerInfo &&\n    containerInfo &&\n    containerInfo.ownerDocument &&\n    containsNode(containerInfo.ownerDocument.documentElement, containerInfo)\n  ) {\n    if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo))\n      if (\n        ((priorSelectionInformation = priorSelectionRange.start),\n        (curFocusedElem = priorSelectionRange.end),\n        void 0 === curFocusedElem &&\n          (curFocusedElem = priorSelectionInformation),\n        "selectionStart" in containerInfo)\n      )\n        (containerInfo.selectionStart = priorSelectionInformation),\n          (containerInfo.selectionEnd = Math.min(\n            curFocusedElem,\n            containerInfo.value.length\n          ));\n      else if (\n        ((curFocusedElem =\n          ((priorSelectionInformation =\n            containerInfo.ownerDocument || document) &&\n            priorSelectionInformation.defaultView) ||\n          window),\n        curFocusedElem.getSelection)\n      ) {\n        curFocusedElem = curFocusedElem.getSelection();\n        var length = containerInfo.textContent.length,\n          start = Math.min(priorSelectionRange.start, length);\n        priorSelectionRange =\n          void 0 === priorSelectionRange.end\n            ? start\n            : Math.min(priorSelectionRange.end, length);\n        !curFocusedElem.extend &&\n          start > priorSelectionRange &&\n          ((length = priorSelectionRange),\n          (priorSelectionRange = start),\n          (start = length));\n        length = getNodeForCharacterOffset(containerInfo, start);\n        var endMarker = getNodeForCharacterOffset(\n          containerInfo,\n          priorSelectionRange\n        );\n        length &&\n          endMarker &&\n          (1 !== curFocusedElem.rangeCount ||\n            curFocusedElem.anchorNode !== length.node ||\n            curFocusedElem.anchorOffset !== length.offset ||\n            curFocusedElem.focusNode !== endMarker.node ||\n            curFocusedElem.focusOffset !== endMarker.offset) &&\n          ((priorSelectionInformation =\n            priorSelectionInformation.createRange()),\n          priorSelectionInformation.setStart(length.node, length.offset),\n          curFocusedElem.removeAllRanges(),\n          start > priorSelectionRange\n            ? (curFocusedElem.addRange(priorSelectionInformation),\n              curFocusedElem.extend(endMarker.node, endMarker.offset))\n            : (priorSelectionInformation.setEnd(\n                endMarker.node,\n                endMarker.offset\n              ),\n              curFocusedElem.addRange(priorSelectionInformation)));\n      }\n    priorSelectionInformation = [];\n    for (\n      curFocusedElem = containerInfo;\n      (curFocusedElem = curFocusedElem.parentNode);\n\n    )\n      1 === curFocusedElem.nodeType &&\n        priorSelectionInformation.push({\n          element: curFocusedElem,\n          left: curFocusedElem.scrollLeft,\n          top: curFocusedElem.scrollTop\n        });\n    "function" === typeof containerInfo.focus && containerInfo.focus();\n    for (\n      containerInfo = 0;\n      containerInfo < priorSelectionInformation.length;\n      containerInfo++\n    )\n      (curFocusedElem = priorSelectionInformation[containerInfo]),\n        (curFocusedElem.element.scrollLeft = curFocusedElem.left),\n        (curFocusedElem.element.scrollTop = curFocusedElem.top);\n  }\n}\nvar skipSelectionChangeEvent =\n    canUseDOM && "documentMode" in document && 11 >= document.documentMode,\n  activeElement = null,\n  activeElementInst = null,\n  lastSelection = null,\n  mouseDown = !1;\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  var doc =\n    nativeEventTarget.window === nativeEventTarget\n      ? nativeEventTarget.document\n      : 9 === nativeEventTarget.nodeType\n        ? nativeEventTarget\n        : nativeEventTarget.ownerDocument;\n  mouseDown ||\n    null == activeElement ||\n    activeElement !== getActiveElement(doc) ||\n    ((doc = activeElement),\n    "selectionStart" in doc && hasSelectionCapabilities(doc)\n      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })\n      : ((doc = (\n          (doc.ownerDocument && doc.ownerDocument.defaultView) ||\n          window\n        ).getSelection()),\n        (doc = {\n          anchorNode: doc.anchorNode,\n          anchorOffset: doc.anchorOffset,\n          focusNode: doc.focusNode,\n          focusOffset: doc.focusOffset\n        })),\n    (lastSelection && shallowEqual(lastSelection, doc)) ||\n      ((lastSelection = doc),\n      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),\n      0 < doc.length &&\n        ((nativeEvent = new SyntheticEvent(\n          "onSelect",\n          "select",\n          null,\n          nativeEvent,\n          nativeEventTarget\n        )),\n        dispatchQueue.push({ event: nativeEvent, listeners: doc }),\n        (nativeEvent.target = activeElement))));\n}\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes["Webkit" + styleProp] = "webkit" + eventName;\n  prefixes["Moz" + styleProp] = "moz" + eventName;\n  return prefixes;\n}\nvar vendorPrefixes = {\n    animationend: makePrefixMap("Animation", "AnimationEnd"),\n    animationiteration: makePrefixMap("Animation", "AnimationIteration"),\n    animationstart: makePrefixMap("Animation", "AnimationStart"),\n    transitionrun: makePrefixMap("Transition", "TransitionRun"),\n    transitionstart: makePrefixMap("Transition", "TransitionStart"),\n    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),\n    transitionend: makePrefixMap("Transition", "TransitionEnd")\n  },\n  prefixedEventNames = {},\n  style = {};\ncanUseDOM &&\n  ((style = document.createElement("div").style),\n  "AnimationEvent" in window ||\n    (delete vendorPrefixes.animationend.animation,\n    delete vendorPrefixes.animationiteration.animation,\n    delete vendorPrefixes.animationstart.animation),\n  "TransitionEvent" in window ||\n    delete vendorPrefixes.transitionend.transition);\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\n  if (!vendorPrefixes[eventName]) return eventName;\n  var prefixMap = vendorPrefixes[eventName],\n    styleProp;\n  for (styleProp in prefixMap)\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\n  return eventName;\n}\nvar ANIMATION_END = getVendorPrefixedEventName("animationend"),\n  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),\n  ANIMATION_START = getVendorPrefixedEventName("animationstart"),\n  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),\n  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),\n  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),\n  TRANSITION_END = getVendorPrefixedEventName("transitionend"),\n  topLevelEventsToReactNames = new Map(),\n  simpleEventPluginEvents =\n    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(\n      " "\n    );\nfunction registerSimpleEvent(domEventName, reactName) {\n  topLevelEventsToReactNames.set(domEventName, reactName);\n  registerTwoPhaseEvent(reactName, [domEventName]);\n}\nvar concurrentQueues = [],\n  concurrentQueuesIndex = 0,\n  concurrentlyUpdatedLanes = 0;\nfunction finishQueueingConcurrentUpdates() {\n  for (\n    var endIndex = concurrentQueuesIndex,\n      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);\n    i < endIndex;\n\n  ) {\n    var fiber = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var queue = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var update = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var lane = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    if (null !== queue && null !== update) {\n      var pending = queue.pending;\n      null === pending\n        ? (update.next = update)\n        : ((update.next = pending.next), (pending.next = update));\n      queue.pending = update;\n    }\n    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n  }\n}\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n  concurrentlyUpdatedLanes |= lane;\n  fiber.lanes |= lane;\n  fiber = fiber.alternate;\n  null !== fiber && (fiber.lanes |= lane);\n}\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  enqueueUpdate$1(fiber, queue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\n  enqueueUpdate$1(fiber, null, null, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n  sourceFiber.lanes |= lane;\n  var alternate = sourceFiber.alternate;\n  null !== alternate && (alternate.lanes |= lane);\n  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )\n    (parent.childLanes |= lane),\n      (alternate = parent.alternate),\n      null !== alternate && (alternate.childLanes |= lane),\n      22 === parent.tag &&\n        ((sourceFiber = parent.stateNode),\n        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),\n      (sourceFiber = parent),\n      (parent = parent.return);\n  isHidden &&\n    null !== update &&\n    3 === sourceFiber.tag &&\n    ((parent = sourceFiber.stateNode),\n    (isHidden = 31 - clz32(lane)),\n    (parent = parent.hiddenUpdates),\n    (sourceFiber = parent[isHidden]),\n    null === sourceFiber\n      ? (parent[isHidden] = [update])\n      : sourceFiber.push(update),\n    (update.lane = lane | 536870912));\n}\nfunction getRootForUpdatedFiber(sourceFiber) {\n  if (50 < nestedUpdateCount)\n    throw (\n      ((nestedUpdateCount = 0),\n      (rootWithNestedUpdates = null),\n      Error(formatProdErrorMessage(185)))\n    );\n  for (var parent = sourceFiber.return; null !== parent; )\n    (sourceFiber = parent), (parent = sourceFiber.return);\n  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;\n}\nvar emptyContextObject = {},\n  CapturedStacks = new WeakMap();\nfunction createCapturedValueAtFiber(value, source) {\n  if ("object" === typeof value && null !== value) {\n    var existing = CapturedStacks.get(value);\n    if (void 0 !== existing) return existing;\n    source = {\n      value: value,\n      source: source,\n      stack: getStackByFiberInDevAndProd(source)\n    };\n    CapturedStacks.set(value, source);\n    return source;\n  }\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\nvar forkStack = [],\n  forkStackIndex = 0,\n  treeForkProvider = null,\n  treeForkCount = 0,\n  idStack = [],\n  idStackIndex = 0,\n  treeContextProvider = null,\n  treeContextId = 1,\n  treeContextOverflow = "";\nfunction pushTreeFork(workInProgress, totalChildren) {\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  workInProgress = treeContextOverflow;\n  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n  baseIdWithLeadingBit &= ~(1 << baseLength);\n  index += 1;\n  var length = 32 - clz32(totalChildren) + baseLength;\n  if (30 < length) {\n    var numberOfOverflowBits = baseLength - (baseLength % 5);\n    length = (\n      baseIdWithLeadingBit &\n      ((1 << numberOfOverflowBits) - 1)\n    ).toString(32);\n    baseIdWithLeadingBit >>= numberOfOverflowBits;\n    baseLength -= numberOfOverflowBits;\n    treeContextId =\n      (1 << (32 - clz32(totalChildren) + baseLength)) |\n      (index << baseLength) |\n      baseIdWithLeadingBit;\n    treeContextOverflow = length + workInProgress;\n  } else\n    (treeContextId =\n      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),\n      (treeContextOverflow = workInProgress);\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  null !== workInProgress.return &&\n    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n}\nfunction popTreeContext(workInProgress) {\n  for (; workInProgress === treeForkProvider; )\n    (treeForkProvider = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null),\n      (treeForkCount = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null);\n  for (; workInProgress === treeContextProvider; )\n    (treeContextProvider = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextOverflow = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextId = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null);\n}\nvar hydrationParentFiber = null,\n  nextHydratableInstance = null,\n  isHydrating = !1,\n  hydrationErrors = null,\n  rootOrSingletonContext = !1,\n  HydrationMismatchException = Error(formatProdErrorMessage(519));\nfunction throwOnHydrationMismatch(fiber) {\n  var error = Error(formatProdErrorMessage(418, ""));\n  queueHydrationError(createCapturedValueAtFiber(error, fiber));\n  throw HydrationMismatchException;\n}\nfunction prepareToHydrateHostInstance(fiber) {\n  var instance = fiber.stateNode,\n    type = fiber.type,\n    props = fiber.memoizedProps;\n  instance[internalInstanceKey] = fiber;\n  instance[internalPropsKey] = props;\n  switch (type) {\n    case "dialog":\n      listenToNonDelegatedEvent("cancel", instance);\n      listenToNonDelegatedEvent("close", instance);\n      break;\n    case "iframe":\n    case "object":\n    case "embed":\n      listenToNonDelegatedEvent("load", instance);\n      break;\n    case "video":\n    case "audio":\n      for (type = 0; type < mediaEventTypes.length; type++)\n        listenToNonDelegatedEvent(mediaEventTypes[type], instance);\n      break;\n    case "source":\n      listenToNonDelegatedEvent("error", instance);\n      break;\n    case "img":\n    case "image":\n    case "link":\n      listenToNonDelegatedEvent("error", instance);\n      listenToNonDelegatedEvent("load", instance);\n      break;\n    case "details":\n      listenToNonDelegatedEvent("toggle", instance);\n      break;\n    case "input":\n      listenToNonDelegatedEvent("invalid", instance);\n      initInput(\n        instance,\n        props.value,\n        props.defaultValue,\n        props.checked,\n        props.defaultChecked,\n        props.type,\n        props.name,\n        !0\n      );\n      track(instance);\n      break;\n    case "select":\n      listenToNonDelegatedEvent("invalid", instance);\n      break;\n    case "textarea":\n      listenToNonDelegatedEvent("invalid", instance),\n        initTextarea(instance, props.value, props.defaultValue, props.children),\n        track(instance);\n  }\n  type = props.children;\n  ("string" !== typeof type &&\n    "number" !== typeof type &&\n    "bigint" !== typeof type) ||\n  instance.textContent === "" + type ||\n  !0 === props.suppressHydrationWarning ||\n  checkForUnmatchedText(instance.textContent, type)\n    ? (null != props.popover &&\n        (listenToNonDelegatedEvent("beforetoggle", instance),\n        listenToNonDelegatedEvent("toggle", instance)),\n      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),\n      null != props.onScrollEnd &&\n        listenToNonDelegatedEvent("scrollend", instance),\n      null != props.onClick && (instance.onclick = noop$1),\n      (instance = !0))\n    : (instance = !1);\n  instance || throwOnHydrationMismatch(fiber);\n}\nfunction popToNextHostParent(fiber) {\n  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )\n    switch (hydrationParentFiber.tag) {\n      case 3:\n      case 27:\n        rootOrSingletonContext = !0;\n        return;\n      case 5:\n      case 13:\n        rootOrSingletonContext = !1;\n        return;\n      default:\n        hydrationParentFiber = hydrationParentFiber.return;\n    }\n}\nfunction popHydrationState(fiber) {\n  if (fiber !== hydrationParentFiber) return !1;\n  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;\n  var shouldClear = !1,\n    JSCompiler_temp;\n  if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {\n    if ((JSCompiler_temp = 5 === fiber.tag))\n      (JSCompiler_temp = fiber.type),\n        (JSCompiler_temp =\n          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||\n          shouldSetTextContent(fiber.type, fiber.memoizedProps));\n    JSCompiler_temp = !JSCompiler_temp;\n  }\n  JSCompiler_temp && (shouldClear = !0);\n  shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);\n  popToNextHostParent(fiber);\n  if (13 === fiber.tag) {\n    fiber = fiber.memoizedState;\n    fiber = null !== fiber ? fiber.dehydrated : null;\n    if (!fiber) throw Error(formatProdErrorMessage(317));\n    a: {\n      fiber = fiber.nextSibling;\n      for (shouldClear = 0; fiber; ) {\n        if (8 === fiber.nodeType)\n          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {\n            if (0 === shouldClear) {\n              nextHydratableInstance = getNextHydratable(fiber.nextSibling);\n              break a;\n            }\n            shouldClear--;\n          } else\n            ("$" !== JSCompiler_temp &&\n              "$!" !== JSCompiler_temp &&\n              "$?" !== JSCompiler_temp) ||\n              shouldClear++;\n        fiber = fiber.nextSibling;\n      }\n      nextHydratableInstance = null;\n    }\n  } else\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratable(fiber.stateNode.nextSibling)\n      : null;\n  return !0;\n}\nfunction resetHydrationState() {\n  nextHydratableInstance = hydrationParentFiber = null;\n  isHydrating = !1;\n}\nfunction queueHydrationError(error) {\n  null === hydrationErrors\n    ? (hydrationErrors = [error])\n    : hydrationErrors.push(error);\n}\nvar SuspenseException = Error(formatProdErrorMessage(460)),\n  SuspenseyCommitException = Error(formatProdErrorMessage(474)),\n  noopSuspenseyCommitThenable = { then: function () {} };\nfunction isThenableResolved(thenable) {\n  thenable = thenable.status;\n  return "fulfilled" === thenable || "rejected" === thenable;\n}\nfunction noop$3() {}\nfunction trackUsedThenable(thenableState, thenable, index) {\n  index = thenableState[index];\n  void 0 === index\n    ? thenableState.push(thenable)\n    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));\n  switch (thenable.status) {\n    case "fulfilled":\n      return thenable.value;\n    case "rejected":\n      thenableState = thenable.reason;\n      if (thenableState === SuspenseException)\n        throw Error(formatProdErrorMessage(483));\n      throw thenableState;\n    default:\n      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);\n      else {\n        thenableState = workInProgressRoot;\n        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)\n          throw Error(formatProdErrorMessage(482));\n        thenableState = thenable;\n        thenableState.status = "pending";\n        thenableState.then(\n          function (fulfilledValue) {\n            if ("pending" === thenable.status) {\n              var fulfilledThenable = thenable;\n              fulfilledThenable.status = "fulfilled";\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          function (error) {\n            if ("pending" === thenable.status) {\n              var rejectedThenable = thenable;\n              rejectedThenable.status = "rejected";\n              rejectedThenable.reason = error;\n            }\n          }\n        );\n      }\n      switch (thenable.status) {\n        case "fulfilled":\n          return thenable.value;\n        case "rejected":\n          thenableState = thenable.reason;\n          if (thenableState === SuspenseException)\n            throw Error(formatProdErrorMessage(483));\n          throw thenableState;\n      }\n      suspendedThenable = thenable;\n      throw SuspenseException;\n  }\n}\nvar suspendedThenable = null;\nfunction getSuspendedThenable() {\n  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\n  var thenable = suspendedThenable;\n  suspendedThenable = null;\n  return thenable;\n}\nvar thenableState$1 = null,\n  thenableIndexCounter$1 = 0;\nfunction unwrapThenable(thenable) {\n  var index = thenableIndexCounter$1;\n  thenableIndexCounter$1 += 1;\n  null === thenableState$1 && (thenableState$1 = []);\n  return trackUsedThenable(thenableState$1, thenable, index);\n}\nfunction coerceRef(workInProgress, element) {\n  element = element.props.ref;\n  workInProgress.ref = void 0 !== element ? element : null;\n}\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)\n    throw Error(formatProdErrorMessage(525));\n  returnFiber = Object.prototype.toString.call(newChild);\n  throw Error(\n    formatProdErrorMessage(\n      31,\n      "[object Object]" === returnFiber\n        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"\n        : returnFiber\n    )\n  );\n}\nfunction resolveLazy(lazyType) {\n  var init = lazyType._init;\n  return init(lazyType._payload);\n}\nfunction createChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (shouldTrackSideEffects) {\n      var deletions = returnFiber.deletions;\n      null === deletions\n        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))\n        : deletions.push(childToDelete);\n    }\n  }\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) return null;\n    for (; null !== currentFirstChild; )\n      deleteChild(returnFiber, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return null;\n  }\n  function mapRemainingChildren(currentFirstChild) {\n    for (var existingChildren = new Map(); null !== currentFirstChild; )\n      null !== currentFirstChild.key\n        ? existingChildren.set(currentFirstChild.key, currentFirstChild)\n        : existingChildren.set(currentFirstChild.index, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return existingChildren;\n  }\n  function useFiber(fiber, pendingProps) {\n    fiber = createWorkInProgress(fiber, pendingProps);\n    fiber.index = 0;\n    fiber.sibling = null;\n    return fiber;\n  }\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects)\n      return (newFiber.flags |= 1048576), lastPlacedIndex;\n    newIndex = newFiber.alternate;\n    if (null !== newIndex)\n      return (\n        (newIndex = newIndex.index),\n        newIndex < lastPlacedIndex\n          ? ((newFiber.flags |= 33554434), lastPlacedIndex)\n          : newIndex\n      );\n    newFiber.flags |= 33554434;\n    return lastPlacedIndex;\n  }\n  function placeSingleChild(newFiber) {\n    shouldTrackSideEffects &&\n      null === newFiber.alternate &&\n      (newFiber.flags |= 33554434);\n    return newFiber;\n  }\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (null === current || 6 !== current.tag)\n      return (\n        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, textContent);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE)\n      return updateFragment(\n        returnFiber,\n        current,\n        element.props.children,\n        lanes,\n        element.key\n      );\n    if (\n      null !== current &&\n      (current.elementType === elementType ||\n        ("object" === typeof elementType &&\n          null !== elementType &&\n          elementType.$$typeof === REACT_LAZY_TYPE &&\n          resolveLazy(elementType) === current.type))\n    )\n      return (\n        (current = useFiber(current, element.props)),\n        coerceRef(current, element),\n        (current.return = returnFiber),\n        current\n      );\n    current = createFiberFromTypeAndProps(\n      element.type,\n      element.key,\n      element.props,\n      null,\n      returnFiber.mode,\n      lanes\n    );\n    coerceRef(current, element);\n    current.return = returnFiber;\n    return current;\n  }\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (\n      null === current ||\n      4 !== current.tag ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    )\n      return (\n        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, portal.children || []);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (null === current || 7 !== current.tag)\n      return (\n        (current = createFiberFromFragment(\n          fragment,\n          returnFiber.mode,\n          lanes,\n          key\n        )),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, fragment);\n    current.return = returnFiber;\n    return current;\n  }\n  function createChild(returnFiber, newChild, lanes) {\n    if (\n      ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n    )\n      return (\n        (newChild = createFiberFromText(\n          "" + newChild,\n          returnFiber.mode,\n          lanes\n        )),\n        (newChild.return = returnFiber),\n        newChild\n      );\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (lanes = createFiberFromTypeAndProps(\n              newChild.type,\n              newChild.key,\n              newChild.props,\n              null,\n              returnFiber.mode,\n              lanes\n            )),\n            coerceRef(lanes, newChild),\n            (lanes.return = returnFiber),\n            lanes\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (newChild = createFiberFromPortal(\n              newChild,\n              returnFiber.mode,\n              lanes\n            )),\n            (newChild.return = returnFiber),\n            newChild\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return createChild(returnFiber, newChild, lanes);\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (newChild = createFiberFromFragment(\n            newChild,\n            returnFiber.mode,\n            lanes,\n            null\n          )),\n          (newChild.return = returnFiber),\n          newChild\n        );\n      if ("function" === typeof newChild.then)\n        return createChild(returnFiber, unwrapThenable(newChild), lanes);\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return createChild(\n          returnFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    var key = null !== oldFiber ? oldFiber.key : null;\n    if (\n      ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n    )\n      return null !== key\n        ? null\n        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return newChild.key === key\n            ? updateElement(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_PORTAL_TYPE:\n          return newChild.key === key\n            ? updatePortal(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            updateSlot(returnFiber, oldFiber, newChild, lanes)\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return null !== key\n          ? null\n          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      if ("function" === typeof newChild.then)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    lanes\n  ) {\n    if (\n      ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n    )\n      return (\n        (existingChildren = existingChildren.get(newIdx) || null),\n        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)\n      );\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updateElement(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updatePortal(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return updateFromMap(\n            existingChildren,\n            returnFiber,\n            newIdx,\n            newChild,\n            lanes\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (existingChildren = existingChildren.get(newIdx) || null),\n          updateFragment(returnFiber, existingChildren, newChild, lanes, null)\n        );\n      if ("function" === typeof newChild.then)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null;\n      null !== oldFiber && newIdx < newChildren.length;\n      newIdx++\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        lanes\n      );\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (newIdx === newChildren.length)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; newIdx < newChildren.length; newIdx++)\n        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),\n          null !== oldFiber &&\n            ((currentFirstChild = placeChild(\n              oldFiber,\n              currentFirstChild,\n              newIdx\n            )),\n            null === previousNewFiber\n              ? (resultingFirstChild = oldFiber)\n              : (previousNewFiber.sibling = oldFiber),\n            (previousNewFiber = oldFiber));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      newIdx < newChildren.length;\n      newIdx++\n    )\n      (nextOldFiber = updateFromMap(\n        oldFiber,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        lanes\n      )),\n        null !== nextOldFiber &&\n          (shouldTrackSideEffects &&\n            null !== nextOldFiber.alternate &&\n            oldFiber.delete(\n              null === nextOldFiber.key ? newIdx : nextOldFiber.key\n            ),\n          (currentFirstChild = placeChild(\n            nextOldFiber,\n            currentFirstChild,\n            newIdx\n          )),\n          null === previousNewFiber\n            ? (resultingFirstChild = nextOldFiber)\n            : (previousNewFiber.sibling = nextOldFiber),\n          (previousNewFiber = nextOldFiber));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    if (null == newChildren) throw Error(formatProdErrorMessage(151));\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null,\n        step = newChildren.next();\n      null !== oldFiber && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (step.done)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; !step.done; newIdx++, step = newChildren.next())\n        (step = createChild(returnFiber, step.value, lanes)),\n          null !== step &&\n            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n            null === previousNewFiber\n              ? (resultingFirstChild = step)\n              : (previousNewFiber.sibling = step),\n            (previousNewFiber = step));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      !step.done;\n      newIdx++, step = newChildren.next()\n    )\n      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),\n        null !== step &&\n          (shouldTrackSideEffects &&\n            null !== step.alternate &&\n            oldFiber.delete(null === step.key ? newIdx : step.key),\n          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n          null === previousNewFiber\n            ? (resultingFirstChild = step)\n            : (previousNewFiber.sibling = step),\n          (previousNewFiber = step));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildFibersImpl(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    lanes\n  ) {\n    "object" === typeof newChild &&\n      null !== newChild &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      null === newChild.key &&\n      (newChild = newChild.props.children);\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          a: {\n            for (var key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key) {\n                key = newChild.type;\n                if (key === REACT_FRAGMENT_TYPE) {\n                  if (7 === currentFirstChild.tag) {\n                    deleteRemainingChildren(\n                      returnFiber,\n                      currentFirstChild.sibling\n                    );\n                    lanes = useFiber(\n                      currentFirstChild,\n                      newChild.props.children\n                    );\n                    lanes.return = returnFiber;\n                    returnFiber = lanes;\n                    break a;\n                  }\n                } else if (\n                  currentFirstChild.elementType === key ||\n                  ("object" === typeof key &&\n                    null !== key &&\n                    key.$$typeof === REACT_LAZY_TYPE &&\n                    resolveLazy(key) === currentFirstChild.type)\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.props);\n                  coerceRef(lanes, newChild);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                }\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                break;\n              } else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            newChild.type === REACT_FRAGMENT_TYPE\n              ? ((lanes = createFiberFromFragment(\n                  newChild.props.children,\n                  returnFiber.mode,\n                  lanes,\n                  newChild.key\n                )),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes))\n              : ((lanes = createFiberFromTypeAndProps(\n                  newChild.type,\n                  newChild.key,\n                  newChild.props,\n                  null,\n                  returnFiber.mode,\n                  lanes\n                )),\n                coerceRef(lanes, newChild),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes));\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_PORTAL_TYPE:\n          a: {\n            for (key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key)\n                if (\n                  4 === currentFirstChild.tag &&\n                  currentFirstChild.stateNode.containerInfo ===\n                    newChild.containerInfo &&\n                  currentFirstChild.stateNode.implementation ===\n                    newChild.implementation\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.children || []);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                } else {\n                  deleteRemainingChildren(returnFiber, currentFirstChild);\n                  break;\n                }\n              else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            lanes.return = returnFiber;\n            returnFiber = lanes;\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            reconcileChildFibersImpl(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes\n            )\n          );\n      }\n      if (isArrayImpl(newChild))\n        return reconcileChildrenArray(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      if (getIteratorFn(newChild)) {\n        key = getIteratorFn(newChild);\n        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));\n        newChild = key.call(newChild);\n        return reconcileChildrenIterator(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      }\n      if ("function" === typeof newChild.then)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n      ? ((newChild = "" + newChild),\n        null !== currentFirstChild && 6 === currentFirstChild.tag\n          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),\n            (lanes = useFiber(currentFirstChild, newChild)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes))\n          : (deleteRemainingChildren(returnFiber, currentFirstChild),\n            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes)),\n        placeSingleChild(returnFiber))\n      : deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n  return function (returnFiber, currentFirstChild, newChild, lanes) {\n    try {\n      thenableIndexCounter$1 = 0;\n      var firstChildFiber = reconcileChildFibersImpl(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        lanes\n      );\n      thenableState$1 = null;\n      return firstChildFiber;\n    } catch (x) {\n      if (x === SuspenseException) throw x;\n      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);\n      fiber.lanes = lanes;\n      fiber.return = returnFiber;\n      return fiber;\n    } finally {\n    }\n  };\n}\nvar reconcileChildFibers = createChildReconciler(!0),\n  mountChildFibers = createChildReconciler(!1),\n  currentTreeHiddenStackCursor = createCursor(null),\n  prevEntangledRenderLanesCursor = createCursor(0);\nfunction pushHiddenContext(fiber, context) {\n  fiber = entangledRenderLanes;\n  push(prevEntangledRenderLanesCursor, fiber);\n  push(currentTreeHiddenStackCursor, context);\n  entangledRenderLanes = fiber | context.baseLanes;\n}\nfunction reuseHiddenContextOnStack() {\n  push(prevEntangledRenderLanesCursor, entangledRenderLanes);\n  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);\n}\nfunction popHiddenContext() {\n  entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n  pop(currentTreeHiddenStackCursor);\n  pop(prevEntangledRenderLanesCursor);\n}\nvar suspenseHandlerStackCursor = createCursor(null),\n  shellBoundary = null;\nfunction pushPrimaryTreeSuspenseHandler(handler) {\n  var current = handler.alternate;\n  push(suspenseStackCursor, suspenseStackCursor.current & 1);\n  push(suspenseHandlerStackCursor, handler);\n  null === shellBoundary &&\n    (null === current || null !== currentTreeHiddenStackCursor.current\n      ? (shellBoundary = handler)\n      : null !== current.memoizedState && (shellBoundary = handler));\n}\nfunction pushOffscreenSuspenseHandler(fiber) {\n  if (22 === fiber.tag) {\n    if (\n      (push(suspenseStackCursor, suspenseStackCursor.current),\n      push(suspenseHandlerStackCursor, fiber),\n      null === shellBoundary)\n    ) {\n      var current = fiber.alternate;\n      null !== current &&\n        null !== current.memoizedState &&\n        (shellBoundary = fiber);\n    }\n  } else reuseSuspenseHandlerOnStack(fiber);\n}\nfunction reuseSuspenseHandlerOnStack() {\n  push(suspenseStackCursor, suspenseStackCursor.current);\n  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);\n}\nfunction popSuspenseHandler(fiber) {\n  pop(suspenseHandlerStackCursor);\n  shellBoundary === fiber && (shellBoundary = null);\n  pop(suspenseStackCursor);\n}\nvar suspenseStackCursor = createCursor(0);\nfunction findFirstSuspended(row) {\n  for (var node = row; null !== node; ) {\n    if (13 === node.tag) {\n      var state = node.memoizedState;\n      if (\n        null !== state &&\n        ((state = state.dehydrated),\n        null === state || "$?" === state.data || "$!" === state.data)\n      )\n        return node;\n    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n      if (0 !== (node.flags & 128)) return node;\n    } else if (null !== node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) break;\n    for (; null === node.sibling; ) {\n      if (null === node.return || node.return === row) return null;\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\nvar AbortControllerLocal =\n    "undefined" !== typeof AbortController\n      ? AbortController\n      : function () {\n          var listeners = [],\n            signal = (this.signal = {\n              aborted: !1,\n              addEventListener: function (type, listener) {\n                listeners.push(listener);\n              }\n            });\n          this.abort = function () {\n            signal.aborted = !0;\n            listeners.forEach(function (listener) {\n              return listener();\n            });\n          };\n        },\n  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,\n  NormalPriority = Scheduler.unstable_NormalPriority,\n  CacheContext = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    Consumer: null,\n    Provider: null,\n    _currentValue: null,\n    _currentValue2: null,\n    _threadCount: 0\n  };\nfunction createCache() {\n  return {\n    controller: new AbortControllerLocal(),\n    data: new Map(),\n    refCount: 0\n  };\n}\nfunction releaseCache(cache) {\n  cache.refCount--;\n  0 === cache.refCount &&\n    scheduleCallback$2(NormalPriority, function () {\n      cache.controller.abort();\n    });\n}\nvar currentEntangledListeners = null,\n  currentEntangledPendingCount = 0,\n  currentEntangledLane = 0,\n  currentEntangledActionThenable = null;\nfunction entangleAsyncAction(transition, thenable) {\n  if (null === currentEntangledListeners) {\n    var entangledListeners = (currentEntangledListeners = []);\n    currentEntangledPendingCount = 0;\n    currentEntangledLane = requestTransitionLane();\n    currentEntangledActionThenable = {\n      status: "pending",\n      value: void 0,\n      then: function (resolve) {\n        entangledListeners.push(resolve);\n      }\n    };\n  }\n  currentEntangledPendingCount++;\n  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n  return thenable;\n}\nfunction pingEngtangledActionScope() {\n  if (\n    0 === --currentEntangledPendingCount &&\n    null !== currentEntangledListeners\n  ) {\n    null !== currentEntangledActionThenable &&\n      (currentEntangledActionThenable.status = "fulfilled");\n    var listeners = currentEntangledListeners;\n    currentEntangledListeners = null;\n    currentEntangledLane = 0;\n    currentEntangledActionThenable = null;\n    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();\n  }\n}\nfunction chainThenableValue(thenable, result) {\n  var listeners = [],\n    thenableWithOverride = {\n      status: "pending",\n      value: null,\n      reason: null,\n      then: function (resolve) {\n        listeners.push(resolve);\n      }\n    };\n  thenable.then(\n    function () {\n      thenableWithOverride.status = "fulfilled";\n      thenableWithOverride.value = result;\n      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);\n    },\n    function (error) {\n      thenableWithOverride.status = "rejected";\n      thenableWithOverride.reason = error;\n      for (error = 0; error < listeners.length; error++)\n        (0, listeners[error])(void 0);\n    }\n  );\n  return thenableWithOverride;\n}\nvar prevOnStartTransitionFinish = ReactSharedInternals.S;\nReactSharedInternals.S = function (transition, returnValue) {\n  "object" === typeof returnValue &&\n    null !== returnValue &&\n    "function" === typeof returnValue.then &&\n    entangleAsyncAction(transition, returnValue);\n  null !== prevOnStartTransitionFinish &&\n    prevOnStartTransitionFinish(transition, returnValue);\n};\nvar resumedCache = createCursor(null);\nfunction peekCacheFromPool() {\n  var cacheResumedFromPreviousRender = resumedCache.current;\n  return null !== cacheResumedFromPreviousRender\n    ? cacheResumedFromPreviousRender\n    : workInProgressRoot.pooledCache;\n}\nfunction pushTransition(offscreenWorkInProgress, prevCachePool) {\n  null === prevCachePool\n    ? push(resumedCache, resumedCache.current)\n    : push(resumedCache, prevCachePool.pool);\n}\nfunction getSuspendedCache() {\n  var cacheFromPool = peekCacheFromPool();\n  return null === cacheFromPool\n    ? null\n    : { parent: CacheContext._currentValue, pool: cacheFromPool };\n}\nvar renderLanes = 0,\n  currentlyRenderingFiber$1 = null,\n  currentHook = null,\n  workInProgressHook = null,\n  didScheduleRenderPhaseUpdate = !1,\n  didScheduleRenderPhaseUpdateDuringThisPass = !1,\n  shouldDoubleInvokeUserFnsInHooksDEV = !1,\n  localIdCounter = 0,\n  thenableIndexCounter = 0,\n  thenableState = null,\n  globalClientIdCounter = 0;\nfunction throwInvalidHookError() {\n  throw Error(formatProdErrorMessage(321));\n}\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (null === prevDeps) return !1;\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)\n    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n  return !0;\n}\nfunction renderWithHooks(\n  current,\n  workInProgress,\n  Component,\n  props,\n  secondArg,\n  nextRenderLanes\n) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber$1 = workInProgress;\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = 0;\n  ReactSharedInternals.H =\n    null === current || null === current.memoizedState\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  nextRenderLanes = Component(props, secondArg);\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  didScheduleRenderPhaseUpdateDuringThisPass &&\n    (nextRenderLanes = renderWithHooksAgain(\n      workInProgress,\n      Component,\n      props,\n      secondArg\n    ));\n  finishRenderingHooks(current);\n  return nextRenderLanes;\n}\nfunction finishRenderingHooks(current) {\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n  didScheduleRenderPhaseUpdate = !1;\n  thenableIndexCounter = 0;\n  thenableState = null;\n  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));\n  null === current ||\n    didReceiveUpdate ||\n    ((current = current.dependencies),\n    null !== current &&\n      checkIfContextChanged(current) &&\n      (didReceiveUpdate = !0));\n}\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n  currentlyRenderingFiber$1 = workInProgress;\n  var numberOfReRenders = 0;\n  do {\n    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n    thenableIndexCounter = 0;\n    didScheduleRenderPhaseUpdateDuringThisPass = !1;\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\n    numberOfReRenders += 1;\n    workInProgressHook = currentHook = null;\n    if (null != workInProgress.updateQueue) {\n      var children = workInProgress.updateQueue;\n      children.lastEffect = null;\n      children.events = null;\n      children.stores = null;\n      null != children.memoCache && (children.memoCache.index = 0);\n    }\n    ReactSharedInternals.H = HooksDispatcherOnRerender;\n    children = Component(props, secondArg);\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  return children;\n}\nfunction TransitionAwareHostComponent() {\n  var dispatcher = ReactSharedInternals.H,\n    maybeThenable = dispatcher.useState()[0];\n  maybeThenable =\n    "function" === typeof maybeThenable.then\n      ? useThenable(maybeThenable)\n      : maybeThenable;\n  dispatcher = dispatcher.useState()[0];\n  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&\n    (currentlyRenderingFiber$1.flags |= 1024);\n  return maybeThenable;\n}\nfunction checkDidRenderIdHook() {\n  var didRenderIdHook = 0 !== localIdCounter;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.flags &= -2053;\n  current.lanes &= ~lanes;\n}\nfunction resetHooksOnUnwind(workInProgress) {\n  if (didScheduleRenderPhaseUpdate) {\n    for (\n      workInProgress = workInProgress.memoizedState;\n      null !== workInProgress;\n\n    ) {\n      var queue = workInProgress.queue;\n      null !== queue && (queue.pending = null);\n      workInProgress = workInProgress.next;\n    }\n    didScheduleRenderPhaseUpdate = !1;\n  }\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n  didScheduleRenderPhaseUpdateDuringThisPass = !1;\n  thenableIndexCounter = localIdCounter = 0;\n  thenableState = null;\n}\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n  null === workInProgressHook\n    ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)\n    : (workInProgressHook = workInProgressHook.next = hook);\n  return workInProgressHook;\n}\nfunction updateWorkInProgressHook() {\n  if (null === currentHook) {\n    var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n    nextCurrentHook =\n      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n  } else nextCurrentHook = currentHook.next;\n  var nextWorkInProgressHook =\n    null === workInProgressHook\n      ? currentlyRenderingFiber$1.memoizedState\n      : workInProgressHook.next;\n  if (null !== nextWorkInProgressHook)\n    (workInProgressHook = nextWorkInProgressHook),\n      (currentHook = nextCurrentHook);\n  else {\n    if (null === nextCurrentHook) {\n      if (null === currentlyRenderingFiber$1.alternate)\n        throw Error(formatProdErrorMessage(467));\n      throw Error(formatProdErrorMessage(310));\n    }\n    currentHook = nextCurrentHook;\n    nextCurrentHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n    null === workInProgressHook\n      ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =\n          nextCurrentHook)\n      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);\n  }\n  return workInProgressHook;\n}\nvar createFunctionComponentUpdateQueue;\ncreateFunctionComponentUpdateQueue = function () {\n  return { lastEffect: null, events: null, stores: null, memoCache: null };\n};\nfunction useThenable(thenable) {\n  var index = thenableIndexCounter;\n  thenableIndexCounter += 1;\n  null === thenableState && (thenableState = []);\n  thenable = trackUsedThenable(thenableState, thenable, index);\n  index = currentlyRenderingFiber$1;\n  null ===\n    (null === workInProgressHook\n      ? index.memoizedState\n      : workInProgressHook.next) &&\n    ((index = index.alternate),\n    (ReactSharedInternals.H =\n      null === index || null === index.memoizedState\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate));\n  return thenable;\n}\nfunction use(usable) {\n  if (null !== usable && "object" === typeof usable) {\n    if ("function" === typeof usable.then) return useThenable(usable);\n    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n  }\n  throw Error(formatProdErrorMessage(438, String(usable)));\n}\nfunction useMemoCache(size) {\n  var memoCache = null,\n    updateQueue = currentlyRenderingFiber$1.updateQueue;\n  null !== updateQueue && (memoCache = updateQueue.memoCache);\n  if (null == memoCache) {\n    var current = currentlyRenderingFiber$1.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      null !== current &&\n        ((current = current.memoCache),\n        null != current &&\n          (memoCache = {\n            data: current.data.map(function (array) {\n              return array.slice();\n            }),\n            index: 0\n          })));\n  }\n  null == memoCache && (memoCache = { data: [], index: 0 });\n  null === updateQueue &&\n    ((updateQueue = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber$1.updateQueue = updateQueue));\n  updateQueue.memoCache = memoCache;\n  updateQueue = memoCache.data[memoCache.index];\n  if (void 0 === updateQueue)\n    for (\n      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;\n      current < size;\n      current++\n    )\n      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n  memoCache.index++;\n  return updateQueue;\n}\nfunction basicStateReducer(state, action) {\n  return "function" === typeof action ? action(state) : action;\n}\nfunction updateReducer(reducer) {\n  var hook = updateWorkInProgressHook();\n  return updateReducerImpl(hook, currentHook, reducer);\n}\nfunction updateReducerImpl(hook, current, reducer) {\n  var queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var baseQueue = hook.baseQueue,\n    pendingQueue = queue.pending;\n  if (null !== pendingQueue) {\n    if (null !== baseQueue) {\n      var baseFirst = baseQueue.next;\n      baseQueue.next = pendingQueue.next;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n  pendingQueue = hook.baseState;\n  if (null === baseQueue) hook.memoizedState = pendingQueue;\n  else {\n    current = baseQueue.next;\n    var newBaseQueueFirst = (baseFirst = null),\n      newBaseQueueLast = null,\n      update = current,\n      didReadFromEntangledAsyncAction$54 = !1;\n    do {\n      var updateLane = update.lane & -536870913;\n      if (\n        updateLane !== update.lane\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        var revertLane = update.revertLane;\n        if (0 === revertLane)\n          null !== newBaseQueueLast &&\n            (newBaseQueueLast = newBaseQueueLast.next =\n              {\n                lane: 0,\n                revertLane: 0,\n                action: update.action,\n                hasEagerState: update.hasEagerState,\n                eagerState: update.eagerState,\n                next: null\n              }),\n            updateLane === currentEntangledLane &&\n              (didReadFromEntangledAsyncAction$54 = !0);\n        else if ((renderLanes & revertLane) === revertLane) {\n          update = update.next;\n          revertLane === currentEntangledLane &&\n            (didReadFromEntangledAsyncAction$54 = !0);\n          continue;\n        } else\n          (updateLane = {\n            lane: 0,\n            revertLane: update.revertLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          }),\n            null === newBaseQueueLast\n              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),\n                (baseFirst = pendingQueue))\n              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),\n            (currentlyRenderingFiber$1.lanes |= revertLane),\n            (workInProgressRootSkippedLanes |= revertLane);\n        updateLane = update.action;\n        shouldDoubleInvokeUserFnsInHooksDEV &&\n          reducer(pendingQueue, updateLane);\n        pendingQueue = update.hasEagerState\n          ? update.eagerState\n          : reducer(pendingQueue, updateLane);\n      } else\n        (revertLane = {\n          lane: updateLane,\n          revertLane: update.revertLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        }),\n          null === newBaseQueueLast\n            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),\n              (baseFirst = pendingQueue))\n            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),\n          (currentlyRenderingFiber$1.lanes |= updateLane),\n          (workInProgressRootSkippedLanes |= updateLane);\n      update = update.next;\n    } while (null !== update && update !== current);\n    null === newBaseQueueLast\n      ? (baseFirst = pendingQueue)\n      : (newBaseQueueLast.next = newBaseQueueFirst);\n    if (\n      !objectIs(pendingQueue, hook.memoizedState) &&\n      ((didReceiveUpdate = !0),\n      didReadFromEntangledAsyncAction$54 &&\n        ((reducer = currentEntangledActionThenable), null !== reducer))\n    )\n      throw reducer;\n    hook.memoizedState = pendingQueue;\n    hook.baseState = baseFirst;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = pendingQueue;\n  }\n  null === baseQueue && (queue.lanes = 0);\n  return [hook.memoizedState, queue.dispatch];\n}\nfunction rerenderReducer(reducer) {\n  var hook = updateWorkInProgressHook(),\n    queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var dispatch = queue.dispatch,\n    lastRenderPhaseUpdate = queue.pending,\n    newState = hook.memoizedState;\n  if (null !== lastRenderPhaseUpdate) {\n    queue.pending = null;\n    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);\n    do (newState = reducer(newState, update.action)), (update = update.next);\n    while (update !== lastRenderPhaseUpdate);\n    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n    hook.memoizedState = newState;\n    null === hook.baseQueue && (hook.baseState = newState);\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1,\n    hook = updateWorkInProgressHook(),\n    isHydrating$jscomp$0 = isHydrating;\n  if (isHydrating$jscomp$0) {\n    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));\n    getServerSnapshot = getServerSnapshot();\n  } else getServerSnapshot = getSnapshot();\n  var snapshotChanged = !objectIs(\n    (currentHook || hook).memoizedState,\n    getServerSnapshot\n  );\n  snapshotChanged &&\n    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));\n  hook = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [\n    subscribe\n  ]);\n  if (\n    hook.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)\n  ) {\n    fiber.flags |= 2048;\n    pushEffect(\n      9,\n      updateStoreInstance.bind(\n        null,\n        fiber,\n        hook,\n        getServerSnapshot,\n        getSnapshot\n      ),\n      { destroy: void 0 },\n      null\n    );\n    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\n    isHydrating$jscomp$0 ||\n      0 !== (renderLanes & 60) ||\n      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n  }\n  return getServerSnapshot;\n}\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= 16384;\n  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };\n  getSnapshot = currentlyRenderingFiber$1.updateQueue;\n  null === getSnapshot\n    ? ((getSnapshot = createFunctionComponentUpdateQueue()),\n      (currentlyRenderingFiber$1.updateQueue = getSnapshot),\n      (getSnapshot.stores = [fiber]))\n    : ((renderedSnapshot = getSnapshot.stores),\n      null === renderedSnapshot\n        ? (getSnapshot.stores = [fiber])\n        : renderedSnapshot.push(fiber));\n}\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n}\nfunction subscribeToStore(fiber, inst, subscribe) {\n  return subscribe(function () {\n    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n  });\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction forceStoreRerender(fiber) {\n  var root = enqueueConcurrentRenderForLane(fiber, 2);\n  null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n}\nfunction mountStateImpl(initialState) {\n  var hook = mountWorkInProgressHook();\n  if ("function" === typeof initialState) {\n    var initialStateInitializer = initialState;\n    initialState = initialStateInitializer();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(!0);\n      try {\n        initialStateInitializer();\n      } finally {\n        setIsStrictModeForDevtools(!1);\n      }\n    }\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  hook.queue = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  return hook;\n}\nfunction updateOptimisticImpl(hook, current, passthrough, reducer) {\n  hook.baseState = passthrough;\n  return updateReducerImpl(\n    hook,\n    currentHook,\n    "function" === typeof reducer ? reducer : basicStateReducer\n  );\n}\nfunction dispatchActionState(\n  fiber,\n  actionQueue,\n  setPendingState,\n  setState,\n  payload\n) {\n  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));\n  fiber = actionQueue.action;\n  if (null !== fiber) {\n    var actionNode = {\n      payload: payload,\n      action: fiber,\n      next: null,\n      isTransition: !0,\n      status: "pending",\n      value: null,\n      reason: null,\n      listeners: [],\n      then: function (listener) {\n        actionNode.listeners.push(listener);\n      }\n    };\n    null !== ReactSharedInternals.T\n      ? setPendingState(!0)\n      : (actionNode.isTransition = !1);\n    setState(actionNode);\n    setPendingState = actionQueue.pending;\n    null === setPendingState\n      ? ((actionNode.next = actionQueue.pending = actionNode),\n        runActionStateAction(actionQueue, actionNode))\n      : ((actionNode.next = setPendingState.next),\n        (actionQueue.pending = setPendingState.next = actionNode));\n  }\n}\nfunction runActionStateAction(actionQueue, node) {\n  var action = node.action,\n    payload = node.payload,\n    prevState = actionQueue.state;\n  if (node.isTransition) {\n    var prevTransition = ReactSharedInternals.T,\n      currentTransition = {};\n    ReactSharedInternals.T = currentTransition;\n    try {\n      var returnValue = action(prevState, payload),\n        onStartTransitionFinish = ReactSharedInternals.S;\n      null !== onStartTransitionFinish &&\n        onStartTransitionFinish(currentTransition, returnValue);\n      handleActionReturnValue(actionQueue, node, returnValue);\n    } catch (error) {\n      onActionError(actionQueue, node, error);\n    } finally {\n      ReactSharedInternals.T = prevTransition;\n    }\n  } else\n    try {\n      (prevTransition = action(prevState, payload)),\n        handleActionReturnValue(actionQueue, node, prevTransition);\n    } catch (error$60) {\n      onActionError(actionQueue, node, error$60);\n    }\n}\nfunction handleActionReturnValue(actionQueue, node, returnValue) {\n  null !== returnValue &&\n  "object" === typeof returnValue &&\n  "function" === typeof returnValue.then\n    ? returnValue.then(\n        function (nextState) {\n          onActionSuccess(actionQueue, node, nextState);\n        },\n        function (error) {\n          return onActionError(actionQueue, node, error);\n        }\n      )\n    : onActionSuccess(actionQueue, node, returnValue);\n}\nfunction onActionSuccess(actionQueue, actionNode, nextState) {\n  actionNode.status = "fulfilled";\n  actionNode.value = nextState;\n  notifyActionListeners(actionNode);\n  actionQueue.state = nextState;\n  actionNode = actionQueue.pending;\n  null !== actionNode &&\n    ((nextState = actionNode.next),\n    nextState === actionNode\n      ? (actionQueue.pending = null)\n      : ((nextState = nextState.next),\n        (actionNode.next = nextState),\n        runActionStateAction(actionQueue, nextState)));\n}\nfunction onActionError(actionQueue, actionNode, error) {\n  var last = actionQueue.pending;\n  actionQueue.pending = null;\n  if (null !== last) {\n    last = last.next;\n    do\n      (actionNode.status = "rejected"),\n        (actionNode.reason = error),\n        notifyActionListeners(actionNode),\n        (actionNode = actionNode.next);\n    while (actionNode !== last);\n  }\n  actionQueue.action = null;\n}\nfunction notifyActionListeners(actionNode) {\n  actionNode = actionNode.listeners;\n  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();\n}\nfunction actionStateReducer(oldState, newState) {\n  return newState;\n}\nfunction mountActionState(action, initialStateProp) {\n  if (isHydrating) {\n    var ssrFormState = workInProgressRoot.formState;\n    if (null !== ssrFormState) {\n      a: {\n        var JSCompiler_inline_result = currentlyRenderingFiber$1;\n        if (isHydrating) {\n          if (nextHydratableInstance) {\n            b: {\n              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;\n              for (\n                var inRootOrSingleton = rootOrSingletonContext;\n                8 !== JSCompiler_inline_result$jscomp$0.nodeType;\n\n              ) {\n                if (!inRootOrSingleton) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n                JSCompiler_inline_result$jscomp$0 = getNextHydratable(\n                  JSCompiler_inline_result$jscomp$0.nextSibling\n                );\n                if (null === JSCompiler_inline_result$jscomp$0) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n              }\n              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;\n              JSCompiler_inline_result$jscomp$0 =\n                "F!" === inRootOrSingleton || "F" === inRootOrSingleton\n                  ? JSCompiler_inline_result$jscomp$0\n                  : null;\n            }\n            if (JSCompiler_inline_result$jscomp$0) {\n              nextHydratableInstance = getNextHydratable(\n                JSCompiler_inline_result$jscomp$0.nextSibling\n              );\n              JSCompiler_inline_result =\n                "F!" === JSCompiler_inline_result$jscomp$0.data;\n              break a;\n            }\n          }\n          throwOnHydrationMismatch(JSCompiler_inline_result);\n        }\n        JSCompiler_inline_result = !1;\n      }\n      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);\n    }\n  }\n  ssrFormState = mountWorkInProgressHook();\n  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n  JSCompiler_inline_result = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: actionStateReducer,\n    lastRenderedState: initialStateProp\n  };\n  ssrFormState.queue = JSCompiler_inline_result;\n  ssrFormState = dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    JSCompiler_inline_result\n  );\n  JSCompiler_inline_result.dispatch = ssrFormState;\n  JSCompiler_inline_result = mountStateImpl(!1);\n  inRootOrSingleton = dispatchOptimisticSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    !1,\n    JSCompiler_inline_result.queue\n  );\n  JSCompiler_inline_result = mountWorkInProgressHook();\n  JSCompiler_inline_result$jscomp$0 = {\n    state: initialStateProp,\n    dispatch: null,\n    action: action,\n    pending: null\n  };\n  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;\n  ssrFormState = dispatchActionState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    JSCompiler_inline_result$jscomp$0,\n    inRootOrSingleton,\n    ssrFormState\n  );\n  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;\n  JSCompiler_inline_result.memoizedState = action;\n  return [initialStateProp, ssrFormState, !1];\n}\nfunction updateActionState(action) {\n  var stateHook = updateWorkInProgressHook();\n  return updateActionStateImpl(stateHook, currentHook, action);\n}\nfunction updateActionStateImpl(stateHook, currentStateHook, action) {\n  currentStateHook = updateReducerImpl(\n    stateHook,\n    currentStateHook,\n    actionStateReducer\n  )[0];\n  stateHook = updateReducer(basicStateReducer)[0];\n  currentStateHook =\n    "object" === typeof currentStateHook &&\n    null !== currentStateHook &&\n    "function" === typeof currentStateHook.then\n      ? useThenable(currentStateHook)\n      : currentStateHook;\n  var actionQueueHook = updateWorkInProgressHook(),\n    actionQueue = actionQueueHook.queue,\n    dispatch = actionQueue.dispatch;\n  action !== actionQueueHook.memoizedState &&\n    ((currentlyRenderingFiber$1.flags |= 2048),\n    pushEffect(\n      9,\n      actionStateActionEffect.bind(null, actionQueue, action),\n      { destroy: void 0 },\n      null\n    ));\n  return [currentStateHook, dispatch, stateHook];\n}\nfunction actionStateActionEffect(actionQueue, action) {\n  actionQueue.action = action;\n}\nfunction rerenderActionState(action) {\n  var stateHook = updateWorkInProgressHook(),\n    currentStateHook = currentHook;\n  if (null !== currentStateHook)\n    return updateActionStateImpl(stateHook, currentStateHook, action);\n  updateWorkInProgressHook();\n  stateHook = stateHook.memoizedState;\n  currentStateHook = updateWorkInProgressHook();\n  var dispatch = currentStateHook.queue.dispatch;\n  currentStateHook.memoizedState = action;\n  return [stateHook, dispatch, !1];\n}\nfunction pushEffect(tag, create, inst, deps) {\n  tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };\n  create = currentlyRenderingFiber$1.updateQueue;\n  null === create &&\n    ((create = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber$1.updateQueue = create));\n  inst = create.lastEffect;\n  null === inst\n    ? (create.lastEffect = tag.next = tag)\n    : ((deps = inst.next),\n      (inst.next = tag),\n      (tag.next = deps),\n      (create.lastEffect = tag));\n  return tag;\n}\nfunction updateRef() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = mountWorkInProgressHook();\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(\n    1 | hookFlags,\n    create,\n    { destroy: void 0 },\n    void 0 === deps ? null : deps\n  );\n}\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var inst = hook.memoizedState.inst;\n  null !== currentHook &&\n  null !== deps &&\n  areHookInputsEqual(deps, currentHook.memoizedState.deps)\n    ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))\n    : ((currentlyRenderingFiber$1.flags |= fiberFlags),\n      (hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps)));\n}\nfunction mountEffect(create, deps) {\n  mountEffectImpl(8390656, 8, create, deps);\n}\nfunction updateEffect(create, deps) {\n  updateEffectImpl(2048, 8, create, deps);\n}\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(4, 2, create, deps);\n}\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(4, 4, create, deps);\n}\nfunction imperativeHandleEffect(create, ref) {\n  if ("function" === typeof ref) {\n    create = create();\n    var refCleanup = ref(create);\n    return function () {\n      "function" === typeof refCleanup ? refCleanup() : ref(null);\n    };\n  }\n  if (null !== ref && void 0 !== ref)\n    return (\n      (create = create()),\n      (ref.current = create),\n      function () {\n        ref.current = null;\n      }\n    );\n}\nfunction updateImperativeHandle(ref, create, deps) {\n  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);\n}\nfunction mountDebugValue() {}\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  hook.memoizedState = [callback, deps];\n  return callback;\n}\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  prevState = nextCreate();\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    setIsStrictModeForDevtools(!0);\n    try {\n      nextCreate();\n    } finally {\n      setIsStrictModeForDevtools(!1);\n    }\n  }\n  hook.memoizedState = [prevState, deps];\n  return prevState;\n}\nfunction mountDeferredValueImpl(hook, value, initialValue) {\n  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))\n    return (hook.memoizedState = value);\n  hook.memoizedState = initialValue;\n  hook = requestDeferredLane();\n  currentlyRenderingFiber$1.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return initialValue;\n}\nfunction updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n  if (objectIs(value, prevValue)) return value;\n  if (null !== currentTreeHiddenStackCursor.current)\n    return (\n      (hook = mountDeferredValueImpl(hook, value, initialValue)),\n      objectIs(hook, prevValue) || (didReceiveUpdate = !0),\n      hook\n    );\n  if (0 === (renderLanes & 42))\n    return (didReceiveUpdate = !0), (hook.memoizedState = value);\n  hook = requestDeferredLane();\n  currentlyRenderingFiber$1.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return prevValue;\n}\nfunction startTransition(fiber, queue, pendingState, finishedState, callback) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  ReactDOMSharedInternals.p =\n    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n  try {\n    var returnValue = callback(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    if (\n      null !== returnValue &&\n      "object" === typeof returnValue &&\n      "function" === typeof returnValue.then\n    ) {\n      var thenableForFinishedState = chainThenableValue(\n        returnValue,\n        finishedState\n      );\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        thenableForFinishedState,\n        requestUpdateLane(fiber)\n      );\n    } else\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        finishedState,\n        requestUpdateLane(fiber)\n      );\n  } catch (error) {\n    dispatchSetStateInternal(\n      fiber,\n      queue,\n      { then: function () {}, status: "rejected", reason: error },\n      requestUpdateLane()\n    );\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction noop$2() {}\nfunction startHostTransition(formFiber, pendingState, action, formData) {\n  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));\n  var queue = ensureFormComponentIsStateful(formFiber).queue;\n  startTransition(\n    formFiber,\n    queue,\n    pendingState,\n    sharedNotPendingObject,\n    null === action\n      ? noop$2\n      : function () {\n          requestFormReset$1(formFiber);\n          return action(formData);\n        }\n  );\n}\nfunction ensureFormComponentIsStateful(formFiber) {\n  var existingStateHook = formFiber.memoizedState;\n  if (null !== existingStateHook) return existingStateHook;\n  existingStateHook = {\n    memoizedState: sharedNotPendingObject,\n    baseState: sharedNotPendingObject,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: sharedNotPendingObject\n    },\n    next: null\n  };\n  var initialResetState = {};\n  existingStateHook.next = {\n    memoizedState: initialResetState,\n    baseState: initialResetState,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: initialResetState\n    },\n    next: null\n  };\n  formFiber.memoizedState = existingStateHook;\n  formFiber = formFiber.alternate;\n  null !== formFiber && (formFiber.memoizedState = existingStateHook);\n  return existingStateHook;\n}\nfunction requestFormReset$1(formFiber) {\n  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());\n}\nfunction useHostTransitionStatus() {\n  return readContext(HostTransitionContext);\n}\nfunction updateId() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction updateRefresh() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction refreshCache(fiber) {\n  for (var provider = fiber.return; null !== provider; ) {\n    switch (provider.tag) {\n      case 24:\n      case 3:\n        var lane = requestUpdateLane();\n        fiber = createUpdate(lane);\n        var root$63 = enqueueUpdate(provider, fiber, lane);\n        null !== root$63 &&\n          (scheduleUpdateOnFiber(root$63, provider, lane),\n          entangleTransitions(root$63, provider, lane));\n        provider = { cache: createCache() };\n        fiber.payload = provider;\n        return;\n    }\n    provider = provider.return;\n  }\n}\nfunction dispatchReducerAction(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  action = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  isRenderPhaseUpdate(fiber)\n    ? enqueueRenderPhaseUpdate(queue, action)\n    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),\n      null !== action &&\n        (scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane)));\n}\nfunction dispatchSetState(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  dispatchSetStateInternal(fiber, queue, action, lane);\n}\nfunction dispatchSetStateInternal(fiber, queue, action, lane) {\n  var update = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n  else {\n    var alternate = fiber.alternate;\n    if (\n      0 === fiber.lanes &&\n      (null === alternate || 0 === alternate.lanes) &&\n      ((alternate = queue.lastRenderedReducer), null !== alternate)\n    )\n      try {\n        var currentState = queue.lastRenderedState,\n          eagerState = alternate(currentState, action);\n        update.hasEagerState = !0;\n        update.eagerState = eagerState;\n        if (objectIs(eagerState, currentState))\n          return (\n            enqueueUpdate$1(fiber, queue, update, 0),\n            null === workInProgressRoot && finishQueueingConcurrentUpdates(),\n            !1\n          );\n      } catch (error) {\n      } finally {\n      }\n    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (null !== action)\n      return (\n        scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane),\n        !0\n      );\n  }\n  return !1;\n}\nfunction dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n  action = {\n    lane: 2,\n    revertLane: requestTransitionLane(),\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) {\n    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));\n  } else\n    (throwIfDuringRender = enqueueConcurrentHookUpdate(\n      fiber,\n      queue,\n      action,\n      2\n    )),\n      null !== throwIfDuringRender &&\n        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n}\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return (\n    fiber === currentlyRenderingFiber$1 ||\n    (null !== alternate && alternate === currentlyRenderingFiber$1)\n  );\n}\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =\n    !0;\n  var pending = queue.pending;\n  null === pending\n    ? (update.next = update)\n    : ((update.next = pending.next), (pending.next = update));\n  queue.pending = update;\n}\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (0 !== (lane & 4194176)) {\n    var queueLanes = queue.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    queue.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nvar ContextOnlyDispatcher = {\n  readContext: readContext,\n  use: use,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError\n};\nContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\nContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\nContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\nContextOnlyDispatcher.useFormState = throwInvalidHookError;\nContextOnlyDispatcher.useActionState = throwInvalidHookError;\nContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\nvar HooksDispatcherOnMount = {\n  readContext: readContext,\n  use: use,\n  useCallback: function (callback, deps) {\n    mountWorkInProgressHook().memoizedState = [\n      callback,\n      void 0 === deps ? null : deps\n    ];\n    return callback;\n  },\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: function (ref, create, deps) {\n    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n    mountEffectImpl(\n      4194308,\n      4,\n      imperativeHandleEffect.bind(null, create, ref),\n      deps\n    );\n  },\n  useLayoutEffect: function (create, deps) {\n    return mountEffectImpl(4194308, 4, create, deps);\n  },\n  useInsertionEffect: function (create, deps) {\n    mountEffectImpl(4, 2, create, deps);\n  },\n  useMemo: function (nextCreate, deps) {\n    var hook = mountWorkInProgressHook();\n    deps = void 0 === deps ? null : deps;\n    var nextValue = nextCreate();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(!0);\n      try {\n        nextCreate();\n      } finally {\n        setIsStrictModeForDevtools(!1);\n      }\n    }\n    hook.memoizedState = [nextValue, deps];\n    return nextValue;\n  },\n  useReducer: function (reducer, initialArg, init) {\n    var hook = mountWorkInProgressHook();\n    if (void 0 !== init) {\n      var initialState = init(initialArg);\n      if (shouldDoubleInvokeUserFnsInHooksDEV) {\n        setIsStrictModeForDevtools(!0);\n        try {\n          init(initialArg);\n        } finally {\n          setIsStrictModeForDevtools(!1);\n        }\n      }\n    } else initialState = initialArg;\n    hook.memoizedState = hook.baseState = initialState;\n    reducer = {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: reducer,\n      lastRenderedState: initialState\n    };\n    hook.queue = reducer;\n    reducer = reducer.dispatch = dispatchReducerAction.bind(\n      null,\n      currentlyRenderingFiber$1,\n      reducer\n    );\n    return [hook.memoizedState, reducer];\n  },\n  useRef: function (initialValue) {\n    var hook = mountWorkInProgressHook();\n    initialValue = { current: initialValue };\n    return (hook.memoizedState = initialValue);\n  },\n  useState: function (initialState) {\n    initialState = mountStateImpl(initialState);\n    var queue = initialState.queue,\n      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n    queue.dispatch = dispatch;\n    return [initialState.memoizedState, dispatch];\n  },\n  useDebugValue: mountDebugValue,\n  useDeferredValue: function (value, initialValue) {\n    var hook = mountWorkInProgressHook();\n    return mountDeferredValueImpl(hook, value, initialValue);\n  },\n  useTransition: function () {\n    var stateHook = mountStateImpl(!1);\n    stateHook = startTransition.bind(\n      null,\n      currentlyRenderingFiber$1,\n      stateHook.queue,\n      !0,\n      !1\n    );\n    mountWorkInProgressHook().memoizedState = stateHook;\n    return [!1, stateHook];\n  },\n  useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n    var fiber = currentlyRenderingFiber$1,\n      hook = mountWorkInProgressHook();\n    if (isHydrating) {\n      if (void 0 === getServerSnapshot)\n        throw Error(formatProdErrorMessage(407));\n      getServerSnapshot = getServerSnapshot();\n    } else {\n      getServerSnapshot = getSnapshot();\n      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\n      0 !== (workInProgressRootRenderLanes & 60) ||\n        pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n    }\n    hook.memoizedState = getServerSnapshot;\n    var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };\n    hook.queue = inst;\n    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n      subscribe\n    ]);\n    fiber.flags |= 2048;\n    pushEffect(\n      9,\n      updateStoreInstance.bind(\n        null,\n        fiber,\n        inst,\n        getServerSnapshot,\n        getSnapshot\n      ),\n      { destroy: void 0 },\n      null\n    );\n    return getServerSnapshot;\n  },\n  useId: function () {\n    var hook = mountWorkInProgressHook(),\n      identifierPrefix = workInProgressRoot.identifierPrefix;\n    if (isHydrating) {\n      var JSCompiler_inline_result = treeContextOverflow;\n      var idWithLeadingBit = treeContextId;\n      JSCompiler_inline_result =\n        (\n          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))\n        ).toString(32) + JSCompiler_inline_result;\n      identifierPrefix =\n        ":" + identifierPrefix + "R" + JSCompiler_inline_result;\n      JSCompiler_inline_result = localIdCounter++;\n      0 < JSCompiler_inline_result &&\n        (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));\n      identifierPrefix += ":";\n    } else\n      (JSCompiler_inline_result = globalClientIdCounter++),\n        (identifierPrefix =\n          ":" +\n          identifierPrefix +\n          "r" +\n          JSCompiler_inline_result.toString(32) +\n          ":");\n    return (hook.memoizedState = identifierPrefix);\n  },\n  useCacheRefresh: function () {\n    return (mountWorkInProgressHook().memoizedState = refreshCache.bind(\n      null,\n      currentlyRenderingFiber$1\n    ));\n  }\n};\nHooksDispatcherOnMount.useMemoCache = useMemoCache;\nHooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;\nHooksDispatcherOnMount.useFormState = mountActionState;\nHooksDispatcherOnMount.useActionState = mountActionState;\nHooksDispatcherOnMount.useOptimistic = function (passthrough) {\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = hook.baseState = passthrough;\n  var queue = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: null,\n    lastRenderedState: null\n  };\n  hook.queue = queue;\n  hook = dispatchOptimisticSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    !0,\n    queue\n  );\n  queue.dispatch = hook;\n  return [passthrough, hook];\n};\nvar HooksDispatcherOnUpdate = {\n  readContext: readContext,\n  use: use,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: function () {\n    return updateReducer(basicStateReducer);\n  },\n  useDebugValue: mountDebugValue,\n  useDeferredValue: function (value, initialValue) {\n    var hook = updateWorkInProgressHook();\n    return updateDeferredValueImpl(\n      hook,\n      currentHook.memoizedState,\n      value,\n      initialValue\n    );\n  },\n  useTransition: function () {\n    var booleanOrThenable = updateReducer(basicStateReducer)[0],\n      start = updateWorkInProgressHook().memoizedState;\n    return [\n      "boolean" === typeof booleanOrThenable\n        ? booleanOrThenable\n        : useThenable(booleanOrThenable),\n      start\n    ];\n  },\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId\n};\nHooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;\nHooksDispatcherOnUpdate.useMemoCache = useMemoCache;\nHooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;\nHooksDispatcherOnUpdate.useFormState = updateActionState;\nHooksDispatcherOnUpdate.useActionState = updateActionState;\nHooksDispatcherOnUpdate.useOptimistic = function (passthrough, reducer) {\n  var hook = updateWorkInProgressHook();\n  return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n};\nvar HooksDispatcherOnRerender = {\n  readContext: readContext,\n  use: use,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: function () {\n    return rerenderReducer(basicStateReducer);\n  },\n  useDebugValue: mountDebugValue,\n  useDeferredValue: function (value, initialValue) {\n    var hook = updateWorkInProgressHook();\n    return null === currentHook\n      ? mountDeferredValueImpl(hook, value, initialValue)\n      : updateDeferredValueImpl(\n          hook,\n          currentHook.memoizedState,\n          value,\n          initialValue\n        );\n  },\n  useTransition: function () {\n    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],\n      start = updateWorkInProgressHook().memoizedState;\n    return [\n      "boolean" === typeof booleanOrThenable\n        ? booleanOrThenable\n        : useThenable(booleanOrThenable),\n      start\n    ];\n  },\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId\n};\nHooksDispatcherOnRerender.useCacheRefresh = updateRefresh;\nHooksDispatcherOnRerender.useMemoCache = useMemoCache;\nHooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;\nHooksDispatcherOnRerender.useFormState = rerenderActionState;\nHooksDispatcherOnRerender.useActionState = rerenderActionState;\nHooksDispatcherOnRerender.useOptimistic = function (passthrough, reducer) {\n  var hook = updateWorkInProgressHook();\n  if (null !== currentHook)\n    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n  hook.baseState = passthrough;\n  return [passthrough, hook.queue.dispatch];\n};\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  ctor,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  ctor = workInProgress.memoizedState;\n  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);\n  getDerivedStateFromProps =\n    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps\n      ? ctor\n      : assign({}, ctor, getDerivedStateFromProps);\n  workInProgress.memoizedState = getDerivedStateFromProps;\n  0 === workInProgress.lanes &&\n    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);\n}\nvar classComponentUpdater = {\n  isMounted: function (component) {\n    return (component = component._reactInternals)\n      ? getNearestMountedFiber(component) === component\n      : !1;\n  },\n  enqueueSetState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 1;\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 2;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    callback = enqueueUpdate(inst, update, lane);\n    null !== callback &&\n      (scheduleUpdateOnFiber(callback, inst, lane),\n      entangleTransitions(callback, inst, lane));\n  }\n};\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext\n) {\n  workInProgress = workInProgress.stateNode;\n  return "function" === typeof workInProgress.shouldComponentUpdate\n    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)\n    : ctor.prototype && ctor.prototype.isPureReactComponent\n      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      : !0;\n}\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext\n) {\n  workInProgress = instance.state;\n  "function" === typeof instance.componentWillReceiveProps &&\n    instance.componentWillReceiveProps(newProps, nextContext);\n  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  instance.state !== workInProgress &&\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n}\nfunction resolveClassComponentProps(Component, baseProps) {\n  var newProps = baseProps;\n  if ("ref" in baseProps) {\n    newProps = {};\n    for (var propName in baseProps)\n      "ref" !== propName && (newProps[propName] = baseProps[propName]);\n  }\n  if ((Component = Component.defaultProps)) {\n    newProps === baseProps && (newProps = assign({}, newProps));\n    for (var propName$67 in Component)\n      void 0 === newProps[propName$67] &&\n        (newProps[propName$67] = Component[propName$67]);\n  }\n  return newProps;\n}\nvar reportGlobalError =\n  "function" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          "object" === typeof window &&\n          "function" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent("error", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              "object" === typeof error &&\n              null !== error &&\n              "string" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          "object" === typeof process &&\n          "function" === typeof process.emit\n        ) {\n          process.emit("uncaughtException", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction defaultOnUncaughtError(error) {\n  reportGlobalError(error);\n}\nfunction defaultOnCaughtError(error) {\n  console.error(error);\n}\nfunction defaultOnRecoverableError(error) {\n  reportGlobalError(error);\n}\nfunction logUncaughtError(root, errorInfo) {\n  try {\n    var onUncaughtError = root.onUncaughtError;\n    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });\n  } catch (e$68) {\n    setTimeout(function () {\n      throw e$68;\n    });\n  }\n}\nfunction logCaughtError(root, boundary, errorInfo) {\n  try {\n    var onCaughtError = root.onCaughtError;\n    onCaughtError(errorInfo.value, {\n      componentStack: errorInfo.stack,\n      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n    });\n  } catch (e$69) {\n    setTimeout(function () {\n      throw e$69;\n    });\n  }\n}\nfunction createRootErrorUpdate(root, errorInfo, lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  lane.payload = { element: null };\n  lane.callback = function () {\n    logUncaughtError(root, errorInfo);\n  };\n  return lane;\n}\nfunction createClassErrorUpdate(lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  return lane;\n}\nfunction initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if ("function" === typeof getDerivedStateFromError) {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromError(error);\n    };\n    update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n    };\n  }\n  var inst = fiber.stateNode;\n  null !== inst &&\n    "function" === typeof inst.componentDidCatch &&\n    (update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n      "function" !== typeof getDerivedStateFromError &&\n        (null === legacyErrorBoundariesThatAlreadyFailed\n          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))\n          : legacyErrorBoundariesThatAlreadyFailed.add(this));\n      var stack = errorInfo.stack;\n      this.componentDidCatch(errorInfo.value, {\n        componentStack: null !== stack ? stack : ""\n      });\n    });\n}\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  rootRenderLanes\n) {\n  sourceFiber.flags |= 32768;\n  if (\n    null !== value &&\n    "object" === typeof value &&\n    "function" === typeof value.then\n  ) {\n    returnFiber = sourceFiber.alternate;\n    null !== returnFiber &&\n      propagateParentContextChanges(\n        returnFiber,\n        sourceFiber,\n        rootRenderLanes,\n        !0\n      );\n    sourceFiber = suspenseHandlerStackCursor.current;\n    if (null !== sourceFiber) {\n      switch (sourceFiber.tag) {\n        case 13:\n          return (\n            null === shellBoundary\n              ? renderDidSuspendDelayIfPossible()\n              : null === sourceFiber.alternate &&\n                0 === workInProgressRootExitStatus &&\n                (workInProgressRootExitStatus = 3),\n            (sourceFiber.flags &= -257),\n            (sourceFiber.flags |= 65536),\n            (sourceFiber.lanes = rootRenderLanes),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? (sourceFiber.updateQueue = new Set([value]))\n                  : returnFiber.add(value),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n        case 22:\n          return (\n            (sourceFiber.flags |= 65536),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? ((returnFiber = {\n                      transitions: null,\n                      markerInstances: null,\n                      retryQueue: new Set([value])\n                    }),\n                    (sourceFiber.updateQueue = returnFiber))\n                  : ((sourceFiber = returnFiber.retryQueue),\n                    null === sourceFiber\n                      ? (returnFiber.retryQueue = new Set([value]))\n                      : sourceFiber.add(value)),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n      }\n      throw Error(formatProdErrorMessage(435, sourceFiber.tag));\n    }\n    attachPingListener(root, value, rootRenderLanes);\n    renderDidSuspendDelayIfPossible();\n    return !1;\n  }\n  if (isHydrating)\n    return (\n      (returnFiber = suspenseHandlerStackCursor.current),\n      null !== returnFiber\n        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),\n          (returnFiber.flags |= 65536),\n          (returnFiber.lanes = rootRenderLanes),\n          value !== HydrationMismatchException &&\n            ((root = Error(formatProdErrorMessage(422), { cause: value })),\n            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))\n        : (value !== HydrationMismatchException &&\n            ((returnFiber = Error(formatProdErrorMessage(423), {\n              cause: value\n            })),\n            queueHydrationError(\n              createCapturedValueAtFiber(returnFiber, sourceFiber)\n            )),\n          (root = root.current.alternate),\n          (root.flags |= 65536),\n          (rootRenderLanes &= -rootRenderLanes),\n          (root.lanes |= rootRenderLanes),\n          (value = createCapturedValueAtFiber(value, sourceFiber)),\n          (rootRenderLanes = createRootErrorUpdate(\n            root.stateNode,\n            value,\n            rootRenderLanes\n          )),\n          enqueueCapturedUpdate(root, rootRenderLanes),\n          4 !== workInProgressRootExitStatus &&\n            (workInProgressRootExitStatus = 2)),\n      !1\n    );\n  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });\n  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);\n  null === workInProgressRootConcurrentErrors\n    ? (workInProgressRootConcurrentErrors = [wrapperError])\n    : workInProgressRootConcurrentErrors.push(wrapperError);\n  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);\n  if (null === returnFiber) return !0;\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  sourceFiber = returnFiber;\n  do {\n    switch (sourceFiber.tag) {\n      case 3:\n        return (\n          (sourceFiber.flags |= 65536),\n          (root = rootRenderLanes & -rootRenderLanes),\n          (sourceFiber.lanes |= root),\n          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),\n          enqueueCapturedUpdate(sourceFiber, root),\n          !1\n        );\n      case 1:\n        if (\n          ((returnFiber = sourceFiber.type),\n          (wrapperError = sourceFiber.stateNode),\n          0 === (sourceFiber.flags & 128) &&\n            ("function" === typeof returnFiber.getDerivedStateFromError ||\n              (null !== wrapperError &&\n                "function" === typeof wrapperError.componentDidCatch &&\n                (null === legacyErrorBoundariesThatAlreadyFailed ||\n                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))\n        )\n          return (\n            (sourceFiber.flags |= 65536),\n            (rootRenderLanes &= -rootRenderLanes),\n            (sourceFiber.lanes |= rootRenderLanes),\n            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),\n            initializeClassErrorUpdate(\n              rootRenderLanes,\n              root,\n              sourceFiber,\n              value\n            ),\n            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),\n            !1\n          );\n    }\n    sourceFiber = sourceFiber.return;\n  } while (null !== sourceFiber);\n  return !1;\n}\nvar SelectiveHydrationException = Error(formatProdErrorMessage(461)),\n  didReceiveUpdate = !1;\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  workInProgress.child =\n    null === current\n      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)\n      : reconcileChildFibers(\n          workInProgress,\n          current.child,\n          nextChildren,\n          renderLanes\n        );\n}\nfunction updateForwardRef(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  Component = Component.render;\n  var ref = workInProgress.ref;\n  if ("ref" in nextProps) {\n    var propsWithoutRef = {};\n    for (var key in nextProps)\n      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);\n  } else propsWithoutRef = nextProps;\n  prepareToReadContext(workInProgress);\n  nextProps = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    propsWithoutRef,\n    ref,\n    renderLanes\n  );\n  key = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && key && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null === current) {\n    var type = Component.type;\n    if (\n      "function" === typeof type &&\n      !shouldConstruct(type) &&\n      void 0 === type.defaultProps &&\n      null === Component.compare\n    )\n      return (\n        (workInProgress.tag = 15),\n        (workInProgress.type = type),\n        updateSimpleMemoComponent(\n          current,\n          workInProgress,\n          type,\n          nextProps,\n          renderLanes\n        )\n      );\n    current = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      workInProgress,\n      workInProgress.mode,\n      renderLanes\n    );\n    current.ref = workInProgress.ref;\n    current.return = workInProgress;\n    return (workInProgress.child = current);\n  }\n  type = current.child;\n  if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n    var prevProps = type.memoizedProps;\n    Component = Component.compare;\n    Component = null !== Component ? Component : shallowEqual;\n    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  workInProgress.flags |= 1;\n  current = createWorkInProgress(type, nextProps);\n  current.ref = workInProgress.ref;\n  current.return = workInProgress;\n  return (workInProgress.child = current);\n}\nfunction updateSimpleMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null !== current) {\n    var prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref\n    )\n      if (\n        ((didReceiveUpdate = !1),\n        (workInProgress.pendingProps = nextProps = prevProps),\n        checkScheduledUpdateOrContext(current, renderLanes))\n      )\n        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n      else\n        return (\n          (workInProgress.lanes = current.lanes),\n          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n        );\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderLanes\n  );\n}\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    nextChildren = nextProps.children,\n    nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),\n    prevState = null !== current ? current.memoizedState : null;\n  markRef(current, workInProgress);\n  if ("hidden" === nextProps.mode || nextIsDetached) {\n    if (0 !== (workInProgress.flags & 128)) {\n      nextProps =\n        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n      if (null !== current) {\n        nextChildren = workInProgress.child = current.child;\n        for (nextIsDetached = 0; null !== nextChildren; )\n          (nextIsDetached =\n            nextIsDetached | nextChildren.lanes | nextChildren.childLanes),\n            (nextChildren = nextChildren.sibling);\n        workInProgress.childLanes = nextIsDetached & ~nextProps;\n      } else (workInProgress.childLanes = 0), (workInProgress.child = null);\n      return deferHiddenOffscreenComponent(\n        current,\n        workInProgress,\n        nextProps,\n        renderLanes\n      );\n    }\n    if (0 !== (renderLanes & 536870912))\n      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),\n        null !== current &&\n          pushTransition(\n            workInProgress,\n            null !== prevState ? prevState.cachePool : null\n          ),\n        null !== prevState\n          ? pushHiddenContext(workInProgress, prevState)\n          : reuseHiddenContextOnStack(),\n        pushOffscreenSuspenseHandler(workInProgress);\n    else\n      return (\n        (workInProgress.lanes = workInProgress.childLanes = 536870912),\n        deferHiddenOffscreenComponent(\n          current,\n          workInProgress,\n          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,\n          renderLanes\n        )\n      );\n  } else\n    null !== prevState\n      ? (pushTransition(workInProgress, prevState.cachePool),\n        pushHiddenContext(workInProgress, prevState),\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (workInProgress.memoizedState = null))\n      : (null !== current && pushTransition(workInProgress, null),\n        reuseHiddenContextOnStack(),\n        reuseSuspenseHandlerOnStack(workInProgress));\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nfunction deferHiddenOffscreenComponent(\n  current,\n  workInProgress,\n  nextBaseLanes,\n  renderLanes\n) {\n  var JSCompiler_inline_result = peekCacheFromPool();\n  JSCompiler_inline_result =\n    null === JSCompiler_inline_result\n      ? null\n      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };\n  workInProgress.memoizedState = {\n    baseLanes: nextBaseLanes,\n    cachePool: JSCompiler_inline_result\n  };\n  null !== current && pushTransition(workInProgress, null);\n  reuseHiddenContextOnStack();\n  pushOffscreenSuspenseHandler(workInProgress);\n  null !== current &&\n    propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n  return null;\n}\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n  if (null === ref)\n    null !== current &&\n      null !== current.ref &&\n      (workInProgress.flags |= 2097664);\n  else {\n    if ("function" !== typeof ref && "object" !== typeof ref)\n      throw Error(formatProdErrorMessage(284));\n    if (null === current || current.ref !== ref)\n      workInProgress.flags |= 2097664;\n  }\n}\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  Component = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    void 0,\n    renderLanes\n  );\n  nextProps = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, Component, renderLanes);\n  return workInProgress.child;\n}\nfunction replayFunctionComponent(\n  current,\n  workInProgress,\n  nextProps,\n  Component,\n  secondArg,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  workInProgress.updateQueue = null;\n  nextProps = renderWithHooksAgain(\n    workInProgress,\n    Component,\n    nextProps,\n    secondArg\n  );\n  finishRenderingHooks(current);\n  Component = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && Component && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateClassComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  if (null === workInProgress.stateNode) {\n    var context = emptyContextObject,\n      contextType = Component.contextType;\n    "object" === typeof contextType &&\n      null !== contextType &&\n      (context = readContext(contextType));\n    context = new Component(nextProps, context);\n    workInProgress.memoizedState =\n      null !== context.state && void 0 !== context.state ? context.state : null;\n    context.updater = classComponentUpdater;\n    workInProgress.stateNode = context;\n    context._reactInternals = workInProgress;\n    context = workInProgress.stateNode;\n    context.props = nextProps;\n    context.state = workInProgress.memoizedState;\n    context.refs = {};\n    initializeUpdateQueue(workInProgress);\n    contextType = Component.contextType;\n    context.context =\n      "object" === typeof contextType && null !== contextType\n        ? readContext(contextType)\n        : emptyContextObject;\n    context.state = workInProgress.memoizedState;\n    contextType = Component.getDerivedStateFromProps;\n    "function" === typeof contextType &&\n      (applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        contextType,\n        nextProps\n      ),\n      (context.state = workInProgress.memoizedState));\n    "function" === typeof Component.getDerivedStateFromProps ||\n      "function" === typeof context.getSnapshotBeforeUpdate ||\n      ("function" !== typeof context.UNSAFE_componentWillMount &&\n        "function" !== typeof context.componentWillMount) ||\n      ((contextType = context.state),\n      "function" === typeof context.componentWillMount &&\n        context.componentWillMount(),\n      "function" === typeof context.UNSAFE_componentWillMount &&\n        context.UNSAFE_componentWillMount(),\n      contextType !== context.state &&\n        classComponentUpdater.enqueueReplaceState(context, context.state, null),\n      processUpdateQueue(workInProgress, nextProps, context, renderLanes),\n      suspendIfUpdateReadFromEntangledAsyncAction(),\n      (context.state = workInProgress.memoizedState));\n    "function" === typeof context.componentDidMount &&\n      (workInProgress.flags |= 4194308);\n    nextProps = !0;\n  } else if (null === current) {\n    context = workInProgress.stateNode;\n    var unresolvedOldProps = workInProgress.memoizedProps,\n      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);\n    context.props = oldProps;\n    var oldContext = context.context,\n      contextType$jscomp$0 = Component.contextType;\n    contextType = emptyContextObject;\n    "object" === typeof contextType$jscomp$0 &&\n      null !== contextType$jscomp$0 &&\n      (contextType = readContext(contextType$jscomp$0));\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    contextType$jscomp$0 =\n      "function" === typeof getDerivedStateFromProps ||\n      "function" === typeof context.getSnapshotBeforeUpdate;\n    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n    contextType$jscomp$0 ||\n      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        "function" !== typeof context.componentWillReceiveProps) ||\n      ((unresolvedOldProps || oldContext !== contextType) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          contextType\n        ));\n    hasForceUpdate = !1;\n    var oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    oldContext = workInProgress.memoizedState;\n    unresolvedOldProps || oldState !== oldContext || hasForceUpdate\n      ? ("function" === typeof getDerivedStateFromProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            getDerivedStateFromProps,\n            nextProps\n          ),\n          (oldContext = workInProgress.memoizedState)),\n        (oldProps =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            oldProps,\n            nextProps,\n            oldState,\n            oldContext,\n            contextType\n          ))\n          ? (contextType$jscomp$0 ||\n              ("function" !== typeof context.UNSAFE_componentWillMount &&\n                "function" !== typeof context.componentWillMount) ||\n              ("function" === typeof context.componentWillMount &&\n                context.componentWillMount(),\n              "function" === typeof context.UNSAFE_componentWillMount &&\n                context.UNSAFE_componentWillMount()),\n            "function" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308))\n          : ("function" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = oldContext)),\n        (context.props = nextProps),\n        (context.state = oldContext),\n        (context.context = contextType),\n        (nextProps = oldProps))\n      : ("function" === typeof context.componentDidMount &&\n          (workInProgress.flags |= 4194308),\n        (nextProps = !1));\n  } else {\n    context = workInProgress.stateNode;\n    cloneUpdateQueue(current, workInProgress);\n    contextType = workInProgress.memoizedProps;\n    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);\n    context.props = contextType$jscomp$0;\n    getDerivedStateFromProps = workInProgress.pendingProps;\n    oldState = context.context;\n    oldContext = Component.contextType;\n    oldProps = emptyContextObject;\n    "object" === typeof oldContext &&\n      null !== oldContext &&\n      (oldProps = readContext(oldContext));\n    unresolvedOldProps = Component.getDerivedStateFromProps;\n    (oldContext =\n      "function" === typeof unresolvedOldProps ||\n      "function" === typeof context.getSnapshotBeforeUpdate) ||\n      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        "function" !== typeof context.componentWillReceiveProps) ||\n      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          oldProps\n        ));\n    hasForceUpdate = !1;\n    oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    var newState = workInProgress.memoizedState;\n    contextType !== getDerivedStateFromProps ||\n    oldState !== newState ||\n    hasForceUpdate ||\n    (null !== current &&\n      null !== current.dependencies &&\n      checkIfContextChanged(current.dependencies))\n      ? ("function" === typeof unresolvedOldProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            unresolvedOldProps,\n            nextProps\n          ),\n          (newState = workInProgress.memoizedState)),\n        (contextType$jscomp$0 =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            contextType$jscomp$0,\n            nextProps,\n            oldState,\n            newState,\n            oldProps\n          ) ||\n          (null !== current &&\n            null !== current.dependencies &&\n            checkIfContextChanged(current.dependencies)))\n          ? (oldContext ||\n              ("function" !== typeof context.UNSAFE_componentWillUpdate &&\n                "function" !== typeof context.componentWillUpdate) ||\n              ("function" === typeof context.componentWillUpdate &&\n                context.componentWillUpdate(nextProps, newState, oldProps),\n              "function" === typeof context.UNSAFE_componentWillUpdate &&\n                context.UNSAFE_componentWillUpdate(\n                  nextProps,\n                  newState,\n                  oldProps\n                )),\n            "function" === typeof context.componentDidUpdate &&\n              (workInProgress.flags |= 4),\n            "function" === typeof context.getSnapshotBeforeUpdate &&\n              (workInProgress.flags |= 1024))\n          : ("function" !== typeof context.componentDidUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 4),\n            "function" !== typeof context.getSnapshotBeforeUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 1024),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = newState)),\n        (context.props = nextProps),\n        (context.state = newState),\n        (context.context = oldProps),\n        (nextProps = contextType$jscomp$0))\n      : ("function" !== typeof context.componentDidUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 4),\n        "function" !== typeof context.getSnapshotBeforeUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 1024),\n        (nextProps = !1));\n  }\n  context = nextProps;\n  markRef(current, workInProgress);\n  nextProps = 0 !== (workInProgress.flags & 128);\n  context || nextProps\n    ? ((context = workInProgress.stateNode),\n      (Component =\n        nextProps && "function" !== typeof Component.getDerivedStateFromError\n          ? null\n          : context.render()),\n      (workInProgress.flags |= 1),\n      null !== current && nextProps\n        ? ((workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            current.child,\n            null,\n            renderLanes\n          )),\n          (workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            null,\n            Component,\n            renderLanes\n          )))\n        : reconcileChildren(current, workInProgress, Component, renderLanes),\n      (workInProgress.memoizedState = context.state),\n      (current = workInProgress.child))\n    : (current = bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderLanes\n      ));\n  return current;\n}\nfunction mountHostRootWithoutHydrating(\n  current,\n  workInProgress,\n  nextChildren,\n  renderLanes\n) {\n  resetHydrationState();\n  workInProgress.flags |= 256;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nvar SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };\n}\nfunction getRemainingWorkInPrimaryTree(\n  current,\n  primaryTreeDidDefer,\n  renderLanes\n) {\n  current = null !== current ? current.childLanes & ~renderLanes : 0;\n  primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n  return current;\n}\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    showFallback = !1,\n    didSuspend = 0 !== (workInProgress.flags & 128),\n    JSCompiler_temp;\n  (JSCompiler_temp = didSuspend) ||\n    (JSCompiler_temp =\n      null !== current && null === current.memoizedState\n        ? !1\n        : 0 !== (suspenseStackCursor.current & 2));\n  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));\n  JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n  workInProgress.flags &= -33;\n  if (null === current) {\n    if (isHydrating) {\n      showFallback\n        ? pushPrimaryTreeSuspenseHandler(workInProgress)\n        : reuseSuspenseHandlerOnStack(workInProgress);\n      if (isHydrating) {\n        var nextInstance = nextHydratableInstance,\n          JSCompiler_temp$jscomp$0;\n        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {\n          c: {\n            JSCompiler_temp$jscomp$0 = nextInstance;\n            for (\n              nextInstance = rootOrSingletonContext;\n              8 !== JSCompiler_temp$jscomp$0.nodeType;\n\n            ) {\n              if (!nextInstance) {\n                nextInstance = null;\n                break c;\n              }\n              JSCompiler_temp$jscomp$0 = getNextHydratable(\n                JSCompiler_temp$jscomp$0.nextSibling\n              );\n              if (null === JSCompiler_temp$jscomp$0) {\n                nextInstance = null;\n                break c;\n              }\n            }\n            nextInstance = JSCompiler_temp$jscomp$0;\n          }\n          null !== nextInstance\n            ? ((workInProgress.memoizedState = {\n                dehydrated: nextInstance,\n                treeContext:\n                  null !== treeContextProvider\n                    ? { id: treeContextId, overflow: treeContextOverflow }\n                    : null,\n                retryLane: 536870912\n              }),\n              (JSCompiler_temp$jscomp$0 = createFiberImplClass(\n                18,\n                null,\n                null,\n                0\n              )),\n              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),\n              (JSCompiler_temp$jscomp$0.return = workInProgress),\n              (workInProgress.child = JSCompiler_temp$jscomp$0),\n              (hydrationParentFiber = workInProgress),\n              (nextHydratableInstance = null),\n              (JSCompiler_temp$jscomp$0 = !0))\n            : (JSCompiler_temp$jscomp$0 = !1);\n        }\n        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);\n      }\n      nextInstance = workInProgress.memoizedState;\n      if (\n        null !== nextInstance &&\n        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)\n      )\n        return (\n          "$!" === nextInstance.data\n            ? (workInProgress.lanes = 16)\n            : (workInProgress.lanes = 536870912),\n          null\n        );\n      popSuspenseHandler(workInProgress);\n    }\n    nextInstance = nextProps.children;\n    nextProps = nextProps.fallback;\n    if (showFallback)\n      return (\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (showFallback = workInProgress.mode),\n        (nextInstance = mountWorkInProgressOffscreenFiber(\n          { mode: "hidden", children: nextInstance },\n          showFallback\n        )),\n        (nextProps = createFiberFromFragment(\n          nextProps,\n          showFallback,\n          renderLanes,\n          null\n        )),\n        (nextInstance.return = workInProgress),\n        (nextProps.return = workInProgress),\n        (nextInstance.sibling = nextProps),\n        (workInProgress.child = nextInstance),\n        (showFallback = workInProgress.child),\n        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),\n        (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n          current,\n          JSCompiler_temp,\n          renderLanes\n        )),\n        (workInProgress.memoizedState = SUSPENDED_MARKER),\n        nextProps\n      );\n    pushPrimaryTreeSuspenseHandler(workInProgress);\n    return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n  }\n  JSCompiler_temp$jscomp$0 = current.memoizedState;\n  if (\n    null !== JSCompiler_temp$jscomp$0 &&\n    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),\n    null !== nextInstance)\n  ) {\n    if (didSuspend)\n      workInProgress.flags & 256\n        ? (pushPrimaryTreeSuspenseHandler(workInProgress),\n          (workInProgress.flags &= -257),\n          (workInProgress = retrySuspenseComponentWithoutHydrating(\n            current,\n            workInProgress,\n            renderLanes\n          )))\n        : null !== workInProgress.memoizedState\n          ? (reuseSuspenseHandlerOnStack(workInProgress),\n            (workInProgress.child = current.child),\n            (workInProgress.flags |= 128),\n            (workInProgress = null))\n          : (reuseSuspenseHandlerOnStack(workInProgress),\n            (showFallback = nextProps.fallback),\n            (nextInstance = workInProgress.mode),\n            (nextProps = mountWorkInProgressOffscreenFiber(\n              { mode: "visible", children: nextProps.children },\n              nextInstance\n            )),\n            (showFallback = createFiberFromFragment(\n              showFallback,\n              nextInstance,\n              renderLanes,\n              null\n            )),\n            (showFallback.flags |= 2),\n            (nextProps.return = workInProgress),\n            (showFallback.return = workInProgress),\n            (nextProps.sibling = showFallback),\n            (workInProgress.child = nextProps),\n            reconcileChildFibers(\n              workInProgress,\n              current.child,\n              null,\n              renderLanes\n            ),\n            (nextProps = workInProgress.child),\n            (nextProps.memoizedState =\n              mountSuspenseOffscreenState(renderLanes)),\n            (nextProps.childLanes = getRemainingWorkInPrimaryTree(\n              current,\n              JSCompiler_temp,\n              renderLanes\n            )),\n            (workInProgress.memoizedState = SUSPENDED_MARKER),\n            (workInProgress = showFallback));\n    else if (\n      (pushPrimaryTreeSuspenseHandler(workInProgress),\n      "$!" === nextInstance.data)\n    ) {\n      JSCompiler_temp =\n        nextInstance.nextSibling && nextInstance.nextSibling.dataset;\n      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;\n      JSCompiler_temp = digest;\n      nextProps = Error(formatProdErrorMessage(419));\n      nextProps.stack = "";\n      nextProps.digest = JSCompiler_temp;\n      queueHydrationError({ value: nextProps, source: null, stack: null });\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else if (\n      (didReceiveUpdate ||\n        propagateParentContextChanges(current, workInProgress, renderLanes, !1),\n      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),\n      didReceiveUpdate || JSCompiler_temp)\n    ) {\n      JSCompiler_temp = workInProgressRoot;\n      if (null !== JSCompiler_temp) {\n        nextProps = renderLanes & -renderLanes;\n        if (0 !== (nextProps & 42)) nextProps = 1;\n        else\n          switch (nextProps) {\n            case 2:\n              nextProps = 1;\n              break;\n            case 8:\n              nextProps = 4;\n              break;\n            case 32:\n              nextProps = 16;\n              break;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n              nextProps = 64;\n              break;\n            case 268435456:\n              nextProps = 134217728;\n              break;\n            default:\n              nextProps = 0;\n          }\n        nextProps =\n          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))\n            ? 0\n            : nextProps;\n        if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)\n          throw (\n            ((JSCompiler_temp$jscomp$0.retryLane = nextProps),\n            enqueueConcurrentRenderForLane(current, nextProps),\n            scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),\n            SelectiveHydrationException)\n          );\n      }\n      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else\n      "$?" === nextInstance.data\n        ? ((workInProgress.flags |= 128),\n          (workInProgress.child = current.child),\n          (workInProgress = retryDehydratedSuspenseBoundary.bind(\n            null,\n            current\n          )),\n          (nextInstance._reactRetry = workInProgress),\n          (workInProgress = null))\n        : ((current = JSCompiler_temp$jscomp$0.treeContext),\n          (nextHydratableInstance = getNextHydratable(\n            nextInstance.nextSibling\n          )),\n          (hydrationParentFiber = workInProgress),\n          (isHydrating = !0),\n          (hydrationErrors = null),\n          (rootOrSingletonContext = !1),\n          null !== current &&\n            ((idStack[idStackIndex++] = treeContextId),\n            (idStack[idStackIndex++] = treeContextOverflow),\n            (idStack[idStackIndex++] = treeContextProvider),\n            (treeContextId = current.id),\n            (treeContextOverflow = current.overflow),\n            (treeContextProvider = workInProgress)),\n          (workInProgress = mountSuspensePrimaryChildren(\n            workInProgress,\n            nextProps.children\n          )),\n          (workInProgress.flags |= 4096));\n    return workInProgress;\n  }\n  if (showFallback)\n    return (\n      reuseSuspenseHandlerOnStack(workInProgress),\n      (showFallback = nextProps.fallback),\n      (nextInstance = workInProgress.mode),\n      (JSCompiler_temp$jscomp$0 = current.child),\n      (digest = JSCompiler_temp$jscomp$0.sibling),\n      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n        mode: "hidden",\n        children: nextProps.children\n      })),\n      (nextProps.subtreeFlags =\n        JSCompiler_temp$jscomp$0.subtreeFlags & 31457280),\n      null !== digest\n        ? (showFallback = createWorkInProgress(digest, showFallback))\n        : ((showFallback = createFiberFromFragment(\n            showFallback,\n            nextInstance,\n            renderLanes,\n            null\n          )),\n          (showFallback.flags |= 2)),\n      (showFallback.return = workInProgress),\n      (nextProps.return = workInProgress),\n      (nextProps.sibling = showFallback),\n      (workInProgress.child = nextProps),\n      (nextProps = showFallback),\n      (showFallback = workInProgress.child),\n      (nextInstance = current.child.memoizedState),\n      null === nextInstance\n        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))\n        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),\n          null !== JSCompiler_temp$jscomp$0\n            ? ((digest = CacheContext._currentValue),\n              (JSCompiler_temp$jscomp$0 =\n                JSCompiler_temp$jscomp$0.parent !== digest\n                  ? { parent: digest, pool: digest }\n                  : JSCompiler_temp$jscomp$0))\n            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),\n          (nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n          })),\n      (showFallback.memoizedState = nextInstance),\n      (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n        current,\n        JSCompiler_temp,\n        renderLanes\n      )),\n      (workInProgress.memoizedState = SUSPENDED_MARKER),\n      nextProps\n    );\n  pushPrimaryTreeSuspenseHandler(workInProgress);\n  renderLanes = current.child;\n  current = renderLanes.sibling;\n  renderLanes = createWorkInProgress(renderLanes, {\n    mode: "visible",\n    children: nextProps.children\n  });\n  renderLanes.return = workInProgress;\n  renderLanes.sibling = null;\n  null !== current &&\n    ((JSCompiler_temp = workInProgress.deletions),\n    null === JSCompiler_temp\n      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))\n      : JSCompiler_temp.push(current));\n  workInProgress.child = renderLanes;\n  workInProgress.memoizedState = null;\n  return renderLanes;\n}\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n  primaryChildren = mountWorkInProgressOffscreenFiber(\n    { mode: "visible", children: primaryChildren },\n    workInProgress.mode\n  );\n  primaryChildren.return = workInProgress;\n  return (workInProgress.child = primaryChildren);\n}\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n  return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n}\nfunction retrySuspenseComponentWithoutHydrating(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  current = mountSuspensePrimaryChildren(\n    workInProgress,\n    workInProgress.pendingProps.children\n  );\n  current.flags |= 2;\n  workInProgress.memoizedState = null;\n  return current;\n}\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes |= renderLanes;\n  var alternate = fiber.alternate;\n  null !== alternate && (alternate.lanes |= renderLanes);\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\nfunction initSuspenseListRenderState(\n  workInProgress,\n  isBackwards,\n  tail,\n  lastContentRow,\n  tailMode\n) {\n  var renderState = workInProgress.memoizedState;\n  null === renderState\n    ? (workInProgress.memoizedState = {\n        isBackwards: isBackwards,\n        rendering: null,\n        renderingStartTime: 0,\n        last: lastContentRow,\n        tail: tail,\n        tailMode: tailMode\n      })\n    : ((renderState.isBackwards = isBackwards),\n      (renderState.rendering = null),\n      (renderState.renderingStartTime = 0),\n      (renderState.last = lastContentRow),\n      (renderState.tail = tail),\n      (renderState.tailMode = tailMode));\n}\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    revealOrder = nextProps.revealOrder,\n    tailMode = nextProps.tail;\n  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);\n  nextProps = suspenseStackCursor.current;\n  if (0 !== (nextProps & 2))\n    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);\n  else {\n    if (null !== current && 0 !== (current.flags & 128))\n      a: for (current = workInProgress.child; null !== current; ) {\n        if (13 === current.tag)\n          null !== current.memoizedState &&\n            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (19 === current.tag)\n          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (null !== current.child) {\n          current.child.return = current;\n          current = current.child;\n          continue;\n        }\n        if (current === workInProgress) break a;\n        for (; null === current.sibling; ) {\n          if (null === current.return || current.return === workInProgress)\n            break a;\n          current = current.return;\n        }\n        current.sibling.return = current.return;\n        current = current.sibling;\n      }\n    nextProps &= 1;\n  }\n  push(suspenseStackCursor, nextProps);\n  switch (revealOrder) {\n    case "forwards":\n      renderLanes = workInProgress.child;\n      for (revealOrder = null; null !== renderLanes; )\n        (current = renderLanes.alternate),\n          null !== current &&\n            null === findFirstSuspended(current) &&\n            (revealOrder = renderLanes),\n          (renderLanes = renderLanes.sibling);\n      renderLanes = revealOrder;\n      null === renderLanes\n        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))\n        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));\n      initSuspenseListRenderState(\n        workInProgress,\n        !1,\n        revealOrder,\n        renderLanes,\n        tailMode\n      );\n      break;\n    case "backwards":\n      renderLanes = null;\n      revealOrder = workInProgress.child;\n      for (workInProgress.child = null; null !== revealOrder; ) {\n        current = revealOrder.alternate;\n        if (null !== current && null === findFirstSuspended(current)) {\n          workInProgress.child = revealOrder;\n          break;\n        }\n        current = revealOrder.sibling;\n        revealOrder.sibling = renderLanes;\n        renderLanes = revealOrder;\n        revealOrder = current;\n      }\n      initSuspenseListRenderState(\n        workInProgress,\n        !0,\n        renderLanes,\n        null,\n        tailMode\n      );\n      break;\n    case "together":\n      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n      break;\n    default:\n      workInProgress.memoizedState = null;\n  }\n  return workInProgress.child;\n}\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  null !== current && (workInProgress.dependencies = current.dependencies);\n  workInProgressRootSkippedLanes |= workInProgress.lanes;\n  if (0 === (renderLanes & workInProgress.childLanes))\n    if (null !== current) {\n      if (\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        0 === (renderLanes & workInProgress.childLanes))\n      )\n        return null;\n    } else return null;\n  if (null !== current && workInProgress.child !== current.child)\n    throw Error(formatProdErrorMessage(153));\n  if (null !== workInProgress.child) {\n    current = workInProgress.child;\n    renderLanes = createWorkInProgress(current, current.pendingProps);\n    workInProgress.child = renderLanes;\n    for (renderLanes.return = workInProgress; null !== current.sibling; )\n      (current = current.sibling),\n        (renderLanes = renderLanes.sibling =\n          createWorkInProgress(current, current.pendingProps)),\n        (renderLanes.return = workInProgress);\n    renderLanes.sibling = null;\n  }\n  return workInProgress.child;\n}\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  if (0 !== (current.lanes & renderLanes)) return !0;\n  current = current.dependencies;\n  return null !== current && checkIfContextChanged(current) ? !0 : !1;\n}\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  switch (workInProgress.tag) {\n    case 3:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n      resetHydrationState();\n      break;\n    case 27:\n    case 5:\n      pushHostContext(workInProgress);\n      break;\n    case 4:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case 10:\n      pushProvider(\n        workInProgress,\n        workInProgress.type,\n        workInProgress.memoizedProps.value\n      );\n      break;\n    case 13:\n      var state = workInProgress.memoizedState;\n      if (null !== state) {\n        if (null !== state.dehydrated)\n          return (\n            pushPrimaryTreeSuspenseHandler(workInProgress),\n            (workInProgress.flags |= 128),\n            null\n          );\n        if (0 !== (renderLanes & workInProgress.child.childLanes))\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        current = bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes\n        );\n        return null !== current ? current.sibling : null;\n      }\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      break;\n    case 19:\n      var didSuspendBefore = 0 !== (current.flags & 128);\n      state = 0 !== (renderLanes & workInProgress.childLanes);\n      state ||\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        (state = 0 !== (renderLanes & workInProgress.childLanes)));\n      if (didSuspendBefore) {\n        if (state)\n          return updateSuspenseListComponent(\n            current,\n            workInProgress,\n            renderLanes\n          );\n        workInProgress.flags |= 128;\n      }\n      didSuspendBefore = workInProgress.memoizedState;\n      null !== didSuspendBefore &&\n        ((didSuspendBefore.rendering = null),\n        (didSuspendBefore.tail = null),\n        (didSuspendBefore.lastEffect = null));\n      push(suspenseStackCursor, suspenseStackCursor.current);\n      if (state) break;\n      else return null;\n    case 22:\n    case 23:\n      return (\n        (workInProgress.lanes = 0),\n        updateOffscreenComponent(current, workInProgress, renderLanes)\n      );\n    case 24:\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n  }\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (null !== current)\n    if (current.memoizedProps !== workInProgress.pendingProps)\n      didReceiveUpdate = !0;\n    else {\n      if (\n        !checkScheduledUpdateOrContext(current, renderLanes) &&\n        0 === (workInProgress.flags & 128)\n      )\n        return (\n          (didReceiveUpdate = !1),\n          attemptEarlyBailoutIfNoScheduledUpdate(\n            current,\n            workInProgress,\n            renderLanes\n          )\n        );\n      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n    }\n  else\n    (didReceiveUpdate = !1),\n      isHydrating &&\n        0 !== (workInProgress.flags & 1048576) &&\n        pushTreeId(workInProgress, treeForkCount, workInProgress.index);\n  workInProgress.lanes = 0;\n  switch (workInProgress.tag) {\n    case 16:\n      a: {\n        current = workInProgress.pendingProps;\n        var lazyComponent = workInProgress.elementType,\n          init = lazyComponent._init;\n        lazyComponent = init(lazyComponent._payload);\n        workInProgress.type = lazyComponent;\n        if ("function" === typeof lazyComponent)\n          shouldConstruct(lazyComponent)\n            ? ((current = resolveClassComponentProps(lazyComponent, current)),\n              (workInProgress.tag = 1),\n              (workInProgress = updateClassComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )))\n            : ((workInProgress.tag = 0),\n              (workInProgress = updateFunctionComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )));\n        else {\n          if (void 0 !== lazyComponent && null !== lazyComponent)\n            if (\n              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)\n            ) {\n              workInProgress.tag = 11;\n              workInProgress = updateForwardRef(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            } else if (init === REACT_MEMO_TYPE) {\n              workInProgress.tag = 14;\n              workInProgress = updateMemoComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            }\n          workInProgress =\n            getComponentNameFromType(lazyComponent) || lazyComponent;\n          throw Error(formatProdErrorMessage(306, workInProgress, ""));\n        }\n      }\n      return workInProgress;\n    case 0:\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 1:\n      return (\n        (lazyComponent = workInProgress.type),\n        (init = resolveClassComponentProps(\n          lazyComponent,\n          workInProgress.pendingProps\n        )),\n        updateClassComponent(\n          current,\n          workInProgress,\n          lazyComponent,\n          init,\n          renderLanes\n        )\n      );\n    case 3:\n      a: {\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        if (null === current) throw Error(formatProdErrorMessage(387));\n        var nextProps = workInProgress.pendingProps;\n        init = workInProgress.memoizedState;\n        lazyComponent = init.element;\n        cloneUpdateQueue(current, workInProgress);\n        processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n        var nextState = workInProgress.memoizedState;\n        nextProps = nextState.cache;\n        pushProvider(workInProgress, CacheContext, nextProps);\n        nextProps !== init.cache &&\n          propagateContextChanges(\n            workInProgress,\n            [CacheContext],\n            renderLanes,\n            !0\n          );\n        suspendIfUpdateReadFromEntangledAsyncAction();\n        nextProps = nextState.element;\n        if (init.isDehydrated)\n          if (\n            ((init = {\n              element: nextProps,\n              isDehydrated: !1,\n              cache: nextState.cache\n            }),\n            (workInProgress.updateQueue.baseState = init),\n            (workInProgress.memoizedState = init),\n            workInProgress.flags & 256)\n          ) {\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              nextProps,\n              renderLanes\n            );\n            break a;\n          } else if (nextProps !== lazyComponent) {\n            lazyComponent = createCapturedValueAtFiber(\n              Error(formatProdErrorMessage(424)),\n              workInProgress\n            );\n            queueHydrationError(lazyComponent);\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              nextProps,\n              renderLanes\n            );\n            break a;\n          } else\n            for (\n              nextHydratableInstance = getNextHydratable(\n                workInProgress.stateNode.containerInfo.firstChild\n              ),\n                hydrationParentFiber = workInProgress,\n                isHydrating = !0,\n                hydrationErrors = null,\n                rootOrSingletonContext = !0,\n                renderLanes = mountChildFibers(\n                  workInProgress,\n                  null,\n                  nextProps,\n                  renderLanes\n                ),\n                workInProgress.child = renderLanes;\n              renderLanes;\n\n            )\n              (renderLanes.flags = (renderLanes.flags & -3) | 4096),\n                (renderLanes = renderLanes.sibling);\n        else {\n          resetHydrationState();\n          if (nextProps === lazyComponent) {\n            workInProgress = bailoutOnAlreadyFinishedWork(\n              current,\n              workInProgress,\n              renderLanes\n            );\n            break a;\n          }\n          reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        }\n        workInProgress = workInProgress.child;\n      }\n      return workInProgress;\n    case 26:\n      return (\n        markRef(current, workInProgress),\n        null === current\n          ? (renderLanes = getResource(\n              workInProgress.type,\n              null,\n              workInProgress.pendingProps,\n              null\n            ))\n            ? (workInProgress.memoizedState = renderLanes)\n            : isHydrating ||\n              ((renderLanes = workInProgress.type),\n              (current = workInProgress.pendingProps),\n              (lazyComponent = getOwnerDocumentFromRootContainer(\n                rootInstanceStackCursor.current\n              ).createElement(renderLanes)),\n              (lazyComponent[internalInstanceKey] = workInProgress),\n              (lazyComponent[internalPropsKey] = current),\n              setInitialProperties(lazyComponent, renderLanes, current),\n              markNodeAsHoistable(lazyComponent),\n              (workInProgress.stateNode = lazyComponent))\n          : (workInProgress.memoizedState = getResource(\n              workInProgress.type,\n              current.memoizedProps,\n              workInProgress.pendingProps,\n              current.memoizedState\n            )),\n        null\n      );\n    case 27:\n      return (\n        pushHostContext(workInProgress),\n        null === current &&\n          isHydrating &&\n          ((lazyComponent = workInProgress.stateNode =\n            resolveSingletonInstance(\n              workInProgress.type,\n              workInProgress.pendingProps,\n              rootInstanceStackCursor.current\n            )),\n          (hydrationParentFiber = workInProgress),\n          (rootOrSingletonContext = !0),\n          (nextHydratableInstance = getNextHydratable(\n            lazyComponent.firstChild\n          ))),\n        (lazyComponent = workInProgress.pendingProps.children),\n        null !== current || isHydrating\n          ? reconcileChildren(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            )\n          : (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            )),\n        markRef(current, workInProgress),\n        workInProgress.child\n      );\n    case 5:\n      if (null === current && isHydrating) {\n        if ((init = lazyComponent = nextHydratableInstance))\n          (lazyComponent = canHydrateInstance(\n            lazyComponent,\n            workInProgress.type,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== lazyComponent\n              ? ((workInProgress.stateNode = lazyComponent),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = getNextHydratable(\n                  lazyComponent.firstChild\n                )),\n                (rootOrSingletonContext = !1),\n                (init = !0))\n              : (init = !1);\n        init || throwOnHydrationMismatch(workInProgress);\n      }\n      pushHostContext(workInProgress);\n      init = workInProgress.type;\n      nextProps = workInProgress.pendingProps;\n      nextState = null !== current ? current.memoizedProps : null;\n      lazyComponent = nextProps.children;\n      shouldSetTextContent(init, nextProps)\n        ? (lazyComponent = null)\n        : null !== nextState &&\n          shouldSetTextContent(init, nextState) &&\n          (workInProgress.flags |= 32);\n      null !== workInProgress.memoizedState &&\n        ((init = renderWithHooks(\n          current,\n          workInProgress,\n          TransitionAwareHostComponent,\n          null,\n          null,\n          renderLanes\n        )),\n        (HostTransitionContext._currentValue = init));\n      markRef(current, workInProgress);\n      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);\n      return workInProgress.child;\n    case 6:\n      if (null === current && isHydrating) {\n        if ((current = renderLanes = nextHydratableInstance))\n          (renderLanes = canHydrateTextInstance(\n            renderLanes,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== renderLanes\n              ? ((workInProgress.stateNode = renderLanes),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = null),\n                (current = !0))\n              : (current = !1);\n        current || throwOnHydrationMismatch(workInProgress);\n      }\n      return null;\n    case 13:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case 4:\n      return (\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        ),\n        (lazyComponent = workInProgress.pendingProps),\n        null === current\n          ? (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            ))\n          : reconcileChildren(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            ),\n        workInProgress.child\n      );\n    case 11:\n      return updateForwardRef(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 7:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 8:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 12:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 10:\n      return (\n        (lazyComponent = workInProgress.pendingProps),\n        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),\n        reconcileChildren(\n          current,\n          workInProgress,\n          lazyComponent.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 9:\n      return (\n        (init = workInProgress.type._context),\n        (lazyComponent = workInProgress.pendingProps.children),\n        prepareToReadContext(workInProgress),\n        (init = readContext(init)),\n        (lazyComponent = lazyComponent(init)),\n        (workInProgress.flags |= 1),\n        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),\n        workInProgress.child\n      );\n    case 14:\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 15:\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 19:\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    case 22:\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    case 24:\n      return (\n        prepareToReadContext(workInProgress),\n        (lazyComponent = readContext(CacheContext)),\n        null === current\n          ? ((init = peekCacheFromPool()),\n            null === init &&\n              ((init = workInProgressRoot),\n              (nextProps = createCache()),\n              (init.pooledCache = nextProps),\n              nextProps.refCount++,\n              null !== nextProps && (init.pooledCacheLanes |= renderLanes),\n              (init = nextProps)),\n            (workInProgress.memoizedState = {\n              parent: lazyComponent,\n              cache: init\n            }),\n            initializeUpdateQueue(workInProgress),\n            pushProvider(workInProgress, CacheContext, init))\n          : (0 !== (current.lanes & renderLanes) &&\n              (cloneUpdateQueue(current, workInProgress),\n              processUpdateQueue(workInProgress, null, null, renderLanes),\n              suspendIfUpdateReadFromEntangledAsyncAction()),\n            (init = current.memoizedState),\n            (nextProps = workInProgress.memoizedState),\n            init.parent !== lazyComponent\n              ? ((init = { parent: lazyComponent, cache: lazyComponent }),\n                (workInProgress.memoizedState = init),\n                0 === workInProgress.lanes &&\n                  (workInProgress.memoizedState =\n                    workInProgress.updateQueue.baseState =\n                      init),\n                pushProvider(workInProgress, CacheContext, lazyComponent))\n              : ((lazyComponent = nextProps.cache),\n                pushProvider(workInProgress, CacheContext, lazyComponent),\n                lazyComponent !== init.cache &&\n                  propagateContextChanges(\n                    workInProgress,\n                    [CacheContext],\n                    renderLanes,\n                    !0\n                  ))),\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 29:\n      throw workInProgress.pendingProps;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nvar valueCursor = createCursor(null),\n  currentlyRenderingFiber = null,\n  lastContextDependency = null;\nfunction pushProvider(providerFiber, context, nextValue) {\n  push(valueCursor, context._currentValue);\n  context._currentValue = nextValue;\n}\nfunction popProvider(context) {\n  context._currentValue = valueCursor.current;\n  pop(valueCursor);\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  for (; null !== parent; ) {\n    var alternate = parent.alternate;\n    (parent.childLanes & renderLanes) !== renderLanes\n      ? ((parent.childLanes |= renderLanes),\n        null !== alternate && (alternate.childLanes |= renderLanes))\n      : null !== alternate &&\n        (alternate.childLanes & renderLanes) !== renderLanes &&\n        (alternate.childLanes |= renderLanes);\n    if (parent === propagationRoot) break;\n    parent = parent.return;\n  }\n}\nfunction propagateContextChanges(\n  workInProgress,\n  contexts,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  var fiber = workInProgress.child;\n  null !== fiber && (fiber.return = workInProgress);\n  for (; null !== fiber; ) {\n    var list = fiber.dependencies;\n    if (null !== list) {\n      var nextFiber = fiber.child;\n      list = list.firstContext;\n      a: for (; null !== list; ) {\n        var dependency = list;\n        list = fiber;\n        for (var i = 0; i < contexts.length; i++)\n          if (dependency.context === contexts[i]) {\n            list.lanes |= renderLanes;\n            dependency = list.alternate;\n            null !== dependency && (dependency.lanes |= renderLanes);\n            scheduleContextWorkOnParentPath(\n              list.return,\n              renderLanes,\n              workInProgress\n            );\n            forcePropagateEntireTree || (nextFiber = null);\n            break a;\n          }\n        list = dependency.next;\n      }\n    } else if (18 === fiber.tag) {\n      nextFiber = fiber.return;\n      if (null === nextFiber) throw Error(formatProdErrorMessage(341));\n      nextFiber.lanes |= renderLanes;\n      list = nextFiber.alternate;\n      null !== list && (list.lanes |= renderLanes);\n      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n      nextFiber = null;\n    } else nextFiber = fiber.child;\n    if (null !== nextFiber) nextFiber.return = fiber;\n    else\n      for (nextFiber = fiber; null !== nextFiber; ) {\n        if (nextFiber === workInProgress) {\n          nextFiber = null;\n          break;\n        }\n        fiber = nextFiber.sibling;\n        if (null !== fiber) {\n          fiber.return = nextFiber.return;\n          nextFiber = fiber;\n          break;\n        }\n        nextFiber = nextFiber.return;\n      }\n    fiber = nextFiber;\n  }\n}\nfunction propagateParentContextChanges(\n  current,\n  workInProgress,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  current = null;\n  for (\n    var parent = workInProgress, isInsidePropagationBailout = !1;\n    null !== parent;\n\n  ) {\n    if (!isInsidePropagationBailout)\n      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n      else if (0 !== (parent.flags & 262144)) break;\n    if (10 === parent.tag) {\n      var currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent = currentParent.memoizedProps;\n      if (null !== currentParent) {\n        var context = parent.type;\n        objectIs(parent.pendingProps.value, currentParent.value) ||\n          (null !== current ? current.push(context) : (current = [context]));\n      }\n    } else if (parent === hostTransitionProviderCursor.current) {\n      currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent.memoizedState.memoizedState !==\n        parent.memoizedState.memoizedState &&\n        (null !== current\n          ? current.push(HostTransitionContext)\n          : (current = [HostTransitionContext]));\n    }\n    parent = parent.return;\n  }\n  null !== current &&\n    propagateContextChanges(\n      workInProgress,\n      current,\n      renderLanes,\n      forcePropagateEntireTree\n    );\n  workInProgress.flags |= 262144;\n}\nfunction checkIfContextChanged(currentDependencies) {\n  for (\n    currentDependencies = currentDependencies.firstContext;\n    null !== currentDependencies;\n\n  ) {\n    if (\n      !objectIs(\n        currentDependencies.context._currentValue,\n        currentDependencies.memoizedValue\n      )\n    )\n      return !0;\n    currentDependencies = currentDependencies.next;\n  }\n  return !1;\n}\nfunction prepareToReadContext(workInProgress) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  workInProgress = workInProgress.dependencies;\n  null !== workInProgress && (workInProgress.firstContext = null);\n}\nfunction readContext(context) {\n  return readContextForConsumer(currentlyRenderingFiber, context);\n}\nfunction readContextDuringReconciliation(consumer, context) {\n  null === currentlyRenderingFiber && prepareToReadContext(consumer);\n  return readContextForConsumer(consumer, context);\n}\nfunction readContextForConsumer(consumer, context) {\n  var value = context._currentValue;\n  context = { context: context, memoizedValue: value, next: null };\n  if (null === lastContextDependency) {\n    if (null === consumer) throw Error(formatProdErrorMessage(308));\n    lastContextDependency = context;\n    consumer.dependencies = { lanes: 0, firstContext: context };\n    consumer.flags |= 524288;\n  } else lastContextDependency = lastContextDependency.next = context;\n  return value;\n}\nvar hasForceUpdate = !1;\nfunction initializeUpdateQueue(fiber) {\n  fiber.updateQueue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: { pending: null, lanes: 0, hiddenCallbacks: null },\n    callbacks: null\n  };\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  current = current.updateQueue;\n  workInProgress.updateQueue === current &&\n    (workInProgress.updateQueue = {\n      baseState: current.baseState,\n      firstBaseUpdate: current.firstBaseUpdate,\n      lastBaseUpdate: current.lastBaseUpdate,\n      shared: current.shared,\n      callbacks: null\n    });\n}\nfunction createUpdate(lane) {\n  return { lane: lane, tag: 0, payload: null, callback: null, next: null };\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n  if (null === updateQueue) return null;\n  updateQueue = updateQueue.shared;\n  if (0 !== (executionContext & 2)) {\n    var pending = updateQueue.pending;\n    null === pending\n      ? (update.next = update)\n      : ((update.next = pending.next), (pending.next = update));\n    updateQueue.pending = update;\n    update = getRootForUpdatedFiber(fiber);\n    markUpdateLaneFromFiberToRoot(fiber, null, lane);\n    return update;\n  }\n  enqueueUpdate$1(fiber, updateQueue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction entangleTransitions(root, fiber, lane) {\n  fiber = fiber.updateQueue;\n  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {\n    var queueLanes = fiber.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    fiber.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  var queue = workInProgress.updateQueue,\n    current = workInProgress.alternate;\n  if (\n    null !== current &&\n    ((current = current.updateQueue), queue === current)\n  ) {\n    var newFirst = null,\n      newLast = null;\n    queue = queue.firstBaseUpdate;\n    if (null !== queue) {\n      do {\n        var clone = {\n          lane: queue.lane,\n          tag: queue.tag,\n          payload: queue.payload,\n          callback: null,\n          next: null\n        };\n        null === newLast\n          ? (newFirst = newLast = clone)\n          : (newLast = newLast.next = clone);\n        queue = queue.next;\n      } while (null !== queue);\n      null === newLast\n        ? (newFirst = newLast = capturedUpdate)\n        : (newLast = newLast.next = capturedUpdate);\n    } else newFirst = newLast = capturedUpdate;\n    queue = {\n      baseState: current.baseState,\n      firstBaseUpdate: newFirst,\n      lastBaseUpdate: newLast,\n      shared: current.shared,\n      callbacks: current.callbacks\n    };\n    workInProgress.updateQueue = queue;\n    return;\n  }\n  workInProgress = queue.lastBaseUpdate;\n  null === workInProgress\n    ? (queue.firstBaseUpdate = capturedUpdate)\n    : (workInProgress.next = capturedUpdate);\n  queue.lastBaseUpdate = capturedUpdate;\n}\nvar didReadFromEntangledAsyncAction = !1;\nfunction suspendIfUpdateReadFromEntangledAsyncAction() {\n  if (didReadFromEntangledAsyncAction) {\n    var entangledActionThenable = currentEntangledActionThenable;\n    if (null !== entangledActionThenable) throw entangledActionThenable;\n  }\n}\nfunction processUpdateQueue(\n  workInProgress$jscomp$0,\n  props,\n  instance$jscomp$0,\n  renderLanes\n) {\n  didReadFromEntangledAsyncAction = !1;\n  var queue = workInProgress$jscomp$0.updateQueue;\n  hasForceUpdate = !1;\n  var firstBaseUpdate = queue.firstBaseUpdate,\n    lastBaseUpdate = queue.lastBaseUpdate,\n    pendingQueue = queue.shared.pending;\n  if (null !== pendingQueue) {\n    queue.shared.pending = null;\n    var lastPendingUpdate = pendingQueue,\n      firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    null === lastBaseUpdate\n      ? (firstBaseUpdate = firstPendingUpdate)\n      : (lastBaseUpdate.next = firstPendingUpdate);\n    lastBaseUpdate = lastPendingUpdate;\n    var current = workInProgress$jscomp$0.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      (pendingQueue = current.lastBaseUpdate),\n      pendingQueue !== lastBaseUpdate &&\n        (null === pendingQueue\n          ? (current.firstBaseUpdate = firstPendingUpdate)\n          : (pendingQueue.next = firstPendingUpdate),\n        (current.lastBaseUpdate = lastPendingUpdate)));\n  }\n  if (null !== firstBaseUpdate) {\n    var newState = queue.baseState;\n    lastBaseUpdate = 0;\n    current = firstPendingUpdate = lastPendingUpdate = null;\n    pendingQueue = firstBaseUpdate;\n    do {\n      var updateLane = pendingQueue.lane & -536870913,\n        isHiddenUpdate = updateLane !== pendingQueue.lane;\n      if (\n        isHiddenUpdate\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        0 !== updateLane &&\n          updateLane === currentEntangledLane &&\n          (didReadFromEntangledAsyncAction = !0);\n        null !== current &&\n          (current = current.next =\n            {\n              lane: 0,\n              tag: pendingQueue.tag,\n              payload: pendingQueue.payload,\n              callback: null,\n              next: null\n            });\n        a: {\n          var workInProgress = workInProgress$jscomp$0,\n            update = pendingQueue;\n          updateLane = props;\n          var instance = instance$jscomp$0;\n          switch (update.tag) {\n            case 1:\n              workInProgress = update.payload;\n              if ("function" === typeof workInProgress) {\n                newState = workInProgress.call(instance, newState, updateLane);\n                break a;\n              }\n              newState = workInProgress;\n              break a;\n            case 3:\n              workInProgress.flags = (workInProgress.flags & -65537) | 128;\n            case 0:\n              workInProgress = update.payload;\n              updateLane =\n                "function" === typeof workInProgress\n                  ? workInProgress.call(instance, newState, updateLane)\n                  : workInProgress;\n              if (null === updateLane || void 0 === updateLane) break a;\n              newState = assign({}, newState, updateLane);\n              break a;\n            case 2:\n              hasForceUpdate = !0;\n          }\n        }\n        updateLane = pendingQueue.callback;\n        null !== updateLane &&\n          ((workInProgress$jscomp$0.flags |= 64),\n          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),\n          (isHiddenUpdate = queue.callbacks),\n          null === isHiddenUpdate\n            ? (queue.callbacks = [updateLane])\n            : isHiddenUpdate.push(updateLane));\n      } else\n        (isHiddenUpdate = {\n          lane: updateLane,\n          tag: pendingQueue.tag,\n          payload: pendingQueue.payload,\n          callback: pendingQueue.callback,\n          next: null\n        }),\n          null === current\n            ? ((firstPendingUpdate = current = isHiddenUpdate),\n              (lastPendingUpdate = newState))\n            : (current = current.next = isHiddenUpdate),\n          (lastBaseUpdate |= updateLane);\n      pendingQueue = pendingQueue.next;\n      if (null === pendingQueue)\n        if (((pendingQueue = queue.shared.pending), null === pendingQueue))\n          break;\n        else\n          (isHiddenUpdate = pendingQueue),\n            (pendingQueue = isHiddenUpdate.next),\n            (isHiddenUpdate.next = null),\n            (queue.lastBaseUpdate = isHiddenUpdate),\n            (queue.shared.pending = null);\n    } while (1);\n    null === current && (lastPendingUpdate = newState);\n    queue.baseState = lastPendingUpdate;\n    queue.firstBaseUpdate = firstPendingUpdate;\n    queue.lastBaseUpdate = current;\n    null === firstBaseUpdate && (queue.shared.lanes = 0);\n    workInProgressRootSkippedLanes |= lastBaseUpdate;\n    workInProgress$jscomp$0.lanes = lastBaseUpdate;\n    workInProgress$jscomp$0.memoizedState = newState;\n  }\n}\nfunction callCallback(callback, context) {\n  if ("function" !== typeof callback)\n    throw Error(formatProdErrorMessage(191, callback));\n  callback.call(context);\n}\nfunction commitCallbacks(updateQueue, context) {\n  var callbacks = updateQueue.callbacks;\n  if (null !== callbacks)\n    for (\n      updateQueue.callbacks = null, updateQueue = 0;\n      updateQueue < callbacks.length;\n      updateQueue++\n    )\n      callCallback(callbacks[updateQueue], context);\n}\nfunction commitHookEffectListMount(flags, finishedWork) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          lastEffect = void 0;\n          var create = updateQueue.create,\n            inst = updateQueue.inst;\n          lastEffect = create();\n          inst.destroy = lastEffect;\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHookEffectListUnmount(\n  flags,\n  finishedWork,\n  nearestMountedAncestor$jscomp$0\n) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          var inst = updateQueue.inst,\n            destroy = inst.destroy;\n          if (void 0 !== destroy) {\n            inst.destroy = void 0;\n            lastEffect = finishedWork;\n            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;\n            try {\n              destroy();\n            } catch (error) {\n              captureCommitPhaseError(\n                lastEffect,\n                nearestMountedAncestor,\n                error\n              );\n            }\n          }\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitClassCallbacks(finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  if (null !== updateQueue) {\n    var instance = finishedWork.stateNode;\n    try {\n      commitCallbacks(updateQueue, instance);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\nfunction safelyCallComponentWillUnmount(\n  current,\n  nearestMountedAncestor,\n  instance\n) {\n  instance.props = resolveClassComponentProps(\n    current.type,\n    current.memoizedProps\n  );\n  instance.state = current.memoizedState;\n  try {\n    instance.componentWillUnmount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    var ref = current.ref;\n    if (null !== ref) {\n      var instance = current.stateNode;\n      switch (current.tag) {\n        case 26:\n        case 27:\n        case 5:\n          var instanceToUse = instance;\n          break;\n        default:\n          instanceToUse = instance;\n      }\n      "function" === typeof ref\n        ? (current.refCleanup = ref(instanceToUse))\n        : (ref.current = instanceToUse);\n    }\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref,\n    refCleanup = current.refCleanup;\n  if (null !== ref)\n    if ("function" === typeof refCleanup)\n      try {\n        refCleanup();\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      } finally {\n        (current.refCleanup = null),\n          (current = current.alternate),\n          null != current && (current.refCleanup = null);\n      }\n    else if ("function" === typeof ref)\n      try {\n        ref(null);\n      } catch (error$112) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error$112);\n      }\n    else ref.current = null;\n}\nfunction commitHostMount(finishedWork) {\n  var type = finishedWork.type,\n    props = finishedWork.memoizedProps,\n    instance = finishedWork.stateNode;\n  try {\n    a: switch (type) {\n      case "button":\n      case "input":\n      case "select":\n      case "textarea":\n        props.autoFocus && instance.focus();\n        break a;\n      case "img":\n        props.src\n          ? (instance.src = props.src)\n          : props.srcSet && (instance.srcset = props.srcSet);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHostUpdate(finishedWork, newProps, oldProps) {\n  try {\n    var domElement = finishedWork.stateNode;\n    updateProperties(domElement, finishedWork.type, oldProps, newProps);\n    domElement[internalPropsKey] = newProps;\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction isHostParent(fiber) {\n  return (\n    5 === fiber.tag ||\n    3 === fiber.tag ||\n    26 === fiber.tag ||\n    27 === fiber.tag ||\n    4 === fiber.tag\n  );\n}\nfunction getHostSibling(fiber) {\n  a: for (;;) {\n    for (; null === fiber.sibling; ) {\n      if (null === fiber.return || isHostParent(fiber.return)) return null;\n      fiber = fiber.return;\n    }\n    fiber.sibling.return = fiber.return;\n    for (\n      fiber = fiber.sibling;\n      5 !== fiber.tag &&\n      6 !== fiber.tag &&\n      27 !== fiber.tag &&\n      18 !== fiber.tag;\n\n    ) {\n      if (fiber.flags & 2) continue a;\n      if (null === fiber.child || 4 === fiber.tag) continue a;\n      else (fiber.child.return = fiber), (fiber = fiber.child);\n    }\n    if (!(fiber.flags & 2)) return fiber.stateNode;\n  }\n}\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before\n        ? 8 === parent.nodeType\n          ? parent.parentNode.insertBefore(node, before)\n          : parent.insertBefore(node, before)\n        : (8 === parent.nodeType\n            ? ((before = parent.parentNode), before.insertBefore(node, parent))\n            : ((before = parent), before.appendChild(node)),\n          (parent = parent._reactRootContainer),\n          (null !== parent && void 0 !== parent) ||\n            null !== before.onclick ||\n            (before.onclick = noop$1));\n  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))\n    for (\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        (node = node.sibling);\n}\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before ? parent.insertBefore(node, before) : parent.appendChild(node);\n  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))\n    for (\n      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);\n}\nvar offscreenSubtreeIsHidden = !1,\n  offscreenSubtreeWasHidden = !1,\n  needsFormReset = !1,\n  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,\n  nextEffect = null,\n  shouldFireAfterActiveInstanceBlur = !1;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  root = root.containerInfo;\n  eventsEnabled = _enabled;\n  root = getActiveElementDeep(root);\n  if (hasSelectionCapabilities(root)) {\n    if ("selectionStart" in root)\n      var JSCompiler_temp = {\n        start: root.selectionStart,\n        end: root.selectionEnd\n      };\n    else\n      a: {\n        JSCompiler_temp =\n          ((JSCompiler_temp = root.ownerDocument) &&\n            JSCompiler_temp.defaultView) ||\n          window;\n        var selection =\n          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\n        if (selection && 0 !== selection.rangeCount) {\n          JSCompiler_temp = selection.anchorNode;\n          var anchorOffset = selection.anchorOffset,\n            focusNode = selection.focusNode;\n          selection = selection.focusOffset;\n          try {\n            JSCompiler_temp.nodeType, focusNode.nodeType;\n          } catch (e$20) {\n            JSCompiler_temp = null;\n            break a;\n          }\n          var length = 0,\n            start = -1,\n            end = -1,\n            indexWithinAnchor = 0,\n            indexWithinFocus = 0,\n            node = root,\n            parentNode = null;\n          b: for (;;) {\n            for (var next; ; ) {\n              node !== JSCompiler_temp ||\n                (0 !== anchorOffset && 3 !== node.nodeType) ||\n                (start = length + anchorOffset);\n              node !== focusNode ||\n                (0 !== selection && 3 !== node.nodeType) ||\n                (end = length + selection);\n              3 === node.nodeType && (length += node.nodeValue.length);\n              if (null === (next = node.firstChild)) break;\n              parentNode = node;\n              node = next;\n            }\n            for (;;) {\n              if (node === root) break b;\n              parentNode === JSCompiler_temp &&\n                ++indexWithinAnchor === anchorOffset &&\n                (start = length);\n              parentNode === focusNode &&\n                ++indexWithinFocus === selection &&\n                (end = length);\n              if (null !== (next = node.nextSibling)) break;\n              node = parentNode;\n              parentNode = node.parentNode;\n            }\n            node = next;\n          }\n          JSCompiler_temp =\n            -1 === start || -1 === end ? null : { start: start, end: end };\n        } else JSCompiler_temp = null;\n      }\n    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };\n  } else JSCompiler_temp = null;\n  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };\n  _enabled = !1;\n  for (nextEffect = firstChild; null !== nextEffect; )\n    if (\n      ((firstChild = nextEffect),\n      (root = firstChild.child),\n      0 !== (firstChild.subtreeFlags & 1028) && null !== root)\n    )\n      (root.return = firstChild), (nextEffect = root);\n    else\n      for (; null !== nextEffect; ) {\n        firstChild = nextEffect;\n        focusNode = firstChild.alternate;\n        root = firstChild.flags;\n        switch (firstChild.tag) {\n          case 0:\n            break;\n          case 11:\n          case 15:\n            break;\n          case 1:\n            if (0 !== (root & 1024) && null !== focusNode) {\n              root = void 0;\n              JSCompiler_temp = firstChild;\n              anchorOffset = focusNode.memoizedProps;\n              focusNode = focusNode.memoizedState;\n              selection = JSCompiler_temp.stateNode;\n              try {\n                var resolvedPrevProps = resolveClassComponentProps(\n                  JSCompiler_temp.type,\n                  anchorOffset,\n                  JSCompiler_temp.elementType === JSCompiler_temp.type\n                );\n                root = selection.getSnapshotBeforeUpdate(\n                  resolvedPrevProps,\n                  focusNode\n                );\n                selection.__reactInternalSnapshotBeforeUpdate = root;\n              } catch (error) {\n                captureCommitPhaseError(\n                  JSCompiler_temp,\n                  JSCompiler_temp.return,\n                  error\n                );\n              }\n            }\n            break;\n          case 3:\n            if (0 !== (root & 1024))\n              if (\n                ((root = firstChild.stateNode.containerInfo),\n                (JSCompiler_temp = root.nodeType),\n                9 === JSCompiler_temp)\n              )\n                clearContainerSparingly(root);\n              else if (1 === JSCompiler_temp)\n                switch (root.nodeName) {\n                  case "HEAD":\n                  case "HTML":\n                  case "BODY":\n                    clearContainerSparingly(root);\n                    break;\n                  default:\n                    root.textContent = "";\n                }\n            break;\n          case 5:\n          case 26:\n          case 27:\n          case 6:\n          case 4:\n          case 17:\n            break;\n          default:\n            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));\n        }\n        root = firstChild.sibling;\n        if (null !== root) {\n          root.return = firstChild.return;\n          nextEffect = root;\n          break;\n        }\n        nextEffect = firstChild.return;\n      }\n  resolvedPrevProps = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = !1;\n  return resolvedPrevProps;\n}\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitHookEffectListMount(5, finishedWork);\n      break;\n    case 1:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (flags & 4)\n        if (((finishedRoot = finishedWork.stateNode), null === current))\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        else {\n          var prevProps = resolveClassComponentProps(\n            finishedWork.type,\n            current.memoizedProps\n          );\n          current = current.memoizedState;\n          try {\n            finishedRoot.componentDidUpdate(\n              prevProps,\n              current,\n              finishedRoot.__reactInternalSnapshotBeforeUpdate\n            );\n          } catch (error$111) {\n            captureCommitPhaseError(\n              finishedWork,\n              finishedWork.return,\n              error$111\n            );\n          }\n        }\n      flags & 64 && commitClassCallbacks(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {\n        finishedRoot = null;\n        if (null !== finishedWork.child)\n          switch (finishedWork.child.tag) {\n            case 27:\n            case 5:\n              finishedRoot = finishedWork.child.stateNode;\n              break;\n            case 1:\n              finishedRoot = finishedWork.child.stateNode;\n          }\n        try {\n          commitCallbacks(flags, finishedRoot);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 26:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 27:\n    case 5:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      null === current && flags & 4 && commitHostMount(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 12:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      break;\n    case 22:\n      prevProps =\n        null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n      if (!prevProps) {\n        current =\n          (null !== current && null !== current.memoizedState) ||\n          offscreenSubtreeWasHidden;\n        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,\n          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n        offscreenSubtreeIsHidden = prevProps;\n        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden\n          ? recursivelyTraverseReappearLayoutEffects(\n              finishedRoot,\n              finishedWork,\n              0 !== (finishedWork.subtreeFlags & 8772)\n            )\n          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      }\n      flags & 512 &&\n        ("manual" === finishedWork.memoizedProps.mode\n          ? safelyAttachRef(finishedWork, finishedWork.return)\n          : safelyDetachRef(finishedWork, finishedWork.return));\n      break;\n    default:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n  }\n}\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n  null !== alternate &&\n    ((fiber.alternate = null), detachFiberAfterEffects(alternate));\n  fiber.child = null;\n  fiber.deletions = null;\n  fiber.sibling = null;\n  5 === fiber.tag &&\n    ((alternate = fiber.stateNode),\n    null !== alternate && detachDeletedInstance(alternate));\n  fiber.stateNode = null;\n  fiber.return = null;\n  fiber.dependencies = null;\n  fiber.memoizedProps = null;\n  fiber.memoizedState = null;\n  fiber.pendingProps = null;\n  fiber.stateNode = null;\n  fiber.updateQueue = null;\n}\nvar hostParent = null,\n  hostParentIsContainer = !1;\nfunction recursivelyTraverseDeletionEffects(\n  finishedRoot,\n  nearestMountedAncestor,\n  parent\n) {\n  for (parent = parent.child; null !== parent; )\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),\n      (parent = parent.sibling);\n}\nfunction commitDeletionEffectsOnFiber(\n  finishedRoot,\n  nearestMountedAncestor,\n  deletedFiber\n) {\n  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n    } catch (err) {}\n  switch (deletedFiber.tag) {\n    case 26:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      deletedFiber.memoizedState\n        ? deletedFiber.memoizedState.count--\n        : deletedFiber.stateNode &&\n          ((deletedFiber = deletedFiber.stateNode),\n          deletedFiber.parentNode.removeChild(deletedFiber));\n      break;\n    case 27:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      var prevHostParent = hostParent,\n        prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = deletedFiber.stateNode;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      deletedFiber = deletedFiber.stateNode;\n      for (\n        nearestMountedAncestor = deletedFiber.attributes;\n        nearestMountedAncestor.length;\n\n      )\n        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);\n      detachDeletedInstance(deletedFiber);\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 5:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n    case 6:\n      prevHostParentIsContainer = hostParent;\n      var prevHostParentIsContainer$119 = hostParentIsContainer;\n      hostParent = null;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParentIsContainer;\n      hostParentIsContainer = prevHostParentIsContainer$119;\n      if (null !== hostParent)\n        if (hostParentIsContainer)\n          try {\n            (finishedRoot = hostParent),\n              (prevHostParent = deletedFiber.stateNode),\n              8 === finishedRoot.nodeType\n                ? finishedRoot.parentNode.removeChild(prevHostParent)\n                : finishedRoot.removeChild(prevHostParent);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n        else\n          try {\n            hostParent.removeChild(deletedFiber.stateNode);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n      break;\n    case 18:\n      null !== hostParent &&\n        (hostParentIsContainer\n          ? ((nearestMountedAncestor = hostParent),\n            (deletedFiber = deletedFiber.stateNode),\n            8 === nearestMountedAncestor.nodeType\n              ? clearSuspenseBoundary(\n                  nearestMountedAncestor.parentNode,\n                  deletedFiber\n                )\n              : 1 === nearestMountedAncestor.nodeType &&\n                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),\n            retryIfBlockedOn(nearestMountedAncestor))\n          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n      break;\n    case 4:\n      prevHostParent = hostParent;\n      prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = deletedFiber.stateNode.containerInfo;\n      hostParentIsContainer = !0;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 1:\n      offscreenSubtreeWasHidden ||\n        (safelyDetachRef(deletedFiber, nearestMountedAncestor),\n        (prevHostParent = deletedFiber.stateNode),\n        "function" === typeof prevHostParent.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            deletedFiber,\n            nearestMountedAncestor,\n            prevHostParent\n          ));\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 21:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 22:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      offscreenSubtreeWasHidden =\n        (prevHostParent = offscreenSubtreeWasHidden) ||\n        null !== deletedFiber.memoizedState;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      offscreenSubtreeWasHidden = prevHostParent;\n      break;\n    default:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n  }\n}\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (\n    null === finishedWork.memoizedState &&\n    ((finishedRoot = finishedWork.alternate),\n    null !== finishedRoot &&\n      ((finishedRoot = finishedRoot.memoizedState),\n      null !== finishedRoot &&\n        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))\n  )\n    try {\n      retryIfBlockedOn(finishedRoot);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n}\nfunction getRetryCache(finishedWork) {\n  switch (finishedWork.tag) {\n    case 13:\n    case 19:\n      var retryCache = finishedWork.stateNode;\n      null === retryCache &&\n        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n      return retryCache;\n    case 22:\n      return (\n        (finishedWork = finishedWork.stateNode),\n        (retryCache = finishedWork._retryCache),\n        null === retryCache &&\n          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),\n        retryCache\n      );\n    default:\n      throw Error(formatProdErrorMessage(435, finishedWork.tag));\n  }\n}\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\n  var retryCache = getRetryCache(finishedWork);\n  wakeables.forEach(function (wakeable) {\n    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n    retryCache.has(wakeable) ||\n      (retryCache.add(wakeable), wakeable.then(retry, retry));\n  });\n}\nfunction recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (null !== deletions)\n    for (var i = 0; i < deletions.length; i++) {\n      var childToDelete = deletions[i],\n        root = root$jscomp$0,\n        returnFiber = parentFiber,\n        parent = returnFiber;\n      a: for (; null !== parent; ) {\n        switch (parent.tag) {\n          case 27:\n          case 5:\n            hostParent = parent.stateNode;\n            hostParentIsContainer = !1;\n            break a;\n          case 3:\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = !0;\n            break a;\n          case 4:\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = !0;\n            break a;\n        }\n        parent = parent.return;\n      }\n      if (null === hostParent) throw Error(formatProdErrorMessage(160));\n      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);\n      hostParent = null;\n      hostParentIsContainer = !1;\n      root = childToDelete.alternate;\n      null !== root && (root.return = null);\n      childToDelete.return = null;\n    }\n  if (parentFiber.subtreeFlags & 13878)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),\n        (parentFiber = parentFiber.sibling);\n}\nvar currentHoistableRoot = null;\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\n  var current = finishedWork.alternate,\n    flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),\n        commitHookEffectListMount(3, finishedWork),\n        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));\n      break;\n    case 1:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      flags & 64 &&\n        offscreenSubtreeIsHidden &&\n        ((finishedWork = finishedWork.updateQueue),\n        null !== finishedWork &&\n          ((flags = finishedWork.callbacks),\n          null !== flags &&\n            ((current = finishedWork.shared.hiddenCallbacks),\n            (finishedWork.shared.hiddenCallbacks =\n              null === current ? flags : current.concat(flags)))));\n      break;\n    case 26:\n      var hoistableRoot = currentHoistableRoot;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (flags & 4) {\n        var currentResource = null !== current ? current.memoizedState : null;\n        flags = finishedWork.memoizedState;\n        if (null === current)\n          if (null === flags)\n            if (null === finishedWork.stateNode) {\n              a: {\n                flags = finishedWork.type;\n                current = finishedWork.memoizedProps;\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n                b: switch (flags) {\n                  case "title":\n                    currentResource =\n                      hoistableRoot.getElementsByTagName("title")[0];\n                    if (\n                      !currentResource ||\n                      currentResource[internalHoistableMarker] ||\n                      currentResource[internalInstanceKey] ||\n                      "http://www.w3.org/2000/svg" ===\n                        currentResource.namespaceURI ||\n                      currentResource.hasAttribute("itemprop")\n                    )\n                      (currentResource = hoistableRoot.createElement(flags)),\n                        hoistableRoot.head.insertBefore(\n                          currentResource,\n                          hoistableRoot.querySelector("head > title")\n                        );\n                    setInitialProperties(currentResource, flags, current);\n                    currentResource[internalInstanceKey] = finishedWork;\n                    markNodeAsHoistable(currentResource);\n                    flags = currentResource;\n                    break a;\n                  case "link":\n                    var maybeNodes = getHydratableHoistableCache(\n                      "link",\n                      "href",\n                      hoistableRoot\n                    ).get(flags + (current.href || ""));\n                    if (maybeNodes)\n                      for (var i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute("href") ===\n                            (null == current.href ? null : current.href) &&\n                            currentResource.getAttribute("rel") ===\n                              (null == current.rel ? null : current.rel) &&\n                            currentResource.getAttribute("title") ===\n                              (null == current.title ? null : current.title) &&\n                            currentResource.getAttribute("crossorigin") ===\n                              (null == current.crossOrigin\n                                ? null\n                                : current.crossOrigin))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  case "meta":\n                    if (\n                      (maybeNodes = getHydratableHoistableCache(\n                        "meta",\n                        "content",\n                        hoistableRoot\n                      ).get(flags + (current.content || "")))\n                    )\n                      for (i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute("content") ===\n                            (null == current.content\n                              ? null\n                              : "" + current.content) &&\n                            currentResource.getAttribute("name") ===\n                              (null == current.name ? null : current.name) &&\n                            currentResource.getAttribute("property") ===\n                              (null == current.property\n                                ? null\n                                : current.property) &&\n                            currentResource.getAttribute("http-equiv") ===\n                              (null == current.httpEquiv\n                                ? null\n                                : current.httpEquiv) &&\n                            currentResource.getAttribute("charset") ===\n                              (null == current.charSet\n                                ? null\n                                : current.charSet))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  default:\n                    throw Error(formatProdErrorMessage(468, flags));\n                }\n                currentResource[internalInstanceKey] = finishedWork;\n                markNodeAsHoistable(currentResource);\n                flags = currentResource;\n              }\n              finishedWork.stateNode = flags;\n            } else\n              mountHoistable(\n                hoistableRoot,\n                finishedWork.type,\n                finishedWork.stateNode\n              );\n          else\n            finishedWork.stateNode = acquireResource(\n              hoistableRoot,\n              flags,\n              finishedWork.memoizedProps\n            );\n        else\n          currentResource !== flags\n            ? (null === currentResource\n                ? null !== current.stateNode &&\n                  ((current = current.stateNode),\n                  current.parentNode.removeChild(current))\n                : currentResource.count--,\n              null === flags\n                ? mountHoistable(\n                    hoistableRoot,\n                    finishedWork.type,\n                    finishedWork.stateNode\n                  )\n                : acquireResource(\n                    hoistableRoot,\n                    flags,\n                    finishedWork.memoizedProps\n                  ))\n            : null === flags &&\n              null !== finishedWork.stateNode &&\n              commitHostUpdate(\n                finishedWork,\n                finishedWork.memoizedProps,\n                current.memoizedProps\n              );\n      }\n      break;\n    case 27:\n      if (flags & 4 && null === finishedWork.alternate) {\n        hoistableRoot = finishedWork.stateNode;\n        currentResource = finishedWork.memoizedProps;\n        try {\n          for (var node = hoistableRoot.firstChild; node; ) {\n            var nextNode = node.nextSibling,\n              nodeName = node.nodeName;\n            node[internalHoistableMarker] ||\n              "HEAD" === nodeName ||\n              "BODY" === nodeName ||\n              "SCRIPT" === nodeName ||\n              "STYLE" === nodeName ||\n              ("LINK" === nodeName &&\n                "stylesheet" === node.rel.toLowerCase()) ||\n              hoistableRoot.removeChild(node);\n            node = nextNode;\n          }\n          for (\n            var type = finishedWork.type, attributes = hoistableRoot.attributes;\n            attributes.length;\n\n          )\n            hoistableRoot.removeAttributeNode(attributes[0]);\n          setInitialProperties(hoistableRoot, type, currentResource);\n          hoistableRoot[internalInstanceKey] = finishedWork;\n          hoistableRoot[internalPropsKey] = currentResource;\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n    case 5:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (finishedWork.flags & 32) {\n        hoistableRoot = finishedWork.stateNode;\n        try {\n          setTextContent(hoistableRoot, "");\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      flags & 4 &&\n        null != finishedWork.stateNode &&\n        ((hoistableRoot = finishedWork.memoizedProps),\n        commitHostUpdate(\n          finishedWork,\n          hoistableRoot,\n          null !== current ? current.memoizedProps : hoistableRoot\n        ));\n      flags & 1024 && (needsFormReset = !0);\n      break;\n    case 6:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4) {\n        if (null === finishedWork.stateNode)\n          throw Error(formatProdErrorMessage(162));\n        flags = finishedWork.memoizedProps;\n        current = finishedWork.stateNode;\n        try {\n          current.nodeValue = flags;\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 3:\n      tagCaches = null;\n      hoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(root.containerInfo);\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      currentHoistableRoot = hoistableRoot;\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)\n        try {\n          retryIfBlockedOn(root.containerInfo);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      needsFormReset &&\n        ((needsFormReset = !1), recursivelyResetForms(finishedWork));\n      break;\n    case 4:\n      flags = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(\n        finishedWork.stateNode.containerInfo\n      );\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      currentHoistableRoot = flags;\n      break;\n    case 12:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      finishedWork.child.flags & 8192 &&\n        (null !== finishedWork.memoizedState) !==\n          (null !== current && null !== current.memoizedState) &&\n        (globalMostRecentFallbackTime = now());\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 22:\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      node = null !== finishedWork.memoizedState;\n      nextNode = null !== current && null !== current.memoizedState;\n      nodeName = offscreenSubtreeIsHidden;\n      type = offscreenSubtreeWasHidden;\n      offscreenSubtreeIsHidden = nodeName || node;\n      offscreenSubtreeWasHidden = type || nextNode;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      offscreenSubtreeWasHidden = type;\n      offscreenSubtreeIsHidden = nodeName;\n      commitReconciliationEffects(finishedWork);\n      root = finishedWork.stateNode;\n      root._current = finishedWork;\n      root._visibility &= -3;\n      root._visibility |= root._pendingVisibility & 2;\n      if (\n        flags & 8192 &&\n        ((root._visibility = node\n          ? root._visibility & -2\n          : root._visibility | 1),\n        node &&\n          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),\n          null === current ||\n            nextNode ||\n            root ||\n            recursivelyTraverseDisappearLayoutEffects(finishedWork)),\n        null === finishedWork.memoizedProps ||\n          "manual" !== finishedWork.memoizedProps.mode)\n      )\n        a: for (current = null, root = finishedWork; ; ) {\n          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {\n            if (null === current) {\n              nextNode = current = root;\n              try {\n                if (((hoistableRoot = nextNode.stateNode), node))\n                  (currentResource = hoistableRoot.style),\n                    "function" === typeof currentResource.setProperty\n                      ? currentResource.setProperty(\n                          "display",\n                          "none",\n                          "important"\n                        )\n                      : (currentResource.display = "none");\n                else {\n                  maybeNodes = nextNode.stateNode;\n                  i = nextNode.memoizedProps.style;\n                  var display =\n                    void 0 !== i && null !== i && i.hasOwnProperty("display")\n                      ? i.display\n                      : null;\n                  maybeNodes.style.display =\n                    null == display || "boolean" === typeof display\n                      ? ""\n                      : ("" + display).trim();\n                }\n              } catch (error) {\n                captureCommitPhaseError(nextNode, nextNode.return, error);\n              }\n            }\n          } else if (6 === root.tag) {\n            if (null === current) {\n              nextNode = root;\n              try {\n                nextNode.stateNode.nodeValue = node\n                  ? ""\n                  : nextNode.memoizedProps;\n              } catch (error) {\n                captureCommitPhaseError(nextNode, nextNode.return, error);\n              }\n            }\n          } else if (\n            ((22 !== root.tag && 23 !== root.tag) ||\n              null === root.memoizedState ||\n              root === finishedWork) &&\n            null !== root.child\n          ) {\n            root.child.return = root;\n            root = root.child;\n            continue;\n          }\n          if (root === finishedWork) break a;\n          for (; null === root.sibling; ) {\n            if (null === root.return || root.return === finishedWork) break a;\n            current === root && (current = null);\n            root = root.return;\n          }\n          current === root && (current = null);\n          root.sibling.return = root.return;\n          root = root.sibling;\n        }\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((current = flags.retryQueue),\n          null !== current &&\n            ((flags.retryQueue = null),\n            attachSuspenseRetryListeners(finishedWork, current))));\n      break;\n    case 19:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 21:\n      break;\n    default:\n      recursivelyTraverseMutationEffects(root, finishedWork),\n        commitReconciliationEffects(finishedWork);\n  }\n}\nfunction commitReconciliationEffects(finishedWork) {\n  var flags = finishedWork.flags;\n  if (flags & 2) {\n    try {\n      if (27 !== finishedWork.tag) {\n        a: {\n          for (var parent = finishedWork.return; null !== parent; ) {\n            if (isHostParent(parent)) {\n              var JSCompiler_inline_result = parent;\n              break a;\n            }\n            parent = parent.return;\n          }\n          throw Error(formatProdErrorMessage(160));\n        }\n        switch (JSCompiler_inline_result.tag) {\n          case 27:\n            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,\n              before = getHostSibling(finishedWork);\n            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);\n            break;\n          case 5:\n            var parent$113 = JSCompiler_inline_result.stateNode;\n            JSCompiler_inline_result.flags & 32 &&\n              (setTextContent(parent$113, ""),\n              (JSCompiler_inline_result.flags &= -33));\n            var before$114 = getHostSibling(finishedWork);\n            insertOrAppendPlacementNode(finishedWork, before$114, parent$113);\n            break;\n          case 3:\n          case 4:\n            var parent$115 = JSCompiler_inline_result.stateNode.containerInfo,\n              before$116 = getHostSibling(finishedWork);\n            insertOrAppendPlacementNodeIntoContainer(\n              finishedWork,\n              before$116,\n              parent$115\n            );\n            break;\n          default:\n            throw Error(formatProdErrorMessage(161));\n        }\n      }\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    finishedWork.flags &= -3;\n  }\n  flags & 4096 && (finishedWork.flags &= -4097);\n}\nfunction recursivelyResetForms(parentFiber) {\n  if (parentFiber.subtreeFlags & 1024)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var fiber = parentFiber;\n      recursivelyResetForms(fiber);\n      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();\n      parentFiber = parentFiber.sibling;\n    }\n}\nfunction recursivelyTraverseLayoutEffects(root, parentFiber) {\n  if (parentFiber.subtreeFlags & 8772)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedWork = parentFiber;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 14:\n      case 15:\n        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 1:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        var instance = finishedWork.stateNode;\n        "function" === typeof instance.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            finishedWork,\n            finishedWork.return,\n            instance\n          );\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 26:\n      case 27:\n      case 5:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 22:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      default:\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseReappearLayoutEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var current = parentFiber.alternate,\n      finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(4, finishedWork);\n        break;\n      case 1:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        current = finishedWork;\n        finishedRoot = current.stateNode;\n        if ("function" === typeof finishedRoot.componentDidMount)\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        current = finishedWork;\n        finishedRoot = current.updateQueue;\n        if (null !== finishedRoot) {\n          var instance = current.stateNode;\n          try {\n            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;\n            if (null !== hiddenCallbacks)\n              for (\n                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;\n                finishedRoot < hiddenCallbacks.length;\n                finishedRoot++\n              )\n                callCallback(hiddenCallbacks[finishedRoot], instance);\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        }\n        includeWorkInProgressEffects &&\n          flags & 64 &&\n          commitClassCallbacks(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 26:\n      case 27:\n      case 5:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          null === current &&\n          flags & 4 &&\n          commitHostMount(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 12:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        break;\n      case 13:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 4 &&\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        break;\n      case 22:\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseReappearLayoutEffects(\n            finishedRoot,\n            finishedWork,\n            includeWorkInProgressEffects\n          );\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      default:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitOffscreenPassiveMountEffects(current, finishedWork) {\n  var previousCache = null;\n  null !== current &&\n    null !== current.memoizedState &&\n    null !== current.memoizedState.cachePool &&\n    (previousCache = current.memoizedState.cachePool.pool);\n  current = null;\n  null !== finishedWork.memoizedState &&\n    null !== finishedWork.memoizedState.cachePool &&\n    (current = finishedWork.memoizedState.cachePool.pool);\n  current !== previousCache &&\n    (null != current && current.refCount++,\n    null != previousCache && releaseCache(previousCache));\n}\nfunction commitCachePassiveMountEffect(current, finishedWork) {\n  current = null;\n  null !== finishedWork.alternate &&\n    (current = finishedWork.alternate.memoizedState.cache);\n  finishedWork = finishedWork.memoizedState.cache;\n  finishedWork !== current &&\n    (finishedWork.refCount++, null != current && releaseCache(current));\n}\nfunction recursivelyTraversePassiveMountEffects(\n  root,\n  parentFiber,\n  committedLanes,\n  committedTransitions\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveMountOnFiber(\n        root,\n        parentFiber,\n        committedLanes,\n        committedTransitions\n      ),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveMountOnFiber(\n  finishedRoot,\n  finishedWork,\n  committedLanes,\n  committedTransitions\n) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 && commitHookEffectListMount(9, finishedWork);\n      break;\n    case 3:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        ((finishedRoot = null),\n        null !== finishedWork.alternate &&\n          (finishedRoot = finishedWork.alternate.memoizedState.cache),\n        (finishedWork = finishedWork.memoizedState.cache),\n        finishedWork !== finishedRoot &&\n          (finishedWork.refCount++,\n          null != finishedRoot && releaseCache(finishedRoot)));\n      break;\n    case 12:\n      if (flags & 2048) {\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n        finishedRoot = finishedWork.stateNode;\n        try {\n          var _finishedWork$memoize2 = finishedWork.memoizedProps,\n            id = _finishedWork$memoize2.id,\n            onPostCommit = _finishedWork$memoize2.onPostCommit;\n          "function" === typeof onPostCommit &&\n            onPostCommit(\n              id,\n              null === finishedWork.alternate ? "mount" : "update",\n              finishedRoot.passiveEffectDuration,\n              -0\n            );\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      } else\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n      break;\n    case 23:\n      break;\n    case 22:\n      _finishedWork$memoize2 = finishedWork.stateNode;\n      null !== finishedWork.memoizedState\n        ? _finishedWork$memoize2._visibility & 4\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)\n        : _finishedWork$memoize2._visibility & 4\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : ((_finishedWork$memoize2._visibility |= 4),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              0 !== (finishedWork.subtreeFlags & 10256)\n            ));\n      flags & 2048 &&\n        commitOffscreenPassiveMountEffects(\n          finishedWork.alternate,\n          finishedWork\n        );\n      break;\n    case 24:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n  }\n}\nfunction recursivelyTraverseReconnectPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  committedLanes$jscomp$0,\n  committedTransitions$jscomp$0,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      committedLanes = committedLanes$jscomp$0,\n      committedTransitions = committedTransitions$jscomp$0,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(8, finishedWork);\n        break;\n      case 23:\n        break;\n      case 22:\n        var instance = finishedWork.stateNode;\n        null !== finishedWork.memoizedState\n          ? instance._visibility & 4\n            ? recursivelyTraverseReconnectPassiveEffects(\n                finishedRoot,\n                finishedWork,\n                committedLanes,\n                committedTransitions,\n                includeWorkInProgressEffects\n              )\n            : recursivelyTraverseAtomicPassiveEffects(\n                finishedRoot,\n                finishedWork\n              )\n          : ((instance._visibility |= 4),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              includeWorkInProgressEffects\n            ));\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitOffscreenPassiveMountEffects(\n            finishedWork.alternate,\n            finishedWork\n          );\n        break;\n      case 24:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n        break;\n      default:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseAtomicPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var finishedRoot = finishedRoot$jscomp$0,\n        finishedWork = parentFiber,\n        flags = finishedWork.flags;\n      switch (finishedWork.tag) {\n        case 22:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitOffscreenPassiveMountEffects(\n              finishedWork.alternate,\n              finishedWork\n            );\n          break;\n        case 24:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n          break;\n        default:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n      }\n      parentFiber = parentFiber.sibling;\n    }\n}\nvar suspenseyCommitFlag = 8192;\nfunction recursivelyAccumulateSuspenseyCommit(parentFiber) {\n  if (parentFiber.subtreeFlags & suspenseyCommitFlag)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      accumulateSuspenseyCommitOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction accumulateSuspenseyCommitOnFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      fiber.flags & suspenseyCommitFlag &&\n        null !== fiber.memoizedState &&\n        suspendResource(\n          currentHoistableRoot,\n          fiber.memoizedState,\n          fiber.memoizedProps\n        );\n      break;\n    case 5:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      break;\n    case 3:\n    case 4:\n      var previousHoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      currentHoistableRoot = previousHoistableRoot;\n      break;\n    case 22:\n      null === fiber.memoizedState &&\n        ((previousHoistableRoot = fiber.alternate),\n        null !== previousHoistableRoot &&\n        null !== previousHoistableRoot.memoizedState\n          ? ((previousHoistableRoot = suspenseyCommitFlag),\n            (suspenseyCommitFlag = 16777216),\n            recursivelyAccumulateSuspenseyCommit(fiber),\n            (suspenseyCommitFlag = previousHoistableRoot))\n          : recursivelyAccumulateSuspenseyCommit(fiber));\n      break;\n    default:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n  }\n}\nfunction detachAlternateSiblings(parentFiber) {\n  var previousFiber = parentFiber.alternate;\n  if (\n    null !== previousFiber &&\n    ((parentFiber = previousFiber.child), null !== parentFiber)\n  ) {\n    previousFiber.child = null;\n    do\n      (previousFiber = parentFiber.sibling),\n        (parentFiber.sibling = null),\n        (parentFiber = previousFiber);\n    while (null !== parentFiber);\n  }\n}\nfunction recursivelyTraversePassiveUnmountEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveUnmountOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      finishedWork.flags & 2048 &&\n        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 12:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 22:\n      var instance = finishedWork.stateNode;\n      null !== finishedWork.memoizedState &&\n      instance._visibility & 4 &&\n      (null === finishedWork.return || 13 !== finishedWork.return.tag)\n        ? ((instance._visibility &= -5),\n          recursivelyTraverseDisconnectPassiveEffects(finishedWork))\n        : recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n  }\n}\nfunction recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    deletions = parentFiber;\n    switch (deletions.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, deletions, deletions.return);\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n        break;\n      case 22:\n        i = deletions.stateNode;\n        i._visibility & 4 &&\n          ((i._visibility &= -5),\n          recursivelyTraverseDisconnectPassiveEffects(deletions));\n        break;\n      default:\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n  deletedSubtreeRoot,\n  nearestMountedAncestor\n) {\n  for (; null !== nextEffect; ) {\n    var fiber = nextEffect;\n    switch (fiber.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);\n        break;\n      case 23:\n      case 22:\n        if (\n          null !== fiber.memoizedState &&\n          null !== fiber.memoizedState.cachePool\n        ) {\n          var cache = fiber.memoizedState.cachePool.pool;\n          null != cache && cache.refCount++;\n        }\n        break;\n      case 24:\n        releaseCache(fiber.memoizedState.cache);\n    }\n    cache = fiber.child;\n    if (null !== cache) (cache.return = fiber), (nextEffect = cache);\n    else\n      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {\n        cache = nextEffect;\n        var sibling = cache.sibling,\n          returnFiber = cache.return;\n        detachFiberAfterEffects(cache);\n        if (cache === fiber) {\n          nextEffect = null;\n          break a;\n        }\n        if (null !== sibling) {\n          sibling.return = returnFiber;\n          nextEffect = sibling;\n          break a;\n        }\n        nextEffect = returnFiber;\n      }\n  }\n}\nfunction FiberNode(tag, pendingProps, key, mode) {\n  this.tag = tag;\n  this.key = key;\n  this.sibling =\n    this.child =\n    this.return =\n    this.stateNode =\n    this.type =\n    this.elementType =\n      null;\n  this.index = 0;\n  this.refCleanup = this.ref = null;\n  this.pendingProps = pendingProps;\n  this.dependencies =\n    this.memoizedState =\n    this.updateQueue =\n    this.memoizedProps =\n      null;\n  this.mode = mode;\n  this.subtreeFlags = this.flags = 0;\n  this.deletions = null;\n  this.childLanes = this.lanes = 0;\n  this.alternate = null;\n}\nfunction createFiberImplClass(tag, pendingProps, key, mode) {\n  return new FiberNode(tag, pendingProps, key, mode);\n}\nfunction shouldConstruct(Component) {\n  Component = Component.prototype;\n  return !(!Component || !Component.isReactComponent);\n}\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n  null === workInProgress\n    ? ((workInProgress = createFiberImplClass(\n        current.tag,\n        pendingProps,\n        current.key,\n        current.mode\n      )),\n      (workInProgress.elementType = current.elementType),\n      (workInProgress.type = current.type),\n      (workInProgress.stateNode = current.stateNode),\n      (workInProgress.alternate = current),\n      (current.alternate = workInProgress))\n    : ((workInProgress.pendingProps = pendingProps),\n      (workInProgress.type = current.type),\n      (workInProgress.flags = 0),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null));\n  workInProgress.flags = current.flags & 31457280;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  pendingProps = current.dependencies;\n  workInProgress.dependencies =\n    null === pendingProps\n      ? null\n      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n  workInProgress.refCleanup = current.refCleanup;\n  return workInProgress;\n}\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  workInProgress.flags &= 31457282;\n  var current = workInProgress.alternate;\n  null === current\n    ? ((workInProgress.childLanes = 0),\n      (workInProgress.lanes = renderLanes),\n      (workInProgress.child = null),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.memoizedProps = null),\n      (workInProgress.memoizedState = null),\n      (workInProgress.updateQueue = null),\n      (workInProgress.dependencies = null),\n      (workInProgress.stateNode = null))\n    : ((workInProgress.childLanes = current.childLanes),\n      (workInProgress.lanes = current.lanes),\n      (workInProgress.child = current.child),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null),\n      (workInProgress.memoizedProps = current.memoizedProps),\n      (workInProgress.memoizedState = current.memoizedState),\n      (workInProgress.updateQueue = current.updateQueue),\n      (workInProgress.type = current.type),\n      (renderLanes = current.dependencies),\n      (workInProgress.dependencies =\n        null === renderLanes\n          ? null\n          : {\n              lanes: renderLanes.lanes,\n              firstContext: renderLanes.firstContext\n            }));\n  return workInProgress;\n}\nfunction createFiberFromTypeAndProps(\n  type,\n  key,\n  pendingProps,\n  owner,\n  mode,\n  lanes\n) {\n  var fiberTag = 0;\n  owner = type;\n  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);\n  else if ("string" === typeof type)\n    fiberTag = isHostHoistableType(\n      type,\n      pendingProps,\n      contextStackCursor.current\n    )\n      ? 26\n      : "html" === type || "head" === type || "body" === type\n        ? 27\n        : 5;\n  else\n    a: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = 8;\n        mode |= 24;\n        break;\n      case REACT_PROFILER_TYPE:\n        return (\n          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),\n          (type.elementType = REACT_PROFILER_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_TYPE:\n        return (\n          (type = createFiberImplClass(13, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_LIST_TYPE:\n        return (\n          (type = createFiberImplClass(19, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_LIST_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_OFFSCREEN_TYPE:\n        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n      default:\n        if ("object" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              fiberTag = 10;\n              break a;\n            case REACT_CONSUMER_TYPE:\n              fiberTag = 9;\n              break a;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = 11;\n              break a;\n            case REACT_MEMO_TYPE:\n              fiberTag = 14;\n              break a;\n            case REACT_LAZY_TYPE:\n              fiberTag = 16;\n              owner = null;\n              break a;\n          }\n        fiberTag = 29;\n        pendingProps = Error(\n          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")\n        );\n        owner = null;\n    }\n  key = createFiberImplClass(fiberTag, pendingProps, key, mode);\n  key.elementType = type;\n  key.type = owner;\n  key.lanes = lanes;\n  return key;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  elements = createFiberImplClass(7, elements, key, mode);\n  elements.lanes = lanes;\n  return elements;\n}\nfunction createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n  pendingProps = createFiberImplClass(22, pendingProps, key, mode);\n  pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n  pendingProps.lanes = lanes;\n  var primaryChildInstance = {\n    _visibility: 1,\n    _pendingVisibility: 1,\n    _pendingMarkers: null,\n    _retryCache: null,\n    _transitions: null,\n    _current: null,\n    detach: function () {\n      var fiber = primaryChildInstance._current;\n      if (null === fiber) throw Error(formatProdErrorMessage(456));\n      if (0 === (primaryChildInstance._pendingVisibility & 2)) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root &&\n          ((primaryChildInstance._pendingVisibility |= 2),\n          scheduleUpdateOnFiber(root, fiber, 2));\n      }\n    },\n    attach: function () {\n      var fiber = primaryChildInstance._current;\n      if (null === fiber) throw Error(formatProdErrorMessage(456));\n      if (0 !== (primaryChildInstance._pendingVisibility & 2)) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root &&\n          ((primaryChildInstance._pendingVisibility &= -3),\n          scheduleUpdateOnFiber(root, fiber, 2));\n      }\n    }\n  };\n  pendingProps.stateNode = primaryChildInstance;\n  return pendingProps;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  content = createFiberImplClass(6, content, null, mode);\n  content.lanes = lanes;\n  return content;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  mode = createFiberImplClass(\n    4,\n    null !== portal.children ? portal.children : [],\n    portal.key,\n    mode\n  );\n  mode.lanes = lanes;\n  mode.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    implementation: portal.implementation\n  };\n  return mode;\n}\nfunction markUpdate(workInProgress) {\n  workInProgress.flags |= 4;\n}\nfunction preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))\n    workInProgress.flags &= -16777217;\n  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {\n    resource = suspenseHandlerStackCursor.current;\n    if (\n      null !== resource &&\n      ((workInProgressRootRenderLanes & 4194176) ===\n      workInProgressRootRenderLanes\n        ? null !== shellBoundary\n        : ((workInProgressRootRenderLanes & 62914560) !==\n            workInProgressRootRenderLanes &&\n            0 === (workInProgressRootRenderLanes & 536870912)) ||\n          resource !== shellBoundary)\n    )\n      throw (\n        ((suspendedThenable = noopSuspenseyCommitThenable),\n        SuspenseyCommitException)\n      );\n    workInProgress.flags |= 8192;\n  }\n}\nfunction scheduleRetryEffect(workInProgress, retryQueue) {\n  null !== retryQueue && (workInProgress.flags |= 4);\n  workInProgress.flags & 16384 &&\n    ((retryQueue =\n      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),\n    (workInProgress.lanes |= retryQueue),\n    (workInProgressSuspendedRetryLanes |= retryQueue));\n}\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (!isHydrating)\n    switch (renderState.tailMode) {\n      case "hidden":\n        hasRenderedATailFallback = renderState.tail;\n        for (var lastTailNode = null; null !== hasRenderedATailFallback; )\n          null !== hasRenderedATailFallback.alternate &&\n            (lastTailNode = hasRenderedATailFallback),\n            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);\n        null === lastTailNode\n          ? (renderState.tail = null)\n          : (lastTailNode.sibling = null);\n        break;\n      case "collapsed":\n        lastTailNode = renderState.tail;\n        for (var lastTailNode$131 = null; null !== lastTailNode; )\n          null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode),\n            (lastTailNode = lastTailNode.sibling);\n        null === lastTailNode$131\n          ? hasRenderedATailFallback || null === renderState.tail\n            ? (renderState.tail = null)\n            : (renderState.tail.sibling = null)\n          : (lastTailNode$131.sibling = null);\n    }\n}\nfunction bubbleProperties(completedWork) {\n  var didBailout =\n      null !== completedWork.alternate &&\n      completedWork.alternate.child === completedWork.child,\n    newChildLanes = 0,\n    subtreeFlags = 0;\n  if (didBailout)\n    for (var child$132 = completedWork.child; null !== child$132; )\n      (newChildLanes |= child$132.lanes | child$132.childLanes),\n        (subtreeFlags |= child$132.subtreeFlags & 31457280),\n        (subtreeFlags |= child$132.flags & 31457280),\n        (child$132.return = completedWork),\n        (child$132 = child$132.sibling);\n  else\n    for (child$132 = completedWork.child; null !== child$132; )\n      (newChildLanes |= child$132.lanes | child$132.childLanes),\n        (subtreeFlags |= child$132.subtreeFlags),\n        (subtreeFlags |= child$132.flags),\n        (child$132.return = completedWork),\n        (child$132 = child$132.sibling);\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps;\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 16:\n    case 15:\n    case 0:\n    case 11:\n    case 7:\n    case 8:\n    case 12:\n    case 9:\n    case 14:\n      return bubbleProperties(workInProgress), null;\n    case 1:\n      return bubbleProperties(workInProgress), null;\n    case 3:\n      renderLanes = workInProgress.stateNode;\n      newProps = null;\n      null !== current && (newProps = current.memoizedState.cache);\n      workInProgress.memoizedState.cache !== newProps &&\n        (workInProgress.flags |= 2048);\n      popProvider(CacheContext);\n      popHostContainer();\n      renderLanes.pendingContext &&\n        ((renderLanes.context = renderLanes.pendingContext),\n        (renderLanes.pendingContext = null));\n      if (null === current || null === current.child)\n        popHydrationState(workInProgress)\n          ? markUpdate(workInProgress)\n          : null === current ||\n            (current.memoizedState.isDehydrated &&\n              0 === (workInProgress.flags & 256)) ||\n            ((workInProgress.flags |= 1024),\n            null !== hydrationErrors &&\n              (queueRecoverableErrors(hydrationErrors),\n              (hydrationErrors = null)));\n      bubbleProperties(workInProgress);\n      return null;\n    case 26:\n      return (\n        (renderLanes = workInProgress.memoizedState),\n        null === current\n          ? (markUpdate(workInProgress),\n            null !== renderLanes\n              ? (bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217)))\n          : renderLanes\n            ? renderLanes !== current.memoizedState\n              ? (markUpdate(workInProgress),\n                bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217))\n            : (current.memoizedProps !== newProps && markUpdate(workInProgress),\n              bubbleProperties(workInProgress),\n              (workInProgress.flags &= -16777217)),\n        null\n      );\n    case 27:\n      popHostContext(workInProgress);\n      renderLanes = rootInstanceStackCursor.current;\n      var type = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        popHydrationState(workInProgress)\n          ? prepareToHydrateHostInstance(workInProgress, current)\n          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),\n            (workInProgress.stateNode = current),\n            markUpdate(workInProgress));\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 5:\n      popHostContext(workInProgress);\n      renderLanes = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        if (popHydrationState(workInProgress))\n          prepareToHydrateHostInstance(workInProgress, current);\n        else {\n          type = getOwnerDocumentFromRootContainer(\n            rootInstanceStackCursor.current\n          );\n          switch (current) {\n            case 1:\n              current = type.createElementNS(\n                "http://www.w3.org/2000/svg",\n                renderLanes\n              );\n              break;\n            case 2:\n              current = type.createElementNS(\n                "http://www.w3.org/1998/Math/MathML",\n                renderLanes\n              );\n              break;\n            default:\n              switch (renderLanes) {\n                case "svg":\n                  current = type.createElementNS(\n                    "http://www.w3.org/2000/svg",\n                    renderLanes\n                  );\n                  break;\n                case "math":\n                  current = type.createElementNS(\n                    "http://www.w3.org/1998/Math/MathML",\n                    renderLanes\n                  );\n                  break;\n                case "script":\n                  current = type.createElement("div");\n                  current.innerHTML = "<script>\\x3c/script>";\n                  current = current.removeChild(current.firstChild);\n                  break;\n                case "select":\n                  current =\n                    "string" === typeof newProps.is\n                      ? type.createElement("select", { is: newProps.is })\n                      : type.createElement("select");\n                  newProps.multiple\n                    ? (current.multiple = !0)\n                    : newProps.size && (current.size = newProps.size);\n                  break;\n                default:\n                  current =\n                    "string" === typeof newProps.is\n                      ? type.createElement(renderLanes, { is: newProps.is })\n                      : type.createElement(renderLanes);\n              }\n          }\n          current[internalInstanceKey] = workInProgress;\n          current[internalPropsKey] = newProps;\n          a: for (type = workInProgress.child; null !== type; ) {\n            if (5 === type.tag || 6 === type.tag)\n              current.appendChild(type.stateNode);\n            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {\n              type.child.return = type;\n              type = type.child;\n              continue;\n            }\n            if (type === workInProgress) break a;\n            for (; null === type.sibling; ) {\n              if (null === type.return || type.return === workInProgress)\n                break a;\n              type = type.return;\n            }\n            type.sibling.return = type.return;\n            type = type.sibling;\n          }\n          workInProgress.stateNode = current;\n          a: switch (\n            (setInitialProperties(current, renderLanes, newProps), renderLanes)\n          ) {\n            case "button":\n            case "input":\n            case "select":\n            case "textarea":\n              current = !!newProps.autoFocus;\n              break a;\n            case "img":\n              current = !0;\n              break a;\n            default:\n              current = !1;\n          }\n          current && markUpdate(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      workInProgress.flags &= -16777217;\n      return null;\n    case 6:\n      if (current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if ("string" !== typeof newProps && null === workInProgress.stateNode)\n          throw Error(formatProdErrorMessage(166));\n        current = rootInstanceStackCursor.current;\n        if (popHydrationState(workInProgress)) {\n          current = workInProgress.stateNode;\n          renderLanes = workInProgress.memoizedProps;\n          newProps = null;\n          type = hydrationParentFiber;\n          if (null !== type)\n            switch (type.tag) {\n              case 27:\n              case 5:\n                newProps = type.memoizedProps;\n            }\n          current[internalInstanceKey] = workInProgress;\n          current =\n            current.nodeValue === renderLanes ||\n            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||\n            checkForUnmatchedText(current.nodeValue, renderLanes)\n              ? !0\n              : !1;\n          current || throwOnHydrationMismatch(workInProgress);\n        } else\n          (current =\n            getOwnerDocumentFromRootContainer(current).createTextNode(\n              newProps\n            )),\n            (current[internalInstanceKey] = workInProgress),\n            (workInProgress.stateNode = current);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 13:\n      newProps = workInProgress.memoizedState;\n      if (\n        null === current ||\n        (null !== current.memoizedState &&\n          null !== current.memoizedState.dehydrated)\n      ) {\n        type = popHydrationState(workInProgress);\n        if (null !== newProps && null !== newProps.dehydrated) {\n          if (null === current) {\n            if (!type) throw Error(formatProdErrorMessage(318));\n            type = workInProgress.memoizedState;\n            type = null !== type ? type.dehydrated : null;\n            if (!type) throw Error(formatProdErrorMessage(317));\n            type[internalInstanceKey] = workInProgress;\n          } else\n            resetHydrationState(),\n              0 === (workInProgress.flags & 128) &&\n                (workInProgress.memoizedState = null),\n              (workInProgress.flags |= 4);\n          bubbleProperties(workInProgress);\n          type = !1;\n        } else\n          null !== hydrationErrors &&\n            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),\n            (type = !0);\n        if (!type) {\n          if (workInProgress.flags & 256)\n            return popSuspenseHandler(workInProgress), workInProgress;\n          popSuspenseHandler(workInProgress);\n          return null;\n        }\n      }\n      popSuspenseHandler(workInProgress);\n      if (0 !== (workInProgress.flags & 128))\n        return (workInProgress.lanes = renderLanes), workInProgress;\n      renderLanes = null !== newProps;\n      current = null !== current && null !== current.memoizedState;\n      if (renderLanes) {\n        newProps = workInProgress.child;\n        type = null;\n        null !== newProps.alternate &&\n          null !== newProps.alternate.memoizedState &&\n          null !== newProps.alternate.memoizedState.cachePool &&\n          (type = newProps.alternate.memoizedState.cachePool.pool);\n        var cache$144 = null;\n        null !== newProps.memoizedState &&\n          null !== newProps.memoizedState.cachePool &&\n          (cache$144 = newProps.memoizedState.cachePool.pool);\n        cache$144 !== type && (newProps.flags |= 2048);\n      }\n      renderLanes !== current &&\n        renderLanes &&\n        (workInProgress.child.flags |= 8192);\n      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n      bubbleProperties(workInProgress);\n      return null;\n    case 4:\n      return (\n        popHostContainer(),\n        null === current &&\n          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 10:\n      return (\n        popProvider(workInProgress.type), bubbleProperties(workInProgress), null\n      );\n    case 19:\n      pop(suspenseStackCursor);\n      type = workInProgress.memoizedState;\n      if (null === type) return bubbleProperties(workInProgress), null;\n      newProps = 0 !== (workInProgress.flags & 128);\n      cache$144 = type.rendering;\n      if (null === cache$144)\n        if (newProps) cutOffTailIfNeeded(type, !1);\n        else {\n          if (\n            0 !== workInProgressRootExitStatus ||\n            (null !== current && 0 !== (current.flags & 128))\n          )\n            for (current = workInProgress.child; null !== current; ) {\n              cache$144 = findFirstSuspended(current);\n              if (null !== cache$144) {\n                workInProgress.flags |= 128;\n                cutOffTailIfNeeded(type, !1);\n                current = cache$144.updateQueue;\n                workInProgress.updateQueue = current;\n                scheduleRetryEffect(workInProgress, current);\n                workInProgress.subtreeFlags = 0;\n                current = renderLanes;\n                for (renderLanes = workInProgress.child; null !== renderLanes; )\n                  resetWorkInProgress(renderLanes, current),\n                    (renderLanes = renderLanes.sibling);\n                push(\n                  suspenseStackCursor,\n                  (suspenseStackCursor.current & 1) | 2\n                );\n                return workInProgress.child;\n              }\n              current = current.sibling;\n            }\n          null !== type.tail &&\n            now() > workInProgressRootRenderTargetTime &&\n            ((workInProgress.flags |= 128),\n            (newProps = !0),\n            cutOffTailIfNeeded(type, !1),\n            (workInProgress.lanes = 4194304));\n        }\n      else {\n        if (!newProps)\n          if (((current = findFirstSuspended(cache$144)), null !== current)) {\n            if (\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              (current = current.updateQueue),\n              (workInProgress.updateQueue = current),\n              scheduleRetryEffect(workInProgress, current),\n              cutOffTailIfNeeded(type, !0),\n              null === type.tail &&\n                "hidden" === type.tailMode &&\n                !cache$144.alternate &&\n                !isHydrating)\n            )\n              return bubbleProperties(workInProgress), null;\n          } else\n            2 * now() - type.renderingStartTime >\n              workInProgressRootRenderTargetTime &&\n              536870912 !== renderLanes &&\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              cutOffTailIfNeeded(type, !1),\n              (workInProgress.lanes = 4194304));\n        type.isBackwards\n          ? ((cache$144.sibling = workInProgress.child),\n            (workInProgress.child = cache$144))\n          : ((current = type.last),\n            null !== current\n              ? (current.sibling = cache$144)\n              : (workInProgress.child = cache$144),\n            (type.last = cache$144));\n      }\n      if (null !== type.tail)\n        return (\n          (workInProgress = type.tail),\n          (type.rendering = workInProgress),\n          (type.tail = workInProgress.sibling),\n          (type.renderingStartTime = now()),\n          (workInProgress.sibling = null),\n          (current = suspenseStackCursor.current),\n          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),\n          workInProgress\n        );\n      bubbleProperties(workInProgress);\n      return null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        (newProps = null !== workInProgress.memoizedState),\n        null !== current\n          ? (null !== current.memoizedState) !== newProps &&\n            (workInProgress.flags |= 8192)\n          : newProps && (workInProgress.flags |= 8192),\n        newProps\n          ? 0 !== (renderLanes & 536870912) &&\n            0 === (workInProgress.flags & 128) &&\n            (bubbleProperties(workInProgress),\n            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))\n          : bubbleProperties(workInProgress),\n        (renderLanes = workInProgress.updateQueue),\n        null !== renderLanes &&\n          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),\n        (renderLanes = null),\n        null !== current &&\n          null !== current.memoizedState &&\n          null !== current.memoizedState.cachePool &&\n          (renderLanes = current.memoizedState.cachePool.pool),\n        (newProps = null),\n        null !== workInProgress.memoizedState &&\n          null !== workInProgress.memoizedState.cachePool &&\n          (newProps = workInProgress.memoizedState.cachePool.pool),\n        newProps !== renderLanes && (workInProgress.flags |= 2048),\n        null !== current && pop(resumedCache),\n        null\n      );\n    case 24:\n      return (\n        (renderLanes = null),\n        null !== current && (renderLanes = current.memoizedState.cache),\n        workInProgress.memoizedState.cache !== renderLanes &&\n          (workInProgress.flags |= 2048),\n        popProvider(CacheContext),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 25:\n      return null;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nfunction unwindWork(current, workInProgress) {\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 1:\n      return (\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 3:\n      return (\n        popProvider(CacheContext),\n        popHostContainer(),\n        (current = workInProgress.flags),\n        0 !== (current & 65536) && 0 === (current & 128)\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 26:\n    case 27:\n    case 5:\n      return popHostContext(workInProgress), null;\n    case 13:\n      popSuspenseHandler(workInProgress);\n      current = workInProgress.memoizedState;\n      if (null !== current && null !== current.dehydrated) {\n        if (null === workInProgress.alternate)\n          throw Error(formatProdErrorMessage(340));\n        resetHydrationState();\n      }\n      current = workInProgress.flags;\n      return current & 65536\n        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n        : null;\n    case 19:\n      return pop(suspenseStackCursor), null;\n    case 4:\n      return popHostContainer(), null;\n    case 10:\n      return popProvider(workInProgress.type), null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        null !== current && pop(resumedCache),\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 24:\n      return popProvider(CacheContext), null;\n    case 25:\n      return null;\n    default:\n      return null;\n  }\n}\nfunction unwindInterruptedWork(current, interruptedWork) {\n  popTreeContext(interruptedWork);\n  switch (interruptedWork.tag) {\n    case 3:\n      popProvider(CacheContext);\n      popHostContainer();\n      break;\n    case 26:\n    case 27:\n    case 5:\n      popHostContext(interruptedWork);\n      break;\n    case 4:\n      popHostContainer();\n      break;\n    case 13:\n      popSuspenseHandler(interruptedWork);\n      break;\n    case 19:\n      pop(suspenseStackCursor);\n      break;\n    case 10:\n      popProvider(interruptedWork.type);\n      break;\n    case 22:\n    case 23:\n      popSuspenseHandler(interruptedWork);\n      popHiddenContext();\n      null !== current && pop(resumedCache);\n      break;\n    case 24:\n      popProvider(CacheContext);\n  }\n}\nvar DefaultAsyncDispatcher = {\n    getCacheForType: function (resourceType) {\n      var cache = readContext(CacheContext),\n        cacheForType = cache.data.get(resourceType);\n      void 0 === cacheForType &&\n        ((cacheForType = resourceType()),\n        cache.data.set(resourceType, cacheForType));\n      return cacheForType;\n    }\n  },\n  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,\n  executionContext = 0,\n  workInProgressRoot = null,\n  workInProgress = null,\n  workInProgressRootRenderLanes = 0,\n  workInProgressSuspendedReason = 0,\n  workInProgressThrownValue = null,\n  workInProgressRootDidSkipSuspendedSiblings = !1,\n  workInProgressRootIsPrerendering = !1,\n  workInProgressRootDidAttachPingListener = !1,\n  entangledRenderLanes = 0,\n  workInProgressRootExitStatus = 0,\n  workInProgressRootSkippedLanes = 0,\n  workInProgressRootInterleavedUpdatedLanes = 0,\n  workInProgressRootPingedLanes = 0,\n  workInProgressDeferredLane = 0,\n  workInProgressSuspendedRetryLanes = 0,\n  workInProgressRootConcurrentErrors = null,\n  workInProgressRootRecoverableErrors = null,\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,\n  globalMostRecentFallbackTime = 0,\n  workInProgressRootRenderTargetTime = Infinity,\n  workInProgressTransitions = null,\n  legacyErrorBoundariesThatAlreadyFailed = null,\n  rootDoesHavePassiveEffects = !1,\n  rootWithPendingPassiveEffects = null,\n  pendingPassiveEffectsLanes = 0,\n  pendingPassiveEffectsRemainingLanes = 0,\n  pendingPassiveTransitions = null,\n  nestedUpdateCount = 0,\n  rootWithNestedUpdates = null;\nfunction requestUpdateLane() {\n  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)\n    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n  if (null !== ReactSharedInternals.T) {\n    var actionScopeLane = currentEntangledLane;\n    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();\n  }\n  return resolveUpdatePriority();\n}\nfunction requestDeferredLane() {\n  0 === workInProgressDeferredLane &&\n    (workInProgressDeferredLane =\n      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating\n        ? claimNextTransitionLane()\n        : 536870912);\n  var suspenseHandler = suspenseHandlerStackCursor.current;\n  null !== suspenseHandler && (suspenseHandler.flags |= 32);\n  return workInProgressDeferredLane;\n}\nfunction scheduleUpdateOnFiber(root, fiber, lane) {\n  if (\n    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||\n    null !== root.cancelPendingCommit\n  )\n    prepareFreshStack(root, 0),\n      markRootSuspended(\n        root,\n        workInProgressRootRenderLanes,\n        workInProgressDeferredLane,\n        !1\n      );\n  markRootUpdated$1(root, lane);\n  if (0 === (executionContext & 2) || root !== workInProgressRoot)\n    root === workInProgressRoot &&\n      (0 === (executionContext & 2) &&\n        (workInProgressRootInterleavedUpdatedLanes |= lane),\n      4 === workInProgressRootExitStatus &&\n        markRootSuspended(\n          root,\n          workInProgressRootRenderLanes,\n          workInProgressDeferredLane,\n          !1\n        )),\n      ensureRootIsScheduled(root);\n}\nfunction performWorkOnRoot(root$jscomp$0, lanes, forceSync) {\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  var shouldTimeSlice =\n      (!forceSync &&\n        0 === (lanes & 60) &&\n        0 === (lanes & root$jscomp$0.expiredLanes)) ||\n      checkIfRootIsPrerendering(root$jscomp$0, lanes),\n    exitStatus = shouldTimeSlice\n      ? renderRootConcurrent(root$jscomp$0, lanes)\n      : renderRootSync(root$jscomp$0, lanes, !0),\n    renderWasConcurrent = shouldTimeSlice;\n  do {\n    if (0 === exitStatus) {\n      workInProgressRootIsPrerendering &&\n        !shouldTimeSlice &&\n        markRootSuspended(root$jscomp$0, lanes, 0, !1);\n      break;\n    } else if (6 === exitStatus)\n      markRootSuspended(\n        root$jscomp$0,\n        lanes,\n        0,\n        !workInProgressRootDidSkipSuspendedSiblings\n      );\n    else {\n      forceSync = root$jscomp$0.current.alternate;\n      if (\n        renderWasConcurrent &&\n        !isRenderConsistentWithExternalStores(forceSync)\n      ) {\n        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);\n        renderWasConcurrent = !1;\n        continue;\n      }\n      if (2 === exitStatus) {\n        renderWasConcurrent = lanes;\n        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)\n          var JSCompiler_inline_result = 0;\n        else\n          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),\n            (JSCompiler_inline_result =\n              0 !== JSCompiler_inline_result\n                ? JSCompiler_inline_result\n                : JSCompiler_inline_result & 536870912\n                  ? 536870912\n                  : 0);\n        if (0 !== JSCompiler_inline_result) {\n          lanes = JSCompiler_inline_result;\n          a: {\n            var root = root$jscomp$0;\n            exitStatus = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = root.current.memoizedState.isDehydrated;\n            wasRootDehydrated &&\n              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);\n            JSCompiler_inline_result = renderRootSync(\n              root,\n              JSCompiler_inline_result,\n              !1\n            );\n            if (2 !== JSCompiler_inline_result) {\n              if (\n                workInProgressRootDidAttachPingListener &&\n                !wasRootDehydrated\n              ) {\n                root.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                workInProgressRootInterleavedUpdatedLanes |=\n                  renderWasConcurrent;\n                exitStatus = 4;\n                break a;\n              }\n              renderWasConcurrent = workInProgressRootRecoverableErrors;\n              workInProgressRootRecoverableErrors = exitStatus;\n              null !== renderWasConcurrent &&\n                queueRecoverableErrors(renderWasConcurrent);\n            }\n            exitStatus = JSCompiler_inline_result;\n          }\n          renderWasConcurrent = !1;\n          if (2 !== exitStatus) continue;\n        }\n      }\n      if (1 === exitStatus) {\n        prepareFreshStack(root$jscomp$0, 0);\n        markRootSuspended(root$jscomp$0, lanes, 0, !0);\n        break;\n      }\n      a: {\n        shouldTimeSlice = root$jscomp$0;\n        switch (exitStatus) {\n          case 0:\n          case 1:\n            throw Error(formatProdErrorMessage(345));\n          case 4:\n            if ((lanes & 4194176) === lanes) {\n              markRootSuspended(\n                shouldTimeSlice,\n                lanes,\n                workInProgressDeferredLane,\n                !workInProgressRootDidSkipSuspendedSiblings\n              );\n              break a;\n            }\n            break;\n          case 2:\n            workInProgressRootRecoverableErrors = null;\n            break;\n          case 3:\n          case 5:\n            break;\n          default:\n            throw Error(formatProdErrorMessage(329));\n        }\n        shouldTimeSlice.finishedWork = forceSync;\n        shouldTimeSlice.finishedLanes = lanes;\n        if (\n          (lanes & 62914560) === lanes &&\n          ((renderWasConcurrent = globalMostRecentFallbackTime + 300 - now()),\n          10 < renderWasConcurrent)\n        ) {\n          markRootSuspended(\n            shouldTimeSlice,\n            lanes,\n            workInProgressDeferredLane,\n            !workInProgressRootDidSkipSuspendedSiblings\n          );\n          if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n          shouldTimeSlice.timeoutHandle = scheduleTimeout(\n            commitRootWhenReady.bind(\n              null,\n              shouldTimeSlice,\n              forceSync,\n              workInProgressRootRecoverableErrors,\n              workInProgressTransitions,\n              workInProgressRootDidIncludeRecursiveRenderUpdate,\n              lanes,\n              workInProgressDeferredLane,\n              workInProgressRootInterleavedUpdatedLanes,\n              workInProgressSuspendedRetryLanes,\n              workInProgressRootDidSkipSuspendedSiblings,\n              2,\n              -0,\n              0\n            ),\n            renderWasConcurrent\n          );\n          break a;\n        }\n        commitRootWhenReady(\n          shouldTimeSlice,\n          forceSync,\n          workInProgressRootRecoverableErrors,\n          workInProgressTransitions,\n          workInProgressRootDidIncludeRecursiveRenderUpdate,\n          lanes,\n          workInProgressDeferredLane,\n          workInProgressRootInterleavedUpdatedLanes,\n          workInProgressSuspendedRetryLanes,\n          workInProgressRootDidSkipSuspendedSiblings,\n          0,\n          -0,\n          0\n        );\n      }\n    }\n    break;\n  } while (1);\n  ensureRootIsScheduled(root$jscomp$0);\n}\nfunction queueRecoverableErrors(errors) {\n  null === workInProgressRootRecoverableErrors\n    ? (workInProgressRootRecoverableErrors = errors)\n    : workInProgressRootRecoverableErrors.push.apply(\n        workInProgressRootRecoverableErrors,\n        errors\n      );\n}\nfunction commitRootWhenReady(\n  root,\n  finishedWork,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  lanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes,\n  didSkipSuspendedSiblings,\n  suspendedCommitReason,\n  completedRenderStartTime,\n  completedRenderEndTime\n) {\n  var subtreeFlags = finishedWork.subtreeFlags;\n  if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))\n    if (\n      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),\n      accumulateSuspenseyCommitOnFiber(finishedWork),\n      (finishedWork = waitForCommitToBeReady()),\n      null !== finishedWork)\n    ) {\n      root.cancelPendingCommit = finishedWork(\n        commitRoot.bind(\n          null,\n          root,\n          recoverableErrors,\n          transitions,\n          didIncludeRenderPhaseUpdate,\n          spawnedLane,\n          updatedLanes,\n          suspendedRetryLanes,\n          1,\n          completedRenderStartTime,\n          completedRenderEndTime\n        )\n      );\n      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n      return;\n    }\n  commitRoot(\n    root,\n    recoverableErrors,\n    transitions,\n    didIncludeRenderPhaseUpdate,\n    spawnedLane,\n    updatedLanes,\n    suspendedRetryLanes,\n    suspendedCommitReason,\n    completedRenderStartTime,\n    completedRenderEndTime\n  );\n}\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  for (var node = finishedWork; ; ) {\n    var tag = node.tag;\n    if (\n      (0 === tag || 11 === tag || 15 === tag) &&\n      node.flags & 16384 &&\n      ((tag = node.updateQueue),\n      null !== tag && ((tag = tag.stores), null !== tag))\n    )\n      for (var i = 0; i < tag.length; i++) {\n        var check = tag[i],\n          getSnapshot = check.getSnapshot;\n        check = check.value;\n        try {\n          if (!objectIs(getSnapshot(), check)) return !1;\n        } catch (error) {\n          return !1;\n        }\n      }\n    tag = node.child;\n    if (node.subtreeFlags & 16384 && null !== tag)\n      (tag.return = node), (node = tag);\n    else {\n      if (node === finishedWork) break;\n      for (; null === node.sibling; ) {\n        if (null === node.return || node.return === finishedWork) return !0;\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n  return !0;\n}\nfunction markRootSuspended(\n  root,\n  suspendedLanes,\n  spawnedLane,\n  didAttemptEntireTree\n) {\n  suspendedLanes &= ~workInProgressRootPingedLanes;\n  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n  didAttemptEntireTree = root.expirationTimes;\n  for (var lanes = suspendedLanes; 0 < lanes; ) {\n    var index$6 = 31 - clz32(lanes),\n      lane = 1 << index$6;\n    didAttemptEntireTree[index$6] = -1;\n    lanes &= ~lane;\n  }\n  0 !== spawnedLane &&\n    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n}\nfunction flushSyncWork$1() {\n  return 0 === (executionContext & 6)\n    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)\n    : !0;\n}\nfunction resetWorkInProgressStack() {\n  if (null !== workInProgress) {\n    if (0 === workInProgressSuspendedReason)\n      var interruptedWork = workInProgress.return;\n    else\n      (interruptedWork = workInProgress),\n        (lastContextDependency = currentlyRenderingFiber = null),\n        resetHooksOnUnwind(interruptedWork),\n        (thenableState$1 = null),\n        (thenableIndexCounter$1 = 0),\n        (interruptedWork = workInProgress);\n    for (; null !== interruptedWork; )\n      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),\n        (interruptedWork = interruptedWork.return);\n    workInProgress = null;\n  }\n}\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = 0;\n  var timeoutHandle = root.timeoutHandle;\n  -1 !== timeoutHandle &&\n    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));\n  timeoutHandle = root.cancelPendingCommit;\n  null !== timeoutHandle &&\n    ((root.cancelPendingCommit = null), timeoutHandle());\n  resetWorkInProgressStack();\n  workInProgressRoot = root;\n  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = lanes;\n  workInProgressSuspendedReason = 0;\n  workInProgressThrownValue = null;\n  workInProgressRootDidSkipSuspendedSiblings = !1;\n  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n  workInProgressRootDidAttachPingListener = !1;\n  workInProgressSuspendedRetryLanes =\n    workInProgressDeferredLane =\n    workInProgressRootPingedLanes =\n    workInProgressRootInterleavedUpdatedLanes =\n    workInProgressRootSkippedLanes =\n    workInProgressRootExitStatus =\n      0;\n  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =\n    null;\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n  0 !== (lanes & 8) && (lanes |= lanes & 32);\n  var allEntangledLanes = root.entangledLanes;\n  if (0 !== allEntangledLanes)\n    for (\n      root = root.entanglements, allEntangledLanes &= lanes;\n      0 < allEntangledLanes;\n\n    ) {\n      var index$4 = 31 - clz32(allEntangledLanes),\n        lane = 1 << index$4;\n      lanes |= root[index$4];\n      allEntangledLanes &= ~lane;\n    }\n  entangledRenderLanes = lanes;\n  finishQueueingConcurrentUpdates();\n  return timeoutHandle;\n}\nfunction handleThrow(root, thrownValue) {\n  currentlyRenderingFiber$1 = null;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  thrownValue === SuspenseException\n    ? ((thrownValue = getSuspendedThenable()),\n      (workInProgressSuspendedReason = 3))\n    : thrownValue === SuspenseyCommitException\n      ? ((thrownValue = getSuspendedThenable()),\n        (workInProgressSuspendedReason = 4))\n      : (workInProgressSuspendedReason =\n          thrownValue === SelectiveHydrationException\n            ? 8\n            : null !== thrownValue &&\n                "object" === typeof thrownValue &&\n                "function" === typeof thrownValue.then\n              ? 6\n              : 1);\n  workInProgressThrownValue = thrownValue;\n  null === workInProgress &&\n    ((workInProgressRootExitStatus = 1),\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    ));\n}\nfunction pushDispatcher() {\n  var prevDispatcher = ReactSharedInternals.H;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n}\nfunction pushAsyncDispatcher() {\n  var prevAsyncDispatcher = ReactSharedInternals.A;\n  ReactSharedInternals.A = DefaultAsyncDispatcher;\n  return prevAsyncDispatcher;\n}\nfunction renderDidSuspendDelayIfPossible() {\n  workInProgressRootExitStatus = 4;\n  workInProgressRootDidSkipSuspendedSiblings ||\n    ((workInProgressRootRenderLanes & 4194176) !==\n      workInProgressRootRenderLanes &&\n      null !== suspenseHandlerStackCursor.current) ||\n    (workInProgressRootIsPrerendering = !0);\n  (0 === (workInProgressRootSkippedLanes & 134217727) &&\n    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||\n    null === workInProgressRoot ||\n    markRootSuspended(\n      workInProgressRoot,\n      workInProgressRootRenderLanes,\n      workInProgressDeferredLane,\n      !1\n    );\n}\nfunction renderRootSync(root, lanes, shouldYieldForPrerendering) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)\n    (workInProgressTransitions = null), prepareFreshStack(root, lanes);\n  lanes = !1;\n  var exitStatus = workInProgressRootExitStatus;\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        var unitOfWork = workInProgress,\n          thrownValue = workInProgressThrownValue;\n        switch (workInProgressSuspendedReason) {\n          case 8:\n            resetWorkInProgressStack();\n            exitStatus = 6;\n            break a;\n          case 3:\n          case 2:\n          case 6:\n            null === suspenseHandlerStackCursor.current && (lanes = !0);\n            var reason = workInProgressSuspendedReason;\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n            if (\n              shouldYieldForPrerendering &&\n              workInProgressRootIsPrerendering\n            ) {\n              exitStatus = 0;\n              break a;\n            }\n            break;\n          default:\n            (reason = workInProgressSuspendedReason),\n              (workInProgressSuspendedReason = 0),\n              (workInProgressThrownValue = null),\n              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n        }\n      }\n      workLoopSync();\n      exitStatus = workInProgressRootExitStatus;\n      break;\n    } catch (thrownValue$164) {\n      handleThrow(root, thrownValue$164);\n    }\n  while (1);\n  lanes && root.shellSuspendCounter++;\n  lastContextDependency = currentlyRenderingFiber = null;\n  executionContext = prevExecutionContext;\n  ReactSharedInternals.H = prevDispatcher;\n  ReactSharedInternals.A = prevAsyncDispatcher;\n  null === workInProgress &&\n    ((workInProgressRoot = null),\n    (workInProgressRootRenderLanes = 0),\n    finishQueueingConcurrentUpdates());\n  return exitStatus;\n}\nfunction workLoopSync() {\n  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);\n}\nfunction renderRootConcurrent(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes\n    ? ((workInProgressTransitions = null),\n      (workInProgressRootRenderTargetTime = now() + 500),\n      prepareFreshStack(root, lanes))\n    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(\n        root,\n        lanes\n      ));\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        lanes = workInProgress;\n        var thrownValue = workInProgressThrownValue;\n        b: switch (workInProgressSuspendedReason) {\n          case 1:\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);\n            break;\n          case 2:\n            if (isThenableResolved(thrownValue)) {\n              workInProgressSuspendedReason = 0;\n              workInProgressThrownValue = null;\n              replaySuspendedUnitOfWork(lanes);\n              break;\n            }\n            lanes = function () {\n              2 === workInProgressSuspendedReason &&\n                workInProgressRoot === root &&\n                (workInProgressSuspendedReason = 7);\n              ensureRootIsScheduled(root);\n            };\n            thrownValue.then(lanes, lanes);\n            break a;\n          case 3:\n            workInProgressSuspendedReason = 7;\n            break a;\n          case 4:\n            workInProgressSuspendedReason = 5;\n            break a;\n          case 7:\n            isThenableResolved(thrownValue)\n              ? ((workInProgressSuspendedReason = 0),\n                (workInProgressThrownValue = null),\n                replaySuspendedUnitOfWork(lanes))\n              : ((workInProgressSuspendedReason = 0),\n                (workInProgressThrownValue = null),\n                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));\n            break;\n          case 5:\n            var resource = null;\n            switch (workInProgress.tag) {\n              case 26:\n                resource = workInProgress.memoizedState;\n              case 5:\n              case 27:\n                var hostFiber = workInProgress;\n                if (resource ? preloadResource(resource) : 1) {\n                  workInProgressSuspendedReason = 0;\n                  workInProgressThrownValue = null;\n                  var sibling = hostFiber.sibling;\n                  if (null !== sibling) workInProgress = sibling;\n                  else {\n                    var returnFiber = hostFiber.return;\n                    null !== returnFiber\n                      ? ((workInProgress = returnFiber),\n                        completeUnitOfWork(returnFiber))\n                      : (workInProgress = null);\n                  }\n                  break b;\n                }\n            }\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);\n            break;\n          case 6:\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);\n            break;\n          case 8:\n            resetWorkInProgressStack();\n            workInProgressRootExitStatus = 6;\n            break a;\n          default:\n            throw Error(formatProdErrorMessage(462));\n        }\n      }\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue$166) {\n      handleThrow(root, thrownValue$166);\n    }\n  while (1);\n  lastContextDependency = currentlyRenderingFiber = null;\n  ReactSharedInternals.H = prevDispatcher;\n  ReactSharedInternals.A = prevAsyncDispatcher;\n  executionContext = prevExecutionContext;\n  if (null !== workInProgress) return 0;\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = 0;\n  finishQueueingConcurrentUpdates();\n  return workInProgressRootExitStatus;\n}\nfunction workLoopConcurrent() {\n  for (; null !== workInProgress && !shouldYield(); )\n    performUnitOfWork(workInProgress);\n}\nfunction performUnitOfWork(unitOfWork) {\n  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);\n}\nfunction replaySuspendedUnitOfWork(unitOfWork) {\n  var next = unitOfWork;\n  var current = next.alternate;\n  switch (next.tag) {\n    case 15:\n    case 0:\n      next = replayFunctionComponent(\n        current,\n        next,\n        next.pendingProps,\n        next.type,\n        void 0,\n        workInProgressRootRenderLanes\n      );\n      break;\n    case 11:\n      next = replayFunctionComponent(\n        current,\n        next,\n        next.pendingProps,\n        next.type.render,\n        next.ref,\n        workInProgressRootRenderLanes\n      );\n      break;\n    case 5:\n      resetHooksOnUnwind(next);\n    default:\n      unwindInterruptedWork(current, next),\n        (next = workInProgress =\n          resetWorkInProgress(next, entangledRenderLanes)),\n        (next = beginWork(current, next, entangledRenderLanes));\n  }\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);\n}\nfunction throwAndUnwindWorkLoop(\n  root,\n  unitOfWork,\n  thrownValue,\n  suspendedReason\n) {\n  lastContextDependency = currentlyRenderingFiber = null;\n  resetHooksOnUnwind(unitOfWork);\n  thenableState$1 = null;\n  thenableIndexCounter$1 = 0;\n  var returnFiber = unitOfWork.return;\n  try {\n    if (\n      throwException(\n        root,\n        returnFiber,\n        unitOfWork,\n        thrownValue,\n        workInProgressRootRenderLanes\n      )\n    ) {\n      workInProgressRootExitStatus = 1;\n      logUncaughtError(\n        root,\n        createCapturedValueAtFiber(thrownValue, root.current)\n      );\n      workInProgress = null;\n      return;\n    }\n  } catch (error) {\n    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);\n    workInProgressRootExitStatus = 1;\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    );\n    workInProgress = null;\n    return;\n  }\n  if (unitOfWork.flags & 32768) {\n    if (isHydrating || 1 === suspendedReason) root = !0;\n    else if (\n      workInProgressRootIsPrerendering ||\n      0 !== (workInProgressRootRenderLanes & 536870912)\n    )\n      root = !1;\n    else if (\n      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),\n      2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)\n    )\n      (suspendedReason = suspenseHandlerStackCursor.current),\n        null !== suspendedReason &&\n          13 === suspendedReason.tag &&\n          (suspendedReason.flags |= 16384);\n    unwindUnitOfWork(unitOfWork, root);\n  } else completeUnitOfWork(unitOfWork);\n}\nfunction completeUnitOfWork(unitOfWork) {\n  var completedWork = unitOfWork;\n  do {\n    if (0 !== (completedWork.flags & 32768)) {\n      unwindUnitOfWork(\n        completedWork,\n        workInProgressRootDidSkipSuspendedSiblings\n      );\n      return;\n    }\n    unitOfWork = completedWork.return;\n    var next = completeWork(\n      completedWork.alternate,\n      completedWork,\n      entangledRenderLanes\n    );\n    if (null !== next) {\n      workInProgress = next;\n      return;\n    }\n    completedWork = completedWork.sibling;\n    if (null !== completedWork) {\n      workInProgress = completedWork;\n      return;\n    }\n    workInProgress = completedWork = unitOfWork;\n  } while (null !== completedWork);\n  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);\n}\nfunction unwindUnitOfWork(unitOfWork, skipSiblings) {\n  do {\n    var next = unwindWork(unitOfWork.alternate, unitOfWork);\n    if (null !== next) {\n      next.flags &= 32767;\n      workInProgress = next;\n      return;\n    }\n    next = unitOfWork.return;\n    null !== next &&\n      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));\n    if (\n      !skipSiblings &&\n      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)\n    ) {\n      workInProgress = unitOfWork;\n      return;\n    }\n    workInProgress = unitOfWork = next;\n  } while (null !== unitOfWork);\n  workInProgressRootExitStatus = 6;\n  workInProgress = null;\n}\nfunction commitRoot(\n  root,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes,\n  suspendedCommitReason,\n  completedRenderStartTime,\n  completedRenderEndTime\n) {\n  var prevTransition = ReactSharedInternals.T,\n    previousUpdateLanePriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 2),\n      (ReactSharedInternals.T = null),\n      commitRootImpl(\n        root,\n        recoverableErrors,\n        transitions,\n        didIncludeRenderPhaseUpdate,\n        previousUpdateLanePriority,\n        spawnedLane,\n        updatedLanes,\n        suspendedRetryLanes,\n        suspendedCommitReason,\n        completedRenderStartTime,\n        completedRenderEndTime\n      );\n  } finally {\n    (ReactSharedInternals.T = prevTransition),\n      (ReactDOMSharedInternals.p = previousUpdateLanePriority);\n  }\n}\nfunction commitRootImpl(\n  root,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  renderPriorityLevel,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  do flushPassiveEffects();\n  while (null !== rootWithPendingPassiveEffects);\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  var finishedWork = root.finishedWork;\n  didIncludeRenderPhaseUpdate = root.finishedLanes;\n  if (null === finishedWork) return null;\n  root.finishedWork = null;\n  root.finishedLanes = 0;\n  if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));\n  root.callbackNode = null;\n  root.callbackPriority = 0;\n  root.cancelPendingCommit = null;\n  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n  remainingLanes |= concurrentlyUpdatedLanes;\n  markRootFinished(\n    root,\n    didIncludeRenderPhaseUpdate,\n    remainingLanes,\n    spawnedLane,\n    updatedLanes,\n    suspendedRetryLanes\n  );\n  root === workInProgressRoot &&\n    ((workInProgress = workInProgressRoot = null),\n    (workInProgressRootRenderLanes = 0));\n  (0 === (finishedWork.subtreeFlags & 10256) &&\n    0 === (finishedWork.flags & 10256)) ||\n    rootDoesHavePassiveEffects ||\n    ((rootDoesHavePassiveEffects = !0),\n    (pendingPassiveEffectsRemainingLanes = remainingLanes),\n    (pendingPassiveTransitions = transitions),\n    scheduleCallback$1(NormalPriority$1, function () {\n      flushPassiveEffects(!0);\n      return null;\n    }));\n  transitions = 0 !== (finishedWork.flags & 15990);\n  0 !== (finishedWork.subtreeFlags & 15990) || transitions\n    ? ((transitions = ReactSharedInternals.T),\n      (ReactSharedInternals.T = null),\n      (spawnedLane = ReactDOMSharedInternals.p),\n      (ReactDOMSharedInternals.p = 2),\n      (updatedLanes = executionContext),\n      (executionContext |= 4),\n      commitBeforeMutationEffects(root, finishedWork),\n      commitMutationEffectsOnFiber(finishedWork, root),\n      restoreSelection(selectionInformation, root.containerInfo),\n      (_enabled = !!eventsEnabled),\n      (selectionInformation = eventsEnabled = null),\n      (root.current = finishedWork),\n      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),\n      requestPaint(),\n      (executionContext = updatedLanes),\n      (ReactDOMSharedInternals.p = spawnedLane),\n      (ReactSharedInternals.T = transitions))\n    : (root.current = finishedWork);\n  rootDoesHavePassiveEffects\n    ? ((rootDoesHavePassiveEffects = !1),\n      (rootWithPendingPassiveEffects = root),\n      (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))\n    : releaseRootPooledCache(root, remainingLanes);\n  remainingLanes = root.pendingLanes;\n  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n  ensureRootIsScheduled(root);\n  if (null !== recoverableErrors)\n    for (\n      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;\n      finishedWork < recoverableErrors.length;\n      finishedWork++\n    )\n      (remainingLanes = recoverableErrors[finishedWork]),\n        renderPriorityLevel(remainingLanes.value, {\n          componentStack: remainingLanes.stack\n        });\n  0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n  remainingLanes = root.pendingLanes;\n  0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42)\n    ? root === rootWithNestedUpdates\n      ? nestedUpdateCount++\n      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))\n    : (nestedUpdateCount = 0);\n  flushSyncWorkAcrossRoots_impl(0, !1);\n  return null;\n}\nfunction releaseRootPooledCache(root, remainingLanes) {\n  0 === (root.pooledCacheLanes &= remainingLanes) &&\n    ((remainingLanes = root.pooledCache),\n    null != remainingLanes &&\n      ((root.pooledCache = null), releaseCache(remainingLanes)));\n}\nfunction flushPassiveEffects() {\n  if (null !== rootWithPendingPassiveEffects) {\n    var root$170 = rootWithPendingPassiveEffects,\n      remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = 0;\n    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),\n      prevTransition = ReactSharedInternals.T,\n      previousPriority = ReactDOMSharedInternals.p;\n    try {\n      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;\n      ReactSharedInternals.T = null;\n      if (null === rootWithPendingPassiveEffects)\n        var JSCompiler_inline_result = !1;\n      else {\n        renderPriority = pendingPassiveTransitions;\n        pendingPassiveTransitions = null;\n        var root = rootWithPendingPassiveEffects,\n          lanes = pendingPassiveEffectsLanes;\n        rootWithPendingPassiveEffects = null;\n        pendingPassiveEffectsLanes = 0;\n        if (0 !== (executionContext & 6))\n          throw Error(formatProdErrorMessage(331));\n        var prevExecutionContext = executionContext;\n        executionContext |= 4;\n        commitPassiveUnmountOnFiber(root.current);\n        commitPassiveMountOnFiber(root, root.current, lanes, renderPriority);\n        executionContext = prevExecutionContext;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        if (\n          injectedHook &&\n          "function" === typeof injectedHook.onPostCommitFiberRoot\n        )\n          try {\n            injectedHook.onPostCommitFiberRoot(rendererID, root);\n          } catch (err) {}\n        JSCompiler_inline_result = !0;\n      }\n      return JSCompiler_inline_result;\n    } finally {\n      (ReactDOMSharedInternals.p = previousPriority),\n        (ReactSharedInternals.T = prevTransition),\n        releaseRootPooledCache(root$170, remainingLanes);\n    }\n  }\n  return !1;\n}\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n  null !== rootFiber &&\n    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n}\nfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n  if (3 === sourceFiber.tag)\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n  else\n    for (; null !== nearestMountedAncestor; ) {\n      if (3 === nearestMountedAncestor.tag) {\n        captureCommitPhaseErrorOnRoot(\n          nearestMountedAncestor,\n          sourceFiber,\n          error\n        );\n        break;\n      } else if (1 === nearestMountedAncestor.tag) {\n        var instance = nearestMountedAncestor.stateNode;\n        if (\n          "function" ===\n            typeof nearestMountedAncestor.type.getDerivedStateFromError ||\n          ("function" === typeof instance.componentDidCatch &&\n            (null === legacyErrorBoundariesThatAlreadyFailed ||\n              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))\n        ) {\n          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n          error = createClassErrorUpdate(2);\n          instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n          null !== instance &&\n            (initializeClassErrorUpdate(\n              error,\n              instance,\n              nearestMountedAncestor,\n              sourceFiber\n            ),\n            markRootUpdated$1(instance, 2),\n            ensureRootIsScheduled(instance));\n          break;\n        }\n      }\n      nearestMountedAncestor = nearestMountedAncestor.return;\n    }\n}\nfunction attachPingListener(root, wakeable, lanes) {\n  var pingCache = root.pingCache;\n  if (null === pingCache) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    var threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else\n    (threadIDs = pingCache.get(wakeable)),\n      void 0 === threadIDs &&\n        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));\n  threadIDs.has(lanes) ||\n    ((workInProgressRootDidAttachPingListener = !0),\n    threadIDs.add(lanes),\n    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),\n    wakeable.then(root, root));\n}\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  var pingCache = root.pingCache;\n  null !== pingCache && pingCache.delete(wakeable);\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n  root.warmLanes &= ~pingedLanes;\n  workInProgressRoot === root &&\n    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&\n    (4 === workInProgressRootExitStatus ||\n    (3 === workInProgressRootExitStatus &&\n      (workInProgressRootRenderLanes & 62914560) ===\n        workInProgressRootRenderLanes &&\n      300 > now() - globalMostRecentFallbackTime)\n      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)\n      : (workInProgressRootPingedLanes |= pingedLanes),\n    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&\n      (workInProgressSuspendedRetryLanes = 0));\n  ensureRootIsScheduled(root);\n}\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  0 === retryLane && (retryLane = claimNextRetryLane());\n  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n  null !== boundaryFiber &&\n    (markRootUpdated$1(boundaryFiber, retryLane),\n    ensureRootIsScheduled(boundaryFiber));\n}\nfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n  var suspenseState = boundaryFiber.memoizedState,\n    retryLane = 0;\n  null !== suspenseState && (retryLane = suspenseState.retryLane);\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n  var retryLane = 0;\n  switch (boundaryFiber.tag) {\n    case 13:\n      var retryCache = boundaryFiber.stateNode;\n      var suspenseState = boundaryFiber.memoizedState;\n      null !== suspenseState && (retryLane = suspenseState.retryLane);\n      break;\n    case 19:\n      retryCache = boundaryFiber.stateNode;\n      break;\n    case 22:\n      retryCache = boundaryFiber.stateNode._retryCache;\n      break;\n    default:\n      throw Error(formatProdErrorMessage(314));\n  }\n  null !== retryCache && retryCache.delete(wakeable);\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction scheduleCallback$1(priorityLevel, callback) {\n  return scheduleCallback$3(priorityLevel, callback);\n}\nvar firstScheduledRoot = null,\n  lastScheduledRoot = null,\n  didScheduleMicrotask = !1,\n  mightHavePendingSyncWork = !1,\n  isFlushingWork = !1,\n  currentEventTransitionLane = 0;\nfunction ensureRootIsScheduled(root) {\n  root !== lastScheduledRoot &&\n    null === root.next &&\n    (null === lastScheduledRoot\n      ? (firstScheduledRoot = lastScheduledRoot = root)\n      : (lastScheduledRoot = lastScheduledRoot.next = root));\n  mightHavePendingSyncWork = !0;\n  didScheduleMicrotask ||\n    ((didScheduleMicrotask = !0),\n    scheduleImmediateTask(processRootScheduleInMicrotask));\n}\nfunction flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n  if (!isFlushingWork && mightHavePendingSyncWork) {\n    isFlushingWork = !0;\n    do {\n      var didPerformSomeWork = !1;\n      for (var root$172 = firstScheduledRoot; null !== root$172; ) {\n        if (!onlyLegacy)\n          if (0 !== syncTransitionLanes) {\n            var pendingLanes = root$172.pendingLanes;\n            if (0 === pendingLanes) var JSCompiler_inline_result = 0;\n            else {\n              var suspendedLanes = root$172.suspendedLanes,\n                pingedLanes = root$172.pingedLanes;\n              JSCompiler_inline_result =\n                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;\n              JSCompiler_inline_result &=\n                pendingLanes & ~(suspendedLanes & ~pingedLanes);\n              JSCompiler_inline_result =\n                JSCompiler_inline_result & 201326677\n                  ? (JSCompiler_inline_result & 201326677) | 1\n                  : JSCompiler_inline_result\n                    ? JSCompiler_inline_result | 2\n                    : 0;\n            }\n            0 !== JSCompiler_inline_result &&\n              ((didPerformSomeWork = !0),\n              performSyncWorkOnRoot(root$172, JSCompiler_inline_result));\n          } else\n            (JSCompiler_inline_result = workInProgressRootRenderLanes),\n              (JSCompiler_inline_result = getNextLanes(\n                root$172,\n                root$172 === workInProgressRoot ? JSCompiler_inline_result : 0\n              )),\n              0 === (JSCompiler_inline_result & 3) ||\n                checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) ||\n                ((didPerformSomeWork = !0),\n                performSyncWorkOnRoot(root$172, JSCompiler_inline_result));\n        root$172 = root$172.next;\n      }\n    } while (didPerformSomeWork);\n    isFlushingWork = !1;\n  }\n}\nfunction processRootScheduleInMicrotask() {\n  mightHavePendingSyncWork = didScheduleMicrotask = !1;\n  var syncTransitionLanes = 0;\n  0 !== currentEventTransitionLane &&\n    (shouldAttemptEagerTransition() &&\n      (syncTransitionLanes = currentEventTransitionLane),\n    (currentEventTransitionLane = 0));\n  for (\n    var currentTime = now(), prev = null, root = firstScheduledRoot;\n    null !== root;\n\n  ) {\n    var next = root.next,\n      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n    if (0 === nextLanes)\n      (root.next = null),\n        null === prev ? (firstScheduledRoot = next) : (prev.next = next),\n        null === next && (lastScheduledRoot = prev);\n    else if (\n      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))\n    )\n      mightHavePendingSyncWork = !0;\n    root = next;\n  }\n  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n}\nfunction scheduleTaskForRootDuringMicrotask(root, currentTime) {\n  for (\n    var suspendedLanes = root.suspendedLanes,\n      pingedLanes = root.pingedLanes,\n      expirationTimes = root.expirationTimes,\n      lanes = root.pendingLanes & -62914561;\n    0 < lanes;\n\n  ) {\n    var index$5 = 31 - clz32(lanes),\n      lane = 1 << index$5,\n      expirationTime = expirationTimes[index$5];\n    if (-1 === expirationTime) {\n      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))\n        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);\n    } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n    lanes &= ~lane;\n  }\n  currentTime = workInProgressRoot;\n  suspendedLanes = workInProgressRootRenderLanes;\n  suspendedLanes = getNextLanes(\n    root,\n    root === currentTime ? suspendedLanes : 0\n  );\n  pingedLanes = root.callbackNode;\n  if (\n    0 === suspendedLanes ||\n    (root === currentTime && 2 === workInProgressSuspendedReason) ||\n    null !== root.cancelPendingCommit\n  )\n    return (\n      null !== pingedLanes &&\n        null !== pingedLanes &&\n        cancelCallback$1(pingedLanes),\n      (root.callbackNode = null),\n      (root.callbackPriority = 0)\n    );\n  if (\n    0 === (suspendedLanes & 3) ||\n    checkIfRootIsPrerendering(root, suspendedLanes)\n  ) {\n    currentTime = suspendedLanes & -suspendedLanes;\n    if (currentTime === root.callbackPriority) return currentTime;\n    null !== pingedLanes && cancelCallback$1(pingedLanes);\n    switch (lanesToEventPriority(suspendedLanes)) {\n      case 2:\n      case 8:\n        suspendedLanes = UserBlockingPriority;\n        break;\n      case 32:\n        suspendedLanes = NormalPriority$1;\n        break;\n      case 268435456:\n        suspendedLanes = IdlePriority;\n        break;\n      default:\n        suspendedLanes = NormalPriority$1;\n    }\n    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n    root.callbackPriority = currentTime;\n    root.callbackNode = suspendedLanes;\n    return currentTime;\n  }\n  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);\n  root.callbackPriority = 2;\n  root.callbackNode = null;\n  return 2;\n}\nfunction performWorkOnRootViaSchedulerTask(root, didTimeout) {\n  var originalCallbackNode = root.callbackNode;\n  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)\n    return null;\n  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0\n  );\n  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n  scheduleTaskForRootDuringMicrotask(root, now());\n  return null != root.callbackNode && root.callbackNode === originalCallbackNode\n    ? performWorkOnRootViaSchedulerTask.bind(null, root)\n    : null;\n}\nfunction performSyncWorkOnRoot(root, lanes) {\n  if (flushPassiveEffects()) return null;\n  performWorkOnRoot(root, lanes, !0);\n}\nfunction scheduleImmediateTask(cb) {\n  scheduleMicrotask(function () {\n    0 !== (executionContext & 6)\n      ? scheduleCallback$3(ImmediatePriority, cb)\n      : cb();\n  });\n}\nfunction requestTransitionLane() {\n  0 === currentEventTransitionLane &&\n    (currentEventTransitionLane = claimNextTransitionLane());\n  return currentEventTransitionLane;\n}\nfunction coerceFormActionProp(actionProp) {\n  return null == actionProp ||\n    "symbol" === typeof actionProp ||\n    "boolean" === typeof actionProp\n    ? null\n    : "function" === typeof actionProp\n      ? actionProp\n      : sanitizeURL("" + actionProp);\n}\nfunction createFormDataWithSubmitter(form, submitter) {\n  var temp = submitter.ownerDocument.createElement("input");\n  temp.name = submitter.name;\n  temp.value = submitter.value;\n  form.id && temp.setAttribute("form", form.id);\n  submitter.parentNode.insertBefore(temp, submitter);\n  form = new FormData(form);\n  temp.parentNode.removeChild(temp);\n  return form;\n}\nfunction extractEvents$1(\n  dispatchQueue,\n  domEventName,\n  maybeTargetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  if (\n    "submit" === domEventName &&\n    maybeTargetInst &&\n    maybeTargetInst.stateNode === nativeEventTarget\n  ) {\n    var action = coerceFormActionProp(\n        (nativeEventTarget[internalPropsKey] || null).action\n      ),\n      submitter = nativeEvent.submitter;\n    submitter &&\n      ((domEventName = (domEventName = submitter[internalPropsKey] || null)\n        ? coerceFormActionProp(domEventName.formAction)\n        : submitter.getAttribute("formAction")),\n      null !== domEventName && ((action = domEventName), (submitter = null)));\n    var event = new SyntheticEvent(\n      "action",\n      "action",\n      null,\n      nativeEvent,\n      nativeEventTarget\n    );\n    dispatchQueue.push({\n      event: event,\n      listeners: [\n        {\n          instance: null,\n          listener: function () {\n            if (nativeEvent.defaultPrevented) {\n              if (0 !== currentEventTransitionLane) {\n                var formData = submitter\n                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)\n                  : new FormData(nativeEventTarget);\n                startHostTransition(\n                  maybeTargetInst,\n                  {\n                    pending: !0,\n                    data: formData,\n                    method: nativeEventTarget.method,\n                    action: action\n                  },\n                  null,\n                  formData\n                );\n              }\n            } else\n              "function" === typeof action &&\n                (event.preventDefault(),\n                (formData = submitter\n                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)\n                  : new FormData(nativeEventTarget)),\n                startHostTransition(\n                  maybeTargetInst,\n                  {\n                    pending: !0,\n                    data: formData,\n                    method: nativeEventTarget.method,\n                    action: action\n                  },\n                  action,\n                  formData\n                ));\n          },\n          currentTarget: nativeEventTarget\n        }\n      ]\n    });\n  }\n}\nfor (\n  var i$jscomp$inline_1439 = 0;\n  i$jscomp$inline_1439 < simpleEventPluginEvents.length;\n  i$jscomp$inline_1439++\n) {\n  var eventName$jscomp$inline_1440 =\n      simpleEventPluginEvents[i$jscomp$inline_1439],\n    domEventName$jscomp$inline_1441 =\n      eventName$jscomp$inline_1440.toLowerCase(),\n    capitalizedEvent$jscomp$inline_1442 =\n      eventName$jscomp$inline_1440[0].toUpperCase() +\n      eventName$jscomp$inline_1440.slice(1);\n  registerSimpleEvent(\n    domEventName$jscomp$inline_1441,\n    "on" + capitalizedEvent$jscomp$inline_1442\n  );\n}\nregisterSimpleEvent(ANIMATION_END, "onAnimationEnd");\nregisterSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");\nregisterSimpleEvent(ANIMATION_START, "onAnimationStart");\nregisterSimpleEvent("dblclick", "onDoubleClick");\nregisterSimpleEvent("focusin", "onFocus");\nregisterSimpleEvent("focusout", "onBlur");\nregisterSimpleEvent(TRANSITION_RUN, "onTransitionRun");\nregisterSimpleEvent(TRANSITION_START, "onTransitionStart");\nregisterSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");\nregisterSimpleEvent(TRANSITION_END, "onTransitionEnd");\nregisterDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);\nregisterDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);\nregisterDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);\nregisterDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);\nregisterTwoPhaseEvent(\n  "onChange",\n  "change click focusin focusout input keydown keyup selectionchange".split(" ")\n);\nregisterTwoPhaseEvent(\n  "onSelect",\n  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(\n    " "\n  )\n);\nregisterTwoPhaseEvent("onBeforeInput", [\n  "compositionend",\n  "keypress",\n  "textInput",\n  "paste"\n]);\nregisterTwoPhaseEvent(\n  "onCompositionEnd",\n  "compositionend focusout keydown keypress keyup mousedown".split(" ")\n);\nregisterTwoPhaseEvent(\n  "onCompositionStart",\n  "compositionstart focusout keydown keypress keyup mousedown".split(" ")\n);\nregisterTwoPhaseEvent(\n  "onCompositionUpdate",\n  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")\n);\nvar mediaEventTypes =\n    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(\n      " "\n    ),\n  nonDelegatedEvents = new Set(\n    "beforetoggle cancel close invalid load scroll scrollend toggle"\n      .split(" ")\n      .concat(mediaEventTypes)\n  );\nfunction processDispatchQueue(dispatchQueue, eventSystemFlags) {\n  eventSystemFlags = 0 !== (eventSystemFlags & 4);\n  for (var i = 0; i < dispatchQueue.length; i++) {\n    var _dispatchQueue$i = dispatchQueue[i],\n      event = _dispatchQueue$i.event;\n    _dispatchQueue$i = _dispatchQueue$i.listeners;\n    a: {\n      var previousInstance = void 0;\n      if (eventSystemFlags)\n        for (\n          var i$jscomp$0 = _dispatchQueue$i.length - 1;\n          0 <= i$jscomp$0;\n          i$jscomp$0--\n        ) {\n          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],\n            instance = _dispatchListeners$i.instance,\n            currentTarget = _dispatchListeners$i.currentTarget;\n          _dispatchListeners$i = _dispatchListeners$i.listener;\n          if (instance !== previousInstance && event.isPropagationStopped())\n            break a;\n          previousInstance = _dispatchListeners$i;\n          event.currentTarget = currentTarget;\n          try {\n            previousInstance(event);\n          } catch (error) {\n            reportGlobalError(error);\n          }\n          event.currentTarget = null;\n          previousInstance = instance;\n        }\n      else\n        for (\n          i$jscomp$0 = 0;\n          i$jscomp$0 < _dispatchQueue$i.length;\n          i$jscomp$0++\n        ) {\n          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];\n          instance = _dispatchListeners$i.instance;\n          currentTarget = _dispatchListeners$i.currentTarget;\n          _dispatchListeners$i = _dispatchListeners$i.listener;\n          if (instance !== previousInstance && event.isPropagationStopped())\n            break a;\n          previousInstance = _dispatchListeners$i;\n          event.currentTarget = currentTarget;\n          try {\n            previousInstance(event);\n          } catch (error) {\n            reportGlobalError(error);\n          }\n          event.currentTarget = null;\n          previousInstance = instance;\n        }\n    }\n  }\n}\nfunction listenToNonDelegatedEvent(domEventName, targetElement) {\n  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];\n  void 0 === JSCompiler_inline_result &&\n    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =\n      new Set());\n  var listenerSetKey = domEventName + "__bubble";\n  JSCompiler_inline_result.has(listenerSetKey) ||\n    (addTrappedEventListener(targetElement, domEventName, 2, !1),\n    JSCompiler_inline_result.add(listenerSetKey));\n}\nfunction listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n  var eventSystemFlags = 0;\n  isCapturePhaseListener && (eventSystemFlags |= 4);\n  addTrappedEventListener(\n    target,\n    domEventName,\n    eventSystemFlags,\n    isCapturePhaseListener\n  );\n}\nvar listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);\nfunction listenToAllSupportedEvents(rootContainerElement) {\n  if (!rootContainerElement[listeningMarker]) {\n    rootContainerElement[listeningMarker] = !0;\n    allNativeEvents.forEach(function (domEventName) {\n      "selectionchange" !== domEventName &&\n        (nonDelegatedEvents.has(domEventName) ||\n          listenToNativeEvent(domEventName, !1, rootContainerElement),\n        listenToNativeEvent(domEventName, !0, rootContainerElement));\n    });\n    var ownerDocument =\n      9 === rootContainerElement.nodeType\n        ? rootContainerElement\n        : rootContainerElement.ownerDocument;\n    null === ownerDocument ||\n      ownerDocument[listeningMarker] ||\n      ((ownerDocument[listeningMarker] = !0),\n      listenToNativeEvent("selectionchange", !1, ownerDocument));\n  }\n}\nfunction addTrappedEventListener(\n  targetContainer,\n  domEventName,\n  eventSystemFlags,\n  isCapturePhaseListener\n) {\n  switch (getEventPriority(domEventName)) {\n    case 2:\n      var listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case 8:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    default:\n      listenerWrapper = dispatchEvent;\n  }\n  eventSystemFlags = listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer\n  );\n  listenerWrapper = void 0;\n  !passiveBrowserEventsSupported ||\n    ("touchstart" !== domEventName &&\n      "touchmove" !== domEventName &&\n      "wheel" !== domEventName) ||\n    (listenerWrapper = !0);\n  isCapturePhaseListener\n    ? void 0 !== listenerWrapper\n      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n          capture: !0,\n          passive: listenerWrapper\n        })\n      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)\n    : void 0 !== listenerWrapper\n      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n          passive: listenerWrapper\n        })\n      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);\n}\nfunction dispatchEventForPluginEventSystem(\n  domEventName,\n  eventSystemFlags,\n  nativeEvent,\n  targetInst$jscomp$0,\n  targetContainer\n) {\n  var ancestorInst = targetInst$jscomp$0;\n  if (\n    0 === (eventSystemFlags & 1) &&\n    0 === (eventSystemFlags & 2) &&\n    null !== targetInst$jscomp$0\n  )\n    a: for (;;) {\n      if (null === targetInst$jscomp$0) return;\n      var nodeTag = targetInst$jscomp$0.tag;\n      if (3 === nodeTag || 4 === nodeTag) {\n        var container = targetInst$jscomp$0.stateNode.containerInfo;\n        if (\n          container === targetContainer ||\n          (8 === container.nodeType && container.parentNode === targetContainer)\n        )\n          break;\n        if (4 === nodeTag)\n          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {\n            var grandTag = nodeTag.tag;\n            if (3 === grandTag || 4 === grandTag)\n              if (\n                ((grandTag = nodeTag.stateNode.containerInfo),\n                grandTag === targetContainer ||\n                  (8 === grandTag.nodeType &&\n                    grandTag.parentNode === targetContainer))\n              )\n                return;\n            nodeTag = nodeTag.return;\n          }\n        for (; null !== container; ) {\n          nodeTag = getClosestInstanceFromNode(container);\n          if (null === nodeTag) return;\n          grandTag = nodeTag.tag;\n          if (\n            5 === grandTag ||\n            6 === grandTag ||\n            26 === grandTag ||\n            27 === grandTag\n          ) {\n            targetInst$jscomp$0 = ancestorInst = nodeTag;\n            continue a;\n          }\n          container = container.parentNode;\n        }\n      }\n      targetInst$jscomp$0 = targetInst$jscomp$0.return;\n    }\n  batchedUpdates$1(function () {\n    var targetInst = ancestorInst,\n      nativeEventTarget = getEventTarget(nativeEvent),\n      dispatchQueue = [];\n    a: {\n      var reactName = topLevelEventsToReactNames.get(domEventName);\n      if (void 0 !== reactName) {\n        var SyntheticEventCtor = SyntheticEvent,\n          reactEventType = domEventName;\n        switch (domEventName) {\n          case "keypress":\n            if (0 === getEventCharCode(nativeEvent)) break a;\n          case "keydown":\n          case "keyup":\n            SyntheticEventCtor = SyntheticKeyboardEvent;\n            break;\n          case "focusin":\n            reactEventType = "focus";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case "focusout":\n            reactEventType = "blur";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case "beforeblur":\n          case "afterblur":\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case "click":\n            if (2 === nativeEvent.button) break a;\n          case "auxclick":\n          case "dblclick":\n          case "mousedown":\n          case "mousemove":\n          case "mouseup":\n          case "mouseout":\n          case "mouseover":\n          case "contextmenu":\n            SyntheticEventCtor = SyntheticMouseEvent;\n            break;\n          case "drag":\n          case "dragend":\n          case "dragenter":\n          case "dragexit":\n          case "dragleave":\n          case "dragover":\n          case "dragstart":\n          case "drop":\n            SyntheticEventCtor = SyntheticDragEvent;\n            break;\n          case "touchcancel":\n          case "touchend":\n          case "touchmove":\n          case "touchstart":\n            SyntheticEventCtor = SyntheticTouchEvent;\n            break;\n          case ANIMATION_END:\n          case ANIMATION_ITERATION:\n          case ANIMATION_START:\n            SyntheticEventCtor = SyntheticAnimationEvent;\n            break;\n          case TRANSITION_END:\n            SyntheticEventCtor = SyntheticTransitionEvent;\n            break;\n          case "scroll":\n          case "scrollend":\n            SyntheticEventCtor = SyntheticUIEvent;\n            break;\n          case "wheel":\n            SyntheticEventCtor = SyntheticWheelEvent;\n            break;\n          case "copy":\n          case "cut":\n          case "paste":\n            SyntheticEventCtor = SyntheticClipboardEvent;\n            break;\n          case "gotpointercapture":\n          case "lostpointercapture":\n          case "pointercancel":\n          case "pointerdown":\n          case "pointermove":\n          case "pointerout":\n          case "pointerover":\n          case "pointerup":\n            SyntheticEventCtor = SyntheticPointerEvent;\n            break;\n          case "toggle":\n          case "beforetoggle":\n            SyntheticEventCtor = SyntheticToggleEvent;\n        }\n        var inCapturePhase = 0 !== (eventSystemFlags & 4),\n          accumulateTargetOnly =\n            !inCapturePhase &&\n            ("scroll" === domEventName || "scrollend" === domEventName),\n          reactEventName = inCapturePhase\n            ? null !== reactName\n              ? reactName + "Capture"\n              : null\n            : reactName;\n        inCapturePhase = [];\n        for (\n          var instance = targetInst, lastHostComponent;\n          null !== instance;\n\n        ) {\n          var _instance = instance;\n          lastHostComponent = _instance.stateNode;\n          _instance = _instance.tag;\n          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||\n            null === lastHostComponent ||\n            null === reactEventName ||\n            ((_instance = getListener(instance, reactEventName)),\n            null != _instance &&\n              inCapturePhase.push(\n                createDispatchListener(instance, _instance, lastHostComponent)\n              ));\n          if (accumulateTargetOnly) break;\n          instance = instance.return;\n        }\n        0 < inCapturePhase.length &&\n          ((reactName = new SyntheticEventCtor(\n            reactName,\n            reactEventType,\n            null,\n            nativeEvent,\n            nativeEventTarget\n          )),\n          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));\n      }\n    }\n    if (0 === (eventSystemFlags & 7)) {\n      a: {\n        reactName =\n          "mouseover" === domEventName || "pointerover" === domEventName;\n        SyntheticEventCtor =\n          "mouseout" === domEventName || "pointerout" === domEventName;\n        if (\n          reactName &&\n          nativeEvent !== currentReplayingEvent &&\n          (reactEventType =\n            nativeEvent.relatedTarget || nativeEvent.fromElement) &&\n          (getClosestInstanceFromNode(reactEventType) ||\n            reactEventType[internalContainerInstanceKey])\n        )\n          break a;\n        if (SyntheticEventCtor || reactName) {\n          reactName =\n            nativeEventTarget.window === nativeEventTarget\n              ? nativeEventTarget\n              : (reactName = nativeEventTarget.ownerDocument)\n                ? reactName.defaultView || reactName.parentWindow\n                : window;\n          if (SyntheticEventCtor) {\n            if (\n              ((reactEventType =\n                nativeEvent.relatedTarget || nativeEvent.toElement),\n              (SyntheticEventCtor = targetInst),\n              (reactEventType = reactEventType\n                ? getClosestInstanceFromNode(reactEventType)\n                : null),\n              null !== reactEventType &&\n                ((accumulateTargetOnly =\n                  getNearestMountedFiber(reactEventType)),\n                (inCapturePhase = reactEventType.tag),\n                reactEventType !== accumulateTargetOnly ||\n                  (5 !== inCapturePhase &&\n                    27 !== inCapturePhase &&\n                    6 !== inCapturePhase)))\n            )\n              reactEventType = null;\n          } else (SyntheticEventCtor = null), (reactEventType = targetInst);\n          if (SyntheticEventCtor !== reactEventType) {\n            inCapturePhase = SyntheticMouseEvent;\n            _instance = "onMouseLeave";\n            reactEventName = "onMouseEnter";\n            instance = "mouse";\n            if ("pointerout" === domEventName || "pointerover" === domEventName)\n              (inCapturePhase = SyntheticPointerEvent),\n                (_instance = "onPointerLeave"),\n                (reactEventName = "onPointerEnter"),\n                (instance = "pointer");\n            accumulateTargetOnly =\n              null == SyntheticEventCtor\n                ? reactName\n                : getNodeFromInstance(SyntheticEventCtor);\n            lastHostComponent =\n              null == reactEventType\n                ? reactName\n                : getNodeFromInstance(reactEventType);\n            reactName = new inCapturePhase(\n              _instance,\n              instance + "leave",\n              SyntheticEventCtor,\n              nativeEvent,\n              nativeEventTarget\n            );\n            reactName.target = accumulateTargetOnly;\n            reactName.relatedTarget = lastHostComponent;\n            _instance = null;\n            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&\n              ((inCapturePhase = new inCapturePhase(\n                reactEventName,\n                instance + "enter",\n                reactEventType,\n                nativeEvent,\n                nativeEventTarget\n              )),\n              (inCapturePhase.target = lastHostComponent),\n              (inCapturePhase.relatedTarget = accumulateTargetOnly),\n              (_instance = inCapturePhase));\n            accumulateTargetOnly = _instance;\n            if (SyntheticEventCtor && reactEventType)\n              b: {\n                inCapturePhase = SyntheticEventCtor;\n                reactEventName = reactEventType;\n                instance = 0;\n                for (\n                  lastHostComponent = inCapturePhase;\n                  lastHostComponent;\n                  lastHostComponent = getParent(lastHostComponent)\n                )\n                  instance++;\n                lastHostComponent = 0;\n                for (\n                  _instance = reactEventName;\n                  _instance;\n                  _instance = getParent(_instance)\n                )\n                  lastHostComponent++;\n                for (; 0 < instance - lastHostComponent; )\n                  (inCapturePhase = getParent(inCapturePhase)), instance--;\n                for (; 0 < lastHostComponent - instance; )\n                  (reactEventName = getParent(reactEventName)),\n                    lastHostComponent--;\n                for (; instance--; ) {\n                  if (\n                    inCapturePhase === reactEventName ||\n                    (null !== reactEventName &&\n                      inCapturePhase === reactEventName.alternate)\n                  )\n                    break b;\n                  inCapturePhase = getParent(inCapturePhase);\n                  reactEventName = getParent(reactEventName);\n                }\n                inCapturePhase = null;\n              }\n            else inCapturePhase = null;\n            null !== SyntheticEventCtor &&\n              accumulateEnterLeaveListenersForEvent(\n                dispatchQueue,\n                reactName,\n                SyntheticEventCtor,\n                inCapturePhase,\n                !1\n              );\n            null !== reactEventType &&\n              null !== accumulateTargetOnly &&\n              accumulateEnterLeaveListenersForEvent(\n                dispatchQueue,\n                accumulateTargetOnly,\n                reactEventType,\n                inCapturePhase,\n                !0\n              );\n          }\n        }\n      }\n      a: {\n        reactName = targetInst ? getNodeFromInstance(targetInst) : window;\n        SyntheticEventCtor =\n          reactName.nodeName && reactName.nodeName.toLowerCase();\n        if (\n          "select" === SyntheticEventCtor ||\n          ("input" === SyntheticEventCtor && "file" === reactName.type)\n        )\n          var getTargetInstFunc = getTargetInstForChangeEvent;\n        else if (isTextInputElement(reactName))\n          if (isInputEventSupported)\n            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n          else {\n            getTargetInstFunc = getTargetInstForInputEventPolyfill;\n            var handleEventFunc = handleEventsForInputEventPolyfill;\n          }\n        else\n          (SyntheticEventCtor = reactName.nodeName),\n            !SyntheticEventCtor ||\n            "input" !== SyntheticEventCtor.toLowerCase() ||\n            ("checkbox" !== reactName.type && "radio" !== reactName.type)\n              ? targetInst &&\n                isCustomElement(targetInst.elementType) &&\n                (getTargetInstFunc = getTargetInstForChangeEvent)\n              : (getTargetInstFunc = getTargetInstForClickEvent);\n        if (\n          getTargetInstFunc &&\n          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))\n        ) {\n          createAndAccumulateChangeEvent(\n            dispatchQueue,\n            getTargetInstFunc,\n            nativeEvent,\n            nativeEventTarget\n          );\n          break a;\n        }\n        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);\n        "focusout" === domEventName &&\n          targetInst &&\n          "number" === reactName.type &&\n          null != targetInst.memoizedProps.value &&\n          setDefaultValue(reactName, "number", reactName.value);\n      }\n      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;\n      switch (domEventName) {\n        case "focusin":\n          if (\n            isTextInputElement(handleEventFunc) ||\n            "true" === handleEventFunc.contentEditable\n          )\n            (activeElement = handleEventFunc),\n              (activeElementInst = targetInst),\n              (lastSelection = null);\n          break;\n        case "focusout":\n          lastSelection = activeElementInst = activeElement = null;\n          break;\n        case "mousedown":\n          mouseDown = !0;\n          break;\n        case "contextmenu":\n        case "mouseup":\n        case "dragend":\n          mouseDown = !1;\n          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n          break;\n        case "selectionchange":\n          if (skipSelectionChangeEvent) break;\n        case "keydown":\n        case "keyup":\n          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n      }\n      var fallbackData;\n      if (canUseCompositionEvent)\n        b: {\n          switch (domEventName) {\n            case "compositionstart":\n              var eventType = "onCompositionStart";\n              break b;\n            case "compositionend":\n              eventType = "onCompositionEnd";\n              break b;\n            case "compositionupdate":\n              eventType = "onCompositionUpdate";\n              break b;\n          }\n          eventType = void 0;\n        }\n      else\n        isComposing\n          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&\n            (eventType = "onCompositionEnd")\n          : "keydown" === domEventName &&\n            229 === nativeEvent.keyCode &&\n            (eventType = "onCompositionStart");\n      eventType &&\n        (useFallbackCompositionData &&\n          "ko" !== nativeEvent.locale &&\n          (isComposing || "onCompositionStart" !== eventType\n            ? "onCompositionEnd" === eventType &&\n              isComposing &&\n              (fallbackData = getData())\n            : ((root = nativeEventTarget),\n              (startText = "value" in root ? root.value : root.textContent),\n              (isComposing = !0))),\n        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),\n        0 < handleEventFunc.length &&\n          ((eventType = new SyntheticCompositionEvent(\n            eventType,\n            domEventName,\n            null,\n            nativeEvent,\n            nativeEventTarget\n          )),\n          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),\n          fallbackData\n            ? (eventType.data = fallbackData)\n            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),\n              null !== fallbackData && (eventType.data = fallbackData))));\n      if (\n        (fallbackData = canUseTextInputEvent\n          ? getNativeBeforeInputChars(domEventName, nativeEvent)\n          : getFallbackBeforeInputChars(domEventName, nativeEvent))\n      )\n        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),\n          0 < eventType.length &&\n            ((handleEventFunc = new SyntheticCompositionEvent(\n              "onBeforeInput",\n              "beforeinput",\n              null,\n              nativeEvent,\n              nativeEventTarget\n            )),\n            dispatchQueue.push({\n              event: handleEventFunc,\n              listeners: eventType\n            }),\n            (handleEventFunc.data = fallbackData));\n      extractEvents$1(\n        dispatchQueue,\n        domEventName,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n    }\n    processDispatchQueue(dispatchQueue, eventSystemFlags);\n  });\n}\nfunction createDispatchListener(instance, listener, currentTarget) {\n  return {\n    instance: instance,\n    listener: listener,\n    currentTarget: currentTarget\n  };\n}\nfunction accumulateTwoPhaseListeners(targetFiber, reactName) {\n  for (\n    var captureName = reactName + "Capture", listeners = [];\n    null !== targetFiber;\n\n  ) {\n    var _instance2 = targetFiber,\n      stateNode = _instance2.stateNode;\n    _instance2 = _instance2.tag;\n    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||\n      null === stateNode ||\n      ((_instance2 = getListener(targetFiber, captureName)),\n      null != _instance2 &&\n        listeners.unshift(\n          createDispatchListener(targetFiber, _instance2, stateNode)\n        ),\n      (_instance2 = getListener(targetFiber, reactName)),\n      null != _instance2 &&\n        listeners.push(\n          createDispatchListener(targetFiber, _instance2, stateNode)\n        ));\n    targetFiber = targetFiber.return;\n  }\n  return listeners;\n}\nfunction getParent(inst) {\n  if (null === inst) return null;\n  do inst = inst.return;\n  while (inst && 5 !== inst.tag && 27 !== inst.tag);\n  return inst ? inst : null;\n}\nfunction accumulateEnterLeaveListenersForEvent(\n  dispatchQueue,\n  event,\n  target,\n  common,\n  inCapturePhase\n) {\n  for (\n    var registrationName = event._reactName, listeners = [];\n    null !== target && target !== common;\n\n  ) {\n    var _instance3 = target,\n      alternate = _instance3.alternate,\n      stateNode = _instance3.stateNode;\n    _instance3 = _instance3.tag;\n    if (null !== alternate && alternate === common) break;\n    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||\n      null === stateNode ||\n      ((alternate = stateNode),\n      inCapturePhase\n        ? ((stateNode = getListener(target, registrationName)),\n          null != stateNode &&\n            listeners.unshift(\n              createDispatchListener(target, stateNode, alternate)\n            ))\n        : inCapturePhase ||\n          ((stateNode = getListener(target, registrationName)),\n          null != stateNode &&\n            listeners.push(\n              createDispatchListener(target, stateNode, alternate)\n            )));\n    target = target.return;\n  }\n  0 !== listeners.length &&\n    dispatchQueue.push({ event: event, listeners: listeners });\n}\nvar NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g,\n  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\nfunction normalizeMarkupForTextOrAttribute(markup) {\n  return ("string" === typeof markup ? markup : "" + markup)\n    .replace(NORMALIZE_NEWLINES_REGEX, "\\n")\n    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");\n}\nfunction checkForUnmatchedText(serverText, clientText) {\n  clientText = normalizeMarkupForTextOrAttribute(clientText);\n  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;\n}\nfunction noop$1() {}\nfunction setProp(domElement, tag, key, value, props, prevValue) {\n  switch (key) {\n    case "children":\n      "string" === typeof value\n        ? "body" === tag ||\n          ("textarea" === tag && "" === value) ||\n          setTextContent(domElement, value)\n        : ("number" === typeof value || "bigint" === typeof value) &&\n          "body" !== tag &&\n          setTextContent(domElement, "" + value);\n      break;\n    case "className":\n      setValueForKnownAttribute(domElement, "class", value);\n      break;\n    case "tabIndex":\n      setValueForKnownAttribute(domElement, "tabindex", value);\n      break;\n    case "dir":\n    case "role":\n    case "viewBox":\n    case "width":\n    case "height":\n      setValueForKnownAttribute(domElement, key, value);\n      break;\n    case "style":\n      setValueForStyles(domElement, value, prevValue);\n      break;\n    case "data":\n      if ("object" !== tag) {\n        setValueForKnownAttribute(domElement, "data", value);\n        break;\n      }\n    case "src":\n    case "href":\n      if ("" === value && ("a" !== tag || "href" !== key)) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      if (\n        null == value ||\n        "function" === typeof value ||\n        "symbol" === typeof value ||\n        "boolean" === typeof value\n      ) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      value = sanitizeURL("" + value);\n      domElement.setAttribute(key, value);\n      break;\n    case "action":\n    case "formAction":\n      if ("function" === typeof value) {\n        domElement.setAttribute(\n          key,\n          "javascript:throw new Error(\'A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\\\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().\')"\n        );\n        break;\n      } else\n        "function" === typeof prevValue &&\n          ("formAction" === key\n            ? ("input" !== tag &&\n                setProp(domElement, tag, "name", props.name, props, null),\n              setProp(\n                domElement,\n                tag,\n                "formEncType",\n                props.formEncType,\n                props,\n                null\n              ),\n              setProp(\n                domElement,\n                tag,\n                "formMethod",\n                props.formMethod,\n                props,\n                null\n              ),\n              setProp(\n                domElement,\n                tag,\n                "formTarget",\n                props.formTarget,\n                props,\n                null\n              ))\n            : (setProp(domElement, tag, "encType", props.encType, props, null),\n              setProp(domElement, tag, "method", props.method, props, null),\n              setProp(domElement, tag, "target", props.target, props, null)));\n      if (\n        null == value ||\n        "symbol" === typeof value ||\n        "boolean" === typeof value\n      ) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      value = sanitizeURL("" + value);\n      domElement.setAttribute(key, value);\n      break;\n    case "onClick":\n      null != value && (domElement.onclick = noop$1);\n      break;\n    case "onScroll":\n      null != value && listenToNonDelegatedEvent("scroll", domElement);\n      break;\n    case "onScrollEnd":\n      null != value && listenToNonDelegatedEvent("scrollend", domElement);\n      break;\n    case "dangerouslySetInnerHTML":\n      if (null != value) {\n        if ("object" !== typeof value || !("__html" in value))\n          throw Error(formatProdErrorMessage(61));\n        key = value.__html;\n        if (null != key) {\n          if (null != props.children) throw Error(formatProdErrorMessage(60));\n          domElement.innerHTML = key;\n        }\n      }\n      break;\n    case "multiple":\n      domElement.multiple =\n        value && "function" !== typeof value && "symbol" !== typeof value;\n      break;\n    case "muted":\n      domElement.muted =\n        value && "function" !== typeof value && "symbol" !== typeof value;\n      break;\n    case "suppressContentEditableWarning":\n    case "suppressHydrationWarning":\n    case "defaultValue":\n    case "defaultChecked":\n    case "innerHTML":\n    case "ref":\n      break;\n    case "autoFocus":\n      break;\n    case "xlinkHref":\n      if (\n        null == value ||\n        "function" === typeof value ||\n        "boolean" === typeof value ||\n        "symbol" === typeof value\n      ) {\n        domElement.removeAttribute("xlink:href");\n        break;\n      }\n      key = sanitizeURL("" + value);\n      domElement.setAttributeNS(\n        "http://www.w3.org/1999/xlink",\n        "xlink:href",\n        key\n      );\n      break;\n    case "contentEditable":\n    case "spellCheck":\n    case "draggable":\n    case "value":\n    case "autoReverse":\n    case "externalResourcesRequired":\n    case "focusable":\n    case "preserveAlpha":\n      null != value && "function" !== typeof value && "symbol" !== typeof value\n        ? domElement.setAttribute(key, "" + value)\n        : domElement.removeAttribute(key);\n      break;\n    case "inert":\n    case "allowFullScreen":\n    case "async":\n    case "autoPlay":\n    case "controls":\n    case "default":\n    case "defer":\n    case "disabled":\n    case "disablePictureInPicture":\n    case "disableRemotePlayback":\n    case "formNoValidate":\n    case "hidden":\n    case "loop":\n    case "noModule":\n    case "noValidate":\n    case "open":\n    case "playsInline":\n    case "readOnly":\n    case "required":\n    case "reversed":\n    case "scoped":\n    case "seamless":\n    case "itemScope":\n      value && "function" !== typeof value && "symbol" !== typeof value\n        ? domElement.setAttribute(key, "")\n        : domElement.removeAttribute(key);\n      break;\n    case "capture":\n    case "download":\n      !0 === value\n        ? domElement.setAttribute(key, "")\n        : !1 !== value &&\n            null != value &&\n            "function" !== typeof value &&\n            "symbol" !== typeof value\n          ? domElement.setAttribute(key, value)\n          : domElement.removeAttribute(key);\n      break;\n    case "cols":\n    case "rows":\n    case "size":\n    case "span":\n      null != value &&\n      "function" !== typeof value &&\n      "symbol" !== typeof value &&\n      !isNaN(value) &&\n      1 <= value\n        ? domElement.setAttribute(key, value)\n        : domElement.removeAttribute(key);\n      break;\n    case "rowSpan":\n    case "start":\n      null == value ||\n      "function" === typeof value ||\n      "symbol" === typeof value ||\n      isNaN(value)\n        ? domElement.removeAttribute(key)\n        : domElement.setAttribute(key, value);\n      break;\n    case "popover":\n      listenToNonDelegatedEvent("beforetoggle", domElement);\n      listenToNonDelegatedEvent("toggle", domElement);\n      setValueForAttribute(domElement, "popover", value);\n      break;\n    case "xlinkActuate":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:actuate",\n        value\n      );\n      break;\n    case "xlinkArcrole":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:arcrole",\n        value\n      );\n      break;\n    case "xlinkRole":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:role",\n        value\n      );\n      break;\n    case "xlinkShow":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:show",\n        value\n      );\n      break;\n    case "xlinkTitle":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:title",\n        value\n      );\n      break;\n    case "xlinkType":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:type",\n        value\n      );\n      break;\n    case "xmlBase":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/XML/1998/namespace",\n        "xml:base",\n        value\n      );\n      break;\n    case "xmlLang":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/XML/1998/namespace",\n        "xml:lang",\n        value\n      );\n      break;\n    case "xmlSpace":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/XML/1998/namespace",\n        "xml:space",\n        value\n      );\n      break;\n    case "is":\n      setValueForAttribute(domElement, "is", value);\n      break;\n    case "innerText":\n    case "textContent":\n      break;\n    default:\n      if (\n        !(2 < key.length) ||\n        ("o" !== key[0] && "O" !== key[0]) ||\n        ("n" !== key[1] && "N" !== key[1])\n      )\n        (key = aliases.get(key) || key),\n          setValueForAttribute(domElement, key, value);\n  }\n}\nfunction setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {\n  switch (key) {\n    case "style":\n      setValueForStyles(domElement, value, prevValue);\n      break;\n    case "dangerouslySetInnerHTML":\n      if (null != value) {\n        if ("object" !== typeof value || !("__html" in value))\n          throw Error(formatProdErrorMessage(61));\n        key = value.__html;\n        if (null != key) {\n          if (null != props.children) throw Error(formatProdErrorMessage(60));\n          domElement.innerHTML = key;\n        }\n      }\n      break;\n    case "children":\n      "string" === typeof value\n        ? setTextContent(domElement, value)\n        : ("number" === typeof value || "bigint" === typeof value) &&\n          setTextContent(domElement, "" + value);\n      break;\n    case "onScroll":\n      null != value && listenToNonDelegatedEvent("scroll", domElement);\n      break;\n    case "onScrollEnd":\n      null != value && listenToNonDelegatedEvent("scrollend", domElement);\n      break;\n    case "onClick":\n      null != value && (domElement.onclick = noop$1);\n      break;\n    case "suppressContentEditableWarning":\n    case "suppressHydrationWarning":\n    case "innerHTML":\n    case "ref":\n      break;\n    case "innerText":\n    case "textContent":\n      break;\n    default:\n      if (!registrationNameDependencies.hasOwnProperty(key))\n        a: {\n          if (\n            "o" === key[0] &&\n            "n" === key[1] &&\n            ((props = key.endsWith("Capture")),\n            (tag = key.slice(2, props ? key.length - 7 : void 0)),\n            (prevValue = domElement[internalPropsKey] || null),\n            (prevValue = null != prevValue ? prevValue[key] : null),\n            "function" === typeof prevValue &&\n              domElement.removeEventListener(tag, prevValue, props),\n            "function" === typeof value)\n          ) {\n            "function" !== typeof prevValue &&\n              null !== prevValue &&\n              (key in domElement\n                ? (domElement[key] = null)\n                : domElement.hasAttribute(key) &&\n                  domElement.removeAttribute(key));\n            domElement.addEventListener(tag, value, props);\n            break a;\n          }\n          key in domElement\n            ? (domElement[key] = value)\n            : !0 === value\n              ? domElement.setAttribute(key, "")\n              : setValueForAttribute(domElement, key, value);\n        }\n  }\n}\nfunction setInitialProperties(domElement, tag, props) {\n  switch (tag) {\n    case "div":\n    case "span":\n    case "svg":\n    case "path":\n    case "a":\n    case "g":\n    case "p":\n    case "li":\n      break;\n    case "img":\n      listenToNonDelegatedEvent("error", domElement);\n      listenToNonDelegatedEvent("load", domElement);\n      var hasSrc = !1,\n        hasSrcSet = !1,\n        propKey;\n      for (propKey in props)\n        if (props.hasOwnProperty(propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case "src":\n                hasSrc = !0;\n                break;\n              case "srcSet":\n                hasSrcSet = !0;\n                break;\n              case "children":\n              case "dangerouslySetInnerHTML":\n                throw Error(formatProdErrorMessage(137, tag));\n              default:\n                setProp(domElement, tag, propKey, propValue, props, null);\n            }\n        }\n      hasSrcSet &&\n        setProp(domElement, tag, "srcSet", props.srcSet, props, null);\n      hasSrc && setProp(domElement, tag, "src", props.src, props, null);\n      return;\n    case "input":\n      listenToNonDelegatedEvent("invalid", domElement);\n      var defaultValue = (propKey = propValue = hasSrcSet = null),\n        checked = null,\n        defaultChecked = null;\n      for (hasSrc in props)\n        if (props.hasOwnProperty(hasSrc)) {\n          var propValue$186 = props[hasSrc];\n          if (null != propValue$186)\n            switch (hasSrc) {\n              case "name":\n                hasSrcSet = propValue$186;\n                break;\n              case "type":\n                propValue = propValue$186;\n                break;\n              case "checked":\n                checked = propValue$186;\n                break;\n              case "defaultChecked":\n                defaultChecked = propValue$186;\n                break;\n              case "value":\n                propKey = propValue$186;\n                break;\n              case "defaultValue":\n                defaultValue = propValue$186;\n                break;\n              case "children":\n              case "dangerouslySetInnerHTML":\n                if (null != propValue$186)\n                  throw Error(formatProdErrorMessage(137, tag));\n                break;\n              default:\n                setProp(domElement, tag, hasSrc, propValue$186, props, null);\n            }\n        }\n      initInput(\n        domElement,\n        propKey,\n        defaultValue,\n        checked,\n        defaultChecked,\n        propValue,\n        hasSrcSet,\n        !1\n      );\n      track(domElement);\n      return;\n    case "select":\n      listenToNonDelegatedEvent("invalid", domElement);\n      hasSrc = propValue = propKey = null;\n      for (hasSrcSet in props)\n        if (\n          props.hasOwnProperty(hasSrcSet) &&\n          ((defaultValue = props[hasSrcSet]), null != defaultValue)\n        )\n          switch (hasSrcSet) {\n            case "value":\n              propKey = defaultValue;\n              break;\n            case "defaultValue":\n              propValue = defaultValue;\n              break;\n            case "multiple":\n              hasSrc = defaultValue;\n            default:\n              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);\n          }\n      tag = propKey;\n      props = propValue;\n      domElement.multiple = !!hasSrc;\n      null != tag\n        ? updateOptions(domElement, !!hasSrc, tag, !1)\n        : null != props && updateOptions(domElement, !!hasSrc, props, !0);\n      return;\n    case "textarea":\n      listenToNonDelegatedEvent("invalid", domElement);\n      propKey = hasSrcSet = hasSrc = null;\n      for (propValue in props)\n        if (\n          props.hasOwnProperty(propValue) &&\n          ((defaultValue = props[propValue]), null != defaultValue)\n        )\n          switch (propValue) {\n            case "value":\n              hasSrc = defaultValue;\n              break;\n            case "defaultValue":\n              hasSrcSet = defaultValue;\n              break;\n            case "children":\n              propKey = defaultValue;\n              break;\n            case "dangerouslySetInnerHTML":\n              if (null != defaultValue) throw Error(formatProdErrorMessage(91));\n              break;\n            default:\n              setProp(domElement, tag, propValue, defaultValue, props, null);\n          }\n      initTextarea(domElement, hasSrc, hasSrcSet, propKey);\n      track(domElement);\n      return;\n    case "option":\n      for (checked in props)\n        if (\n          props.hasOwnProperty(checked) &&\n          ((hasSrc = props[checked]), null != hasSrc)\n        )\n          switch (checked) {\n            case "selected":\n              domElement.selected =\n                hasSrc &&\n                "function" !== typeof hasSrc &&\n                "symbol" !== typeof hasSrc;\n              break;\n            default:\n              setProp(domElement, tag, checked, hasSrc, props, null);\n          }\n      return;\n    case "dialog":\n      listenToNonDelegatedEvent("cancel", domElement);\n      listenToNonDelegatedEvent("close", domElement);\n      break;\n    case "iframe":\n    case "object":\n      listenToNonDelegatedEvent("load", domElement);\n      break;\n    case "video":\n    case "audio":\n      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)\n        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);\n      break;\n    case "image":\n      listenToNonDelegatedEvent("error", domElement);\n      listenToNonDelegatedEvent("load", domElement);\n      break;\n    case "details":\n      listenToNonDelegatedEvent("toggle", domElement);\n      break;\n    case "embed":\n    case "source":\n    case "link":\n      listenToNonDelegatedEvent("error", domElement),\n        listenToNonDelegatedEvent("load", domElement);\n    case "area":\n    case "base":\n    case "br":\n    case "col":\n    case "hr":\n    case "keygen":\n    case "meta":\n    case "param":\n    case "track":\n    case "wbr":\n    case "menuitem":\n      for (defaultChecked in props)\n        if (\n          props.hasOwnProperty(defaultChecked) &&\n          ((hasSrc = props[defaultChecked]), null != hasSrc)\n        )\n          switch (defaultChecked) {\n            case "children":\n            case "dangerouslySetInnerHTML":\n              throw Error(formatProdErrorMessage(137, tag));\n            default:\n              setProp(domElement, tag, defaultChecked, hasSrc, props, null);\n          }\n      return;\n    default:\n      if (isCustomElement(tag)) {\n        for (propValue$186 in props)\n          props.hasOwnProperty(propValue$186) &&\n            ((hasSrc = props[propValue$186]),\n            void 0 !== hasSrc &&\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                propValue$186,\n                hasSrc,\n                props,\n                void 0\n              ));\n        return;\n      }\n  }\n  for (defaultValue in props)\n    props.hasOwnProperty(defaultValue) &&\n      ((hasSrc = props[defaultValue]),\n      null != hasSrc &&\n        setProp(domElement, tag, defaultValue, hasSrc, props, null));\n}\nfunction updateProperties(domElement, tag, lastProps, nextProps) {\n  switch (tag) {\n    case "div":\n    case "span":\n    case "svg":\n    case "path":\n    case "a":\n    case "g":\n    case "p":\n    case "li":\n      break;\n    case "input":\n      var name = null,\n        type = null,\n        value = null,\n        defaultValue = null,\n        lastDefaultValue = null,\n        checked = null,\n        defaultChecked = null;\n      for (propKey in lastProps) {\n        var lastProp = lastProps[propKey];\n        if (lastProps.hasOwnProperty(propKey) && null != lastProp)\n          switch (propKey) {\n            case "checked":\n              break;\n            case "value":\n              break;\n            case "defaultValue":\n              lastDefaultValue = lastProp;\n            default:\n              nextProps.hasOwnProperty(propKey) ||\n                setProp(domElement, tag, propKey, null, nextProps, lastProp);\n          }\n      }\n      for (var propKey$203 in nextProps) {\n        var propKey = nextProps[propKey$203];\n        lastProp = lastProps[propKey$203];\n        if (\n          nextProps.hasOwnProperty(propKey$203) &&\n          (null != propKey || null != lastProp)\n        )\n          switch (propKey$203) {\n            case "type":\n              type = propKey;\n              break;\n            case "name":\n              name = propKey;\n              break;\n            case "checked":\n              checked = propKey;\n              break;\n            case "defaultChecked":\n              defaultChecked = propKey;\n              break;\n            case "value":\n              value = propKey;\n              break;\n            case "defaultValue":\n              defaultValue = propKey;\n              break;\n            case "children":\n            case "dangerouslySetInnerHTML":\n              if (null != propKey)\n                throw Error(formatProdErrorMessage(137, tag));\n              break;\n            default:\n              propKey !== lastProp &&\n                setProp(\n                  domElement,\n                  tag,\n                  propKey$203,\n                  propKey,\n                  nextProps,\n                  lastProp\n                );\n          }\n      }\n      updateInput(\n        domElement,\n        value,\n        defaultValue,\n        lastDefaultValue,\n        checked,\n        defaultChecked,\n        type,\n        name\n      );\n      return;\n    case "select":\n      propKey = value = defaultValue = propKey$203 = null;\n      for (type in lastProps)\n        if (\n          ((lastDefaultValue = lastProps[type]),\n          lastProps.hasOwnProperty(type) && null != lastDefaultValue)\n        )\n          switch (type) {\n            case "value":\n              break;\n            case "multiple":\n              propKey = lastDefaultValue;\n            default:\n              nextProps.hasOwnProperty(type) ||\n                setProp(\n                  domElement,\n                  tag,\n                  type,\n                  null,\n                  nextProps,\n                  lastDefaultValue\n                );\n          }\n      for (name in nextProps)\n        if (\n          ((type = nextProps[name]),\n          (lastDefaultValue = lastProps[name]),\n          nextProps.hasOwnProperty(name) &&\n            (null != type || null != lastDefaultValue))\n        )\n          switch (name) {\n            case "value":\n              propKey$203 = type;\n              break;\n            case "defaultValue":\n              defaultValue = type;\n              break;\n            case "multiple":\n              value = type;\n            default:\n              type !== lastDefaultValue &&\n                setProp(\n                  domElement,\n                  tag,\n                  name,\n                  type,\n                  nextProps,\n                  lastDefaultValue\n                );\n          }\n      tag = defaultValue;\n      lastProps = value;\n      nextProps = propKey;\n      null != propKey$203\n        ? updateOptions(domElement, !!lastProps, propKey$203, !1)\n        : !!nextProps !== !!lastProps &&\n          (null != tag\n            ? updateOptions(domElement, !!lastProps, tag, !0)\n            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));\n      return;\n    case "textarea":\n      propKey = propKey$203 = null;\n      for (defaultValue in lastProps)\n        if (\n          ((name = lastProps[defaultValue]),\n          lastProps.hasOwnProperty(defaultValue) &&\n            null != name &&\n            !nextProps.hasOwnProperty(defaultValue))\n        )\n          switch (defaultValue) {\n            case "value":\n              break;\n            case "children":\n              break;\n            default:\n              setProp(domElement, tag, defaultValue, null, nextProps, name);\n          }\n      for (value in nextProps)\n        if (\n          ((name = nextProps[value]),\n          (type = lastProps[value]),\n          nextProps.hasOwnProperty(value) && (null != name || null != type))\n        )\n          switch (value) {\n            case "value":\n              propKey$203 = name;\n              break;\n            case "defaultValue":\n              propKey = name;\n              break;\n            case "children":\n              break;\n            case "dangerouslySetInnerHTML":\n              if (null != name) throw Error(formatProdErrorMessage(91));\n              break;\n            default:\n              name !== type &&\n                setProp(domElement, tag, value, name, nextProps, type);\n          }\n      updateTextarea(domElement, propKey$203, propKey);\n      return;\n    case "option":\n      for (var propKey$219 in lastProps)\n        if (\n          ((propKey$203 = lastProps[propKey$219]),\n          lastProps.hasOwnProperty(propKey$219) &&\n            null != propKey$203 &&\n            !nextProps.hasOwnProperty(propKey$219))\n        )\n          switch (propKey$219) {\n            case "selected":\n              domElement.selected = !1;\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                propKey$219,\n                null,\n                nextProps,\n                propKey$203\n              );\n          }\n      for (lastDefaultValue in nextProps)\n        if (\n          ((propKey$203 = nextProps[lastDefaultValue]),\n          (propKey = lastProps[lastDefaultValue]),\n          nextProps.hasOwnProperty(lastDefaultValue) &&\n            propKey$203 !== propKey &&\n            (null != propKey$203 || null != propKey))\n        )\n          switch (lastDefaultValue) {\n            case "selected":\n              domElement.selected =\n                propKey$203 &&\n                "function" !== typeof propKey$203 &&\n                "symbol" !== typeof propKey$203;\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                lastDefaultValue,\n                propKey$203,\n                nextProps,\n                propKey\n              );\n          }\n      return;\n    case "img":\n    case "link":\n    case "area":\n    case "base":\n    case "br":\n    case "col":\n    case "embed":\n    case "hr":\n    case "keygen":\n    case "meta":\n    case "param":\n    case "source":\n    case "track":\n    case "wbr":\n    case "menuitem":\n      for (var propKey$224 in lastProps)\n        (propKey$203 = lastProps[propKey$224]),\n          lastProps.hasOwnProperty(propKey$224) &&\n            null != propKey$203 &&\n            !nextProps.hasOwnProperty(propKey$224) &&\n            setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);\n      for (checked in nextProps)\n        if (\n          ((propKey$203 = nextProps[checked]),\n          (propKey = lastProps[checked]),\n          nextProps.hasOwnProperty(checked) &&\n            propKey$203 !== propKey &&\n            (null != propKey$203 || null != propKey))\n        )\n          switch (checked) {\n            case "children":\n            case "dangerouslySetInnerHTML":\n              if (null != propKey$203)\n                throw Error(formatProdErrorMessage(137, tag));\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                checked,\n                propKey$203,\n                nextProps,\n                propKey\n              );\n          }\n      return;\n    default:\n      if (isCustomElement(tag)) {\n        for (var propKey$229 in lastProps)\n          (propKey$203 = lastProps[propKey$229]),\n            lastProps.hasOwnProperty(propKey$229) &&\n              void 0 !== propKey$203 &&\n              !nextProps.hasOwnProperty(propKey$229) &&\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                propKey$229,\n                void 0,\n                nextProps,\n                propKey$203\n              );\n        for (defaultChecked in nextProps)\n          (propKey$203 = nextProps[defaultChecked]),\n            (propKey = lastProps[defaultChecked]),\n            !nextProps.hasOwnProperty(defaultChecked) ||\n              propKey$203 === propKey ||\n              (void 0 === propKey$203 && void 0 === propKey) ||\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                defaultChecked,\n                propKey$203,\n                nextProps,\n                propKey\n              );\n        return;\n      }\n  }\n  for (var propKey$234 in lastProps)\n    (propKey$203 = lastProps[propKey$234]),\n      lastProps.hasOwnProperty(propKey$234) &&\n        null != propKey$203 &&\n        !nextProps.hasOwnProperty(propKey$234) &&\n        setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);\n  for (lastProp in nextProps)\n    (propKey$203 = nextProps[lastProp]),\n      (propKey = lastProps[lastProp]),\n      !nextProps.hasOwnProperty(lastProp) ||\n        propKey$203 === propKey ||\n        (null == propKey$203 && null == propKey) ||\n        setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);\n}\nvar eventsEnabled = null,\n  selectionInformation = null;\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return 9 === rootContainerElement.nodeType\n    ? rootContainerElement\n    : rootContainerElement.ownerDocument;\n}\nfunction getOwnHostContext(namespaceURI) {\n  switch (namespaceURI) {\n    case "http://www.w3.org/2000/svg":\n      return 1;\n    case "http://www.w3.org/1998/Math/MathML":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getChildHostContextProd(parentNamespace, type) {\n  if (0 === parentNamespace)\n    switch (type) {\n      case "svg":\n        return 1;\n      case "math":\n        return 2;\n      default:\n        return 0;\n    }\n  return 1 === parentNamespace && "foreignObject" === type\n    ? 0\n    : parentNamespace;\n}\nfunction shouldSetTextContent(type, props) {\n  return (\n    "textarea" === type ||\n    "noscript" === type ||\n    "string" === typeof props.children ||\n    "number" === typeof props.children ||\n    "bigint" === typeof props.children ||\n    ("object" === typeof props.dangerouslySetInnerHTML &&\n      null !== props.dangerouslySetInnerHTML &&\n      null != props.dangerouslySetInnerHTML.__html)\n  );\n}\nvar currentPopstateTransitionEvent = null;\nfunction shouldAttemptEagerTransition() {\n  var event = window.event;\n  if (event && "popstate" === event.type) {\n    if (event === currentPopstateTransitionEvent) return !1;\n    currentPopstateTransitionEvent = event;\n    return !0;\n  }\n  currentPopstateTransitionEvent = null;\n  return !1;\n}\nvar scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,\n  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,\n  localPromise = "function" === typeof Promise ? Promise : void 0,\n  scheduleMicrotask =\n    "function" === typeof queueMicrotask\n      ? queueMicrotask\n      : "undefined" !== typeof localPromise\n        ? function (callback) {\n            return localPromise\n              .resolve(null)\n              .then(callback)\n              .catch(handleErrorInNextTick);\n          }\n        : scheduleTimeout;\nfunction handleErrorInNextTick(error) {\n  setTimeout(function () {\n    throw error;\n  });\n}\nfunction clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  var node = suspenseInstance,\n    depth = 0;\n  do {\n    var nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && 8 === nextNode.nodeType)\n      if (((node = nextNode.data), "/$" === node)) {\n        if (0 === depth) {\n          parentInstance.removeChild(nextNode);\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        }\n        depth--;\n      } else ("$" !== node && "$?" !== node && "$!" !== node) || depth++;\n    node = nextNode;\n  } while (node);\n  retryIfBlockedOn(suspenseInstance);\n}\nfunction clearContainerSparingly(container) {\n  var nextNode = container.firstChild;\n  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);\n  for (; nextNode; ) {\n    var node = nextNode;\n    nextNode = nextNode.nextSibling;\n    switch (node.nodeName) {\n      case "HTML":\n      case "HEAD":\n      case "BODY":\n        clearContainerSparingly(node);\n        detachDeletedInstance(node);\n        continue;\n      case "SCRIPT":\n      case "STYLE":\n        continue;\n      case "LINK":\n        if ("stylesheet" === node.rel.toLowerCase()) continue;\n    }\n    container.removeChild(node);\n  }\n}\nfunction canHydrateInstance(instance, type, props, inRootOrSingleton) {\n  for (; 1 === instance.nodeType; ) {\n    var anyProps = props;\n    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {\n      if (\n        !inRootOrSingleton &&\n        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)\n      )\n        break;\n    } else if (!inRootOrSingleton)\n      if ("input" === type && "hidden" === instance.type) {\n        var name = null == anyProps.name ? null : "" + anyProps.name;\n        if (\n          "hidden" === anyProps.type &&\n          instance.getAttribute("name") === name\n        )\n          return instance;\n      } else return instance;\n    else if (!instance[internalHoistableMarker])\n      switch (type) {\n        case "meta":\n          if (!instance.hasAttribute("itemprop")) break;\n          return instance;\n        case "link":\n          name = instance.getAttribute("rel");\n          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))\n            break;\n          else if (\n            name !== anyProps.rel ||\n            instance.getAttribute("href") !==\n              (null == anyProps.href ? null : anyProps.href) ||\n            instance.getAttribute("crossorigin") !==\n              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||\n            instance.getAttribute("title") !==\n              (null == anyProps.title ? null : anyProps.title)\n          )\n            break;\n          return instance;\n        case "style":\n          if (instance.hasAttribute("data-precedence")) break;\n          return instance;\n        case "script":\n          name = instance.getAttribute("src");\n          if (\n            (name !== (null == anyProps.src ? null : anyProps.src) ||\n              instance.getAttribute("type") !==\n                (null == anyProps.type ? null : anyProps.type) ||\n              instance.getAttribute("crossorigin") !==\n                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&\n            name &&\n            instance.hasAttribute("async") &&\n            !instance.hasAttribute("itemprop")\n          )\n            break;\n          return instance;\n        default:\n          return instance;\n      }\n    instance = getNextHydratable(instance.nextSibling);\n    if (null === instance) break;\n  }\n  return null;\n}\nfunction canHydrateTextInstance(instance, text, inRootOrSingleton) {\n  if ("" === text) return null;\n  for (; 3 !== instance.nodeType; ) {\n    if (\n      (1 !== instance.nodeType ||\n        "INPUT" !== instance.nodeName ||\n        "hidden" !== instance.type) &&\n      !inRootOrSingleton\n    )\n      return null;\n    instance = getNextHydratable(instance.nextSibling);\n    if (null === instance) return null;\n  }\n  return instance;\n}\nfunction getNextHydratable(node) {\n  for (; null != node; node = node.nextSibling) {\n    var nodeType = node.nodeType;\n    if (1 === nodeType || 3 === nodeType) break;\n    if (8 === nodeType) {\n      nodeType = node.data;\n      if (\n        "$" === nodeType ||\n        "$!" === nodeType ||\n        "$?" === nodeType ||\n        "F!" === nodeType ||\n        "F" === nodeType\n      )\n        break;\n      if ("/$" === nodeType) return null;\n    }\n  }\n  return node;\n}\nfunction getParentSuspenseInstance(targetInstance) {\n  targetInstance = targetInstance.previousSibling;\n  for (var depth = 0; targetInstance; ) {\n    if (8 === targetInstance.nodeType) {\n      var data = targetInstance.data;\n      if ("$" === data || "$!" === data || "$?" === data) {\n        if (0 === depth) return targetInstance;\n        depth--;\n      } else "/$" === data && depth++;\n    }\n    targetInstance = targetInstance.previousSibling;\n  }\n  return null;\n}\nfunction resolveSingletonInstance(type, props, rootContainerInstance) {\n  props = getOwnerDocumentFromRootContainer(rootContainerInstance);\n  switch (type) {\n    case "html":\n      type = props.documentElement;\n      if (!type) throw Error(formatProdErrorMessage(452));\n      return type;\n    case "head":\n      type = props.head;\n      if (!type) throw Error(formatProdErrorMessage(453));\n      return type;\n    case "body":\n      type = props.body;\n      if (!type) throw Error(formatProdErrorMessage(454));\n      return type;\n    default:\n      throw Error(formatProdErrorMessage(451));\n  }\n}\nvar preloadPropsMap = new Map(),\n  preconnectsSet = new Set();\nfunction getHoistableRoot(container) {\n  return "function" === typeof container.getRootNode\n    ? container.getRootNode()\n    : container.ownerDocument;\n}\nvar previousDispatcher = ReactDOMSharedInternals.d;\nReactDOMSharedInternals.d = {\n  f: flushSyncWork,\n  r: requestFormReset,\n  D: prefetchDNS,\n  C: preconnect,\n  L: preload,\n  m: preloadModule,\n  X: preinitScript,\n  S: preinitStyle,\n  M: preinitModuleScript\n};\nfunction flushSyncWork() {\n  var previousWasRendering = previousDispatcher.f(),\n    wasRendering = flushSyncWork$1();\n  return previousWasRendering || wasRendering;\n}\nfunction requestFormReset(form) {\n  var formInst = getInstanceFromNode(form);\n  null !== formInst && 5 === formInst.tag && "form" === formInst.type\n    ? requestFormReset$1(formInst)\n    : previousDispatcher.r(form);\n}\nvar globalDocument = "undefined" === typeof document ? null : document;\nfunction preconnectAs(rel, href, crossOrigin) {\n  var ownerDocument = globalDocument;\n  if (ownerDocument && "string" === typeof href && href) {\n    var limitedEscapedHref =\n      escapeSelectorAttributeValueInsideDoubleQuotes(href);\n    limitedEscapedHref =\n      \'link[rel="\' + rel + \'"][href="\' + limitedEscapedHref + \'"]\';\n    "string" === typeof crossOrigin &&\n      (limitedEscapedHref += \'[crossorigin="\' + crossOrigin + \'"]\');\n    preconnectsSet.has(limitedEscapedHref) ||\n      (preconnectsSet.add(limitedEscapedHref),\n      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),\n      null === ownerDocument.querySelector(limitedEscapedHref) &&\n        ((href = ownerDocument.createElement("link")),\n        setInitialProperties(href, "link", rel),\n        markNodeAsHoistable(href),\n        ownerDocument.head.appendChild(href)));\n  }\n}\nfunction prefetchDNS(href) {\n  previousDispatcher.D(href);\n  preconnectAs("dns-prefetch", href, null);\n}\nfunction preconnect(href, crossOrigin) {\n  previousDispatcher.C(href, crossOrigin);\n  preconnectAs("preconnect", href, crossOrigin);\n}\nfunction preload(href, as, options) {\n  previousDispatcher.L(href, as, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href && as) {\n    var preloadSelector =\n      \'link[rel="preload"][as="\' +\n      escapeSelectorAttributeValueInsideDoubleQuotes(as) +\n      \'"]\';\n    "image" === as\n      ? options && options.imageSrcSet\n        ? ((preloadSelector +=\n            \'[imagesrcset="\' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(\n              options.imageSrcSet\n            ) +\n            \'"]\'),\n          "string" === typeof options.imageSizes &&\n            (preloadSelector +=\n              \'[imagesizes="\' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                options.imageSizes\n              ) +\n              \'"]\'))\n        : (preloadSelector +=\n            \'[href="\' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n            \'"]\')\n      : (preloadSelector +=\n          \'[href="\' +\n          escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n          \'"]\');\n    var key = preloadSelector;\n    switch (as) {\n      case "style":\n        key = getStyleKey(href);\n        break;\n      case "script":\n        key = getScriptKey(href);\n    }\n    preloadPropsMap.has(key) ||\n      ((href = assign(\n        {\n          rel: "preload",\n          href:\n            "image" === as && options && options.imageSrcSet ? void 0 : href,\n          as: as\n        },\n        options\n      )),\n      preloadPropsMap.set(key, href),\n      null !== ownerDocument.querySelector(preloadSelector) ||\n        ("style" === as &&\n          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||\n        ("script" === as &&\n          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||\n        ((as = ownerDocument.createElement("link")),\n        setInitialProperties(as, "link", href),\n        markNodeAsHoistable(as),\n        ownerDocument.head.appendChild(as)));\n  }\n}\nfunction preloadModule(href, options) {\n  previousDispatcher.m(href, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href) {\n    var as = options && "string" === typeof options.as ? options.as : "script",\n      preloadSelector =\n        \'link[rel="modulepreload"][as="\' +\n        escapeSelectorAttributeValueInsideDoubleQuotes(as) +\n        \'"][href="\' +\n        escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n        \'"]\',\n      key = preloadSelector;\n    switch (as) {\n      case "audioworklet":\n      case "paintworklet":\n      case "serviceworker":\n      case "sharedworker":\n      case "worker":\n      case "script":\n        key = getScriptKey(href);\n    }\n    if (\n      !preloadPropsMap.has(key) &&\n      ((href = assign({ rel: "modulepreload", href: href }, options)),\n      preloadPropsMap.set(key, href),\n      null === ownerDocument.querySelector(preloadSelector))\n    ) {\n      switch (as) {\n        case "audioworklet":\n        case "paintworklet":\n        case "serviceworker":\n        case "sharedworker":\n        case "worker":\n        case "script":\n          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))\n            return;\n      }\n      as = ownerDocument.createElement("link");\n      setInitialProperties(as, "link", href);\n      markNodeAsHoistable(as);\n      ownerDocument.head.appendChild(as);\n    }\n  }\n}\nfunction preinitStyle(href, precedence, options) {\n  previousDispatcher.S(href, precedence, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href) {\n    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,\n      key = getStyleKey(href);\n    precedence = precedence || "default";\n    var resource = styles.get(key);\n    if (!resource) {\n      var state = { loading: 0, preload: null };\n      if (\n        (resource = ownerDocument.querySelector(\n          getStylesheetSelectorFromKey(key)\n        ))\n      )\n        state.loading = 5;\n      else {\n        href = assign(\n          { rel: "stylesheet", href: href, "data-precedence": precedence },\n          options\n        );\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForStylesheet(href, options);\n        var link = (resource = ownerDocument.createElement("link"));\n        markNodeAsHoistable(link);\n        setInitialProperties(link, "link", href);\n        link._p = new Promise(function (resolve, reject) {\n          link.onload = resolve;\n          link.onerror = reject;\n        });\n        link.addEventListener("load", function () {\n          state.loading |= 1;\n        });\n        link.addEventListener("error", function () {\n          state.loading |= 2;\n        });\n        state.loading |= 4;\n        insertStylesheet(resource, precedence, ownerDocument);\n      }\n      resource = {\n        type: "stylesheet",\n        instance: resource,\n        count: 1,\n        state: state\n      };\n      styles.set(key, resource);\n    }\n  }\n}\nfunction preinitScript(src, options) {\n  previousDispatcher.X(src, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && src) {\n    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,\n      key = getScriptKey(src),\n      resource = scripts.get(key);\n    resource ||\n      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),\n      resource ||\n        ((src = assign({ src: src, async: !0 }, options)),\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForScript(src, options),\n        (resource = ownerDocument.createElement("script")),\n        markNodeAsHoistable(resource),\n        setInitialProperties(resource, "link", src),\n        ownerDocument.head.appendChild(resource)),\n      (resource = {\n        type: "script",\n        instance: resource,\n        count: 1,\n        state: null\n      }),\n      scripts.set(key, resource));\n  }\n}\nfunction preinitModuleScript(src, options) {\n  previousDispatcher.M(src, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && src) {\n    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,\n      key = getScriptKey(src),\n      resource = scripts.get(key);\n    resource ||\n      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),\n      resource ||\n        ((src = assign({ src: src, async: !0, type: "module" }, options)),\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForScript(src, options),\n        (resource = ownerDocument.createElement("script")),\n        markNodeAsHoistable(resource),\n        setInitialProperties(resource, "link", src),\n        ownerDocument.head.appendChild(resource)),\n      (resource = {\n        type: "script",\n        instance: resource,\n        count: 1,\n        state: null\n      }),\n      scripts.set(key, resource));\n  }\n}\nfunction getResource(type, currentProps, pendingProps, currentResource) {\n  var JSCompiler_inline_result = (JSCompiler_inline_result =\n    rootInstanceStackCursor.current)\n    ? getHoistableRoot(JSCompiler_inline_result)\n    : null;\n  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));\n  switch (type) {\n    case "meta":\n    case "title":\n      return null;\n    case "style":\n      return "string" === typeof pendingProps.precedence &&\n        "string" === typeof pendingProps.href\n        ? ((currentProps = getStyleKey(pendingProps.href)),\n          (pendingProps = getResourcesFromRoot(\n            JSCompiler_inline_result\n          ).hoistableStyles),\n          (currentResource = pendingProps.get(currentProps)),\n          currentResource ||\n            ((currentResource = {\n              type: "style",\n              instance: null,\n              count: 0,\n              state: null\n            }),\n            pendingProps.set(currentProps, currentResource)),\n          currentResource)\n        : { type: "void", instance: null, count: 0, state: null };\n    case "link":\n      if (\n        "stylesheet" === pendingProps.rel &&\n        "string" === typeof pendingProps.href &&\n        "string" === typeof pendingProps.precedence\n      ) {\n        type = getStyleKey(pendingProps.href);\n        var styles$242 = getResourcesFromRoot(\n            JSCompiler_inline_result\n          ).hoistableStyles,\n          resource$243 = styles$242.get(type);\n        resource$243 ||\n          ((JSCompiler_inline_result =\n            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),\n          (resource$243 = {\n            type: "stylesheet",\n            instance: null,\n            count: 0,\n            state: { loading: 0, preload: null }\n          }),\n          styles$242.set(type, resource$243),\n          (styles$242 = JSCompiler_inline_result.querySelector(\n            getStylesheetSelectorFromKey(type)\n          )) &&\n            !styles$242._p &&\n            ((resource$243.instance = styles$242),\n            (resource$243.state.loading = 5)),\n          preloadPropsMap.has(type) ||\n            ((pendingProps = {\n              rel: "preload",\n              as: "style",\n              href: pendingProps.href,\n              crossOrigin: pendingProps.crossOrigin,\n              integrity: pendingProps.integrity,\n              media: pendingProps.media,\n              hrefLang: pendingProps.hrefLang,\n              referrerPolicy: pendingProps.referrerPolicy\n            }),\n            preloadPropsMap.set(type, pendingProps),\n            styles$242 ||\n              preloadStylesheet(\n                JSCompiler_inline_result,\n                type,\n                pendingProps,\n                resource$243.state\n              )));\n        if (currentProps && null === currentResource)\n          throw Error(formatProdErrorMessage(528, ""));\n        return resource$243;\n      }\n      if (currentProps && null !== currentResource)\n        throw Error(formatProdErrorMessage(529, ""));\n      return null;\n    case "script":\n      return (\n        (currentProps = pendingProps.async),\n        (pendingProps = pendingProps.src),\n        "string" === typeof pendingProps &&\n        currentProps &&\n        "function" !== typeof currentProps &&\n        "symbol" !== typeof currentProps\n          ? ((currentProps = getScriptKey(pendingProps)),\n            (pendingProps = getResourcesFromRoot(\n              JSCompiler_inline_result\n            ).hoistableScripts),\n            (currentResource = pendingProps.get(currentProps)),\n            currentResource ||\n              ((currentResource = {\n                type: "script",\n                instance: null,\n                count: 0,\n                state: null\n              }),\n              pendingProps.set(currentProps, currentResource)),\n            currentResource)\n          : { type: "void", instance: null, count: 0, state: null }\n      );\n    default:\n      throw Error(formatProdErrorMessage(444, type));\n  }\n}\nfunction getStyleKey(href) {\n  return \'href="\' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + \'"\';\n}\nfunction getStylesheetSelectorFromKey(key) {\n  return \'link[rel="stylesheet"][\' + key + "]";\n}\nfunction stylesheetPropsFromRawProps(rawProps) {\n  return assign({}, rawProps, {\n    "data-precedence": rawProps.precedence,\n    precedence: null\n  });\n}\nfunction preloadStylesheet(ownerDocument, key, preloadProps, state) {\n  ownerDocument.querySelector(\'link[rel="preload"][as="style"][\' + key + "]")\n    ? (state.loading = 1)\n    : ((key = ownerDocument.createElement("link")),\n      (state.preload = key),\n      key.addEventListener("load", function () {\n        return (state.loading |= 1);\n      }),\n      key.addEventListener("error", function () {\n        return (state.loading |= 2);\n      }),\n      setInitialProperties(key, "link", preloadProps),\n      markNodeAsHoistable(key),\n      ownerDocument.head.appendChild(key));\n}\nfunction getScriptKey(src) {\n  return \'[src="\' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + \'"]\';\n}\nfunction getScriptSelectorFromKey(key) {\n  return "script[async]" + key;\n}\nfunction acquireResource(hoistableRoot, resource, props) {\n  resource.count++;\n  if (null === resource.instance)\n    switch (resource.type) {\n      case "style":\n        var instance = hoistableRoot.querySelector(\n          \'style[data-href~="\' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +\n            \'"]\'\n        );\n        if (instance)\n          return (\n            (resource.instance = instance),\n            markNodeAsHoistable(instance),\n            instance\n          );\n        var styleProps = assign({}, props, {\n          "data-href": props.href,\n          "data-precedence": props.precedence,\n          href: null,\n          precedence: null\n        });\n        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(\n          "style"\n        );\n        markNodeAsHoistable(instance);\n        setInitialProperties(instance, "style", styleProps);\n        insertStylesheet(instance, props.precedence, hoistableRoot);\n        return (resource.instance = instance);\n      case "stylesheet":\n        styleProps = getStyleKey(props.href);\n        var instance$248 = hoistableRoot.querySelector(\n          getStylesheetSelectorFromKey(styleProps)\n        );\n        if (instance$248)\n          return (\n            (resource.state.loading |= 4),\n            (resource.instance = instance$248),\n            markNodeAsHoistable(instance$248),\n            instance$248\n          );\n        instance = stylesheetPropsFromRawProps(props);\n        (styleProps = preloadPropsMap.get(styleProps)) &&\n          adoptPreloadPropsForStylesheet(instance, styleProps);\n        instance$248 = (\n          hoistableRoot.ownerDocument || hoistableRoot\n        ).createElement("link");\n        markNodeAsHoistable(instance$248);\n        var linkInstance = instance$248;\n        linkInstance._p = new Promise(function (resolve, reject) {\n          linkInstance.onload = resolve;\n          linkInstance.onerror = reject;\n        });\n        setInitialProperties(instance$248, "link", instance);\n        resource.state.loading |= 4;\n        insertStylesheet(instance$248, props.precedence, hoistableRoot);\n        return (resource.instance = instance$248);\n      case "script":\n        instance$248 = getScriptKey(props.src);\n        if (\n          (styleProps = hoistableRoot.querySelector(\n            getScriptSelectorFromKey(instance$248)\n          ))\n        )\n          return (\n            (resource.instance = styleProps),\n            markNodeAsHoistable(styleProps),\n            styleProps\n          );\n        instance = props;\n        if ((styleProps = preloadPropsMap.get(instance$248)))\n          (instance = assign({}, props)),\n            adoptPreloadPropsForScript(instance, styleProps);\n        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n        styleProps = hoistableRoot.createElement("script");\n        markNodeAsHoistable(styleProps);\n        setInitialProperties(styleProps, "link", instance);\n        hoistableRoot.head.appendChild(styleProps);\n        return (resource.instance = styleProps);\n      case "void":\n        return null;\n      default:\n        throw Error(formatProdErrorMessage(443, resource.type));\n    }\n  else\n    "stylesheet" === resource.type &&\n      0 === (resource.state.loading & 4) &&\n      ((instance = resource.instance),\n      (resource.state.loading |= 4),\n      insertStylesheet(instance, props.precedence, hoistableRoot));\n  return resource.instance;\n}\nfunction insertStylesheet(instance, precedence, root) {\n  for (\n    var nodes = root.querySelectorAll(\n        \'link[rel="stylesheet"][data-precedence],style[data-precedence]\'\n      ),\n      last = nodes.length ? nodes[nodes.length - 1] : null,\n      prior = last,\n      i = 0;\n    i < nodes.length;\n    i++\n  ) {\n    var node = nodes[i];\n    if (node.dataset.precedence === precedence) prior = node;\n    else if (prior !== last) break;\n  }\n  prior\n    ? prior.parentNode.insertBefore(instance, prior.nextSibling)\n    : ((precedence = 9 === root.nodeType ? root.head : root),\n      precedence.insertBefore(instance, precedence.firstChild));\n}\nfunction adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {\n  null == stylesheetProps.crossOrigin &&\n    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);\n  null == stylesheetProps.referrerPolicy &&\n    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);\n  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);\n}\nfunction adoptPreloadPropsForScript(scriptProps, preloadProps) {\n  null == scriptProps.crossOrigin &&\n    (scriptProps.crossOrigin = preloadProps.crossOrigin);\n  null == scriptProps.referrerPolicy &&\n    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);\n  null == scriptProps.integrity &&\n    (scriptProps.integrity = preloadProps.integrity);\n}\nvar tagCaches = null;\nfunction getHydratableHoistableCache(type, keyAttribute, ownerDocument) {\n  if (null === tagCaches) {\n    var cache = new Map();\n    var caches = (tagCaches = new Map());\n    caches.set(ownerDocument, cache);\n  } else\n    (caches = tagCaches),\n      (cache = caches.get(ownerDocument)),\n      cache || ((cache = new Map()), caches.set(ownerDocument, cache));\n  if (cache.has(type)) return cache;\n  cache.set(type, null);\n  ownerDocument = ownerDocument.getElementsByTagName(type);\n  for (caches = 0; caches < ownerDocument.length; caches++) {\n    var node = ownerDocument[caches];\n    if (\n      !(\n        node[internalHoistableMarker] ||\n        node[internalInstanceKey] ||\n        ("link" === type && "stylesheet" === node.getAttribute("rel"))\n      ) &&\n      "http://www.w3.org/2000/svg" !== node.namespaceURI\n    ) {\n      var nodeKey = node.getAttribute(keyAttribute) || "";\n      nodeKey = type + nodeKey;\n      var existing = cache.get(nodeKey);\n      existing ? existing.push(node) : cache.set(nodeKey, [node]);\n    }\n  }\n  return cache;\n}\nfunction mountHoistable(hoistableRoot, type, instance) {\n  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n  hoistableRoot.head.insertBefore(\n    instance,\n    "title" === type ? hoistableRoot.querySelector("head > title") : null\n  );\n}\nfunction isHostHoistableType(type, props, hostContext) {\n  if (1 === hostContext || null != props.itemProp) return !1;\n  switch (type) {\n    case "meta":\n    case "title":\n      return !0;\n    case "style":\n      if (\n        "string" !== typeof props.precedence ||\n        "string" !== typeof props.href ||\n        "" === props.href\n      )\n        break;\n      return !0;\n    case "link":\n      if (\n        "string" !== typeof props.rel ||\n        "string" !== typeof props.href ||\n        "" === props.href ||\n        props.onLoad ||\n        props.onError\n      )\n        break;\n      switch (props.rel) {\n        case "stylesheet":\n          return (\n            (type = props.disabled),\n            "string" === typeof props.precedence && null == type\n          );\n        default:\n          return !0;\n      }\n    case "script":\n      if (\n        props.async &&\n        "function" !== typeof props.async &&\n        "symbol" !== typeof props.async &&\n        !props.onLoad &&\n        !props.onError &&\n        props.src &&\n        "string" === typeof props.src\n      )\n        return !0;\n  }\n  return !1;\n}\nfunction preloadResource(resource) {\n  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)\n    ? !1\n    : !0;\n}\nvar suspendedState = null;\nfunction noop() {}\nfunction suspendResource(hoistableRoot, resource, props) {\n  if (null === suspendedState) throw Error(formatProdErrorMessage(475));\n  var state = suspendedState;\n  if (\n    "stylesheet" === resource.type &&\n    ("string" !== typeof props.media ||\n      !1 !== matchMedia(props.media).matches) &&\n    0 === (resource.state.loading & 4)\n  ) {\n    if (null === resource.instance) {\n      var key = getStyleKey(props.href),\n        instance = hoistableRoot.querySelector(\n          getStylesheetSelectorFromKey(key)\n        );\n      if (instance) {\n        hoistableRoot = instance._p;\n        null !== hoistableRoot &&\n          "object" === typeof hoistableRoot &&\n          "function" === typeof hoistableRoot.then &&\n          (state.count++,\n          (state = onUnsuspend.bind(state)),\n          hoistableRoot.then(state, state));\n        resource.state.loading |= 4;\n        resource.instance = instance;\n        markNodeAsHoistable(instance);\n        return;\n      }\n      instance = hoistableRoot.ownerDocument || hoistableRoot;\n      props = stylesheetPropsFromRawProps(props);\n      (key = preloadPropsMap.get(key)) &&\n        adoptPreloadPropsForStylesheet(props, key);\n      instance = instance.createElement("link");\n      markNodeAsHoistable(instance);\n      var linkInstance = instance;\n      linkInstance._p = new Promise(function (resolve, reject) {\n        linkInstance.onload = resolve;\n        linkInstance.onerror = reject;\n      });\n      setInitialProperties(instance, "link", props);\n      resource.instance = instance;\n    }\n    null === state.stylesheets && (state.stylesheets = new Map());\n    state.stylesheets.set(resource, hoistableRoot);\n    (hoistableRoot = resource.state.preload) &&\n      0 === (resource.state.loading & 3) &&\n      (state.count++,\n      (resource = onUnsuspend.bind(state)),\n      hoistableRoot.addEventListener("load", resource),\n      hoistableRoot.addEventListener("error", resource));\n  }\n}\nfunction waitForCommitToBeReady() {\n  if (null === suspendedState) throw Error(formatProdErrorMessage(475));\n  var state = suspendedState;\n  state.stylesheets &&\n    0 === state.count &&\n    insertSuspendedStylesheets(state, state.stylesheets);\n  return 0 < state.count\n    ? function (commit) {\n        var stylesheetTimer = setTimeout(function () {\n          state.stylesheets &&\n            insertSuspendedStylesheets(state, state.stylesheets);\n          if (state.unsuspend) {\n            var unsuspend = state.unsuspend;\n            state.unsuspend = null;\n            unsuspend();\n          }\n        }, 6e4);\n        state.unsuspend = commit;\n        return function () {\n          state.unsuspend = null;\n          clearTimeout(stylesheetTimer);\n        };\n      }\n    : null;\n}\nfunction onUnsuspend() {\n  this.count--;\n  if (0 === this.count)\n    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);\n    else if (this.unsuspend) {\n      var unsuspend = this.unsuspend;\n      this.unsuspend = null;\n      unsuspend();\n    }\n}\nvar precedencesByRoot = null;\nfunction insertSuspendedStylesheets(state, resources) {\n  state.stylesheets = null;\n  null !== state.unsuspend &&\n    (state.count++,\n    (precedencesByRoot = new Map()),\n    resources.forEach(insertStylesheetIntoRoot, state),\n    (precedencesByRoot = null),\n    onUnsuspend.call(state));\n}\nfunction insertStylesheetIntoRoot(root, resource) {\n  if (!(resource.state.loading & 4)) {\n    var precedences = precedencesByRoot.get(root);\n    if (precedences) var last = precedences.get(null);\n    else {\n      precedences = new Map();\n      precedencesByRoot.set(root, precedences);\n      for (\n        var nodes = root.querySelectorAll(\n            "link[data-precedence],style[data-precedence]"\n          ),\n          i = 0;\n        i < nodes.length;\n        i++\n      ) {\n        var node = nodes[i];\n        if (\n          "LINK" === node.nodeName ||\n          "not all" !== node.getAttribute("media")\n        )\n          precedences.set(node.dataset.precedence, node), (last = node);\n      }\n      last && precedences.set(null, last);\n    }\n    nodes = resource.instance;\n    node = nodes.getAttribute("data-precedence");\n    i = precedences.get(node) || last;\n    i === last && precedences.set(null, nodes);\n    precedences.set(node, nodes);\n    this.count++;\n    last = onUnsuspend.bind(this);\n    nodes.addEventListener("load", last);\n    nodes.addEventListener("error", last);\n    i\n      ? i.parentNode.insertBefore(nodes, i.nextSibling)\n      : ((root = 9 === root.nodeType ? root.head : root),\n        root.insertBefore(nodes, root.firstChild));\n    resource.state.loading |= 4;\n  }\n}\nvar HostTransitionContext = {\n  $$typeof: REACT_CONTEXT_TYPE,\n  Provider: null,\n  Consumer: null,\n  _currentValue: sharedNotPendingObject,\n  _currentValue2: sharedNotPendingObject,\n  _threadCount: 0\n};\nfunction FiberRootNode(\n  containerInfo,\n  tag,\n  hydrate,\n  identifierPrefix,\n  onUncaughtError,\n  onCaughtError,\n  onRecoverableError,\n  formState\n) {\n  this.tag = 1;\n  this.containerInfo = containerInfo;\n  this.finishedWork =\n    this.pingCache =\n    this.current =\n    this.pendingChildren =\n      null;\n  this.timeoutHandle = -1;\n  this.callbackNode =\n    this.next =\n    this.pendingContext =\n    this.context =\n    this.cancelPendingCommit =\n      null;\n  this.callbackPriority = 0;\n  this.expirationTimes = createLaneMap(-1);\n  this.entangledLanes =\n    this.shellSuspendCounter =\n    this.errorRecoveryDisabledLanes =\n    this.finishedLanes =\n    this.expiredLanes =\n    this.warmLanes =\n    this.pingedLanes =\n    this.suspendedLanes =\n    this.pendingLanes =\n      0;\n  this.entanglements = createLaneMap(0);\n  this.hiddenUpdates = createLaneMap(null);\n  this.identifierPrefix = identifierPrefix;\n  this.onUncaughtError = onUncaughtError;\n  this.onCaughtError = onCaughtError;\n  this.onRecoverableError = onRecoverableError;\n  this.pooledCache = null;\n  this.pooledCacheLanes = 0;\n  this.formState = formState;\n  this.incompleteTransitions = new Map();\n}\nfunction createFiberRoot(\n  containerInfo,\n  tag,\n  hydrate,\n  initialChildren,\n  hydrationCallbacks,\n  isStrictMode,\n  identifierPrefix,\n  onUncaughtError,\n  onCaughtError,\n  onRecoverableError,\n  transitionCallbacks,\n  formState\n) {\n  containerInfo = new FiberRootNode(\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    formState\n  );\n  tag = 1;\n  !0 === isStrictMode && (tag |= 24);\n  isStrictMode = createFiberImplClass(3, null, null, tag);\n  containerInfo.current = isStrictMode;\n  isStrictMode.stateNode = containerInfo;\n  tag = createCache();\n  tag.refCount++;\n  containerInfo.pooledCache = tag;\n  tag.refCount++;\n  isStrictMode.memoizedState = {\n    element: initialChildren,\n    isDehydrated: hydrate,\n    cache: tag\n  };\n  initializeUpdateQueue(isStrictMode);\n  return containerInfo;\n}\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) return emptyContextObject;\n  parentComponent = emptyContextObject;\n  return parentComponent;\n}\nfunction updateContainerImpl(\n  rootFiber,\n  lane,\n  element,\n  container,\n  parentComponent,\n  callback\n) {\n  parentComponent = getContextForSubtree(parentComponent);\n  null === container.context\n    ? (container.context = parentComponent)\n    : (container.pendingContext = parentComponent);\n  container = createUpdate(lane);\n  container.payload = { element: element };\n  callback = void 0 === callback ? null : callback;\n  null !== callback && (container.callback = callback);\n  element = enqueueUpdate(rootFiber, container, lane);\n  null !== element &&\n    (scheduleUpdateOnFiber(element, rootFiber, lane),\n    entangleTransitions(element, rootFiber, lane));\n}\nfunction markRetryLaneImpl(fiber, retryLane) {\n  fiber = fiber.memoizedState;\n  if (null !== fiber && null !== fiber.dehydrated) {\n    var a = fiber.retryLane;\n    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n  }\n}\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n}\nfunction attemptContinuousHydration(fiber) {\n  if (13 === fiber.tag) {\n    var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n    markRetryLaneIfNotHydrated(fiber, 67108864);\n  }\n}\nvar _enabled = !0;\nfunction dispatchDiscreteEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent\n) {\n  var prevTransition = ReactSharedInternals.T;\n  ReactSharedInternals.T = null;\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 2),\n      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction dispatchContinuousEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent\n) {\n  var prevTransition = ReactSharedInternals.T;\n  ReactSharedInternals.T = null;\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 8),\n      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction dispatchEvent(\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  if (_enabled) {\n    var blockedOn = findInstanceBlockingEvent(nativeEvent);\n    if (null === blockedOn)\n      dispatchEventForPluginEventSystem(\n        domEventName,\n        eventSystemFlags,\n        nativeEvent,\n        return_targetInst,\n        targetContainer\n      ),\n        clearIfContinuousEvent(domEventName, nativeEvent);\n    else if (\n      queueIfContinuousEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent\n      )\n    )\n      nativeEvent.stopPropagation();\n    else if (\n      (clearIfContinuousEvent(domEventName, nativeEvent),\n      eventSystemFlags & 4 &&\n        -1 < discreteReplayableEvents.indexOf(domEventName))\n    ) {\n      for (; null !== blockedOn; ) {\n        var fiber = getInstanceFromNode(blockedOn);\n        if (null !== fiber)\n          switch (fiber.tag) {\n            case 3:\n              fiber = fiber.stateNode;\n              if (fiber.current.memoizedState.isDehydrated) {\n                var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                if (0 !== lanes) {\n                  var root = fiber;\n                  root.pendingLanes |= 2;\n                  for (root.entangledLanes |= 2; lanes; ) {\n                    var lane = 1 << (31 - clz32(lanes));\n                    root.entanglements[1] |= lane;\n                    lanes &= ~lane;\n                  }\n                  ensureRootIsScheduled(fiber);\n                  0 === (executionContext & 6) &&\n                    ((workInProgressRootRenderTargetTime = now() + 500),\n                    flushSyncWorkAcrossRoots_impl(0, !1));\n                }\n              }\n              break;\n            case 13:\n              (root = enqueueConcurrentRenderForLane(fiber, 2)),\n                null !== root && scheduleUpdateOnFiber(root, fiber, 2),\n                flushSyncWork$1(),\n                markRetryLaneIfNotHydrated(fiber, 2);\n          }\n        fiber = findInstanceBlockingEvent(nativeEvent);\n        null === fiber &&\n          dispatchEventForPluginEventSystem(\n            domEventName,\n            eventSystemFlags,\n            nativeEvent,\n            return_targetInst,\n            targetContainer\n          );\n        if (fiber === blockedOn) break;\n        blockedOn = fiber;\n      }\n      null !== blockedOn && nativeEvent.stopPropagation();\n    } else\n      dispatchEventForPluginEventSystem(\n        domEventName,\n        eventSystemFlags,\n        nativeEvent,\n        null,\n        targetContainer\n      );\n  }\n}\nfunction findInstanceBlockingEvent(nativeEvent) {\n  nativeEvent = getEventTarget(nativeEvent);\n  return findInstanceBlockingTarget(nativeEvent);\n}\nvar return_targetInst = null;\nfunction findInstanceBlockingTarget(targetNode) {\n  return_targetInst = null;\n  targetNode = getClosestInstanceFromNode(targetNode);\n  if (null !== targetNode) {\n    var nearestMounted = getNearestMountedFiber(targetNode);\n    if (null === nearestMounted) targetNode = null;\n    else {\n      var tag = nearestMounted.tag;\n      if (13 === tag) {\n        targetNode = getSuspenseInstanceFromFiber(nearestMounted);\n        if (null !== targetNode) return targetNode;\n        targetNode = null;\n      } else if (3 === tag) {\n        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)\n          return 3 === nearestMounted.tag\n            ? nearestMounted.stateNode.containerInfo\n            : null;\n        targetNode = null;\n      } else nearestMounted !== targetNode && (targetNode = null);\n    }\n  }\n  return_targetInst = targetNode;\n  return null;\n}\nfunction getEventPriority(domEventName) {\n  switch (domEventName) {\n    case "beforetoggle":\n    case "cancel":\n    case "click":\n    case "close":\n    case "contextmenu":\n    case "copy":\n    case "cut":\n    case "auxclick":\n    case "dblclick":\n    case "dragend":\n    case "dragstart":\n    case "drop":\n    case "focusin":\n    case "focusout":\n    case "input":\n    case "invalid":\n    case "keydown":\n    case "keypress":\n    case "keyup":\n    case "mousedown":\n    case "mouseup":\n    case "paste":\n    case "pause":\n    case "play":\n    case "pointercancel":\n    case "pointerdown":\n    case "pointerup":\n    case "ratechange":\n    case "reset":\n    case "resize":\n    case "seeked":\n    case "submit":\n    case "toggle":\n    case "touchcancel":\n    case "touchend":\n    case "touchstart":\n    case "volumechange":\n    case "change":\n    case "selectionchange":\n    case "textInput":\n    case "compositionstart":\n    case "compositionend":\n    case "compositionupdate":\n    case "beforeblur":\n    case "afterblur":\n    case "beforeinput":\n    case "blur":\n    case "fullscreenchange":\n    case "focus":\n    case "hashchange":\n    case "popstate":\n    case "select":\n    case "selectstart":\n      return 2;\n    case "drag":\n    case "dragenter":\n    case "dragexit":\n    case "dragleave":\n    case "dragover":\n    case "mousemove":\n    case "mouseout":\n    case "mouseover":\n    case "pointermove":\n    case "pointerout":\n    case "pointerover":\n    case "scroll":\n    case "touchmove":\n    case "wheel":\n    case "mouseenter":\n    case "mouseleave":\n    case "pointerenter":\n    case "pointerleave":\n      return 8;\n    case "message":\n      switch (getCurrentPriorityLevel()) {\n        case ImmediatePriority:\n          return 2;\n        case UserBlockingPriority:\n          return 8;\n        case NormalPriority$1:\n        case LowPriority:\n          return 32;\n        case IdlePriority:\n          return 268435456;\n        default:\n          return 32;\n      }\n    default:\n      return 32;\n  }\n}\nvar hasScheduledReplayAttempt = !1,\n  queuedFocus = null,\n  queuedDrag = null,\n  queuedMouse = null,\n  queuedPointers = new Map(),\n  queuedPointerCaptures = new Map(),\n  queuedExplicitHydrationTargets = [],\n  discreteReplayableEvents =\n    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(\n      " "\n    );\nfunction clearIfContinuousEvent(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case "focusin":\n    case "focusout":\n      queuedFocus = null;\n      break;\n    case "dragenter":\n    case "dragleave":\n      queuedDrag = null;\n      break;\n    case "mouseover":\n    case "mouseout":\n      queuedMouse = null;\n      break;\n    case "pointerover":\n    case "pointerout":\n      queuedPointers.delete(nativeEvent.pointerId);\n      break;\n    case "gotpointercapture":\n    case "lostpointercapture":\n      queuedPointerCaptures.delete(nativeEvent.pointerId);\n  }\n}\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent,\n  blockedOn,\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  if (\n    null === existingQueuedEvent ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  )\n    return (\n      (existingQueuedEvent = {\n        blockedOn: blockedOn,\n        domEventName: domEventName,\n        eventSystemFlags: eventSystemFlags,\n        nativeEvent: nativeEvent,\n        targetContainers: [targetContainer]\n      }),\n      null !== blockedOn &&\n        ((blockedOn = getInstanceFromNode(blockedOn)),\n        null !== blockedOn && attemptContinuousHydration(blockedOn)),\n      existingQueuedEvent\n    );\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  blockedOn = existingQueuedEvent.targetContainers;\n  null !== targetContainer &&\n    -1 === blockedOn.indexOf(targetContainer) &&\n    blockedOn.push(targetContainer);\n  return existingQueuedEvent;\n}\nfunction queueIfContinuousEvent(\n  blockedOn,\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  switch (domEventName) {\n    case "focusin":\n      return (\n        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedFocus,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case "dragenter":\n      return (\n        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedDrag,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case "mouseover":\n      return (\n        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedMouse,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case "pointerover":\n      var pointerId = nativeEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )\n      );\n      return !0;\n    case "gotpointercapture":\n      return (\n        (pointerId = nativeEvent.pointerId),\n        queuedPointerCaptures.set(\n          pointerId,\n          accumulateOrCreateContinuousQueuedReplayableEvent(\n            queuedPointerCaptures.get(pointerId) || null,\n            blockedOn,\n            domEventName,\n            eventSystemFlags,\n            targetContainer,\n            nativeEvent\n          )\n        ),\n        !0\n      );\n  }\n  return !1;\n}\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (null !== targetInst) {\n    var nearestMounted = getNearestMountedFiber(targetInst);\n    if (null !== nearestMounted)\n      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {\n        if (\n          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),\n          null !== targetInst)\n        ) {\n          queuedTarget.blockedOn = targetInst;\n          runWithPriority(queuedTarget.priority, function () {\n            if (13 === nearestMounted.tag) {\n              var lane = requestUpdateLane(),\n                root = enqueueConcurrentRenderForLane(nearestMounted, lane);\n              null !== root &&\n                scheduleUpdateOnFiber(root, nearestMounted, lane);\n              markRetryLaneIfNotHydrated(nearestMounted, lane);\n            }\n          });\n          return;\n        }\n      } else if (\n        3 === targetInst &&\n        nearestMounted.stateNode.current.memoizedState.isDehydrated\n      ) {\n        queuedTarget.blockedOn =\n          3 === nearestMounted.tag\n            ? nearestMounted.stateNode.containerInfo\n            : null;\n        return;\n      }\n  }\n  queuedTarget.blockedOn = null;\n}\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (null !== queuedEvent.blockedOn) return !1;\n  for (\n    var targetContainers = queuedEvent.targetContainers;\n    0 < targetContainers.length;\n\n  ) {\n    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);\n    if (null === nextBlockedOn) {\n      nextBlockedOn = queuedEvent.nativeEvent;\n      var nativeEventClone = new nextBlockedOn.constructor(\n        nextBlockedOn.type,\n        nextBlockedOn\n      );\n      currentReplayingEvent = nativeEventClone;\n      nextBlockedOn.target.dispatchEvent(nativeEventClone);\n      currentReplayingEvent = null;\n    } else\n      return (\n        (targetContainers = getInstanceFromNode(nextBlockedOn)),\n        null !== targetContainers &&\n          attemptContinuousHydration(targetContainers),\n        (queuedEvent.blockedOn = nextBlockedOn),\n        !1\n      );\n    targetContainers.shift();\n  }\n  return !0;\n}\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);\n}\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = !1;\n  null !== queuedFocus &&\n    attemptReplayContinuousQueuedEvent(queuedFocus) &&\n    (queuedFocus = null);\n  null !== queuedDrag &&\n    attemptReplayContinuousQueuedEvent(queuedDrag) &&\n    (queuedDrag = null);\n  null !== queuedMouse &&\n    attemptReplayContinuousQueuedEvent(queuedMouse) &&\n    (queuedMouse = null);\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  queuedEvent.blockedOn === unblocked &&\n    ((queuedEvent.blockedOn = null),\n    hasScheduledReplayAttempt ||\n      ((hasScheduledReplayAttempt = !0),\n      Scheduler.unstable_scheduleCallback(\n        Scheduler.unstable_NormalPriority,\n        replayUnblockedEvents\n      )));\n}\nvar lastScheduledReplayQueue = null;\nfunction scheduleReplayQueueIfNeeded(formReplayingQueue) {\n  lastScheduledReplayQueue !== formReplayingQueue &&\n    ((lastScheduledReplayQueue = formReplayingQueue),\n    Scheduler.unstable_scheduleCallback(\n      Scheduler.unstable_NormalPriority,\n      function () {\n        lastScheduledReplayQueue === formReplayingQueue &&\n          (lastScheduledReplayQueue = null);\n        for (var i = 0; i < formReplayingQueue.length; i += 3) {\n          var form = formReplayingQueue[i],\n            submitterOrAction = formReplayingQueue[i + 1],\n            formData = formReplayingQueue[i + 2];\n          if ("function" !== typeof submitterOrAction)\n            if (null === findInstanceBlockingTarget(submitterOrAction || form))\n              continue;\n            else break;\n          var formInst = getInstanceFromNode(form);\n          null !== formInst &&\n            (formReplayingQueue.splice(i, 3),\n            (i -= 3),\n            startHostTransition(\n              formInst,\n              {\n                pending: !0,\n                data: formData,\n                method: form.method,\n                action: submitterOrAction\n              },\n              submitterOrAction,\n              formData\n            ));\n        }\n      }\n    ));\n}\nfunction retryIfBlockedOn(unblocked) {\n  function unblock(queuedEvent) {\n    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  }\n  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    var queuedTarget = queuedExplicitHydrationTargets[i];\n    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);\n  }\n  for (\n    ;\n    0 < queuedExplicitHydrationTargets.length &&\n    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);\n\n  )\n    attemptExplicitHydrationTarget(i),\n      null === i.blockedOn && queuedExplicitHydrationTargets.shift();\n  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;\n  if (null != i)\n    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {\n      var form = i[queuedTarget],\n        submitterOrAction = i[queuedTarget + 1],\n        formProps = form[internalPropsKey] || null;\n      if ("function" === typeof submitterOrAction)\n        formProps || scheduleReplayQueueIfNeeded(i);\n      else if (formProps) {\n        var action = null;\n        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))\n          if (\n            ((form = submitterOrAction),\n            (formProps = submitterOrAction[internalPropsKey] || null))\n          )\n            action = formProps.formAction;\n          else {\n            if (null !== findInstanceBlockingTarget(form)) continue;\n          }\n        else action = formProps.action;\n        "function" === typeof action\n          ? (i[queuedTarget + 1] = action)\n          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));\n        scheduleReplayQueueIfNeeded(i);\n      }\n    }\n}\nfunction ReactDOMRoot(internalRoot) {\n  this._internalRoot = internalRoot;\n}\nReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =\n  function (children) {\n    var root = this._internalRoot;\n    if (null === root) throw Error(formatProdErrorMessage(409));\n    var current = root.current,\n      lane = requestUpdateLane();\n    updateContainerImpl(current, lane, children, root, null, null);\n  };\nReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =\n  function () {\n    var root = this._internalRoot;\n    if (null !== root) {\n      this._internalRoot = null;\n      var container = root.containerInfo;\n      0 === root.tag && flushPassiveEffects();\n      updateContainerImpl(root.current, 2, null, root, null, null);\n      flushSyncWork$1();\n      container[internalContainerInstanceKey] = null;\n    }\n  };\nfunction ReactDOMHydrationRoot(internalRoot) {\n  this._internalRoot = internalRoot;\n}\nReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n  if (target) {\n    var updatePriority = resolveUpdatePriority();\n    target = { blockedOn: null, target: target, priority: updatePriority };\n    for (\n      var i = 0;\n      i < queuedExplicitHydrationTargets.length &&\n      0 !== updatePriority &&\n      updatePriority < queuedExplicitHydrationTargets[i].priority;\n      i++\n    );\n    queuedExplicitHydrationTargets.splice(i, 0, target);\n    0 === i && attemptExplicitHydrationTarget(target);\n  }\n};\nvar isomorphicReactPackageVersion$jscomp$inline_1686 = React.version;\nif (\n  "19.0.0" !==\n  isomorphicReactPackageVersion$jscomp$inline_1686\n)\n  throw Error(\n    formatProdErrorMessage(\n      527,\n      isomorphicReactPackageVersion$jscomp$inline_1686,\n      "19.0.0"\n    )\n  );\nReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n  var fiber = componentOrElement._reactInternals;\n  if (void 0 === fiber) {\n    if ("function" === typeof componentOrElement.render)\n      throw Error(formatProdErrorMessage(188));\n    componentOrElement = Object.keys(componentOrElement).join(",");\n    throw Error(formatProdErrorMessage(268, componentOrElement));\n  }\n  componentOrElement = findCurrentFiberUsingSlowPath(fiber);\n  componentOrElement =\n    null !== componentOrElement\n      ? findCurrentHostFiberImpl(componentOrElement)\n      : null;\n  componentOrElement =\n    null === componentOrElement ? null : componentOrElement.stateNode;\n  return componentOrElement;\n};\nvar internals$jscomp$inline_2165 = {\n  bundleType: 0,\n  version: "19.0.0",\n  rendererPackageName: "react-dom",\n  currentDispatcherRef: ReactSharedInternals,\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  reconcilerVersion: "19.0.0"\n};\nif ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n  var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (\n    !hook$jscomp$inline_2166.isDisabled &&\n    hook$jscomp$inline_2166.supportsFiber\n  )\n    try {\n      (rendererID = hook$jscomp$inline_2166.inject(\n        internals$jscomp$inline_2165\n      )),\n        (injectedHook = hook$jscomp$inline_2166);\n    } catch (err) {}\n}\nexports.createRoot = function (container, options) {\n  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));\n  var isStrictMode = !1,\n    identifierPrefix = "",\n    onUncaughtError = defaultOnUncaughtError,\n    onCaughtError = defaultOnCaughtError,\n    onRecoverableError = defaultOnRecoverableError,\n    transitionCallbacks = null;\n  null !== options &&\n    void 0 !== options &&\n    (!0 === options.unstable_strictMode && (isStrictMode = !0),\n    void 0 !== options.identifierPrefix &&\n      (identifierPrefix = options.identifierPrefix),\n    void 0 !== options.onUncaughtError &&\n      (onUncaughtError = options.onUncaughtError),\n    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),\n    void 0 !== options.onRecoverableError &&\n      (onRecoverableError = options.onRecoverableError),\n    void 0 !== options.unstable_transitionCallbacks &&\n      (transitionCallbacks = options.unstable_transitionCallbacks));\n  options = createFiberRoot(\n    container,\n    1,\n    !1,\n    null,\n    null,\n    isStrictMode,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    transitionCallbacks,\n    null\n  );\n  container[internalContainerInstanceKey] = options.current;\n  listenToAllSupportedEvents(\n    8 === container.nodeType ? container.parentNode : container\n  );\n  return new ReactDOMRoot(options);\n};\nexports.hydrateRoot = function (container, initialChildren, options) {\n  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));\n  var isStrictMode = !1,\n    identifierPrefix = "",\n    onUncaughtError = defaultOnUncaughtError,\n    onCaughtError = defaultOnCaughtError,\n    onRecoverableError = defaultOnRecoverableError,\n    transitionCallbacks = null,\n    formState = null;\n  null !== options &&\n    void 0 !== options &&\n    (!0 === options.unstable_strictMode && (isStrictMode = !0),\n    void 0 !== options.identifierPrefix &&\n      (identifierPrefix = options.identifierPrefix),\n    void 0 !== options.onUncaughtError &&\n      (onUncaughtError = options.onUncaughtError),\n    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),\n    void 0 !== options.onRecoverableError &&\n      (onRecoverableError = options.onRecoverableError),\n    void 0 !== options.unstable_transitionCallbacks &&\n      (transitionCallbacks = options.unstable_transitionCallbacks),\n    void 0 !== options.formState && (formState = options.formState));\n  initialChildren = createFiberRoot(\n    container,\n    1,\n    !0,\n    initialChildren,\n    null != options ? options : null,\n    isStrictMode,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    transitionCallbacks,\n    formState\n  );\n  initialChildren.context = getContextForSubtree(null);\n  options = initialChildren.current;\n  isStrictMode = requestUpdateLane();\n  identifierPrefix = createUpdate(isStrictMode);\n  identifierPrefix.callback = null;\n  enqueueUpdate(options, identifierPrefix, isStrictMode);\n  initialChildren.current.lanes = isStrictMode;\n  markRootUpdated$1(initialChildren, isStrictMode);\n  ensureRootIsScheduled(initialChildren);\n  container[internalContainerInstanceKey] = initialChildren.current;\n  listenToAllSupportedEvents(container);\n  return new ReactDOMHydrationRoot(initialChildren);\n};\nexports.version = "19.0.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2E7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyxHQUFPO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxHQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQXlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixvQkFBb0Isb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MseUJBQXlCLGlCQUFpQjtBQUMxRTtBQUNBLGlDQUFpQyxzQkFBc0Isa0JBQWtCO0FBQ3pFO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdUNBQXVDLG9CQUFvQixTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrREFBa0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0IscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWLDhCQUE4QixPQUFPO0FBQ3JDLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQTRDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWO0FBQ0EsMkNBQTJDO0FBQzNDLElBQUk7QUFDSiwyQkFBMkI7QUFDM0I7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQ0FBMkM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBOEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9DQUFvQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzPzM3NWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKlxuIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuKi9cblwidXNlIHN0cmljdFwiO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoXCJzY2hlZHVsZXJcIiksXG4gIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICBSZWFjdERPTSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9IFwiaHR0cHM6Ly9yZWFjdC5kZXYvZXJyb3JzL1wiICsgY29kZTtcbiAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdXJsICs9IFwiP2FyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbMV0pO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgdXJsICs9IFwiJmFyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiAoXG4gICAgXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgK1xuICAgIGNvZGUgK1xuICAgIFwiOyB2aXNpdCBcIiArXG4gICAgdXJsICtcbiAgICBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gIShcbiAgICAhbm9kZSB8fFxuICAgICgxICE9PSBub2RlLm5vZGVUeXBlICYmIDkgIT09IG5vZGUubm9kZVR5cGUgJiYgMTEgIT09IG5vZGUubm9kZVR5cGUpXG4gICk7XG59XG52YXIgUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLFxuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG5TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik7XG5TeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG5TeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKTtcblN5bWJvbC5mb3IoXCJyZWFjdC50cmFjaW5nX21hcmtlclwiKTtcbnZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSkgcmV0dXJuIG51bGw7XG4gIG1heWJlSXRlcmFibGUgPVxuICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xufVxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgPyBudWxsXG4gICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgfVxuICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICApO1xuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gIHByZWZpeCxcbiAgc3VmZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgIHN1ZmZpeCA9XG4gICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgfVxuICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG59XG52YXIgcmVlbnRyeSA9ICExO1xuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gIHJlZW50cnkgPSAhMDtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICB9XG4gICAgfTtcbiAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgIFwibmFtZVwiXG4gICAgKTtcbiAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICApO1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICBmb3IgKFxuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBSdW5JblJvb3RGcmFtZSA9IDA7XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICFzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0uaW5jbHVkZXMoXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIik7XG5cbiAgICAgIClcbiAgICAgICAgUnVuSW5Sb290RnJhbWUrKztcbiAgICAgIGZvciAoXG4gICAgICAgIDtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAhY29udHJvbExpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICApO1xuXG4gICAgICApXG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgaWYgKFxuICAgICAgICBSdW5JblJvb3RGcmFtZSA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgIDEgPD0gUnVuSW5Sb290RnJhbWUgJiZcbiAgICAgICAgICAwIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIHNhbXBsZUxpbmVzW1J1bkluUm9vdEZyYW1lXSAhPT0gY29udHJvbExpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl07XG5cbiAgICAgICAgKVxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tO1xuICAgICAgZm9yIChcbiAgICAgICAgO1xuICAgICAgICAxIDw9IFJ1bkluUm9vdEZyYW1lICYmIDAgPD0gbmFtZVByb3BEZXNjcmlwdG9yO1xuICAgICAgICBSdW5JblJvb3RGcmFtZS0tLCBuYW1lUHJvcERlc2NyaXB0b3ItLVxuICAgICAgKVxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbUnVuSW5Sb290RnJhbWVdICE9PSBjb250cm9sTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSkge1xuICAgICAgICAgIGlmICgxICE9PSBSdW5JblJvb3RGcmFtZSB8fCAxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoUnVuSW5Sb290RnJhbWUtLSxcbiAgICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAwID4gbmFtZVByb3BEZXNjcmlwdG9yIHx8XG4gICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0gIT09XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgKGZyYW1lID0gZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoMSA8PSBSdW5JblJvb3RGcmFtZSAmJiAwIDw9IG5hbWVQcm9wRGVzY3JpcHRvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIChyZWVudHJ5ID0gITEpLCAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlKTtcbiAgfVxuICByZXR1cm4gKHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUocHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSlcbiAgICA6IFwiXCI7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSAyNjpcbiAgICBjYXNlIDI3OlxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICBjYXNlIDEzOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VcIik7XG4gICAgY2FzZSAxOTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJldHVybiAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICExKSksIGZpYmVyO1xuICAgIGNhc2UgMTE6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyLCAhMSkpLCBmaWJlclxuICAgICAgKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMCkpLCBmaWJlcjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICBkb1xuICAgICAgKGluZm8gKz0gZGVzY3JpYmVGaWJlcih3b3JrSW5Qcm9ncmVzcykpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4pO1xuICAgIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXIsXG4gICAgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcbiAgaWYgKGZpYmVyLmFsdGVybmF0ZSkgZm9yICg7IG5vZGUucmV0dXJuOyApIG5vZGUgPSBub2RlLnJldHVybjtcbiAgZWxzZSB7XG4gICAgZmliZXIgPSBub2RlO1xuICAgIGRvXG4gICAgICAobm9kZSA9IGZpYmVyKSxcbiAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJiAobmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybiksXG4gICAgICAgIChmaWJlciA9IG5vZGUucmV0dXJuKTtcbiAgICB3aGlsZSAoZmliZXIpO1xuICB9XG4gIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5lYXJlc3RNb3VudGVkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgbnVsbCA9PT0gc3VzcGVuc2VTdGF0ZSAmJlxuICAgICAgKChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICBudWxsICE9PSBmaWJlciAmJiAoc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGUpKTtcbiAgICBpZiAobnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSkgcmV0dXJuIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKVxuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg4KSk7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIGFsdGVybmF0ZSA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuICAgIGlmIChudWxsID09PSBhbHRlcm5hdGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg4KSk7XG4gICAgcmV0dXJuIGFsdGVybmF0ZSAhPT0gZmliZXIgPyBudWxsIDogZmliZXI7XG4gIH1cbiAgZm9yICh2YXIgYSA9IGZpYmVyLCBiID0gYWx0ZXJuYXRlOyA7ICkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgaWYgKG51bGwgPT09IHBhcmVudEEpIGJyZWFrO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG4gICAgaWYgKG51bGwgPT09IHBhcmVudEIpIHtcbiAgICAgIGIgPSBwYXJlbnRBLnJldHVybjtcbiAgICAgIGlmIChudWxsICE9PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgZm9yIChwYXJlbnRCID0gcGFyZW50QS5jaGlsZDsgcGFyZW50QjsgKSB7XG4gICAgICAgIGlmIChwYXJlbnRCID09PSBhKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBmaWJlcjtcbiAgICAgICAgaWYgKHBhcmVudEIgPT09IGIpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGFsdGVybmF0ZTtcbiAgICAgICAgcGFyZW50QiA9IHBhcmVudEIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg4KSk7XG4gICAgfVxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIChhID0gcGFyZW50QSksIChiID0gcGFyZW50Qik7XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBkaWRGaW5kQ2hpbGQgPSAhMSwgY2hpbGQkMiA9IHBhcmVudEEuY2hpbGQ7IGNoaWxkJDI7ICkge1xuICAgICAgICBpZiAoY2hpbGQkMiA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCQyID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQkMiA9IGNoaWxkJDIuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIGZvciAoY2hpbGQkMiA9IHBhcmVudEIuY2hpbGQ7IGNoaWxkJDI7ICkge1xuICAgICAgICAgIGlmIChjaGlsZCQyID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkJDIgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZCQyID0gY2hpbGQkMi5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkwKSk7XG4gIH1cbiAgaWYgKDMgIT09IGEudGFnKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xuICByZXR1cm4gYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSA/IGZpYmVyIDogYWx0ZXJuYXRlO1xufVxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICB0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSk7XG4gICAgaWYgKG51bGwgIT09IHRhZykgcmV0dXJuIHRhZztcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPVxuICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgc2hhcmVkTm90UGVuZGluZ09iamVjdCA9IHtcbiAgICBwZW5kaW5nOiAhMSxcbiAgICBkYXRhOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBhY3Rpb246IG51bGxcbiAgfSxcbiAgdmFsdWVTdGFjayA9IFtdLFxuICBpbmRleCA9IC0xO1xuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4geyBjdXJyZW50OiBkZWZhdWx0VmFsdWUgfTtcbn1cbmZ1bmN0aW9uIHBvcChjdXJzb3IpIHtcbiAgMCA+IGluZGV4IHx8XG4gICAgKChjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdKSwgKHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbCksIGluZGV4LS0pO1xufVxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlKTtcbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCk7XG4gIGZpYmVyID0gbmV4dFJvb3RJbnN0YW5jZS5ub2RlVHlwZTtcbiAgc3dpdGNoIChmaWJlcikge1xuICAgIGNhc2UgOTpcbiAgICBjYXNlIDExOlxuICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IChuZXh0Um9vdEluc3RhbmNlID0gbmV4dFJvb3RJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQpXG4gICAgICAgID8gKG5leHRSb290SW5zdGFuY2UgPSBuZXh0Um9vdEluc3RhbmNlLm5hbWVzcGFjZVVSSSlcbiAgICAgICAgICA/IGdldE93bkhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpXG4gICAgICAgICAgOiAwXG4gICAgICAgIDogMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoXG4gICAgICAgICgoZmliZXIgPSA4ID09PSBmaWJlciA/IG5leHRSb290SW5zdGFuY2UucGFyZW50Tm9kZSA6IG5leHRSb290SW5zdGFuY2UpLFxuICAgICAgICAobmV4dFJvb3RJbnN0YW5jZSA9IGZpYmVyLnRhZ05hbWUpLFxuICAgICAgICAoZmliZXIgPSBmaWJlci5uYW1lc3BhY2VVUkkpKVxuICAgICAgKVxuICAgICAgICAoZmliZXIgPSBnZXRPd25Ib3N0Q29udGV4dChmaWJlcikpLFxuICAgICAgICAgIChuZXh0Um9vdEluc3RhbmNlID0gZ2V0Q2hpbGRIb3N0Q29udGV4dFByb2QoZmliZXIsIG5leHRSb290SW5zdGFuY2UpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IDA7XG4gICAgICAgIH1cbiAgfVxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcigpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvcik7XG59XG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJiBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyKTtcbiAgdmFyIGNvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGdldENoaWxkSG9zdENvbnRleHRQcm9kKGNvbnRleHQsIGZpYmVyLnR5cGUpO1xuICBjb250ZXh0ICE9PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAocHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpLFxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpKTtcbn1cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgKHBvcChjb250ZXh0U3RhY2tDdXJzb3IpLCBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IpKTtcbiAgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgIChwb3AoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciksXG4gICAgKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gc2hhcmVkTm90UGVuZGluZ09iamVjdCkpO1xufVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgc2NoZWR1bGVDYWxsYmFjayQzID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gIGNhbmNlbENhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICBub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IFNjaGVkdWxlci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxcbiAgSW1tZWRpYXRlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksXG4gIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICBMb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxcbiAgbG9nJDEgPSBTY2hlZHVsZXIubG9nLFxuICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSxcbiAgcmVuZGVyZXJJRCA9IG51bGwsXG4gIGluamVjdGVkSG9vayA9IG51bGw7XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdClcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KFxuICAgICAgICByZW5kZXJlcklELFxuICAgICAgICByb290LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIDEyOCA9PT0gKHJvb3QuY3VycmVudC5mbGFncyAmIDEyOClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxufVxuZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG4gIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxvZyQxICYmIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUpXG4gICAgdHJ5IHtcbiAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxufVxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICBsb2cgPSBNYXRoLmxvZyxcbiAgTE4yID0gTWF0aC5MTjI7XG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgeCA+Pj49IDA7XG4gIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyh4KSAvIExOMikgfCAwKSkgfCAwO1xufVxudmFyIG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCxcbiAgbmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQ7XG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gIGlmICgwICE9PSBwZW5kaW5nU3luY0xhbmVzKSByZXR1cm4gcGVuZGluZ1N5bmNMYW5lcztcbiAgc3dpdGNoIChsYW5lcyAmIC1sYW5lcykge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgMTY6XG4gICAgICByZXR1cm4gMTY7XG4gICAgY2FzZSAzMjpcbiAgICAgIHJldHVybiAzMjtcbiAgICBjYXNlIDY0OlxuICAgICAgcmV0dXJuIDY0O1xuICAgIGNhc2UgMTI4OlxuICAgIGNhc2UgMjU2OlxuICAgIGNhc2UgNTEyOlxuICAgIGNhc2UgMTAyNDpcbiAgICBjYXNlIDIwNDg6XG4gICAgY2FzZSA0MDk2OlxuICAgIGNhc2UgODE5MjpcbiAgICBjYXNlIDE2Mzg0OlxuICAgIGNhc2UgMzI3Njg6XG4gICAgY2FzZSA2NTUzNjpcbiAgICBjYXNlIDEzMTA3MjpcbiAgICBjYXNlIDI2MjE0NDpcbiAgICBjYXNlIDUyNDI4ODpcbiAgICBjYXNlIDEwNDg1NzY6XG4gICAgY2FzZSAyMDk3MTUyOlxuICAgICAgcmV0dXJuIGxhbmVzICYgNDE5NDE3NjtcbiAgICBjYXNlIDQxOTQzMDQ6XG4gICAgY2FzZSA4Mzg4NjA4OlxuICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgIHJldHVybiBsYW5lcyAmIDYyOTE0NTYwO1xuICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICByZXR1cm4gMTM0MjE3NzI4O1xuICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgcmV0dXJuIDI2ODQzNTQ1NjtcbiAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgcmV0dXJuIDA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgcmV0dXJuIDA7XG4gIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXMsXG4gICAgd2FybUxhbmVzID0gcm9vdC53YXJtTGFuZXM7XG4gIHJvb3QgPSAwICE9PSByb290LmZpbmlzaGVkTGFuZXM7XG4gIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgMTM0MjE3NzI3O1xuICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgPyAoKHBlbmRpbmdMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgMCAhPT0gcGVuZGluZ0xhbmVzXG4gICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBlbmRpbmdMYW5lcykpXG4gICAgICAgIDogKChwaW5nZWRMYW5lcyAmPSBub25JZGxlUGVuZGluZ0xhbmVzKSxcbiAgICAgICAgICAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgOiByb290IHx8XG4gICAgICAgICAgICAgICgod2FybUxhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKSlcbiAgICA6ICgobm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcyksXG4gICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQZW5kaW5nTGFuZXMpKVxuICAgICAgICA6IDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+d2FybUxhbmVzKSxcbiAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKTtcbiAgcmV0dXJuIDAgPT09IG5leHRMYW5lc1xuICAgID8gMFxuICAgIDogMCAhPT0gd2lwTGFuZXMgJiZcbiAgICAgICAgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJlxuICAgICAgICAwID09PSAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgJiZcbiAgICAgICAgKChzdXNwZW5kZWRMYW5lcyA9IG5leHRMYW5lcyAmIC1uZXh0TGFuZXMpLFxuICAgICAgICAod2FybUxhbmVzID0gd2lwTGFuZXMgJiAtd2lwTGFuZXMpLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSB3YXJtTGFuZXMgfHxcbiAgICAgICAgICAoMzIgPT09IHN1c3BlbmRlZExhbmVzICYmIDAgIT09ICh3YXJtTGFuZXMgJiA0MTk0MTc2KSkpXG4gICAgICA/IHdpcExhbmVzXG4gICAgICA6IG5leHRMYW5lcztcbn1cbmZ1bmN0aW9uIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIChcbiAgICAwID09PVxuICAgIChyb290LnBlbmRpbmdMYW5lcyAmXG4gICAgICB+KHJvb3Quc3VzcGVuZGVkTGFuZXMgJiB+cm9vdC5waW5nZWRMYW5lcykgJlxuICAgICAgcmVuZGVyTGFuZXMpXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgc3dpdGNoIChsYW5lKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDQ6XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICAgIGNhc2UgMTY6XG4gICAgY2FzZSAzMjpcbiAgICBjYXNlIDY0OlxuICAgIGNhc2UgMTI4OlxuICAgIGNhc2UgMjU2OlxuICAgIGNhc2UgNTEyOlxuICAgIGNhc2UgMTAyNDpcbiAgICBjYXNlIDIwNDg6XG4gICAgY2FzZSA0MDk2OlxuICAgIGNhc2UgODE5MjpcbiAgICBjYXNlIDE2Mzg0OlxuICAgIGNhc2UgMzI3Njg6XG4gICAgY2FzZSA2NTUzNjpcbiAgICBjYXNlIDEzMTA3MjpcbiAgICBjYXNlIDI2MjE0NDpcbiAgICBjYXNlIDUyNDI4ODpcbiAgICBjYXNlIDEwNDg1NzY6XG4gICAgY2FzZSAyMDk3MTUyOlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgNWUzO1xuICAgIGNhc2UgNDE5NDMwNDpcbiAgICBjYXNlIDgzODg2MDg6XG4gICAgY2FzZSAxNjc3NzIxNjpcbiAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgcmV0dXJuIC0xO1xuICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgcmV0dXJuIC0xO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuICAwID09PSAobmV4dFRyYW5zaXRpb25MYW5lICYgNDE5NDE3NikgJiYgKG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG4gIDAgPT09IChuZXh0UmV0cnlMYW5lICYgNjI5MTQ1NjApICYmIChuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lO1xuICAyNjg0MzU0NTYgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSwgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSwgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChcbiAgcm9vdCxcbiAgZmluaXNoZWRMYW5lcyxcbiAgcmVtYWluaW5nTGFuZXMsXG4gIHNwYXduZWRMYW5lLFxuICB1cGRhdGVkTGFuZXMsXG4gIHN1c3BlbmRlZFJldHJ5TGFuZXNcbikge1xuICB2YXIgcHJldmlvdXNseVBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgcm9vdC5waW5nZWRMYW5lcyA9IDA7XG4gIHJvb3Qud2FybUxhbmVzID0gMDtcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzLFxuICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gIGZvciAoXG4gICAgcmVtYWluaW5nTGFuZXMgPSBwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICApIHtcbiAgICB2YXIgaW5kZXgkNyA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNztcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4JDddID0gMDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXgkN10gPSAtMTtcbiAgICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4JDddO1xuICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgIGZvciAoXG4gICAgICAgIGhpZGRlblVwZGF0ZXNbaW5kZXgkN10gPSBudWxsLCBpbmRleCQ3ID0gMDtcbiAgICAgICAgaW5kZXgkNyA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgaW5kZXgkNysrXG4gICAgICApIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGhpZGRlblVwZGF0ZXNGb3JMYW5lW2luZGV4JDddO1xuICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgfVxuICAgIHJlbWFpbmluZ0xhbmVzICY9IH5sYW5lO1xuICB9XG4gIDAgIT09IHNwYXduZWRMYW5lICYmIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCAwKTtcbiAgMCAhPT0gc3VzcGVuZGVkUmV0cnlMYW5lcyAmJlxuICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgIDAgIT09IHJvb3QudGFnICYmXG4gICAgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfD1cbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xufVxuZnVuY3Rpb24gbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIGVudGFuZ2xlZExhbmVzKSB7XG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICByb290LnN1c3BlbmRlZExhbmVzICY9IH5zcGF3bmVkTGFuZTtcbiAgdmFyIHNwYXduZWRMYW5lSW5kZXggPSAzMSAtIGNsejMyKHNwYXduZWRMYW5lKTtcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdID1cbiAgICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gfFxuICAgIDEwNzM3NDE4MjQgfFxuICAgIChlbnRhbmdsZWRMYW5lcyAmIDQxOTQyMTgpO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgdmFyIHJvb3RFbnRhbmdsZWRMYW5lcyA9IChyb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgZm9yIChyb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzOyByb290RW50YW5nbGVkTGFuZXM7ICkge1xuICAgIHZhciBpbmRleCQ4ID0gMzEgLSBjbHozMihyb290RW50YW5nbGVkTGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkODtcbiAgICAobGFuZSAmIGVudGFuZ2xlZExhbmVzKSB8IChyb290W2luZGV4JDhdICYgZW50YW5nbGVkTGFuZXMpICYmXG4gICAgICAocm9vdFtpbmRleCQ4XSB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgcm9vdEVudGFuZ2xlZExhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICBsYW5lcyAmPSAtbGFuZXM7XG4gIHJldHVybiAyIDwgbGFuZXNcbiAgICA/IDggPCBsYW5lc1xuICAgICAgPyAwICE9PSAobGFuZXMgJiAxMzQyMTc3MjcpXG4gICAgICAgID8gMzJcbiAgICAgICAgOiAyNjg0MzU0NTZcbiAgICAgIDogOFxuICAgIDogMjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVVcGRhdGVQcmlvcml0eSgpIHtcbiAgdmFyIHVwZGF0ZVByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgaWYgKDAgIT09IHVwZGF0ZVByaW9yaXR5KSByZXR1cm4gdXBkYXRlUHJpb3JpdHk7XG4gIHVwZGF0ZVByaW9yaXR5ID0gd2luZG93LmV2ZW50O1xuICByZXR1cm4gdm9pZCAwID09PSB1cGRhdGVQcmlvcml0eSA/IDMyIDogZ2V0RXZlbnRQcmlvcml0eSh1cGRhdGVQcmlvcml0eS50eXBlKTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIHJldHVybiAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByaW9yaXR5KSwgZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eTtcbiAgfVxufVxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICBpbnRlcm5hbEluc3RhbmNlS2V5ID0gXCJfX3JlYWN0RmliZXIkXCIgKyByYW5kb21LZXksXG4gIGludGVybmFsUHJvcHNLZXkgPSBcIl9fcmVhY3RQcm9wcyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleSA9IFwiX19yZWFjdENvbnRhaW5lciRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gXCJfX3JlYWN0RXZlbnRzJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleSA9IFwiX19yZWFjdExpc3RlbmVycyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXkgPSBcIl9fcmVhY3RIYW5kbGVzJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbFJvb3ROb2RlUmVzb3VyY2VzS2V5ID0gXCJfX3JlYWN0UmVzb3VyY2VzJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbEhvaXN0YWJsZU1hcmtlciA9IFwiX19yZWFjdE1hcmtlciRcIiArIHJhbmRvbUtleTtcbmZ1bmN0aW9uIGRldGFjaERlbGV0ZWRJbnN0YW5jZShub2RlKSB7XG4gIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbFByb3BzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlc1NldEtleV07XG59XG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKHRhcmdldEluc3QpIHJldHVybiB0YXJnZXRJbnN0O1xuICBmb3IgKHZhciBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlOyBwYXJlbnROb2RlOyApIHtcbiAgICBpZiAoXG4gICAgICAodGFyZ2V0SW5zdCA9XG4gICAgICAgIHBhcmVudE5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgcGFyZW50Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSlcbiAgICApIHtcbiAgICAgIHBhcmVudE5vZGUgPSB0YXJnZXRJbnN0LmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdGFyZ2V0SW5zdC5jaGlsZCB8fFxuICAgICAgICAobnVsbCAhPT0gcGFyZW50Tm9kZSAmJiBudWxsICE9PSBwYXJlbnROb2RlLmNoaWxkKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuICAgICAgICAgIG51bGwgIT09IHRhcmdldE5vZGU7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKChwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkpIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG4gICAgdGFyZ2V0Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAoXG4gICAgKG5vZGUgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8IG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0pXG4gICkge1xuICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICBpZiAoXG4gICAgICA1ID09PSB0YWcgfHxcbiAgICAgIDYgPT09IHRhZyB8fFxuICAgICAgMTMgPT09IHRhZyB8fFxuICAgICAgMjYgPT09IHRhZyB8fFxuICAgICAgMjcgPT09IHRhZyB8fFxuICAgICAgMyA9PT0gdGFnXG4gICAgKVxuICAgICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgdmFyIHRhZyA9IGluc3QudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMykpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VzRnJvbVJvb3Qocm9vdCkge1xuICB2YXIgcmVzb3VyY2VzID0gcm9vdFtpbnRlcm5hbFJvb3ROb2RlUmVzb3VyY2VzS2V5XTtcbiAgcmVzb3VyY2VzIHx8XG4gICAgKHJlc291cmNlcyA9IHJvb3RbaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleV0gPVxuICAgICAgeyBob2lzdGFibGVTdHlsZXM6IG5ldyBNYXAoKSwgaG9pc3RhYmxlU2NyaXB0czogbmV3IE1hcCgpIH0pO1xuICByZXR1cm4gcmVzb3VyY2VzO1xufVxuZnVuY3Rpb24gbWFya05vZGVBc0hvaXN0YWJsZShub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdID0gITA7XG59XG52YXIgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpLFxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgXCJDYXB0dXJlXCIsIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuICBmb3IgKFxuICAgIHJlZ2lzdHJhdGlvbk5hbWUgPSAwO1xuICAgIHJlZ2lzdHJhdGlvbk5hbWUgPCBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgIHJlZ2lzdHJhdGlvbk5hbWUrK1xuICApXG4gICAgYWxsTmF0aXZlRXZlbnRzLmFkZChkZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0pO1xufVxudmFyIGNhblVzZURPTSA9ICEoXG4gICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdyB8fFxuICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgfHxcbiAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgKSxcbiAgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBSZWdFeHAoXG4gICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICksXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSByZXR1cm4gITE7XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxuICAgIHJldHVybiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITApO1xuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHZhciBwcmVmaXgkMTAgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgaWYgKFwiZGF0YS1cIiAhPT0gcHJlZml4JDEwICYmIFwiYXJpYS1cIiAhPT0gcHJlZml4JDEwKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiICsgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKG51bGwgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIiArIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKG5vZGUsIG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKG51bGwgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIFwiXCIgKyB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICByZXR1cm4gKFxuICAgIChlbGVtID0gZWxlbS5ub2RlTmFtZSkgJiZcbiAgICBcImlucHV0XCIgPT09IGVsZW0udG9Mb3dlckNhc2UoKSAmJlxuICAgIChcImNoZWNrYm94XCIgPT09IHR5cGUgfHwgXCJyYWRpb1wiID09PSB0eXBlKVxuICApO1xufVxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyBcImNoZWNrZWRcIiA6IFwidmFsdWVcIixcbiAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLFxuICAgICAgdmFsdWVGaWVsZFxuICAgICksXG4gICAgY3VycmVudFZhbHVlID0gXCJcIiArIG5vZGVbdmFsdWVGaWVsZF07XG4gIGlmIChcbiAgICAhbm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSAmJlxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkZXNjcmlwdG9yICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVzY3JpcHRvci5nZXQgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZXNjcmlwdG9yLnNldFxuICApIHtcbiAgICB2YXIgZ2V0ID0gZGVzY3JpcHRvci5nZXQsXG4gICAgICBzZXQgPSBkZXNjcmlwdG9yLnNldDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0LmNhbGwodGhpcyk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgfSxcbiAgICAgIHN0b3BUcmFja2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xuICAgICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciB8fCAobm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuICExO1xuICB2YXIgdHJhY2tlciA9IG5vZGUuX3ZhbHVlVHJhY2tlcjtcbiAgaWYgKCF0cmFja2VyKSByZXR1cm4gITA7XG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciB2YWx1ZSA9IFwiXCI7XG4gIG5vZGUgJiZcbiAgICAodmFsdWUgPSBpc0NoZWNrYWJsZShub2RlKVxuICAgICAgPyBub2RlLmNoZWNrZWRcbiAgICAgICAgPyBcInRydWVcIlxuICAgICAgICA6IFwiZmFsc2VcIlxuICAgICAgOiBub2RlLnZhbHVlKTtcbiAgbm9kZSA9IHZhbHVlO1xuICByZXR1cm4gbm9kZSAhPT0gbGFzdFZhbHVlID8gKHRyYWNrZXIuc2V0VmFsdWUobm9kZSksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8IChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudCA6IHZvaWQgMCk7XG4gIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cbnZhciBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzUmVnZXggPSAvW1xcblwiXFxcXF0vZztcbmZ1bmN0aW9uIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoXG4gICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlc1JlZ2V4LFxuICAgIGZ1bmN0aW9uIChjaCkge1xuICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikgKyBcIiBcIjtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnB1dChcbiAgZWxlbWVudCxcbiAgdmFsdWUsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgbGFzdERlZmF1bHRWYWx1ZSxcbiAgY2hlY2tlZCxcbiAgZGVmYXVsdENoZWNrZWQsXG4gIHR5cGUsXG4gIG5hbWVcbikge1xuICBlbGVtZW50Lm5hbWUgPSBcIlwiO1xuICBudWxsICE9IHR5cGUgJiZcbiAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHR5cGVcbiAgICA/IChlbGVtZW50LnR5cGUgPSB0eXBlKVxuICAgIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICBpZiAobnVsbCAhPSB2YWx1ZSlcbiAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZSkge1xuICAgICAgaWYgKCgwID09PSB2YWx1ZSAmJiBcIlwiID09PSBlbGVtZW50LnZhbHVlKSB8fCBlbGVtZW50LnZhbHVlICE9IHZhbHVlKVxuICAgICAgICBlbGVtZW50LnZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZVxuICAgICAgZWxlbWVudC52YWx1ZSAhPT0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpICYmXG4gICAgICAgIChlbGVtZW50LnZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgZWxzZVxuICAgIChcInN1Ym1pdFwiICE9PSB0eXBlICYmIFwicmVzZXRcIiAhPT0gdHlwZSkgfHwgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgbnVsbCAhPSB2YWx1ZVxuICAgID8gc2V0RGVmYXVsdFZhbHVlKGVsZW1lbnQsIHR5cGUsIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKVxuICAgIDogbnVsbCAhPSBkZWZhdWx0VmFsdWVcbiAgICAgID8gc2V0RGVmYXVsdFZhbHVlKGVsZW1lbnQsIHR5cGUsIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSlcbiAgICAgIDogbnVsbCAhPSBsYXN0RGVmYXVsdFZhbHVlICYmIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XG4gIG51bGwgPT0gY2hlY2tlZCAmJlxuICAgIG51bGwgIT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAoZWxlbWVudC5kZWZhdWx0Q2hlY2tlZCA9ICEhZGVmYXVsdENoZWNrZWQpO1xuICBudWxsICE9IGNoZWNrZWQgJiZcbiAgICAoZWxlbWVudC5jaGVja2VkID1cbiAgICAgIGNoZWNrZWQgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hlY2tlZCk7XG4gIG51bGwgIT0gbmFtZSAmJlxuICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gIFwic3ltYm9sXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gIFwiYm9vbGVhblwiICE9PSB0eXBlb2YgbmFtZVxuICAgID8gKGVsZW1lbnQubmFtZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKG5hbWUpKVxuICAgIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJuYW1lXCIpO1xufVxuZnVuY3Rpb24gaW5pdElucHV0KFxuICBlbGVtZW50LFxuICB2YWx1ZSxcbiAgZGVmYXVsdFZhbHVlLFxuICBjaGVja2VkLFxuICBkZWZhdWx0Q2hlY2tlZCxcbiAgdHlwZSxcbiAgbmFtZSxcbiAgaXNIeWRyYXRpbmdcbikge1xuICBudWxsICE9IHR5cGUgJiZcbiAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICAoZWxlbWVudC50eXBlID0gdHlwZSk7XG4gIGlmIChudWxsICE9IHZhbHVlIHx8IG51bGwgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgKFwic3VibWl0XCIgIT09IHR5cGUgJiYgXCJyZXNldFwiICE9PSB0eXBlKSB8fFxuICAgICAgICAodm9pZCAwICE9PSB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSlcbiAgICAgIClcbiAgICApXG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdFZhbHVlID1cbiAgICAgIG51bGwgIT0gZGVmYXVsdFZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSA6IFwiXCI7XG4gICAgdmFsdWUgPSBudWxsICE9IHZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICAgIGlzSHlkcmF0aW5nIHx8IHZhbHVlID09PSBlbGVtZW50LnZhbHVlIHx8IChlbGVtZW50LnZhbHVlID0gdmFsdWUpO1xuICAgIGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgY2hlY2tlZCA9IG51bGwgIT0gY2hlY2tlZCA/IGNoZWNrZWQgOiBkZWZhdWx0Q2hlY2tlZDtcbiAgY2hlY2tlZCA9XG4gICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJiAhIWNoZWNrZWQ7XG4gIGVsZW1lbnQuY2hlY2tlZCA9IGlzSHlkcmF0aW5nID8gZWxlbWVudC5jaGVja2VkIDogISFjaGVja2VkO1xuICBlbGVtZW50LmRlZmF1bHRDaGVja2VkID0gISFjaGVja2VkO1xuICBudWxsICE9IG5hbWUgJiZcbiAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICAoZWxlbWVudC5uYW1lID0gbmFtZSk7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgKFwibnVtYmVyXCIgPT09IHR5cGUgJiYgZ2V0QWN0aXZlRWxlbWVudChub2RlLm93bmVyRG9jdW1lbnQpID09PSBub2RlKSB8fFxuICAgIG5vZGUuZGVmYXVsdFZhbHVlID09PSBcIlwiICsgdmFsdWUgfHxcbiAgICAobm9kZS5kZWZhdWx0VmFsdWUgPSBcIlwiICsgdmFsdWUpO1xufVxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgbm9kZSA9IG5vZGUub3B0aW9ucztcbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgbXVsdGlwbGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgIG11bHRpcGxlW1wiJFwiICsgcHJvcFZhbHVlW2ldXSA9ICEwO1xuICAgIGZvciAocHJvcFZhbHVlID0gMDsgcHJvcFZhbHVlIDwgbm9kZS5sZW5ndGg7IHByb3BWYWx1ZSsrKVxuICAgICAgKGkgPSBtdWx0aXBsZS5oYXNPd25Qcm9wZXJ0eShcIiRcIiArIG5vZGVbcHJvcFZhbHVlXS52YWx1ZSkpLFxuICAgICAgICBub2RlW3Byb3BWYWx1ZV0uc2VsZWN0ZWQgIT09IGkgJiYgKG5vZGVbcHJvcFZhbHVlXS5zZWxlY3RlZCA9IGkpLFxuICAgICAgICBpICYmIHNldERlZmF1bHRTZWxlY3RlZCAmJiAobm9kZVtwcm9wVmFsdWVdLmRlZmF1bHRTZWxlY3RlZCA9ICEwKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9wVmFsdWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wVmFsdWUpO1xuICAgIG11bHRpcGxlID0gbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5vZGVbaV0udmFsdWUgPT09IHByb3BWYWx1ZSkge1xuICAgICAgICBub2RlW2ldLnNlbGVjdGVkID0gITA7XG4gICAgICAgIHNldERlZmF1bHRTZWxlY3RlZCAmJiAobm9kZVtpXS5kZWZhdWx0U2VsZWN0ZWQgPSAhMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IG11bHRpcGxlIHx8IG5vZGVbaV0uZGlzYWJsZWQgfHwgKG11bHRpcGxlID0gbm9kZVtpXSk7XG4gICAgfVxuICAgIG51bGwgIT09IG11bHRpcGxlICYmIChtdWx0aXBsZS5zZWxlY3RlZCA9ICEwKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlVGV4dGFyZWEoZWxlbWVudCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoXG4gICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICgodmFsdWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSkpLFxuICAgIHZhbHVlICE9PSBlbGVtZW50LnZhbHVlICYmIChlbGVtZW50LnZhbHVlID0gdmFsdWUpLFxuICAgIG51bGwgPT0gZGVmYXVsdFZhbHVlKVxuICApIHtcbiAgICBlbGVtZW50LmRlZmF1bHRWYWx1ZSAhPT0gdmFsdWUgJiYgKGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50LmRlZmF1bHRWYWx1ZSA9XG4gICAgbnVsbCAhPSBkZWZhdWx0VmFsdWUgPyBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShkZWZhdWx0VmFsdWUpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGluaXRUZXh0YXJlYShlbGVtZW50LCB2YWx1ZSwgZGVmYXVsdFZhbHVlLCBjaGlsZHJlbikge1xuICBpZiAobnVsbCA9PSB2YWx1ZSkge1xuICAgIGlmIChudWxsICE9IGNoaWxkcmVuKSB7XG4gICAgICBpZiAobnVsbCAhPSBkZWZhdWx0VmFsdWUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOTIpKTtcbiAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgaWYgKDEgPCBjaGlsZHJlbi5sZW5ndGgpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOTMpKTtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBudWxsID09IGRlZmF1bHRWYWx1ZSAmJiAoZGVmYXVsdFZhbHVlID0gXCJcIik7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gIGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gIGNoaWxkcmVuID09PSBkZWZhdWx0VmFsdWUgJiZcbiAgICBcIlwiICE9PSBjaGlsZHJlbiAmJlxuICAgIG51bGwgIT09IGNoaWxkcmVuICYmXG4gICAgKGVsZW1lbnQudmFsdWUgPSBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgaWYgKFxuICAgICAgZmlyc3RDaGlsZCAmJlxuICAgICAgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiZcbiAgICAgIDMgPT09IGZpcnN0Q2hpbGQubm9kZVR5cGVcbiAgICApIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG52YXIgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChcbiAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudCBhc3BlY3RSYXRpbyBib3JkZXJJbWFnZU91dHNldCBib3JkZXJJbWFnZVNsaWNlIGJvcmRlckltYWdlV2lkdGggYm94RmxleCBib3hGbGV4R3JvdXAgYm94T3JkaW5hbEdyb3VwIGNvbHVtbkNvdW50IGNvbHVtbnMgZmxleCBmbGV4R3JvdyBmbGV4UG9zaXRpdmUgZmxleFNocmluayBmbGV4TmVnYXRpdmUgZmxleE9yZGVyIGdyaWRBcmVhIGdyaWRSb3cgZ3JpZFJvd0VuZCBncmlkUm93U3BhbiBncmlkUm93U3RhcnQgZ3JpZENvbHVtbiBncmlkQ29sdW1uRW5kIGdyaWRDb2x1bW5TcGFuIGdyaWRDb2x1bW5TdGFydCBmb250V2VpZ2h0IGxpbmVDbGFtcCBsaW5lSGVpZ2h0IG9wYWNpdHkgb3JkZXIgb3JwaGFucyBzY2FsZSB0YWJTaXplIHdpZG93cyB6SW5kZXggem9vbSBmaWxsT3BhY2l0eSBmbG9vZE9wYWNpdHkgc3RvcE9wYWNpdHkgc3Ryb2tlRGFzaGFycmF5IHN0cm9rZURhc2hvZmZzZXQgc3Ryb2tlTWl0ZXJsaW1pdCBzdHJva2VPcGFjaXR5IHN0cm9rZVdpZHRoIE1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IE1vekJveEZsZXggTW96Qm94RmxleEdyb3VwIE1vekxpbmVDbGFtcCBtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IG1zRmxleCBtc1pvb20gbXNGbGV4R3JvdyBtc0ZsZXhOZWdhdGl2ZSBtc0ZsZXhPcmRlciBtc0ZsZXhQb3NpdGl2ZSBtc0ZsZXhTaHJpbmsgbXNHcmlkQ29sdW1uIG1zR3JpZENvbHVtblNwYW4gbXNHcmlkUm93IG1zR3JpZFJvd1NwYW4gV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgV2Via2l0Qm94RmxleCBXZWJLaXRCb3hGbGV4R3JvdXAgV2Via2l0Qm94T3JkaW5hbEdyb3VwIFdlYmtpdENvbHVtbkNvdW50IFdlYmtpdENvbHVtbnMgV2Via2l0RmxleCBXZWJraXRGbGV4R3JvdyBXZWJraXRGbGV4UG9zaXRpdmUgV2Via2l0RmxleFNocmluayBXZWJraXRMaW5lQ2xhbXBcIi5zcGxpdChcbiAgICBcIiBcIlxuICApXG4pO1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZShzdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IDAgPT09IHN0eWxlTmFtZS5pbmRleE9mKFwiLS1cIik7XG4gIG51bGwgPT0gdmFsdWUgfHwgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcIlwiID09PSB2YWx1ZVxuICAgID8gaXNDdXN0b21Qcm9wZXJ0eVxuICAgICAgPyBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIFwiXCIpXG4gICAgICA6IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgID8gKHN0eWxlLmNzc0Zsb2F0ID0gXCJcIilcbiAgICAgICAgOiAoc3R5bGVbc3R5bGVOYW1lXSA9IFwiXCIpXG4gICAgOiBpc0N1c3RvbVByb3BlcnR5XG4gICAgICA/IHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgdmFsdWUpXG4gICAgICA6IFwibnVtYmVyXCIgIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgIDAgPT09IHZhbHVlIHx8XG4gICAgICAgICAgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgID8gXCJmbG9hdFwiID09PSBzdHlsZU5hbWVcbiAgICAgICAgICA/IChzdHlsZS5jc3NGbG9hdCA9IHZhbHVlKVxuICAgICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSAoXCJcIiArIHZhbHVlKS50cmltKCkpXG4gICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZSArIFwicHhcIik7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMsIHByZXZTdHlsZXMpIHtcbiAgaWYgKG51bGwgIT0gc3R5bGVzICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdHlsZXMpXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MikpO1xuICBub2RlID0gbm9kZS5zdHlsZTtcbiAgaWYgKG51bGwgIT0gcHJldlN0eWxlcykge1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBwcmV2U3R5bGVzKVxuICAgICAgIXByZXZTdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSB8fFxuICAgICAgICAobnVsbCAhPSBzdHlsZXMgJiYgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHx8XG4gICAgICAgICgwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpXG4gICAgICAgICAgPyBub2RlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgXCJcIilcbiAgICAgICAgICA6IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgICAgICA/IChub2RlLmNzc0Zsb2F0ID0gXCJcIilcbiAgICAgICAgICAgIDogKG5vZGVbc3R5bGVOYW1lXSA9IFwiXCIpKTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUkMTYgaW4gc3R5bGVzKVxuICAgICAgKHN0eWxlTmFtZSA9IHN0eWxlc1tzdHlsZU5hbWUkMTZdKSxcbiAgICAgICAgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSQxNikgJiZcbiAgICAgICAgICBwcmV2U3R5bGVzW3N0eWxlTmFtZSQxNl0gIT09IHN0eWxlTmFtZSAmJlxuICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUobm9kZSwgc3R5bGVOYW1lJDE2LCBzdHlsZU5hbWUpO1xuICB9IGVsc2VcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUkMTcgaW4gc3R5bGVzKVxuICAgICAgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSQxNykgJiZcbiAgICAgICAgc2V0VmFsdWVGb3JTdHlsZShub2RlLCBzdHlsZU5hbWUkMTcsIHN0eWxlc1tzdHlsZU5hbWUkMTddKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh0YWdOYW1lKSB7XG4gIGlmICgtMSA9PT0gdGFnTmFtZS5pbmRleE9mKFwiLVwiKSkgcmV0dXJuICExO1xuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgcmV0dXJuICExO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gITA7XG4gIH1cbn1cbnZhciBhbGlhc2VzID0gbmV3IE1hcChbXG4gICAgW1wiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2VwdC1jaGFyc2V0XCJdLFxuICAgIFtcImh0bWxGb3JcIiwgXCJmb3JcIl0sXG4gICAgW1wiaHR0cEVxdWl2XCIsIFwiaHR0cC1lcXVpdlwiXSxcbiAgICBbXCJjcm9zc09yaWdpblwiLCBcImNyb3Nzb3JpZ2luXCJdLFxuICAgIFtcImFjY2VudEhlaWdodFwiLCBcImFjY2VudC1oZWlnaHRcIl0sXG4gICAgW1wiYWxpZ25tZW50QmFzZWxpbmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIl0sXG4gICAgW1wiYXJhYmljRm9ybVwiLCBcImFyYWJpYy1mb3JtXCJdLFxuICAgIFtcImJhc2VsaW5lU2hpZnRcIiwgXCJiYXNlbGluZS1zaGlmdFwiXSxcbiAgICBbXCJjYXBIZWlnaHRcIiwgXCJjYXAtaGVpZ2h0XCJdLFxuICAgIFtcImNsaXBQYXRoXCIsIFwiY2xpcC1wYXRoXCJdLFxuICAgIFtcImNsaXBSdWxlXCIsIFwiY2xpcC1ydWxlXCJdLFxuICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb25cIl0sXG4gICAgW1wiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiXSxcbiAgICBbXCJjb2xvclByb2ZpbGVcIiwgXCJjb2xvci1wcm9maWxlXCJdLFxuICAgIFtcImNvbG9yUmVuZGVyaW5nXCIsIFwiY29sb3ItcmVuZGVyaW5nXCJdLFxuICAgIFtcImRvbWluYW50QmFzZWxpbmVcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiXSxcbiAgICBbXCJlbmFibGVCYWNrZ3JvdW5kXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIl0sXG4gICAgW1wiZmlsbE9wYWNpdHlcIiwgXCJmaWxsLW9wYWNpdHlcIl0sXG4gICAgW1wiZmlsbFJ1bGVcIiwgXCJmaWxsLXJ1bGVcIl0sXG4gICAgW1wiZmxvb2RDb2xvclwiLCBcImZsb29kLWNvbG9yXCJdLFxuICAgIFtcImZsb29kT3BhY2l0eVwiLCBcImZsb29kLW9wYWNpdHlcIl0sXG4gICAgW1wiZm9udEZhbWlseVwiLCBcImZvbnQtZmFtaWx5XCJdLFxuICAgIFtcImZvbnRTaXplXCIsIFwiZm9udC1zaXplXCJdLFxuICAgIFtcImZvbnRTaXplQWRqdXN0XCIsIFwiZm9udC1zaXplLWFkanVzdFwiXSxcbiAgICBbXCJmb250U3RyZXRjaFwiLCBcImZvbnQtc3RyZXRjaFwiXSxcbiAgICBbXCJmb250U3R5bGVcIiwgXCJmb250LXN0eWxlXCJdLFxuICAgIFtcImZvbnRWYXJpYW50XCIsIFwiZm9udC12YXJpYW50XCJdLFxuICAgIFtcImZvbnRXZWlnaHRcIiwgXCJmb250LXdlaWdodFwiXSxcbiAgICBbXCJnbHlwaE5hbWVcIiwgXCJnbHlwaC1uYW1lXCJdLFxuICAgIFtcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiXSxcbiAgICBbXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiXSxcbiAgICBbXCJob3JpekFkdlhcIiwgXCJob3Jpei1hZHYteFwiXSxcbiAgICBbXCJob3Jpek9yaWdpblhcIiwgXCJob3Jpei1vcmlnaW4teFwiXSxcbiAgICBbXCJpbWFnZVJlbmRlcmluZ1wiLCBcImltYWdlLXJlbmRlcmluZ1wiXSxcbiAgICBbXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGV0dGVyLXNwYWNpbmdcIl0sXG4gICAgW1wibGlnaHRpbmdDb2xvclwiLCBcImxpZ2h0aW5nLWNvbG9yXCJdLFxuICAgIFtcIm1hcmtlckVuZFwiLCBcIm1hcmtlci1lbmRcIl0sXG4gICAgW1wibWFya2VyTWlkXCIsIFwibWFya2VyLW1pZFwiXSxcbiAgICBbXCJtYXJrZXJTdGFydFwiLCBcIm1hcmtlci1zdGFydFwiXSxcbiAgICBbXCJvdmVybGluZVBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgW1wib3ZlcmxpbmVUaGlja25lc3NcIiwgXCJvdmVybGluZS10aGlja25lc3NcIl0sXG4gICAgW1wicGFpbnRPcmRlclwiLCBcInBhaW50LW9yZGVyXCJdLFxuICAgIFtcInBhbm9zZS0xXCIsIFwicGFub3NlLTFcIl0sXG4gICAgW1wicG9pbnRlckV2ZW50c1wiLCBcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgIFtcInJlbmRlcmluZ0ludGVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIl0sXG4gICAgW1wic2hhcGVSZW5kZXJpbmdcIiwgXCJzaGFwZS1yZW5kZXJpbmdcIl0sXG4gICAgW1wic3RvcENvbG9yXCIsIFwic3RvcC1jb2xvclwiXSxcbiAgICBbXCJzdG9wT3BhY2l0eVwiLCBcInN0b3Atb3BhY2l0eVwiXSxcbiAgICBbXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCJdLFxuICAgIFtcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiXSxcbiAgICBbXCJzdHJva2VEYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaGFycmF5XCJdLFxuICAgIFtcInN0cm9rZURhc2hvZmZzZXRcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiXSxcbiAgICBbXCJzdHJva2VMaW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVjYXBcIl0sXG4gICAgW1wic3Ryb2tlTGluZWpvaW5cIiwgXCJzdHJva2UtbGluZWpvaW5cIl0sXG4gICAgW1wic3Ryb2tlTWl0ZXJsaW1pdFwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCJdLFxuICAgIFtcInN0cm9rZU9wYWNpdHlcIiwgXCJzdHJva2Utb3BhY2l0eVwiXSxcbiAgICBbXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZS13aWR0aFwiXSxcbiAgICBbXCJ0ZXh0QW5jaG9yXCIsIFwidGV4dC1hbmNob3JcIl0sXG4gICAgW1widGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIl0sXG4gICAgW1widGV4dFJlbmRlcmluZ1wiLCBcInRleHQtcmVuZGVyaW5nXCJdLFxuICAgIFtcInRyYW5zZm9ybU9yaWdpblwiLCBcInRyYW5zZm9ybS1vcmlnaW5cIl0sXG4gICAgW1widW5kZXJsaW5lUG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgW1widW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICBbXCJ1bmljb2RlQmlkaVwiLCBcInVuaWNvZGUtYmlkaVwiXSxcbiAgICBbXCJ1bmljb2RlUmFuZ2VcIiwgXCJ1bmljb2RlLXJhbmdlXCJdLFxuICAgIFtcInVuaXRzUGVyRW1cIiwgXCJ1bml0cy1wZXItZW1cIl0sXG4gICAgW1widkFscGhhYmV0aWNcIiwgXCJ2LWFscGhhYmV0aWNcIl0sXG4gICAgW1widkhhbmdpbmdcIiwgXCJ2LWhhbmdpbmdcIl0sXG4gICAgW1widklkZW9ncmFwaGljXCIsIFwidi1pZGVvZ3JhcGhpY1wiXSxcbiAgICBbXCJ2TWF0aGVtYXRpY2FsXCIsIFwidi1tYXRoZW1hdGljYWxcIl0sXG4gICAgW1widmVjdG9yRWZmZWN0XCIsIFwidmVjdG9yLWVmZmVjdFwiXSxcbiAgICBbXCJ2ZXJ0QWR2WVwiLCBcInZlcnQtYWR2LXlcIl0sXG4gICAgW1widmVydE9yaWdpblhcIiwgXCJ2ZXJ0LW9yaWdpbi14XCJdLFxuICAgIFtcInZlcnRPcmlnaW5ZXCIsIFwidmVydC1vcmlnaW4teVwiXSxcbiAgICBbXCJ3b3JkU3BhY2luZ1wiLCBcIndvcmQtc3BhY2luZ1wiXSxcbiAgICBbXCJ3cml0aW5nTW9kZVwiLCBcIndyaXRpbmctbW9kZVwiXSxcbiAgICBbXCJ4bWxuc1hsaW5rXCIsIFwieG1sbnM6eGxpbmtcIl0sXG4gICAgW1wieEhlaWdodFwiLCBcIngtaGVpZ2h0XCJdXG4gIF0pLFxuICBpc0phdmFTY3JpcHRQcm90b2NvbCA9XG4gICAgL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKjovaTtcbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICByZXR1cm4gaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdChcIlwiICsgdXJsKVxuICAgID8gXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgaGFzIGJsb2NrZWQgYSBqYXZhc2NyaXB0OiBVUkwgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLicpXCJcbiAgICA6IHVybDtcbn1cbnZhciBjdXJyZW50UmVwbGF5aW5nRXZlbnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgbmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG4gIG5hdGl2ZUV2ZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50ICYmXG4gICAgKG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO1xuICByZXR1cm4gMyA9PT0gbmF0aXZlRXZlbnQubm9kZVR5cGUgPyBuYXRpdmVFdmVudC5wYXJlbnROb2RlIDogbmF0aXZlRXZlbnQ7XG59XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGwsXG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlICYmICh0YXJnZXQgPSBpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSkpIHtcbiAgICB2YXIgcHJvcHMgPSB0YXJnZXRbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICBhOiBzd2l0Y2ggKCgodGFyZ2V0ID0gaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUpKSB7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgdXBkYXRlSW5wdXQoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICAgIHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJvcHMuY2hlY2tlZCxcbiAgICAgICAgICBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgICBwcm9wcy50eXBlLFxuICAgICAgICAgIHByb3BzLm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIGlmIChcInJhZGlvXCIgPT09IHByb3BzLnR5cGUgJiYgbnVsbCAhPSBpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAgICAgZm9yIChwcm9wcyA9IHRhcmdldDsgcHJvcHMucGFyZW50Tm9kZTsgKSBwcm9wcyA9IHByb3BzLnBhcmVudE5vZGU7XG4gICAgICAgICAgcHJvcHMgPSBwcm9wcy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJ2lucHV0W25hbWU9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhcbiAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJuYWxJbnN0YW5jZVxuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJ1wiXVt0eXBlPVwicmFkaW9cIl0nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IDA7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlIDwgcHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gcHJvcHNbaW50ZXJuYWxJbnN0YW5jZV07XG4gICAgICAgICAgICBpZiAob3RoZXJOb2RlICE9PSB0YXJnZXQgJiYgb3RoZXJOb2RlLmZvcm0gPT09IHRhcmdldC5mb3JtKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlclByb3BzID0gb3RoZXJOb2RlW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgICAgICAgICAgIGlmICghb3RoZXJQcm9wcykgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5MCkpO1xuICAgICAgICAgICAgICB1cGRhdGVJbnB1dChcbiAgICAgICAgICAgICAgICBvdGhlck5vZGUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5uYW1lXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlID0gMDtcbiAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UgPCBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlKytcbiAgICAgICAgICApXG4gICAgICAgICAgICAob3RoZXJOb2RlID0gcHJvcHNbaW50ZXJuYWxJbnN0YW5jZV0pLFxuICAgICAgICAgICAgICBvdGhlck5vZGUuZm9ybSA9PT0gdGFyZ2V0LmZvcm0gJiYgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhayBhO1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIHVwZGF0ZVRleHRhcmVhKHRhcmdldCwgcHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIGJyZWFrIGE7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIChpbnRlcm5hbEluc3RhbmNlID0gcHJvcHMudmFsdWUpLFxuICAgICAgICAgIG51bGwgIT0gaW50ZXJuYWxJbnN0YW5jZSAmJlxuICAgICAgICAgICAgdXBkYXRlT3B0aW9ucyh0YXJnZXQsICEhcHJvcHMubXVsdGlwbGUsIGludGVybmFsSW5zdGFuY2UsICExKTtcbiAgICB9XG4gIH1cbn1cbnZhciBpc0luc2lkZUV2ZW50SGFuZGxlciA9ICExO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSwgYikge1xuICBpZiAoaXNJbnNpZGVFdmVudEhhbmRsZXIpIHJldHVybiBmbihhLCBiKTtcbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSAhMDtcbiAgdHJ5IHtcbiAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZm4oYSk7XG4gICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoXG4gICAgICAoKGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gITEpLFxuICAgICAgbnVsbCAhPT0gcmVzdG9yZVRhcmdldCB8fCBudWxsICE9PSByZXN0b3JlUXVldWUpXG4gICAgKVxuICAgICAgaWYgKFxuICAgICAgICAoZmx1c2hTeW5jV29yayQxKCksXG4gICAgICAgIHJlc3RvcmVUYXJnZXQgJiZcbiAgICAgICAgICAoKGEgPSByZXN0b3JlVGFyZ2V0KSxcbiAgICAgICAgICAoZm4gPSByZXN0b3JlUXVldWUpLFxuICAgICAgICAgIChyZXN0b3JlUXVldWUgPSByZXN0b3JlVGFyZ2V0ID0gbnVsbCksXG4gICAgICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQoYSksXG4gICAgICAgICAgZm4pKVxuICAgICAgKVxuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgZm4ubGVuZ3RoOyBhKyspIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KGZuW2FdKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmIChudWxsID09PSBzdGF0ZU5vZGUpIHJldHVybiBudWxsO1xuICB2YXIgcHJvcHMgPSBzdGF0ZU5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgaWYgKG51bGwgPT09IHByb3BzKSByZXR1cm4gbnVsbDtcbiAgc3RhdGVOb2RlID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGE6IHN3aXRjaCAocmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgY2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6XG4gICAgY2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpcbiAgICBjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpcbiAgICBjYXNlIFwib25Nb3VzZURvd25cIjpcbiAgICBjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6XG4gICAgY2FzZSBcIm9uTW91c2VNb3ZlXCI6XG4gICAgY2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlVXBcIjpcbiAgICBjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlRW50ZXJcIjpcbiAgICAgIChwcm9wcyA9ICFwcm9wcy5kaXNhYmxlZCkgfHxcbiAgICAgICAgKChpbnN0ID0gaW5zdC50eXBlKSxcbiAgICAgICAgKHByb3BzID0gIShcbiAgICAgICAgICBcImJ1dHRvblwiID09PSBpbnN0IHx8XG4gICAgICAgICAgXCJpbnB1dFwiID09PSBpbnN0IHx8XG4gICAgICAgICAgXCJzZWxlY3RcIiA9PT0gaW5zdCB8fFxuICAgICAgICAgIFwidGV4dGFyZWFcIiA9PT0gaW5zdFxuICAgICAgICApKSk7XG4gICAgICBpbnN0ID0gIXByb3BzO1xuICAgICAgYnJlYWsgYTtcbiAgICBkZWZhdWx0OlxuICAgICAgaW5zdCA9ICExO1xuICB9XG4gIGlmIChpbnN0KSByZXR1cm4gbnVsbDtcbiAgaWYgKHN0YXRlTm9kZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBzdGF0ZU5vZGUpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIzMSwgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIHN0YXRlTm9kZSlcbiAgICApO1xuICByZXR1cm4gc3RhdGVOb2RlO1xufVxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gITE7XG5pZiAoY2FuVXNlRE9NKVxuICB0cnkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMsIFwicGFzc2l2ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMTtcbiAgfVxudmFyIHJvb3QgPSBudWxsLFxuICBzdGFydFRleHQgPSBudWxsLFxuICBmYWxsYmFja1RleHQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgdmFyIHN0YXJ0LFxuICAgIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQsXG4gICAgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aCxcbiAgICBlbmQsXG4gICAgZW5kVmFsdWUgPSBcInZhbHVlXCIgaW4gcm9vdCA/IHJvb3QudmFsdWUgOiByb290LnRleHRDb250ZW50LFxuICAgIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcbiAgZm9yIChcbiAgICBzdGFydCA9IDA7XG4gICAgc3RhcnQgPCBzdGFydExlbmd0aCAmJiBzdGFydFZhbHVlW3N0YXJ0XSA9PT0gZW5kVmFsdWVbc3RhcnRdO1xuICAgIHN0YXJ0KytcbiAgKTtcbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gIGZvciAoXG4gICAgZW5kID0gMTtcbiAgICBlbmQgPD0gbWluRW5kICYmXG4gICAgc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gPT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF07XG4gICAgZW5kKytcbiAgKTtcbiAgcmV0dXJuIChmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgMSA8IGVuZCA/IDEgLSBlbmQgOiB2b2lkIDApKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuICBcImNoYXJDb2RlXCIgaW4gbmF0aXZlRXZlbnRcbiAgICA/ICgobmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudC5jaGFyQ29kZSksXG4gICAgICAwID09PSBuYXRpdmVFdmVudCAmJiAxMyA9PT0ga2V5Q29kZSAmJiAobmF0aXZlRXZlbnQgPSAxMykpXG4gICAgOiAobmF0aXZlRXZlbnQgPSBrZXlDb2RlKTtcbiAgMTAgPT09IG5hdGl2ZUV2ZW50ICYmIChuYXRpdmVFdmVudCA9IDEzKTtcbiAgcmV0dXJuIDMyIDw9IG5hdGl2ZUV2ZW50IHx8IDEzID09PSBuYXRpdmVFdmVudCA/IG5hdGl2ZUV2ZW50IDogMDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKCkge1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEludGVyZmFjZSkge1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQoXG4gICAgcmVhY3ROYW1lLFxuICAgIHJlYWN0RXZlbnRUeXBlLFxuICAgIHRhcmdldEluc3QsXG4gICAgbmF0aXZlRXZlbnQsXG4gICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgKSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKVxuICAgICAgSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJlxuICAgICAgICAoKHJlYWN0TmFtZSA9IEludGVyZmFjZVtwcm9wTmFtZV0pLFxuICAgICAgICAodGhpc1twcm9wTmFtZV0gPSByZWFjdE5hbWVcbiAgICAgICAgICA/IHJlYWN0TmFtZShuYXRpdmVFdmVudClcbiAgICAgICAgICA6IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXSkpO1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKFxuICAgICAgbnVsbCAhPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICAgID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICA6ICExID09PSBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZVxuICAgIClcbiAgICAgID8gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgICAgIDogZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgICAgZXZlbnQgJiZcbiAgICAgICAgKGV2ZW50LnByZXZlbnREZWZhdWx0XG4gICAgICAgICAgPyBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgOiBcInVua25vd25cIiAhPT0gdHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICYmIChldmVudC5yZXR1cm5WYWx1ZSA9ICExKSxcbiAgICAgICAgKHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUpKTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICAgIGV2ZW50ICYmXG4gICAgICAgIChldmVudC5zdG9wUHJvcGFnYXRpb25cbiAgICAgICAgICA/IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgOiBcInVua25vd25cIiAhPT0gdHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAmJlxuICAgICAgICAgICAgKGV2ZW50LmNhbmNlbEJ1YmJsZSA9ICEwKSxcbiAgICAgICAgKHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSkpO1xuICAgIH0sXG4gICAgcGVyc2lzdDogZnVuY3Rpb24gKCkge30sXG4gICAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICB9KTtcbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgICBldmVudFBoYXNlOiAwLFxuICAgIGJ1YmJsZXM6IDAsXG4gICAgY2FuY2VsYWJsZTogMCxcbiAgICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgZGVmYXVsdFByZXZlbnRlZDogMCxcbiAgICBpc1RydXN0ZWQ6IDBcbiAgfSxcbiAgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSksXG4gIFVJRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7IHZpZXc6IDAsIGRldGFpbDogMCB9KSxcbiAgU3ludGhldGljVUlFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFVJRXZlbnRJbnRlcmZhY2UpLFxuICBsYXN0TW92ZW1lbnRYLFxuICBsYXN0TW92ZW1lbnRZLFxuICBsYXN0TW91c2VFdmVudCxcbiAgTW91c2VFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICAgIHNjcmVlblg6IDAsXG4gICAgc2NyZWVuWTogMCxcbiAgICBjbGllbnRYOiAwLFxuICAgIGNsaWVudFk6IDAsXG4gICAgcGFnZVg6IDAsXG4gICAgcGFnZVk6IDAsXG4gICAgY3RybEtleTogMCxcbiAgICBzaGlmdEtleTogMCxcbiAgICBhbHRLZXk6IDAsXG4gICAgbWV0YUtleTogMCxcbiAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gICAgYnV0dG9uOiAwLFxuICAgIGJ1dHRvbnM6IDAsXG4gICAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgICAgID8gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnRcbiAgICAgICAgICA/IGV2ZW50LnRvRWxlbWVudFxuICAgICAgICAgIDogZXZlbnQuZnJvbUVsZW1lbnRcbiAgICAgICAgOiBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIH0sXG4gICAgbW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChcIm1vdmVtZW50WFwiIGluIGV2ZW50KSByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgZXZlbnQgIT09IGxhc3RNb3VzZUV2ZW50ICYmXG4gICAgICAgIChsYXN0TW91c2VFdmVudCAmJiBcIm1vdXNlbW92ZVwiID09PSBldmVudC50eXBlXG4gICAgICAgICAgPyAoKGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWCksXG4gICAgICAgICAgICAobGFzdE1vdmVtZW50WSA9IGV2ZW50LnNjcmVlblkgLSBsYXN0TW91c2VFdmVudC5zY3JlZW5ZKSlcbiAgICAgICAgICA6IChsYXN0TW92ZW1lbnRZID0gbGFzdE1vdmVtZW50WCA9IDApLFxuICAgICAgICAobGFzdE1vdXNlRXZlbnQgPSBldmVudCkpO1xuICAgICAgcmV0dXJuIGxhc3RNb3ZlbWVudFg7XG4gICAgfSxcbiAgICBtb3ZlbWVudFk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwibW92ZW1lbnRZXCIgaW4gZXZlbnQgPyBldmVudC5tb3ZlbWVudFkgOiBsYXN0TW92ZW1lbnRZO1xuICAgIH1cbiAgfSksXG4gIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKSxcbiAgRHJhZ0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7IGRhdGFUcmFuc2ZlcjogMCB9KSxcbiAgU3ludGhldGljRHJhZ0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRHJhZ0V2ZW50SW50ZXJmYWNlKSxcbiAgRm9jdXNFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwgeyByZWxhdGVkVGFyZ2V0OiAwIH0pLFxuICBTeW50aGV0aWNGb2N1c0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSksXG4gIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIGFuaW1hdGlvbk5hbWU6IDAsXG4gICAgZWxhcHNlZFRpbWU6IDAsXG4gICAgcHNldWRvRWxlbWVudDogMFxuICB9KSxcbiAgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSksXG4gIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwiY2xpcGJvYXJkRGF0YVwiIGluIGV2ZW50XG4gICAgICAgID8gZXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgICA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgIH1cbiAgfSksXG4gIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpLFxuICBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwgeyBkYXRhOiAwIH0pLFxuICBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSksXG4gIG5vcm1hbGl6ZUtleSA9IHtcbiAgICBFc2M6IFwiRXNjYXBlXCIsXG4gICAgU3BhY2ViYXI6IFwiIFwiLFxuICAgIExlZnQ6IFwiQXJyb3dMZWZ0XCIsXG4gICAgVXA6IFwiQXJyb3dVcFwiLFxuICAgIFJpZ2h0OiBcIkFycm93UmlnaHRcIixcbiAgICBEb3duOiBcIkFycm93RG93blwiLFxuICAgIERlbDogXCJEZWxldGVcIixcbiAgICBXaW46IFwiT1NcIixcbiAgICBNZW51OiBcIkNvbnRleHRNZW51XCIsXG4gICAgQXBwczogXCJDb250ZXh0TWVudVwiLFxuICAgIFNjcm9sbDogXCJTY3JvbGxMb2NrXCIsXG4gICAgTW96UHJpbnRhYmxlS2V5OiBcIlVuaWRlbnRpZmllZFwiXG4gIH0sXG4gIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAgIDg6IFwiQmFja3NwYWNlXCIsXG4gICAgOTogXCJUYWJcIixcbiAgICAxMjogXCJDbGVhclwiLFxuICAgIDEzOiBcIkVudGVyXCIsXG4gICAgMTY6IFwiU2hpZnRcIixcbiAgICAxNzogXCJDb250cm9sXCIsXG4gICAgMTg6IFwiQWx0XCIsXG4gICAgMTk6IFwiUGF1c2VcIixcbiAgICAyMDogXCJDYXBzTG9ja1wiLFxuICAgIDI3OiBcIkVzY2FwZVwiLFxuICAgIDMyOiBcIiBcIixcbiAgICAzMzogXCJQYWdlVXBcIixcbiAgICAzNDogXCJQYWdlRG93blwiLFxuICAgIDM1OiBcIkVuZFwiLFxuICAgIDM2OiBcIkhvbWVcIixcbiAgICAzNzogXCJBcnJvd0xlZnRcIixcbiAgICAzODogXCJBcnJvd1VwXCIsXG4gICAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICAgIDQwOiBcIkFycm93RG93blwiLFxuICAgIDQ1OiBcIkluc2VydFwiLFxuICAgIDQ2OiBcIkRlbGV0ZVwiLFxuICAgIDExMjogXCJGMVwiLFxuICAgIDExMzogXCJGMlwiLFxuICAgIDExNDogXCJGM1wiLFxuICAgIDExNTogXCJGNFwiLFxuICAgIDExNjogXCJGNVwiLFxuICAgIDExNzogXCJGNlwiLFxuICAgIDExODogXCJGN1wiLFxuICAgIDExOTogXCJGOFwiLFxuICAgIDEyMDogXCJGOVwiLFxuICAgIDEyMTogXCJGMTBcIixcbiAgICAxMjI6IFwiRjExXCIsXG4gICAgMTIzOiBcIkYxMlwiLFxuICAgIDE0NDogXCJOdW1Mb2NrXCIsXG4gICAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgICAyMjQ6IFwiTWV0YVwiXG4gIH0sXG4gIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAgIEFsdDogXCJhbHRLZXlcIixcbiAgICBDb250cm9sOiBcImN0cmxLZXlcIixcbiAgICBNZXRhOiBcIm1ldGFLZXlcIixcbiAgICBTaGlmdDogXCJzaGlmdEtleVwiXG4gIH07XG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgbmF0aXZlRXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZVxuICAgID8gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpXG4gICAgOiAoa2V5QXJnID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXSlcbiAgICAgID8gISFuYXRpdmVFdmVudFtrZXlBcmddXG4gICAgICA6ICExO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gICAga2V5OiBmdW5jdGlvbiAobmF0aXZlRXZlbnQpIHtcbiAgICAgIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAgICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICAgICAgaWYgKFwiVW5pZGVudGlmaWVkXCIgIT09IGtleSkgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImtleXByZXNzXCIgPT09IG5hdGl2ZUV2ZW50LnR5cGVcbiAgICAgICAgPyAoKG5hdGl2ZUV2ZW50ID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkpLFxuICAgICAgICAgIDEzID09PSBuYXRpdmVFdmVudCA/IFwiRW50ZXJcIiA6IFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQpKVxuICAgICAgICA6IFwia2V5ZG93blwiID09PSBuYXRpdmVFdmVudC50eXBlIHx8IFwia2V5dXBcIiA9PT0gbmF0aXZlRXZlbnQudHlwZVxuICAgICAgICAgID8gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgXCJVbmlkZW50aWZpZWRcIlxuICAgICAgICAgIDogXCJcIjtcbiAgICB9LFxuICAgIGNvZGU6IDAsXG4gICAgbG9jYXRpb246IDAsXG4gICAgY3RybEtleTogMCxcbiAgICBzaGlmdEtleTogMCxcbiAgICBhbHRLZXk6IDAsXG4gICAgbWV0YUtleTogMCxcbiAgICByZXBlYXQ6IDAsXG4gICAgbG9jYWxlOiAwLFxuICAgIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBldmVudC50eXBlID8gZ2V0RXZlbnRDaGFyQ29kZShldmVudCkgOiAwO1xuICAgIH0sXG4gICAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJrZXlkb3duXCIgPT09IGV2ZW50LnR5cGUgfHwgXCJrZXl1cFwiID09PSBldmVudC50eXBlXG4gICAgICAgID8gZXZlbnQua2V5Q29kZVxuICAgICAgICA6IDA7XG4gICAgfSxcbiAgICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBldmVudC50eXBlXG4gICAgICAgID8gZ2V0RXZlbnRDaGFyQ29kZShldmVudClcbiAgICAgICAgOiBcImtleWRvd25cIiA9PT0gZXZlbnQudHlwZSB8fCBcImtleXVwXCIgPT09IGV2ZW50LnR5cGVcbiAgICAgICAgICA/IGV2ZW50LmtleUNvZGVcbiAgICAgICAgICA6IDA7XG4gICAgfVxuICB9KSxcbiAgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpLFxuICBQb2ludGVyRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgICBwb2ludGVySWQ6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHByZXNzdXJlOiAwLFxuICAgIHRhbmdlbnRpYWxQcmVzc3VyZTogMCxcbiAgICB0aWx0WDogMCxcbiAgICB0aWx0WTogMCxcbiAgICB0d2lzdDogMCxcbiAgICBwb2ludGVyVHlwZTogMCxcbiAgICBpc1ByaW1hcnk6IDBcbiAgfSksXG4gIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSksXG4gIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgICB0b3VjaGVzOiAwLFxuICAgIHRhcmdldFRvdWNoZXM6IDAsXG4gICAgY2hhbmdlZFRvdWNoZXM6IDAsXG4gICAgYWx0S2V5OiAwLFxuICAgIG1ldGFLZXk6IDAsXG4gICAgY3RybEtleTogMCxcbiAgICBzaGlmdEtleTogMCxcbiAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAgfSksXG4gIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUb3VjaEV2ZW50SW50ZXJmYWNlKSxcbiAgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIHByb3BlcnR5TmFtZTogMCxcbiAgICBlbGFwc2VkVGltZTogMCxcbiAgICBwc2V1ZG9FbGVtZW50OiAwXG4gIH0pLFxuICBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpLFxuICBXaGVlbEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBcImRlbHRhWFwiIGluIGV2ZW50XG4gICAgICAgID8gZXZlbnQuZGVsdGFYXG4gICAgICAgIDogXCJ3aGVlbERlbHRhWFwiIGluIGV2ZW50XG4gICAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVhcbiAgICAgICAgICA6IDA7XG4gICAgfSxcbiAgICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwiZGVsdGFZXCIgaW4gZXZlbnRcbiAgICAgICAgPyBldmVudC5kZWx0YVlcbiAgICAgICAgOiBcIndoZWVsRGVsdGFZXCIgaW4gZXZlbnRcbiAgICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhWVxuICAgICAgICAgIDogXCJ3aGVlbERlbHRhXCIgaW4gZXZlbnRcbiAgICAgICAgICAgID8gLWV2ZW50LndoZWVsRGVsdGFcbiAgICAgICAgICAgIDogMDtcbiAgICB9LFxuICAgIGRlbHRhWjogMCxcbiAgICBkZWx0YU1vZGU6IDBcbiAgfSksXG4gIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKSxcbiAgVG9nZ2xlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gICAgbmV3U3RhdGU6IDAsXG4gICAgb2xkU3RhdGU6IDBcbiAgfSksXG4gIFN5bnRoZXRpY1RvZ2dsZUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVG9nZ2xlRXZlbnRJbnRlcmZhY2UpLFxuICBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl0sXG4gIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBjYW5Vc2VET00gJiYgXCJDb21wb3NpdGlvbkV2ZW50XCIgaW4gd2luZG93LFxuICBkb2N1bWVudE1vZGUgPSBudWxsO1xuY2FuVXNlRE9NICYmXG4gIFwiZG9jdW1lbnRNb2RlXCIgaW4gZG9jdW1lbnQgJiZcbiAgKGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBjYW5Vc2VET00gJiYgXCJUZXh0RXZlbnRcIiBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSxcbiAgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPVxuICAgIGNhblVzZURPTSAmJlxuICAgICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fFxuICAgICAgKGRvY3VtZW50TW9kZSAmJiA4IDwgZG9jdW1lbnRNb2RlICYmIDExID49IGRvY3VtZW50TW9kZSkpLFxuICBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiksXG4gIGhhc1NwYWNlS2V5cHJlc3MgPSAhMTtcbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImtleXVwXCI6XG4gICAgICByZXR1cm4gLTEgIT09IEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpO1xuICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICByZXR1cm4gMjI5ICE9PSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgIHJldHVybiAhMDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5hdGl2ZUV2ZW50ICYmIFwiZGF0YVwiIGluIG5hdGl2ZUV2ZW50XG4gICAgPyBuYXRpdmVFdmVudC5kYXRhXG4gICAgOiBudWxsO1xufVxudmFyIGlzQ29tcG9zaW5nID0gITE7XG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgIGlmICgzMiAhPT0gbmF0aXZlRXZlbnQud2hpY2gpIHJldHVybiBudWxsO1xuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9ICEwO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG4gICAgY2FzZSBcInRleHRJbnB1dFwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGRvbUV2ZW50TmFtZSA9IG5hdGl2ZUV2ZW50LmRhdGEpLFxuICAgICAgICBkb21FdmVudE5hbWUgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcyA/IG51bGwgOiBkb21FdmVudE5hbWVcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBpZiAoaXNDb21wb3NpbmcpXG4gICAgcmV0dXJuIFwiY29tcG9zaXRpb25lbmRcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiZcbiAgICAgICAgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKVxuICAgICAgPyAoKGRvbUV2ZW50TmFtZSA9IGdldERhdGEoKSksXG4gICAgICAgIChmYWxsYmFja1RleHQgPSBzdGFydFRleHQgPSByb290ID0gbnVsbCksXG4gICAgICAgIChpc0NvbXBvc2luZyA9ICExKSxcbiAgICAgICAgZG9tRXZlbnROYW1lKVxuICAgICAgOiBudWxsO1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICBpZiAoXG4gICAgICAgICEobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgfHxcbiAgICAgICAgKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KVxuICAgICAgKSB7XG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIDEgPCBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJiBcImtvXCIgIT09IG5hdGl2ZUV2ZW50LmxvY2FsZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gIGNvbG9yOiAhMCxcbiAgZGF0ZTogITAsXG4gIGRhdGV0aW1lOiAhMCxcbiAgXCJkYXRldGltZS1sb2NhbFwiOiAhMCxcbiAgZW1haWw6ICEwLFxuICBtb250aDogITAsXG4gIG51bWJlcjogITAsXG4gIHBhc3N3b3JkOiAhMCxcbiAgcmFuZ2U6ICEwLFxuICBzZWFyY2g6ICEwLFxuICB0ZWw6ICEwLFxuICB0ZXh0OiAhMCxcbiAgdGltZTogITAsXG4gIHVybDogITAsXG4gIHdlZWs6ICEwXG59O1xuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gbm9kZU5hbWVcbiAgICA/ICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdXG4gICAgOiBcInRleHRhcmVhXCIgPT09IG5vZGVOYW1lXG4gICAgICA/ICEwXG4gICAgICA6ICExO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KFxuICBkaXNwYXRjaFF1ZXVlLFxuICBpbnN0LFxuICBuYXRpdmVFdmVudCxcbiAgdGFyZ2V0XG4pIHtcbiAgcmVzdG9yZVRhcmdldFxuICAgID8gcmVzdG9yZVF1ZXVlXG4gICAgICA/IHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldClcbiAgICAgIDogKHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdKVxuICAgIDogKHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQpO1xuICBpbnN0ID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGluc3QsIFwib25DaGFuZ2VcIik7XG4gIDAgPCBpbnN0Lmxlbmd0aCAmJlxuICAgICgobmF0aXZlRXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICBcImNoYW5nZVwiLFxuICAgICAgbnVsbCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgdGFyZ2V0XG4gICAgKSksXG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IG5hdGl2ZUV2ZW50LCBsaXN0ZW5lcnM6IGluc3QgfSkpO1xufVxudmFyIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGwsXG4gIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG59XG5mdW5jdGlvbiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCkge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkgcmV0dXJuIHRhcmdldEluc3Q7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChcImNoYW5nZVwiID09PSBkb21FdmVudE5hbWUpIHJldHVybiB0YXJnZXRJbnN0O1xufVxudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9ICExO1xuaWYgKGNhblVzZURPTSkge1xuICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyODM7XG4gIGlmIChjYW5Vc2VET00pIHtcbiAgICB2YXIgaXNTdXBwb3J0ZWQkanNjb21wJGlubGluZV80MTggPSBcIm9uaW5wdXRcIiBpbiBkb2N1bWVudDtcbiAgICBpZiAoIWlzU3VwcG9ydGVkJGpzY29tcCRpbmxpbmVfNDE4KSB7XG4gICAgICB2YXIgZWxlbWVudCRqc2NvbXAkaW5saW5lXzQxOSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50JGpzY29tcCRpbmxpbmVfNDE5LnNldEF0dHJpYnV0ZShcIm9uaW5wdXRcIiwgXCJyZXR1cm47XCIpO1xuICAgICAgaXNTdXBwb3J0ZWQkanNjb21wJGlubGluZV80MTggPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50JGpzY29tcCRpbmxpbmVfNDE5Lm9uaW5wdXQ7XG4gICAgfVxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjgzID0gaXNTdXBwb3J0ZWQkanNjb21wJGlubGluZV80MTg7XG4gIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDI4MyA9ICExO1xuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPVxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjgzICYmXG4gICAgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgOSA8IGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG59XG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgYWN0aXZlRWxlbWVudCQxICYmXG4gICAgKGFjdGl2ZUVsZW1lbnQkMS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIiwgaGFuZGxlUHJvcGVydHlDaGFuZ2UpLFxuICAgIChhY3RpdmVFbGVtZW50SW5zdCQxID0gYWN0aXZlRWxlbWVudCQxID0gbnVsbCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKFxuICAgIFwidmFsdWVcIiA9PT0gbmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICYmXG4gICAgZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0JDEpXG4gICkge1xuICAgIHZhciBkaXNwYXRjaFF1ZXVlID0gW107XG4gICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KVxuICAgICk7XG4gICAgYmF0Y2hlZFVwZGF0ZXMkMShydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgXCJmb2N1c2luXCIgPT09IGRvbUV2ZW50TmFtZVxuICAgID8gKHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCksXG4gICAgICAoYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0KSxcbiAgICAgIChhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdCksXG4gICAgICBhY3RpdmVFbGVtZW50JDEuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKSlcbiAgICA6IFwiZm9jdXNvdXRcIiA9PT0gZG9tRXZlbnROYW1lICYmIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSkge1xuICBpZiAoXG4gICAgXCJzZWxlY3Rpb25jaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgXCJrZXl1cFwiID09PSBkb21FdmVudE5hbWUgfHxcbiAgICBcImtleWRvd25cIiA9PT0gZG9tRXZlbnROYW1lXG4gIClcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0JDEpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChcImNsaWNrXCIgPT09IGRvbUV2ZW50TmFtZSkgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChcImlucHV0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcImNoYW5nZVwiID09PSBkb21FdmVudE5hbWUpXG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbn1cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xufVxudmFyIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXM7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHJldHVybiAhMDtcbiAgaWYgKFxuICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpBIHx8XG4gICAgbnVsbCA9PT0gb2JqQSB8fFxuICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgbnVsbCA9PT0gb2JqQlxuICApXG4gICAgcmV0dXJuICExO1xuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKSxcbiAgICBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgZm9yIChrZXlzQiA9IDA7IGtleXNCIDwga2V5c0EubGVuZ3RoOyBrZXlzQisrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtrZXlzQl07XG4gICAgaWYgKFxuICAgICAgIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwgY3VycmVudEtleSkgfHxcbiAgICAgICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKVxuICAgIClcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIGZvciAoOyBub2RlICYmIG5vZGUuZmlyc3RDaGlsZDsgKSBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHJvb3QgPSAwO1xuICBmb3IgKHZhciBub2RlRW5kOyBub2RlOyApIHtcbiAgICBpZiAoMyA9PT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgbm9kZUVuZCA9IHJvb3QgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgIGlmIChyb290IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgLSByb290IH07XG4gICAgICByb290ID0gbm9kZUVuZDtcbiAgICB9XG4gICAgYToge1xuICAgICAgZm9yICg7IG5vZGU7ICkge1xuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIHJldHVybiBvdXRlck5vZGUgJiYgaW5uZXJOb2RlXG4gICAgPyBvdXRlck5vZGUgPT09IGlubmVyTm9kZVxuICAgICAgPyAhMFxuICAgICAgOiBvdXRlck5vZGUgJiYgMyA9PT0gb3V0ZXJOb2RlLm5vZGVUeXBlXG4gICAgICAgID8gITFcbiAgICAgICAgOiBpbm5lck5vZGUgJiYgMyA9PT0gaW5uZXJOb2RlLm5vZGVUeXBlXG4gICAgICAgICAgPyBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICA6IFwiY29udGFpbnNcIiBpbiBvdXRlck5vZGVcbiAgICAgICAgICAgID8gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSlcbiAgICAgICAgICAgIDogb3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgICAgICAgID8gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNilcbiAgICAgICAgICAgICAgOiAhMVxuICAgIDogITE7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50RGVlcChjb250YWluZXJJbmZvKSB7XG4gIGNvbnRhaW5lckluZm8gPVxuICAgIG51bGwgIT0gY29udGFpbmVySW5mbyAmJlxuICAgIG51bGwgIT0gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50ICYmXG4gICAgbnVsbCAhPSBjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXdcbiAgICAgID8gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3XG4gICAgICA6IHdpbmRvdztcbiAgZm9yIChcbiAgICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoY29udGFpbmVySW5mby5kb2N1bWVudCk7XG4gICAgZWxlbWVudCBpbnN0YW5jZW9mIGNvbnRhaW5lckluZm8uSFRNTElGcmFtZUVsZW1lbnQ7XG5cbiAgKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICB9XG4gICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgY29udGFpbmVySW5mbyA9IGVsZW1lbnQuY29udGVudFdpbmRvdztcbiAgICBlbHNlIGJyZWFrO1xuICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KGNvbnRhaW5lckluZm8uZG9jdW1lbnQpO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChcbiAgICBub2RlTmFtZSAmJlxuICAgICgoXCJpbnB1dFwiID09PSBub2RlTmFtZSAmJlxuICAgICAgKFwidGV4dFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgXCJzZWFyY2hcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgIFwidGVsXCIgPT09IGVsZW0udHlwZSB8fFxuICAgICAgICBcInVybFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgXCJwYXNzd29yZFwiID09PSBlbGVtLnR5cGUpKSB8fFxuICAgICAgXCJ0ZXh0YXJlYVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgXCJ0cnVlXCIgPT09IGVsZW0uY29udGVudEVkaXRhYmxlKVxuICApO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLCBjb250YWluZXJJbmZvKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKGNvbnRhaW5lckluZm8pO1xuICBjb250YWluZXJJbmZvID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoXG4gICAgY3VyRm9jdXNlZEVsZW0gIT09IGNvbnRhaW5lckluZm8gJiZcbiAgICBjb250YWluZXJJbmZvICYmXG4gICAgY29udGFpbmVySW5mby5vd25lckRvY3VtZW50ICYmXG4gICAgY29udGFpbnNOb2RlKGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNvbnRhaW5lckluZm8pXG4gICkge1xuICAgIGlmIChudWxsICE9PSBwcmlvclNlbGVjdGlvblJhbmdlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhjb250YWluZXJJbmZvKSlcbiAgICAgIGlmIChcbiAgICAgICAgKChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uID0gcHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCksXG4gICAgICAgIChjdXJGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uUmFuZ2UuZW5kKSxcbiAgICAgICAgdm9pZCAwID09PSBjdXJGb2N1c2VkRWxlbSAmJlxuICAgICAgICAgIChjdXJGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pLFxuICAgICAgICBcInNlbGVjdGlvblN0YXJ0XCIgaW4gY29udGFpbmVySW5mbylcbiAgICAgIClcbiAgICAgICAgKGNvbnRhaW5lckluZm8uc2VsZWN0aW9uU3RhcnQgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSxcbiAgICAgICAgICAoY29udGFpbmVySW5mby5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLFxuICAgICAgICAgICAgY29udGFpbmVySW5mby52YWx1ZS5sZW5ndGhcbiAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAoKGN1ckZvY3VzZWRFbGVtID1cbiAgICAgICAgICAoKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24gPVxuICAgICAgICAgICAgY29udGFpbmVySW5mby5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSAmJlxuICAgICAgICAgICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5kZWZhdWx0VmlldykgfHxcbiAgICAgICAgICB3aW5kb3cpLFxuICAgICAgICBjdXJGb2N1c2VkRWxlbS5nZXRTZWxlY3Rpb24pXG4gICAgICApIHtcbiAgICAgICAgY3VyRm9jdXNlZEVsZW0gPSBjdXJGb2N1c2VkRWxlbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRhaW5lckluZm8udGV4dENvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4ocHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgcHJpb3JTZWxlY3Rpb25SYW5nZSA9XG4gICAgICAgICAgdm9pZCAwID09PSBwcmlvclNlbGVjdGlvblJhbmdlLmVuZFxuICAgICAgICAgICAgPyBzdGFydFxuICAgICAgICAgICAgOiBNYXRoLm1pbihwcmlvclNlbGVjdGlvblJhbmdlLmVuZCwgbGVuZ3RoKTtcbiAgICAgICAgIWN1ckZvY3VzZWRFbGVtLmV4dGVuZCAmJlxuICAgICAgICAgIHN0YXJ0ID4gcHJpb3JTZWxlY3Rpb25SYW5nZSAmJlxuICAgICAgICAgICgobGVuZ3RoID0gcHJpb3JTZWxlY3Rpb25SYW5nZSksXG4gICAgICAgICAgKHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBzdGFydCksXG4gICAgICAgICAgKHN0YXJ0ID0gbGVuZ3RoKSk7XG4gICAgICAgIGxlbmd0aCA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQoY29udGFpbmVySW5mbywgc3RhcnQpO1xuICAgICAgICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChcbiAgICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgICAgbGVuZ3RoICYmXG4gICAgICAgICAgZW5kTWFya2VyICYmXG4gICAgICAgICAgKDEgIT09IGN1ckZvY3VzZWRFbGVtLnJhbmdlQ291bnQgfHxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmFuY2hvck5vZGUgIT09IGxlbmd0aC5ub2RlIHx8XG4gICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5hbmNob3JPZmZzZXQgIT09IGxlbmd0aC5vZmZzZXQgfHxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmZvY3VzTm9kZSAhPT0gZW5kTWFya2VyLm5vZGUgfHxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmZvY3VzT2Zmc2V0ICE9PSBlbmRNYXJrZXIub2Zmc2V0KSAmJlxuICAgICAgICAgICgocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiA9XG4gICAgICAgICAgICBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmNyZWF0ZVJhbmdlKCkpLFxuICAgICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2V0U3RhcnQobGVuZ3RoLm5vZGUsIGxlbmd0aC5vZmZzZXQpLFxuICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLnJlbW92ZUFsbFJhbmdlcygpLFxuICAgICAgICAgIHN0YXJ0ID4gcHJpb3JTZWxlY3Rpb25SYW5nZVxuICAgICAgICAgICAgPyAoY3VyRm9jdXNlZEVsZW0uYWRkUmFuZ2UocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiksXG4gICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCkpXG4gICAgICAgICAgICA6IChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNldEVuZChcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIubm9kZSxcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIub2Zmc2V0XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmFkZFJhbmdlKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pKSk7XG4gICAgICB9XG4gICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiA9IFtdO1xuICAgIGZvciAoXG4gICAgICBjdXJGb2N1c2VkRWxlbSA9IGNvbnRhaW5lckluZm87XG4gICAgICAoY3VyRm9jdXNlZEVsZW0gPSBjdXJGb2N1c2VkRWxlbS5wYXJlbnROb2RlKTtcblxuICAgIClcbiAgICAgIDEgPT09IGN1ckZvY3VzZWRFbGVtLm5vZGVUeXBlICYmXG4gICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24ucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogY3VyRm9jdXNlZEVsZW0sXG4gICAgICAgICAgbGVmdDogY3VyRm9jdXNlZEVsZW0uc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGN1ckZvY3VzZWRFbGVtLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250YWluZXJJbmZvLmZvY3VzICYmIGNvbnRhaW5lckluZm8uZm9jdXMoKTtcbiAgICBmb3IgKFxuICAgICAgY29udGFpbmVySW5mbyA9IDA7XG4gICAgICBjb250YWluZXJJbmZvIDwgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5sZW5ndGg7XG4gICAgICBjb250YWluZXJJbmZvKytcbiAgICApXG4gICAgICAoY3VyRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uW2NvbnRhaW5lckluZm9dKSxcbiAgICAgICAgKGN1ckZvY3VzZWRFbGVtLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGN1ckZvY3VzZWRFbGVtLmxlZnQpLFxuICAgICAgICAoY3VyRm9jdXNlZEVsZW0uZWxlbWVudC5zY3JvbGxUb3AgPSBjdXJGb2N1c2VkRWxlbS50b3ApO1xuICB9XG59XG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID1cbiAgICBjYW5Vc2VET00gJiYgXCJkb2N1bWVudE1vZGVcIiBpbiBkb2N1bWVudCAmJiAxMSA+PSBkb2N1bWVudC5kb2N1bWVudE1vZGUsXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsLFxuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGwsXG4gIGxhc3RTZWxlY3Rpb24gPSBudWxsLFxuICBtb3VzZURvd24gPSAhMTtcbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZG9jID1cbiAgICBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICA/IG5hdGl2ZUV2ZW50VGFyZ2V0LmRvY3VtZW50XG4gICAgICA6IDkgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlXG4gICAgICAgID8gbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICBtb3VzZURvd24gfHxcbiAgICBudWxsID09IGFjdGl2ZUVsZW1lbnQgfHxcbiAgICBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KGRvYykgfHxcbiAgICAoKGRvYyA9IGFjdGl2ZUVsZW1lbnQpLFxuICAgIFwic2VsZWN0aW9uU3RhcnRcIiBpbiBkb2MgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGRvYylcbiAgICAgID8gKGRvYyA9IHsgc3RhcnQ6IGRvYy5zZWxlY3Rpb25TdGFydCwgZW5kOiBkb2Muc2VsZWN0aW9uRW5kIH0pXG4gICAgICA6ICgoZG9jID0gKFxuICAgICAgICAgIChkb2Mub3duZXJEb2N1bWVudCAmJiBkb2Mub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHxcbiAgICAgICAgICB3aW5kb3dcbiAgICAgICAgKS5nZXRTZWxlY3Rpb24oKSksXG4gICAgICAgIChkb2MgPSB7XG4gICAgICAgICAgYW5jaG9yTm9kZTogZG9jLmFuY2hvck5vZGUsXG4gICAgICAgICAgYW5jaG9yT2Zmc2V0OiBkb2MuYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgIGZvY3VzTm9kZTogZG9jLmZvY3VzTm9kZSxcbiAgICAgICAgICBmb2N1c09mZnNldDogZG9jLmZvY3VzT2Zmc2V0XG4gICAgICAgIH0pKSxcbiAgICAobGFzdFNlbGVjdGlvbiAmJiBzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgZG9jKSkgfHxcbiAgICAgICgobGFzdFNlbGVjdGlvbiA9IGRvYyksXG4gICAgICAoZG9jID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGFjdGl2ZUVsZW1lbnRJbnN0LCBcIm9uU2VsZWN0XCIpKSxcbiAgICAgIDAgPCBkb2MubGVuZ3RoICYmXG4gICAgICAgICgobmF0aXZlRXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICAgICAgXCJvblNlbGVjdFwiLFxuICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICApKSxcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IG5hdGl2ZUV2ZW50LCBsaXN0ZW5lcnM6IGRvYyB9KSxcbiAgICAgICAgKG5hdGl2ZUV2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQpKSkpO1xufVxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzW1wiV2Via2l0XCIgKyBzdHlsZVByb3BdID0gXCJ3ZWJraXRcIiArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbXCJNb3pcIiArIHN0eWxlUHJvcF0gPSBcIm1velwiICsgZXZlbnROYW1lO1xuICByZXR1cm4gcHJlZml4ZXM7XG59XG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gICAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiQW5pbWF0aW9uXCIsIFwiQW5pbWF0aW9uRW5kXCIpLFxuICAgIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcChcIkFuaW1hdGlvblwiLCBcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxcbiAgICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcChcIkFuaW1hdGlvblwiLCBcIkFuaW1hdGlvblN0YXJ0XCIpLFxuICAgIHRyYW5zaXRpb25ydW46IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvblJ1blwiKSxcbiAgICB0cmFuc2l0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvblN0YXJ0XCIpLFxuICAgIHRyYW5zaXRpb25jYW5jZWw6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvbkNhbmNlbFwiKSxcbiAgICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25FbmRcIilcbiAgfSxcbiAgcHJlZml4ZWRFdmVudE5hbWVzID0ge30sXG4gIHN0eWxlID0ge307XG5jYW5Vc2VET00gJiZcbiAgKChzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUpLFxuICBcIkFuaW1hdGlvbkV2ZW50XCIgaW4gd2luZG93IHx8XG4gICAgKGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uLFxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLFxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFxuICBcIlRyYW5zaXRpb25FdmVudFwiIGluIHdpbmRvdyB8fFxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHJldHVybiBldmVudE5hbWU7XG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdLFxuICAgIHN0eWxlUHJvcDtcbiAgZm9yIChzdHlsZVByb3AgaW4gcHJlZml4TWFwKVxuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpXG4gICAgICByZXR1cm4gKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF0pO1xuICByZXR1cm4gZXZlbnROYW1lO1xufVxudmFyIEFOSU1BVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbmVuZFwiKSxcbiAgQU5JTUFUSU9OX0lURVJBVElPTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpLFxuICBBTklNQVRJT05fU1RBUlQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbnN0YXJ0XCIpLFxuICBUUkFOU0lUSU9OX1JVTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbnJ1blwiKSxcbiAgVFJBTlNJVElPTl9TVEFSVCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbnN0YXJ0XCIpLFxuICBUUkFOU0lUSU9OX0NBTkNFTCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbmNhbmNlbFwiKSxcbiAgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25lbmRcIiksXG4gIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzID0gbmV3IE1hcCgpLFxuICBzaW1wbGVFdmVudFBsdWdpbkV2ZW50cyA9XG4gICAgXCJhYm9ydCBhdXhDbGljayBiZWZvcmVUb2dnbGUgY2FuY2VsIGNhblBsYXkgY2FuUGxheVRocm91Z2ggY2xpY2sgY2xvc2UgY29udGV4dE1lbnUgY29weSBjdXQgZHJhZyBkcmFnRW5kIGRyYWdFbnRlciBkcmFnRXhpdCBkcmFnTGVhdmUgZHJhZ092ZXIgZHJhZ1N0YXJ0IGRyb3AgZHVyYXRpb25DaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgZ290UG9pbnRlckNhcHR1cmUgaW5wdXQgaW52YWxpZCBrZXlEb3duIGtleVByZXNzIGtleVVwIGxvYWQgbG9hZGVkRGF0YSBsb2FkZWRNZXRhZGF0YSBsb2FkU3RhcnQgbG9zdFBvaW50ZXJDYXB0dXJlIG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHBvaW50ZXJDYW5jZWwgcG9pbnRlckRvd24gcG9pbnRlck1vdmUgcG9pbnRlck91dCBwb2ludGVyT3ZlciBwb2ludGVyVXAgcHJvZ3Jlc3MgcmF0ZUNoYW5nZSByZXNldCByZXNpemUgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdWJtaXQgc3VzcGVuZCB0aW1lVXBkYXRlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoU3RhcnQgdm9sdW1lQ2hhbmdlIHNjcm9sbCBzY3JvbGxFbmQgdG9nZ2xlIHRvdWNoTW92ZSB3YWl0aW5nIHdoZWVsXCIuc3BsaXQoXG4gICAgICBcIiBcIlxuICAgICk7XG5mdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSwgcmVhY3ROYW1lKSB7XG4gIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLnNldChkb21FdmVudE5hbWUsIHJlYWN0TmFtZSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFtkb21FdmVudE5hbWVdKTtcbn1cbnZhciBjb25jdXJyZW50UXVldWVzID0gW10sXG4gIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDAsXG4gIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IDA7XG5mdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuICBmb3IgKFxuICAgIHZhciBlbmRJbmRleCA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleCxcbiAgICAgIGkgPSAoY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCk7XG4gICAgaSA8IGVuZEluZGV4O1xuXG4gICkge1xuICAgIHZhciBmaWJlciA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgcXVldWUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgbGFuZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICBpZiAobnVsbCAhPT0gcXVldWUgJiYgbnVsbCAhPT0gdXBkYXRlKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cbiAgICAwICE9PSBsYW5lICYmIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBxdWV1ZTtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSB1cGRhdGU7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzIHw9IGxhbmU7XG4gIGZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIubGFuZXMgfD0gbGFuZSk7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKSB7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgbnVsbCwgbnVsbCwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gbGFuZSk7XG4gIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgKHBhcmVudC5jaGlsZExhbmVzIHw9IGxhbmUpLFxuICAgICAgKGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGUpLFxuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgIDIyID09PSBwYXJlbnQudGFnICYmXG4gICAgICAgICgoc291cmNlRmliZXIgPSBwYXJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHwgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiAxIHx8IChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAoc291cmNlRmliZXIgPSBwYXJlbnQpLFxuICAgICAgKHBhcmVudCA9IHBhcmVudC5yZXR1cm4pO1xuICBpc0hpZGRlbiAmJlxuICAgIG51bGwgIT09IHVwZGF0ZSAmJlxuICAgIDMgPT09IHNvdXJjZUZpYmVyLnRhZyAmJlxuICAgICgocGFyZW50ID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAoaXNIaWRkZW4gPSAzMSAtIGNsejMyKGxhbmUpKSxcbiAgICAocGFyZW50ID0gcGFyZW50LmhpZGRlblVwZGF0ZXMpLFxuICAgIChzb3VyY2VGaWJlciA9IHBhcmVudFtpc0hpZGRlbl0pLFxuICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICA/IChwYXJlbnRbaXNIaWRkZW5dID0gW3VwZGF0ZV0pXG4gICAgICA6IHNvdXJjZUZpYmVyLnB1c2godXBkYXRlKSxcbiAgICAodXBkYXRlLmxhbmUgPSBsYW5lIHwgNTM2ODcwOTEyKSk7XG59XG5mdW5jdGlvbiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKSB7XG4gIGlmICg1MCA8IG5lc3RlZFVwZGF0ZUNvdW50KVxuICAgIHRocm93IChcbiAgICAgICgobmVzdGVkVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgIEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg1KSkpXG4gICAgKTtcbiAgZm9yICh2YXIgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAoc291cmNlRmliZXIgPSBwYXJlbnQpLCAocGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuKTtcbiAgcmV0dXJuIDMgPT09IHNvdXJjZUZpYmVyLnRhZyA/IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSA6IG51bGw7XG59XG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge30sXG4gIENhcHR1cmVkU3RhY2tzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2UpIHtcbiAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgIHZhciBleGlzdGluZyA9IENhcHR1cmVkU3RhY2tzLmdldCh2YWx1ZSk7XG4gICAgaWYgKHZvaWQgMCAhPT0gZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICBzb3VyY2UgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgIH07XG4gICAgQ2FwdHVyZWRTdGFja3Muc2V0KHZhbHVlLCBzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG52YXIgZm9ya1N0YWNrID0gW10sXG4gIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgdHJlZUZvcmtQcm92aWRlciA9IG51bGwsXG4gIHRyZWVGb3JrQ291bnQgPSAwLFxuICBpZFN0YWNrID0gW10sXG4gIGlkU3RhY2tJbmRleCA9IDAsXG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsLFxuICB0cmVlQ29udGV4dElkID0gMSxcbiAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IFwiXCI7XG5mdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgdHJlZUZvcmtQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgd29ya0luUHJvZ3Jlc3MgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICB2YXIgYmFzZUxlbmd0aCA9IDMyIC0gY2x6MzIoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJj0gfigxIDw8IGJhc2VMZW5ndGgpO1xuICBpbmRleCArPSAxO1xuICB2YXIgbGVuZ3RoID0gMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7XG4gIGlmICgzMCA8IGxlbmd0aCkge1xuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgIGxlbmd0aCA9IChcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICZcbiAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICkudG9TdHJpbmcoMzIpO1xuICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ID4+PSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgIHRyZWVDb250ZXh0SWQgPVxuICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0O1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBsZW5ndGggKyB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlXG4gICAgKHRyZWVDb250ZXh0SWQgPVxuICAgICAgKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0KSxcbiAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gd29ya0luUHJvZ3Jlc3MpO1xufVxuZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4gJiZcbiAgICAocHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCAxKSwgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgMSwgMCkpO1xufVxuZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyOyApXG4gICAgKHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF0pLFxuICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICh0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCk7XG4gIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcjsgKVxuICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAodHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKTtcbn1cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwsXG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsLFxuICBpc0h5ZHJhdGluZyA9ICExLFxuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsLFxuICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEsXG4gIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MTkpKTtcbmZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICB2YXIgZXJyb3IgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQxOCwgXCJcIikpO1xuICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBmaWJlcikpO1xuICB0aHJvdyBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLFxuICAgIHR5cGUgPSBmaWJlci50eXBlLFxuICAgIHByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaWJlcjtcbiAgaW5zdGFuY2VbaW50ZXJuYWxQcm9wc0tleV0gPSBwcm9wcztcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImNhbmNlbFwiLCBpbnN0YW5jZSk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2xvc2VcIiwgaW5zdGFuY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlmcmFtZVwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgIGNhc2UgXCJhdWRpb1wiOlxuICAgICAgZm9yICh0eXBlID0gMDsgdHlwZSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IHR5cGUrKylcbiAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbdHlwZV0sIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW1nXCI6XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgY2FzZSBcImxpbmtcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBpbnN0YW5jZSk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGV0YWlsc1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGluc3RhbmNlKTtcbiAgICAgIGluaXRJbnB1dChcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIHByb3BzLmNoZWNrZWQsXG4gICAgICAgIHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgICBwcm9wcy50eXBlLFxuICAgICAgICBwcm9wcy5uYW1lLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgICAgIHRyYWNrKGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgaW5zdGFuY2UpLFxuICAgICAgICBpbml0VGV4dGFyZWEoaW5zdGFuY2UsIHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgdHJhY2soaW5zdGFuY2UpO1xuICB9XG4gIHR5cGUgPSBwcm9wcy5jaGlsZHJlbjtcbiAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgXCJudW1iZXJcIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICBcImJpZ2ludFwiICE9PSB0eXBlb2YgdHlwZSkgfHxcbiAgaW5zdGFuY2UudGV4dENvbnRlbnQgPT09IFwiXCIgKyB0eXBlIHx8XG4gICEwID09PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgfHxcbiAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KGluc3RhbmNlLnRleHRDb250ZW50LCB0eXBlKVxuICAgID8gKG51bGwgIT0gcHJvcHMucG9wb3ZlciAmJlxuICAgICAgICAobGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImJlZm9yZXRvZ2dsZVwiLCBpbnN0YW5jZSksXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJ0b2dnbGVcIiwgaW5zdGFuY2UpKSxcbiAgICAgIG51bGwgIT0gcHJvcHMub25TY3JvbGwgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBpbnN0YW5jZSksXG4gICAgICBudWxsICE9IHByb3BzLm9uU2Nyb2xsRW5kICYmXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxlbmRcIiwgaW5zdGFuY2UpLFxuICAgICAgbnVsbCAhPSBwcm9wcy5vbkNsaWNrICYmIChpbnN0YW5jZS5vbmNsaWNrID0gbm9vcCQxKSxcbiAgICAgIChpbnN0YW5jZSA9ICEwKSlcbiAgICA6IChpbnN0YW5jZSA9ICExKTtcbiAgaW5zdGFuY2UgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgZm9yIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjsgaHlkcmF0aW9uUGFyZW50RmliZXI7IClcbiAgICBzd2l0Y2ggKGh5ZHJhdGlvblBhcmVudEZpYmVyLnRhZykge1xuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSAyNzpcbiAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHJldHVybiAhMTtcbiAgaWYgKCFpc0h5ZHJhdGluZykgcmV0dXJuIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpLCAoaXNIeWRyYXRpbmcgPSAhMCksICExO1xuICB2YXIgc2hvdWxkQ2xlYXIgPSAhMSxcbiAgICBKU0NvbXBpbGVyX3RlbXA7XG4gIGlmICgoSlNDb21waWxlcl90ZW1wID0gMyAhPT0gZmliZXIudGFnICYmIDI3ICE9PSBmaWJlci50YWcpKSB7XG4gICAgaWYgKChKU0NvbXBpbGVyX3RlbXAgPSA1ID09PSBmaWJlci50YWcpKVxuICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IGZpYmVyLnR5cGUpLFxuICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAhKFwiZm9ybVwiICE9PSBKU0NvbXBpbGVyX3RlbXAgJiYgXCJidXR0b25cIiAhPT0gSlNDb21waWxlcl90ZW1wKSB8fFxuICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICBKU0NvbXBpbGVyX3RlbXAgPSAhSlNDb21waWxlcl90ZW1wO1xuICB9XG4gIEpTQ29tcGlsZXJfdGVtcCAmJiAoc2hvdWxkQ2xlYXIgPSAhMCk7XG4gIHNob3VsZENsZWFyICYmIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgJiYgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgIGZpYmVyID0gbnVsbCAhPT0gZmliZXIgPyBmaWJlci5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICBpZiAoIWZpYmVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxNykpO1xuICAgIGE6IHtcbiAgICAgIGZpYmVyID0gZmliZXIubmV4dFNpYmxpbmc7XG4gICAgICBmb3IgKHNob3VsZENsZWFyID0gMDsgZmliZXI7ICkge1xuICAgICAgICBpZiAoOCA9PT0gZmliZXIubm9kZVR5cGUpXG4gICAgICAgICAgaWYgKCgoSlNDb21waWxlcl90ZW1wID0gZmliZXIuZGF0YSksIFwiLyRcIiA9PT0gSlNDb21waWxlcl90ZW1wKSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHNob3VsZENsZWFyKSB7XG4gICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShmaWJlci5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRDbGVhci0tO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKFwiJFwiICE9PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgXCIkIVwiICE9PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgXCIkP1wiICE9PSBKU0NvbXBpbGVyX3RlbXApIHx8XG4gICAgICAgICAgICAgIHNob3VsZENsZWFyKys7XG4gICAgICAgIGZpYmVyID0gZmliZXIubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZVxuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlclxuICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZShmaWJlci5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpXG4gICAgICA6IG51bGw7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIGlzSHlkcmF0aW5nID0gITE7XG59XG5mdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gIG51bGwgPT09IGh5ZHJhdGlvbkVycm9yc1xuICAgID8gKGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl0pXG4gICAgOiBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG59XG52YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ2MCkpLFxuICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24gPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ3NCkpLFxuICBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7IHRoZW46IGZ1bmN0aW9uICgpIHt9IH07XG5mdW5jdGlvbiBpc1RoZW5hYmxlUmVzb2x2ZWQodGhlbmFibGUpIHtcbiAgdGhlbmFibGUgPSB0aGVuYWJsZS5zdGF0dXM7XG4gIHJldHVybiBcImZ1bGZpbGxlZFwiID09PSB0aGVuYWJsZSB8fCBcInJlamVjdGVkXCIgPT09IHRoZW5hYmxlO1xufVxuZnVuY3Rpb24gbm9vcCQzKCkge31cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICBpbmRleCA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuICB2b2lkIDAgPT09IGluZGV4XG4gICAgPyB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpXG4gICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiYgKHRoZW5hYmxlLnRoZW4obm9vcCQzLCBub29wJDMpLCAodGhlbmFibGUgPSBpbmRleCkpO1xuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICBpZiAodGhlbmFibGVTdGF0ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24pXG4gICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDgzKSk7XG4gICAgICB0aHJvdyB0aGVuYWJsZVN0YXRlO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1cykgdGhlbmFibGUudGhlbihub29wJDMsIG5vb3AkMyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgaWYgKG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiYgMTAwIDwgdGhlbmFibGVTdGF0ZS5zaGVsbFN1c3BlbmRDb3VudGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDgyKSk7XG4gICAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZTtcbiAgICAgICAgdGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0ODMpKTtcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZVN0YXRlO1xuICAgICAgfVxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICB9XG59XG52YXIgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gIGlmIChudWxsID09PSBzdXNwZW5kZWRUaGVuYWJsZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTkpKTtcbiAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxudmFyIHRoZW5hYmxlU3RhdGUkMSA9IG51bGwsXG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuICBudWxsID09PSB0aGVuYWJsZVN0YXRlJDEgJiYgKHRoZW5hYmxlU3RhdGUkMSA9IFtdKTtcbiAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUkMSwgdGhlbmFibGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGNvZXJjZVJlZih3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCkge1xuICBlbGVtZW50ID0gZWxlbWVudC5wcm9wcy5yZWY7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IHZvaWQgMCAhPT0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjUpKTtcbiAgcmV0dXJuRmliZXIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICB0aHJvdyBFcnJvcihcbiAgICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKFxuICAgICAgMzEsXG4gICAgICBcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXR1cm5GaWJlclxuICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgOiByZXR1cm5GaWJlclxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXp5KGxhenlUeXBlKSB7XG4gIHZhciBpbml0ID0gbGF6eVR5cGUuX2luaXQ7XG4gIHJldHVybiBpbml0KGxhenlUeXBlLl9wYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICBudWxsID09PSBkZWxldGlvbnNcbiAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgIDogZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykgcmV0dXJuIG51bGw7XG4gICAgZm9yICg7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGZvciAodmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZC5rZXlcbiAgICAgICAgPyBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5rZXksIGN1cnJlbnRGaXJzdENoaWxkKVxuICAgICAgICA6IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmluZGV4LCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICBmaWJlciA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGZpYmVyLmluZGV4ID0gMDtcbiAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKVxuICAgICAgcmV0dXJuIChuZXdGaWJlci5mbGFncyB8PSAxMDQ4NTc2KSwgbGFzdFBsYWNlZEluZGV4O1xuICAgIG5ld0luZGV4ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChudWxsICE9PSBuZXdJbmRleClcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChuZXdJbmRleCA9IG5ld0luZGV4LmluZGV4KSxcbiAgICAgICAgbmV3SW5kZXggPCBsYXN0UGxhY2VkSW5kZXhcbiAgICAgICAgICA/ICgobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpLCBsYXN0UGxhY2VkSW5kZXgpXG4gICAgICAgICAgOiBuZXdJbmRleFxuICAgICAgKTtcbiAgICBuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNDtcbiAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICB9XG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgIChuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNCk7XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA2ICE9PSBjdXJyZW50LnRhZylcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpKSxcbiAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICBjdXJyZW50XG4gICAgICApO1xuICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpXG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICBsYW5lcyxcbiAgICAgICAgZWxlbWVudC5rZXlcbiAgICAgICk7XG4gICAgaWYgKFxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkpXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKSksXG4gICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSxcbiAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICBjdXJyZW50XG4gICAgICApO1xuICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICBlbGVtZW50LnR5cGUsXG4gICAgICBlbGVtZW50LmtleSxcbiAgICAgIGVsZW1lbnQucHJvcHMsXG4gICAgICBudWxsLFxuICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgIGxhbmVzXG4gICAgKTtcbiAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICBpZiAoXG4gICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICA0ICE9PSBjdXJyZW50LnRhZyB8fFxuICAgICAgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICApXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgY3VycmVudFxuICAgICAgKTtcbiAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDcgIT09IGN1cnJlbnQudGFnKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgIGtleVxuICAgICAgICApKSxcbiAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICBjdXJyZW50XG4gICAgICApO1xuICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKFxuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICBcIlwiICsgbmV3Q2hpbGQsXG4gICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApKSxcbiAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgbmV3Q2hpbGRcbiAgICAgICk7XG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlLFxuICAgICAgICAgICAgICBuZXdDaGlsZC5rZXksXG4gICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgbmV3Q2hpbGQgPSBpbml0KG5ld0NoaWxkLl9wYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICApO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLCBsYW5lcyk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gbnVsbCAhPT0gb2xkRmliZXIgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuICAgIGlmIChcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgIClcbiAgICAgIHJldHVybiBudWxsICE9PSBrZXlcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBuZXdDaGlsZC5rZXkgPT09IGtleVxuICAgICAgICAgICAgPyB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBuZXdDaGlsZC5rZXkgPT09IGtleVxuICAgICAgICAgICAgPyB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoa2V5ID0gbmV3Q2hpbGQuX2luaXQpLFxuICAgICAgICAgICAgKG5ld0NoaWxkID0ga2V5KG5ld0NoaWxkLl9wYXlsb2FkKSksXG4gICAgICAgICAgICB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgIHJldHVybkZpYmVyLFxuICAgIG5ld0lkeCxcbiAgICBuZXdDaGlsZCxcbiAgICBsYW5lc1xuICApIHtcbiAgICBpZiAoXG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICApXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgKTtcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgIG5ld0NoaWxkID0gaW5pdChuZXdDaGlsZC5fcGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICBuZXdDaGlsZHJlbixcbiAgICBsYW5lc1xuICApIHtcbiAgICBmb3IgKFxuICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbnVsbCxcbiAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgICBudWxsICE9PSBvbGRGaWJlciAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICBuZXdJZHgrK1xuICAgICkge1xuICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgIDogKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmcpO1xuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICBsYW5lc1xuICAgICAgKTtcbiAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpXG4gICAgICByZXR1cm4gKFxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICk7XG4gICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKylcbiAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiZcbiAgICAgICAgICAgICgoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gb2xkRmliZXIpLFxuICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBvbGRGaWJlciA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTtcbiAgICAgIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgIG5ld0lkeCsrXG4gICAgKVxuICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgbmV3SWR4LFxuICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICBsYW5lc1xuICAgICAgKSksXG4gICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gbmV4dE9sZEZpYmVyKSk7XG4gICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICBuZXdDaGlsZHJlbixcbiAgICBsYW5lc1xuICApIHtcbiAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNTEpKTtcbiAgICBmb3IgKFxuICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbnVsbCxcbiAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgIG5leHRPbGRGaWJlciA9IG51bGwsXG4gICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICBudWxsICE9PSBvbGRGaWJlciAmJiAhc3RlcC5kb25lO1xuICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICApIHtcbiAgICAgIG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4XG4gICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcyk7XG4gICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG4gICAgaWYgKHN0ZXAuZG9uZSlcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KSxcbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgKTtcbiAgICBpZiAobnVsbCA9PT0gb2xkRmliZXIpIHtcbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSlcbiAgICAgICAgKHN0ZXAgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpKSxcbiAgICAgICAgICBudWxsICE9PSBzdGVwICYmXG4gICAgICAgICAgICAoKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChzdGVwLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KSksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBzdGVwKVxuICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBzdGVwKSxcbiAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gc3RlcCkpO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBvbGRGaWJlciA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTtcbiAgICAgICFzdGVwLmRvbmU7XG4gICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgIClcbiAgICAgIChzdGVwID0gdXBkYXRlRnJvbU1hcChvbGRGaWJlciwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpKSxcbiAgICAgICAgbnVsbCAhPT0gc3RlcCAmJlxuICAgICAgICAgIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsICE9PSBzdGVwLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKG51bGwgPT09IHN0ZXAua2V5ID8gbmV3SWR4IDogc3RlcC5rZXkpLFxuICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoc3RlcCwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCkpLFxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBzdGVwKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gc3RlcCksXG4gICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBzdGVwKSk7XG4gICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgIHJldHVybkZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgIG5ld0NoaWxkLFxuICAgIGxhbmVzXG4gICkge1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgbnVsbCAhPT0gbmV3Q2hpbGQgJiZcbiAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSAmJlxuICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5ID0gbmV3Q2hpbGQua2V5OyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG5ld0NoaWxkLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGtleSAmJlxuICAgICAgICAgICAgICAgICAgICBrZXkuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlTGF6eShrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnR5cGUsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZC5rZXksXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBmb3IgKGtleSA9IG5ld0NoaWxkLmtleTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7ICkge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBrZXkpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgNCA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnICYmXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQuY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PVxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5pbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoa2V5ID0gbmV3Q2hpbGQuX2luaXQpLFxuICAgICAgICAgICAgKG5ld0NoaWxkID0ga2V5KG5ld0NoaWxkLl9wYXlsb2FkKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBrZXkpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUwKSk7XG4gICAgICAgIG5ld0NoaWxkID0ga2V5LmNhbGwobmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICA/ICgobmV3Q2hpbGQgPSBcIlwiICsgbmV3Q2hpbGQpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZCAmJiA2ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWdcbiAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyksXG4gICAgICAgICAgICAobGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQpKSxcbiAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVRleHQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKSxcbiAgICAgICAgcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcikpXG4gICAgICA6IGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIHRyeSB7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgIHZhciBmaXJzdENoaWxkRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApO1xuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgIHJldHVybiBmaXJzdENoaWxkRmliZXI7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgaWYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB0aHJvdyB4O1xuICAgICAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMjksIHgsIG51bGwsIHJldHVybkZpYmVyLm1vZGUpO1xuICAgICAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH0gZmluYWxseSB7XG4gICAgfVxuICB9O1xufVxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCEwKSxcbiAgbW91bnRDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMSksXG4gIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcigwKTtcbmZ1bmN0aW9uIHB1c2hIaWRkZW5Db250ZXh0KGZpYmVyLCBjb250ZXh0KSB7XG4gIGZpYmVyID0gZW50YW5nbGVkUmVuZGVyTGFuZXM7XG4gIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBmaWJlcik7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCk7XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gZmliZXIgfCBjb250ZXh0LmJhc2VMYW5lcztcbn1cbmZ1bmN0aW9uIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2soKSB7XG4gIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KTtcbn1cbmZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoKSB7XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yKTtcbiAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvcik7XG59XG52YXIgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIHNoZWxsQm91bmRhcnkgPSBudWxsO1xuZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiAxKTtcbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlcik7XG4gIG51bGwgPT09IHNoZWxsQm91bmRhcnkgJiZcbiAgICAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgID8gKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKVxuICAgICAgOiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiYgKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKSk7XG59XG5mdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIGlmICgyMiA9PT0gZmliZXIudGFnKSB7XG4gICAgaWYgKFxuICAgICAgKHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyKSxcbiAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkpXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIChzaGVsbEJvdW5kYXJ5ID0gZmliZXIpO1xuICAgIH1cbiAgfSBlbHNlIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG59XG5mdW5jdGlvbiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soKSB7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCk7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yKTtcbiAgc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIgJiYgKHNoZWxsQm91bmRhcnkgPSBudWxsKTtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IpO1xufVxudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCk7XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIGZvciAodmFyIG5vZGUgPSByb3c7IG51bGwgIT09IG5vZGU7ICkge1xuICAgIGlmICgxMyA9PT0gbm9kZS50YWcpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gc3RhdGUgJiZcbiAgICAgICAgKChzdGF0ZSA9IHN0YXRlLmRlaHlkcmF0ZWQpLFxuICAgICAgICBudWxsID09PSBzdGF0ZSB8fCBcIiQ/XCIgPT09IHN0YXRlLmRhdGEgfHwgXCIkIVwiID09PSBzdGF0ZS5kYXRhKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKDE5ID09PSBub2RlLnRhZyAmJiB2b2lkIDAgIT09IG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlcikge1xuICAgICAgaWYgKDAgIT09IChub2RlLmZsYWdzICYgMTI4KSkgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gcm93KSBicmVhaztcbiAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gcm93KSByZXR1cm4gbnVsbDtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgQWJvcnRDb250cm9sbGVyTG9jYWwgPVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBBYm9ydENvbnRyb2xsZXJcbiAgICAgID8gQWJvcnRDb250cm9sbGVyXG4gICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICBzaWduYWwgPSAodGhpcy5zaWduYWwgPSB7XG4gICAgICAgICAgICAgIGFib3J0ZWQ6ICExLFxuICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaWduYWwuYWJvcnRlZCA9ICEwO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgc2NoZWR1bGVDYWxsYmFjayQyID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gIE5vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICBDYWNoZUNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBfY3VycmVudFZhbHVlOiBudWxsLFxuICAgIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICAgIF90aHJlYWRDb3VudDogMFxuICB9O1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlckxvY2FsKCksXG4gICAgZGF0YTogbmV3IE1hcCgpLFxuICAgIHJlZkNvdW50OiAwXG4gIH07XG59XG5mdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgY2FjaGUucmVmQ291bnQtLTtcbiAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICBzY2hlZHVsZUNhbGxiYWNrJDIoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbn1cbnZhciBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbCxcbiAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMCxcbiAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgdGhlbmFibGUpIHtcbiAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICB2YXIgZW50YW5nbGVkTGlzdGVuZXJzID0gKGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBbXSk7XG4gICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSB7XG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGVudGFuZ2xlZExpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICB0aGVuYWJsZS50aGVuKHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUsIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUpO1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5mdW5jdGlvbiBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKCkge1xuICBpZiAoXG4gICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVyc1xuICApIHtcbiAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgIChjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIik7XG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnM7XG4gICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSAwO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICB0aGVuYWJsZVdpdGhPdmVycmlkZSA9IHtcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH07XG4gIHRoZW5hYmxlLnRoZW4oXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnZhbHVlID0gcmVzdWx0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKHJlc3VsdCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgZm9yIChlcnJvciA9IDA7IGVycm9yIDwgbGlzdGVuZXJzLmxlbmd0aDsgZXJyb3IrKylcbiAgICAgICAgKDAsIGxpc3RlbmVyc1tlcnJvcl0pKHZvaWQgMCk7XG4gICAgfVxuICApO1xuICByZXR1cm4gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG59XG52YXIgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcblJlYWN0U2hhcmVkSW50ZXJuYWxzLlMgPSBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpIHtcbiAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gIG51bGwgIT09IHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG59O1xudmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbmZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG4gIHJldHVybiBudWxsICE9PSBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXJcbiAgICA/IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgIDogd29ya0luUHJvZ3Jlc3NSb290LnBvb2xlZENhY2hlO1xufVxuZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpIHtcbiAgbnVsbCA9PT0gcHJldkNhY2hlUG9vbFxuICAgID8gcHVzaChyZXN1bWVkQ2FjaGUsIHJlc3VtZWRDYWNoZS5jdXJyZW50KVxuICAgIDogcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCk7XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgdmFyIGNhY2hlRnJvbVBvb2wgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuICByZXR1cm4gbnVsbCA9PT0gY2FjaGVGcm9tUG9vbFxuICAgID8gbnVsbFxuICAgIDogeyBwYXJlbnQ6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlLCBwb29sOiBjYWNoZUZyb21Qb29sIH07XG59XG52YXIgcmVuZGVyTGFuZXMgPSAwLFxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgY3VycmVudEhvb2sgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExLFxuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExLFxuICBsb2NhbElkQ291bnRlciA9IDAsXG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIxKSk7XG59XG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChudWxsID09PSBwcmV2RGVwcykgcmV0dXJuICExO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspXG4gICAgaWYgKCFvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgcHJvcHMsXG4gIHNlY29uZEFyZyxcbiAgbmV4dFJlbmRlckxhbmVzXG4pIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICBudWxsID09PSBjdXJyZW50IHx8IG51bGwgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPbk1vdW50XG4gICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlO1xuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICBuZXh0UmVuZGVyTGFuZXMgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITE7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJlxuICAgIChuZXh0UmVuZGVyTGFuZXMgPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmdcbiAgICApKTtcbiAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCk7XG4gIHJldHVybiBuZXh0UmVuZGVyTGFuZXM7XG59XG5mdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50KSB7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IG51bGwgIT09IGN1cnJlbnRIb29rICYmIG51bGwgIT09IGN1cnJlbnRIb29rLm5leHQ7XG4gIHJlbmRlckxhbmVzID0gMDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzAwKSk7XG4gIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICBkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgKChjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSAmJlxuICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xufVxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIGRvIHtcbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiYgKHRoZW5hYmxlU3RhdGUgPSBudWxsKTtcbiAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwMSkpO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBudWxsO1xuICAgIGlmIChudWxsICE9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGNoaWxkcmVuLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgY2hpbGRyZW4uZXZlbnRzID0gbnVsbDtcbiAgICAgIGNoaWxkcmVuLnN0b3JlcyA9IG51bGw7XG4gICAgICBudWxsICE9IGNoaWxkcmVuLm1lbW9DYWNoZSAmJiAoY2hpbGRyZW4ubWVtb0NhY2hlLmluZGV4ID0gMCk7XG4gICAgfVxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgsXG4gICAgbWF5YmVUaGVuYWJsZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKVswXTtcbiAgbWF5YmVUaGVuYWJsZSA9XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVUaGVuYWJsZS50aGVuXG4gICAgICA/IHVzZVRoZW5hYmxlKG1heWJlVGhlbmFibGUpXG4gICAgICA6IG1heWJlVGhlbmFibGU7XG4gIGRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gIChudWxsICE9PSBjdXJyZW50SG9vayA/IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsKSAhPT0gZGlzcGF0Y2hlciAmJlxuICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDEwMjQpO1xuICByZXR1cm4gbWF5YmVUaGVuYWJsZTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICB2YXIgZGlkUmVuZGVySWRIb29rID0gMCAhPT0gbG9jYWxJZENvdW50ZXI7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjA1MztcbiAgY3VycmVudC5sYW5lcyAmPSB+bGFuZXM7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzT25VbndpbmQod29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICBmb3IgKFxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICApIHtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnF1ZXVlO1xuICAgICAgbnVsbCAhPT0gcXVldWUgJiYgKHF1ZXVlLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubmV4dDtcbiAgICB9XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICB9XG4gIHJlbmRlckxhbmVzID0gMDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rKVxuICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vayk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmIChudWxsID09PSBjdXJyZW50SG9vaykge1xuICAgIHZhciBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICBuZXh0Q3VycmVudEhvb2sgPVxuICAgICAgbnVsbCAhPT0gbmV4dEN1cnJlbnRIb29rID8gbmV4dEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICB9IGVsc2UgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgPyBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGVcbiAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIGlmIChudWxsICE9PSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKVxuICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKSxcbiAgICAgIChjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vayk7XG4gIGVsc2Uge1xuICAgIGlmIChudWxsID09PSBuZXh0Q3VycmVudEhvb2spIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NjcpKTtcbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEwKSk7XG4gICAgfVxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIG5leHRDdXJyZW50SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICAgIG5leHRDdXJyZW50SG9vaylcbiAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxudmFyIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWU7XG5jcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4geyBsYXN0RWZmZWN0OiBudWxsLCBldmVudHM6IG51bGwsIHN0b3JlczogbnVsbCwgbWVtb0NhY2hlOiBudWxsIH07XG59O1xuZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBbXSk7XG4gIHRoZW5hYmxlID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbiAgaW5kZXggPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICBudWxsID09PVxuICAgIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgID8gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCkgJiZcbiAgICAoKGluZGV4ID0gaW5kZXguYWx0ZXJuYXRlKSxcbiAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICBudWxsID09PSBpbmRleCB8fCBudWxsID09PSBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFxuICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlKSk7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cbmZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKSByZXR1cm4gdXNlVGhlbmFibGUodXNhYmxlKTtcbiAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICB9XG4gIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDM4LCBTdHJpbmcodXNhYmxlKSkpO1xufVxuZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgdmFyIG1lbW9DYWNoZSA9IG51bGwsXG4gICAgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICBudWxsICE9PSB1cGRhdGVRdWV1ZSAmJiAobWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlKTtcbiAgaWYgKG51bGwgPT0gbWVtb0NhY2hlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vQ2FjaGUpLFxuICAgICAgICBudWxsICE9IGN1cnJlbnQgJiZcbiAgICAgICAgICAobWVtb0NhY2hlID0ge1xuICAgICAgICAgICAgZGF0YTogY3VycmVudC5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgfSkpKTtcbiAgfVxuICBudWxsID09IG1lbW9DYWNoZSAmJiAobWVtb0NhY2hlID0geyBkYXRhOiBbXSwgaW5kZXg6IDAgfSk7XG4gIG51bGwgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgKCh1cGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZSkpO1xuICB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUgPSBtZW1vQ2FjaGU7XG4gIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XTtcbiAgaWYgKHZvaWQgMCA9PT0gdXBkYXRlUXVldWUpXG4gICAgZm9yIChcbiAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XSA9IEFycmF5KHNpemUpLCBjdXJyZW50ID0gMDtcbiAgICAgIGN1cnJlbnQgPCBzaXplO1xuICAgICAgY3VycmVudCsrXG4gICAgKVxuICAgICAgdXBkYXRlUXVldWVbY3VycmVudF0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICBtZW1vQ2FjaGUuaW5kZXgrKztcbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlO1xufVxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xufVxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudCwgcmVkdWNlcikge1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICBpZiAobnVsbCA9PT0gcXVldWUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzExKSk7XG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgYmFzZVF1ZXVlID0gaG9vay5iYXNlUXVldWUsXG4gICAgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcbiAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgIGlmIChudWxsICE9PSBiYXNlUXVldWUpIHtcbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICB9XG4gICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gIH1cbiAgcGVuZGluZ1F1ZXVlID0gaG9vay5iYXNlU3RhdGU7XG4gIGlmIChudWxsID09PSBiYXNlUXVldWUpIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgZWxzZSB7XG4gICAgY3VycmVudCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IChiYXNlRmlyc3QgPSBudWxsKSxcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsLFxuICAgICAgdXBkYXRlID0gY3VycmVudCxcbiAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24kNTQgPSAhMTtcbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lICYgLTUzNjg3MDkxMztcbiAgICAgIGlmIChcbiAgICAgICAgdXBkYXRlTGFuZSAhPT0gdXBkYXRlLmxhbmVcbiAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG4gICAgICAgIGlmICgwID09PSByZXZlcnRMYW5lKVxuICAgICAgICAgIG51bGwgIT09IG5ld0Jhc2VRdWV1ZUxhc3QgJiZcbiAgICAgICAgICAgIChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID1cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uJDU0ID0gITApO1xuICAgICAgICBlbHNlIGlmICgocmVuZGVyTGFuZXMgJiByZXZlcnRMYW5lKSA9PT0gcmV2ZXJ0TGFuZSkge1xuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICAgIHJldmVydExhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiQ1NCA9ICEwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgKHVwZGF0ZUxhbmUgPSB7XG4gICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSByZXZlcnRMYW5lKTtcbiAgICAgICAgdXBkYXRlTGFuZSA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWICYmXG4gICAgICAgICAgcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICBwZW5kaW5nUXVldWUgPSB1cGRhdGUuaGFzRWFnZXJTdGF0ZVxuICAgICAgICAgID8gdXBkYXRlLmVhZ2VyU3RhdGVcbiAgICAgICAgICA6IHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAocmV2ZXJ0TGFuZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB1cGRhdGVMYW5lKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKG51bGwgIT09IHVwZGF0ZSAmJiB1cGRhdGUgIT09IGN1cnJlbnQpO1xuICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgID8gKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSlcbiAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0KTtcbiAgICBpZiAoXG4gICAgICAhb2JqZWN0SXMocGVuZGluZ1F1ZXVlLCBob29rLm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uJDU0ICYmXG4gICAgICAgICgocmVkdWNlciA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSksIG51bGwgIT09IHJlZHVjZXIpKVxuICAgIClcbiAgICAgIHRocm93IHJlZHVjZXI7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gYmFzZUZpcnN0O1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgfVxuICBudWxsID09PSBiYXNlUXVldWUgJiYgKHF1ZXVlLmxhbmVzID0gMCk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBxdWV1ZS5kaXNwYXRjaF07XG59XG5mdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgaWYgKG51bGwgPT09IHF1ZXVlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxMSkpO1xuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2gsXG4gICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZyxcbiAgICBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSAobGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQpO1xuICAgIGRvIChuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIHVwZGF0ZS5hY3Rpb24pKSwgKHVwZGF0ZSA9IHVwZGF0ZS5uZXh0KTtcbiAgICB3aGlsZSAodXBkYXRlICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgIG9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIG51bGwgPT09IGhvb2suYmFzZVF1ZXVlICYmIChob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlKTtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG4gIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwID0gaXNIeWRyYXRpbmc7XG4gIGlmIChpc0h5ZHJhdGluZyRqc2NvbXAkMCkge1xuICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQwNykpO1xuICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgfSBlbHNlIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgdmFyIHNuYXBzaG90Q2hhbmdlZCA9ICFvYmplY3RJcyhcbiAgICAoY3VycmVudEhvb2sgfHwgaG9vaykubWVtb2l6ZWRTdGF0ZSxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICBzbmFwc2hvdENoYW5nZWQgJiZcbiAgICAoKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGdldFNlcnZlclNuYXBzaG90KSwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xuICBob29rID0gaG9vay5xdWV1ZTtcbiAgdXBkYXRlRWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaG9vaywgc3Vic2NyaWJlKSwgW1xuICAgIHN1YnNjcmliZVxuICBdKTtcbiAgaWYgKFxuICAgIGhvb2suZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8XG4gICAgc25hcHNob3RDaGFuZ2VkIHx8XG4gICAgKG51bGwgIT09IHdvcmtJblByb2dyZXNzSG9vayAmJiB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiAxKVxuICApIHtcbiAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgIHB1c2hFZmZlY3QoXG4gICAgICA5LFxuICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBmaWJlcixcbiAgICAgICAgaG9vayxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgIGdldFNuYXBzaG90XG4gICAgICApLFxuICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQ5KSk7XG4gICAgaXNIeWRyYXRpbmckanNjb21wJDAgfHxcbiAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG59XG5mdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuICBmaWJlci5mbGFncyB8PSAxNjM4NDtcbiAgZmliZXIgPSB7IGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCwgdmFsdWU6IHJlbmRlcmVkU25hcHNob3QgfTtcbiAgZ2V0U25hcHNob3QgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICBudWxsID09PSBnZXRTbmFwc2hvdFxuICAgID8gKChnZXRTbmFwc2hvdCA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGdldFNuYXBzaG90KSxcbiAgICAgIChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKSlcbiAgICA6ICgocmVuZGVyZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90LnN0b3JlcyksXG4gICAgICBudWxsID09PSByZW5kZXJlZFNuYXBzaG90XG4gICAgICAgID8gKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pXG4gICAgICAgIDogcmVuZGVyZWRTbmFwc2hvdC5wdXNoKGZpYmVyKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcbiAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgaW5zdCA9IGluc3QudmFsdWU7XG4gIHRyeSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxuZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xufVxuZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluaXRpYWxTdGF0ZSkge1xuICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGhvb2sucXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogMCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIHJldHVybiBob29rO1xufVxuZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudCwgcGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgIGhvb2ssXG4gICAgY3VycmVudEhvb2ssXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVkdWNlciA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlclxuICApO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShcbiAgZmliZXIsXG4gIGFjdGlvblF1ZXVlLFxuICBzZXRQZW5kaW5nU3RhdGUsXG4gIHNldFN0YXRlLFxuICBwYXlsb2FkXG4pIHtcbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ4NSkpO1xuICBmaWJlciA9IGFjdGlvblF1ZXVlLmFjdGlvbjtcbiAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgdmFyIGFjdGlvbk5vZGUgPSB7XG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgYWN0aW9uOiBmaWJlcixcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBpc1RyYW5zaXRpb246ICEwLFxuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBhY3Rpb25Ob2RlLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlRcbiAgICAgID8gc2V0UGVuZGluZ1N0YXRlKCEwKVxuICAgICAgOiAoYWN0aW9uTm9kZS5pc1RyYW5zaXRpb24gPSAhMSk7XG4gICAgc2V0U3RhdGUoYWN0aW9uTm9kZSk7XG4gICAgc2V0UGVuZGluZ1N0YXRlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICBudWxsID09PSBzZXRQZW5kaW5nU3RhdGVcbiAgICAgID8gKChhY3Rpb25Ob2RlLm5leHQgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uTm9kZSksXG4gICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKSlcbiAgICAgIDogKChhY3Rpb25Ob2RlLm5leHQgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCksXG4gICAgICAgIChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gc2V0UGVuZGluZ1N0YXRlLm5leHQgPSBhY3Rpb25Ob2RlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBub2RlKSB7XG4gIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbixcbiAgICBwYXlsb2FkID0gbm9kZS5wYXlsb2FkLFxuICAgIHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlO1xuICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpLFxuICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9IGVsc2VcbiAgICB0cnkge1xuICAgICAgKHByZXZUcmFuc2l0aW9uID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCkpLFxuICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcHJldlRyYW5zaXRpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yJDYwKSB7XG4gICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvciQ2MCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKSB7XG4gIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgPyByZXR1cm5WYWx1ZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgOiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbn1cbmZ1bmN0aW9uIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgbmV4dFN0YXRlKSB7XG4gIGFjdGlvbk5vZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpO1xuICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgYWN0aW9uTm9kZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gIG51bGwgIT09IGFjdGlvbk5vZGUgJiZcbiAgICAoKG5leHRTdGF0ZSA9IGFjdGlvbk5vZGUubmV4dCksXG4gICAgbmV4dFN0YXRlID09PSBhY3Rpb25Ob2RlXG4gICAgICA/IChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbClcbiAgICAgIDogKChuZXh0U3RhdGUgPSBuZXh0U3RhdGUubmV4dCksXG4gICAgICAgIChhY3Rpb25Ob2RlLm5leHQgPSBuZXh0U3RhdGUpLFxuICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbmV4dFN0YXRlKSkpO1xufVxuZnVuY3Rpb24gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgZXJyb3IpIHtcbiAgdmFyIGxhc3QgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgaWYgKG51bGwgIT09IGxhc3QpIHtcbiAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIGRvXG4gICAgICAoYWN0aW9uTm9kZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAoYWN0aW9uTm9kZS5yZWFzb24gPSBlcnJvciksXG4gICAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSxcbiAgICAgICAgKGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLm5leHQpO1xuICAgIHdoaWxlIChhY3Rpb25Ob2RlICE9PSBsYXN0KTtcbiAgfVxuICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBudWxsO1xufVxuZnVuY3Rpb24gbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpIHtcbiAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubGlzdGVuZXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvbk5vZGUubGVuZ3RoOyBpKyspICgwLCBhY3Rpb25Ob2RlW2ldKSgpO1xufVxuZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5mdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCkge1xuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICB2YXIgc3NyRm9ybVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290LmZvcm1TdGF0ZTtcbiAgICBpZiAobnVsbCAhPT0gc3NyRm9ybVN0YXRlKSB7XG4gICAgICBhOiB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBpZiAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaW5Sb290T3JTaW5nbGV0b24gPSByb290T3JTaW5nbGV0b25Db250ZXh0O1xuICAgICAgICAgICAgICAgIDggIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMC5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluUm9vdE9yU2luZ2xldG9uKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpblJvb3RPclNpbmdsZXRvbiA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMC5kYXRhO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIFwiRiFcIiA9PT0gaW5Sb290T3JTaW5nbGV0b24gfHwgXCJGXCIgPT09IGluUm9vdE9yU2luZ2xldG9uXG4gICAgICAgICAgICAgICAgICA/IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgXCJGIVwiID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiYgKGluaXRpYWxTdGF0ZVByb3AgPSBzc3JGb3JtU3RhdGVbMF0pO1xuICAgIH1cbiAgfVxuICBzc3JGb3JtU3RhdGUgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBzc3JGb3JtU3RhdGUubWVtb2l6ZWRTdGF0ZSA9IHNzckZvcm1TdGF0ZS5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGVQcm9wO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogMCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBhY3Rpb25TdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgfTtcbiAgc3NyRm9ybVN0YXRlLnF1ZXVlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgbnVsbCxcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICApO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZGlzcGF0Y2ggPSBzc3JGb3JtU3RhdGU7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgaW5Sb290T3JTaW5nbGV0b24gPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgIG51bGwsXG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAhMSxcbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQucXVldWVcbiAgKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0ge1xuICAgIHN0YXRlOiBpbml0aWFsU3RhdGVQcm9wLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIHBlbmRpbmc6IG51bGxcbiAgfTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnF1ZXVlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaEFjdGlvblN0YXRlLmJpbmQoXG4gICAgbnVsbCxcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCxcbiAgICBpblJvb3RPclNpbmdsZXRvbixcbiAgICBzc3JGb3JtU3RhdGVcbiAgKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgcmV0dXJuIFtpbml0aWFsU3RhdGVQcm9wLCBzc3JGb3JtU3RhdGUsICExXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50SG9vaywgYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbikge1xuICBjdXJyZW50U3RhdGVIb29rID0gdXBkYXRlUmVkdWNlckltcGwoXG4gICAgc3RhdGVIb29rLFxuICAgIGN1cnJlbnRTdGF0ZUhvb2ssXG4gICAgYWN0aW9uU3RhdGVSZWR1Y2VyXG4gIClbMF07XG4gIHN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdO1xuICBjdXJyZW50U3RhdGVIb29rID1cbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgIG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50U3RhdGVIb29rLnRoZW5cbiAgICAgID8gdXNlVGhlbmFibGUoY3VycmVudFN0YXRlSG9vaylcbiAgICAgIDogY3VycmVudFN0YXRlSG9vaztcbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlLFxuICAgIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7XG4gIGFjdGlvbiAhPT0gYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGUgJiZcbiAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMjA0OCksXG4gICAgcHVzaEVmZmVjdChcbiAgICAgIDksXG4gICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgIG51bGxcbiAgICApKTtcbiAgcmV0dXJuIFtjdXJyZW50U3RhdGVIb29rLCBkaXNwYXRjaCwgc3RhdGVIb29rXTtcbn1cbmZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgYWN0aW9uUXVldWUuYWN0aW9uID0gYWN0aW9uO1xufVxuZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSBjdXJyZW50SG9vaztcbiAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgZGlzcGF0Y2ggPSBjdXJyZW50U3RhdGVIb29rLnF1ZXVlLmRpc3BhdGNoO1xuICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gIHJldHVybiBbc3RhdGVIb29rLCBkaXNwYXRjaCwgITFdO1xufVxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICB0YWcgPSB7IHRhZzogdGFnLCBjcmVhdGU6IGNyZWF0ZSwgaW5zdDogaW5zdCwgZGVwczogZGVwcywgbmV4dDogbnVsbCB9O1xuICBjcmVhdGUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICBudWxsID09PSBjcmVhdGUgJiZcbiAgICAoKGNyZWF0ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjcmVhdGUpKTtcbiAgaW5zdCA9IGNyZWF0ZS5sYXN0RWZmZWN0O1xuICBudWxsID09PSBpbnN0XG4gICAgPyAoY3JlYXRlLmxhc3RFZmZlY3QgPSB0YWcubmV4dCA9IHRhZylcbiAgICA6ICgoZGVwcyA9IGluc3QubmV4dCksXG4gICAgICAoaW5zdC5uZXh0ID0gdGFnKSxcbiAgICAgICh0YWcubmV4dCA9IGRlcHMpLFxuICAgICAgKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnKSk7XG4gIHJldHVybiB0YWc7XG59XG5mdW5jdGlvbiB1cGRhdGVSZWYoKSB7XG4gIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xufVxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KFxuICAgIDEgfCBob29rRmxhZ3MsXG4gICAgY3JlYXRlLFxuICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICB2YXIgaW5zdCA9IGhvb2subWVtb2l6ZWRTdGF0ZS5pbnN0O1xuICBudWxsICE9PSBjdXJyZW50SG9vayAmJlxuICBudWxsICE9PSBkZXBzICYmXG4gIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLmRlcHMpXG4gICAgPyAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgaW5zdCwgZGVwcykpXG4gICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdCgxIHwgaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIGRlcHMpKSk7XG59XG5mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgbW91bnRFZmZlY3RJbXBsKDgzOTA2NTYsIDgsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgOCwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgMiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgNCwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIHZhciByZWZDbGVhbnVwID0gcmVmKGNyZWF0ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXAgPyByZWZDbGVhbnVwKCkgOiByZWYobnVsbCk7XG4gICAgfTtcbiAgfVxuICBpZiAobnVsbCAhPT0gcmVmICYmIHZvaWQgMCAhPT0gcmVmKVxuICAgIHJldHVybiAoXG4gICAgICAoY3JlYXRlID0gY3JlYXRlKCkpLFxuICAgICAgKHJlZi5jdXJyZW50ID0gY3JlYXRlKSxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHVwZGF0ZUVmZmVjdEltcGwoNCwgNCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZGVwcyk7XG59XG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUoKSB7fVxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIGRlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICBwcmV2U3RhdGUgPSBuZXh0Q3JlYXRlKCk7XG4gIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICB0cnkge1xuICAgICAgbmV4dENyZWF0ZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgfVxuICB9XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtwcmV2U3RhdGUsIGRlcHNdO1xuICByZXR1cm4gcHJldlN0YXRlO1xufVxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmICh2b2lkIDAgPT09IGluaXRpYWxWYWx1ZSB8fCAwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSlcbiAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlO1xuICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IGhvb2s7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICBpZiAobnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KVxuICAgIHJldHVybiAoXG4gICAgICAoaG9vayA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkpLFxuICAgICAgb2JqZWN0SXMoaG9vaywgcHJldlZhbHVlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgIGhvb2tcbiAgICApO1xuICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgNDIpKVxuICAgIHJldHVybiAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSwgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihmaWJlciwgcXVldWUsIHBlbmRpbmdTdGF0ZSwgZmluaXNoZWRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID1cbiAgICAwICE9PSBwcmV2aW91c1ByaW9yaXR5ICYmIDggPiBwcmV2aW91c1ByaW9yaXR5ID8gcHJldmlvdXNQcmlvcml0eSA6IDg7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgITEsIHF1ZXVlLCBwZW5kaW5nU3RhdGUpO1xuICB0cnkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCksXG4gICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgaWYgKFxuICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICkge1xuICAgICAgdmFyIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSA9IGNoYWluVGhlbmFibGVWYWx1ZShcbiAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgIGZpbmlzaGVkU3RhdGVcbiAgICAgICk7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlLFxuICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICB7IHRoZW46IGZ1bmN0aW9uICgpIHt9LCBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiBlcnJvciB9LFxuICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoKVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBub29wJDIoKSB7fVxuZnVuY3Rpb24gc3RhcnRIb3N0VHJhbnNpdGlvbihmb3JtRmliZXIsIHBlbmRpbmdTdGF0ZSwgYWN0aW9uLCBmb3JtRGF0YSkge1xuICBpZiAoNSAhPT0gZm9ybUZpYmVyLnRhZykgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzYpKTtcbiAgdmFyIHF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5xdWV1ZTtcbiAgc3RhcnRUcmFuc2l0aW9uKFxuICAgIGZvcm1GaWJlcixcbiAgICBxdWV1ZSxcbiAgICBwZW5kaW5nU3RhdGUsXG4gICAgc2hhcmVkTm90UGVuZGluZ09iamVjdCxcbiAgICBudWxsID09PSBhY3Rpb25cbiAgICAgID8gbm9vcCQyXG4gICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXF1ZXN0Rm9ybVJlc2V0JDEoZm9ybUZpYmVyKTtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGZvcm1EYXRhKTtcbiAgICAgICAgfVxuICApO1xufVxuZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gIHZhciBleGlzdGluZ1N0YXRlSG9vayA9IGZvcm1GaWJlci5tZW1vaXplZFN0YXRlO1xuICBpZiAobnVsbCAhPT0gZXhpc3RpbmdTdGF0ZUhvb2spIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgZXhpc3RpbmdTdGF0ZUhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogc2hhcmVkTm90UGVuZGluZ09iamVjdCxcbiAgICBiYXNlU3RhdGU6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgbGFuZXM6IDAsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3RcbiAgICB9LFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGluaXRpYWxSZXNldFN0YXRlID0ge307XG4gIGV4aXN0aW5nU3RhdGVIb29rLm5leHQgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgYmFzZVN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IHtcbiAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICBsYW5lczogMCxcbiAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgICB9LFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vaztcbiAgZm9ybUZpYmVyID0gZm9ybUZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gZm9ybUZpYmVyICYmIChmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rKTtcbiAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xufVxuZnVuY3Rpb24gcmVxdWVzdEZvcm1SZXNldCQxKGZvcm1GaWJlcikge1xuICB2YXIgcmVzZXRTdGF0ZVF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5uZXh0LnF1ZXVlO1xuICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZm9ybUZpYmVyLCByZXNldFN0YXRlUXVldWUsIHt9LCByZXF1ZXN0VXBkYXRlTGFuZSgpKTtcbn1cbmZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICByZXR1cm4gcmVhZENvbnRleHQoSG9zdFRyYW5zaXRpb25Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUlkKCkge1xuICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlZnJlc2goKSB7XG4gIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xufVxuZnVuY3Rpb24gcmVmcmVzaENhY2hlKGZpYmVyKSB7XG4gIGZvciAodmFyIHByb3ZpZGVyID0gZmliZXIucmV0dXJuOyBudWxsICE9PSBwcm92aWRlcjsgKSB7XG4gICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgIGNhc2UgMjQ6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKTtcbiAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgIHZhciByb290JDYzID0gZW5xdWV1ZVVwZGF0ZShwcm92aWRlciwgZmliZXIsIGxhbmUpO1xuICAgICAgICBudWxsICE9PSByb290JDYzICYmXG4gICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290JDYzLCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290JDYzLCBwcm92aWRlciwgbGFuZSkpO1xuICAgICAgICBwcm92aWRlciA9IHsgY2FjaGU6IGNyZWF0ZUNhY2hlKCkgfTtcbiAgICAgICAgZmliZXIucGF5bG9hZCA9IHByb3ZpZGVyO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpO1xuICBhY3Rpb24gPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICByZXZlcnRMYW5lOiAwLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKVxuICAgID8gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCBhY3Rpb24pXG4gICAgOiAoKGFjdGlvbiA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkpLFxuICAgICAgbnVsbCAhPT0gYWN0aW9uICYmXG4gICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShhY3Rpb24sIHF1ZXVlLCBsYW5lKSkpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCk7XG4gIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZmliZXIsIHF1ZXVlLCBhY3Rpb24sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIHJldmVydExhbmU6IDAsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICBlbHNlIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChcbiAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAobnVsbCA9PT0gYWx0ZXJuYXRlIHx8IDAgPT09IGFsdGVybmF0ZS5sYW5lcykgJiZcbiAgICAgICgoYWx0ZXJuYXRlID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciksIG51bGwgIT09IGFsdGVybmF0ZSlcbiAgICApXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZSA9IGFsdGVybmF0ZShjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcbiAgICAgICAgaWYgKG9iamVjdElzKGVhZ2VyU3RhdGUsIGN1cnJlbnRTdGF0ZSkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgMCksXG4gICAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICB9XG4gICAgYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFjdGlvbiwgZmliZXIsIGxhbmUpLFxuICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICEwXG4gICAgICApO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCB0aHJvd0lmRHVyaW5nUmVuZGVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIGFjdGlvbiA9IHtcbiAgICBsYW5lOiAyLFxuICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBpZiAodGhyb3dJZkR1cmluZ1JlbmRlcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzkpKTtcbiAgfSBlbHNlXG4gICAgKHRocm93SWZEdXJpbmdSZW5kZXIgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uLFxuICAgICAgMlxuICAgICkpLFxuICAgICAgbnVsbCAhPT0gdGhyb3dJZkR1cmluZ1JlbmRlciAmJlxuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIodGhyb3dJZkR1cmluZ1JlbmRlciwgZmliZXIsIDIpO1xufVxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gKFxuICAgIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8XG4gICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpXG4gICk7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID1cbiAgICAhMDtcbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICBudWxsID09PSBwZW5kaW5nXG4gICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gIGlmICgwICE9PSAobGFuZSAmIDQxOTQxNzYpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBxdWV1ZS5sYW5lcztcbiAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICBxdWV1ZS5sYW5lcyA9IGxhbmU7XG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gIH1cbn1cbnZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3Jcbn07XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbkNvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbkNvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlQWN0aW9uU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50ID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgY2FsbGJhY2ssXG4gICAgICB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwc1xuICAgIF07XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LFxuICB1c2VDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlRWZmZWN0OiBtb3VudEVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICBtb3VudEVmZmVjdEltcGwoXG4gICAgICA0MTk0MzA4LFxuICAgICAgNCxcbiAgICAgIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksXG4gICAgICBkZXBzXG4gICAgKTtcbiAgfSxcbiAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbCg0MTk0MzA4LCA0LCBjcmVhdGUsIGRlcHMpO1xuICB9LFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICBtb3VudEVmZmVjdEltcGwoNCwgMiwgY3JlYXRlLCBkZXBzKTtcbiAgfSxcbiAgdXNlTWVtbzogZnVuY3Rpb24gKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgIGlmICh2b2lkIDAgIT09IGluaXQpIHtcbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHJlZHVjZXIgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgbGFuZXM6IDAsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgfTtcbiAgICBob29rLnF1ZXVlID0gcmVkdWNlcjtcbiAgICByZWR1Y2VyID0gcmVkdWNlci5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKFxuICAgICAgbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICByZWR1Y2VyXG4gICAgKTtcbiAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gIH0sXG4gIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICBpbml0aWFsVmFsdWUgPSB7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9O1xuICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlKTtcbiAgfSxcbiAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpO1xuICAgIHZhciBxdWV1ZSA9IGluaXRpYWxTdGF0ZS5xdWV1ZSxcbiAgICAgIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogbW91bnREZWJ1Z1ZhbHVlLFxuICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgfSxcbiAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgc3RhdGVIb29rID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQoXG4gICAgICBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgIHN0YXRlSG9vay5xdWV1ZSxcbiAgICAgICEwLFxuICAgICAgITFcbiAgICApO1xuICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgICByZXR1cm4gWyExLCBzdGF0ZUhvb2tdO1xuICB9LFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDA3KSk7XG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQ5KSk7XG4gICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgdmFyIGluc3QgPSB7IHZhbHVlOiBnZXRTZXJ2ZXJTbmFwc2hvdCwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH07XG4gICAgaG9vay5xdWV1ZSA9IGluc3Q7XG4gICAgbW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbXG4gICAgICBzdWJzY3JpYmVcbiAgICBdKTtcbiAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgIHB1c2hFZmZlY3QoXG4gICAgICA5LFxuICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBmaWJlcixcbiAgICAgICAgaW5zdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgIGdldFNuYXBzaG90XG4gICAgICApLFxuICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgfSxcbiAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICBpZGVudGlmaWVyUHJlZml4ID0gd29ya0luUHJvZ3Jlc3NSb290LmlkZW50aWZpZXJQcmVmaXg7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgIChcbiAgICAgICAgICBpZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8ICgzMiAtIGNsejMyKGlkV2l0aExlYWRpbmdCaXQpIC0gMSkpXG4gICAgICAgICkudG9TdHJpbmcoMzIpICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgIFwiOlwiICsgaWRlbnRpZmllclByZWZpeCArIFwiUlwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgIDAgPCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggKz0gXCJIXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQudG9TdHJpbmcoMzIpKTtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggKz0gXCI6XCI7XG4gICAgfSBlbHNlXG4gICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZ2xvYmFsQ2xpZW50SWRDb3VudGVyKyspLFxuICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgIGlkZW50aWZpZXJQcmVmaXggK1xuICAgICAgICAgIFwiclwiICtcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQudG9TdHJpbmcoMzIpICtcbiAgICAgICAgICBcIjpcIik7XG4gICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgfSxcbiAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgIG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgKSk7XG4gIH1cbn07XG5Ib29rc0Rpc3BhdGNoZXJPbk1vdW50LnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlRm9ybVN0YXRlID0gbW91bnRBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlQWN0aW9uU3RhdGUgPSBtb3VudEFjdGlvblN0YXRlO1xuSG9va3NEaXNwYXRjaGVyT25Nb3VudC51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IDAsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIGhvb2sgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgIG51bGwsXG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAhMCxcbiAgICBxdWV1ZVxuICApO1xuICBxdWV1ZS5kaXNwYXRjaCA9IGhvb2s7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2tdO1xufTtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZSA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ2FsbGJhY2s6IHVwZGF0ZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlRWZmZWN0OiB1cGRhdGVFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdXBkYXRlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0ZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbzogdXBkYXRlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXBkYXRlUmVkdWNlcixcbiAgdXNlUmVmOiB1cGRhdGVSZWYsXG4gIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICB9LFxuICB1c2VEZWJ1Z1ZhbHVlOiBtb3VudERlYnVnVmFsdWUsXG4gIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICBob29rLFxuICAgICAgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgaW5pdGlhbFZhbHVlXG4gICAgKTtcbiAgfSxcbiAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgIHJldHVybiBbXG4gICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICBzdGFydFxuICAgIF07XG4gIH0sXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgdXNlSWQ6IHVwZGF0ZUlkXG59O1xuSG9va3NEaXNwYXRjaGVyT25VcGRhdGUudXNlQ2FjaGVSZWZyZXNoID0gdXBkYXRlUmVmcmVzaDtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VGb3JtU3RhdGUgPSB1cGRhdGVBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZUFjdGlvblN0YXRlID0gdXBkYXRlQWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufTtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogdXBkYXRlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VFZmZlY3Q6IHVwZGF0ZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB1cGRhdGVJbnNlcnRpb25FZmZlY3QsXG4gIHVzZUxheW91dEVmZmVjdDogdXBkYXRlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vOiB1cGRhdGVNZW1vLFxuICB1c2VSZWR1Y2VyOiByZXJlbmRlclJlZHVjZXIsXG4gIHVzZVJlZjogdXBkYXRlUmVmLFxuICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICB9LFxuICB1c2VEZWJ1Z1ZhbHVlOiBtb3VudERlYnVnVmFsdWUsXG4gIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudEhvb2tcbiAgICAgID8gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKVxuICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICBob29rLFxuICAgICAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICAgICk7XG4gIH0sXG4gIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgIHJldHVybiBbXG4gICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICBzdGFydFxuICAgIF07XG4gIH0sXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgdXNlSWQ6IHVwZGF0ZUlkXG59O1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VDYWNoZVJlZnJlc2ggPSB1cGRhdGVSZWZyZXNoO1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZUZvcm1TdGF0ZSA9IHJlcmVuZGVyQWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZUFjdGlvblN0YXRlID0gcmVyZW5kZXJBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXIudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICBpZiAobnVsbCAhPT0gY3VycmVudEhvb2spXG4gICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2sucXVldWUuZGlzcGF0Y2hdO1xufTtcbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgY3RvcixcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICBuZXh0UHJvcHNcbikge1xuICBjdG9yID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgY3Rvcik7XG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9XG4gICAgbnVsbCA9PT0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8IHZvaWQgMCA9PT0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICA/IGN0b3JcbiAgICAgIDogYXNzaWduKHt9LCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xufVxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQgPSBjb21wb25lbnQuX3JlYWN0SW50ZXJuYWxzKVxuICAgICAgPyBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGNvbXBvbmVudCkgPT09IGNvbXBvbmVudFxuICAgICAgOiAhMTtcbiAgfSxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpLFxuICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmIG51bGwgIT09IGNhbGxiYWNrICYmICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCksXG4gICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IDE7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgJiYgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpLFxuICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSAyO1xuICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgJiYgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjayA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihjYWxsYmFjaywgaW5zdCwgbGFuZSksXG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGNhbGxiYWNrLCBpbnN0LCBsYW5lKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGN0b3IsXG4gIG9sZFByb3BzLFxuICBuZXdQcm9wcyxcbiAgb2xkU3RhdGUsXG4gIG5ld1N0YXRlLFxuICBuZXh0Q29udGV4dFxuKSB7XG4gIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3Muc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gICAgPyB3b3JrSW5Qcm9ncmVzcy5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dClcbiAgICA6IGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50XG4gICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgIDogITA7XG59XG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGluc3RhbmNlLFxuICBuZXdQcm9wcyxcbiAgbmV4dENvbnRleHRcbikge1xuICB3b3JrSW5Qcm9ncmVzcyA9IGluc3RhbmNlLnN0YXRlO1xuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIGluc3RhbmNlLnN0YXRlICE9PSB3b3JrSW5Qcm9ncmVzcyAmJlxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICB2YXIgbmV3UHJvcHMgPSBiYXNlUHJvcHM7XG4gIGlmIChcInJlZlwiIGluIGJhc2VQcm9wcykge1xuICAgIG5ld1Byb3BzID0ge307XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gYmFzZVByb3BzKVxuICAgICAgXCJyZWZcIiAhPT0gcHJvcE5hbWUgJiYgKG5ld1Byb3BzW3Byb3BOYW1lXSA9IGJhc2VQcm9wc1twcm9wTmFtZV0pO1xuICB9XG4gIGlmICgoQ29tcG9uZW50ID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcykpIHtcbiAgICBuZXdQcm9wcyA9PT0gYmFzZVByb3BzICYmIChuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMpKTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSQ2NyBpbiBDb21wb25lbnQpXG4gICAgICB2b2lkIDAgPT09IG5ld1Byb3BzW3Byb3BOYW1lJDY3XSAmJlxuICAgICAgICAobmV3UHJvcHNbcHJvcE5hbWUkNjddID0gQ29tcG9uZW50W3Byb3BOYW1lJDY3XSk7XG4gIH1cbiAgcmV0dXJuIG5ld1Byb3BzO1xufVxudmFyIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICA/IHJlcG9ydEVycm9yXG4gICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9O1xuZnVuY3Rpb24gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25DYXVnaHRFcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IoZXJyb3IpIHtcbiAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xufVxuZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICB2YXIgb25VbmNhdWdodEVycm9yID0gcm9vdC5vblVuY2F1Z2h0RXJyb3I7XG4gICAgb25VbmNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwgeyBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrIH0pO1xuICB9IGNhdGNoIChlJDY4KSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlJDY4O1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsb2dDYXVnaHRFcnJvcihyb290LCBib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9uQ2F1Z2h0RXJyb3IgPSByb290Lm9uQ2F1Z2h0RXJyb3I7XG4gICAgb25DYXVnaHRFcnJvcihlcnJvckluZm8udmFsdWUsIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICBlcnJvckJvdW5kYXJ5OiAxID09PSBib3VuZGFyeS50YWcgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUkNjkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGUkNjk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgbGFuZS50YWcgPSAzO1xuICBsYW5lLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgbGFuZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGVycm9ySW5mbyk7XG4gIH07XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIGxhbmUudGFnID0gMztcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2dDYXVnaHRFcnJvcihyb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICB9O1xuICB9XG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICBudWxsICE9PSBpbnN0ICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICh1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2dDYXVnaHRFcnJvcihyb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWRcbiAgICAgICAgICA/IChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW3RoaXNdKSlcbiAgICAgICAgICA6IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZCh0aGlzKSk7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogbnVsbCAhPT0gc3RhY2sgPyBzdGFjayA6IFwiXCJcbiAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24oXG4gIHJvb3QsXG4gIHJldHVybkZpYmVyLFxuICBzb3VyY2VGaWJlcixcbiAgdmFsdWUsXG4gIHJvb3RSZW5kZXJMYW5lc1xuKSB7XG4gIHNvdXJjZUZpYmVyLmZsYWdzIHw9IDMyNzY4O1xuICBpZiAoXG4gICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuXG4gICkge1xuICAgIHJldHVybkZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIHNvdXJjZUZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBpZiAobnVsbCAhPT0gc291cmNlRmliZXIpIHtcbiAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgICAgPyByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKClcbiAgICAgICAgICAgICAgOiBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAzKSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICA6IHJldHVybkZpYmVyLmFkZCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt2YWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICA6ICgoc291cmNlRmliZXIgPSByZXR1cm5GaWJlci5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlci5yZXRyeVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHNvdXJjZUZpYmVyLmFkZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzNSwgc291cmNlRmliZXIudGFnKSk7XG4gICAgfVxuICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGlmIChpc0h5ZHJhdGluZylcbiAgICByZXR1cm4gKFxuICAgICAgKHJldHVybkZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICA/ICgwID09PSAocmV0dXJuRmliZXIuZmxhZ3MgJiA2NTUzNikgJiYgKHJldHVybkZpYmVyLmZsYWdzIHw9IDI1NiksXG4gICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAocmV0dXJuRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgIHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgKChyb290ID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MjIpLCB7IGNhdXNlOiB2YWx1ZSB9KSksXG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHJvb3QsIHNvdXJjZUZpYmVyKSkpKVxuICAgICAgICA6ICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQyMyksIHtcbiAgICAgICAgICAgICAgY2F1c2U6IHZhbHVlXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihyZXR1cm5GaWJlciwgc291cmNlRmliZXIpXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAocm9vdCA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgIChyb290LmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgIChyb290LmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKSksXG4gICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgIHJvb3Quc3RhdGVOb2RlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUocm9vdCwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICA0ICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDIpKSxcbiAgICAgICExXG4gICAgKTtcbiAgdmFyIHdyYXBwZXJFcnJvciA9IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTIwKSwgeyBjYXVzZTogdmFsdWUgfSk7XG4gIHdyYXBwZXJFcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHdyYXBwZXJFcnJvciwgc291cmNlRmliZXIpO1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzXG4gICAgPyAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFt3cmFwcGVyRXJyb3JdKVxuICAgIDogd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKHdyYXBwZXJFcnJvcik7XG4gIDQgIT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAyKTtcbiAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKSByZXR1cm4gITA7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgc291cmNlRmliZXIgPSByZXR1cm5GaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAocm9vdCA9IHJvb3RSZW5kZXJMYW5lcyAmIC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290KSxcbiAgICAgICAgICAocm9vdCA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShzb3VyY2VGaWJlci5zdGF0ZU5vZGUsIHZhbHVlLCByb290KSksXG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290KSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnR5cGUpLFxuICAgICAgICAgICh3cmFwcGVyRXJyb3IgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgIDAgPT09IChzb3VyY2VGaWJlci5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IHdyYXBwZXJFcnJvciAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdyYXBwZXJFcnJvci5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyh3cmFwcGVyRXJyb3IpKSkpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShyb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgc291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIH0gd2hpbGUgKG51bGwgIT09IHNvdXJjZUZpYmVyKTtcbiAgcmV0dXJuICExO1xufVxudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiA9IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDYxKSksXG4gIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID1cbiAgICBudWxsID09PSBjdXJyZW50XG4gICAgICA/IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpXG4gICAgICA6IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG59XG5mdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICBuZXh0UHJvcHMsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgaWYgKFwicmVmXCIgaW4gbmV4dFByb3BzKSB7XG4gICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBuZXh0UHJvcHMpXG4gICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gbmV4dFByb3BzW2tleV0pO1xuICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIENvbXBvbmVudCxcbiAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgcmVmLFxuICAgIHJlbmRlckxhbmVzXG4gICk7XG4gIGtleSA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgIHJldHVybiAoXG4gICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICk7XG4gIGlzSHlkcmF0aW5nICYmIGtleSAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICBuZXh0UHJvcHMsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIGlmIChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICAgIHZvaWQgMCA9PT0gdHlwZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgIG51bGwgPT09IENvbXBvbmVudC5jb21wYXJlXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnRhZyA9IDE1KSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSB0eXBlKSxcbiAgICAgICAgdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgIENvbXBvbmVudC50eXBlLFxuICAgICAgbnVsbCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKTtcbiAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbiAgfVxuICB0eXBlID0gY3VycmVudC5jaGlsZDtcbiAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICB2YXIgcHJldlByb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgIENvbXBvbmVudCA9IG51bGwgIT09IENvbXBvbmVudCA/IENvbXBvbmVudCA6IHNoYWxsb3dFcXVhbDtcbiAgICBpZiAoQ29tcG9uZW50KHByZXZQcm9wcywgbmV4dFByb3BzKSAmJiBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmKVxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICBjdXJyZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3ModHlwZSwgbmV4dFByb3BzKTtcbiAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKFxuICAgICAgc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZlxuICAgIClcbiAgICAgIGlmIChcbiAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzKSxcbiAgICAgICAgY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKVxuICAgICAgKVxuICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgJiYgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICByZW5kZXJMYW5lc1xuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICBuZXh0SXNEZXRhY2hlZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMiksXG4gICAgcHJldlN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoXCJoaWRkZW5cIiA9PT0gbmV4dFByb3BzLm1vZGUgfHwgbmV4dElzRGV0YWNoZWQpIHtcbiAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSkge1xuICAgICAgbmV4dFByb3BzID1cbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzIDogcmVuZGVyTGFuZXM7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgIGZvciAobmV4dElzRGV0YWNoZWQgPSAwOyBudWxsICE9PSBuZXh0Q2hpbGRyZW47IClcbiAgICAgICAgICAobmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgICAgbmV4dElzRGV0YWNoZWQgfCBuZXh0Q2hpbGRyZW4ubGFuZXMgfCBuZXh0Q2hpbGRyZW4uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAobmV4dENoaWxkcmVuID0gbmV4dENoaWxkcmVuLnNpYmxpbmcpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbmV4dElzRGV0YWNoZWQgJiB+bmV4dFByb3BzO1xuICAgICAgfSBlbHNlICh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpO1xuICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpXG4gICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHsgYmFzZUxhbmVzOiAwLCBjYWNoZVBvb2w6IG51bGwgfSksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBwdXNoVHJhbnNpdGlvbihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGxcbiAgICAgICAgICApLFxuICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICA/IHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpXG4gICAgICAgICAgOiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKCksXG4gICAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gIH0gZWxzZVxuICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgPyAocHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZS5jYWNoZVBvb2wpLFxuICAgICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKSxcbiAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSlcbiAgICAgIDogKG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpLFxuICAgICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKCksXG4gICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcykpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cbmZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgbmV4dEJhc2VMYW5lcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICBudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgID8gbnVsbFxuICAgICAgOiB7IHBhcmVudDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUsIHBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCB9O1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lcyxcbiAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICB9O1xuICBudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjaygpO1xuICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgITApO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgaWYgKG51bGwgPT09IHJlZilcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICBudWxsICE9PSBjdXJyZW50LnJlZiAmJlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQpO1xuICBlbHNlIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVmICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiByZWYpXG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI4NCkpO1xuICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0O1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgbmV4dFByb3BzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgQ29tcG9uZW50ID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICB2b2lkIDAsXG4gICAgcmVuZGVyTGFuZXNcbiAgKTtcbiAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgcmV0dXJuIChcbiAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgKTtcbiAgaXNIeWRyYXRpbmcgJiYgbmV4dFByb3BzICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cbmZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgbmV4dFByb3BzLFxuICBDb21wb25lbnQsXG4gIHNlY29uZEFyZyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICBzZWNvbmRBcmdcbiAgKTtcbiAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCk7XG4gIENvbXBvbmVudCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgIHJldHVybiAoXG4gICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICk7XG4gIGlzSHlkcmF0aW5nICYmIENvbXBvbmVudCAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgbmV4dFByb3BzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgY29udGV4dFR5cGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlICYmXG4gICAgICBudWxsICE9PSBjb250ZXh0VHlwZSAmJlxuICAgICAgKGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSkpO1xuICAgIGNvbnRleHQgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICBudWxsICE9PSBjb250ZXh0LnN0YXRlICYmIHZvaWQgMCAhPT0gY29udGV4dC5zdGF0ZSA/IGNvbnRleHQuc3RhdGUgOiBudWxsO1xuICAgIGNvbnRleHQudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjb250ZXh0O1xuICAgIGNvbnRleHQuX3JlYWN0SW50ZXJuYWxzID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBjb250ZXh0LnByb3BzID0gbmV4dFByb3BzO1xuICAgIGNvbnRleHQuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHQucmVmcyA9IHt9O1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY29udGV4dFR5cGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgY29udGV4dC5jb250ZXh0ID1cbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSAmJiBudWxsICE9PSBjb250ZXh0VHlwZVxuICAgICAgICA/IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKVxuICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICBjb250ZXh0LnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBjb250ZXh0VHlwZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiZcbiAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgY29udGV4dFR5cGUsXG4gICAgICAgIG5leHRQcm9wc1xuICAgICAgKSxcbiAgICAgIChjb250ZXh0LnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAoKGNvbnRleHRUeXBlID0gY29udGV4dC5zdGF0ZSksXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgY29udGV4dFR5cGUgIT09IGNvbnRleHQuc3RhdGUgJiZcbiAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoY29udGV4dCwgY29udGV4dC5zdGF0ZSwgbnVsbCksXG4gICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpLFxuICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpLFxuICAgICAgKGNvbnRleHQuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpO1xuICAgIG5leHRQcm9wcyA9ICEwO1xuICB9IGVsc2UgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAgICAgb2xkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gICAgY29udGV4dC5wcm9wcyA9IG9sZFByb3BzO1xuICAgIHZhciBvbGRDb250ZXh0ID0gY29udGV4dC5jb250ZXh0LFxuICAgICAgY29udGV4dFR5cGUkanNjb21wJDAgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgY29udGV4dFR5cGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlJGpzY29tcCQwICYmXG4gICAgICBudWxsICE9PSBjb250ZXh0VHlwZSRqc2NvbXAkMCAmJlxuICAgICAgKGNvbnRleHRUeXBlID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUkanNjb21wJDApKTtcbiAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICBjb250ZXh0VHlwZSRqc2NvbXAkMCA9XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7XG4gICAgY29udGV4dFR5cGUkanNjb21wJDAgfHxcbiAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICgodW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZENvbnRleHQgIT09IGNvbnRleHRUeXBlKSAmJlxuICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICBjb250ZXh0VHlwZVxuICAgICAgICApKTtcbiAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgY29udGV4dC5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgIG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkQ29udGV4dCB8fCBoYXNGb3JjZVVwZGF0ZVxuICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApLFxuICAgICAgICAgIChvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAob2xkUHJvcHMgPVxuICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICBvbGRDb250ZXh0LFxuICAgICAgICAgICAgY29udGV4dFR5cGVcbiAgICAgICAgICApKVxuICAgICAgICAgID8gKGNvbnRleHRUeXBlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG9sZENvbnRleHQpKSxcbiAgICAgICAgKGNvbnRleHQucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAoY29udGV4dC5zdGF0ZSA9IG9sZENvbnRleHQpLFxuICAgICAgICAoY29udGV4dC5jb250ZXh0ID0gY29udGV4dFR5cGUpLFxuICAgICAgICAobmV4dFByb3BzID0gb2xkUHJvcHMpKVxuICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgKG5leHRQcm9wcyA9ICExKSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBjb250ZXh0VHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgY29udGV4dFR5cGUkanNjb21wJDAgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGNvbnRleHRUeXBlKTtcbiAgICBjb250ZXh0LnByb3BzID0gY29udGV4dFR5cGUkanNjb21wJDA7XG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIG9sZFN0YXRlID0gY29udGV4dC5jb250ZXh0O1xuICAgIG9sZENvbnRleHQgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgb2xkUHJvcHMgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9sZENvbnRleHQgJiZcbiAgICAgIG51bGwgIT09IG9sZENvbnRleHQgJiZcbiAgICAgIChvbGRQcm9wcyA9IHJlYWRDb250ZXh0KG9sZENvbnRleHQpKTtcbiAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgIChvbGRDb250ZXh0ID1cbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyB8fFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSkgfHxcbiAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICgoY29udGV4dFR5cGUgIT09IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkUHJvcHMpICYmXG4gICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIG9sZFByb3BzXG4gICAgICAgICkpO1xuICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHQuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHRUeXBlICE9PSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICBvbGRTdGF0ZSAhPT0gbmV3U3RhdGUgfHxcbiAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgIChudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICBudWxsICE9PSBjdXJyZW50LmRlcGVuZGVuY2llcyAmJlxuICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQuZGVwZW5kZW5jaWVzKSlcbiAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyAmJlxuICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAobmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgIChjb250ZXh0VHlwZSRqc2NvbXAkMCA9XG4gICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgY29udGV4dFR5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgb2xkUHJvcHNcbiAgICAgICAgICApIHx8XG4gICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudC5kZXBlbmRlbmNpZXMpKSlcbiAgICAgICAgICA/IChvbGRDb250ZXh0IHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsVXBkYXRlKSB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV3U3RhdGUsIG9sZFByb3BzKSxcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9sZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudERpZFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoY29udGV4dFR5cGUgPT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKGNvbnRleHRUeXBlID09PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlKSksXG4gICAgICAgIChjb250ZXh0LnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgKGNvbnRleHQuc3RhdGUgPSBuZXdTdGF0ZSksXG4gICAgICAgIChjb250ZXh0LmNvbnRleHQgPSBvbGRQcm9wcyksXG4gICAgICAgIChuZXh0UHJvcHMgPSBjb250ZXh0VHlwZSRqc2NvbXAkMCkpXG4gICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgIChjb250ZXh0VHlwZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIChjb250ZXh0VHlwZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgKG5leHRQcm9wcyA9ICExKSk7XG4gIH1cbiAgY29udGV4dCA9IG5leHRQcm9wcztcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIG5leHRQcm9wcyA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gIGNvbnRleHQgfHwgbmV4dFByb3BzXG4gICAgPyAoKGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpLFxuICAgICAgKENvbXBvbmVudCA9XG4gICAgICAgIG5leHRQcm9wcyAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiBjb250ZXh0LnJlbmRlcigpKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxKSxcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbmV4dFByb3BzXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpKVxuICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY29udGV4dC5zdGF0ZSksXG4gICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSlcbiAgICA6IChjdXJyZW50ID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApKTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIG5leHRDaGlsZHJlbixcbiAgcmVuZGVyTGFuZXNcbikge1xuICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI1NjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG52YXIgU1VTUEVOREVEX01BUktFUiA9IHsgZGVoeWRyYXRlZDogbnVsbCwgdHJlZUNvbnRleHQ6IG51bGwsIHJldHJ5TGFuZTogMCB9O1xuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7IGJhc2VMYW5lczogcmVuZGVyTGFuZXMsIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKSB9O1xufVxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gIGN1cnJlbnQsXG4gIHByaW1hcnlUcmVlRGlkRGVmZXIsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LmNoaWxkTGFuZXMgJiB+cmVuZGVyTGFuZXMgOiAwO1xuICBwcmltYXJ5VHJlZURpZERlZmVyICYmIChjdXJyZW50IHw9IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICBzaG93RmFsbGJhY2sgPSAhMSxcbiAgICBkaWRTdXNwZW5kID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSxcbiAgICBKU0NvbXBpbGVyX3RlbXA7XG4gIChKU0NvbXBpbGVyX3RlbXAgPSBkaWRTdXNwZW5kKSB8fFxuICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgPyAhMVxuICAgICAgICA6IDAgIT09IChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiAyKSk7XG4gIEpTQ29tcGlsZXJfdGVtcCAmJiAoKHNob3dGYWxsYmFjayA9ICEwKSwgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xMjkpKTtcbiAgSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzIpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMzM7XG4gIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgPyBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgIGlmICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAgIGM6IHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IG5leHRJbnN0YW5jZTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5leHRJbnN0YW5jZSA9IHJvb3RPclNpbmdsZXRvbkNvbnRleHQ7XG4gICAgICAgICAgICAgIDggIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5ub2RlVHlwZTtcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5uZXh0U2libGluZ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0SW5zdGFuY2UgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZVxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZGVoeWRyYXRlZDogbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHRyZWVDb250ZXh0OlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHJlZUNvbnRleHRQcm92aWRlclxuICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IHRyZWVDb250ZXh0SWQsIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJldHJ5TGFuZTogNTM2ODcwOTEyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoXG4gICAgICAgICAgICAgICAgMTgsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc3RhdGVOb2RlID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCksXG4gICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICEwKSlcbiAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICExKTtcbiAgICAgICAgfVxuICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSAmJlxuICAgICAgICAoKG5leHRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZS5kZWh5ZHJhdGVkKSwgbnVsbCAhPT0gbmV4dEluc3RhbmNlKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIFwiJCFcIiA9PT0gbmV4dEluc3RhbmNlLmRhdGFcbiAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMTYpXG4gICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgbmV4dEluc3RhbmNlID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAobmV4dEluc3RhbmNlID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgIHsgbW9kZTogXCJoaWRkZW5cIiwgY2hpbGRyZW46IG5leHRJbnN0YW5jZSB9LFxuICAgICAgICAgIHNob3dGYWxsYmFja1xuICAgICAgICApKSxcbiAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKSxcbiAgICAgICAgKG5leHRJbnN0YW5jZS5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAobmV4dEluc3RhbmNlLnNpYmxpbmcgPSBuZXh0UHJvcHMpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgIG5leHRQcm9wc1xuICAgICAgKTtcbiAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpO1xuICB9XG4gIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKFxuICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCAmJlxuICAgICgobmV4dEluc3RhbmNlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLmRlaHlkcmF0ZWQpLFxuICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgKSB7XG4gICAgaWYgKGRpZFN1c3BlbmQpXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NlxuICAgICAgICA/IChwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKSkpXG4gICAgICAgIDogbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgOiAocmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbiB9LFxuICAgICAgICAgICAgICBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAobmV4dFByb3BzLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gc2hvd0ZhbGxiYWNrKSk7XG4gICAgZWxzZSBpZiAoXG4gICAgICAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgIFwiJCFcIiA9PT0gbmV4dEluc3RhbmNlLmRhdGEpXG4gICAgKSB7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICBuZXh0SW5zdGFuY2UubmV4dFNpYmxpbmcgJiYgbmV4dEluc3RhbmNlLm5leHRTaWJsaW5nLmRhdGFzZXQ7XG4gICAgICBpZiAoSlNDb21waWxlcl90ZW1wKSB2YXIgZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wLmRnc3Q7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPSBkaWdlc3Q7XG4gICAgICBuZXh0UHJvcHMgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQxOSkpO1xuICAgICAgbmV4dFByb3BzLnN0YWNrID0gXCJcIjtcbiAgICAgIG5leHRQcm9wcy5kaWdlc3QgPSBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHsgdmFsdWU6IG5leHRQcm9wcywgc291cmNlOiBudWxsLCBzdGFjazogbnVsbCB9KTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAhMSksXG4gICAgICAoSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHJlbmRlckxhbmVzICYgY3VycmVudC5jaGlsZExhbmVzKSksXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8IEpTQ29tcGlsZXJfdGVtcClcbiAgICApIHtcbiAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgIGlmIChudWxsICE9PSBKU0NvbXBpbGVyX3RlbXApIHtcbiAgICAgICAgbmV4dFByb3BzID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgNDIpKSBuZXh0UHJvcHMgPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3dpdGNoIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgIGNhc2UgNTEyOlxuICAgICAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICAgICAgY2FzZSAxNjM4NDpcbiAgICAgICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICAgICAgY2FzZSAxMzEwNzI6XG4gICAgICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICAgICAgY2FzZSAxMDQ4NTc2OlxuICAgICAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDY0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxMzQyMTc3Mjg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgMCAhPT0gKG5leHRQcm9wcyAmIChKU0NvbXBpbGVyX3RlbXAuc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogbmV4dFByb3BzO1xuICAgICAgICBpZiAoMCAhPT0gbmV4dFByb3BzICYmIG5leHRQcm9wcyAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnJldHJ5TGFuZSlcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXRyeUxhbmUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoSlNDb21waWxlcl90ZW1wLCBjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBcIiQ/XCIgPT09IG5leHRJbnN0YW5jZS5kYXRhIHx8IHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIFwiJD9cIiA9PT0gbmV4dEluc3RhbmNlLmRhdGFcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlLl9yZWFjdFJldHJ5ID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICA6ICgoY3VycmVudCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC50cmVlQ29udGV4dCksXG4gICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgIG5leHRJbnN0YW5jZS5uZXh0U2libGluZ1xuICAgICAgICAgICkpLFxuICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICgoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkKSxcbiAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlciksXG4gICAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGN1cnJlbnQuaWQpLFxuICAgICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBjdXJyZW50Lm92ZXJmbG93KSxcbiAgICAgICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3MpKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICApKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5NikpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgIHJldHVybiAoXG4gICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAobmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3VycmVudC5jaGlsZCksXG4gICAgICAoZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnNpYmxpbmcpLFxuICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCwge1xuICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICB9KSksXG4gICAgICAobmV4dFByb3BzLnN1YnRyZWVGbGFncyA9XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zdWJ0cmVlRmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICBudWxsICE9PSBkaWdlc3RcbiAgICAgICAgPyAoc2hvd0ZhbGxiYWNrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZGlnZXN0LCBzaG93RmFsbGJhY2spKVxuICAgICAgICA6ICgoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpKSxcbiAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgIChuZXh0UHJvcHMgPSBzaG93RmFsbGJhY2spLFxuICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgIChuZXh0SW5zdGFuY2UgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGUpLFxuICAgICAgbnVsbCA9PT0gbmV4dEluc3RhbmNlXG4gICAgICAgID8gKG5leHRJbnN0YW5jZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgIDogKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBuZXh0SW5zdGFuY2UuY2FjaGVQb29sKSxcbiAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICAgID8gKChkaWdlc3QgPSBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5wYXJlbnQgIT09IGRpZ2VzdFxuICAgICAgICAgICAgICAgICAgPyB7IHBhcmVudDogZGlnZXN0LCBwb29sOiBkaWdlc3QgfVxuICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApKVxuICAgICAgICAgICAgOiAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gZ2V0U3VzcGVuZGVkQ2FjaGUoKSksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgIGJhc2VMYW5lczogbmV4dEluc3RhbmNlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgY2FjaGVQb29sOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICB9KSksXG4gICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICkpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgIG5leHRQcm9wc1xuICAgICk7XG4gIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlbmRlckxhbmVzID0gY3VycmVudC5jaGlsZDtcbiAgY3VycmVudCA9IHJlbmRlckxhbmVzLnNpYmxpbmc7XG4gIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIHtcbiAgICBtb2RlOiBcInZpc2libGVcIixcbiAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gIH0pO1xuICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAoKEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyksXG4gICAgbnVsbCA9PT0gSlNDb21waWxlcl90ZW1wXG4gICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRdKSwgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2KSlcbiAgICAgIDogSlNDb21waWxlcl90ZW1wLnB1c2goY3VycmVudCkpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHJlbmRlckxhbmVzO1xufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKSB7XG4gIHByaW1hcnlDaGlsZHJlbiA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuIH0sXG4gICAgd29ya0luUHJvZ3Jlc3MubW9kZVxuICApO1xuICBwcmltYXJ5Q2hpbGRyZW4ucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlKSB7XG4gIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIDAsIG51bGwpO1xufVxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIGN1cnJlbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICApO1xuICBjdXJyZW50LmZsYWdzIHw9IDI7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCk7XG59XG5mdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gIHdvcmtJblByb2dyZXNzLFxuICBpc0JhY2t3YXJkcyxcbiAgdGFpbCxcbiAgbGFzdENvbnRlbnRSb3csXG4gIHRhaWxNb2RlXG4pIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgbnVsbCA9PT0gcmVuZGVyU3RhdGVcbiAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgICB9KVxuICAgIDogKChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzKSxcbiAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwKSxcbiAgICAgIChyZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3cpLFxuICAgICAgKHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsKSxcbiAgICAgIChyZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXIsXG4gICAgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcy5jaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICBuZXh0UHJvcHMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIGlmICgwICE9PSAobmV4dFByb3BzICYgMikpXG4gICAgKG5leHRQcm9wcyA9IChuZXh0UHJvcHMgJiAxKSB8IDIpLCAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KTtcbiAgZWxzZSB7XG4gICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgYTogZm9yIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGN1cnJlbnQsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGVsc2UgaWYgKDE5ID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoY3VycmVudCwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgICAgIGN1cnJlbnQuY2hpbGQucmV0dXJuID0gY3VycmVudDtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrIGE7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBjdXJyZW50LnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50LnJldHVybiB8fCBjdXJyZW50LnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LnNpYmxpbmcucmV0dXJuID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICB9XG4gICAgbmV4dFByb3BzICY9IDE7XG4gIH1cbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXh0UHJvcHMpO1xuICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgY2FzZSBcImZvcndhcmRzXCI6XG4gICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgZm9yIChyZXZlYWxPcmRlciA9IG51bGw7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgIChjdXJyZW50ID0gcmVuZGVyTGFuZXMuYWx0ZXJuYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAgIChyZXZlYWxPcmRlciA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICBudWxsID09PSByZW5kZXJMYW5lc1xuICAgICAgICA/ICgocmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpKVxuICAgICAgICA6ICgocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcy5zaWJsaW5nKSwgKHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsKSk7XG4gICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAhMSxcbiAgICAgICAgcmV2ZWFsT3JkZXIsXG4gICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICB0YWlsTW9kZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgIHJlbmRlckxhbmVzID0gbnVsbDtcbiAgICAgIHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBmb3IgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDsgbnVsbCAhPT0gcmV2ZWFsT3JkZXI7ICkge1xuICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5zaWJsaW5nO1xuICAgICAgICByZXZlYWxPcmRlci5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgIHJldmVhbE9yZGVyID0gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICEwLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGFpbE1vZGVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgITEsIG51bGwsIG51bGwsIHZvaWQgMCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgbnVsbCAhPT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gd29ya0luUHJvZ3Jlc3MubGFuZXM7XG4gIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAhMVxuICAgICAgICApLFxuICAgICAgICAwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHJldHVybiBudWxsO1xuICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZClcbiAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1MykpO1xuICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcyk7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICBmb3IgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzOyBudWxsICE9PSBjdXJyZW50LnNpYmxpbmc7IClcbiAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyA9XG4gICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbDtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICBpZiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykpIHJldHVybiAhMDtcbiAgY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCAmJiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgPyAhMCA6ICExO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSAzOlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gc3RhdGUpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGRMYW5lcykpXG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGN1cnJlbnQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LnNpYmxpbmcgOiBudWxsO1xuICAgICAgfVxuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTk6XG4gICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgIHN0YXRlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG4gICAgICBzdGF0ZSB8fFxuICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAhMVxuICAgICAgICApLFxuICAgICAgICAoc3RhdGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkpO1xuICAgICAgaWYgKGRpZFN1c3BlbmRCZWZvcmUpIHtcbiAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgIH1cbiAgICAgIGRpZFN1c3BlbmRCZWZvcmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZEJlZm9yZSAmJlxuICAgICAgICAoKGRpZFN1c3BlbmRCZWZvcmUucmVuZGVyaW5nID0gbnVsbCksXG4gICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLnRhaWwgPSBudWxsKSxcbiAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUubGFzdEVmZmVjdCA9IG51bGwpKTtcbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgIGlmIChzdGF0ZSkgYnJlYWs7XG4gICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgIGNhc2UgMjI6XG4gICAgY2FzZSAyMzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDApLFxuICAgICAgICB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgKTtcbiAgICBjYXNlIDI0OlxuICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbn1cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnQpXG4gICAgaWYgKGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKVxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKFxuICAgICAgICAhY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpICYmXG4gICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSA/ICEwIDogITE7XG4gICAgfVxuICBlbHNlXG4gICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMDQ4NTc2KSAmJlxuICAgICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0cmVlRm9ya0NvdW50LCB3b3JrSW5Qcm9ncmVzcy5pbmRleCk7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIDE2OlxuICAgICAgYToge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlLFxuICAgICAgICAgIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICBsYXp5Q29tcG9uZW50ID0gaW5pdChsYXp5Q29tcG9uZW50Ll9wYXlsb2FkKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGxhenlDb21wb25lbnQ7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsYXp5Q29tcG9uZW50KVxuICAgICAgICAgIHNob3VsZENvbnN0cnVjdChsYXp5Q29tcG9uZW50KVxuICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhsYXp5Q29tcG9uZW50LCBjdXJyZW50KSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gbGF6eUNvbXBvbmVudCAmJiBudWxsICE9PSBsYXp5Q29tcG9uZW50KVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGluaXQgPSBsYXp5Q29tcG9uZW50LiQkdHlwZW9mKSwgaW5pdCA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluaXQgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGxhenlDb21wb25lbnQpIHx8IGxhenlDb21wb25lbnQ7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMDYsIHdvcmtJblByb2dyZXNzLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgIChpbml0ID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgKSksXG4gICAgICAgIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICBpbml0LFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgY2FzZSAzOlxuICAgICAgYToge1xuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzODcpKTtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgaW5pdCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGxhenlDb21wb25lbnQgPSBpbml0LmVsZW1lbnQ7XG4gICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgbmV4dFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzICE9PSBpbml0LmNhY2hlICYmXG4gICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgIGlmIChpbml0LmlzRGVoeWRyYXRlZClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGluaXQgPSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgaXNEZWh5ZHJhdGVkOiAhMSxcbiAgICAgICAgICAgICAgY2FjaGU6IG5leHRTdGF0ZS5jYWNoZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gaW5pdCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluaXQpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0UHJvcHMgIT09IGxhenlDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MjQpKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGxhenlDb21wb25lbnQpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGlzSHlkcmF0aW5nID0gITAsXG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITAsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcy5mbGFncyA9IChyZW5kZXJMYW5lcy5mbGFncyAmIC0zKSB8IDQwOTYpLFxuICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbGF6eUNvbXBvbmVudCkge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICBjYXNlIDI2OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/IChyZW5kZXJMYW5lcyA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcmVuZGVyTGFuZXMpXG4gICAgICAgICAgICA6IGlzSHlkcmF0aW5nIHx8XG4gICAgICAgICAgICAgICgocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAobGF6eUNvbXBvbmVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICkuY3JlYXRlRWxlbWVudChyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAobGF6eUNvbXBvbmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKGxhenlDb21wb25lbnRbaW50ZXJuYWxQcm9wc0tleV0gPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMobGF6eUNvbXBvbmVudCwgcmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGxhenlDb21wb25lbnQpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbGF6eUNvbXBvbmVudCkpXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI3OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgKChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID1cbiAgICAgICAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCksXG4gICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQuZmlyc3RDaGlsZFxuICAgICAgICAgICkpKSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50IHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgPyByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgNTpcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50ICYmIGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICgoaW5pdCA9IGxhenlDb21wb25lbnQgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSlcbiAgICAgICAgICAobGF6eUNvbXBvbmVudCA9IGNhbkh5ZHJhdGVJbnN0YW5jZShcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbGF6eUNvbXBvbmVudFxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbGF6eUNvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICAoaW5pdCA9ICEwKSlcbiAgICAgICAgICAgICAgOiAoaW5pdCA9ICExKTtcbiAgICAgICAgaW5pdCB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgbmV4dFN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG4gICAgICBsYXp5Q29tcG9uZW50ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQoaW5pdCwgbmV4dFByb3BzKVxuICAgICAgICA/IChsYXp5Q29tcG9uZW50ID0gbnVsbClcbiAgICAgICAgOiBudWxsICE9PSBuZXh0U3RhdGUgJiZcbiAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChpbml0LCBuZXh0U3RhdGUpICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDMyKTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChpbml0ID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSksXG4gICAgICAgIChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGluaXQpKTtcbiAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhenlDb21wb25lbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBjYXNlIDY6XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCAmJiBpc0h5ZHJhdGluZykge1xuICAgICAgICBpZiAoKGN1cnJlbnQgPSByZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpKVxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgPSAhMCkpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnQgPSAhMSk7XG4gICAgICAgIGN1cnJlbnQgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgMTM6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICApLFxuICAgICAgICAobGF6eUNvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDExOlxuICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgMTI6XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIGxhenlDb21wb25lbnQudmFsdWUpLFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGxhenlDb21wb25lbnQuY2hpbGRyZW4sXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICk7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGluaXQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0KSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChpbml0ID0gcmVhZENvbnRleHQoaW5pdCkpLFxuICAgICAgICAobGF6eUNvbXBvbmVudCA9IGxhenlDb21wb25lbnQoaW5pdCkpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMSksXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYXp5Q29tcG9uZW50LCByZW5kZXJMYW5lcyksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgMTQ6XG4gICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgY2FzZSAxNTpcbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICBjYXNlIDE5OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIGNhc2UgMjI6XG4gICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgY2FzZSAyNDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgID8gKChpbml0ID0gcGVla0NhY2hlRnJvbVBvb2woKSksXG4gICAgICAgICAgICBudWxsID09PSBpbml0ICYmXG4gICAgICAgICAgICAgICgoaW5pdCA9IHdvcmtJblByb2dyZXNzUm9vdCksXG4gICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKGluaXQucG9vbGVkQ2FjaGUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMucmVmQ291bnQrKyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmIChpbml0LnBvb2xlZENhY2hlTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAoaW5pdCA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgY2FjaGU6IGluaXRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBpbml0KSlcbiAgICAgICAgICA6ICgwICE9PSAoY3VycmVudC5sYW5lcyAmIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgICAoY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkpLFxuICAgICAgICAgICAgKGluaXQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgaW5pdC5wYXJlbnQgIT09IGxhenlDb21wb25lbnRcbiAgICAgICAgICAgICAgPyAoKGluaXQgPSB7IHBhcmVudDogbGF6eUNvbXBvbmVudCwgY2FjaGU6IGxhenlDb21wb25lbnQgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbml0KSxcbiAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgIGluaXQpLFxuICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBsYXp5Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgOiAoKGxhenlDb21wb25lbnQgPSBuZXh0UHJvcHMuY2FjaGUpLFxuICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBsYXp5Q29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50ICE9PSBpbml0LmNhY2hlICYmXG4gICAgICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICkpKSxcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICk7XG4gICAgY2FzZSAyOTpcbiAgICAgIHRocm93IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgfVxuICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1Niwgd29ya0luUHJvZ3Jlc3MudGFnKSk7XG59XG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbCxcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlKTtcbiAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCkge1xuICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICBwb3AodmFsdWVDdXJzb3IpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgKHBhcmVudC5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lc1xuICAgICAgPyAoKHBhcmVudC5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcykpXG4gICAgICA6IG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgaWYgKHBhcmVudCA9PT0gcHJvcGFnYXRpb25Sb290KSBicmVhaztcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGNvbnRleHRzLFxuICByZW5kZXJMYW5lcyxcbiAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4pIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gIGZvciAoOyBudWxsICE9PSBmaWJlcjsgKSB7XG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKG51bGwgIT09IGxpc3QpIHtcbiAgICAgIHZhciBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIGxpc3QgPSBsaXN0LmZpcnN0Q29udGV4dDtcbiAgICAgIGE6IGZvciAoOyBudWxsICE9PSBsaXN0OyApIHtcbiAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gZmliZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dHNbaV0pIHtcbiAgICAgICAgICAgIGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICBkZXBlbmRlbmN5ID0gbGlzdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBudWxsICE9PSBkZXBlbmRlbmN5ICYmIChkZXBlbmRlbmN5LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICAgIGxpc3QucmV0dXJuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUgfHwgKG5leHRGaWJlciA9IG51bGwpO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgIGxpc3QgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgxOCA9PT0gZmliZXIudGFnKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICBpZiAobnVsbCA9PT0gbmV4dEZpYmVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0MSkpO1xuICAgICAgbmV4dEZpYmVyLmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgbGlzdCA9IG5leHRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBsaXN0ICYmIChsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgobmV4dEZpYmVyLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICB9IGVsc2UgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgaWYgKG51bGwgIT09IG5leHRGaWJlcikgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIGVsc2VcbiAgICAgIGZvciAobmV4dEZpYmVyID0gZmliZXI7IG51bGwgIT09IG5leHRGaWJlcjsgKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWJlciA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgICBmaWJlci5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgcmVuZGVyTGFuZXMsXG4gIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuKSB7XG4gIGN1cnJlbnQgPSBudWxsO1xuICBmb3IgKFxuICAgIHZhciBwYXJlbnQgPSB3b3JrSW5Qcm9ncmVzcywgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMTtcbiAgICBudWxsICE9PSBwYXJlbnQ7XG5cbiAgKSB7XG4gICAgaWYgKCFpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dClcbiAgICAgIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgNTI0Mjg4KSkgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMDtcbiAgICAgIGVsc2UgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiAyNjIxNDQpKSBicmVhaztcbiAgICBpZiAoMTAgPT09IHBhcmVudC50YWcpIHtcbiAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM4NykpO1xuICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50LnR5cGU7XG4gICAgICAgIG9iamVjdElzKHBhcmVudC5wZW5kaW5nUHJvcHMudmFsdWUsIGN1cnJlbnRQYXJlbnQudmFsdWUpIHx8XG4gICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LnB1c2goY29udGV4dCkgOiAoY3VycmVudCA9IFtjb250ZXh0XSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyZW50ID09PSBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzg3KSk7XG4gICAgICBjdXJyZW50UGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAhPT1cbiAgICAgICAgcGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgID8gY3VycmVudC5wdXNoKEhvc3RUcmFuc2l0aW9uQ29udGV4dClcbiAgICAgICAgICA6IChjdXJyZW50ID0gW0hvc3RUcmFuc2l0aW9uQ29udGV4dF0pKTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN1cnJlbnQsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI2MjE0NDtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50RGVwZW5kZW5jaWVzKSB7XG4gIGZvciAoXG4gICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuICAgIG51bGwgIT09IGN1cnJlbnREZXBlbmRlbmNpZXM7XG5cbiAgKSB7XG4gICAgaWYgKFxuICAgICAgIW9iamVjdElzKFxuICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQuX2N1cnJlbnRWYWx1ZSxcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcy5tZW1vaXplZFZhbHVlXG4gICAgICApXG4gICAgKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLm5leHQ7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG4gIG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICh3b3JrSW5Qcm9ncmVzcy5maXJzdENvbnRleHQgPSBudWxsKTtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihjb25zdW1lciwgY29udGV4dCkge1xuICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAmJiBwcmVwYXJlVG9SZWFkQ29udGV4dChjb25zdW1lcik7XG4gIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICBjb250ZXh0ID0geyBjb250ZXh0OiBjb250ZXh0LCBtZW1vaXplZFZhbHVlOiB2YWx1ZSwgbmV4dDogbnVsbCB9O1xuICBpZiAobnVsbCA9PT0gbGFzdENvbnRleHREZXBlbmRlbmN5KSB7XG4gICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwOCkpO1xuICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgY29uc3VtZXIuZGVwZW5kZW5jaWVzID0geyBsYW5lczogMCwgZmlyc3RDb250ZXh0OiBjb250ZXh0IH07XG4gICAgY29uc3VtZXIuZmxhZ3MgfD0gNTI0Mjg4O1xuICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICByZXR1cm4gdmFsdWU7XG59XG52YXIgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDogeyBwZW5kaW5nOiBudWxsLCBsYW5lczogMCwgaGlkZGVuQ2FsbGJhY2tzOiBudWxsIH0sXG4gICAgY2FsbGJhY2tzOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9PT0gY3VycmVudCAmJlxuICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUsXG4gICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICByZXR1cm4geyBsYW5lOiBsYW5lLCB0YWc6IDAsIHBheWxvYWQ6IG51bGwsIGNhbGxiYWNrOiBudWxsLCBuZXh0OiBudWxsIH07XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChudWxsID09PSB1cGRhdGVRdWV1ZSkgcmV0dXJuIG51bGw7XG4gIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiAyKSkge1xuICAgIHZhciBwZW5kaW5nID0gdXBkYXRlUXVldWUucGVuZGluZztcbiAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICB1cGRhdGVRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIHVwZGF0ZSA9IGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBudWxsLCBsYW5lKTtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgdXBkYXRlUXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgZmliZXIgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKG51bGwgIT09IGZpYmVyICYmICgoZmliZXIgPSBmaWJlci5zaGFyZWQpLCAwICE9PSAobGFuZSAmIDQxOTQxNzYpKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gZmliZXIubGFuZXM7XG4gICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgZmliZXIubGFuZXMgPSBsYW5lO1xuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLFxuICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gIGlmIChcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksIHF1ZXVlID09PSBjdXJyZW50KVxuICApIHtcbiAgICB2YXIgbmV3Rmlyc3QgPSBudWxsLFxuICAgICAgbmV3TGFzdCA9IG51bGw7XG4gICAgcXVldWUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gICAgaWYgKG51bGwgIT09IHF1ZXVlKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiBxdWV1ZS5sYW5lLFxuICAgICAgICAgIHRhZzogcXVldWUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHF1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBudWxsID09PSBuZXdMYXN0XG4gICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmUpXG4gICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNsb25lKTtcbiAgICAgICAgcXVldWUgPSBxdWV1ZS5uZXh0O1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gcXVldWUpO1xuICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICB9IGVsc2UgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgcXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgIGNhbGxiYWNrczogY3VycmVudC5jYWxsYmFja3NcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdvcmtJblByb2dyZXNzID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgPyAocXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgOiAod29ya0luUHJvZ3Jlc3MubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cbnZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG5mdW5jdGlvbiBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkge1xuICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICBpZiAobnVsbCAhPT0gZW50YW5nbGVkQWN0aW9uVGhlbmFibGUpIHRocm93IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIHdvcmtJblByb2dyZXNzJGpzY29tcCQwLFxuICBwcm9wcyxcbiAgaW5zdGFuY2UkanNjb21wJDAsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMC51cGRhdGVRdWV1ZTtcbiAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSxcbiAgICBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuICBpZiAobnVsbCAhPT0gcGVuZGluZ1F1ZXVlKSB7XG4gICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZSxcbiAgICAgIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7XG4gICAgbnVsbCA9PT0gbGFzdEJhc2VVcGRhdGVcbiAgICAgID8gKGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgIDogKGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpO1xuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMC5hbHRlcm5hdGU7XG4gICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAocGVuZGluZ1F1ZXVlID0gY3VycmVudC5sYXN0QmFzZVVwZGF0ZSksXG4gICAgICBwZW5kaW5nUXVldWUgIT09IGxhc3RCYXNlVXBkYXRlICYmXG4gICAgICAgIChudWxsID09PSBwZW5kaW5nUXVldWVcbiAgICAgICAgICA/IChjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgICAgICA6IChwZW5kaW5nUXVldWUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSksXG4gICAgICAgIChjdXJyZW50Lmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUpKSk7XG4gIH1cbiAgaWYgKG51bGwgIT09IGZpcnN0QmFzZVVwZGF0ZSkge1xuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgICBsYXN0QmFzZVVwZGF0ZSA9IDA7XG4gICAgY3VycmVudCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICBwZW5kaW5nUXVldWUgPSBmaXJzdEJhc2VVcGRhdGU7XG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUubGFuZSAmIC01MzY4NzA5MTMsXG4gICAgICAgIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gcGVuZGluZ1F1ZXVlLmxhbmU7XG4gICAgICBpZiAoXG4gICAgICAgIGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICkge1xuICAgICAgICAwICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5uZXh0ID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBhOiB7XG4gICAgICAgICAgdmFyIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MkanNjb21wJDAsXG4gICAgICAgICAgICB1cGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgICAgdXBkYXRlTGFuZSA9IHByb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlJGpzY29tcCQwO1xuICAgICAgICAgIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTY1NTM3KSB8IDEyODtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3MuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIHVwZGF0ZUxhbmUpXG4gICAgICAgICAgICAgICAgICA6IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdXBkYXRlTGFuZSB8fCB2b2lkIDAgPT09IHVwZGF0ZUxhbmUpIGJyZWFrIGE7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gYXNzaWduKHt9LCBuZXdTdGF0ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUuY2FsbGJhY2s7XG4gICAgICAgIG51bGwgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAoKHdvcmtJblByb2dyZXNzJGpzY29tcCQwLmZsYWdzIHw9IDY0KSxcbiAgICAgICAgICBpc0hpZGRlblVwZGF0ZSAmJiAod29ya0luUHJvZ3Jlc3MkanNjb21wJDAuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcXVldWUuY2FsbGJhY2tzKSxcbiAgICAgICAgICBudWxsID09PSBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgPyAocXVldWUuY2FsbGJhY2tzID0gW3VwZGF0ZUxhbmVdKVxuICAgICAgICAgICAgOiBpc0hpZGRlblVwZGF0ZS5wdXNoKHVwZGF0ZUxhbmUpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHBlbmRpbmdRdWV1ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgID8gKChmaXJzdFBlbmRpbmdVcGRhdGUgPSBjdXJyZW50ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSkpXG4gICAgICAgICAgICA6IChjdXJyZW50ID0gY3VycmVudC5uZXh0ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgIChsYXN0QmFzZVVwZGF0ZSB8PSB1cGRhdGVMYW5lKTtcbiAgICAgIHBlbmRpbmdRdWV1ZSA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgaWYgKG51bGwgPT09IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgaWYgKCgocGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmcpLCBudWxsID09PSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcGVuZGluZ1F1ZXVlKSxcbiAgICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBpc0hpZGRlblVwZGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZS5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICAocXVldWUubGFzdEJhc2VVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAocXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsKTtcbiAgICB9IHdoaWxlICgxKTtcbiAgICBudWxsID09PSBjdXJyZW50ICYmIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50O1xuICAgIG51bGwgPT09IGZpcnN0QmFzZVVwZGF0ZSAmJiAocXVldWUuc2hhcmVkLmxhbmVzID0gMCk7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGxhc3RCYXNlVXBkYXRlO1xuICAgIHdvcmtJblByb2dyZXNzJGpzY29tcCQwLmxhbmVzID0gbGFzdEJhc2VVcGRhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG59XG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkxLCBjYWxsYmFjaykpO1xuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG4gIGlmIChudWxsICE9PSBjYWxsYmFja3MpXG4gICAgZm9yIChcbiAgICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgIHVwZGF0ZVF1ZXVlIDwgY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICApXG4gICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2tzW3VwZGF0ZVF1ZXVlXSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmspIHtcbiAgdHJ5IHtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgICAgbGFzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgY3JlYXRlID0gdXBkYXRlUXVldWUuY3JlYXRlLFxuICAgICAgICAgICAgaW5zdCA9IHVwZGF0ZVF1ZXVlLmluc3Q7XG4gICAgICAgICAgbGFzdEVmZmVjdCA9IGNyZWF0ZSgpO1xuICAgICAgICAgIGluc3QuZGVzdHJveSA9IGxhc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgZmxhZ3MsXG4gIGZpbmlzaGVkV29yayxcbiAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciRqc2NvbXAkMFxuKSB7XG4gIHRyeSB7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAgIHZhciBpbnN0ID0gdXBkYXRlUXVldWUuaW5zdCxcbiAgICAgICAgICAgIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZGVzdHJveSkge1xuICAgICAgICAgICAgaW5zdC5kZXN0cm95ID0gdm9pZCAwO1xuICAgICAgICAgICAgbGFzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICAgIHZhciBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvciRqc2NvbXAkMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgIGxhc3RFZmZlY3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgaWYgKG51bGwgIT09IHVwZGF0ZVF1ZXVlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB0cnkge1xuICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICBjdXJyZW50LFxuICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICBpbnN0YW5jZVxuKSB7XG4gIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgY3VycmVudC50eXBlLFxuICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICApO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgdHJ5IHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKG51bGwgIT09IHJlZikge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB2YXIgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZlxuICAgICAgICA/IChjdXJyZW50LnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSkpXG4gICAgICAgIDogKHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQucmVmLFxuICAgIHJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gIGlmIChudWxsICE9PSByZWYpXG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXApXG4gICAgICB0cnkge1xuICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCksXG4gICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKTtcbiAgICAgIH1cbiAgICBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICB0cnkge1xuICAgICAgICByZWYobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvciQxMTIpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkMTEyKTtcbiAgICAgIH1cbiAgICBlbHNlIHJlZi5jdXJyZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgdHJ5IHtcbiAgICBhOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIHByb3BzLmF1dG9Gb2N1cyAmJiBpbnN0YW5jZS5mb2N1cygpO1xuICAgICAgICBicmVhayBhO1xuICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICBwcm9wcy5zcmNcbiAgICAgICAgICA/IChpbnN0YW5jZS5zcmMgPSBwcm9wcy5zcmMpXG4gICAgICAgICAgOiBwcm9wcy5zcmNTZXQgJiYgKGluc3RhbmNlLnNyY3NldCA9IHByb3BzLnNyY1NldCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRIb3N0VXBkYXRlKGZpbmlzaGVkV29yaywgbmV3UHJvcHMsIG9sZFByb3BzKSB7XG4gIHRyeSB7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgZmluaXNoZWRXb3JrLnR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgZG9tRWxlbWVudFtpbnRlcm5hbFByb3BzS2V5XSA9IG5ld1Byb3BzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIChcbiAgICA1ID09PSBmaWJlci50YWcgfHxcbiAgICAzID09PSBmaWJlci50YWcgfHxcbiAgICAyNiA9PT0gZmliZXIudGFnIHx8XG4gICAgMjcgPT09IGZpYmVyLnRhZyB8fFxuICAgIDQgPT09IGZpYmVyLnRhZ1xuICApO1xufVxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgYTogZm9yICg7Oykge1xuICAgIGZvciAoOyBudWxsID09PSBmaWJlci5zaWJsaW5nOyApIHtcbiAgICAgIGlmIChudWxsID09PSBmaWJlci5yZXR1cm4gfHwgaXNIb3N0UGFyZW50KGZpYmVyLnJldHVybikpIHJldHVybiBudWxsO1xuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLnNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgIGZvciAoXG4gICAgICBmaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgICA1ICE9PSBmaWJlci50YWcgJiZcbiAgICAgIDYgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgMjcgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgMTggIT09IGZpYmVyLnRhZztcblxuICAgICkge1xuICAgICAgaWYgKGZpYmVyLmZsYWdzICYgMikgY29udGludWUgYTtcbiAgICAgIGlmIChudWxsID09PSBmaWJlci5jaGlsZCB8fCA0ID09PSBmaWJlci50YWcpIGNvbnRpbnVlIGE7XG4gICAgICBlbHNlIChmaWJlci5jaGlsZC5yZXR1cm4gPSBmaWJlciksIChmaWJlciA9IGZpYmVyLmNoaWxkKTtcbiAgICB9XG4gICAgaWYgKCEoZmliZXIuZmxhZ3MgJiAyKSkgcmV0dXJuIGZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgYmVmb3JlXG4gICAgICAgID8gOCA9PT0gcGFyZW50Lm5vZGVUeXBlXG4gICAgICAgICAgPyBwYXJlbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgYmVmb3JlKVxuICAgICAgICAgIDogcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBiZWZvcmUpXG4gICAgICAgIDogKDggPT09IHBhcmVudC5ub2RlVHlwZVxuICAgICAgICAgICAgPyAoKGJlZm9yZSA9IHBhcmVudC5wYXJlbnROb2RlKSwgYmVmb3JlLmluc2VydEJlZm9yZShub2RlLCBwYXJlbnQpKVxuICAgICAgICAgICAgOiAoKGJlZm9yZSA9IHBhcmVudCksIGJlZm9yZS5hcHBlbmRDaGlsZChub2RlKSksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5fcmVhY3RSb290Q29udGFpbmVyKSxcbiAgICAgICAgICAobnVsbCAhPT0gcGFyZW50ICYmIHZvaWQgMCAhPT0gcGFyZW50KSB8fFxuICAgICAgICAgICAgbnVsbCAhPT0gYmVmb3JlLm9uY2xpY2sgfHxcbiAgICAgICAgICAgIChiZWZvcmUub25jbGljayA9IG5vb3AkMSkpO1xuICBlbHNlIGlmICg0ICE9PSB0YWcgJiYgMjcgIT09IHRhZyAmJiAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSkpXG4gICAgZm9yIChcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgIClcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG59XG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgIGJlZm9yZSA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgYmVmb3JlKSA6IHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgZWxzZSBpZiAoNCAhPT0gdGFnICYmIDI3ICE9PSB0YWcgJiYgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpKVxuICAgIGZvciAoXG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpLCBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgIClcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbn1cbnZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSAhMSxcbiAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9ICExLFxuICBuZWVkc0Zvcm1SZXNldCA9ICExLFxuICBQb3NzaWJseVdlYWtTZXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrU2V0ID8gV2Vha1NldCA6IFNldCxcbiAgbmV4dEVmZmVjdCA9IG51bGwsXG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExO1xuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgcm9vdCA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgZXZlbnRzRW5hYmxlZCA9IF9lbmFibGVkO1xuICByb290ID0gZ2V0QWN0aXZlRWxlbWVudERlZXAocm9vdCk7XG4gIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocm9vdCkpIHtcbiAgICBpZiAoXCJzZWxlY3Rpb25TdGFydFwiIGluIHJvb3QpXG4gICAgICB2YXIgSlNDb21waWxlcl90ZW1wID0ge1xuICAgICAgICBzdGFydDogcm9vdC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiByb290LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICBlbHNlXG4gICAgICBhOiB7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAgPSByb290Lm93bmVyRG9jdW1lbnQpICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuZGVmYXVsdFZpZXcpIHx8XG4gICAgICAgICAgd2luZG93O1xuICAgICAgICB2YXIgc2VsZWN0aW9uID1cbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuZ2V0U2VsZWN0aW9uICYmIEpTQ29tcGlsZXJfdGVtcC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiAwICE9PSBzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgICAgIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcC5ub2RlVHlwZSwgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUkMjApIHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gMCxcbiAgICAgICAgICAgIHN0YXJ0ID0gLTEsXG4gICAgICAgICAgICBlbmQgPSAtMSxcbiAgICAgICAgICAgIGluZGV4V2l0aGluQW5jaG9yID0gMCxcbiAgICAgICAgICAgIGluZGV4V2l0aGluRm9jdXMgPSAwLFxuICAgICAgICAgICAgbm9kZSA9IHJvb3QsXG4gICAgICAgICAgICBwYXJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgICBiOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuZXh0OyA7ICkge1xuICAgICAgICAgICAgICBub2RlICE9PSBKU0NvbXBpbGVyX3RlbXAgfHxcbiAgICAgICAgICAgICAgICAoMCAhPT0gYW5jaG9yT2Zmc2V0ICYmIDMgIT09IG5vZGUubm9kZVR5cGUpIHx8XG4gICAgICAgICAgICAgICAgKHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgbm9kZSAhPT0gZm9jdXNOb2RlIHx8XG4gICAgICAgICAgICAgICAgKDAgIT09IHNlbGVjdGlvbiAmJiAzICE9PSBub2RlLm5vZGVUeXBlKSB8fFxuICAgICAgICAgICAgICAgIChlbmQgPSBsZW5ndGggKyBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAzID09PSBub2RlLm5vZGVUeXBlICYmIChsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSkgYnJlYWs7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIGJyZWFrIGI7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPT09IEpTQ29tcGlsZXJfdGVtcCAmJlxuICAgICAgICAgICAgICAgICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgICAgIChzdGFydCA9IGxlbmd0aCk7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gc2VsZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgKGVuZCA9IGxlbmd0aCk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSAobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpKSBicmVhaztcbiAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgIC0xID09PSBzdGFydCB8fCAtMSA9PT0gZW5kID8gbnVsbCA6IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgICAgICB9IGVsc2UgSlNDb21waWxlcl90ZW1wID0gbnVsbDtcbiAgICAgIH1cbiAgICBKU0NvbXBpbGVyX3RlbXAgPSBKU0NvbXBpbGVyX3RlbXAgfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0gZWxzZSBKU0NvbXBpbGVyX3RlbXAgPSBudWxsO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IHsgZm9jdXNlZEVsZW06IHJvb3QsIHNlbGVjdGlvblJhbmdlOiBKU0NvbXBpbGVyX3RlbXAgfTtcbiAgX2VuYWJsZWQgPSAhMTtcbiAgZm9yIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKVxuICAgIGlmIChcbiAgICAgICgoZmlyc3RDaGlsZCA9IG5leHRFZmZlY3QpLFxuICAgICAgKHJvb3QgPSBmaXJzdENoaWxkLmNoaWxkKSxcbiAgICAgIDAgIT09IChmaXJzdENoaWxkLnN1YnRyZWVGbGFncyAmIDEwMjgpICYmIG51bGwgIT09IHJvb3QpXG4gICAgKVxuICAgICAgKHJvb3QucmV0dXJuID0gZmlyc3RDaGlsZCksIChuZXh0RWZmZWN0ID0gcm9vdCk7XG4gICAgZWxzZVxuICAgICAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICBmaXJzdENoaWxkID0gbmV4dEVmZmVjdDtcbiAgICAgICAgZm9jdXNOb2RlID0gZmlyc3RDaGlsZC5hbHRlcm5hdGU7XG4gICAgICAgIHJvb3QgPSBmaXJzdENoaWxkLmZsYWdzO1xuICAgICAgICBzd2l0Y2ggKGZpcnN0Q2hpbGQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKDAgIT09IChyb290ICYgMTAyNCkgJiYgbnVsbCAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGZvY3VzTm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmb2N1c05vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uID0gSlNDb21waWxlcl90ZW1wLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWRQcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcC50eXBlLFxuICAgICAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLmVsZW1lbnRUeXBlID09PSBKU0NvbXBpbGVyX3RlbXAudHlwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHNlbGVjdGlvbi5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgZm9jdXNOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSByb290O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKDAgIT09IChyb290ICYgMTAyNCkpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHJvb3QgPSBmaXJzdENoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gcm9vdC5ub2RlVHlwZSksXG4gICAgICAgICAgICAgICAgOSA9PT0gSlNDb21waWxlcl90ZW1wKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkocm9vdCk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKDEgPT09IEpTQ29tcGlsZXJfdGVtcClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJvb3Qubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiSFRNTFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkJPRFlcIjpcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkocm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcm9vdC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKDAgIT09IChyb290ICYgMTAyNCkpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgaWYgKG51bGwgIT09IHJvb3QpIHtcbiAgICAgICAgICByb290LnJldHVybiA9IGZpcnN0Q2hpbGQucmV0dXJuO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSByb290O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkLnJldHVybjtcbiAgICAgIH1cbiAgcmVzb2x2ZWRQcmV2UHJvcHMgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExO1xuICByZXR1cm4gcmVzb2x2ZWRQcmV2UHJvcHM7XG59XG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNCAmJiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KDUsIGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICBpZiAoKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSwgbnVsbCA9PT0gY3VycmVudCkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuY29tcG9uZW50RGlkVXBkYXRlKFxuICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvciQxMTEpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIGVycm9yJDExMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGZsYWdzICYgNjQgJiYgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgaWYgKGZsYWdzICYgNjQgJiYgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKSkge1xuICAgICAgICBmaW5pc2hlZFJvb3QgPSBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gZmluaXNoZWRXb3JrLmNoaWxkKVxuICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhmbGFncywgZmluaXNoZWRSb290KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBudWxsID09PSBjdXJyZW50ICYmIGZsYWdzICYgNCAmJiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDQgJiYgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIHByZXZQcm9wcyA9XG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbixcbiAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZQcm9wcztcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBjdXJyZW50KSAmJiAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW5cbiAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgIH1cbiAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgIChcIm1hbnVhbFwiID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlXG4gICAgICAgICAgPyBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKVxuICAgICAgICAgIDogc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgKChmaWJlci5hbHRlcm5hdGUgPSBudWxsKSwgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKSk7XG4gIGZpYmVyLmNoaWxkID0gbnVsbDtcbiAgZmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgZmliZXIuc2libGluZyA9IG51bGw7XG4gIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICgoYWx0ZXJuYXRlID0gZmliZXIuc3RhdGVOb2RlKSxcbiAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGFsdGVybmF0ZSkpO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICBmaWJlci5yZXR1cm4gPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbn1cbnZhciBob3N0UGFyZW50ID0gbnVsbCxcbiAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICBmaW5pc2hlZFJvb3QsXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gIHBhcmVudFxuKSB7XG4gIGZvciAocGFyZW50ID0gcGFyZW50LmNoaWxkOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgcGFyZW50KSxcbiAgICAgIChwYXJlbnQgPSBwYXJlbnQuc2libGluZyk7XG59XG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICBmaW5pc2hlZFJvb3QsXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gIGRlbGV0ZWRGaWJlclxuKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KVxuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZGVsZXRlZEZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgIGNhc2UgMjY6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICA/IGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlLmNvdW50LS1cbiAgICAgICAgOiBkZWxldGVkRmliZXIuc3RhdGVOb2RlICYmXG4gICAgICAgICAgKChkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICBkZWxldGVkRmliZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkZWxldGVkRmliZXIpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjc6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgZm9yIChcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IGRlbGV0ZWRGaWJlci5hdHRyaWJ1dGVzO1xuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLmxlbmd0aDtcblxuICAgICAgKVxuICAgICAgICBkZWxldGVkRmliZXIucmVtb3ZlQXR0cmlidXRlTm9kZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yWzBdKTtcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZShkZWxldGVkRmliZXIpO1xuICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgY2FzZSA2OlxuICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnQ7XG4gICAgICB2YXIgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciQxMTkgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyJDExOTtcbiAgICAgIGlmIChudWxsICE9PSBob3N0UGFyZW50KVxuICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAoZmluaXNoZWRSb290ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICA4ID09PSBmaW5pc2hlZFJvb3Qubm9kZVR5cGVcbiAgICAgICAgICAgICAgICA/IGZpbmlzaGVkUm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZIb3N0UGFyZW50KVxuICAgICAgICAgICAgICAgIDogZmluaXNoZWRSb290LnJlbW92ZUNoaWxkKHByZXZIb3N0UGFyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQucmVtb3ZlQ2hpbGQoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTg6XG4gICAgICBudWxsICE9PSBob3N0UGFyZW50ICYmXG4gICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICA/ICgobmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgKGRlbGV0ZWRGaWJlciA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgOCA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5ub2RlVHlwZVxuICAgICAgICAgICAgICA/IGNsZWFyU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLm5vZGVUeXBlICYmXG4gICAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlciksXG4gICAgICAgICAgICByZXRyeUlmQmxvY2tlZE9uKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpKVxuICAgICAgICAgIDogY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgKTtcbiAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE0OlxuICAgIGNhc2UgMTU6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCgyLCBkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoNCwgZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAoc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciksXG4gICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2SG9zdFBhcmVudC5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBwcmV2SG9zdFBhcmVudFxuICAgICAgICAgICkpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIxOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPVxuICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB8fFxuICAgICAgICBudWxsICE9PSBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoXG4gICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUpLFxuICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QubWVtb2l6ZWRTdGF0ZSksXG4gICAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICApXG4gICAgdHJ5IHtcbiAgICAgIHJldHJ5SWZCbG9ja2VkT24oZmluaXNoZWRSb290KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAxMzpcbiAgICBjYXNlIDE5OlxuICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpO1xuICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgY2FzZSAyMjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUpLFxuICAgICAgICBudWxsID09PSByZXRyeUNhY2hlICYmXG4gICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICByZXRyeUNhY2hlXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzNSwgZmluaXNoZWRXb3JrLnRhZykpO1xuICB9XG59XG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgd2FrZWFibGVzKSB7XG4gIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuICAgIHJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSB8fFxuICAgICAgKHJldHJ5Q2FjaGUuYWRkKHdha2VhYmxlKSwgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QkanNjb21wJDAsIHBhcmVudEZpYmVyKSB7XG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldLFxuICAgICAgICByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgcmV0dXJuRmliZXIgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgcGFyZW50ID0gcmV0dXJuRmliZXI7XG4gICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2MCkpO1xuICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgcm9vdCA9IGNoaWxkVG9EZWxldGUuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiAocm9vdC5yZXR1cm4gPSBudWxsKTtcbiAgICAgIGNoaWxkVG9EZWxldGUucmV0dXJuID0gbnVsbDtcbiAgICB9XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKHBhcmVudEZpYmVyLCByb290JGpzY29tcCQwKSxcbiAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG59XG52YXIgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsO1xuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE0OlxuICAgIGNhc2UgMTU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KDMsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiksXG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoMywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KDUsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICgoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrICYmXG4gICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyksXG4gICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ID8gZmxhZ3MgOiBjdXJyZW50LmNvbmNhdChmbGFncykpKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNjpcbiAgICAgIHZhciBob2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICB2YXIgY3VycmVudFJlc291cmNlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KVxuICAgICAgICAgIGlmIChudWxsID09PSBmbGFncylcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICAgICAgYjogc3dpdGNoIChmbGFncykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgIWN1cnJlbnRSZXNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UubmFtZXNwYWNlVVJJIHx8XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFJlc291cmNlID0gaG9pc3RhYmxlUm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmhlYWQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcImhlYWQgPiB0aXRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoY3VycmVudFJlc291cmNlLCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBmbGFncyA9IGN1cnJlbnRSZXNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZU5vZGVzID0gZ2V0SHlkcmF0YWJsZUhvaXN0YWJsZUNhY2hlKFxuICAgICAgICAgICAgICAgICAgICAgIFwibGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiaHJlZlwiLFxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgKS5nZXQoZmxhZ3MgKyAoY3VycmVudC5ocmVmIHx8IFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlTm9kZXMpXG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGN1cnJlbnRSZXNvdXJjZSA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmhyZWYgPyBudWxsIDogY3VycmVudC5ocmVmKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnJlbCA/IG51bGwgOiBjdXJyZW50LnJlbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwidGl0bGVcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnRpdGxlID8gbnVsbCA6IGN1cnJlbnQudGl0bGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmNyb3NzT3JpZ2luKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlID0gaG9pc3RhYmxlUm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoY3VycmVudFJlc291cmNlLCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuaGVhZC5hcHBlbmRDaGlsZChjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAobWF5YmVOb2RlcyA9IGdldEh5ZHJhdGFibGVIb2lzdGFibGVDYWNoZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWV0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290XG4gICAgICAgICAgICAgICAgICAgICAgKS5nZXQoZmxhZ3MgKyAoY3VycmVudC5jb250ZW50IHx8IFwiXCIpKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGN1cnJlbnRSZXNvdXJjZSA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiICsgY3VycmVudC5jb250ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5uYW1lID8gbnVsbCA6IGN1cnJlbnQubmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwicHJvcGVydHlcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnQucHJvcGVydHkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImh0dHAtZXF1aXZcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50Lmh0dHBFcXVpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50Lmh0dHBFcXVpdikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwiY2hhcnNldFwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQuY2hhclNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmNoYXJTZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgPSBob2lzdGFibGVSb290LmNyZWF0ZUVsZW1lbnQoZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhjdXJyZW50UmVzb3VyY2UsIGZsYWdzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5oZWFkLmFwcGVuZENoaWxkKGN1cnJlbnRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NjgsIGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGN1cnJlbnRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgZmxhZ3MgPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGZsYWdzO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSAhPT0gZmxhZ3NcbiAgICAgICAgICAgID8gKG51bGwgPT09IGN1cnJlbnRSZXNvdXJjZVxuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gY3VycmVudC5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICA6IGN1cnJlbnRSZXNvdXJjZS5jb3VudC0tLFxuICAgICAgICAgICAgICBudWxsID09PSBmbGFnc1xuICAgICAgICAgICAgICAgID8gbW91bnRIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogbnVsbCA9PT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjc6XG4gICAgICBpZiAoZmxhZ3MgJiA0ICYmIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUpIHtcbiAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGUgPSBob2lzdGFibGVSb290LmZpcnN0Q2hpbGQ7IG5vZGU7ICkge1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgbm9kZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0gfHxcbiAgICAgICAgICAgICAgXCJIRUFEXCIgPT09IG5vZGVOYW1lIHx8XG4gICAgICAgICAgICAgIFwiQk9EWVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICBcIlNDUklQVFwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICBcIlNUWUxFXCIgPT09IG5vZGVOYW1lIHx8XG4gICAgICAgICAgICAgIChcIkxJTktcIiA9PT0gbm9kZU5hbWUgJiZcbiAgICAgICAgICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gbm9kZS5yZWwudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGUsIGF0dHJpYnV0ZXMgPSBob2lzdGFibGVSb290LmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmxlbmd0aDtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QucmVtb3ZlQXR0cmlidXRlTm9kZShhdHRyaWJ1dGVzWzBdKTtcbiAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhob2lzdGFibGVSb290LCB0eXBlLCBjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgIGhvaXN0YWJsZVJvb3RbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdFtpbnRlcm5hbFByb3BzS2V5XSA9IGN1cnJlbnRSZXNvdXJjZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgMzIpIHtcbiAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoaG9pc3RhYmxlUm9vdCwgXCJcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICBudWxsICE9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgKChob2lzdGFibGVSb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBob2lzdGFibGVSb290XG4gICAgICAgICkpO1xuICAgICAgZmxhZ3MgJiAxMDI0ICYmIChuZWVkc0Zvcm1SZXNldCA9ICEwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2MikpO1xuICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjdXJyZW50Lm5vZGVWYWx1ZSA9IGZsYWdzO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICB0YWdDYWNoZXMgPSBudWxsO1xuICAgICAgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGhvaXN0YWJsZVJvb3Q7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGlmIChmbGFncyAmIDQgJiYgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHJ5SWZCbG9ja2VkT24ocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgbmVlZHNGb3JtUmVzZXQgJiZcbiAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICExKSwgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yaykpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZmxhZ3MgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChcbiAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICApO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGZsYWdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAobnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpICE9PVxuICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKSk7XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICBub2RlID0gbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICBuZXh0Tm9kZSA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgbm9kZU5hbWUgPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICB0eXBlID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG5vZGVOYW1lIHx8IG5vZGU7XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gdHlwZSB8fCBuZXh0Tm9kZTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB0eXBlO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gbm9kZU5hbWU7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgcm9vdC5fY3VycmVudCA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuX3Zpc2liaWxpdHkgJj0gLTM7XG4gICAgICByb290Ll92aXNpYmlsaXR5IHw9IHJvb3QuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMjtcbiAgICAgIGlmIChcbiAgICAgICAgZmxhZ3MgJiA4MTkyICYmXG4gICAgICAgICgocm9vdC5fdmlzaWJpbGl0eSA9IG5vZGVcbiAgICAgICAgICA/IHJvb3QuX3Zpc2liaWxpdHkgJiAtMlxuICAgICAgICAgIDogcm9vdC5fdmlzaWJpbGl0eSB8IDEpLFxuICAgICAgICBub2RlICYmXG4gICAgICAgICAgKChyb290ID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pLFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgIG5leHROb2RlIHx8XG4gICAgICAgICAgICByb290IHx8XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspKSxcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICBcIm1hbnVhbFwiICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlKVxuICAgICAgKVxuICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSBudWxsLCByb290ID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICAgIGlmICg1ID09PSByb290LnRhZyB8fCAyNiA9PT0gcm9vdC50YWcgfHwgMjcgPT09IHJvb3QudGFnKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICgoKGhvaXN0YWJsZVJvb3QgPSBuZXh0Tm9kZS5zdGF0ZU5vZGUpLCBub2RlKSlcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBob2lzdGFibGVSb290LnN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudFJlc291cmNlLnNldFByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50UmVzb3VyY2Uuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbXBvcnRhbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogKGN1cnJlbnRSZXNvdXJjZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF5YmVOb2RlcyA9IG5leHROb2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGkgPSBuZXh0Tm9kZS5tZW1vaXplZFByb3BzLnN0eWxlO1xuICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXkgPVxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGkgJiYgbnVsbCAhPT0gaSAmJiBpLmhhc093blByb3BlcnR5KFwiZGlzcGxheVwiKVxuICAgICAgICAgICAgICAgICAgICAgID8gaS5kaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgbWF5YmVOb2Rlcy5zdHlsZS5kaXNwbGF5ID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PSBkaXNwbGF5IHx8IFwiYm9vbGVhblwiID09PSB0eXBlb2YgZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgIDogKFwiXCIgKyBkaXNwbGF5KS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHROb2RlLCBuZXh0Tm9kZS5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gcm9vdC50YWcpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgIG5leHROb2RlID0gcm9vdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZS5zdGF0ZU5vZGUubm9kZVZhbHVlID0gbm9kZVxuICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICA6IG5leHROb2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dE5vZGUsIG5leHROb2RlLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcm9vdC5tZW1vaXplZFN0YXRlIHx8XG4gICAgICAgICAgICAgIHJvb3QgPT09IGZpbmlzaGVkV29yaykgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJvb3QuY2hpbGQucmV0dXJuID0gcm9vdDtcbiAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IHJvb3Quc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdC5yZXR1cm4gfHwgcm9vdC5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgYnJlYWsgYTtcbiAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgIHJvb3QgPSByb290LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgIHJvb3Quc2libGluZy5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gZmxhZ3MucmV0cnlRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgKChmbGFncy5yZXRyeVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgY3VycmVudCkpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE5OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIxOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgyNyAhPT0gZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBhOiB7XG4gICAgICAgICAgZm9yICh2YXIgcGFyZW50ID0gZmluaXNoZWRXb3JrLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjApKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC50YWcpIHtcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgdmFyIHBhcmVudCRqc2NvbXAkMCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCRqc2NvbXAkMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB2YXIgcGFyZW50JDExMyA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZmxhZ3MgJiAzMiAmJlxuICAgICAgICAgICAgICAoc2V0VGV4dENvbnRlbnQocGFyZW50JDExMywgXCJcIiksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZmxhZ3MgJj0gLTMzKSk7XG4gICAgICAgICAgICB2YXIgYmVmb3JlJDExNCA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUkMTE0LCBwYXJlbnQkMTEzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgcGFyZW50JDExNSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgYmVmb3JlJDExNiA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGJlZm9yZSQxMTYsXG4gICAgICAgICAgICAgIHBhcmVudCQxMTVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IC0zO1xuICB9XG4gIGZsYWdzICYgNDA5NiAmJiAoZmluaXNoZWRXb3JrLmZsYWdzICY9IC00MDk3KTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNClcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgIHZhciBmaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpYmVyKTtcbiAgICAgIDUgPT09IGZpYmVyLnRhZyAmJiBmaWJlci5mbGFncyAmIDEwMjQgJiYgZmliZXIuc3RhdGVOb2RlLnJlc2V0KCk7XG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBwYXJlbnRGaWJlci5hbHRlcm5hdGUsIHBhcmVudEZpYmVyKSxcbiAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICB2YXIgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXI7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDExOlxuICAgICAgY2FzZSAxNDpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI2OlxuICAgICAgY2FzZSAyNzpcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMjpcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgcGFyZW50RmliZXIsXG4gIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbikge1xuICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKTtcbiAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGUsXG4gICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBmaW5pc2hlZFdvcmsgPSBwYXJlbnRGaWJlcixcbiAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoNCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpbmlzaGVkUm9vdCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZmluaXNoZWRSb290LmNvbXBvbmVudERpZE1vdW50KVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgY3VycmVudC5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpbmlzaGVkUm9vdCA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IGZpbmlzaGVkUm9vdC5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGhpZGRlbkNhbGxiYWNrcylcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGwsIGZpbmlzaGVkUm9vdCA9IDA7XG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290IDwgaGlkZGVuQ2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2FsbENhbGxiYWNrKGhpZGRlbkNhbGxiYWNrc1tmaW5pc2hlZFJvb3RdLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNjpcbiAgICAgIGNhc2UgMjc6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIyOlxuICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG4gIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgKHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICBjdXJyZW50ID0gbnVsbDtcbiAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgY3VycmVudCAhPT0gcHJldmlvdXNDYWNoZSAmJlxuICAgIChudWxsICE9IGN1cnJlbnQgJiYgY3VycmVudC5yZWZDb3VudCsrLFxuICAgIG51bGwgIT0gcHJldmlvdXNDYWNoZSAmJiByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSkpO1xufVxuZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIGN1cnJlbnQgPSBudWxsO1xuICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICBmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgZmluaXNoZWRXb3JrICE9PSBjdXJyZW50ICYmXG4gICAgKGZpbmlzaGVkV29yay5yZWZDb3VudCsrLCBudWxsICE9IGN1cnJlbnQgJiYgcmVsZWFzZUNhY2hlKGN1cnJlbnQpKTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICByb290LFxuICBwYXJlbnRGaWJlcixcbiAgY29tbWl0dGVkTGFuZXMsXG4gIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4pIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICksXG4gICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgZmluaXNoZWRSb290LFxuICBmaW5pc2hlZFdvcmssXG4gIGNvbW1pdHRlZExhbmVzLFxuICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuKSB7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApO1xuICAgICAgZmxhZ3MgJiAyMDQ4ICYmIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoOSwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApO1xuICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gbnVsbCksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgZmluaXNoZWRXb3JrICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgICAoZmluaXNoZWRXb3JrLnJlZkNvdW50KyssXG4gICAgICAgICAgbnVsbCAhPSBmaW5pc2hlZFJvb3QgJiYgcmVsZWFzZUNhY2hlKGZpbmlzaGVkUm9vdCkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLmlkLFxuICAgICAgICAgICAgb25Qb3N0Q29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblBvc3RDb21taXQ7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb25Qb3N0Q29tbWl0ICYmXG4gICAgICAgICAgICBvblBvc3RDb21taXQoXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgICAgLTBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIzOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgPyBfZmluaXNoZWRXb3JrJG1lbW9pemUyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaylcbiAgICAgICAgOiBfZmluaXNoZWRXb3JrJG1lbW9pemUyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6ICgoX2ZpbmlzaGVkV29yayRtZW1vaXplMi5fdmlzaWJpbGl0eSB8PSA0KSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgICAgICkpO1xuICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgKTtcbiAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApO1xuICB9XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgcGFyZW50RmliZXIsXG4gIGNvbW1pdHRlZExhbmVzJGpzY29tcCQwLFxuICBjb21taXR0ZWRUcmFuc2l0aW9ucyRqc2NvbXAkMCxcbiAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuKSB7XG4gIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPVxuICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KTtcbiAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgdmFyIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMgPSBjb21taXR0ZWRMYW5lcyRqc2NvbXAkMCxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zID0gY29tbWl0dGVkVHJhbnNpdGlvbnMkanNjb21wJDAsXG4gICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoOCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIzOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgPyBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICA6ICgoaW5zdGFuY2UuX3Zpc2liaWxpdHkgfD0gNCksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICkpO1xuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgIH1cbiAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgZmluaXNoZWRSb290JGpzY29tcCQwLFxuICBwYXJlbnRGaWJlclxuKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgIHZhciBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICAgIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyLFxuICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICB9XG59XG52YXIgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDgxOTI7XG5mdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBzdXNwZW5kUmVzb3VyY2UoXG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzXG4gICAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICAgIHZhciBwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBzdXNwZW5zZXlDb21taXRGbGFnKSxcbiAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gMTY3NzcyMTYpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKSxcbiAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldmlvdXNIb2lzdGFibGVSb290KSlcbiAgICAgICAgICA6IHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcikpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKSB7XG4gIHZhciBwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoXG4gICAgbnVsbCAhPT0gcHJldmlvdXNGaWJlciAmJlxuICAgICgocGFyZW50RmliZXIgPSBwcmV2aW91c0ZpYmVyLmNoaWxkKSwgbnVsbCAhPT0gcGFyZW50RmliZXIpXG4gICkge1xuICAgIHByZXZpb3VzRmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGRvXG4gICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAocGFyZW50RmliZXIuc2libGluZyA9IG51bGwpLFxuICAgICAgICAocGFyZW50RmliZXIgPSBwcmV2aW91c0ZpYmVyKTtcbiAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICB9XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gIGlmICgwICE9PSAocGFyZW50RmliZXIuZmxhZ3MgJiAxNikpIHtcbiAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gIH1cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE1OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICYgMjA0OCAmJlxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoOSwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDQgJiZcbiAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgPyAoKGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IC01KSxcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICB9XG4gIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyO1xuICAgIHN3aXRjaCAoZGVsZXRpb25zLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg4LCBkZWxldGlvbnMsIGRlbGV0aW9ucy5yZXR1cm4pO1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGRlbGV0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMjpcbiAgICAgICAgaSA9IGRlbGV0aW9ucy5zdGF0ZU5vZGU7XG4gICAgICAgIGkuX3Zpc2liaWxpdHkgJiA0ICYmXG4gICAgICAgICAgKChpLl92aXNpYmlsaXR5ICY9IC01KSxcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGRlbGV0aW9ucykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZGVsZXRpb25zKTtcbiAgICB9XG4gICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICBkZWxldGVkU3VidHJlZVJvb3QsXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3Jcbikge1xuICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg4LCBmaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMzpcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2xcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGNhY2hlID0gZmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICBudWxsICE9IGNhY2hlICYmIGNhY2hlLnJlZkNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZWxlYXNlQ2FjaGUoZmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgfVxuICAgIGNhY2hlID0gZmliZXIuY2hpbGQ7XG4gICAgaWYgKG51bGwgIT09IGNhY2hlKSAoY2FjaGUucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IGNhY2hlKTtcbiAgICBlbHNlXG4gICAgICBhOiBmb3IgKGZpYmVyID0gZGVsZXRlZFN1YnRyZWVSb290OyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgY2FjaGUgPSBuZXh0RWZmZWN0O1xuICAgICAgICB2YXIgc2libGluZyA9IGNhY2hlLnNpYmxpbmcsXG4gICAgICAgICAgcmV0dXJuRmliZXIgPSBjYWNoZS5yZXR1cm47XG4gICAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGNhY2hlKTtcbiAgICAgICAgaWYgKGNhY2hlID09PSBmaWJlcikge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHtcbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuc2libGluZyA9XG4gICAgdGhpcy5jaGlsZCA9XG4gICAgdGhpcy5yZXR1cm4gPVxuICAgIHRoaXMuc3RhdGVOb2RlID1cbiAgICB0aGlzLnR5cGUgPVxuICAgIHRoaXMuZWxlbWVudFR5cGUgPVxuICAgICAgbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMucmVmQ2xlYW51cCA9IHRoaXMucmVmID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID1cbiAgICB0aGlzLm1lbW9pemVkU3RhdGUgPVxuICAgIHRoaXMudXBkYXRlUXVldWUgPVxuICAgIHRoaXMubWVtb2l6ZWRQcm9wcyA9XG4gICAgICBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLnN1YnRyZWVGbGFncyA9IHRoaXMuZmxhZ3MgPSAwO1xuICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IHRoaXMubGFuZXMgPSAwO1xuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckltcGxDbGFzcyh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufVxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICBDb21wb25lbnQgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISghQ29tcG9uZW50IHx8ICFDb21wb25lbnQuaXNSZWFjdENvbXBvbmVudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgPyAoKHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoXG4gICAgICAgIGN1cnJlbnQudGFnLFxuICAgICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICAgIGN1cnJlbnQua2V5LFxuICAgICAgICBjdXJyZW50Lm1vZGVcbiAgICAgICkpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZSksXG4gICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQpLFxuICAgICAgKGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3MpKVxuICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzID0gMCksXG4gICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCkpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgcGVuZGluZ1Byb3BzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgbnVsbCA9PT0gcGVuZGluZ1Byb3BzXG4gICAgICA/IG51bGxcbiAgICAgIDogeyBsYW5lczogcGVuZGluZ1Byb3BzLmxhbmVzLCBmaXJzdENvbnRleHQ6IHBlbmRpbmdQcm9wcy5maXJzdENvbnRleHQgfTtcbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcbiAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gMzE0NTcyODI7XG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICBudWxsID09PSBjdXJyZW50XG4gICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsKSlcbiAgICA6ICgod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgbGFuZXM6IHJlbmRlckxhbmVzLmxhbmVzLFxuICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHJlbmRlckxhbmVzLmZpcnN0Q29udGV4dFxuICAgICAgICAgICAgfSkpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gIHR5cGUsXG4gIGtleSxcbiAgcGVuZGluZ1Byb3BzLFxuICBvd25lcixcbiAgbW9kZSxcbiAgbGFuZXNcbikge1xuICB2YXIgZmliZXJUYWcgPSAwO1xuICBvd25lciA9IHR5cGU7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgKGZpYmVyVGFnID0gMSk7XG4gIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgIGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZShcbiAgICAgIHR5cGUsXG4gICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudFxuICAgIClcbiAgICAgID8gMjZcbiAgICAgIDogXCJodG1sXCIgPT09IHR5cGUgfHwgXCJoZWFkXCIgPT09IHR5cGUgfHwgXCJib2R5XCIgPT09IHR5cGVcbiAgICAgICAgPyAyN1xuICAgICAgICA6IDU7XG4gIGVsc2VcbiAgICBhOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgbW9kZSB8PSAyNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHR5cGUgPSBjcmVhdGVGaWJlckltcGxDbGFzcygxMiwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCAyKSksXG4gICAgICAgICAgKHR5cGUuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFKSxcbiAgICAgICAgICAodHlwZS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHR5cGUgPSBjcmVhdGVGaWJlckltcGxDbGFzcygxMywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAodHlwZS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEUpLFxuICAgICAgICAgICh0eXBlLmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0eXBlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMTksIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgKHR5cGUuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUpLFxuICAgICAgICAgICh0eXBlLmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBmaWJlclRhZyA9IDE0O1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gMTY7XG4gICAgICAgICAgICAgIG93bmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyVGFnID0gMjk7XG4gICAgICAgIHBlbmRpbmdQcm9wcyA9IEVycm9yKFxuICAgICAgICAgIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMwLCBudWxsID09PSB0eXBlID8gXCJudWxsXCIgOiB0eXBlb2YgdHlwZSwgXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgb3duZXIgPSBudWxsO1xuICAgIH1cbiAga2V5ID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAga2V5LmVsZW1lbnRUeXBlID0gdHlwZTtcbiAga2V5LnR5cGUgPSBvd25lcjtcbiAga2V5LmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICBlbGVtZW50cyA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDcsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBlbGVtZW50cy5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZWxlbWVudHM7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHBlbmRpbmdQcm9wcyA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDIyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIHBlbmRpbmdQcm9wcy5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICBwZW5kaW5nUHJvcHMubGFuZXMgPSBsYW5lcztcbiAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge1xuICAgIF92aXNpYmlsaXR5OiAxLFxuICAgIF9wZW5kaW5nVmlzaWJpbGl0eTogMSxcbiAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgX3JldHJ5Q2FjaGU6IG51bGwsXG4gICAgX3RyYW5zaXRpb25zOiBudWxsLFxuICAgIF9jdXJyZW50OiBudWxsLFxuICAgIGRldGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpYmVyID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDU2KSk7XG4gICAgICBpZiAoMCA9PT0gKHByaW1hcnlDaGlsZEluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICgocHJpbWFyeUNoaWxkSW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IDIpLFxuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXR0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmliZXIgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZS5fY3VycmVudDtcbiAgICAgIGlmIChudWxsID09PSBmaWJlcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTYpKTtcbiAgICAgIGlmICgwICE9PSAocHJpbWFyeUNoaWxkSW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMikpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgKChwcmltYXJ5Q2hpbGRJbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJj0gLTMpLFxuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcGVuZGluZ1Byb3BzLnN0YXRlTm9kZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlO1xuICByZXR1cm4gcGVuZGluZ1Byb3BzO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICBjb250ZW50ID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoNiwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICBtb2RlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoXG4gICAgNCxcbiAgICBudWxsICE9PSBwb3J0YWwuY2hpbGRyZW4gPyBwb3J0YWwuY2hpbGRyZW4gOiBbXSxcbiAgICBwb3J0YWwua2V5LFxuICAgIG1vZGVcbiAgKTtcbiAgbW9kZS5sYW5lcyA9IGxhbmVzO1xuICBtb2RlLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gbW9kZTtcbn1cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDtcbn1cbmZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UpIHtcbiAgaWYgKFwic3R5bGVzaGVldFwiICE9PSByZXNvdXJjZS50eXBlIHx8IDAgIT09IChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgNCkpXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICBlbHNlIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkpKSB7XG4gICAgcmVzb3VyY2UgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgIGlmIChcbiAgICAgIG51bGwgIT09IHJlc291cmNlICYmXG4gICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgPT09XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICA/IG51bGwgIT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApICE9PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpIHx8XG4gICAgICAgICAgcmVzb3VyY2UgIT09IHNoZWxsQm91bmRhcnkpXG4gICAgKVxuICAgICAgdGhyb3cgKFxuICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCByZXRyeVF1ZXVlKSB7XG4gIG51bGwgIT09IHJldHJ5UXVldWUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDE2Mzg0ICYmXG4gICAgKChyZXRyeVF1ZXVlID1cbiAgICAgIDIyICE9PSB3b3JrSW5Qcm9ncmVzcy50YWcgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IDUzNjg3MDkxMiksXG4gICAgKHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IHJldHJ5UXVldWUpLFxuICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgfD0gcmV0cnlRdWV1ZSkpO1xufVxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKCFpc0h5ZHJhdGluZylcbiAgICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjazsgKVxuICAgICAgICAgIG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spLFxuICAgICAgICAgICAgKGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5zaWJsaW5nKTtcbiAgICAgICAgbnVsbCA9PT0gbGFzdFRhaWxOb2RlXG4gICAgICAgICAgPyAocmVuZGVyU3RhdGUudGFpbCA9IG51bGwpXG4gICAgICAgICAgOiAobGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29sbGFwc2VkXCI6XG4gICAgICAgIGxhc3RUYWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSQxMzEgPSBudWxsOyBudWxsICE9PSBsYXN0VGFpbE5vZGU7IClcbiAgICAgICAgICBudWxsICE9PSBsYXN0VGFpbE5vZGUuYWx0ZXJuYXRlICYmIChsYXN0VGFpbE5vZGUkMTMxID0gbGFzdFRhaWxOb2RlKSxcbiAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUuc2libGluZyk7XG4gICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZSQxMzFcbiAgICAgICAgICA/IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayB8fCBudWxsID09PSByZW5kZXJTdGF0ZS50YWlsXG4gICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGwpXG4gICAgICAgICAgOiAobGFzdFRhaWxOb2RlJDEzMS5zaWJsaW5nID0gbnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnViYmxlUHJvcGVydGllcyhjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID1cbiAgICAgIG51bGwgIT09IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZCxcbiAgICBuZXdDaGlsZExhbmVzID0gMCxcbiAgICBzdWJ0cmVlRmxhZ3MgPSAwO1xuICBpZiAoZGlkQmFpbG91dClcbiAgICBmb3IgKHZhciBjaGlsZCQxMzIgPSBjb21wbGV0ZWRXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZCQxMzI7IClcbiAgICAgIChuZXdDaGlsZExhbmVzIHw9IGNoaWxkJDEzMi5sYW5lcyB8IGNoaWxkJDEzMi5jaGlsZExhbmVzKSxcbiAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZCQxMzIuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkJDEzMi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgKGNoaWxkJDEzMi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgKGNoaWxkJDEzMiA9IGNoaWxkJDEzMi5zaWJsaW5nKTtcbiAgZWxzZVxuICAgIGZvciAoY2hpbGQkMTMyID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQkMTMyOyApXG4gICAgICAobmV3Q2hpbGRMYW5lcyB8PSBjaGlsZCQxMzIubGFuZXMgfCBjaGlsZCQxMzIuY2hpbGRMYW5lcyksXG4gICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQkMTMyLnN1YnRyZWVGbGFncyksXG4gICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQkMTMyLmZsYWdzKSxcbiAgICAgICAgKGNoaWxkJDEzMi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgKGNoaWxkJDEzMiA9IGNoaWxkJDEzMi5zaWJsaW5nKTtcbiAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICBjb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXMgPSBuZXdDaGlsZExhbmVzO1xuICByZXR1cm4gZGlkQmFpbG91dDtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSAxNjpcbiAgICBjYXNlIDE1OlxuICAgIGNhc2UgMDpcbiAgICBjYXNlIDExOlxuICAgIGNhc2UgNzpcbiAgICBjYXNlIDg6XG4gICAgY2FzZSAxMjpcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxNDpcbiAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgY2FzZSAzOlxuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBuZXdQcm9wcyA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmIChuZXdQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCk7XG4gICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQpO1xuICAgICAgcG9wSG9zdENvbnRhaW5lcigpO1xuICAgICAgcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgJiZcbiAgICAgICAgKChyZW5kZXJMYW5lcy5jb250ZXh0ID0gcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQpLFxuICAgICAgICAocmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgPSBudWxsKSk7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsID09PSBjdXJyZW50LmNoaWxkKVxuICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA/IG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgOiBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpKSB8fFxuICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAocXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA/IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpKVxuICAgICAgICAgIDogcmVuZGVyTGFuZXNcbiAgICAgICAgICAgID8gcmVuZGVyTGFuZXMgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpXG4gICAgICAgICAgICA6IChjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMjc6XG4gICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTY2KSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgOiAoKGN1cnJlbnQgPSByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudCksXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNTpcbiAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjYpKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIoXG4gICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY3VycmVudCA9IHR5cGUuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY3VycmVudCA9IHR5cGUuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3dpdGNoIChyZW5kZXJMYW5lcykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0eXBlLmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdHlwZS5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0eXBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50LmlubmVySFRNTCA9IFwiPHNjcmlwdD5cXHgzYy9zY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZW1vdmVDaGlsZChjdXJyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgID8gdHlwZS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgaXM6IG5ld1Byb3BzLmlzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiB0eXBlLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcy5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICA/IChjdXJyZW50Lm11bHRpcGxlID0gITApXG4gICAgICAgICAgICAgICAgICAgIDogbmV3UHJvcHMuc2l6ZSAmJiAoY3VycmVudC5zaXplID0gbmV3UHJvcHMuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgID8gdHlwZS5jcmVhdGVFbGVtZW50KHJlbmRlckxhbmVzLCB7IGlzOiBuZXdQcm9wcy5pcyB9KVxuICAgICAgICAgICAgICAgICAgICAgIDogdHlwZS5jcmVhdGVFbGVtZW50KHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgY3VycmVudFtpbnRlcm5hbFByb3BzS2V5XSA9IG5ld1Byb3BzO1xuICAgICAgICAgIGE6IGZvciAodHlwZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSB0eXBlOyApIHtcbiAgICAgICAgICAgIGlmICg1ID09PSB0eXBlLnRhZyB8fCA2ID09PSB0eXBlLnRhZylcbiAgICAgICAgICAgICAgY3VycmVudC5hcHBlbmRDaGlsZCh0eXBlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmICg0ICE9PSB0eXBlLnRhZyAmJiAyNyAhPT0gdHlwZS50YWcgJiYgbnVsbCAhPT0gdHlwZS5jaGlsZCkge1xuICAgICAgICAgICAgICB0eXBlLmNoaWxkLnJldHVybiA9IHR5cGU7XG4gICAgICAgICAgICAgIHR5cGUgPSB0eXBlLmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgIGZvciAoOyBudWxsID09PSB0eXBlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdHlwZS5yZXR1cm4gfHwgdHlwZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIHR5cGUgPSB0eXBlLnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUuc2libGluZy5yZXR1cm4gPSB0eXBlLnJldHVybjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgYTogc3dpdGNoIChcbiAgICAgICAgICAgIChzZXRJbml0aWFsUHJvcGVydGllcyhjdXJyZW50LCByZW5kZXJMYW5lcywgbmV3UHJvcHMpLCByZW5kZXJMYW5lcylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSAhIW5ld1Byb3BzLmF1dG9Gb2N1cztcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICAgICAgY3VycmVudCA9ICEwO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY3VycmVudCA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNjpcbiAgICAgIGlmIChjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgbmV3UHJvcHMgJiYgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTY2KSk7XG4gICAgICAgIGN1cnJlbnQgPSByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgIHR5cGUgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAgIGN1cnJlbnQubm9kZVZhbHVlID09PSByZW5kZXJMYW5lcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IG5ld1Byb3BzICYmICEwID09PSBuZXdQcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHx8XG4gICAgICAgICAgICBjaGVja0ZvclVubWF0Y2hlZFRleHQoY3VycmVudC5ub2RlVmFsdWUsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgICA/ICEwXG4gICAgICAgICAgICAgIDogITE7XG4gICAgICAgICAgY3VycmVudCB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAoY3VycmVudCA9XG4gICAgICAgICAgICBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIoY3VycmVudCkuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDEzOlxuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgIChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZClcbiAgICAgICkge1xuICAgICAgICB0eXBlID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV3UHJvcHMgJiYgbnVsbCAhPT0gbmV3UHJvcHMuZGVoeWRyYXRlZCkge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzE4KSk7XG4gICAgICAgICAgICB0eXBlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHR5cGUgPSBudWxsICE9PSB0eXBlID8gdHlwZS5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdHlwZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMTcpKTtcbiAgICAgICAgICAgIHR5cGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSxcbiAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB0eXBlID0gITE7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSwgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSxcbiAgICAgICAgICAgICh0eXBlID0gITApO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICByZXR1cm4gcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSwgd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmICgwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpKVxuICAgICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXMpLCB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJlbmRlckxhbmVzID0gbnVsbCAhPT0gbmV3UHJvcHM7XG4gICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAocmVuZGVyTGFuZXMpIHtcbiAgICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgKHR5cGUgPSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICAgIHZhciBjYWNoZSQxNDQgPSBudWxsO1xuICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAoY2FjaGUkMTQ0ID0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICAgIGNhY2hlJDE0NCAhPT0gdHlwZSAmJiAobmV3UHJvcHMuZmxhZ3MgfD0gMjA0OCk7XG4gICAgICB9XG4gICAgICByZW5kZXJMYW5lcyAhPT0gY3VycmVudCAmJlxuICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQuZmxhZ3MgfD0gODE5Mik7XG4gICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLnR5cGUpLCBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDE5OlxuICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IpO1xuICAgICAgdHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCA9PT0gdHlwZSkgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgbmV3UHJvcHMgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgY2FjaGUkMTQ0ID0gdHlwZS5yZW5kZXJpbmc7XG4gICAgICBpZiAobnVsbCA9PT0gY2FjaGUkMTQ0KVxuICAgICAgICBpZiAobmV3UHJvcHMpIGN1dE9mZlRhaWxJZk5lZWRlZCh0eXBlLCAhMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDAgIT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICAgIGNhY2hlJDE0NCA9IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGNhY2hlJDE0NCkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjYWNoZSQxNDQudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgIGZvciAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gcmVuZGVyTGFuZXM7IClcbiAgICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgICAgICAgIChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiAxKSB8IDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IHR5cGUudGFpbCAmJlxuICAgICAgICAgICAgbm93KCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICBpZiAoKChjdXJyZW50ID0gZmluZEZpcnN0U3VzcGVuZGVkKGNhY2hlJDE0NCkpLCBudWxsICE9PSBjdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudCksXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITApLFxuICAgICAgICAgICAgICBudWxsID09PSB0eXBlLnRhaWwgJiZcbiAgICAgICAgICAgICAgICBcImhpZGRlblwiID09PSB0eXBlLnRhaWxNb2RlICYmXG4gICAgICAgICAgICAgICAgIWNhY2hlJDE0NC5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAhaXNIeWRyYXRpbmcpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIDIgKiBub3coKSAtIHR5cGUucmVuZGVyaW5nU3RhcnRUaW1lID5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgICA1MzY4NzA5MTIgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgIHR5cGUuaXNCYWNrd2FyZHNcbiAgICAgICAgICA/ICgoY2FjaGUkMTQ0LnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjYWNoZSQxNDQpKVxuICAgICAgICAgIDogKChjdXJyZW50ID0gdHlwZS5sYXN0KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAoY3VycmVudC5zaWJsaW5nID0gY2FjaGUkMTQ0KVxuICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNhY2hlJDE0NCksXG4gICAgICAgICAgICAodHlwZS5sYXN0ID0gY2FjaGUkMTQ0KSk7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gdHlwZS50YWlsKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHR5cGUudGFpbCksXG4gICAgICAgICAgKHR5cGUucmVuZGVyaW5nID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICh0eXBlLnRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nKSxcbiAgICAgICAgICAodHlwZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3coKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAoY3VycmVudCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdQcm9wcyA/IChjdXJyZW50ICYgMSkgfCAyIDogY3VycmVudCAmIDEpLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgMjI6XG4gICAgY2FzZSAyMzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIHBvcEhpZGRlbkNvbnRleHQoKSxcbiAgICAgICAgKG5ld1Byb3BzID0gbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICA/IChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpXG4gICAgICAgICAgOiBuZXdQcm9wcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgPyAwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpICYmXG4gICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiA2ICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSlcbiAgICAgICAgICA6IGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMucmV0cnlRdWV1ZSksXG4gICAgICAgIChyZW5kZXJMYW5lcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgbmV3UHJvcHMgIT09IHJlbmRlckxhbmVzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI0OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCksXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMjU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1Niwgd29ya0luUHJvZ3Jlc3MudGFnKSk7XG59XG5mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgOiBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCksXG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoKSxcbiAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgIDAgIT09IChjdXJyZW50ICYgNjU1MzYpICYmIDAgPT09IChjdXJyZW50ICYgMTI4KVxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI2OlxuICAgIGNhc2UgMjc6XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICBjYXNlIDEzOlxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5kZWh5ZHJhdGVkKSB7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDApKTtcbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgOiBudWxsO1xuICAgIGNhc2UgMTk6XG4gICAgICByZXR1cm4gcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IpLCBudWxsO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBwb3BIb3N0Q29udGFpbmVyKCksIG51bGw7XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlKSwgbnVsbDtcbiAgICBjYXNlIDIyOlxuICAgIGNhc2UgMjM6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBwb3BIaWRkZW5Db250ZXh0KCksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSksXG4gICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA6IG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAyNDpcbiAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQpLCBudWxsO1xuICAgIGNhc2UgMjU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspIHtcbiAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAzOlxuICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0KTtcbiAgICAgIHBvcEhvc3RDb250YWluZXIoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjY6XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgcG9wSG9zdENvbnRhaW5lcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOTpcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmsudHlwZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgIGNhc2UgMjM6XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHBvcEhpZGRlbkNvbnRleHQoKTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI0OlxuICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0KTtcbiAgfVxufVxudmFyIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAocmVzb3VyY2VUeXBlKSB7XG4gICAgICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpLFxuICAgICAgICBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuICAgICAgdm9pZCAwID09PSBjYWNoZUZvclR5cGUgJiZcbiAgICAgICAgKChjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKSksXG4gICAgICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKSk7XG4gICAgICByZXR1cm4gY2FjaGVGb3JUeXBlO1xuICAgIH1cbiAgfSxcbiAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGwsXG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITEsXG4gIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITEsXG4gIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExLFxuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IDAsXG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IDAsXG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITEsXG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHksXG4gIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsLFxuICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwsXG4gIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITEsXG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbCxcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwLFxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDAsXG4gIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsLFxuICBuZXN0ZWRVcGRhdGVDb3VudCA9IDAsXG4gIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZSgpIHtcbiAgaWYgKDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgMikgJiYgMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgLXdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICBpZiAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCkge1xuICAgIHZhciBhY3Rpb25TY29wZUxhbmUgPSBjdXJyZW50RW50YW5nbGVkTGFuZTtcbiAgICByZXR1cm4gMCAhPT0gYWN0aW9uU2NvcGVMYW5lID8gYWN0aW9uU2NvcGVMYW5lIDogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVVcGRhdGVQcmlvcml0eSgpO1xufVxuZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgMCA9PT0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgJiZcbiAgICAod29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICA/IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKClcbiAgICAgICAgOiA1MzY4NzA5MTIpO1xuICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgbnVsbCAhPT0gc3VzcGVuc2VIYW5kbGVyICYmIChzdXNwZW5zZUhhbmRsZXIuZmxhZ3MgfD0gMzIpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgaWYgKFxuICAgIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgMiA9PT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHx8XG4gICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gIClcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKSxcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICByb290LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICExXG4gICAgICApO1xuICBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCBsYW5lKTtcbiAgaWYgKDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgMikgfHwgcm9vdCAhPT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgKDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgMikgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9IGxhbmUpLFxuICAgICAgNCA9PT0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAmJlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICExXG4gICAgICAgICkpLFxuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xufVxuZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCRqc2NvbXAkMCwgbGFuZXMsIGZvcmNlU3luYykge1xuICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiA2KSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMjcpKTtcbiAgdmFyIHNob3VsZFRpbWVTbGljZSA9XG4gICAgICAoIWZvcmNlU3luYyAmJlxuICAgICAgICAwID09PSAobGFuZXMgJiA2MCkgJiZcbiAgICAgICAgMCA9PT0gKGxhbmVzICYgcm9vdCRqc2NvbXAkMC5leHBpcmVkTGFuZXMpKSB8fFxuICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290JGpzY29tcCQwLCBsYW5lcyksXG4gICAgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZVxuICAgICAgPyByZW5kZXJSb290Q29uY3VycmVudChyb290JGpzY29tcCQwLCBsYW5lcylcbiAgICAgIDogcmVuZGVyUm9vdFN5bmMocm9vdCRqc2NvbXAkMCwgbGFuZXMsICEwKSxcbiAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gc2hvdWxkVGltZVNsaWNlO1xuICBkbyB7XG4gICAgaWYgKDAgPT09IGV4aXRTdGF0dXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICFzaG91bGRUaW1lU2xpY2UgJiZcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCRqc2NvbXAkMCwgbGFuZXMsIDAsICExKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoNiA9PT0gZXhpdFN0YXR1cylcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICByb290JGpzY29tcCQwLFxuICAgICAgICBsYW5lcyxcbiAgICAgICAgMCxcbiAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgKTtcbiAgICBlbHNlIHtcbiAgICAgIGZvcmNlU3luYyA9IHJvb3QkanNjb21wJDAuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgJiZcbiAgICAgICAgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3Jlcyhmb3JjZVN5bmMpXG4gICAgICApIHtcbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QkanNjb21wJDAsIGxhbmVzLCAhMSk7XG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoMiA9PT0gZXhpdFN0YXR1cykge1xuICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gbGFuZXM7XG4gICAgICAgIGlmIChyb290JGpzY29tcCQwLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gMDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSByb290JGpzY29tcCQwLnBlbmRpbmdMYW5lcyAmIC01MzY4NzA5MTMpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgIDAgIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgICAgID8gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgID8gNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICBpZiAoMCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgICAgbGFuZXMgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSByb290JGpzY29tcCQwO1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG4gICAgICAgICAgICB2YXIgd2FzUm9vdERlaHlkcmF0ZWQgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG4gICAgICAgICAgICB3YXNSb290RGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAocHJlcGFyZUZyZXNoU3RhY2socm9vdCwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KS5mbGFncyB8PSAyNTYpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcmVuZGVyUm9vdFN5bmMoXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoMiAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAhd2FzUm9vdERlaHlkcmF0ZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyB8PSByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGV4aXRTdGF0dXM7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlcldhc0NvbmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKHJlbmRlcldhc0NvbmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgIGlmICgyICE9PSBleGl0U3RhdHVzKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKDEgPT09IGV4aXRTdGF0dXMpIHtcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCRqc2NvbXAkMCwgMCk7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QkanNjb21wJDAsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICBzaG91bGRUaW1lU2xpY2UgPSByb290JGpzY29tcCQwO1xuICAgICAgICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDUpKTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoKGxhbmVzICYgNDE5NDE3NikgPT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzI5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkV29yayA9IGZvcmNlU3luYztcbiAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChsYW5lcyAmIDYyOTE0NTYwKSA9PT0gbGFuZXMgJiZcbiAgICAgICAgICAoKHJlbmRlcldhc0NvbmN1cnJlbnQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgMzAwIC0gbm93KCkpLFxuICAgICAgICAgIDEwIDwgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgKSB7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDAgIT09IGdldE5leHRMYW5lcyhzaG91bGRUaW1lU2xpY2UsIDApKSBicmVhayBhO1xuICAgICAgICAgIHNob3VsZFRpbWVTbGljZS50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KFxuICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeS5iaW5kKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgLTAsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgfSB3aGlsZSAoMSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290JGpzY29tcCQwKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKSB7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzXG4gICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnMpXG4gICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgZXJyb3JzXG4gICAgICApO1xufVxuZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgcm9vdCxcbiAgZmluaXNoZWRXb3JrLFxuICByZWNvdmVyYWJsZUVycm9ycyxcbiAgdHJhbnNpdGlvbnMsXG4gIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgbGFuZXMsXG4gIHNwYXduZWRMYW5lLFxuICB1cGRhdGVkTGFuZXMsXG4gIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gIGRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbikge1xuICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcbiAgaWYgKHN1YnRyZWVGbGFncyAmIDgxOTIgfHwgMTY3ODU0MDggPT09IChzdWJ0cmVlRmxhZ3MgJiAxNjc4NTQwOCkpXG4gICAgaWYgKFxuICAgICAgKChzdXNwZW5kZWRTdGF0ZSA9IHsgc3R5bGVzaGVldHM6IG51bGwsIGNvdW50OiAwLCB1bnN1c3BlbmQ6IG5vb3AgfSksXG4gICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmspLFxuICAgICAgKGZpbmlzaGVkV29yayA9IHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKSksXG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmspXG4gICAgKSB7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBmaW5pc2hlZFdvcmsoXG4gICAgICAgIGNvbW1pdFJvb3QuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBzcGF3bmVkTGFuZSwgIWRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBjb21taXRSb290KFxuICAgIHJvb3QsXG4gICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgdHJhbnNpdGlvbnMsXG4gICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgIHNwYXduZWRMYW5lLFxuICAgIHVwZGF0ZWRMYW5lcyxcbiAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICApO1xufVxuZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICBmb3IgKHZhciBub2RlID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICBpZiAoXG4gICAgICAoMCA9PT0gdGFnIHx8IDExID09PSB0YWcgfHwgMTUgPT09IHRhZykgJiZcbiAgICAgIG5vZGUuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgKCh0YWcgPSBub2RlLnVwZGF0ZVF1ZXVlKSxcbiAgICAgIG51bGwgIT09IHRhZyAmJiAoKHRhZyA9IHRhZy5zdG9yZXMpLCBudWxsICE9PSB0YWcpKVxuICAgIClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVjayA9IHRhZ1tpXSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCA9IGNoZWNrLmdldFNuYXBzaG90O1xuICAgICAgICBjaGVjayA9IGNoZWNrLnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghb2JqZWN0SXMoZ2V0U25hcHNob3QoKSwgY2hlY2spKSByZXR1cm4gITE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgdGFnID0gbm9kZS5jaGlsZDtcbiAgICBpZiAobm9kZS5zdWJ0cmVlRmxhZ3MgJiAxNjM4NCAmJiBudWxsICE9PSB0YWcpXG4gICAgICAodGFnLnJldHVybiA9IG5vZGUpLCAobm9kZSA9IHRhZyk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSBicmVhaztcbiAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgcmV0dXJuICEwO1xuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChcbiAgcm9vdCxcbiAgc3VzcGVuZGVkTGFuZXMsXG4gIHNwYXduZWRMYW5lLFxuICBkaWRBdHRlbXB0RW50aXJlVHJlZVxuKSB7XG4gIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcztcbiAgc3VzcGVuZGVkTGFuZXMgJj0gfndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzO1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lcztcbiAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgJiYgKHJvb3Qud2FybUxhbmVzIHw9IHN1c3BlbmRlZExhbmVzKTtcbiAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgZm9yICh2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lczsgMCA8IGxhbmVzOyApIHtcbiAgICB2YXIgaW5kZXgkNiA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNjtcbiAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVtpbmRleCQ2XSA9IC0xO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG4gIDAgIT09IHNwYXduZWRMYW5lICYmXG4gICAgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIHN1c3BlbmRlZExhbmVzKTtcbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmskMSgpIHtcbiAgcmV0dXJuIDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgNilcbiAgICA/IChmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSksICExKVxuICAgIDogITA7XG59XG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKSB7XG4gIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmICgwID09PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgZWxzZVxuICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbCksXG4gICAgICAgIHJlc2V0SG9va3NPblVud2luZChpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAodGhlbmFibGVTdGF0ZSQxID0gbnVsbCksXG4gICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCksXG4gICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgZm9yICg7IG51bGwgIT09IGludGVycnVwdGVkV29yazsgKVxuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yay5hbHRlcm5hdGUsIGludGVycnVwdGVkV29yayksXG4gICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuKTtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgdmFyIHRpbWVvdXRIYW5kbGUgPSByb290LnRpbWVvdXRIYW5kbGU7XG4gIC0xICE9PSB0aW1lb3V0SGFuZGxlICYmXG4gICAgKChyb290LnRpbWVvdXRIYW5kbGUgPSAtMSksIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSkpO1xuICB0aW1lb3V0SGFuZGxlID0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0O1xuICBudWxsICE9PSB0aW1lb3V0SGFuZGxlICYmXG4gICAgKChyb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsKSwgdGltZW91dEhhbmRsZSgpKTtcbiAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIHdvcmtJblByb2dyZXNzID0gdGltZW91dEhhbmRsZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMDtcbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMTtcbiAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID1cbiAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPVxuICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID1cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPVxuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPVxuICAgICAgMDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID1cbiAgICBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITE7XG4gIDAgIT09IChsYW5lcyAmIDgpICYmIChsYW5lcyB8PSBsYW5lcyAmIDMyKTtcbiAgdmFyIGFsbEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcbiAgaWYgKDAgIT09IGFsbEVudGFuZ2xlZExhbmVzKVxuICAgIGZvciAoXG4gICAgICByb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzLCBhbGxFbnRhbmdsZWRMYW5lcyAmPSBsYW5lcztcbiAgICAgIDAgPCBhbGxFbnRhbmdsZWRMYW5lcztcblxuICAgICkge1xuICAgICAgdmFyIGluZGV4JDQgPSAzMSAtIGNsejMyKGFsbEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNDtcbiAgICAgIGxhbmVzIHw9IHJvb3RbaW5kZXgkNF07XG4gICAgICBhbGxFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gbGFuZXM7XG4gIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgcmV0dXJuIHRpbWVvdXRIYW5kbGU7XG59XG5mdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAzKSlcbiAgICA6IHRocm93blZhbHVlID09PSBTdXNwZW5zZXlDb21taXRFeGNlcHRpb25cbiAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA0KSlcbiAgICAgIDogKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uXG4gICAgICAgICAgICA/IDhcbiAgICAgICAgICAgIDogbnVsbCAhPT0gdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuXG4gICAgICAgICAgICAgID8gNlxuICAgICAgICAgICAgICA6IDEpO1xuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gdGhyb3duVmFsdWU7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzICYmXG4gICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMSksXG4gICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgIHJvb3QsXG4gICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICkpO1xufVxuZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIHJldHVybiBudWxsID09PSBwcmV2RGlzcGF0Y2hlciA/IENvbnRleHRPbmx5RGlzcGF0Y2hlciA6IHByZXZEaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gNDtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIHx8XG4gICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpICE9PVxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpIHx8XG4gICAgKHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITApO1xuICAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyAmIDEzNDIxNzcyNykgJiZcbiAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgJiAxMzQyMTc3MjcpKSB8fFxuICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCB8fFxuICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290LFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICExXG4gICAgKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IDI7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpXG4gICAgKHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsKSwgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICBsYW5lcyA9ICExO1xuICB2YXIgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gIGE6IGRvXG4gICAgdHJ5IHtcbiAgICAgIGlmICgwICE9PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAmJiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcbiAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IDY7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICB2YXIgcmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb247XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgKHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQxNjQpIHtcbiAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDE2NCk7XG4gICAgfVxuICB3aGlsZSAoMSk7XG4gIGxhbmVzICYmIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlcisrO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAoKHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwpLFxuICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDApLFxuICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gIHJldHVybiBleGl0U3RhdHVzO1xufVxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7ICkgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xufVxuZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSAyO1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICA/ICgod29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3coKSArIDUwMCksXG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykpXG4gICAgOiAod29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICByb290LFxuICAgICAgICBsYW5lc1xuICAgICAgKSk7XG4gIGE6IGRvXG4gICAgdHJ5IHtcbiAgICAgIGlmICgwICE9PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAmJiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBsYW5lcyA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB2YXIgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuICAgICAgICBiOiBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIGxhbmVzLCB0aHJvd25WYWx1ZSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKHRocm93blZhbHVlKSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKGxhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgMiA9PT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gJiZcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA3KTtcbiAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRocm93blZhbHVlLnRoZW4obGFuZXMsIGxhbmVzKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA3O1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDU7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlzVGhlbmFibGVSZXNvbHZlZCh0aHJvd25WYWx1ZSlcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIGxhbmVzLCB0aHJvd25WYWx1ZSwgNykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZSA/IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkgOiAxKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGhvc3RGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgbGFuZXMsIHRocm93blZhbHVlLCA1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCBsYW5lcywgdGhyb3duVmFsdWUsIDYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gNjtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDYyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMTY2KSB7XG4gICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQxNjYpO1xuICAgIH1cbiAgd2hpbGUgKDEpO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKSByZXR1cm4gMDtcbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwO1xuICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xufVxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgIXNob3VsZFlpZWxkKCk7IClcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIHZhciBuZXh0ID0gYmVnaW5Xb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICBudWxsID09PSBuZXh0ID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIDogKHdvcmtJblByb2dyZXNzID0gbmV4dCk7XG59XG5mdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgdmFyIG5leHQgPSB1bml0T2ZXb3JrO1xuICB2YXIgY3VycmVudCA9IG5leHQuYWx0ZXJuYXRlO1xuICBzd2l0Y2ggKG5leHQudGFnKSB7XG4gICAgY2FzZSAxNTpcbiAgICBjYXNlIDA6XG4gICAgICBuZXh0ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIG5leHQucGVuZGluZ1Byb3BzLFxuICAgICAgICBuZXh0LnR5cGUsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOlxuICAgICAgbmV4dCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBuZXh0LFxuICAgICAgICBuZXh0LnBlbmRpbmdQcm9wcyxcbiAgICAgICAgbmV4dC50eXBlLnJlbmRlcixcbiAgICAgICAgbmV4dC5yZWYsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgcmVzZXRIb29rc09uVW53aW5kKG5leHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgbmV4dCksXG4gICAgICAgIChuZXh0ID0gd29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MobmV4dCwgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgKG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgbmV4dCwgZW50YW5nbGVkUmVuZGVyTGFuZXMpKTtcbiAgfVxuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgbnVsbCA9PT0gbmV4dCA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSA6ICh3b3JrSW5Qcm9ncmVzcyA9IG5leHQpO1xufVxuZnVuY3Rpb24gdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgcm9vdCxcbiAgdW5pdE9mV29yayxcbiAgdGhyb3duVmFsdWUsXG4gIHN1c3BlbmRlZFJlYXNvblxuKSB7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspO1xuICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgdmFyIHJldHVybkZpYmVyID0gdW5pdE9mV29yay5yZXR1cm47XG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgdGhyb3dFeGNlcHRpb24oXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAxO1xuICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgcm9vdCxcbiAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcikgdGhyb3cgKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSwgZXJyb3IpO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAxO1xuICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICByb290LFxuICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICApO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHVuaXRPZldvcmsuZmxhZ3MgJiAzMjc2OCkge1xuICAgIGlmIChpc0h5ZHJhdGluZyB8fCAxID09PSBzdXNwZW5kZWRSZWFzb24pIHJvb3QgPSAhMDtcbiAgICBlbHNlIGlmIChcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nIHx8XG4gICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgKVxuICAgICAgcm9vdCA9ICExO1xuICAgIGVsc2UgaWYgKFxuICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgMiA9PT0gc3VzcGVuZGVkUmVhc29uIHx8IDMgPT09IHN1c3BlbmRlZFJlYXNvbiB8fCA2ID09PSBzdXNwZW5kZWRSZWFzb24pXG4gICAgKVxuICAgICAgKHN1c3BlbmRlZFJlYXNvbiA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICBudWxsICE9PSBzdXNwZW5kZWRSZWFzb24gJiZcbiAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24uZmxhZ3MgfD0gMTYzODQpO1xuICAgIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgcm9vdCk7XG4gIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG59XG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gIGRvIHtcbiAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAzMjc2OCkpIHtcbiAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKFxuICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUsXG4gICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICApO1xuICAgIGlmIChudWxsICE9PSBuZXh0KSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbXBsZXRlZFdvcmsgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG4gICAgaWYgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgfSB3aGlsZSAobnVsbCAhPT0gY29tcGxldGVkV29yayk7XG4gIDAgPT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSA1KTtcbn1cbmZ1bmN0aW9uIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgc2tpcFNpYmxpbmdzKSB7XG4gIGRvIHtcbiAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsodW5pdE9mV29yay5hbHRlcm5hdGUsIHVuaXRPZldvcmspO1xuICAgIGlmIChudWxsICE9PSBuZXh0KSB7XG4gICAgICBuZXh0LmZsYWdzICY9IDMyNzY3O1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXh0ID0gdW5pdE9mV29yay5yZXR1cm47XG4gICAgbnVsbCAhPT0gbmV4dCAmJlxuICAgICAgKChuZXh0LmZsYWdzIHw9IDMyNzY4KSwgKG5leHQuc3VidHJlZUZsYWdzID0gMCksIChuZXh0LmRlbGV0aW9ucyA9IG51bGwpKTtcbiAgICBpZiAoXG4gICAgICAhc2tpcFNpYmxpbmdzICYmXG4gICAgICAoKHVuaXRPZldvcmsgPSB1bml0T2ZXb3JrLnNpYmxpbmcpLCBudWxsICE9PSB1bml0T2ZXb3JrKVxuICAgICkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcmsgPSBuZXh0O1xuICB9IHdoaWxlIChudWxsICE9PSB1bml0T2ZXb3JrKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDY7XG4gIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdFJvb3QoXG4gIHJvb3QsXG4gIHJlY292ZXJhYmxlRXJyb3JzLFxuICB0cmFuc2l0aW9ucyxcbiAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICBzcGF3bmVkTGFuZSxcbiAgdXBkYXRlZExhbmVzLFxuICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gMiksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgY29tbWl0Um9vdEltcGwoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwoXG4gIHJvb3QsXG4gIHJlY292ZXJhYmxlRXJyb3JzLFxuICB0cmFuc2l0aW9ucyxcbiAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICByZW5kZXJQcmlvcml0eUxldmVsLFxuICBzcGF3bmVkTGFuZSxcbiAgdXBkYXRlZExhbmVzLFxuICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4pIHtcbiAgZG8gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB3aGlsZSAobnVsbCAhPT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpO1xuICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiA2KSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMjcpKTtcbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgPSByb290LmZpbmlzaGVkTGFuZXM7XG4gIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmspIHJldHVybiBudWxsO1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IDA7XG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNzcpKTtcbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBmaW5pc2hlZFdvcmsubGFuZXMgfCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcztcbiAgcmVtYWluaW5nTGFuZXMgfD0gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xuICBtYXJrUm9vdEZpbmlzaGVkKFxuICAgIHJvb3QsXG4gICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgIHNwYXduZWRMYW5lLFxuICAgIHVwZGF0ZWRMYW5lcyxcbiAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICk7XG4gIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICgod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSk7XG4gICgwID09PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KSAmJlxuICAgIDAgPT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1NikpIHx8XG4gICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgfHxcbiAgICAoKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITApLFxuICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzKSxcbiAgICAocGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zKSxcbiAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cyghMCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KSk7XG4gIHRyYW5zaXRpb25zID0gMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDE1OTkwKTtcbiAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxNTk5MCkgfHwgdHJhbnNpdGlvbnNcbiAgICA/ICgodHJhbnNpdGlvbnMgPSBSZWFjdFNoYXJlZEludGVybmFscy5UKSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAoc3Bhd25lZExhbmUgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wKSxcbiAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gMiksXG4gICAgICAodXBkYXRlZExhbmVzID0gZXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAoZXhlY3V0aW9uQ29udGV4dCB8PSA0KSxcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpLFxuICAgICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbiwgcm9vdC5jb250YWluZXJJbmZvKSxcbiAgICAgIChfZW5hYmxlZCA9ICEhZXZlbnRzRW5hYmxlZCksXG4gICAgICAoc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBldmVudHNFbmFibGVkID0gbnVsbCksXG4gICAgICAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKSxcbiAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKSxcbiAgICAgIHJlcXVlc3RQYWludCgpLFxuICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSB1cGRhdGVkTGFuZXMpLFxuICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBzcGF3bmVkTGFuZSksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHRyYW5zaXRpb25zKSlcbiAgICA6IChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspO1xuICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0c1xuICAgID8gKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExKSxcbiAgICAgIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IHJvb3QpLFxuICAgICAgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSlcbiAgICA6IHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAwID09PSByZW1haW5pbmdMYW5lcyAmJiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsKTtcbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIGlmIChudWxsICE9PSByZWNvdmVyYWJsZUVycm9ycylcbiAgICBmb3IgKFxuICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yLCBmaW5pc2hlZFdvcmsgPSAwO1xuICAgICAgZmluaXNoZWRXb3JrIDwgcmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoO1xuICAgICAgZmluaXNoZWRXb3JrKytcbiAgICApXG4gICAgICAocmVtYWluaW5nTGFuZXMgPSByZWNvdmVyYWJsZUVycm9yc1tmaW5pc2hlZFdvcmtdKSxcbiAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbChyZW1haW5pbmdMYW5lcy52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiByZW1haW5pbmdMYW5lcy5zdGFja1xuICAgICAgICB9KTtcbiAgMCAhPT0gKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzICYgMykgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAwICE9PSAoZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlICYgNDE5NDIxOCkgJiYgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgPyByb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXNcbiAgICAgID8gbmVzdGVkVXBkYXRlQ291bnQrK1xuICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290KSlcbiAgICA6IChuZXN0ZWRVcGRhdGVDb3VudCA9IDApO1xuICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcykge1xuICAwID09PSAocm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzKSAmJlxuICAgICgocmVtYWluaW5nTGFuZXMgPSByb290LnBvb2xlZENhY2hlKSxcbiAgICBudWxsICE9IHJlbWFpbmluZ0xhbmVzICYmXG4gICAgICAoKHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsKSwgcmVsZWFzZUNhY2hlKHJlbWFpbmluZ0xhbmVzKSkpO1xufVxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgaWYgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgdmFyIHJvb3QkMTcwID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMDtcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyksXG4gICAgICBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICB0cnkge1xuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IDMyID4gcmVuZGVyUHJpb3JpdHkgPyAzMiA6IHJlbmRlclByaW9yaXR5O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICBpZiAobnVsbCA9PT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIGVsc2Uge1xuICAgICAgICByZW5kZXJQcmlvcml0eSA9IHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7XG4gICAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgICAgIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gICAgICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwO1xuICAgICAgICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiA2KSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMzMSkpO1xuICAgICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgICBleGVjdXRpb25Db250ZXh0IHw9IDQ7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihyb290LmN1cnJlbnQpO1xuICAgICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKHJvb3QsIHJvb3QuY3VycmVudCwgbGFuZXMsIHJlbmRlclByaW9yaXR5KTtcbiAgICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290XG4gICAgICAgIClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCQxNzAsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICBzb3VyY2VGaWJlciA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBzb3VyY2VGaWJlciwgMik7XG4gIHJvb3RGaWJlciA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgMik7XG4gIG51bGwgIT09IHJvb3RGaWJlciAmJlxuICAgIChtYXJrUm9vdFVwZGF0ZWQkMShyb290RmliZXIsIDIpLCBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdEZpYmVyKSk7XG59XG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpIHtcbiAgaWYgKDMgPT09IHNvdXJjZUZpYmVyLnRhZylcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yKTtcbiAgZWxzZVxuICAgIGZvciAoOyBudWxsICE9PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yOyApIHtcbiAgICAgIGlmICgzID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICgxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgIHR5cGVvZiBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSkpKVxuICAgICAgICApIHtcbiAgICAgICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgZXJyb3IgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKDIpO1xuICAgICAgICAgIGluc3RhbmNlID0gZW5xdWV1ZVVwZGF0ZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciwgMik7XG4gICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgIChpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1hcmtSb290VXBkYXRlZCQxKGluc3RhbmNlLCAyKSxcbiAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5yZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIGlmIChudWxsID09PSBwaW5nQ2FjaGUpIHtcbiAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICB2YXIgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZVxuICAgICh0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKSksXG4gICAgICB2b2lkIDAgPT09IHRocmVhZElEcyAmJlxuICAgICAgICAoKHRocmVhZElEcyA9IG5ldyBTZXQoKSksIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcykpO1xuICB0aHJlYWRJRHMuaGFzKGxhbmVzKSB8fFxuICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITApLFxuICAgIHRocmVhZElEcy5hZGQobGFuZXMpLFxuICAgIChyb290ID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpKSxcbiAgICB3YWtlYWJsZS50aGVuKHJvb3QsIHJvb3QpKTtcbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIG51bGwgIT09IHBpbmdDYWNoZSAmJiBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgcm9vdC5waW5nZWRMYW5lcyB8PSByb290LnN1c3BlbmRlZExhbmVzICYgcGluZ2VkTGFuZXM7XG4gIHJvb3Qud2FybUxhbmVzICY9IH5waW5nZWRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgcGluZ2VkTGFuZXMpID09PSBwaW5nZWRMYW5lcyAmJlxuICAgICg0ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIHx8XG4gICAgKDMgPT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiZcbiAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSA9PT1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgIDMwMCA+IG5vdygpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSlcbiAgICAgID8gMCA9PT0gKGV4ZWN1dGlvbkNvbnRleHQgJiAyKSAmJiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKVxuICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgfD0gcGluZ2VkTGFuZXMpLFxuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwKSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbn1cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgMCA9PT0gcmV0cnlMYW5lICYmIChyZXRyeUxhbmUgPSBjbGFpbU5leHRSZXRyeUxhbmUoKSk7XG4gIGJvdW5kYXJ5RmliZXIgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbiAgbnVsbCAhPT0gYm91bmRhcnlGaWJlciAmJlxuICAgIChtYXJrUm9vdFVwZGF0ZWQkMShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpLFxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChib3VuZGFyeUZpYmVyKSk7XG59XG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgcmV0cnlMYW5lID0gMDtcbiAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gIHZhciByZXRyeUxhbmUgPSAwO1xuICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgY2FzZSAxMzpcbiAgICAgIHZhciByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTk6XG4gICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlLl9yZXRyeUNhY2hlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzE0KSk7XG4gIH1cbiAgbnVsbCAhPT0gcmV0cnlDYWNoZSAmJiByZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayQxKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xufVxudmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMSxcbiAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITEsXG4gIGlzRmx1c2hpbmdXb3JrID0gITEsXG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMDtcbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gIHJvb3QgIT09IGxhc3RTY2hlZHVsZWRSb290ICYmXG4gICAgbnVsbCA9PT0gcm9vdC5uZXh0ICYmXG4gICAgKG51bGwgPT09IGxhc3RTY2hlZHVsZWRSb290XG4gICAgICA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3QpXG4gICAgICA6IChsYXN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290KSk7XG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICBkaWRTY2hlZHVsZU1pY3JvdGFzayB8fFxuICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMCksXG4gICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpO1xufVxuZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgb25seUxlZ2FjeSkge1xuICBpZiAoIWlzRmx1c2hpbmdXb3JrICYmIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yaykge1xuICAgIGlzRmx1c2hpbmdXb3JrID0gITA7XG4gICAgZG8ge1xuICAgICAgdmFyIGRpZFBlcmZvcm1Tb21lV29yayA9ICExO1xuICAgICAgZm9yICh2YXIgcm9vdCQxNzIgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7IG51bGwgIT09IHJvb3QkMTcyOyApIHtcbiAgICAgICAgaWYgKCFvbmx5TGVnYWN5KVxuICAgICAgICAgIGlmICgwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdCQxNzIucGVuZGluZ0xhbmVzO1xuICAgICAgICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IDA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdCQxNzIuc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290JDE3Mi5waW5nZWRMYW5lcztcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAoMSA8PCAoMzEgLSBjbHozMig0MiB8IHN5bmNUcmFuc2l0aW9uTGFuZXMpICsgMSkpIC0gMTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICY9XG4gICAgICAgICAgICAgICAgcGVuZGluZ0xhbmVzICYgfihzdXNwZW5kZWRMYW5lcyAmIH5waW5nZWRMYW5lcyk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYgMjAxMzI2Njc3XG4gICAgICAgICAgICAgICAgICA/IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiAyMDEzMjY2NzcpIHwgMVxuICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgPyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgfCAyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDAgIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QkMTcyLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgICAgICAgICAgcm9vdCQxNzIsXG4gICAgICAgICAgICAgICAgcm9vdCQxNzIgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA6IDBcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIDAgPT09IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiAzKSB8fFxuICAgICAgICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCQxNzIsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgfHxcbiAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCQxNzIsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkpO1xuICAgICAgICByb290JDE3MiA9IHJvb3QkMTcyLm5leHQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZGlkUGVyZm9ybVNvbWVXb3JrKTtcbiAgICBpc0ZsdXNoaW5nV29yayA9ICExO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKSB7XG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IGRpZFNjaGVkdWxlTWljcm90YXNrID0gITE7XG4gIHZhciBzeW5jVHJhbnNpdGlvbkxhbmVzID0gMDtcbiAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAoc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpICYmXG4gICAgICAoc3luY1RyYW5zaXRpb25MYW5lcyA9IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSxcbiAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwKSk7XG4gIGZvciAoXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbm93KCksIHByZXYgPSBudWxsLCByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIG51bGwgIT09IHJvb3Q7XG5cbiAgKSB7XG4gICAgdmFyIG5leHQgPSByb290Lm5leHQsXG4gICAgICBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcbiAgICBpZiAoMCA9PT0gbmV4dExhbmVzKVxuICAgICAgKHJvb3QubmV4dCA9IG51bGwpLFxuICAgICAgICBudWxsID09PSBwcmV2ID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQpIDogKHByZXYubmV4dCA9IG5leHQpLFxuICAgICAgICBudWxsID09PSBuZXh0ICYmIChsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXYpO1xuICAgIGVsc2UgaWYgKFxuICAgICAgKChwcmV2ID0gcm9vdCksIDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMgfHwgMCAhPT0gKG5leHRMYW5lcyAmIDMpKVxuICAgIClcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgIHJvb3QgPSBuZXh0O1xuICB9XG4gIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsICExKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgZm9yIChcbiAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICBsYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTYyOTE0NTYxO1xuICAgIDAgPCBsYW5lcztcblxuICApIHtcbiAgICB2YXIgaW5kZXgkNSA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNSxcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4JDVdO1xuICAgIGlmICgtMSA9PT0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGlmICgwID09PSAobGFuZSAmIHN1c3BlbmRlZExhbmVzKSB8fCAwICE9PSAobGFuZSAmIHBpbmdlZExhbmVzKSlcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4JDVdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2UgZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUgJiYgKHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmUpO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG4gIGN1cnJlbnRUaW1lID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICBzdXNwZW5kZWRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICBzdXNwZW5kZWRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICByb290LFxuICAgIHJvb3QgPT09IGN1cnJlbnRUaW1lID8gc3VzcGVuZGVkTGFuZXMgOiAwXG4gICk7XG4gIHBpbmdlZExhbmVzID0gcm9vdC5jYWxsYmFja05vZGU7XG4gIGlmIChcbiAgICAwID09PSBzdXNwZW5kZWRMYW5lcyB8fFxuICAgIChyb290ID09PSBjdXJyZW50VGltZSAmJiAyID09PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikgfHxcbiAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgKVxuICAgIHJldHVybiAoXG4gICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJlxuICAgICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJlxuICAgICAgICBjYW5jZWxDYWxsYmFjayQxKHBpbmdlZExhbmVzKSxcbiAgICAgIChyb290LmNhbGxiYWNrTm9kZSA9IG51bGwpLFxuICAgICAgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApXG4gICAgKTtcbiAgaWYgKFxuICAgIDAgPT09IChzdXNwZW5kZWRMYW5lcyAmIDMpIHx8XG4gICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBzdXNwZW5kZWRMYW5lcylcbiAgKSB7XG4gICAgY3VycmVudFRpbWUgPSBzdXNwZW5kZWRMYW5lcyAmIC1zdXNwZW5kZWRMYW5lcztcbiAgICBpZiAoY3VycmVudFRpbWUgPT09IHJvb3QuY2FsbGJhY2tQcmlvcml0eSkgcmV0dXJuIGN1cnJlbnRUaW1lO1xuICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrJDEocGluZ2VkTGFuZXMpO1xuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkoc3VzcGVuZGVkTGFuZXMpKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHN1c3BlbmRlZExhbmVzID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzMjpcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgfVxuICAgIHBpbmdlZExhbmVzID0gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdCk7XG4gICAgc3VzcGVuZGVkTGFuZXMgPSBzY2hlZHVsZUNhbGxiYWNrJDMoc3VzcGVuZGVkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBjdXJyZW50VGltZTtcbiAgICByb290LmNhbGxiYWNrTm9kZSA9IHN1c3BlbmRlZExhbmVzO1xuICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgfVxuICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayQxKHBpbmdlZExhbmVzKTtcbiAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMjtcbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayhyb290LCBkaWRUaW1lb3V0KSB7XG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpICYmIHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gZ2V0TmV4dExhbmVzKFxuICAgIHJvb3QsXG4gICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgOiAwXG4gICk7XG4gIGlmICgwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCkgcmV0dXJuIG51bGw7XG4gIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwLCBkaWRUaW1lb3V0KTtcbiAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsICE9IHJvb3QuY2FsbGJhY2tOb2RlICYmIHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZVxuICAgID8gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdClcbiAgICA6IG51bGw7XG59XG5mdW5jdGlvbiBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSkgcmV0dXJuIG51bGw7XG4gIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCAhMCk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUltbWVkaWF0ZVRhc2soY2IpIHtcbiAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgNilcbiAgICAgID8gc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYilcbiAgICAgIDogY2IoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gIDAgPT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSk7XG4gIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbn1cbmZ1bmN0aW9uIGNvZXJjZUZvcm1BY3Rpb25Qcm9wKGFjdGlvblByb3ApIHtcbiAgcmV0dXJuIG51bGwgPT0gYWN0aW9uUHJvcCB8fFxuICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wIHx8XG4gICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wXG4gICAgPyBudWxsXG4gICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wXG4gICAgICA/IGFjdGlvblByb3BcbiAgICAgIDogc2FuaXRpemVVUkwoXCJcIiArIGFjdGlvblByb3ApO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybURhdGFXaXRoU3VibWl0dGVyKGZvcm0sIHN1Ym1pdHRlcikge1xuICB2YXIgdGVtcCA9IHN1Ym1pdHRlci5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgdGVtcC5uYW1lID0gc3VibWl0dGVyLm5hbWU7XG4gIHRlbXAudmFsdWUgPSBzdWJtaXR0ZXIudmFsdWU7XG4gIGZvcm0uaWQgJiYgdGVtcC5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIGZvcm0uaWQpO1xuICBzdWJtaXR0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGVtcCwgc3VibWl0dGVyKTtcbiAgZm9ybSA9IG5ldyBGb3JtRGF0YShmb3JtKTtcbiAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXApO1xuICByZXR1cm4gZm9ybTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkMShcbiAgZGlzcGF0Y2hRdWV1ZSxcbiAgZG9tRXZlbnROYW1lLFxuICBtYXliZVRhcmdldEluc3QsXG4gIG5hdGl2ZUV2ZW50LFxuICBuYXRpdmVFdmVudFRhcmdldFxuKSB7XG4gIGlmIChcbiAgICBcInN1Ym1pdFwiID09PSBkb21FdmVudE5hbWUgJiZcbiAgICBtYXliZVRhcmdldEluc3QgJiZcbiAgICBtYXliZVRhcmdldEluc3Quc3RhdGVOb2RlID09PSBuYXRpdmVFdmVudFRhcmdldFxuICApIHtcbiAgICB2YXIgYWN0aW9uID0gY29lcmNlRm9ybUFjdGlvblByb3AoXG4gICAgICAgIChuYXRpdmVFdmVudFRhcmdldFtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsKS5hY3Rpb25cbiAgICAgICksXG4gICAgICBzdWJtaXR0ZXIgPSBuYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgc3VibWl0dGVyICYmXG4gICAgICAoKGRvbUV2ZW50TmFtZSA9IChkb21FdmVudE5hbWUgPSBzdWJtaXR0ZXJbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbClcbiAgICAgICAgPyBjb2VyY2VGb3JtQWN0aW9uUHJvcChkb21FdmVudE5hbWUuZm9ybUFjdGlvbilcbiAgICAgICAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKSksXG4gICAgICBudWxsICE9PSBkb21FdmVudE5hbWUgJiYgKChhY3Rpb24gPSBkb21FdmVudE5hbWUpLCAoc3VibWl0dGVyID0gbnVsbCkpKTtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICBcImFjdGlvblwiLFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIG51bGwsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgKTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKDAgIT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gc3VibWl0dGVyXG4gICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihuYXRpdmVFdmVudFRhcmdldCwgc3VibWl0dGVyKVxuICAgICAgICAgICAgICAgICAgOiBuZXcgRm9ybURhdGEobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0SG9zdFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgICBtYXliZVRhcmdldEluc3QsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBuYXRpdmVFdmVudFRhcmdldC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZvcm1EYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiAmJlxuICAgICAgICAgICAgICAgIChldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgIChmb3JtRGF0YSA9IHN1Ym1pdHRlclxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGb3JtRGF0YVdpdGhTdWJtaXR0ZXIobmF0aXZlRXZlbnRUYXJnZXQsIHN1Ym1pdHRlcilcbiAgICAgICAgICAgICAgICAgIDogbmV3IEZvcm1EYXRhKG5hdGl2ZUV2ZW50VGFyZ2V0KSksXG4gICAgICAgICAgICAgICAgc3RhcnRIb3N0VHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgIG1heWJlVGFyZ2V0SW5zdCxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogITAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDogbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG59XG5mb3IgKFxuICB2YXIgaSRqc2NvbXAkaW5saW5lXzE0MzkgPSAwO1xuICBpJGpzY29tcCRpbmxpbmVfMTQzOSA8IHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzLmxlbmd0aDtcbiAgaSRqc2NvbXAkaW5saW5lXzE0MzkrK1xuKSB7XG4gIHZhciBldmVudE5hbWUkanNjb21wJGlubGluZV8xNDQwID1cbiAgICAgIHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzW2kkanNjb21wJGlubGluZV8xNDM5XSxcbiAgICBkb21FdmVudE5hbWUkanNjb21wJGlubGluZV8xNDQxID1cbiAgICAgIGV2ZW50TmFtZSRqc2NvbXAkaW5saW5lXzE0NDAudG9Mb3dlckNhc2UoKSxcbiAgICBjYXBpdGFsaXplZEV2ZW50JGpzY29tcCRpbmxpbmVfMTQ0MiA9XG4gICAgICBldmVudE5hbWUkanNjb21wJGlubGluZV8xNDQwWzBdLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgZXZlbnROYW1lJGpzY29tcCRpbmxpbmVfMTQ0MC5zbGljZSgxKTtcbiAgcmVnaXN0ZXJTaW1wbGVFdmVudChcbiAgICBkb21FdmVudE5hbWUkanNjb21wJGlubGluZV8xNDQxLFxuICAgIFwib25cIiArIGNhcGl0YWxpemVkRXZlbnQkanNjb21wJGlubGluZV8xNDQyXG4gICk7XG59XG5yZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9FTkQsIFwib25BbmltYXRpb25FbmRcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9JVEVSQVRJT04sIFwib25BbmltYXRpb25JdGVyYXRpb25cIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9TVEFSVCwgXCJvbkFuaW1hdGlvblN0YXJ0XCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChcImRibGNsaWNrXCIsIFwib25Eb3VibGVDbGlja1wiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJmb2N1c2luXCIsIFwib25Gb2N1c1wiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJmb2N1c291dFwiLCBcIm9uQmx1clwiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9SVU4sIFwib25UcmFuc2l0aW9uUnVuXCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX1NUQVJULCBcIm9uVHJhbnNpdGlvblN0YXJ0XCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX0NBTkNFTCwgXCJvblRyYW5zaXRpb25DYW5jZWxcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fRU5ELCBcIm9uVHJhbnNpdGlvbkVuZFwiKTtcbnJlZ2lzdGVyRGlyZWN0RXZlbnQoXCJvbk1vdXNlRW50ZXJcIiwgW1wibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIl0pO1xucmVnaXN0ZXJEaXJlY3RFdmVudChcIm9uTW91c2VMZWF2ZVwiLCBbXCJtb3VzZW91dFwiLCBcIm1vdXNlb3ZlclwiXSk7XG5yZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyRW50ZXJcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbnJlZ2lzdGVyRGlyZWN0RXZlbnQoXCJvblBvaW50ZXJMZWF2ZVwiLCBbXCJwb2ludGVyb3V0XCIsIFwicG9pbnRlcm92ZXJcIl0pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uQ2hhbmdlXCIsXG4gIFwiY2hhbmdlIGNsaWNrIGZvY3VzaW4gZm9jdXNvdXQgaW5wdXQga2V5ZG93biBrZXl1cCBzZWxlY3Rpb25jaGFuZ2VcIi5zcGxpdChcIiBcIilcbik7XG5yZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gIFwib25TZWxlY3RcIixcbiAgXCJmb2N1c291dCBjb250ZXh0bWVudSBkcmFnZW5kIGZvY3VzaW4ga2V5ZG93biBrZXl1cCBtb3VzZWRvd24gbW91c2V1cCBzZWxlY3Rpb25jaGFuZ2VcIi5zcGxpdChcbiAgICBcIiBcIlxuICApXG4pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFwib25CZWZvcmVJbnB1dFwiLCBbXG4gIFwiY29tcG9zaXRpb25lbmRcIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcInRleHRJbnB1dFwiLFxuICBcInBhc3RlXCJcbl0pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uQ29tcG9zaXRpb25FbmRcIixcbiAgXCJjb21wb3NpdGlvbmVuZCBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKVxuKTtcbnJlZ2lzdGVyVHdvUGhhc2VFdmVudChcbiAgXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbiAgXCJjb21wb3NpdGlvbnN0YXJ0IGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpXG4pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgXCJjb21wb3NpdGlvbnVwZGF0ZSBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKVxuKTtcbnZhciBtZWRpYUV2ZW50VHlwZXMgPVxuICAgIFwiYWJvcnQgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBkdXJhdGlvbmNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBsb2FkZWRkYXRhIGxvYWRlZG1ldGFkYXRhIGxvYWRzdGFydCBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZWNoYW5nZSByZXNpemUgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmdcIi5zcGxpdChcbiAgICAgIFwiIFwiXG4gICAgKSxcbiAgbm9uRGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldChcbiAgICBcImJlZm9yZXRvZ2dsZSBjYW5jZWwgY2xvc2UgaW52YWxpZCBsb2FkIHNjcm9sbCBzY3JvbGxlbmQgdG9nZ2xlXCJcbiAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgIC5jb25jYXQobWVkaWFFdmVudFR5cGVzKVxuICApO1xuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICBldmVudFN5c3RlbUZsYWdzID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9kaXNwYXRjaFF1ZXVlJGkgPSBkaXNwYXRjaFF1ZXVlW2ldLFxuICAgICAgZXZlbnQgPSBfZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50O1xuICAgIF9kaXNwYXRjaFF1ZXVlJGkgPSBfZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztcbiAgICBhOiB7XG4gICAgICB2YXIgcHJldmlvdXNJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICAgIGlmIChldmVudFN5c3RlbUZsYWdzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBpJGpzY29tcCQwID0gX2Rpc3BhdGNoUXVldWUkaS5sZW5ndGggLSAxO1xuICAgICAgICAgIDAgPD0gaSRqc2NvbXAkMDtcbiAgICAgICAgICBpJGpzY29tcCQwLS1cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoUXVldWUkaVtpJGpzY29tcCQwXSxcbiAgICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuY3VycmVudFRhcmdldDtcbiAgICAgICAgICBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmxpc3RlbmVyO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBwcmV2aW91c0luc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGk7XG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UoZXZlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgIGkkanNjb21wJDAgPCBfZGlzcGF0Y2hRdWV1ZSRpLmxlbmd0aDtcbiAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hRdWV1ZSRpW2kkanNjb21wJDBdO1xuICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2U7XG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpO1xuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcmV2aW91c0luc3RhbmNlKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB0YXJnZXRFbGVtZW50W2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG4gIHZvaWQgMCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHRhcmdldEVsZW1lbnRbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9XG4gICAgICBuZXcgU2V0KCkpO1xuICB2YXIgbGlzdGVuZXJTZXRLZXkgPSBkb21FdmVudE5hbWUgKyBcIl9fYnViYmxlXCI7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5oYXMobGlzdGVuZXJTZXRLZXkpIHx8XG4gICAgKGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsIGRvbUV2ZW50TmFtZSwgMiwgITEpLFxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5hZGQobGlzdGVuZXJTZXRLZXkpKTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50U3lzdGVtRmxhZ3MgPSAwO1xuICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyICYmIChldmVudFN5c3RlbUZsYWdzIHw9IDQpO1xuICBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgZG9tRXZlbnROYW1lLFxuICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lclxuICApO1xufVxudmFyIGxpc3RlbmluZ01hcmtlciA9IFwiX3JlYWN0TGlzdGVuaW5nXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIGlmICghcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSkge1xuICAgIHJvb3RDb250YWluZXJFbGVtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMDtcbiAgICBhbGxOYXRpdmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9tRXZlbnROYW1lKSB7XG4gICAgICBcInNlbGVjdGlvbmNoYW5nZVwiICE9PSBkb21FdmVudE5hbWUgJiZcbiAgICAgICAgKG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSB8fFxuICAgICAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCAhMSwgcm9vdENvbnRhaW5lckVsZW1lbnQpLFxuICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgITAsIHJvb3RDb250YWluZXJFbGVtZW50KSk7XG4gICAgfSk7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPVxuICAgICAgOSA9PT0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGVcbiAgICAgICAgPyByb290Q29udGFpbmVyRWxlbWVudFxuICAgICAgICA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgbnVsbCA9PT0gb3duZXJEb2N1bWVudCB8fFxuICAgICAgb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdIHx8XG4gICAgICAoKG93bmVyRG9jdW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9ICEwKSxcbiAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgITEsIG93bmVyRG9jdW1lbnQpKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIoXG4gIHRhcmdldENvbnRhaW5lcixcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4pIHtcbiAgc3dpdGNoIChnZXRFdmVudFByaW9yaXR5KGRvbUV2ZW50TmFtZSkpIHtcbiAgICBjYXNlIDI6XG4gICAgICB2YXIgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hDb250aW51b3VzRXZlbnQ7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hFdmVudDtcbiAgfVxuICBldmVudFN5c3RlbUZsYWdzID0gbGlzdGVuZXJXcmFwcGVyLmJpbmQoXG4gICAgbnVsbCxcbiAgICBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICB0YXJnZXRDb250YWluZXJcbiAgKTtcbiAgbGlzdGVuZXJXcmFwcGVyID0gdm9pZCAwO1xuICAhcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgfHxcbiAgICAoXCJ0b3VjaHN0YXJ0XCIgIT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgXCJ0b3VjaG1vdmVcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICBcIndoZWVsXCIgIT09IGRvbUV2ZW50TmFtZSkgfHxcbiAgICAobGlzdGVuZXJXcmFwcGVyID0gITApO1xuICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgPyB2b2lkIDAgIT09IGxpc3RlbmVyV3JhcHBlclxuICAgICAgPyB0YXJnZXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHtcbiAgICAgICAgICBjYXB0dXJlOiAhMCxcbiAgICAgICAgICBwYXNzaXZlOiBsaXN0ZW5lcldyYXBwZXJcbiAgICAgICAgfSlcbiAgICAgIDogdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCAhMClcbiAgICA6IHZvaWQgMCAhPT0gbGlzdGVuZXJXcmFwcGVyXG4gICAgICA/IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywge1xuICAgICAgICAgIHBhc3NpdmU6IGxpc3RlbmVyV3JhcHBlclxuICAgICAgICB9KVxuICAgICAgOiB0YXJnZXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsICExKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICBuYXRpdmVFdmVudCxcbiAgdGFyZ2V0SW5zdCRqc2NvbXAkMCxcbiAgdGFyZ2V0Q29udGFpbmVyXG4pIHtcbiAgdmFyIGFuY2VzdG9ySW5zdCA9IHRhcmdldEluc3QkanNjb21wJDA7XG4gIGlmIChcbiAgICAwID09PSAoZXZlbnRTeXN0ZW1GbGFncyAmIDEpICYmXG4gICAgMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiAyKSAmJlxuICAgIG51bGwgIT09IHRhcmdldEluc3QkanNjb21wJDBcbiAgKVxuICAgIGE6IGZvciAoOzspIHtcbiAgICAgIGlmIChudWxsID09PSB0YXJnZXRJbnN0JGpzY29tcCQwKSByZXR1cm47XG4gICAgICB2YXIgbm9kZVRhZyA9IHRhcmdldEluc3QkanNjb21wJDAudGFnO1xuICAgICAgaWYgKDMgPT09IG5vZGVUYWcgfHwgNCA9PT0gbm9kZVRhZykge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvbnRhaW5lciA9PT0gdGFyZ2V0Q29udGFpbmVyIHx8XG4gICAgICAgICAgKDggPT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJiBjb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGFyZ2V0Q29udGFpbmVyKVxuICAgICAgICApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICg0ID09PSBub2RlVGFnKVxuICAgICAgICAgIGZvciAobm9kZVRhZyA9IHRhcmdldEluc3QkanNjb21wJDAucmV0dXJuOyBudWxsICE9PSBub2RlVGFnOyApIHtcbiAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IG5vZGVUYWcudGFnO1xuICAgICAgICAgICAgaWYgKDMgPT09IGdyYW5kVGFnIHx8IDQgPT09IGdyYW5kVGFnKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChncmFuZFRhZyA9IG5vZGVUYWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgICAgIGdyYW5kVGFnID09PSB0YXJnZXRDb250YWluZXIgfHxcbiAgICAgICAgICAgICAgICAgICg4ID09PSBncmFuZFRhZy5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICBncmFuZFRhZy5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXIpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZVRhZyA9IG5vZGVUYWcucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgZm9yICg7IG51bGwgIT09IGNvbnRhaW5lcjsgKSB7XG4gICAgICAgICAgbm9kZVRhZyA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5vZGVUYWcpIHJldHVybjtcbiAgICAgICAgICBncmFuZFRhZyA9IG5vZGVUYWcudGFnO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDUgPT09IGdyYW5kVGFnIHx8XG4gICAgICAgICAgICA2ID09PSBncmFuZFRhZyB8fFxuICAgICAgICAgICAgMjYgPT09IGdyYW5kVGFnIHx8XG4gICAgICAgICAgICAyNyA9PT0gZ3JhbmRUYWdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldEluc3QkanNjb21wJDAgPSBhbmNlc3Rvckluc3QgPSBub2RlVGFnO1xuICAgICAgICAgICAgY29udGludWUgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhcmdldEluc3QkanNjb21wJDAgPSB0YXJnZXRJbnN0JGpzY29tcCQwLnJldHVybjtcbiAgICB9XG4gIGJhdGNoZWRVcGRhdGVzJDEoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gYW5jZXN0b3JJbnN0LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCksXG4gICAgICBkaXNwYXRjaFF1ZXVlID0gW107XG4gICAgYToge1xuICAgICAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gcmVhY3ROYW1lKSB7XG4gICAgICAgIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudCxcbiAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IGRvbUV2ZW50TmFtZTtcbiAgICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgICAgIGlmICgwID09PSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSkgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IFwiZm9jdXNcIjtcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gXCJibHVyXCI7XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJlZm9yZWJsdXJcIjpcbiAgICAgICAgICBjYXNlIFwiYWZ0ZXJibHVyXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICAgICAgICBpZiAoMiA9PT0gbmF0aXZlRXZlbnQuYnV0dG9uKSBicmVhayBhO1xuICAgICAgICAgIGNhc2UgXCJhdXhjbGlja1wiOlxuICAgICAgICAgIGNhc2UgXCJkYmxjbGlja1wiOlxuICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICAgICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRyYWdcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2V4aXRcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2xlYXZlXCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdvdmVyXCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdzdGFydFwiOlxuICAgICAgICAgIGNhc2UgXCJkcm9wXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG91Y2hjYW5jZWxcIjpcbiAgICAgICAgICBjYXNlIFwidG91Y2hlbmRcIjpcbiAgICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRSQU5TSVRJT05fRU5EOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgIGNhc2UgXCJzY3JvbGxlbmRcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwid2hlZWxcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29weVwiOlxuICAgICAgICAgIGNhc2UgXCJjdXRcIjpcbiAgICAgICAgICBjYXNlIFwicGFzdGVcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICAgICAgY2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgIGNhc2UgXCJwb2ludGVyY2FuY2VsXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJkb3duXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJtb3ZlXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJvdXRcIjpcbiAgICAgICAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICAgICAgICBjYXNlIFwicG9pbnRlcnVwXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9nZ2xlXCI6XG4gICAgICAgICAgY2FzZSBcImJlZm9yZXRvZ2dsZVwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljVG9nZ2xlRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluQ2FwdHVyZVBoYXNlID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KSxcbiAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAhaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgIChcInNjcm9sbFwiID09PSBkb21FdmVudE5hbWUgfHwgXCJzY3JvbGxlbmRcIiA9PT0gZG9tRXZlbnROYW1lKSxcbiAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlXG4gICAgICAgICAgICA/IG51bGwgIT09IHJlYWN0TmFtZVxuICAgICAgICAgICAgICA/IHJlYWN0TmFtZSArIFwiQ2FwdHVyZVwiXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgOiByZWFjdE5hbWU7XG4gICAgICAgIGluQ2FwdHVyZVBoYXNlID0gW107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gdGFyZ2V0SW5zdCwgbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2U7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID0gX2luc3RhbmNlLnN0YXRlTm9kZTtcbiAgICAgICAgICBfaW5zdGFuY2UgPSBfaW5zdGFuY2UudGFnO1xuICAgICAgICAgICg1ICE9PSBfaW5zdGFuY2UgJiYgMjYgIT09IF9pbnN0YW5jZSAmJiAyNyAhPT0gX2luc3RhbmNlKSB8fFxuICAgICAgICAgICAgbnVsbCA9PT0gbGFzdEhvc3RDb21wb25lbnQgfHxcbiAgICAgICAgICAgIG51bGwgPT09IHJlYWN0RXZlbnROYW1lIHx8XG4gICAgICAgICAgICAoKF9pbnN0YW5jZSA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdEV2ZW50TmFtZSkpLFxuICAgICAgICAgICAgbnVsbCAhPSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBfaW5zdGFuY2UsIGxhc3RIb3N0Q29tcG9uZW50KVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIGJyZWFrO1xuICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIDAgPCBpbkNhcHR1cmVQaGFzZS5sZW5ndGggJiZcbiAgICAgICAgICAoKHJlYWN0TmFtZSA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoXG4gICAgICAgICAgICByZWFjdE5hbWUsXG4gICAgICAgICAgICByZWFjdEV2ZW50VHlwZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgKSksXG4gICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IHJlYWN0TmFtZSwgbGlzdGVuZXJzOiBpbkNhcHR1cmVQaGFzZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgwID09PSAoZXZlbnRTeXN0ZW1GbGFncyAmIDcpKSB7XG4gICAgICBhOiB7XG4gICAgICAgIHJlYWN0TmFtZSA9XG4gICAgICAgICAgXCJtb3VzZW92ZXJcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwicG9pbnRlcm92ZXJcIiA9PT0gZG9tRXZlbnROYW1lO1xuICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPVxuICAgICAgICAgIFwibW91c2VvdXRcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwicG9pbnRlcm91dFwiID09PSBkb21FdmVudE5hbWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICByZWFjdE5hbWUgJiZcbiAgICAgICAgICBuYXRpdmVFdmVudCAhPT0gY3VycmVudFJlcGxheWluZ0V2ZW50ICYmXG4gICAgICAgICAgKHJlYWN0RXZlbnRUeXBlID1cbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpICYmXG4gICAgICAgICAgKGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlYWN0RXZlbnRUeXBlKSB8fFxuICAgICAgICAgICAgcmVhY3RFdmVudFR5cGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0pXG4gICAgICAgIClcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICBpZiAoU3ludGhldGljRXZlbnRDdG9yIHx8IHJlYWN0TmFtZSkge1xuICAgICAgICAgIHJlYWN0TmFtZSA9XG4gICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgID8gbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgOiAocmVhY3ROYW1lID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZS5kZWZhdWx0VmlldyB8fCByZWFjdE5hbWUucGFyZW50V2luZG93XG4gICAgICAgICAgICAgICAgOiB3aW5kb3c7XG4gICAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3Rvcikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJlYWN0RXZlbnRUeXBlID1cbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudCksXG4gICAgICAgICAgICAgIChTeW50aGV0aWNFdmVudEN0b3IgPSB0YXJnZXRJbnN0KSxcbiAgICAgICAgICAgICAgKHJlYWN0RXZlbnRUeXBlID0gcmVhY3RFdmVudFR5cGVcbiAgICAgICAgICAgICAgICA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlYWN0RXZlbnRUeXBlKVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IHJlYWN0RXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgICAgKChhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAgICAgICBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHJlYWN0RXZlbnRUeXBlKSksXG4gICAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlID0gcmVhY3RFdmVudFR5cGUudGFnKSxcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSAhPT0gYWNjdW11bGF0ZVRhcmdldE9ubHkgfHxcbiAgICAgICAgICAgICAgICAgICg1ICE9PSBpbkNhcHR1cmVQaGFzZSAmJlxuICAgICAgICAgICAgICAgICAgICAyNyAhPT0gaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgNiAhPT0gaW5DYXB0dXJlUGhhc2UpKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSAoU3ludGhldGljRXZlbnRDdG9yID0gbnVsbCksIChyZWFjdEV2ZW50VHlwZSA9IHRhcmdldEluc3QpO1xuICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IgIT09IHJlYWN0RXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBcIm9uTW91c2VMZWF2ZVwiO1xuICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSBcIm9uTW91c2VFbnRlclwiO1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBcIm1vdXNlXCI7XG4gICAgICAgICAgICBpZiAoXCJwb2ludGVyb3V0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcInBvaW50ZXJvdmVyXCIgPT09IGRvbUV2ZW50TmFtZSlcbiAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlID0gU3ludGhldGljUG9pbnRlckV2ZW50KSxcbiAgICAgICAgICAgICAgICAoX2luc3RhbmNlID0gXCJvblBvaW50ZXJMZWF2ZVwiKSxcbiAgICAgICAgICAgICAgICAocmVhY3RFdmVudE5hbWUgPSBcIm9uUG9pbnRlckVudGVyXCIpLFxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID1cbiAgICAgICAgICAgICAgbnVsbCA9PSBTeW50aGV0aWNFdmVudEN0b3JcbiAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZVxuICAgICAgICAgICAgICAgIDogZ2V0Tm9kZUZyb21JbnN0YW5jZShTeW50aGV0aWNFdmVudEN0b3IpO1xuICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPVxuICAgICAgICAgICAgICBudWxsID09IHJlYWN0RXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgPyByZWFjdE5hbWVcbiAgICAgICAgICAgICAgICA6IGdldE5vZGVGcm9tSW5zdGFuY2UocmVhY3RFdmVudFR5cGUpO1xuICAgICAgICAgICAgcmVhY3ROYW1lID0gbmV3IGluQ2FwdHVyZVBoYXNlKFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGluc3RhbmNlICsgXCJsZWF2ZVwiLFxuICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlYWN0TmFtZS50YXJnZXQgPSBhY2N1bXVsYXRlVGFyZ2V0T25seTtcbiAgICAgICAgICAgIHJlYWN0TmFtZS5yZWxhdGVkVGFyZ2V0ID0gbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpID09PSB0YXJnZXRJbnN0ICYmXG4gICAgICAgICAgICAgICgoaW5DYXB0dXJlUGhhc2UgPSBuZXcgaW5DYXB0dXJlUGhhc2UoXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgKyBcImVudGVyXCIsXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZS50YXJnZXQgPSBsYXN0SG9zdENvbXBvbmVudCksXG4gICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZS5yZWxhdGVkVGFyZ2V0ID0gYWNjdW11bGF0ZVRhcmdldE9ubHkpLFxuICAgICAgICAgICAgICAoX2luc3RhbmNlID0gaW5DYXB0dXJlUGhhc2UpKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3RvciAmJiByZWFjdEV2ZW50VHlwZSlcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gU3ludGhldGljRXZlbnRDdG9yO1xuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lID0gcmVhY3RFdmVudFR5cGU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IGluQ2FwdHVyZVBoYXNlO1xuICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IGdldFBhcmVudChsYXN0SG9zdENvbXBvbmVudClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSsrO1xuICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlID0gcmVhY3RFdmVudE5hbWU7XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQYXJlbnQoX2luc3RhbmNlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50Kys7XG4gICAgICAgICAgICAgICAgZm9yICg7IDAgPCBpbnN0YW5jZSAtIGxhc3RIb3N0Q29tcG9uZW50OyApXG4gICAgICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UgPSBnZXRQYXJlbnQoaW5DYXB0dXJlUGhhc2UpKSwgaW5zdGFuY2UtLTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgMCA8IGxhc3RIb3N0Q29tcG9uZW50IC0gaW5zdGFuY2U7IClcbiAgICAgICAgICAgICAgICAgIChyZWFjdEV2ZW50TmFtZSA9IGdldFBhcmVudChyZWFjdEV2ZW50TmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudC0tO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpbnN0YW5jZS0tOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPT09IHJlYWN0RXZlbnROYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIChudWxsICE9PSByZWFjdEV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID09PSByZWFjdEV2ZW50TmFtZS5hbHRlcm5hdGUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IGdldFBhcmVudChpbkNhcHR1cmVQaGFzZSk7XG4gICAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IGdldFBhcmVudChyZWFjdEV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpbkNhcHR1cmVQaGFzZSA9IG51bGw7XG4gICAgICAgICAgICBudWxsICE9PSBTeW50aGV0aWNFdmVudEN0b3IgJiZcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgICAgIHJlYWN0TmFtZSxcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IsXG4gICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJlYWN0RXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGFjY3VtdWxhdGVUYXJnZXRPbmx5ICYmXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSxcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSxcbiAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICByZWFjdE5hbWUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID1cbiAgICAgICAgICByZWFjdE5hbWUubm9kZU5hbWUgJiYgcmVhY3ROYW1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcInNlbGVjdFwiID09PSBTeW50aGV0aWNFdmVudEN0b3IgfHxcbiAgICAgICAgICAoXCJpbnB1dFwiID09PSBTeW50aGV0aWNFdmVudEN0b3IgJiYgXCJmaWxlXCIgPT09IHJlYWN0TmFtZS50eXBlKVxuICAgICAgICApXG4gICAgICAgICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgICBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQocmVhY3ROYW1lKSlcbiAgICAgICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKVxuICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICAgICAgdmFyIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoU3ludGhldGljRXZlbnRDdG9yID0gcmVhY3ROYW1lLm5vZGVOYW1lKSxcbiAgICAgICAgICAgICFTeW50aGV0aWNFdmVudEN0b3IgfHxcbiAgICAgICAgICAgIFwiaW5wdXRcIiAhPT0gU3ludGhldGljRXZlbnRDdG9yLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgIChcImNoZWNrYm94XCIgIT09IHJlYWN0TmFtZS50eXBlICYmIFwicmFkaW9cIiAhPT0gcmVhY3ROYW1lLnR5cGUpXG4gICAgICAgICAgICAgID8gdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCh0YXJnZXRJbnN0LmVsZW1lbnRUeXBlKSAmJlxuICAgICAgICAgICAgICAgIChnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudClcbiAgICAgICAgICAgICAgOiAoZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyAmJlxuICAgICAgICAgIChnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jICYmIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHJlYWN0TmFtZSwgdGFyZ2V0SW5zdCk7XG4gICAgICAgIFwiZm9jdXNvdXRcIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHJlYWN0TmFtZS50eXBlICYmXG4gICAgICAgICAgbnVsbCAhPSB0YXJnZXRJbnN0Lm1lbW9pemVkUHJvcHMudmFsdWUgJiZcbiAgICAgICAgICBzZXREZWZhdWx0VmFsdWUocmVhY3ROYW1lLCBcIm51bWJlclwiLCByZWFjdE5hbWUudmFsdWUpO1xuICAgICAgfVxuICAgICAgaGFuZGxlRXZlbnRGdW5jID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVGV4dElucHV0RWxlbWVudChoYW5kbGVFdmVudEZ1bmMpIHx8XG4gICAgICAgICAgICBcInRydWVcIiA9PT0gaGFuZGxlRXZlbnRGdW5jLmNvbnRlbnRFZGl0YWJsZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChhY3RpdmVFbGVtZW50ID0gaGFuZGxlRXZlbnRGdW5jKSxcbiAgICAgICAgICAgICAgKGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdCksXG4gICAgICAgICAgICAgIChsYXN0U2VsZWN0aW9uID0gbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBhY3RpdmVFbGVtZW50SW5zdCA9IGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgICAgbW91c2VEb3duID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb250ZXh0bWVudVwiOlxuICAgICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgIG1vdXNlRG93biA9ICExO1xuICAgICAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjpcbiAgICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSBicmVhaztcbiAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgICAgY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHZhciBmYWxsYmFja0RhdGE7XG4gICAgICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudClcbiAgICAgICAgYjoge1xuICAgICAgICAgIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOlxuICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uU3RhcnRcIjtcbiAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICAgICAgICBldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25FbmRcIjtcbiAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOlxuICAgICAgICAgICAgICBldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIjtcbiAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnRUeXBlID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGlzQ29tcG9zaW5nXG4gICAgICAgICAgPyBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkgJiZcbiAgICAgICAgICAgIChldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25FbmRcIilcbiAgICAgICAgICA6IFwia2V5ZG93blwiID09PSBkb21FdmVudE5hbWUgJiZcbiAgICAgICAgICAgIDIyOSA9PT0gbmF0aXZlRXZlbnQua2V5Q29kZSAmJlxuICAgICAgICAgICAgKGV2ZW50VHlwZSA9IFwib25Db21wb3NpdGlvblN0YXJ0XCIpO1xuICAgICAgZXZlbnRUeXBlICYmXG4gICAgICAgICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJlxuICAgICAgICAgIFwia29cIiAhPT0gbmF0aXZlRXZlbnQubG9jYWxlICYmXG4gICAgICAgICAgKGlzQ29tcG9zaW5nIHx8IFwib25Db21wb3NpdGlvblN0YXJ0XCIgIT09IGV2ZW50VHlwZVxuICAgICAgICAgICAgPyBcIm9uQ29tcG9zaXRpb25FbmRcIiA9PT0gZXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgIGlzQ29tcG9zaW5nICYmXG4gICAgICAgICAgICAgIChmYWxsYmFja0RhdGEgPSBnZXREYXRhKCkpXG4gICAgICAgICAgICA6ICgocm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0KSxcbiAgICAgICAgICAgICAgKHN0YXJ0VGV4dCA9IFwidmFsdWVcIiBpbiByb290ID8gcm9vdC52YWx1ZSA6IHJvb3QudGV4dENvbnRlbnQpLFxuICAgICAgICAgICAgICAoaXNDb21wb3NpbmcgPSAhMCkpKSxcbiAgICAgICAgKGhhbmRsZUV2ZW50RnVuYyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCBldmVudFR5cGUpKSxcbiAgICAgICAgMCA8IGhhbmRsZUV2ZW50RnVuYy5sZW5ndGggJiZcbiAgICAgICAgICAoKGV2ZW50VHlwZSA9IG5ldyBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KFxuICAgICAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICApKSxcbiAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyBldmVudDogZXZlbnRUeXBlLCBsaXN0ZW5lcnM6IGhhbmRsZUV2ZW50RnVuYyB9KSxcbiAgICAgICAgICBmYWxsYmFja0RhdGFcbiAgICAgICAgICAgID8gKGV2ZW50VHlwZS5kYXRhID0gZmFsbGJhY2tEYXRhKVxuICAgICAgICAgICAgOiAoKGZhbGxiYWNrRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmFsbGJhY2tEYXRhICYmIChldmVudFR5cGUuZGF0YSA9IGZhbGxiYWNrRGF0YSkpKSk7XG4gICAgICBpZiAoXG4gICAgICAgIChmYWxsYmFja0RhdGEgPSBjYW5Vc2VUZXh0SW5wdXRFdmVudFxuICAgICAgICAgID8gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KVxuICAgICAgICAgIDogZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKVxuICAgICAgKVxuICAgICAgICAoZXZlbnRUeXBlID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIFwib25CZWZvcmVJbnB1dFwiKSksXG4gICAgICAgICAgMCA8IGV2ZW50VHlwZS5sZW5ndGggJiZcbiAgICAgICAgICAgICgoaGFuZGxlRXZlbnRGdW5jID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoXG4gICAgICAgICAgICAgIFwib25CZWZvcmVJbnB1dFwiLFxuICAgICAgICAgICAgICBcImJlZm9yZWlucHV0XCIsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICBldmVudDogaGFuZGxlRXZlbnRGdW5jLFxuICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGV2ZW50VHlwZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAoaGFuZGxlRXZlbnRGdW5jLmRhdGEgPSBmYWxsYmFja0RhdGEpKTtcbiAgICAgIGV4dHJhY3RFdmVudHMkMShcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICB0YXJnZXRJbnN0LFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHJldHVybiB7XG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0XG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIsIHJlYWN0TmFtZSkge1xuICBmb3IgKFxuICAgIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArIFwiQ2FwdHVyZVwiLCBsaXN0ZW5lcnMgPSBbXTtcbiAgICBudWxsICE9PSB0YXJnZXRGaWJlcjtcblxuICApIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IHRhcmdldEZpYmVyLFxuICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlMi5zdGF0ZU5vZGU7XG4gICAgX2luc3RhbmNlMiA9IF9pbnN0YW5jZTIudGFnO1xuICAgICg1ICE9PSBfaW5zdGFuY2UyICYmIDI2ICE9PSBfaW5zdGFuY2UyICYmIDI3ICE9PSBfaW5zdGFuY2UyKSB8fFxuICAgICAgbnVsbCA9PT0gc3RhdGVOb2RlIHx8XG4gICAgICAoKF9pbnN0YW5jZTIgPSBnZXRMaXN0ZW5lcih0YXJnZXRGaWJlciwgY2FwdHVyZU5hbWUpKSxcbiAgICAgIG51bGwgIT0gX2luc3RhbmNlMiAmJlxuICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChcbiAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKHRhcmdldEZpYmVyLCBfaW5zdGFuY2UyLCBzdGF0ZU5vZGUpXG4gICAgICAgICksXG4gICAgICAoX2luc3RhbmNlMiA9IGdldExpc3RlbmVyKHRhcmdldEZpYmVyLCByZWFjdE5hbWUpKSxcbiAgICAgIG51bGwgIT0gX2luc3RhbmNlMiAmJlxuICAgICAgICBsaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKHRhcmdldEZpYmVyLCBfaW5zdGFuY2UyLCBzdGF0ZU5vZGUpXG4gICAgICAgICkpO1xuICAgIHRhcmdldEZpYmVyID0gdGFyZ2V0RmliZXIucmV0dXJuO1xuICB9XG4gIHJldHVybiBsaXN0ZW5lcnM7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBpZiAobnVsbCA9PT0gaW5zdCkgcmV0dXJuIG51bGw7XG4gIGRvIGluc3QgPSBpbnN0LnJldHVybjtcbiAgd2hpbGUgKGluc3QgJiYgNSAhPT0gaW5zdC50YWcgJiYgMjcgIT09IGluc3QudGFnKTtcbiAgcmV0dXJuIGluc3QgPyBpbnN0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gIGRpc3BhdGNoUXVldWUsXG4gIGV2ZW50LFxuICB0YXJnZXQsXG4gIGNvbW1vbixcbiAgaW5DYXB0dXJlUGhhc2Vcbikge1xuICBmb3IgKFxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZSwgbGlzdGVuZXJzID0gW107XG4gICAgbnVsbCAhPT0gdGFyZ2V0ICYmIHRhcmdldCAhPT0gY29tbW9uO1xuXG4gICkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gdGFyZ2V0LFxuICAgICAgYWx0ZXJuYXRlID0gX2luc3RhbmNlMy5hbHRlcm5hdGUsXG4gICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UzLnN0YXRlTm9kZTtcbiAgICBfaW5zdGFuY2UzID0gX2luc3RhbmNlMy50YWc7XG4gICAgaWYgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikgYnJlYWs7XG4gICAgKDUgIT09IF9pbnN0YW5jZTMgJiYgMjYgIT09IF9pbnN0YW5jZTMgJiYgMjcgIT09IF9pbnN0YW5jZTMpIHx8XG4gICAgICBudWxsID09PSBzdGF0ZU5vZGUgfHxcbiAgICAgICgoYWx0ZXJuYXRlID0gc3RhdGVOb2RlKSxcbiAgICAgIGluQ2FwdHVyZVBoYXNlXG4gICAgICAgID8gKChzdGF0ZU5vZGUgPSBnZXRMaXN0ZW5lcih0YXJnZXQsIHJlZ2lzdHJhdGlvbk5hbWUpKSxcbiAgICAgICAgICBudWxsICE9IHN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoXG4gICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0LCBzdGF0ZU5vZGUsIGFsdGVybmF0ZSlcbiAgICAgICAgICAgICkpXG4gICAgICAgIDogaW5DYXB0dXJlUGhhc2UgfHxcbiAgICAgICAgICAoKHN0YXRlTm9kZSA9IGdldExpc3RlbmVyKHRhcmdldCwgcmVnaXN0cmF0aW9uTmFtZSkpLFxuICAgICAgICAgIG51bGwgIT0gc3RhdGVOb2RlICYmXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXQsIHN0YXRlTm9kZSwgYWx0ZXJuYXRlKVxuICAgICAgICAgICAgKSkpO1xuICAgIHRhcmdldCA9IHRhcmdldC5yZXR1cm47XG4gIH1cbiAgMCAhPT0gbGlzdGVuZXJzLmxlbmd0aCAmJlxuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IGV2ZW50OiBldmVudCwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMgfSk7XG59XG52YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZyxcbiAgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuZnVuY3Rpb24gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKG1hcmt1cCkge1xuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiBtYXJrdXAgPyBtYXJrdXAgOiBcIlwiICsgbWFya3VwKVxuICAgIC5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgXCJcXG5cIilcbiAgICAucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsIFwiXCIpO1xufVxuZnVuY3Rpb24gY2hlY2tGb3JVbm1hdGNoZWRUZXh0KHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgY2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgcmV0dXJuIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KSA9PT0gY2xpZW50VGV4dCA/ICEwIDogITE7XG59XG5mdW5jdGlvbiBub29wJDEoKSB7fVxuZnVuY3Rpb24gc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGtleSwgdmFsdWUsIHByb3BzLCBwcmV2VmFsdWUpIHtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICA/IFwiYm9keVwiID09PSB0YWcgfHxcbiAgICAgICAgICAoXCJ0ZXh0YXJlYVwiID09PSB0YWcgJiYgXCJcIiA9PT0gdmFsdWUpIHx8XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgdmFsdWUpXG4gICAgICAgIDogKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcImJpZ2ludFwiID09PSB0eXBlb2YgdmFsdWUpICYmXG4gICAgICAgICAgXCJib2R5XCIgIT09IHRhZyAmJlxuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwiY2xhc3NcIiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwidGFiaW5kZXhcIiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRpclwiOlxuICAgIGNhc2UgXCJyb2xlXCI6XG4gICAgY2FzZSBcInZpZXdCb3hcIjpcbiAgICBjYXNlIFwid2lkdGhcIjpcbiAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdGFnKSB7XG4gICAgICAgIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUoZG9tRWxlbWVudCwgXCJkYXRhXCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcInNyY1wiOlxuICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICBpZiAoXCJcIiA9PT0gdmFsdWUgJiYgKFwiYVwiICE9PSB0YWcgfHwgXCJocmVmXCIgIT09IGtleSkpIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFjdGlvblwiOlxuICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ0EgUmVhY3QgZm9ybSB3YXMgdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4gSWYgeW91IGNhbGxlZCBmb3JtLnN1Ym1pdCgpIG1hbnVhbGx5LCBjb25zaWRlciB1c2luZyBmb3JtLnJlcXVlc3RTdWJtaXQoKSBpbnN0ZWFkLiBJZiB5b3VcXFxcJ3JlIHRyeWluZyB0byB1c2UgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgaW4gYSBzdWJtaXQgZXZlbnQgaGFuZGxlciwgY29uc2lkZXIgYWxzbyBjYWxsaW5nIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuJylcIlxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAoXCJmb3JtQWN0aW9uXCIgPT09IGtleVxuICAgICAgICAgICAgPyAoXCJpbnB1dFwiICE9PSB0YWcgJiZcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJuYW1lXCIsIHByb3BzLm5hbWUsIHByb3BzLCBudWxsKSxcbiAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgICAgICAgICAgcHJvcHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIFwiZm9ybU1ldGhvZFwiLFxuICAgICAgICAgICAgICAgIHByb3BzLmZvcm1NZXRob2QsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIFwiZm9ybVRhcmdldFwiLFxuICAgICAgICAgICAgICAgIHByb3BzLmZvcm1UYXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiAoc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwiZW5jVHlwZVwiLCBwcm9wcy5lbmNUeXBlLCBwcm9wcywgbnVsbCksXG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcIm1ldGhvZFwiLCBwcm9wcy5tZXRob2QsIHByb3BzLCBudWxsKSxcbiAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwidGFyZ2V0XCIsIHByb3BzLnRhcmdldCwgcHJvcHMsIG51bGwpKSk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9uQ2xpY2tcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgKGRvbUVsZW1lbnQub25jbGljayA9IG5vb3AkMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvblNjcm9sbEVuZFwiOlxuICAgICAgbnVsbCAhPSB2YWx1ZSAmJiBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICBpZiAobnVsbCAhPSB2YWx1ZSkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHZhbHVlIHx8ICEoXCJfX2h0bWxcIiBpbiB2YWx1ZSkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MSkpO1xuICAgICAgICBrZXkgPSB2YWx1ZS5fX2h0bWw7XG4gICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmNoaWxkcmVuKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYwKSk7XG4gICAgICAgICAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgZG9tRWxlbWVudC5tdWx0aXBsZSA9XG4gICAgICAgIHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgZG9tRWxlbWVudC5tdXRlZCA9XG4gICAgICAgIHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICBjYXNlIFwicmVmXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtIcmVmXCI6XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInhsaW5rOmhyZWZcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAga2V5ID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIixcbiAgICAgICAga2V5XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICA/IGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKVxuICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgY2FzZSBcImFzeW5jXCI6XG4gICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgY2FzZSBcImhpZGRlblwiOlxuICAgIGNhc2UgXCJsb29wXCI6XG4gICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICBjYXNlIFwib3BlblwiOlxuICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAhMCA9PT0gdmFsdWVcbiAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgIDogITEgIT09IHZhbHVlICYmXG4gICAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgY2FzZSBcInJvd3NcIjpcbiAgICBjYXNlIFwic2l6ZVwiOlxuICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAhaXNOYU4odmFsdWUpICYmXG4gICAgICAxIDw9IHZhbHVlXG4gICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgOiBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgIGlzTmFOKHZhbHVlKVxuICAgICAgICA/IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSlcbiAgICAgICAgOiBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwb3BvdmVyXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiYmVmb3JldG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwicG9wb3ZlclwiLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtBcmNyb2xlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtSb2xlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtUaXRsZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazp0aXRsZVwiLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ4bGlua1R5cGVcIjpcbiAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgICAgIFwieGxpbms6dHlwZVwiLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgICAgIFwieG1sOmJhc2VcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgICAgICBcInhtbDpsYW5nXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhtbFNwYWNlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgICAgIFwieG1sOnNwYWNlXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlzXCI6XG4gICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBcImlzXCIsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbm5lclRleHRcIjpcbiAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoXG4gICAgICAgICEoMiA8IGtleS5sZW5ndGgpIHx8XG4gICAgICAgIChcIm9cIiAhPT0ga2V5WzBdICYmIFwiT1wiICE9PSBrZXlbMF0pIHx8XG4gICAgICAgIChcIm5cIiAhPT0ga2V5WzFdICYmIFwiTlwiICE9PSBrZXlbMV0pXG4gICAgICApXG4gICAgICAgIChrZXkgPSBhbGlhc2VzLmdldChrZXkpIHx8IGtleSksXG4gICAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFByb3BPbkN1c3RvbUVsZW1lbnQoZG9tRWxlbWVudCwgdGFnLCBrZXksIHZhbHVlLCBwcm9wcywgcHJldlZhbHVlKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fCAhKFwiX19odG1sXCIgaW4gdmFsdWUpKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNjEpKTtcbiAgICAgICAga2V5ID0gdmFsdWUuX19odG1sO1xuICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wcy5jaGlsZHJlbikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MCkpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICA/IHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHZhbHVlKVxuICAgICAgICA6IChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlKSAmJlxuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvblNjcm9sbEVuZFwiOlxuICAgICAgbnVsbCAhPSB2YWx1ZSAmJiBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9uQ2xpY2tcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgKGRvbUVsZW1lbnQub25jbGljayA9IG5vb3AkMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICBjYXNlIFwicmVmXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCFyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIGE6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9cIiA9PT0ga2V5WzBdICYmXG4gICAgICAgICAgICBcIm5cIiA9PT0ga2V5WzFdICYmXG4gICAgICAgICAgICAoKHByb3BzID0ga2V5LmVuZHNXaXRoKFwiQ2FwdHVyZVwiKSksXG4gICAgICAgICAgICAodGFnID0ga2V5LnNsaWNlKDIsIHByb3BzID8ga2V5Lmxlbmd0aCAtIDcgOiB2b2lkIDApKSxcbiAgICAgICAgICAgIChwcmV2VmFsdWUgPSBkb21FbGVtZW50W2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpLFxuICAgICAgICAgICAgKHByZXZWYWx1ZSA9IG51bGwgIT0gcHJldlZhbHVlID8gcHJldlZhbHVlW2tleV0gOiBudWxsKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGFnLCBwcmV2VmFsdWUsIHByb3BzKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJldlZhbHVlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICAoa2V5IGluIGRvbUVsZW1lbnRcbiAgICAgICAgICAgICAgICA/IChkb21FbGVtZW50W2tleV0gPSBudWxsKVxuICAgICAgICAgICAgICAgIDogZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSAmJlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KSk7XG4gICAgICAgICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGFnLCB2YWx1ZSwgcHJvcHMpO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5IGluIGRvbUVsZW1lbnRcbiAgICAgICAgICAgID8gKGRvbUVsZW1lbnRba2V5XSA9IHZhbHVlKVxuICAgICAgICAgICAgOiAhMCA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgICAgICAgIDogc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgXCJkaXZcIjpcbiAgICBjYXNlIFwic3BhblwiOlxuICAgIGNhc2UgXCJzdmdcIjpcbiAgICBjYXNlIFwicGF0aFwiOlxuICAgIGNhc2UgXCJhXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJsaVwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImltZ1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImVycm9yXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICB2YXIgaGFzU3JjID0gITEsXG4gICAgICAgIGhhc1NyY1NldCA9ICExLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgICAgICAgICBoYXNTcmMgPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInNyY1NldFwiOlxuICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaGFzU3JjU2V0ICYmXG4gICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcInNyY1NldFwiLCBwcm9wcy5zcmNTZXQsIHByb3BzLCBudWxsKTtcbiAgICAgIGhhc1NyYyAmJiBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJzcmNcIiwgcHJvcHMuc3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcImlucHV0XCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSAocHJvcEtleSA9IHByb3BWYWx1ZSA9IGhhc1NyY1NldCA9IG51bGwpLFxuICAgICAgICBjaGVja2VkID0gbnVsbCxcbiAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsO1xuICAgICAgZm9yIChoYXNTcmMgaW4gcHJvcHMpXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShoYXNTcmMpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSQxODYgPSBwcm9wc1toYXNTcmNdO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSQxODYpXG4gICAgICAgICAgICBzd2l0Y2ggKGhhc1NyYykge1xuICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBwcm9wVmFsdWUkMTg2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICBwcm9wS2V5ID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkMTg2KVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBoYXNTcmMsIHByb3BWYWx1ZSQxODYsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaW5pdElucHV0KFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBwcm9wS2V5LFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICBwcm9wVmFsdWUsXG4gICAgICAgIGhhc1NyY1NldCxcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGhhc1NyYyA9IHByb3BWYWx1ZSA9IHByb3BLZXkgPSBudWxsO1xuICAgICAgZm9yIChoYXNTcmNTZXQgaW4gcHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShoYXNTcmNTZXQpICYmXG4gICAgICAgICAgKChkZWZhdWx0VmFsdWUgPSBwcm9wc1toYXNTcmNTZXRdKSwgbnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKGhhc1NyY1NldCkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgIGhhc1NyYyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBoYXNTcmNTZXQsIGRlZmF1bHRWYWx1ZSwgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIHRhZyA9IHByb3BLZXk7XG4gICAgICBwcm9wcyA9IHByb3BWYWx1ZTtcbiAgICAgIGRvbUVsZW1lbnQubXVsdGlwbGUgPSAhIWhhc1NyYztcbiAgICAgIG51bGwgIT0gdGFnXG4gICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIWhhc1NyYywgdGFnLCAhMSlcbiAgICAgICAgOiBudWxsICE9IHByb3BzICYmIHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFoYXNTcmMsIHByb3BzLCAhMCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BLZXkgPSBoYXNTcmNTZXQgPSBoYXNTcmMgPSBudWxsO1xuICAgICAgZm9yIChwcm9wVmFsdWUgaW4gcHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wVmFsdWUpICYmXG4gICAgICAgICAgKChkZWZhdWx0VmFsdWUgPSBwcm9wc1twcm9wVmFsdWVdKSwgbnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgIGhhc1NyYyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgIGhhc1NyY1NldCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgcHJvcEtleSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gZGVmYXVsdFZhbHVlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkxKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BWYWx1ZSwgZGVmYXVsdFZhbHVlLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgaW5pdFRleHRhcmVhKGRvbUVsZW1lbnQsIGhhc1NyYywgaGFzU3JjU2V0LCBwcm9wS2V5KTtcbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgIGZvciAoY2hlY2tlZCBpbiBwcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgKChoYXNTcmMgPSBwcm9wc1tjaGVja2VkXSksIG51bGwgIT0gaGFzU3JjKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChjaGVja2VkKSB7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgaGFzU3JjICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaGFzU3JjICYmXG4gICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGhhc1NyYztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgY2hlY2tlZCwgaGFzU3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJkaWFsb2dcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjYW5jZWxcIiwgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2xvc2VcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidmlkZW9cIjpcbiAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgIGZvciAoaGFzU3JjID0gMDsgaGFzU3JjIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaGFzU3JjKyspXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2hhc1NyY10sIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkZXRhaWxzXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVtYmVkXCI6XG4gICAgY2FzZSBcInNvdXJjZVwiOlxuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgZG9tRWxlbWVudCksXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGRvbUVsZW1lbnQpO1xuICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgY2FzZSBcImJhc2VcIjpcbiAgICBjYXNlIFwiYnJcIjpcbiAgICBjYXNlIFwiY29sXCI6XG4gICAgY2FzZSBcImhyXCI6XG4gICAgY2FzZSBcImtleWdlblwiOlxuICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgY2FzZSBcInBhcmFtXCI6XG4gICAgY2FzZSBcInRyYWNrXCI6XG4gICAgY2FzZSBcIndiclwiOlxuICAgIGNhc2UgXCJtZW51aXRlbVwiOlxuICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBwcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGRlZmF1bHRDaGVja2VkKSAmJlxuICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdENoZWNrZWRdKSwgbnVsbCAhPSBoYXNTcmMpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKGRlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzNywgdGFnKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgZGVmYXVsdENoZWNrZWQsIGhhc1NyYywgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgIGZvciAocHJvcFZhbHVlJDE4NiBpbiBwcm9wcylcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wVmFsdWUkMTg2KSAmJlxuICAgICAgICAgICAgKChoYXNTcmMgPSBwcm9wc1twcm9wVmFsdWUkMTg2XSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IGhhc1NyYyAmJlxuICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSQxODYsXG4gICAgICAgICAgICAgICAgaGFzU3JjLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG4gIGZvciAoZGVmYXVsdFZhbHVlIGluIHByb3BzKVxuICAgIHByb3BzLmhhc093blByb3BlcnR5KGRlZmF1bHRWYWx1ZSkgJiZcbiAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdFZhbHVlXSksXG4gICAgICBudWxsICE9IGhhc1NyYyAmJlxuICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgZGVmYXVsdFZhbHVlLCBoYXNTcmMsIHByb3BzLCBudWxsKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFByb3BzLCBuZXh0UHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIFwiZGl2XCI6XG4gICAgY2FzZSBcInNwYW5cIjpcbiAgICBjYXNlIFwic3ZnXCI6XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICBjYXNlIFwiYVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwibGlcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICB0eXBlID0gbnVsbCxcbiAgICAgICAgdmFsdWUgPSBudWxsLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsLFxuICAgICAgICBsYXN0RGVmYXVsdFZhbHVlID0gbnVsbCxcbiAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcbiAgICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgICBpZiAobGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpICYmIG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZSA9IGxhc3RQcm9wO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8XG4gICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXksIG51bGwsIG5leHRQcm9wcywgbGFzdFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3BLZXkkMjAzIGluIG5leHRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcEtleSA9IG5leHRQcm9wc1twcm9wS2V5JDIwM107XG4gICAgICAgIGxhc3RQcm9wID0gbGFzdFByb3BzW3Byb3BLZXkkMjAzXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIwMykgJiZcbiAgICAgICAgICAobnVsbCAhPSBwcm9wS2V5IHx8IG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkMjAzKSB7XG4gICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgICB0eXBlID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICBuYW1lID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BLZXk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHByb3BLZXkgIT09IGxhc3RQcm9wICYmXG4gICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICBwcm9wS2V5JDIwMyxcbiAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBsYXN0UHJvcFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlSW5wdXQoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICB0eXBlLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgIHByb3BLZXkgPSB2YWx1ZSA9IGRlZmF1bHRWYWx1ZSA9IHByb3BLZXkkMjAzID0gbnVsbDtcbiAgICAgIGZvciAodHlwZSBpbiBsYXN0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbdHlwZV0pLFxuICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSAmJiBudWxsICE9IGxhc3REZWZhdWx0VmFsdWUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5ID0gbGFzdERlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSB8fFxuICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBsYXN0RGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKCh0eXBlID0gbmV4dFByb3BzW25hbWVdKSxcbiAgICAgICAgICAobGFzdERlZmF1bHRWYWx1ZSA9IGxhc3RQcm9wc1tuYW1lXSksXG4gICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAobnVsbCAhPSB0eXBlIHx8IG51bGwgIT0gbGFzdERlZmF1bHRWYWx1ZSkpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5JDIwMyA9IHR5cGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0eXBlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICB2YWx1ZSA9IHR5cGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0eXBlICE9PSBsYXN0RGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIHRhZyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGxhc3RQcm9wcyA9IHZhbHVlO1xuICAgICAgbmV4dFByb3BzID0gcHJvcEtleTtcbiAgICAgIG51bGwgIT0gcHJvcEtleSQyMDNcbiAgICAgICAgPyB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhbGFzdFByb3BzLCBwcm9wS2V5JDIwMywgITEpXG4gICAgICAgIDogISFuZXh0UHJvcHMgIT09ICEhbGFzdFByb3BzICYmXG4gICAgICAgICAgKG51bGwgIT0gdGFnXG4gICAgICAgICAgICA/IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFsYXN0UHJvcHMsIHRhZywgITApXG4gICAgICAgICAgICA6IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFsYXN0UHJvcHMsIGxhc3RQcm9wcyA/IFtdIDogXCJcIiwgITEpKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgIHByb3BLZXkgPSBwcm9wS2V5JDIwMyA9IG51bGw7XG4gICAgICBmb3IgKGRlZmF1bHRWYWx1ZSBpbiBsYXN0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKG5hbWUgPSBsYXN0UHJvcHNbZGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KGRlZmF1bHRWYWx1ZSkgJiZcbiAgICAgICAgICAgIG51bGwgIT0gbmFtZSAmJlxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0VmFsdWUpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0VmFsdWUsIG51bGwsIG5leHRQcm9wcywgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuZXh0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKG5hbWUgPSBuZXh0UHJvcHNbdmFsdWVdKSxcbiAgICAgICAgICAodHlwZSA9IGxhc3RQcm9wc1t2YWx1ZV0pLFxuICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgKG51bGwgIT0gbmFtZSB8fCBudWxsICE9IHR5cGUpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkkMjAzID0gbmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkgPSBuYW1lO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBuYW1lKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkxKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbmFtZSAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCB2YWx1ZSwgbmFtZSwgbmV4dFByb3BzLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICB1cGRhdGVUZXh0YXJlYShkb21FbGVtZW50LCBwcm9wS2V5JDIwMywgcHJvcEtleSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgZm9yICh2YXIgcHJvcEtleSQyMTkgaW4gbGFzdFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChwcm9wS2V5JDIwMyA9IGxhc3RQcm9wc1twcm9wS2V5JDIxOV0pLFxuICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIxOSkgJiZcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcEtleSQyMDMgJiZcbiAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMTkpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChwcm9wS2V5JDIxOSkge1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2VsZWN0ZWQgPSAhMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjE5LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgZm9yIChsYXN0RGVmYXVsdFZhbHVlIGluIG5leHRQcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocHJvcEtleSQyMDMgPSBuZXh0UHJvcHNbbGFzdERlZmF1bHRWYWx1ZV0pLFxuICAgICAgICAgIChwcm9wS2V5ID0gbGFzdFByb3BzW2xhc3REZWZhdWx0VmFsdWVdKSxcbiAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkobGFzdERlZmF1bHRWYWx1ZSkgJiZcbiAgICAgICAgICAgIHByb3BLZXkkMjAzICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAobnVsbCAhPSBwcm9wS2V5JDIwMyB8fCBudWxsICE9IHByb3BLZXkpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChsYXN0RGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDMgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wS2V5JDIwMyAmJlxuICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wS2V5JDIwMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcImltZ1wiOlxuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgY2FzZSBcImFyZWFcIjpcbiAgICBjYXNlIFwiYmFzZVwiOlxuICAgIGNhc2UgXCJiclwiOlxuICAgIGNhc2UgXCJjb2xcIjpcbiAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICBjYXNlIFwiaHJcIjpcbiAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgY2FzZSBcIm1ldGFcIjpcbiAgICBjYXNlIFwicGFyYW1cIjpcbiAgICBjYXNlIFwic291cmNlXCI6XG4gICAgY2FzZSBcInRyYWNrXCI6XG4gICAgY2FzZSBcIndiclwiOlxuICAgIGNhc2UgXCJtZW51aXRlbVwiOlxuICAgICAgZm9yICh2YXIgcHJvcEtleSQyMjQgaW4gbGFzdFByb3BzKVxuICAgICAgICAocHJvcEtleSQyMDMgPSBsYXN0UHJvcHNbcHJvcEtleSQyMjRdKSxcbiAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMjQpICYmXG4gICAgICAgICAgICBudWxsICE9IHByb3BLZXkkMjAzICYmXG4gICAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjI0KSAmJlxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXkkMjI0LCBudWxsLCBuZXh0UHJvcHMsIHByb3BLZXkkMjAzKTtcbiAgICAgIGZvciAoY2hlY2tlZCBpbiBuZXh0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2NoZWNrZWRdKSxcbiAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tjaGVja2VkXSksXG4gICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgICBwcm9wS2V5JDIwMyAhPT0gcHJvcEtleSAmJlxuICAgICAgICAgICAgKG51bGwgIT0gcHJvcEtleSQyMDMgfHwgbnVsbCAhPSBwcm9wS2V5KSlcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcEtleSQyMDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JDIwMyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcHJvcEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BLZXkkMjI5IGluIGxhc3RQcm9wcylcbiAgICAgICAgICAocHJvcEtleSQyMDMgPSBsYXN0UHJvcHNbcHJvcEtleSQyMjldKSxcbiAgICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIyOSkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBwcm9wS2V5JDIwMyAmJlxuICAgICAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjI5KSAmJlxuICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjI5LFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2RlZmF1bHRDaGVja2VkXSksXG4gICAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tkZWZhdWx0Q2hlY2tlZF0pLFxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0Q2hlY2tlZCkgfHxcbiAgICAgICAgICAgICAgcHJvcEtleSQyMDMgPT09IHByb3BLZXkgfHxcbiAgICAgICAgICAgICAgKHZvaWQgMCA9PT0gcHJvcEtleSQyMDMgJiYgdm9pZCAwID09PSBwcm9wS2V5KSB8fFxuICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBwcm9wS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICBmb3IgKHZhciBwcm9wS2V5JDIzNCBpbiBsYXN0UHJvcHMpXG4gICAgKHByb3BLZXkkMjAzID0gbGFzdFByb3BzW3Byb3BLZXkkMjM0XSksXG4gICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMzQpICYmXG4gICAgICAgIG51bGwgIT0gcHJvcEtleSQyMDMgJiZcbiAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIzNCkgJiZcbiAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXkkMjM0LCBudWxsLCBuZXh0UHJvcHMsIHByb3BLZXkkMjAzKTtcbiAgZm9yIChsYXN0UHJvcCBpbiBuZXh0UHJvcHMpXG4gICAgKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2xhc3RQcm9wXSksXG4gICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tsYXN0UHJvcF0pLFxuICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShsYXN0UHJvcCkgfHxcbiAgICAgICAgcHJvcEtleSQyMDMgPT09IHByb3BLZXkgfHxcbiAgICAgICAgKG51bGwgPT0gcHJvcEtleSQyMDMgJiYgbnVsbCA9PSBwcm9wS2V5KSB8fFxuICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgbGFzdFByb3AsIHByb3BLZXkkMjAzLCBuZXh0UHJvcHMsIHByb3BLZXkpO1xufVxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsLFxuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIDkgPT09IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlXG4gICAgPyByb290Q29udGFpbmVyRWxlbWVudFxuICAgIDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldE93bkhvc3RDb250ZXh0KG5hbWVzcGFjZVVSSSkge1xuICBzd2l0Y2ggKG5hbWVzcGFjZVVSSSkge1xuICAgIGNhc2UgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjpcbiAgICAgIHJldHVybiAyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRIb3N0Q29udGV4dFByb2QocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmICgwID09PSBwYXJlbnROYW1lc3BhY2UpXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gIHJldHVybiAxID09PSBwYXJlbnROYW1lc3BhY2UgJiYgXCJmb3JlaWduT2JqZWN0XCIgPT09IHR5cGVcbiAgICA/IDBcbiAgICA6IHBhcmVudE5hbWVzcGFjZTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgXCJ0ZXh0YXJlYVwiID09PSB0eXBlIHx8XG4gICAgXCJub3NjcmlwdFwiID09PSB0eXBlIHx8XG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJlxuICAgICAgbnVsbCAhPT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgIG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sKVxuICApO1xufVxudmFyIGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCA9IG51bGw7XG5mdW5jdGlvbiBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG4gIGlmIChldmVudCAmJiBcInBvcHN0YXRlXCIgPT09IGV2ZW50LnR5cGUpIHtcbiAgICBpZiAoZXZlbnQgPT09IGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCkgcmV0dXJuICExO1xuICAgIGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCA9IGV2ZW50O1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBudWxsO1xuICByZXR1cm4gITE7XG59XG52YXIgc2NoZWR1bGVUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiB2b2lkIDAsXG4gIGNhbmNlbFRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjbGVhclRpbWVvdXQgPyBjbGVhclRpbWVvdXQgOiB2b2lkIDAsXG4gIGxvY2FsUHJvbWlzZSA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFByb21pc2UgPyBQcm9taXNlIDogdm9pZCAwLFxuICBzY2hlZHVsZU1pY3JvdGFzayA9XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgID8gcXVldWVNaWNyb3Rhc2tcbiAgICAgIDogXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGxvY2FsUHJvbWlzZVxuICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsUHJvbWlzZVxuICAgICAgICAgICAgICAucmVzb2x2ZShudWxsKVxuICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgLmNhdGNoKGhhbmRsZUVycm9ySW5OZXh0VGljayk7XG4gICAgICAgICAgfVxuICAgICAgICA6IHNjaGVkdWxlVGltZW91dDtcbmZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnkocGFyZW50SW5zdGFuY2UsIHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBzdXNwZW5zZUluc3RhbmNlLFxuICAgIGRlcHRoID0gMDtcbiAgZG8ge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgaWYgKG5leHROb2RlICYmIDggPT09IG5leHROb2RlLm5vZGVUeXBlKVxuICAgICAgaWYgKCgobm9kZSA9IG5leHROb2RlLmRhdGEpLCBcIi8kXCIgPT09IG5vZGUpKSB7XG4gICAgICAgIGlmICgwID09PSBkZXB0aCkge1xuICAgICAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5leHROb2RlKTtcbiAgICAgICAgICByZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aC0tO1xuICAgICAgfSBlbHNlIChcIiRcIiAhPT0gbm9kZSAmJiBcIiQ/XCIgIT09IG5vZGUgJiYgXCIkIVwiICE9PSBub2RlKSB8fCBkZXB0aCsrO1xuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lclNwYXJpbmdseShjb250YWluZXIpIHtcbiAgdmFyIG5leHROb2RlID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIG5leHROb2RlICYmIDEwID09PSBuZXh0Tm9kZS5ub2RlVHlwZSAmJiAobmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0U2libGluZyk7XG4gIGZvciAoOyBuZXh0Tm9kZTsgKSB7XG4gICAgdmFyIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHRTaWJsaW5nO1xuICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgICAgY2FzZSBcIkhUTUxcIjpcbiAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICBjYXNlIFwiQk9EWVwiOlxuICAgICAgICBjbGVhckNvbnRhaW5lclNwYXJpbmdseShub2RlKTtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgXCJTQ1JJUFRcIjpcbiAgICAgIGNhc2UgXCJTVFlMRVwiOlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgXCJMSU5LXCI6XG4gICAgICAgIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gbm9kZS5yZWwudG9Mb3dlckNhc2UoKSkgY29udGludWU7XG4gICAgfVxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgZm9yICg7IDEgPT09IGluc3RhbmNlLm5vZGVUeXBlOyApIHtcbiAgICB2YXIgYW55UHJvcHMgPSBwcm9wcztcbiAgICBpZiAoaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpblJvb3RPclNpbmdsZXRvbiAmJlxuICAgICAgICAoXCJJTlBVVFwiICE9PSBpbnN0YW5jZS5ub2RlTmFtZSB8fCBcImhpZGRlblwiICE9PSBpbnN0YW5jZS50eXBlKVxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKCFpblJvb3RPclNpbmdsZXRvbilcbiAgICAgIGlmIChcImlucHV0XCIgPT09IHR5cGUgJiYgXCJoaWRkZW5cIiA9PT0gaW5zdGFuY2UudHlwZSkge1xuICAgICAgICB2YXIgbmFtZSA9IG51bGwgPT0gYW55UHJvcHMubmFtZSA/IG51bGwgOiBcIlwiICsgYW55UHJvcHMubmFtZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiaGlkZGVuXCIgPT09IGFueVByb3BzLnR5cGUgJiZcbiAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09PSBuYW1lXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9IGVsc2UgcmV0dXJuIGluc3RhbmNlO1xuICAgIGVsc2UgaWYgKCFpbnN0YW5jZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0pXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICBpZiAoIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpKSBicmVhaztcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgbmFtZSA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInJlbFwiKTtcbiAgICAgICAgICBpZiAoXCJzdHlsZXNoZWV0XCIgPT09IG5hbWUgJiYgaW5zdGFuY2UuaGFzQXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICBuYW1lICE9PSBhbnlQcm9wcy5yZWwgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikgIT09XG4gICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLmhyZWYgPyBudWxsIDogYW55UHJvcHMuaHJlZikgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpICE9PVxuICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy5jcm9zc09yaWdpbiA/IG51bGwgOiBhbnlQcm9wcy5jcm9zc09yaWdpbikgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpICE9PVxuICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy50aXRsZSA/IG51bGwgOiBhbnlQcm9wcy50aXRsZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIGlmIChpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIikpIGJyZWFrO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIG5hbWUgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG5hbWUgIT09IChudWxsID09IGFueVByb3BzLnNyYyA/IG51bGwgOiBhbnlQcm9wcy5zcmMpIHx8XG4gICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09XG4gICAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMudHlwZSA/IG51bGwgOiBhbnlQcm9wcy50eXBlKSB8fFxuICAgICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKSAhPT1cbiAgICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy5jcm9zc09yaWdpbiA/IG51bGwgOiBhbnlQcm9wcy5jcm9zc09yaWdpbikpICYmXG4gICAgICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICBpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJhc3luY1wiKSAmJlxuICAgICAgICAgICAgIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICBpbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbiAgICBpZiAobnVsbCA9PT0gaW5zdGFuY2UpIGJyZWFrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCwgaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgaWYgKFwiXCIgPT09IHRleHQpIHJldHVybiBudWxsO1xuICBmb3IgKDsgMyAhPT0gaW5zdGFuY2Uubm9kZVR5cGU7ICkge1xuICAgIGlmIChcbiAgICAgICgxICE9PSBpbnN0YW5jZS5ub2RlVHlwZSB8fFxuICAgICAgICBcIklOUFVUXCIgIT09IGluc3RhbmNlLm5vZGVOYW1lIHx8XG4gICAgICAgIFwiaGlkZGVuXCIgIT09IGluc3RhbmNlLnR5cGUpICYmXG4gICAgICAhaW5Sb290T3JTaW5nbGV0b25cbiAgICApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbiAgICBpZiAobnVsbCA9PT0gaW5zdGFuY2UpIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlKG5vZGUpIHtcbiAgZm9yICg7IG51bGwgIT0gbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIGlmICgxID09PSBub2RlVHlwZSB8fCAzID09PSBub2RlVHlwZSkgYnJlYWs7XG4gICAgaWYgKDggPT09IG5vZGVUeXBlKSB7XG4gICAgICBub2RlVHlwZSA9IG5vZGUuZGF0YTtcbiAgICAgIGlmIChcbiAgICAgICAgXCIkXCIgPT09IG5vZGVUeXBlIHx8XG4gICAgICAgIFwiJCFcIiA9PT0gbm9kZVR5cGUgfHxcbiAgICAgICAgXCIkP1wiID09PSBub2RlVHlwZSB8fFxuICAgICAgICBcIkYhXCIgPT09IG5vZGVUeXBlIHx8XG4gICAgICAgIFwiRlwiID09PSBub2RlVHlwZVxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChcIi8kXCIgPT09IG5vZGVUeXBlKSByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHRhcmdldEluc3RhbmNlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nO1xuICBmb3IgKHZhciBkZXB0aCA9IDA7IHRhcmdldEluc3RhbmNlOyApIHtcbiAgICBpZiAoOCA9PT0gdGFyZ2V0SW5zdGFuY2Uubm9kZVR5cGUpIHtcbiAgICAgIHZhciBkYXRhID0gdGFyZ2V0SW5zdGFuY2UuZGF0YTtcbiAgICAgIGlmIChcIiRcIiA9PT0gZGF0YSB8fCBcIiQhXCIgPT09IGRhdGEgfHwgXCIkP1wiID09PSBkYXRhKSB7XG4gICAgICAgIGlmICgwID09PSBkZXB0aCkgcmV0dXJuIHRhcmdldEluc3RhbmNlO1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgfSBlbHNlIFwiLyRcIiA9PT0gZGF0YSAmJiBkZXB0aCsrO1xuICAgIH1cbiAgICB0YXJnZXRJbnN0YW5jZSA9IHRhcmdldEluc3RhbmNlLnByZXZpb3VzU2libGluZztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gIHByb3BzID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICB0eXBlID0gcHJvcHMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1MikpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgY2FzZSBcImhlYWRcIjpcbiAgICAgIHR5cGUgPSBwcm9wcy5oZWFkO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1MykpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIHR5cGUgPSBwcm9wcy5ib2R5O1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1NCkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDUxKSk7XG4gIH1cbn1cbnZhciBwcmVsb2FkUHJvcHNNYXAgPSBuZXcgTWFwKCksXG4gIHByZWNvbm5lY3RzU2V0ID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gZ2V0SG9pc3RhYmxlUm9vdChjb250YWluZXIpIHtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRhaW5lci5nZXRSb290Tm9kZVxuICAgID8gY29udGFpbmVyLmdldFJvb3ROb2RlKClcbiAgICA6IGNvbnRhaW5lci5vd25lckRvY3VtZW50O1xufVxudmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG5SZWFjdERPTVNoYXJlZEludGVybmFscy5kID0ge1xuICBmOiBmbHVzaFN5bmNXb3JrLFxuICByOiByZXF1ZXN0Rm9ybVJlc2V0LFxuICBEOiBwcmVmZXRjaEROUyxcbiAgQzogcHJlY29ubmVjdCxcbiAgTDogcHJlbG9hZCxcbiAgbTogcHJlbG9hZE1vZHVsZSxcbiAgWDogcHJlaW5pdFNjcmlwdCxcbiAgUzogcHJlaW5pdFN0eWxlLFxuICBNOiBwcmVpbml0TW9kdWxlU2NyaXB0XG59O1xuZnVuY3Rpb24gZmx1c2hTeW5jV29yaygpIHtcbiAgdmFyIHByZXZpb3VzV2FzUmVuZGVyaW5nID0gcHJldmlvdXNEaXNwYXRjaGVyLmYoKSxcbiAgICB3YXNSZW5kZXJpbmcgPSBmbHVzaFN5bmNXb3JrJDEoKTtcbiAgcmV0dXJuIHByZXZpb3VzV2FzUmVuZGVyaW5nIHx8IHdhc1JlbmRlcmluZztcbn1cbmZ1bmN0aW9uIHJlcXVlc3RGb3JtUmVzZXQoZm9ybSkge1xuICB2YXIgZm9ybUluc3QgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGZvcm0pO1xuICBudWxsICE9PSBmb3JtSW5zdCAmJiA1ID09PSBmb3JtSW5zdC50YWcgJiYgXCJmb3JtXCIgPT09IGZvcm1JbnN0LnR5cGVcbiAgICA/IHJlcXVlc3RGb3JtUmVzZXQkMShmb3JtSW5zdClcbiAgICA6IHByZXZpb3VzRGlzcGF0Y2hlci5yKGZvcm0pO1xufVxudmFyIGdsb2JhbERvY3VtZW50ID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGRvY3VtZW50ID8gbnVsbCA6IGRvY3VtZW50O1xuZnVuY3Rpb24gcHJlY29ubmVjdEFzKHJlbCwgaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgIHZhciBsaW1pdGVkRXNjYXBlZEhyZWYgPVxuICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKTtcbiAgICBsaW1pdGVkRXNjYXBlZEhyZWYgPVxuICAgICAgJ2xpbmtbcmVsPVwiJyArIHJlbCArICdcIl1baHJlZj1cIicgKyBsaW1pdGVkRXNjYXBlZEhyZWYgKyAnXCJdJztcbiAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW4gJiZcbiAgICAgIChsaW1pdGVkRXNjYXBlZEhyZWYgKz0gJ1tjcm9zc29yaWdpbj1cIicgKyBjcm9zc09yaWdpbiArICdcIl0nKTtcbiAgICBwcmVjb25uZWN0c1NldC5oYXMobGltaXRlZEVzY2FwZWRIcmVmKSB8fFxuICAgICAgKHByZWNvbm5lY3RzU2V0LmFkZChsaW1pdGVkRXNjYXBlZEhyZWYpLFxuICAgICAgKHJlbCA9IHsgcmVsOiByZWwsIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbiwgaHJlZjogaHJlZiB9KSxcbiAgICAgIG51bGwgPT09IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihsaW1pdGVkRXNjYXBlZEhyZWYpICYmXG4gICAgICAgICgoaHJlZiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpLFxuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhocmVmLCBcImxpbmtcIiwgcmVsKSxcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShocmVmKSxcbiAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGhyZWYpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWZldGNoRE5TKGhyZWYpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gIHByZWNvbm5lY3RBcyhcImRucy1wcmVmZXRjaFwiLCBocmVmLCBudWxsKTtcbn1cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLkMoaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICBwcmVjb25uZWN0QXMoXCJwcmVjb25uZWN0XCIsIGhyZWYsIGNyb3NzT3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHByZWxvYWQoaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLkwoaHJlZiwgYXMsIG9wdGlvbnMpO1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmICYmIGFzKSB7XG4gICAgdmFyIHByZWxvYWRTZWxlY3RvciA9XG4gICAgICAnbGlua1tyZWw9XCJwcmVsb2FkXCJdW2FzPVwiJyArXG4gICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGFzKSArXG4gICAgICAnXCJdJztcbiAgICBcImltYWdlXCIgPT09IGFzXG4gICAgICA/IG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICA/ICgocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAnW2ltYWdlc3Jjc2V0PVwiJyArXG4gICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICApICtcbiAgICAgICAgICAgICdcIl0nKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzICYmXG4gICAgICAgICAgICAocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAgICdbaW1hZ2VzaXplcz1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1hZ2VTaXplc1xuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJ1wiXScpKVxuICAgICAgICA6IChwcmVsb2FkU2VsZWN0b3IgKz1cbiAgICAgICAgICAgICdbaHJlZj1cIicgK1xuICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKSArXG4gICAgICAgICAgICAnXCJdJylcbiAgICAgIDogKHByZWxvYWRTZWxlY3RvciArPVxuICAgICAgICAgICdbaHJlZj1cIicgK1xuICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgK1xuICAgICAgICAgICdcIl0nKTtcbiAgICB2YXIga2V5ID0gcHJlbG9hZFNlbGVjdG9yO1xuICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBrZXkgPSBnZXRTdHlsZUtleShocmVmKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgIGtleSA9IGdldFNjcmlwdEtleShocmVmKTtcbiAgICB9XG4gICAgcHJlbG9hZFByb3BzTWFwLmhhcyhrZXkpIHx8XG4gICAgICAoKGhyZWYgPSBhc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgIGhyZWY6XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IGFzICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVNyY1NldCA/IHZvaWQgMCA6IGhyZWYsXG4gICAgICAgICAgYXM6IGFzXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICkpLFxuICAgICAgcHJlbG9hZFByb3BzTWFwLnNldChrZXksIGhyZWYpLFxuICAgICAgbnVsbCAhPT0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHByZWxvYWRTZWxlY3RvcikgfHxcbiAgICAgICAgKFwic3R5bGVcIiA9PT0gYXMgJiZcbiAgICAgICAgICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleShrZXkpKSkgfHxcbiAgICAgICAgKFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgICAgb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSkgfHxcbiAgICAgICAgKChhcyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpLFxuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhhcywgXCJsaW5rXCIsIGhyZWYpLFxuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGFzKSxcbiAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGFzKSkpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVsb2FkTW9kdWxlKGhyZWYsIG9wdGlvbnMpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLm0oaHJlZiwgb3B0aW9ucyk7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIGhyZWYpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCIsXG4gICAgICBwcmVsb2FkU2VsZWN0b3IgPVxuICAgICAgICAnbGlua1tyZWw9XCJtb2R1bGVwcmVsb2FkXCJdW2FzPVwiJyArXG4gICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoYXMpICtcbiAgICAgICAgJ1wiXVtocmVmPVwiJyArXG4gICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgK1xuICAgICAgICAnXCJdJyxcbiAgICAgIGtleSA9IHByZWxvYWRTZWxlY3RvcjtcbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlIFwiYXVkaW93b3JrbGV0XCI6XG4gICAgICBjYXNlIFwicGFpbnR3b3JrbGV0XCI6XG4gICAgICBjYXNlIFwic2VydmljZXdvcmtlclwiOlxuICAgICAgY2FzZSBcInNoYXJlZHdvcmtlclwiOlxuICAgICAgY2FzZSBcIndvcmtlclwiOlxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICBrZXkgPSBnZXRTY3JpcHRLZXkoaHJlZik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFwcmVsb2FkUHJvcHNNYXAuaGFzKGtleSkgJiZcbiAgICAgICgoaHJlZiA9IGFzc2lnbih7IHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYgfSwgb3B0aW9ucykpLFxuICAgICAgcHJlbG9hZFByb3BzTWFwLnNldChrZXksIGhyZWYpLFxuICAgICAgbnVsbCA9PT0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHByZWxvYWRTZWxlY3RvcikpXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgIGNhc2UgXCJhdWRpb3dvcmtsZXRcIjpcbiAgICAgICAgY2FzZSBcInBhaW50d29ya2xldFwiOlxuICAgICAgICBjYXNlIFwic2VydmljZXdvcmtlclwiOlxuICAgICAgICBjYXNlIFwic2hhcmVkd29ya2VyXCI6XG4gICAgICAgIGNhc2UgXCJ3b3JrZXJcIjpcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIGlmIChvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoYXMsIFwibGlua1wiLCBocmVmKTtcbiAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoYXMpO1xuICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGFzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWluaXRTdHlsZShocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFJlc291cmNlc0Zyb21Sb290KG93bmVyRG9jdW1lbnQpLmhvaXN0YWJsZVN0eWxlcyxcbiAgICAgIGtleSA9IGdldFN0eWxlS2V5KGhyZWYpO1xuICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgIHZhciByZXNvdXJjZSA9IHN0eWxlcy5nZXQoa2V5KTtcbiAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7IGxvYWRpbmc6IDAsIHByZWxvYWQ6IG51bGwgfTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KVxuICAgICAgICApKVxuICAgICAgKVxuICAgICAgICBzdGF0ZS5sb2FkaW5nID0gNTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBocmVmID0gYXNzaWduKFxuICAgICAgICAgIHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogaHJlZiwgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZSB9LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgKG9wdGlvbnMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGhyZWYsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbGluayA9IChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGxpbmspO1xuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhsaW5rLCBcImxpbmtcIiwgaHJlZik7XG4gICAgICAgIGxpbmsuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgbGluay5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICAgIGxpbmsub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlLmxvYWRpbmcgfD0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZS5sb2FkaW5nIHw9IDI7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5sb2FkaW5nIHw9IDQ7XG4gICAgICAgIGluc2VydFN0eWxlc2hlZXQocmVzb3VyY2UsIHByZWNlZGVuY2UsIG93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6IFwic3R5bGVzaGVldFwiLFxuICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH07XG4gICAgICBzdHlsZXMuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlaW5pdFNjcmlwdChzcmMsIG9wdGlvbnMpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLlgoc3JjLCBvcHRpb25zKTtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgc3JjKSB7XG4gICAgdmFyIHNjcmlwdHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChvd25lckRvY3VtZW50KS5ob2lzdGFibGVTY3JpcHRzLFxuICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KHNyYyksXG4gICAgICByZXNvdXJjZSA9IHNjcmlwdHMuZ2V0KGtleSk7XG4gICAgcmVzb3VyY2UgfHxcbiAgICAgICgocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSkpKSxcbiAgICAgIHJlc291cmNlIHx8XG4gICAgICAgICgoc3JjID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCB9LCBvcHRpb25zKSksXG4gICAgICAgIChvcHRpb25zID0gcHJlbG9hZFByb3BzTWFwLmdldChrZXkpKSAmJlxuICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0KHNyYywgb3B0aW9ucyksXG4gICAgICAgIChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSksXG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUocmVzb3VyY2UpLFxuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhyZXNvdXJjZSwgXCJsaW5rXCIsIHNyYyksXG4gICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChyZXNvdXJjZSkpLFxuICAgICAgKHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiBcInNjcmlwdFwiLFxuICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgfSksXG4gICAgICBzY3JpcHRzLnNldChrZXksIHJlc291cmNlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWluaXRNb2R1bGVTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5NKHNyYywgb3B0aW9ucyk7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIHNyYykge1xuICAgIHZhciBzY3JpcHRzID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3Qob3duZXJEb2N1bWVudCkuaG9pc3RhYmxlU2NyaXB0cyxcbiAgICAgIGtleSA9IGdldFNjcmlwdEtleShzcmMpLFxuICAgICAgcmVzb3VyY2UgPSBzY3JpcHRzLmdldChrZXkpO1xuICAgIHJlc291cmNlIHx8XG4gICAgICAoKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSksXG4gICAgICByZXNvdXJjZSB8fFxuICAgICAgICAoKHNyYyA9IGFzc2lnbih7IHNyYzogc3JjLCBhc3luYzogITAsIHR5cGU6IFwibW9kdWxlXCIgfSwgb3B0aW9ucykpLFxuICAgICAgICAob3B0aW9ucyA9IHByZWxvYWRQcm9wc01hcC5nZXQoa2V5KSkgJiZcbiAgICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpLFxuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHJlc291cmNlKSxcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMocmVzb3VyY2UsIFwibGlua1wiLCBzcmMpLFxuICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQocmVzb3VyY2UpKSxcbiAgICAgIChyZXNvdXJjZSA9IHtcbiAgICAgICAgdHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgaW5zdGFuY2U6IHJlc291cmNlLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgIH0pLFxuICAgICAgc2NyaXB0cy5zZXQoa2V5LCByZXNvdXJjZSkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvdXJjZSh0eXBlLCBjdXJyZW50UHJvcHMsIHBlbmRpbmdQcm9wcywgY3VycmVudFJlc291cmNlKSB7XG4gIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KVxuICAgID8gZ2V0SG9pc3RhYmxlUm9vdChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpXG4gICAgOiBudWxsO1xuICBpZiAoIUpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NDYpKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIm1ldGFcIjpcbiAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZSAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLmhyZWZcbiAgICAgICAgPyAoKGN1cnJlbnRQcm9wcyA9IGdldFN0eWxlS2V5KHBlbmRpbmdQcm9wcy5ocmVmKSksXG4gICAgICAgICAgKHBlbmRpbmdQcm9wcyA9IGdldFJlc291cmNlc0Zyb21Sb290KFxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgKS5ob2lzdGFibGVTdHlsZXMpLFxuICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBwZW5kaW5nUHJvcHMuZ2V0KGN1cnJlbnRQcm9wcykpLFxuICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSB8fFxuICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3R5bGVcIixcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMuc2V0KGN1cnJlbnRQcm9wcywgY3VycmVudFJlc291cmNlKSksXG4gICAgICAgICAgY3VycmVudFJlc291cmNlKVxuICAgICAgICA6IHsgdHlwZTogXCJ2b2lkXCIsIGluc3RhbmNlOiBudWxsLCBjb3VudDogMCwgc3RhdGU6IG51bGwgfTtcbiAgICBjYXNlIFwibGlua1wiOlxuICAgICAgaWYgKFxuICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gcGVuZGluZ1Byb3BzLnJlbCAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLmhyZWYgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHBlbmRpbmdQcm9wcy5wcmVjZWRlbmNlXG4gICAgICApIHtcbiAgICAgICAgdHlwZSA9IGdldFN0eWxlS2V5KHBlbmRpbmdQcm9wcy5ocmVmKTtcbiAgICAgICAgdmFyIHN0eWxlcyQyNDIgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICkuaG9pc3RhYmxlU3R5bGVzLFxuICAgICAgICAgIHJlc291cmNlJDI0MyA9IHN0eWxlcyQyNDIuZ2V0KHR5cGUpO1xuICAgICAgICByZXNvdXJjZSQyNDMgfHxcbiAgICAgICAgICAoKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQub3duZXJEb2N1bWVudCB8fCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpLFxuICAgICAgICAgIChyZXNvdXJjZSQyNDMgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICBzdGF0ZTogeyBsb2FkaW5nOiAwLCBwcmVsb2FkOiBudWxsIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzdHlsZXMkMjQyLnNldCh0eXBlLCByZXNvdXJjZSQyNDMpLFxuICAgICAgICAgIChzdHlsZXMkMjQyID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KHR5cGUpXG4gICAgICAgICAgKSkgJiZcbiAgICAgICAgICAgICFzdHlsZXMkMjQyLl9wICYmXG4gICAgICAgICAgICAoKHJlc291cmNlJDI0My5pbnN0YW5jZSA9IHN0eWxlcyQyNDIpLFxuICAgICAgICAgICAgKHJlc291cmNlJDI0My5zdGF0ZS5sb2FkaW5nID0gNSkpLFxuICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5oYXModHlwZSkgfHxcbiAgICAgICAgICAgICgocGVuZGluZ1Byb3BzID0ge1xuICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgICAgICBocmVmOiBwZW5kaW5nUHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHBlbmRpbmdQcm9wcy5jcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwZW5kaW5nUHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICBtZWRpYTogcGVuZGluZ1Byb3BzLm1lZGlhLFxuICAgICAgICAgICAgICBocmVmTGFuZzogcGVuZGluZ1Byb3BzLmhyZWZMYW5nLFxuICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcGVuZGluZ1Byb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQodHlwZSwgcGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIHN0eWxlcyQyNDIgfHxcbiAgICAgICAgICAgICAgcHJlbG9hZFN0eWxlc2hlZXQoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgIHJlc291cmNlJDI0My5zdGF0ZVxuICAgICAgICAgICAgICApKSk7XG4gICAgICAgIGlmIChjdXJyZW50UHJvcHMgJiYgbnVsbCA9PT0gY3VycmVudFJlc291cmNlKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTI4LCBcIlwiKSk7XG4gICAgICAgIHJldHVybiByZXNvdXJjZSQyNDM7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFByb3BzICYmIG51bGwgIT09IGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjksIFwiXCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjdXJyZW50UHJvcHMgPSBwZW5kaW5nUHJvcHMuYXN5bmMpLFxuICAgICAgICAocGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzLnNyYyksXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMgJiZcbiAgICAgICAgY3VycmVudFByb3BzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGN1cnJlbnRQcm9wcyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY3VycmVudFByb3BzXG4gICAgICAgICAgPyAoKGN1cnJlbnRQcm9wcyA9IGdldFNjcmlwdEtleShwZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICApLmhvaXN0YWJsZVNjcmlwdHMpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXNvdXJjZSA9IHBlbmRpbmdQcm9wcy5nZXQoY3VycmVudFByb3BzKSksXG4gICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgfHxcbiAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLnNldChjdXJyZW50UHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkpLFxuICAgICAgICAgICAgY3VycmVudFJlc291cmNlKVxuICAgICAgICAgIDogeyB0eXBlOiBcInZvaWRcIiwgaW5zdGFuY2U6IG51bGwsIGNvdW50OiAwLCBzdGF0ZTogbnVsbCB9XG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ0NCwgdHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdHlsZUtleShocmVmKSB7XG4gIHJldHVybiAnaHJlZj1cIicgKyBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpICsgJ1wiJztcbn1cbmZ1bmN0aW9uIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KSB7XG4gIHJldHVybiAnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdWycgKyBrZXkgKyBcIl1cIjtcbn1cbmZ1bmN0aW9uIHN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyhyYXdQcm9wcykge1xuICByZXR1cm4gYXNzaWduKHt9LCByYXdQcm9wcywge1xuICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWxvYWRTdHlsZXNoZWV0KG93bmVyRG9jdW1lbnQsIGtleSwgcHJlbG9hZFByb3BzLCBzdGF0ZSkge1xuICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdWycgKyBrZXkgKyBcIl1cIilcbiAgICA/IChzdGF0ZS5sb2FkaW5nID0gMSlcbiAgICA6ICgoa2V5ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAoc3RhdGUucHJlbG9hZCA9IGtleSksXG4gICAgICBrZXkuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLmxvYWRpbmcgfD0gMSk7XG4gICAgICB9KSxcbiAgICAgIGtleS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLmxvYWRpbmcgfD0gMik7XG4gICAgICB9KSxcbiAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGtleSwgXCJsaW5rXCIsIHByZWxvYWRQcm9wcyksXG4gICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGtleSksXG4gICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoa2V5KSk7XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRLZXkoc3JjKSB7XG4gIHJldHVybiAnW3NyYz1cIicgKyBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKHNyYykgKyAnXCJdJztcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpIHtcbiAgcmV0dXJuIFwic2NyaXB0W2FzeW5jXVwiICsga2V5O1xufVxuZnVuY3Rpb24gYWNxdWlyZVJlc291cmNlKGhvaXN0YWJsZVJvb3QsIHJlc291cmNlLCBwcm9wcykge1xuICByZXNvdXJjZS5jb3VudCsrO1xuICBpZiAobnVsbCA9PT0gcmVzb3VyY2UuaW5zdGFuY2UpXG4gICAgc3dpdGNoIChyZXNvdXJjZS50eXBlKSB7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgdmFyIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICdzdHlsZVtkYXRhLWhyZWZ+PVwiJyArXG4gICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKHByb3BzLmhyZWYpICtcbiAgICAgICAgICAgICdcIl0nXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbnN0YW5jZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2UpLFxuICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSksXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBzdHlsZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIFwiZGF0YS1ocmVmXCI6IHByb3BzLmhyZWYsXG4gICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICBocmVmOiBudWxsLFxuICAgICAgICAgIHByZWNlZGVuY2U6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGluc3RhbmNlID0gKGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290KS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic3R5bGVcIlxuICAgICAgICApO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UsIFwic3R5bGVcIiwgc3R5bGVQcm9wcyk7XG4gICAgICAgIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UsIHByb3BzLnByZWNlZGVuY2UsIGhvaXN0YWJsZVJvb3QpO1xuICAgICAgICByZXR1cm4gKHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2UpO1xuICAgICAgY2FzZSBcInN0eWxlc2hlZXRcIjpcbiAgICAgICAgc3R5bGVQcm9wcyA9IGdldFN0eWxlS2V5KHByb3BzLmhyZWYpO1xuICAgICAgICB2YXIgaW5zdGFuY2UkMjQ4ID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoc3R5bGVQcm9wcylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluc3RhbmNlJDI0OClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gNCksXG4gICAgICAgICAgICAocmVzb3VyY2UuaW5zdGFuY2UgPSBpbnN0YW5jZSQyNDgpLFxuICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSQyNDgpLFxuICAgICAgICAgICAgaW5zdGFuY2UkMjQ4XG4gICAgICAgICAgKTtcbiAgICAgICAgaW5zdGFuY2UgPSBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocHJvcHMpO1xuICAgICAgICAoc3R5bGVQcm9wcyA9IHByZWxvYWRQcm9wc01hcC5nZXQoc3R5bGVQcm9wcykpICYmXG4gICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGluc3RhbmNlLCBzdHlsZVByb3BzKTtcbiAgICAgICAgaW5zdGFuY2UkMjQ4ID0gKFxuICAgICAgICAgIGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290XG4gICAgICAgICkuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UkMjQ4KTtcbiAgICAgICAgdmFyIGxpbmtJbnN0YW5jZSA9IGluc3RhbmNlJDI0ODtcbiAgICAgICAgbGlua0luc3RhbmNlLl9wID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGxpbmtJbnN0YW5jZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICAgIGxpbmtJbnN0YW5jZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UkMjQ4LCBcImxpbmtcIiwgaW5zdGFuY2UpO1xuICAgICAgICByZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IDQ7XG4gICAgICAgIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UkMjQ4LCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlJDI0OCk7XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgIGluc3RhbmNlJDI0OCA9IGdldFNjcmlwdEtleShwcm9wcy5zcmMpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHN0eWxlUHJvcHMgPSBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoaW5zdGFuY2UkMjQ4KVxuICAgICAgICAgICkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlc291cmNlLmluc3RhbmNlID0gc3R5bGVQcm9wcyksXG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHN0eWxlUHJvcHMpLFxuICAgICAgICAgICAgc3R5bGVQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgIGluc3RhbmNlID0gcHJvcHM7XG4gICAgICAgIGlmICgoc3R5bGVQcm9wcyA9IHByZWxvYWRQcm9wc01hcC5nZXQoaW5zdGFuY2UkMjQ4KSkpXG4gICAgICAgICAgKGluc3RhbmNlID0gYXNzaWduKHt9LCBwcm9wcykpLFxuICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoaW5zdGFuY2UsIHN0eWxlUHJvcHMpO1xuICAgICAgICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgIHN0eWxlUHJvcHMgPSBob2lzdGFibGVSb290LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoc3R5bGVQcm9wcyk7XG4gICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKHN0eWxlUHJvcHMsIFwibGlua1wiLCBpbnN0YW5jZSk7XG4gICAgICAgIGhvaXN0YWJsZVJvb3QuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVByb3BzKTtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IHN0eWxlUHJvcHMpO1xuICAgICAgY2FzZSBcInZvaWRcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ0MywgcmVzb3VyY2UudHlwZSkpO1xuICAgIH1cbiAgZWxzZVxuICAgIFwic3R5bGVzaGVldFwiID09PSByZXNvdXJjZS50eXBlICYmXG4gICAgICAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDQpICYmXG4gICAgICAoKGluc3RhbmNlID0gcmVzb3VyY2UuaW5zdGFuY2UpLFxuICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gNCksXG4gICAgICBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlLCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KSk7XG4gIHJldHVybiByZXNvdXJjZS5pbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UsIHByZWNlZGVuY2UsIHJvb3QpIHtcbiAgZm9yIChcbiAgICB2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICdsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl1bZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdJ1xuICAgICAgKSxcbiAgICAgIGxhc3QgPSBub2Rlcy5sZW5ndGggPyBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA6IG51bGwsXG4gICAgICBwcmlvciA9IGxhc3QsXG4gICAgICBpID0gMDtcbiAgICBpIDwgbm9kZXMubGVuZ3RoO1xuICAgIGkrK1xuICApIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmRhdGFzZXQucHJlY2VkZW5jZSA9PT0gcHJlY2VkZW5jZSkgcHJpb3IgPSBub2RlO1xuICAgIGVsc2UgaWYgKHByaW9yICE9PSBsYXN0KSBicmVhaztcbiAgfVxuICBwcmlvclxuICAgID8gcHJpb3IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIHByaW9yLm5leHRTaWJsaW5nKVxuICAgIDogKChwcmVjZWRlbmNlID0gOSA9PT0gcm9vdC5ub2RlVHlwZSA/IHJvb3QuaGVhZCA6IHJvb3QpLFxuICAgICAgcHJlY2VkZW5jZS5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIHByZWNlZGVuY2UuZmlyc3RDaGlsZCkpO1xufVxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KHN0eWxlc2hlZXRQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLmNyb3NzT3JpZ2luICYmXG4gICAgKHN0eWxlc2hlZXRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLnJlZmVycmVyUG9saWN5ICYmXG4gICAgKHN0eWxlc2hlZXRQcm9wcy5yZWZlcnJlclBvbGljeSA9IHByZWxvYWRQcm9wcy5yZWZlcnJlclBvbGljeSk7XG4gIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLnRpdGxlICYmIChzdHlsZXNoZWV0UHJvcHMudGl0bGUgPSBwcmVsb2FkUHJvcHMudGl0bGUpO1xufVxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoc2NyaXB0UHJvcHMsIHByZWxvYWRQcm9wcykge1xuICBudWxsID09IHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luICYmXG4gICAgKHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luID0gcHJlbG9hZFByb3BzLmNyb3NzT3JpZ2luKTtcbiAgbnVsbCA9PSBzY3JpcHRQcm9wcy5yZWZlcnJlclBvbGljeSAmJlxuICAgIChzY3JpcHRQcm9wcy5yZWZlcnJlclBvbGljeSA9IHByZWxvYWRQcm9wcy5yZWZlcnJlclBvbGljeSk7XG4gIG51bGwgPT0gc2NyaXB0UHJvcHMuaW50ZWdyaXR5ICYmXG4gICAgKHNjcmlwdFByb3BzLmludGVncml0eSA9IHByZWxvYWRQcm9wcy5pbnRlZ3JpdHkpO1xufVxudmFyIHRhZ0NhY2hlcyA9IG51bGw7XG5mdW5jdGlvbiBnZXRIeWRyYXRhYmxlSG9pc3RhYmxlQ2FjaGUodHlwZSwga2V5QXR0cmlidXRlLCBvd25lckRvY3VtZW50KSB7XG4gIGlmIChudWxsID09PSB0YWdDYWNoZXMpIHtcbiAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGNhY2hlcyA9ICh0YWdDYWNoZXMgPSBuZXcgTWFwKCkpO1xuICAgIGNhY2hlcy5zZXQob3duZXJEb2N1bWVudCwgY2FjaGUpO1xuICB9IGVsc2VcbiAgICAoY2FjaGVzID0gdGFnQ2FjaGVzKSxcbiAgICAgIChjYWNoZSA9IGNhY2hlcy5nZXQob3duZXJEb2N1bWVudCkpLFxuICAgICAgY2FjaGUgfHwgKChjYWNoZSA9IG5ldyBNYXAoKSksIGNhY2hlcy5zZXQob3duZXJEb2N1bWVudCwgY2FjaGUpKTtcbiAgaWYgKGNhY2hlLmhhcyh0eXBlKSkgcmV0dXJuIGNhY2hlO1xuICBjYWNoZS5zZXQodHlwZSwgbnVsbCk7XG4gIG93bmVyRG9jdW1lbnQgPSBvd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHR5cGUpO1xuICBmb3IgKGNhY2hlcyA9IDA7IGNhY2hlcyA8IG93bmVyRG9jdW1lbnQubGVuZ3RoOyBjYWNoZXMrKykge1xuICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudFtjYWNoZXNdO1xuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgKFwibGlua1wiID09PSB0eXBlICYmIFwic3R5bGVzaGVldFwiID09PSBub2RlLmdldEF0dHJpYnV0ZShcInJlbFwiKSlcbiAgICAgICkgJiZcbiAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAhPT0gbm9kZS5uYW1lc3BhY2VVUklcbiAgICApIHtcbiAgICAgIHZhciBub2RlS2V5ID0gbm9kZS5nZXRBdHRyaWJ1dGUoa2V5QXR0cmlidXRlKSB8fCBcIlwiO1xuICAgICAgbm9kZUtleSA9IHR5cGUgKyBub2RlS2V5O1xuICAgICAgdmFyIGV4aXN0aW5nID0gY2FjaGUuZ2V0KG5vZGVLZXkpO1xuICAgICAgZXhpc3RpbmcgPyBleGlzdGluZy5wdXNoKG5vZGUpIDogY2FjaGUuc2V0KG5vZGVLZXksIFtub2RlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWNoZTtcbn1cbmZ1bmN0aW9uIG1vdW50SG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIHR5cGUsIGluc3RhbmNlKSB7XG4gIGhvaXN0YWJsZVJvb3QgPSBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdDtcbiAgaG9pc3RhYmxlUm9vdC5oZWFkLmluc2VydEJlZm9yZShcbiAgICBpbnN0YW5jZSxcbiAgICBcInRpdGxlXCIgPT09IHR5cGUgPyBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkID4gdGl0bGVcIikgOiBudWxsXG4gICk7XG59XG5mdW5jdGlvbiBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHByb3BzLCBob3N0Q29udGV4dCkge1xuICBpZiAoMSA9PT0gaG9zdENvbnRleHQgfHwgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCkgcmV0dXJuICExO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwibWV0YVwiOlxuICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMucHJlY2VkZW5jZSB8fFxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuaHJlZiB8fFxuICAgICAgICBcIlwiID09PSBwcm9wcy5ocmVmXG4gICAgICApXG4gICAgICAgIGJyZWFrO1xuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5yZWwgfHxcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLmhyZWYgfHxcbiAgICAgICAgXCJcIiA9PT0gcHJvcHMuaHJlZiB8fFxuICAgICAgICBwcm9wcy5vbkxvYWQgfHxcbiAgICAgICAgcHJvcHMub25FcnJvclxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICAgIHN3aXRjaCAocHJvcHMucmVsKSB7XG4gICAgICAgIGNhc2UgXCJzdHlsZXNoZWV0XCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlID0gcHJvcHMuZGlzYWJsZWQpLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiYgbnVsbCA9PSB0eXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgaWYgKFxuICAgICAgICBwcm9wcy5hc3luYyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wcy5hc3luYyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMuYXN5bmMgJiZcbiAgICAgICAgIXByb3BzLm9uTG9hZCAmJlxuICAgICAgICAhcHJvcHMub25FcnJvciAmJlxuICAgICAgICBwcm9wcy5zcmMgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnNyY1xuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcHJlbG9hZFJlc291cmNlKHJlc291cmNlKSB7XG4gIHJldHVybiBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJiAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDMpXG4gICAgPyAhMVxuICAgIDogITA7XG59XG52YXIgc3VzcGVuZGVkU3RhdGUgPSBudWxsO1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBzdXNwZW5kUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgcmVzb3VyY2UsIHByb3BzKSB7XG4gIGlmIChudWxsID09PSBzdXNwZW5kZWRTdGF0ZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzUpKTtcbiAgdmFyIHN0YXRlID0gc3VzcGVuZGVkU3RhdGU7XG4gIGlmIChcbiAgICBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMubWVkaWEgfHxcbiAgICAgICExICE9PSBtYXRjaE1lZGlhKHByb3BzLm1lZGlhKS5tYXRjaGVzKSAmJlxuICAgIDAgPT09IChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgNClcbiAgKSB7XG4gICAgaWYgKG51bGwgPT09IHJlc291cmNlLmluc3RhbmNlKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0U3R5bGVLZXkocHJvcHMuaHJlZiksXG4gICAgICAgIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KVxuICAgICAgICApO1xuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGhvaXN0YWJsZVJvb3QgPSBpbnN0YW5jZS5fcDtcbiAgICAgICAgbnVsbCAhPT0gaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBob2lzdGFibGVSb290ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaG9pc3RhYmxlUm9vdC50aGVuICYmXG4gICAgICAgICAgKHN0YXRlLmNvdW50KyssXG4gICAgICAgICAgKHN0YXRlID0gb25VbnN1c3BlbmQuYmluZChzdGF0ZSkpLFxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QudGhlbihzdGF0ZSwgc3RhdGUpKTtcbiAgICAgICAgcmVzb3VyY2Uuc3RhdGUubG9hZGluZyB8PSA0O1xuICAgICAgICByZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UgPSBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgIHByb3BzID0gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKTtcbiAgICAgIChrZXkgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChwcm9wcywga2V5KTtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgIHZhciBsaW5rSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIGxpbmtJbnN0YW5jZS5fcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGlua0luc3RhbmNlLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGxpbmtJbnN0YW5jZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhpbnN0YW5jZSwgXCJsaW5rXCIsIHByb3BzKTtcbiAgICAgIHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIG51bGwgPT09IHN0YXRlLnN0eWxlc2hlZXRzICYmIChzdGF0ZS5zdHlsZXNoZWV0cyA9IG5ldyBNYXAoKSk7XG4gICAgc3RhdGUuc3R5bGVzaGVldHMuc2V0KHJlc291cmNlLCBob2lzdGFibGVSb290KTtcbiAgICAoaG9pc3RhYmxlUm9vdCA9IHJlc291cmNlLnN0YXRlLnByZWxvYWQpICYmXG4gICAgICAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDMpICYmXG4gICAgICAoc3RhdGUuY291bnQrKyxcbiAgICAgIChyZXNvdXJjZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgIGhvaXN0YWJsZVJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVzb3VyY2UpLFxuICAgICAgaG9pc3RhYmxlUm9vdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVzb3VyY2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FpdEZvckNvbW1pdFRvQmVSZWFkeSgpIHtcbiAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFN0YXRlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ3NSkpO1xuICB2YXIgc3RhdGUgPSBzdXNwZW5kZWRTdGF0ZTtcbiAgc3RhdGUuc3R5bGVzaGVldHMgJiZcbiAgICAwID09PSBzdGF0ZS5jb3VudCAmJlxuICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHN0YXRlLCBzdGF0ZS5zdHlsZXNoZWV0cyk7XG4gIHJldHVybiAwIDwgc3RhdGUuY291bnRcbiAgICA/IGZ1bmN0aW9uIChjb21taXQpIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlLnN0eWxlc2hlZXRzICYmXG4gICAgICAgICAgICBpbnNlcnRTdXNwZW5kZWRTdHlsZXNoZWV0cyhzdGF0ZSwgc3RhdGUuc3R5bGVzaGVldHMpO1xuICAgICAgICAgIGlmIChzdGF0ZS51bnN1c3BlbmQpIHtcbiAgICAgICAgICAgIHZhciB1bnN1c3BlbmQgPSBzdGF0ZS51bnN1c3BlbmQ7XG4gICAgICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBudWxsO1xuICAgICAgICAgICAgdW5zdXNwZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCA2ZTQpO1xuICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBjb21taXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUudW5zdXNwZW5kID0gbnVsbDtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc3R5bGVzaGVldFRpbWVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICA6IG51bGw7XG59XG5mdW5jdGlvbiBvblVuc3VzcGVuZCgpIHtcbiAgdGhpcy5jb3VudC0tO1xuICBpZiAoMCA9PT0gdGhpcy5jb3VudClcbiAgICBpZiAodGhpcy5zdHlsZXNoZWV0cykgaW5zZXJ0U3VzcGVuZGVkU3R5bGVzaGVldHModGhpcywgdGhpcy5zdHlsZXNoZWV0cyk7XG4gICAgZWxzZSBpZiAodGhpcy51bnN1c3BlbmQpIHtcbiAgICAgIHZhciB1bnN1c3BlbmQgPSB0aGlzLnVuc3VzcGVuZDtcbiAgICAgIHRoaXMudW5zdXNwZW5kID0gbnVsbDtcbiAgICAgIHVuc3VzcGVuZCgpO1xuICAgIH1cbn1cbnZhciBwcmVjZWRlbmNlc0J5Um9vdCA9IG51bGw7XG5mdW5jdGlvbiBpbnNlcnRTdXNwZW5kZWRTdHlsZXNoZWV0cyhzdGF0ZSwgcmVzb3VyY2VzKSB7XG4gIHN0YXRlLnN0eWxlc2hlZXRzID0gbnVsbDtcbiAgbnVsbCAhPT0gc3RhdGUudW5zdXNwZW5kICYmXG4gICAgKHN0YXRlLmNvdW50KyssXG4gICAgKHByZWNlZGVuY2VzQnlSb290ID0gbmV3IE1hcCgpKSxcbiAgICByZXNvdXJjZXMuZm9yRWFjaChpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3QsIHN0YXRlKSxcbiAgICAocHJlY2VkZW5jZXNCeVJvb3QgPSBudWxsKSxcbiAgICBvblVuc3VzcGVuZC5jYWxsKHN0YXRlKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3Qocm9vdCwgcmVzb3VyY2UpIHtcbiAgaWYgKCEocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDQpKSB7XG4gICAgdmFyIHByZWNlZGVuY2VzID0gcHJlY2VkZW5jZXNCeVJvb3QuZ2V0KHJvb3QpO1xuICAgIGlmIChwcmVjZWRlbmNlcykgdmFyIGxhc3QgPSBwcmVjZWRlbmNlcy5nZXQobnVsbCk7XG4gICAgZWxzZSB7XG4gICAgICBwcmVjZWRlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHByZWNlZGVuY2VzQnlSb290LnNldChyb290LCBwcmVjZWRlbmNlcyk7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICBcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgICBpIDwgbm9kZXMubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgICkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJMSU5LXCIgPT09IG5vZGUubm9kZU5hbWUgfHxcbiAgICAgICAgICBcIm5vdCBhbGxcIiAhPT0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKVxuICAgICAgICApXG4gICAgICAgICAgcHJlY2VkZW5jZXMuc2V0KG5vZGUuZGF0YXNldC5wcmVjZWRlbmNlLCBub2RlKSwgKGxhc3QgPSBub2RlKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgJiYgcHJlY2VkZW5jZXMuc2V0KG51bGwsIGxhc3QpO1xuICAgIH1cbiAgICBub2RlcyA9IHJlc291cmNlLmluc3RhbmNlO1xuICAgIG5vZGUgPSBub2Rlcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7XG4gICAgaSA9IHByZWNlZGVuY2VzLmdldChub2RlKSB8fCBsYXN0O1xuICAgIGkgPT09IGxhc3QgJiYgcHJlY2VkZW5jZXMuc2V0KG51bGwsIG5vZGVzKTtcbiAgICBwcmVjZWRlbmNlcy5zZXQobm9kZSwgbm9kZXMpO1xuICAgIHRoaXMuY291bnQrKztcbiAgICBsYXN0ID0gb25VbnN1c3BlbmQuYmluZCh0aGlzKTtcbiAgICBub2Rlcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsYXN0KTtcbiAgICBub2Rlcy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgbGFzdCk7XG4gICAgaVxuICAgICAgPyBpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVzLCBpLm5leHRTaWJsaW5nKVxuICAgICAgOiAoKHJvb3QgPSA5ID09PSByb290Lm5vZGVUeXBlID8gcm9vdC5oZWFkIDogcm9vdCksXG4gICAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKG5vZGVzLCByb290LmZpcnN0Q2hpbGQpKTtcbiAgICByZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IDQ7XG4gIH1cbn1cbnZhciBIb3N0VHJhbnNpdGlvbkNvbnRleHQgPSB7XG4gICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gIFByb3ZpZGVyOiBudWxsLFxuICBDb25zdW1lcjogbnVsbCxcbiAgX2N1cnJlbnRWYWx1ZTogc2hhcmVkTm90UGVuZGluZ09iamVjdCxcbiAgX2N1cnJlbnRWYWx1ZTI6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gIF90aHJlYWRDb3VudDogMFxufTtcbmZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoXG4gIGNvbnRhaW5lckluZm8sXG4gIHRhZyxcbiAgaHlkcmF0ZSxcbiAgaWRlbnRpZmllclByZWZpeCxcbiAgb25VbmNhdWdodEVycm9yLFxuICBvbkNhdWdodEVycm9yLFxuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIGZvcm1TdGF0ZVxuKSB7XG4gIHRoaXMudGFnID0gMTtcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5maW5pc2hlZFdvcmsgPVxuICAgIHRoaXMucGluZ0NhY2hlID1cbiAgICB0aGlzLmN1cnJlbnQgPVxuICAgIHRoaXMucGVuZGluZ0NoaWxkcmVuID1cbiAgICAgIG51bGw7XG4gIHRoaXMudGltZW91dEhhbmRsZSA9IC0xO1xuICB0aGlzLmNhbGxiYWNrTm9kZSA9XG4gICAgdGhpcy5uZXh0ID1cbiAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICB0aGlzLmNvbnRleHQgPVxuICAgIHRoaXMuY2FuY2VsUGVuZGluZ0NvbW1pdCA9XG4gICAgICBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoLTEpO1xuICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICB0aGlzLnNoZWxsU3VzcGVuZENvdW50ZXIgPVxuICAgIHRoaXMuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgPVxuICAgIHRoaXMuZmluaXNoZWRMYW5lcyA9XG4gICAgdGhpcy5leHBpcmVkTGFuZXMgPVxuICAgIHRoaXMud2FybUxhbmVzID1cbiAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICB0aGlzLnN1c3BlbmRlZExhbmVzID1cbiAgICB0aGlzLnBlbmRpbmdMYW5lcyA9XG4gICAgICAwO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKDApO1xuICB0aGlzLmhpZGRlblVwZGF0ZXMgPSBjcmVhdGVMYW5lTWFwKG51bGwpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgdGhpcy5vbkNhdWdodEVycm9yID0gb25DYXVnaHRFcnJvcjtcbiAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gIHRoaXMucG9vbGVkQ2FjaGUgPSBudWxsO1xuICB0aGlzLnBvb2xlZENhY2hlTGFuZXMgPSAwO1xuICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgdGhpcy5pbmNvbXBsZXRlVHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoXG4gIGNvbnRhaW5lckluZm8sXG4gIHRhZyxcbiAgaHlkcmF0ZSxcbiAgaW5pdGlhbENoaWxkcmVuLFxuICBoeWRyYXRpb25DYWxsYmFja3MsXG4gIGlzU3RyaWN0TW9kZSxcbiAgaWRlbnRpZmllclByZWZpeCxcbiAgb25VbmNhdWdodEVycm9yLFxuICBvbkNhdWdodEVycm9yLFxuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gIGZvcm1TdGF0ZVxuKSB7XG4gIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICBjb250YWluZXJJbmZvLFxuICAgIHRhZyxcbiAgICBoeWRyYXRlLFxuICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgb25VbmNhdWdodEVycm9yLFxuICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgIGZvcm1TdGF0ZVxuICApO1xuICB0YWcgPSAxO1xuICAhMCA9PT0gaXNTdHJpY3RNb2RlICYmICh0YWcgfD0gMjQpO1xuICBpc1N0cmljdE1vZGUgPSBjcmVhdGVGaWJlckltcGxDbGFzcygzLCBudWxsLCBudWxsLCB0YWcpO1xuICBjb250YWluZXJJbmZvLmN1cnJlbnQgPSBpc1N0cmljdE1vZGU7XG4gIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICB0YWcgPSBjcmVhdGVDYWNoZSgpO1xuICB0YWcucmVmQ291bnQrKztcbiAgY29udGFpbmVySW5mby5wb29sZWRDYWNoZSA9IHRhZztcbiAgdGFnLnJlZkNvdW50Kys7XG4gIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICBpc0RlaHlkcmF0ZWQ6IGh5ZHJhdGUsXG4gICAgY2FjaGU6IHRhZ1xuICB9O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUoaXNTdHJpY3RNb2RlKTtcbiAgcmV0dXJuIGNvbnRhaW5lckluZm87XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHBhcmVudENvbXBvbmVudCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgcmV0dXJuIHBhcmVudENvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gIHJvb3RGaWJlcixcbiAgbGFuZSxcbiAgZWxlbWVudCxcbiAgY29udGFpbmVyLFxuICBwYXJlbnRDb21wb25lbnQsXG4gIGNhbGxiYWNrXG4pIHtcbiAgcGFyZW50Q29tcG9uZW50ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICA/IChjb250YWluZXIuY29udGV4dCA9IHBhcmVudENvbXBvbmVudClcbiAgICA6IChjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpO1xuICBjb250YWluZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIGNvbnRhaW5lci5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG4gIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgbnVsbCAhPT0gY2FsbGJhY2sgJiYgKGNvbnRhaW5lci5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICBudWxsICE9PSBlbGVtZW50ICYmXG4gICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihlbGVtZW50LCByb290RmliZXIsIGxhbmUpLFxuICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSk7XG59XG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGZpYmVyICYmIG51bGwgIT09IGZpYmVyLmRlaHlkcmF0ZWQpIHtcbiAgICB2YXIgYSA9IGZpYmVyLnJldHJ5TGFuZTtcbiAgICBmaWJlci5yZXRyeUxhbmUgPSAwICE9PSBhICYmIGEgPCByZXRyeUxhbmUgPyBhIDogcmV0cnlMYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAoZmliZXIgPSBmaWJlci5hbHRlcm5hdGUpICYmIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgNjcxMDg4NjQpO1xuICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCA2NzEwODg2NCk7XG4gICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgfVxufVxudmFyIF9lbmFibGVkID0gITA7XG5mdW5jdGlvbiBkaXNwYXRjaERpc2NyZXRlRXZlbnQoXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgY29udGFpbmVyLFxuICBuYXRpdmVFdmVudFxuKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gIHRyeSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSAyKSxcbiAgICAgIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgfSBmaW5hbGx5IHtcbiAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc3BhdGNoQ29udGludW91c0V2ZW50KFxuICBkb21FdmVudE5hbWUsXG4gIGV2ZW50U3lzdGVtRmxhZ3MsXG4gIGNvbnRhaW5lcixcbiAgbmF0aXZlRXZlbnRcbikge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gOCksXG4gICAgICBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KFxuICBkb21FdmVudE5hbWUsXG4gIGV2ZW50U3lzdGVtRmxhZ3MsXG4gIHRhcmdldENvbnRhaW5lcixcbiAgbmF0aXZlRXZlbnRcbikge1xuICBpZiAoX2VuYWJsZWQpIHtcbiAgICB2YXIgYmxvY2tlZE9uID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKG51bGwgPT09IGJsb2NrZWRPbilcbiAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgcmV0dXJuX3RhcmdldEluc3QsXG4gICAgICAgIHRhcmdldENvbnRhaW5lclxuICAgICAgKSxcbiAgICAgICAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcbiAgICBlbHNlIGlmIChcbiAgICAgIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoXG4gICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICApXG4gICAgKVxuICAgICAgbmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZWxzZSBpZiAoXG4gICAgICAoY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MgJiA0ICYmXG4gICAgICAgIC0xIDwgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzLmluZGV4T2YoZG9tRXZlbnROYW1lKSlcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBibG9ja2VkT247ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG4gICAgICAgIGlmIChudWxsICE9PSBmaWJlcilcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBmaWJlciA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGZpYmVyLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhmaWJlci5wZW5kaW5nTGFuZXMpO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBmaWJlcjtcbiAgICAgICAgICAgICAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IDI7XG4gICAgICAgICAgICAgICAgICBmb3IgKHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gMjsgbGFuZXM7ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IDEgPDwgKDMxIC0gY2x6MzIobGFuZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzWzFdIHw9IGxhbmU7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGZpYmVyKTtcbiAgICAgICAgICAgICAgICAgIDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgNikgJiZcbiAgICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93KCkgKyA1MDApLFxuICAgICAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIChyb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpLFxuICAgICAgICAgICAgICAgIGZsdXNoU3luY1dvcmskMSgpLFxuICAgICAgICAgICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChuYXRpdmVFdmVudCk7XG4gICAgICAgIG51bGwgPT09IGZpYmVyICYmXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgcmV0dXJuX3RhcmdldEluc3QsXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoZmliZXIgPT09IGJsb2NrZWRPbikgYnJlYWs7XG4gICAgICAgIGJsb2NrZWRPbiA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZVxuICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBudWxsLFxuICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgbmF0aXZlRXZlbnQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHJldHVybiBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChuYXRpdmVFdmVudCk7XG59XG52YXIgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsO1xuZnVuY3Rpb24gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQodGFyZ2V0Tm9kZSkge1xuICByZXR1cm5fdGFyZ2V0SW5zdCA9IG51bGw7XG4gIHRhcmdldE5vZGUgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKTtcbiAgaWYgKG51bGwgIT09IHRhcmdldE5vZGUpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldE5vZGUpO1xuICAgIGlmIChudWxsID09PSBuZWFyZXN0TW91bnRlZCkgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdGFnID0gbmVhcmVzdE1vdW50ZWQudGFnO1xuICAgICAgaWYgKDEzID09PSB0YWcpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICBpZiAobnVsbCAhPT0gdGFyZ2V0Tm9kZSkgcmV0dXJuIHRhcmdldE5vZGU7XG4gICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICgzID09PSB0YWcpIHtcbiAgICAgICAgaWYgKG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKVxuICAgICAgICAgIHJldHVybiAzID09PSBuZWFyZXN0TW91bnRlZC50YWdcbiAgICAgICAgICAgID8gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgICB9IGVsc2UgbmVhcmVzdE1vdW50ZWQgIT09IHRhcmdldE5vZGUgJiYgKHRhcmdldE5vZGUgPSBudWxsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuX3RhcmdldEluc3QgPSB0YXJnZXROb2RlO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImJlZm9yZXRvZ2dsZVwiOlxuICAgIGNhc2UgXCJjYW5jZWxcIjpcbiAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICBjYXNlIFwiY29weVwiOlxuICAgIGNhc2UgXCJjdXRcIjpcbiAgICBjYXNlIFwiYXV4Y2xpY2tcIjpcbiAgICBjYXNlIFwiZGJsY2xpY2tcIjpcbiAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgIGNhc2UgXCJkcmFnc3RhcnRcIjpcbiAgICBjYXNlIFwiZHJvcFwiOlxuICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgY2FzZSBcImlucHV0XCI6XG4gICAgY2FzZSBcImludmFsaWRcIjpcbiAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgIGNhc2UgXCJwYXVzZVwiOlxuICAgIGNhc2UgXCJwbGF5XCI6XG4gICAgY2FzZSBcInBvaW50ZXJjYW5jZWxcIjpcbiAgICBjYXNlIFwicG9pbnRlcmRvd25cIjpcbiAgICBjYXNlIFwicG9pbnRlcnVwXCI6XG4gICAgY2FzZSBcInJhdGVjaGFuZ2VcIjpcbiAgICBjYXNlIFwicmVzZXRcIjpcbiAgICBjYXNlIFwicmVzaXplXCI6XG4gICAgY2FzZSBcInNlZWtlZFwiOlxuICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICBjYXNlIFwidG9nZ2xlXCI6XG4gICAgY2FzZSBcInRvdWNoY2FuY2VsXCI6XG4gICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICBjYXNlIFwidm9sdW1lY2hhbmdlXCI6XG4gICAgY2FzZSBcImNoYW5nZVwiOlxuICAgIGNhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjpcbiAgICBjYXNlIFwidGV4dElucHV0XCI6XG4gICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICBjYXNlIFwiYmVmb3JlYmx1clwiOlxuICAgIGNhc2UgXCJhZnRlcmJsdXJcIjpcbiAgICBjYXNlIFwiYmVmb3JlaW5wdXRcIjpcbiAgICBjYXNlIFwiYmx1clwiOlxuICAgIGNhc2UgXCJmdWxsc2NyZWVuY2hhbmdlXCI6XG4gICAgY2FzZSBcImZvY3VzXCI6XG4gICAgY2FzZSBcImhhc2hjaGFuZ2VcIjpcbiAgICBjYXNlIFwicG9wc3RhdGVcIjpcbiAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgY2FzZSBcInNlbGVjdHN0YXJ0XCI6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIFwiZHJhZ1wiOlxuICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICBjYXNlIFwiZHJhZ2V4aXRcIjpcbiAgICBjYXNlIFwiZHJhZ2xlYXZlXCI6XG4gICAgY2FzZSBcImRyYWdvdmVyXCI6XG4gICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICBjYXNlIFwicG9pbnRlcm1vdmVcIjpcbiAgICBjYXNlIFwicG9pbnRlcm91dFwiOlxuICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxuICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgY2FzZSBcIndoZWVsXCI6XG4gICAgY2FzZSBcIm1vdXNlZW50ZXJcIjpcbiAgICBjYXNlIFwibW91c2VsZWF2ZVwiOlxuICAgIGNhc2UgXCJwb2ludGVyZW50ZXJcIjpcbiAgICBjYXNlIFwicG9pbnRlcmxlYXZlXCI6XG4gICAgICByZXR1cm4gODtcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgc3dpdGNoIChnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpKSB7XG4gICAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgTm9ybWFsUHJpb3JpdHkkMTpcbiAgICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMzI7XG4gIH1cbn1cbnZhciBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gITEsXG4gIHF1ZXVlZEZvY3VzID0gbnVsbCxcbiAgcXVldWVkRHJhZyA9IG51bGwsXG4gIHF1ZXVlZE1vdXNlID0gbnVsbCxcbiAgcXVldWVkUG9pbnRlcnMgPSBuZXcgTWFwKCksXG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcyA9IG5ldyBNYXAoKSxcbiAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzID0gW10sXG4gIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyA9XG4gICAgXCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXRcIi5zcGxpdChcbiAgICAgIFwiIFwiXG4gICAgKTtcbmZ1bmN0aW9uIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgY2FzZSBcImRyYWdsZWF2ZVwiOlxuICAgICAgcXVldWVkRHJhZyA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICBjYXNlIFwicG9pbnRlcm91dFwiOlxuICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpcbiAgICBjYXNlIFwibG9zdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gIGV4aXN0aW5nUXVldWVkRXZlbnQsXG4gIGJsb2NrZWRPbixcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICB0YXJnZXRDb250YWluZXIsXG4gIG5hdGl2ZUV2ZW50XG4pIHtcbiAgaWYgKFxuICAgIG51bGwgPT09IGV4aXN0aW5nUXVldWVkRXZlbnQgfHxcbiAgICBleGlzdGluZ1F1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50ICE9PSBuYXRpdmVFdmVudFxuICApXG4gICAgcmV0dXJuIChcbiAgICAgIChleGlzdGluZ1F1ZXVlZEV2ZW50ID0ge1xuICAgICAgICBibG9ja2VkT246IGJsb2NrZWRPbixcbiAgICAgICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgICAgIGV2ZW50U3lzdGVtRmxhZ3M6IGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyczogW3RhcmdldENvbnRhaW5lcl1cbiAgICAgIH0pLFxuICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmXG4gICAgICAgICgoYmxvY2tlZE9uID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pKSxcbiAgICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGJsb2NrZWRPbikpLFxuICAgICAgZXhpc3RpbmdRdWV1ZWRFdmVudFxuICAgICk7XG4gIGV4aXN0aW5nUXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncyB8PSBldmVudFN5c3RlbUZsYWdzO1xuICBibG9ja2VkT24gPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG4gIG51bGwgIT09IHRhcmdldENvbnRhaW5lciAmJlxuICAgIC0xID09PSBibG9ja2VkT24uaW5kZXhPZih0YXJnZXRDb250YWluZXIpICYmXG4gICAgYmxvY2tlZE9uLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgcmV0dXJuIGV4aXN0aW5nUXVldWVkRXZlbnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KFxuICBibG9ja2VkT24sXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgdGFyZ2V0Q29udGFpbmVyLFxuICBuYXRpdmVFdmVudFxuKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChxdWV1ZWRGb2N1cyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgcXVldWVkRm9jdXMsXG4gICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApKSxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgY2FzZSBcImRyYWdlbnRlclwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgIHF1ZXVlZERyYWcsXG4gICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApKSxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHF1ZXVlZE1vdXNlID0gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICBxdWV1ZWRNb3VzZSxcbiAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICkpLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICAgIHZhciBwb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgICBxdWV1ZWRQb2ludGVycy5zZXQoXG4gICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICBxdWV1ZWRQb2ludGVycy5nZXQocG9pbnRlcklkKSB8fCBudWxsLFxuICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiAhMDtcbiAgICBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChwb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQpLFxuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuc2V0KFxuICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgICBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmdldChwb2ludGVySWQpIHx8IG51bGwsXG4gICAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgICEwXG4gICAgICApO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShxdWV1ZWRUYXJnZXQudGFyZ2V0KTtcbiAgaWYgKG51bGwgIT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuICAgIGlmIChudWxsICE9PSBuZWFyZXN0TW91bnRlZClcbiAgICAgIGlmICgoKHRhcmdldEluc3QgPSBuZWFyZXN0TW91bnRlZC50YWcpLCAxMyA9PT0gdGFyZ2V0SW5zdCkpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgodGFyZ2V0SW5zdCA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpKSxcbiAgICAgICAgICBudWxsICE9PSB0YXJnZXRJbnN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBydW5XaXRoUHJpb3JpdHkocXVldWVkVGFyZ2V0LnByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoMTMgPT09IG5lYXJlc3RNb3VudGVkLnRhZykge1xuICAgICAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCksXG4gICAgICAgICAgICAgICAgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShuZWFyZXN0TW91bnRlZCwgbGFuZSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgbmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChuZWFyZXN0TW91bnRlZCwgbGFuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAzID09PSB0YXJnZXRJbnN0ICYmXG4gICAgICAgIG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkXG4gICAgICApIHtcbiAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9XG4gICAgICAgICAgMyA9PT0gbmVhcmVzdE1vdW50ZWQudGFnXG4gICAgICAgICAgICA/IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpIHtcbiAgaWYgKG51bGwgIT09IHF1ZXVlZEV2ZW50LmJsb2NrZWRPbikgcmV0dXJuICExO1xuICBmb3IgKFxuICAgIHZhciB0YXJnZXRDb250YWluZXJzID0gcXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztcbiAgICAwIDwgdGFyZ2V0Q29udGFpbmVycy5sZW5ndGg7XG5cbiAgKSB7XG4gICAgdmFyIG5leHRCbG9ja2VkT24gPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICBpZiAobnVsbCA9PT0gbmV4dEJsb2NrZWRPbikge1xuICAgICAgbmV4dEJsb2NrZWRPbiA9IHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgdmFyIG5hdGl2ZUV2ZW50Q2xvbmUgPSBuZXcgbmV4dEJsb2NrZWRPbi5jb25zdHJ1Y3RvcihcbiAgICAgICAgbmV4dEJsb2NrZWRPbi50eXBlLFxuICAgICAgICBuZXh0QmxvY2tlZE9uXG4gICAgICApO1xuICAgICAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbmF0aXZlRXZlbnRDbG9uZTtcbiAgICAgIG5leHRCbG9ja2VkT24udGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7XG4gICAgICBjdXJyZW50UmVwbGF5aW5nRXZlbnQgPSBudWxsO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHRhcmdldENvbnRhaW5lcnMgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKG5leHRCbG9ja2VkT24pKSxcbiAgICAgICAgbnVsbCAhPT0gdGFyZ2V0Q29udGFpbmVycyAmJlxuICAgICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKHRhcmdldENvbnRhaW5lcnMpLFxuICAgICAgICAocXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbmV4dEJsb2NrZWRPbiksXG4gICAgICAgICExXG4gICAgICApO1xuICAgIHRhcmdldENvbnRhaW5lcnMuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAocXVldWVkRXZlbnQsIGtleSwgbWFwKSB7XG4gIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpICYmIG1hcC5kZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIHJlcGxheVVuYmxvY2tlZEV2ZW50cygpIHtcbiAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICExO1xuICBudWxsICE9PSBxdWV1ZWRGb2N1cyAmJlxuICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRm9jdXMpICYmXG4gICAgKHF1ZXVlZEZvY3VzID0gbnVsbCk7XG4gIG51bGwgIT09IHF1ZXVlZERyYWcgJiZcbiAgICBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpICYmXG4gICAgKHF1ZXVlZERyYWcgPSBudWxsKTtcbiAgbnVsbCAhPT0gcXVldWVkTW91c2UgJiZcbiAgICBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZE1vdXNlKSAmJlxuICAgIChxdWV1ZWRNb3VzZSA9IG51bGwpO1xuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCkge1xuICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCAmJlxuICAgICgocXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbCksXG4gICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCB8fFxuICAgICAgKChoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gITApLFxuICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgICAgcmVwbGF5VW5ibG9ja2VkRXZlbnRzXG4gICAgICApKSk7XG59XG52YXIgbGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlID0gbnVsbDtcbmZ1bmN0aW9uIHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChmb3JtUmVwbGF5aW5nUXVldWUpIHtcbiAgbGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlICE9PSBmb3JtUmVwbGF5aW5nUXVldWUgJiZcbiAgICAoKGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9IGZvcm1SZXBsYXlpbmdRdWV1ZSksXG4gICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9PT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgICAgICAgKGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9IG51bGwpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1SZXBsYXlpbmdRdWV1ZS5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIHZhciBmb3JtID0gZm9ybVJlcGxheWluZ1F1ZXVlW2ldLFxuICAgICAgICAgICAgc3VibWl0dGVyT3JBY3Rpb24gPSBmb3JtUmVwbGF5aW5nUXVldWVbaSArIDFdLFxuICAgICAgICAgICAgZm9ybURhdGEgPSBmb3JtUmVwbGF5aW5nUXVldWVbaSArIDJdO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBzdWJtaXR0ZXJPckFjdGlvbilcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChzdWJtaXR0ZXJPckFjdGlvbiB8fCBmb3JtKSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgIHZhciBmb3JtSW5zdCA9IGdldEluc3RhbmNlRnJvbU5vZGUoZm9ybSk7XG4gICAgICAgICAgbnVsbCAhPT0gZm9ybUluc3QgJiZcbiAgICAgICAgICAgIChmb3JtUmVwbGF5aW5nUXVldWUuc3BsaWNlKGksIDMpLFxuICAgICAgICAgICAgKGkgLT0gMyksXG4gICAgICAgICAgICBzdGFydEhvc3RUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICBmb3JtSW5zdCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZm9ybS5tZXRob2QsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBzdWJtaXR0ZXJPckFjdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbixcbiAgICAgICAgICAgICAgZm9ybURhdGFcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKSk7XG59XG5mdW5jdGlvbiByZXRyeUlmQmxvY2tlZE9uKHVuYmxvY2tlZCkge1xuICBmdW5jdGlvbiB1bmJsb2NrKHF1ZXVlZEV2ZW50KSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKTtcbiAgfVxuICBudWxsICE9PSBxdWV1ZWRGb2N1cyAmJiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsIHVuYmxvY2tlZCk7XG4gIG51bGwgIT09IHF1ZXVlZERyYWcgJiYgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERyYWcsIHVuYmxvY2tlZCk7XG4gIG51bGwgIT09IHF1ZXVlZE1vdXNlICYmIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRNb3VzZSwgdW5ibG9ja2VkKTtcbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaCh1bmJsb2NrKTtcbiAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2godW5ibG9jayk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHF1ZXVlZFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXTtcbiAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQgJiYgKHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsKTtcbiAgfVxuICBmb3IgKFxuICAgIDtcbiAgICAwIDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aCAmJlxuICAgICgoaSA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1swXSksIG51bGwgPT09IGkuYmxvY2tlZE9uKTtcblxuICApXG4gICAgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KGkpLFxuICAgICAgbnVsbCA9PT0gaS5ibG9ja2VkT24gJiYgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNoaWZ0KCk7XG4gIGkgPSAodW5ibG9ja2VkLm93bmVyRG9jdW1lbnQgfHwgdW5ibG9ja2VkKS4kJHJlYWN0Rm9ybVJlcGxheTtcbiAgaWYgKG51bGwgIT0gaSlcbiAgICBmb3IgKHF1ZXVlZFRhcmdldCA9IDA7IHF1ZXVlZFRhcmdldCA8IGkubGVuZ3RoOyBxdWV1ZWRUYXJnZXQgKz0gMykge1xuICAgICAgdmFyIGZvcm0gPSBpW3F1ZXVlZFRhcmdldF0sXG4gICAgICAgIHN1Ym1pdHRlck9yQWN0aW9uID0gaVtxdWV1ZWRUYXJnZXQgKyAxXSxcbiAgICAgICAgZm9ybVByb3BzID0gZm9ybVtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN1Ym1pdHRlck9yQWN0aW9uKVxuICAgICAgICBmb3JtUHJvcHMgfHwgc2NoZWR1bGVSZXBsYXlRdWV1ZUlmTmVlZGVkKGkpO1xuICAgICAgZWxzZSBpZiAoZm9ybVByb3BzKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAoc3VibWl0dGVyT3JBY3Rpb24gJiYgc3VibWl0dGVyT3JBY3Rpb24uaGFzQXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGZvcm0gPSBzdWJtaXR0ZXJPckFjdGlvbiksXG4gICAgICAgICAgICAoZm9ybVByb3BzID0gc3VibWl0dGVyT3JBY3Rpb25baW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYWN0aW9uID0gZm9ybVByb3BzLmZvcm1BY3Rpb247XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQoZm9ybSkpIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBhY3Rpb24gPSBmb3JtUHJvcHMuYWN0aW9uO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb25cbiAgICAgICAgICA/IChpW3F1ZXVlZFRhcmdldCArIDFdID0gYWN0aW9uKVxuICAgICAgICAgIDogKGkuc3BsaWNlKHF1ZXVlZFRhcmdldCwgMyksIChxdWV1ZWRUYXJnZXQgLT0gMykpO1xuICAgICAgICBzY2hlZHVsZVJlcGxheVF1ZXVlSWZOZWVkZWQoaSk7XG4gICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gUmVhY3RET01Sb290KGludGVybmFsUm9vdCkge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBpbnRlcm5hbFJvb3Q7XG59XG5SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnJlbmRlciA9IFJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID1cbiAgZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gICAgaWYgKG51bGwgPT09IHJvb3QpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDA5KSk7XG4gICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQsXG4gICAgICBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKTtcbiAgICB1cGRhdGVDb250YWluZXJJbXBsKGN1cnJlbnQsIGxhbmUsIGNoaWxkcmVuLCByb290LCBudWxsLCBudWxsKTtcbiAgfTtcblJlYWN0RE9NSHlkcmF0aW9uUm9vdC5wcm90b3R5cGUudW5tb3VudCA9IFJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudCA9XG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgICBpZiAobnVsbCAhPT0gcm9vdCkge1xuICAgICAgdGhpcy5faW50ZXJuYWxSb290ID0gbnVsbDtcbiAgICAgIHZhciBjb250YWluZXIgPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAwID09PSByb290LnRhZyAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICB1cGRhdGVDb250YWluZXJJbXBsKHJvb3QuY3VycmVudCwgMiwgbnVsbCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgICBmbHVzaFN5bmNXb3JrJDEoKTtcbiAgICAgIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IG51bGw7XG4gICAgfVxuICB9O1xuZnVuY3Rpb24gUmVhY3RET01IeWRyYXRpb25Sb290KGludGVybmFsUm9vdCkge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBpbnRlcm5hbFJvb3Q7XG59XG5SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnVuc3RhYmxlX3NjaGVkdWxlSHlkcmF0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgdmFyIHVwZGF0ZVByaW9yaXR5ID0gcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCk7XG4gICAgdGFyZ2V0ID0geyBibG9ja2VkT246IG51bGwsIHRhcmdldDogdGFyZ2V0LCBwcmlvcml0eTogdXBkYXRlUHJpb3JpdHkgfTtcbiAgICBmb3IgKFxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggJiZcbiAgICAgIDAgIT09IHVwZGF0ZVByaW9yaXR5ICYmXG4gICAgICB1cGRhdGVQcmlvcml0eSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXS5wcmlvcml0eTtcbiAgICAgIGkrK1xuICAgICk7XG4gICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNwbGljZShpLCAwLCB0YXJnZXQpO1xuICAgIDAgPT09IGkgJiYgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHRhcmdldCk7XG4gIH1cbn07XG52YXIgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24kanNjb21wJGlubGluZV8xNjg2ID0gUmVhY3QudmVyc2lvbjtcbmlmIChcbiAgXCIxOS4wLjBcIiAhPT1cbiAgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24kanNjb21wJGlubGluZV8xNjg2XG4pXG4gIHRocm93IEVycm9yKFxuICAgIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoXG4gICAgICA1MjcsXG4gICAgICBpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiRqc2NvbXAkaW5saW5lXzE2ODYsXG4gICAgICBcIjE5LjAuMFwiXG4gICAgKVxuICApO1xuUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZmluZERPTU5vZGUgPSBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIHZhciBmaWJlciA9IGNvbXBvbmVudE9yRWxlbWVudC5fcmVhY3RJbnRlcm5hbHM7XG4gIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIpXG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xuICAgIGNvbXBvbmVudE9yRWxlbWVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkuam9pbihcIixcIik7XG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNjgsIGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICB9XG4gIGNvbXBvbmVudE9yRWxlbWVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgY29tcG9uZW50T3JFbGVtZW50ID1cbiAgICBudWxsICE9PSBjb21wb25lbnRPckVsZW1lbnRcbiAgICAgID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGNvbXBvbmVudE9yRWxlbWVudClcbiAgICAgIDogbnVsbDtcbiAgY29tcG9uZW50T3JFbGVtZW50ID1cbiAgICBudWxsID09PSBjb21wb25lbnRPckVsZW1lbnQgPyBudWxsIDogY29tcG9uZW50T3JFbGVtZW50LnN0YXRlTm9kZTtcbiAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbn07XG52YXIgaW50ZXJuYWxzJGpzY29tcCRpbmxpbmVfMjE2NSA9IHtcbiAgYnVuZGxlVHlwZTogMCxcbiAgdmVyc2lvbjogXCIxOS4wLjBcIixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogXCJyZWFjdC1kb21cIixcbiAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjAuMFwiXG59O1xuaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHtcbiAgdmFyIGhvb2skanNjb21wJGlubGluZV8yMTY2ID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoXG4gICAgIWhvb2skanNjb21wJGlubGluZV8yMTY2LmlzRGlzYWJsZWQgJiZcbiAgICBob29rJGpzY29tcCRpbmxpbmVfMjE2Ni5zdXBwb3J0c0ZpYmVyXG4gIClcbiAgICB0cnkge1xuICAgICAgKHJlbmRlcmVySUQgPSBob29rJGpzY29tcCRpbmxpbmVfMjE2Ni5pbmplY3QoXG4gICAgICAgIGludGVybmFscyRqc2NvbXAkaW5saW5lXzIxNjVcbiAgICAgICkpLFxuICAgICAgICAoaW5qZWN0ZWRIb29rID0gaG9vayRqc2NvbXAkaW5saW5lXzIxNjYpO1xuICAgIH0gY2F0Y2ggKGVycikge31cbn1cbmV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjk5KSk7XG4gIHZhciBpc1N0cmljdE1vZGUgPSAhMSxcbiAgICBpZGVudGlmaWVyUHJlZml4ID0gXCJcIixcbiAgICBvblVuY2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25VbmNhdWdodEVycm9yLFxuICAgIG9uQ2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25DYXVnaHRFcnJvcixcbiAgICBvblJlY292ZXJhYmxlRXJyb3IgPSBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yLFxuICAgIHRyYW5zaXRpb25DYWxsYmFja3MgPSBudWxsO1xuICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgdm9pZCAwICE9PSBvcHRpb25zICYmXG4gICAgKCEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCAmJlxuICAgICAgKGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXgpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgIChvblVuY2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uVW5jYXVnaHRFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IgJiYgKG9uQ2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IgJiZcbiAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MgJiZcbiAgICAgICh0cmFuc2l0aW9uQ2FsbGJhY2tzID0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzKSk7XG4gIG9wdGlvbnMgPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgY29udGFpbmVyLFxuICAgIDEsXG4gICAgITEsXG4gICAgbnVsbCxcbiAgICBudWxsLFxuICAgIGlzU3RyaWN0TW9kZSxcbiAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yLFxuICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgIG51bGxcbiAgKTtcbiAgY29udGFpbmVyW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gb3B0aW9ucy5jdXJyZW50O1xuICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhcbiAgICA4ID09PSBjb250YWluZXIubm9kZVR5cGUgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICApO1xuICByZXR1cm4gbmV3IFJlYWN0RE9NUm9vdChvcHRpb25zKTtcbn07XG5leHBvcnRzLmh5ZHJhdGVSb290ID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgaW5pdGlhbENoaWxkcmVuLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5OSkpO1xuICB2YXIgaXNTdHJpY3RNb2RlID0gITEsXG4gICAgaWRlbnRpZmllclByZWZpeCA9IFwiXCIsXG4gICAgb25VbmNhdWdodEVycm9yID0gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yID0gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IsXG4gICAgb25SZWNvdmVyYWJsZUVycm9yID0gZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbnVsbCxcbiAgICBmb3JtU3RhdGUgPSBudWxsO1xuICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgdm9pZCAwICE9PSBvcHRpb25zICYmXG4gICAgKCEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCAmJlxuICAgICAgKGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXgpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgIChvblVuY2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uVW5jYXVnaHRFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IgJiYgKG9uQ2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IgJiZcbiAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MgJiZcbiAgICAgICh0cmFuc2l0aW9uQ2FsbGJhY2tzID0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMuZm9ybVN0YXRlICYmIChmb3JtU3RhdGUgPSBvcHRpb25zLmZvcm1TdGF0ZSkpO1xuICBpbml0aWFsQ2hpbGRyZW4gPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgY29udGFpbmVyLFxuICAgIDEsXG4gICAgITAsXG4gICAgaW5pdGlhbENoaWxkcmVuLFxuICAgIG51bGwgIT0gb3B0aW9ucyA/IG9wdGlvbnMgOiBudWxsLFxuICAgIGlzU3RyaWN0TW9kZSxcbiAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yLFxuICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgIGZvcm1TdGF0ZVxuICApO1xuICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICBvcHRpb25zID0gaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQ7XG4gIGlzU3RyaWN0TW9kZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCk7XG4gIGlkZW50aWZpZXJQcmVmaXggPSBjcmVhdGVVcGRhdGUoaXNTdHJpY3RNb2RlKTtcbiAgaWRlbnRpZmllclByZWZpeC5jYWxsYmFjayA9IG51bGw7XG4gIGVucXVldWVVcGRhdGUob3B0aW9ucywgaWRlbnRpZmllclByZWZpeCwgaXNTdHJpY3RNb2RlKTtcbiAgaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQubGFuZXMgPSBpc1N0cmljdE1vZGU7XG4gIG1hcmtSb290VXBkYXRlZCQxKGluaXRpYWxDaGlsZHJlbiwgaXNTdHJpY3RNb2RlKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhjb250YWluZXIpO1xuICByZXR1cm4gbmV3IFJlYWN0RE9NSHlkcmF0aW9uUm9vdChpbml0aWFsQ2hpbGRyZW4pO1xufTtcbmV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMC4wXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///247\n')},221:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * react-dom.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar React = __webpack_require__(540);\nfunction formatProdErrorMessage(code) {\n  var url = "https://react.dev/errors/" + code;\n  if (1 < arguments.length) {\n    url += "?args[]=" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += "&args[]=" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    "Minified React error #" +\n    code +\n    "; visit " +\n    url +\n    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."\n  );\n}\nfunction noop() {}\nvar Internals = {\n    d: {\n      f: noop,\n      r: function () {\n        throw Error(formatProdErrorMessage(522));\n      },\n      D: noop,\n      C: noop,\n      L: noop,\n      m: noop,\n      X: noop,\n      S: noop,\n      M: noop\n    },\n    p: 0,\n    findDOMNode: null\n  },\n  REACT_PORTAL_TYPE = Symbol.for("react.portal");\nfunction createPortal$1(children, containerInfo, implementation) {\n  var key =\n    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: null == key ? null : "" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\nvar ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\nfunction getCrossOriginStringAs(as, input) {\n  if ("font" === as) return "";\n  if ("string" === typeof input)\n    return "use-credentials" === input ? input : "";\n}\nexports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  Internals;\nexports.createPortal = function (children, container) {\n  var key =\n    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n  if (\n    !container ||\n    (1 !== container.nodeType &&\n      9 !== container.nodeType &&\n      11 !== container.nodeType)\n  )\n    throw Error(formatProdErrorMessage(299));\n  return createPortal$1(children, container, null, key);\n};\nexports.flushSync = function (fn) {\n  var previousTransition = ReactSharedInternals.T,\n    previousUpdatePriority = Internals.p;\n  try {\n    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();\n  } finally {\n    (ReactSharedInternals.T = previousTransition),\n      (Internals.p = previousUpdatePriority),\n      Internals.d.f();\n  }\n};\nexports.preconnect = function (href, options) {\n  "string" === typeof href &&\n    (options\n      ? ((options = options.crossOrigin),\n        (options =\n          "string" === typeof options\n            ? "use-credentials" === options\n              ? options\n              : ""\n            : void 0))\n      : (options = null),\n    Internals.d.C(href, options));\n};\nexports.prefetchDNS = function (href) {\n  "string" === typeof href && Internals.d.D(href);\n};\nexports.preinit = function (href, options) {\n  if ("string" === typeof href && options && "string" === typeof options.as) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n      integrity =\n        "string" === typeof options.integrity ? options.integrity : void 0,\n      fetchPriority =\n        "string" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0;\n    "style" === as\n      ? Internals.d.S(\n          href,\n          "string" === typeof options.precedence ? options.precedence : void 0,\n          {\n            crossOrigin: crossOrigin,\n            integrity: integrity,\n            fetchPriority: fetchPriority\n          }\n        )\n      : "script" === as &&\n        Internals.d.X(href, {\n          crossOrigin: crossOrigin,\n          integrity: integrity,\n          fetchPriority: fetchPriority,\n          nonce: "string" === typeof options.nonce ? options.nonce : void 0\n        });\n  }\n};\nexports.preinitModule = function (href, options) {\n  if ("string" === typeof href)\n    if ("object" === typeof options && null !== options) {\n      if (null == options.as || "script" === options.as) {\n        var crossOrigin = getCrossOriginStringAs(\n          options.as,\n          options.crossOrigin\n        );\n        Internals.d.M(href, {\n          crossOrigin: crossOrigin,\n          integrity:\n            "string" === typeof options.integrity ? options.integrity : void 0,\n          nonce: "string" === typeof options.nonce ? options.nonce : void 0\n        });\n      }\n    } else null == options && Internals.d.M(href);\n};\nexports.preload = function (href, options) {\n  if (\n    "string" === typeof href &&\n    "object" === typeof options &&\n    null !== options &&\n    "string" === typeof options.as\n  ) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\n    Internals.d.L(href, as, {\n      crossOrigin: crossOrigin,\n      integrity:\n        "string" === typeof options.integrity ? options.integrity : void 0,\n      nonce: "string" === typeof options.nonce ? options.nonce : void 0,\n      type: "string" === typeof options.type ? options.type : void 0,\n      fetchPriority:\n        "string" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0,\n      referrerPolicy:\n        "string" === typeof options.referrerPolicy\n          ? options.referrerPolicy\n          : void 0,\n      imageSrcSet:\n        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\n      imageSizes:\n        "string" === typeof options.imageSizes ? options.imageSizes : void 0,\n      media: "string" === typeof options.media ? options.media : void 0\n    });\n  }\n};\nexports.preloadModule = function (href, options) {\n  if ("string" === typeof href)\n    if (options) {\n      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\n      Internals.d.m(href, {\n        as:\n          "string" === typeof options.as && "script" !== options.as\n            ? options.as\n            : void 0,\n        crossOrigin: crossOrigin,\n        integrity:\n          "string" === typeof options.integrity ? options.integrity : void 0\n      });\n    } else Internals.d.m(href);\n};\nexports.requestFormReset = function (form) {\n  Internals.d.r(form);\n};\nexports.unstable_batchedUpdates = function (fn, a) {\n  return fn(a);\n};\nexports.useFormState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useFormState(action, initialState, permalink);\n};\nexports.useFormStatus = function () {\n  return ReactSharedInternals.H.useHostTransitionStatus();\n};\nexports.version = "19.0.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxHQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLmpzPzczZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHZhciB1cmwgPSBcImh0dHBzOi8vcmVhY3QuZGV2L2Vycm9ycy9cIiArIGNvZGU7XG4gIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHVybCArPSBcIj9hcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzWzFdKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHVybCArPSBcIiZhcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICtcbiAgICBjb2RlICtcbiAgICBcIjsgdmlzaXQgXCIgK1xuICAgIHVybCArXG4gICAgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiXG4gICk7XG59XG5mdW5jdGlvbiBub29wKCkge31cbnZhciBJbnRlcm5hbHMgPSB7XG4gICAgZDoge1xuICAgICAgZjogbm9vcCxcbiAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjIpKTtcbiAgICAgIH0sXG4gICAgICBEOiBub29wLFxuICAgICAgQzogbm9vcCxcbiAgICAgIEw6IG5vb3AsXG4gICAgICBtOiBub29wLFxuICAgICAgWDogbm9vcCxcbiAgICAgIFM6IG5vb3AsXG4gICAgICBNOiBub29wXG4gICAgfSxcbiAgICBwOiAwLFxuICAgIGZpbmRET01Ob2RlOiBudWxsXG4gIH0sXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID1cbiAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleTogbnVsbCA9PSBrZXkgPyBudWxsIDogXCJcIiArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcbmZ1bmN0aW9uIGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIGlucHV0KSB7XG4gIGlmIChcImZvbnRcIiA9PT0gYXMpIHJldHVybiBcIlwiO1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KVxuICAgIHJldHVybiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dCA/IGlucHV0IDogXCJcIjtcbn1cbmV4cG9ydHMuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgSW50ZXJuYWxzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID1cbiAgICAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gIGlmIChcbiAgICAhY29udGFpbmVyIHx8XG4gICAgKDEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgOSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAxMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlKVxuICApXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTkpKTtcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59O1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHByZXZpb3VzVHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IEludGVybmFscy5wO1xuICB0cnkge1xuICAgIGlmICgoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSwgKEludGVybmFscy5wID0gMiksIGZuKSkgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2aW91c1RyYW5zaXRpb24pLFxuICAgICAgKEludGVybmFscy5wID0gcHJldmlvdXNVcGRhdGVQcmlvcml0eSksXG4gICAgICBJbnRlcm5hbHMuZC5mKCk7XG4gIH1cbn07XG5leHBvcnRzLnByZWNvbm5lY3QgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgIChvcHRpb25zXG4gICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAob3B0aW9ucyA9XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gb3B0aW9uc1xuICAgICAgICAgICAgICA/IG9wdGlvbnNcbiAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICA6IHZvaWQgMCkpXG4gICAgICA6IChvcHRpb25zID0gbnVsbCksXG4gICAgSW50ZXJuYWxzLmQuQyhocmVmLCBvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5wcmVmZXRjaEROUyA9IGZ1bmN0aW9uIChocmVmKSB7XG4gIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIEludGVybmFscy5kLkQoaHJlZik7XG59O1xuZXhwb3J0cy5wcmVpbml0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzLFxuICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgIGludGVncml0eSA9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgZmV0Y2hQcmlvcml0eSA9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICA/IG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgIDogdm9pZCAwO1xuICAgIFwic3R5bGVcIiA9PT0gYXNcbiAgICAgID8gSW50ZXJuYWxzLmQuUyhcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnByZWNlZGVuY2UgPyBvcHRpb25zLnByZWNlZGVuY2UgOiB2b2lkIDAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgaW50ZWdyaXR5OiBpbnRlZ3JpdHksXG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICA6IFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgIEludGVybmFscy5kLlgoaHJlZiwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5LFxuICAgICAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gIH1cbn07XG5leHBvcnRzLnByZWluaXRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG51bGwgIT09IG9wdGlvbnMpIHtcbiAgICAgIGlmIChudWxsID09IG9wdGlvbnMuYXMgfHwgXCJzY3JpcHRcIiA9PT0gb3B0aW9ucy5hcykge1xuICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICApO1xuICAgICAgICBJbnRlcm5hbHMuZC5NKGhyZWYsIHtcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgbnVsbCA9PSBvcHRpb25zICYmIEludGVybmFscy5kLk0oaHJlZik7XG59O1xuZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFxuICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiZcbiAgICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXNcbiAgKSB7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcyxcbiAgICAgIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgSW50ZXJuYWxzLmQuTChocmVmLCBhcywge1xuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogdm9pZCAwLFxuICAgICAgZmV0Y2hQcmlvcml0eTpcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgOiB2b2lkIDAsXG4gICAgICByZWZlcnJlclBvbGljeTpcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICA/IG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgIGltYWdlU3JjU2V0OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNyY1NldCA/IG9wdGlvbnMuaW1hZ2VTcmNTZXQgOiB2b2lkIDAsXG4gICAgICBpbWFnZVNpemVzOlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzID8gb3B0aW9ucy5pbWFnZVNpemVzIDogdm9pZCAwLFxuICAgICAgbWVkaWE6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm1lZGlhID8gb3B0aW9ucy5tZWRpYSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0cy5wcmVsb2FkTW9kdWxlID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKG9wdGlvbnMuYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgSW50ZXJuYWxzLmQubShocmVmLCB7XG4gICAgICAgIGFzOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXNcbiAgICAgICAgICAgID8gb3B0aW9ucy5hc1xuICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2UgSW50ZXJuYWxzLmQubShocmVmKTtcbn07XG5leHBvcnRzLnJlcXVlc3RGb3JtUmVzZXQgPSBmdW5jdGlvbiAoZm9ybSkge1xuICBJbnRlcm5hbHMuZC5yKGZvcm0pO1xufTtcbmV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEpIHtcbiAgcmV0dXJuIGZuKGEpO1xufTtcbmV4cG9ydHMudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspO1xufTtcbmV4cG9ydHMudXNlRm9ybVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKTtcbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///221\n')},338:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(247);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQWdFO0FBQ2xFLEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2xpZW50LmpzPzExYjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1jbGllbnQuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///338\n")},961:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(221);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQXlEO0FBQzNELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/OGJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///961\n")},698:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = "" + maybeKey);\n  void 0 !== config.key && (key = "" + config.key);\n  if ("key" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      "key" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanM/Y2Q0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG5mdW5jdGlvbiBqc3hQcm9kKHR5cGUsIGNvbmZpZywgbWF5YmVLZXkpIHtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiYgKGtleSA9IFwiXCIgKyBtYXliZUtleSk7XG4gIHZvaWQgMCAhPT0gY29uZmlnLmtleSAmJiAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpO1xuICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICBtYXliZUtleSA9IHt9O1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICBjb25maWcgPSBtYXliZUtleS5yZWY7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogdm9pZCAwICE9PSBjb25maWcgPyBjb25maWcgOiBudWxsLFxuICAgIHByb3BzOiBtYXliZUtleVxuICB9O1xufVxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeFByb2Q7XG5leHBvcnRzLmpzeHMgPSBqc3hQcm9kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///698\n')},869:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(606);\n/**\n * @license React\n * react.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_PORTAL_TYPE = Symbol.for("react.portal"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),\n  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),\n  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),\n  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),\n  REACT_CONTEXT_TYPE = Symbol.for("react.context"),\n  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),\n  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),\n  REACT_MEMO_TYPE = Symbol.for("react.memo"),\n  REACT_LAZY_TYPE = Symbol.for("react.lazy"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable["@@iterator"];\n  return "function" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ReactNoopUpdateQueue = {\n    isMounted: function () {\n      return !1;\n    },\n    enqueueForceUpdate: function () {},\n    enqueueReplaceState: function () {},\n    enqueueSetState: function () {}\n  },\n  assign = Object.assign,\n  emptyObject = {};\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.isReactComponent = {};\nComponent.prototype.setState = function (partialState, callback) {\n  if (\n    "object" !== typeof partialState &&\n    "function" !== typeof partialState &&\n    null != partialState\n  )\n    throw Error(\n      "takes an object of state variables to update or a function which returns an object of state variables."\n    );\n  this.updater.enqueueSetState(this, partialState, callback, "setState");\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");\n};\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nvar pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = !0;\nvar isArrayImpl = Array.isArray,\n  ReactSharedInternals = { H: null, A: null, T: null, S: null },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction ReactElement(type, key, self, source, owner, props) {\n  self = props.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== self ? self : null,\n    props: props\n  };\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  return ReactElement(\n    oldElement.type,\n    newKey,\n    void 0,\n    void 0,\n    void 0,\n    oldElement.props\n  );\n}\nfunction isValidElement(object) {\n  return (\n    "object" === typeof object &&\n    null !== object &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\nfunction escape(key) {\n  var escaperLookup = { "=": "=0", ":": "=2" };\n  return (\n    "$" +\n    key.replace(/[=:]/g, function (match) {\n      return escaperLookup[match];\n    })\n  );\n}\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction getElementKey(element, index) {\n  return "object" === typeof element && null !== element && null != element.key\n    ? escape("" + element.key)\n    : index.toString(36);\n}\nfunction noop$1() {}\nfunction resolveThenable(thenable) {\n  switch (thenable.status) {\n    case "fulfilled":\n      return thenable.value;\n    case "rejected":\n      throw thenable.reason;\n    default:\n      switch (\n        ("string" === typeof thenable.status\n          ? thenable.then(noop$1, noop$1)\n          : ((thenable.status = "pending"),\n            thenable.then(\n              function (fulfilledValue) {\n                "pending" === thenable.status &&\n                  ((thenable.status = "fulfilled"),\n                  (thenable.value = fulfilledValue));\n              },\n              function (error) {\n                "pending" === thenable.status &&\n                  ((thenable.status = "rejected"), (thenable.reason = error));\n              }\n            )),\n        thenable.status)\n      ) {\n        case "fulfilled":\n          return thenable.value;\n        case "rejected":\n          throw thenable.reason;\n      }\n  }\n  throw thenable;\n}\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n  if ("undefined" === type || "boolean" === type) children = null;\n  var invokeCallback = !1;\n  if (null === children) invokeCallback = !0;\n  else\n    switch (type) {\n      case "bigint":\n      case "string":\n      case "number":\n        invokeCallback = !0;\n        break;\n      case "object":\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = !0;\n            break;\n          case REACT_LAZY_TYPE:\n            return (\n              (invokeCallback = children._init),\n              mapIntoArray(\n                invokeCallback(children._payload),\n                array,\n                escapedPrefix,\n                nameSoFar,\n                callback\n              )\n            );\n        }\n    }\n  if (invokeCallback)\n    return (\n      (callback = callback(children)),\n      (invokeCallback =\n        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),\n      isArrayImpl(callback)\n        ? ((escapedPrefix = ""),\n          null != invokeCallback &&\n            (escapedPrefix =\n              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),\n          mapIntoArray(callback, array, escapedPrefix, "", function (c) {\n            return c;\n          }))\n        : null != callback &&\n          (isValidElement(callback) &&\n            (callback = cloneAndReplaceKey(\n              callback,\n              escapedPrefix +\n                (null == callback.key ||\n                (children && children.key === callback.key)\n                  ? ""\n                  : ("" + callback.key).replace(\n                      userProvidedKeyEscapeRegex,\n                      "$&/"\n                    ) + "/") +\n                invokeCallback\n            )),\n          array.push(callback)),\n      1\n    );\n  invokeCallback = 0;\n  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";\n  if (isArrayImpl(children))\n    for (var i = 0; i < children.length; i++)\n      (nameSoFar = children[i]),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (((i = getIteratorFn(children)), "function" === typeof i))\n    for (\n      children = i.call(children), i = 0;\n      !(nameSoFar = children.next()).done;\n\n    )\n      (nameSoFar = nameSoFar.value),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if ("object" === type) {\n    if ("function" === typeof children.then)\n      return mapIntoArray(\n        resolveThenable(children),\n        array,\n        escapedPrefix,\n        nameSoFar,\n        callback\n      );\n    array = String(children);\n    throw Error(\n      "Objects are not valid as a React child (found: " +\n        ("[object Object]" === array\n          ? "object with keys {" + Object.keys(children).join(", ") + "}"\n          : array) +\n        "). If you meant to render a collection of children, use an array instead."\n    );\n  }\n  return invokeCallback;\n}\nfunction mapChildren(children, func, context) {\n  if (null == children) return children;\n  var result = [],\n    count = 0;\n  mapIntoArray(children, result, "", "", function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\nfunction lazyInitializer(payload) {\n  if (-1 === payload._status) {\n    var ctor = payload._result;\n    ctor = ctor();\n    ctor.then(\n      function (moduleObject) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 1), (payload._result = moduleObject);\n      },\n      function (error) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 2), (payload._result = error);\n      }\n    );\n    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));\n  }\n  if (1 === payload._status) return payload._result.default;\n  throw payload._result;\n}\nvar reportGlobalError =\n  "function" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          "object" === typeof window &&\n          "function" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent("error", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              "object" === typeof error &&\n              null !== error &&\n              "string" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          "object" === typeof process &&\n          "function" === typeof process.emit\n        ) {\n          process.emit("uncaughtException", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction noop() {}\nexports.Children = {\n  map: mapChildren,\n  forEach: function (children, forEachFunc, forEachContext) {\n    mapChildren(\n      children,\n      function () {\n        forEachFunc.apply(this, arguments);\n      },\n      forEachContext\n    );\n  },\n  count: function (children) {\n    var n = 0;\n    mapChildren(children, function () {\n      n++;\n    });\n    return n;\n  },\n  toArray: function (children) {\n    return (\n      mapChildren(children, function (child) {\n        return child;\n      }) || []\n    );\n  },\n  only: function (children) {\n    if (!isValidElement(children))\n      throw Error(\n        "React.Children.only expected to receive a single React element child."\n      );\n    return children;\n  }\n};\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  ReactSharedInternals;\nexports.act = function () {\n  throw Error("act(...) is not supported in production builds of React.");\n};\nexports.cache = function (fn) {\n  return function () {\n    return fn.apply(null, arguments);\n  };\n};\nexports.cloneElement = function (element, config, children) {\n  if (null === element || void 0 === element)\n    throw Error(\n      "The argument must be a React element, but you passed " + element + "."\n    );\n  var props = assign({}, element.props),\n    key = element.key,\n    owner = void 0;\n  if (null != config)\n    for (propName in (void 0 !== config.ref && (owner = void 0),\n    void 0 !== config.key && (key = "" + config.key),\n    config))\n      !hasOwnProperty.call(config, propName) ||\n        "key" === propName ||\n        "__self" === propName ||\n        "__source" === propName ||\n        ("ref" === propName && void 0 === config.ref) ||\n        (props[propName] = config[propName]);\n  var propName = arguments.length - 2;\n  if (1 === propName) props.children = children;\n  else if (1 < propName) {\n    for (var childArray = Array(propName), i = 0; i < propName; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  return ReactElement(element.type, key, void 0, void 0, owner, props);\n};\nexports.createContext = function (defaultValue) {\n  defaultValue = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null\n  };\n  defaultValue.Provider = defaultValue;\n  defaultValue.Consumer = {\n    $$typeof: REACT_CONSUMER_TYPE,\n    _context: defaultValue\n  };\n  return defaultValue;\n};\nexports.createElement = function (type, config, children) {\n  var propName,\n    props = {},\n    key = null;\n  if (null != config)\n    for (propName in (void 0 !== config.key && (key = "" + config.key), config))\n      hasOwnProperty.call(config, propName) &&\n        "key" !== propName &&\n        "__self" !== propName &&\n        "__source" !== propName &&\n        (props[propName] = config[propName]);\n  var childrenLength = arguments.length - 2;\n  if (1 === childrenLength) props.children = children;\n  else if (1 < childrenLength) {\n    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  if (type && type.defaultProps)\n    for (propName in ((childrenLength = type.defaultProps), childrenLength))\n      void 0 === props[propName] &&\n        (props[propName] = childrenLength[propName]);\n  return ReactElement(type, key, void 0, void 0, null, props);\n};\nexports.createRef = function () {\n  return { current: null };\n};\nexports.forwardRef = function (render) {\n  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };\n};\nexports.isValidElement = isValidElement;\nexports.lazy = function (ctor) {\n  return {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: { _status: -1, _result: ctor },\n    _init: lazyInitializer\n  };\n};\nexports.memo = function (type, compare) {\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: void 0 === compare ? null : compare\n  };\n};\nexports.startTransition = function (scope) {\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  try {\n    var returnValue = scope(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    "object" === typeof returnValue &&\n      null !== returnValue &&\n      "function" === typeof returnValue.then &&\n      returnValue.then(noop, reportGlobalError);\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n};\nexports.unstable_useCacheRefresh = function () {\n  return ReactSharedInternals.H.useCacheRefresh();\n};\nexports.use = function (usable) {\n  return ReactSharedInternals.H.use(usable);\n};\nexports.useActionState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useActionState(action, initialState, permalink);\n};\nexports.useCallback = function (callback, deps) {\n  return ReactSharedInternals.H.useCallback(callback, deps);\n};\nexports.useContext = function (Context) {\n  return ReactSharedInternals.H.useContext(Context);\n};\nexports.useDebugValue = function () {};\nexports.useDeferredValue = function (value, initialValue) {\n  return ReactSharedInternals.H.useDeferredValue(value, initialValue);\n};\nexports.useEffect = function (create, deps) {\n  return ReactSharedInternals.H.useEffect(create, deps);\n};\nexports.useId = function () {\n  return ReactSharedInternals.H.useId();\n};\nexports.useImperativeHandle = function (ref, create, deps) {\n  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);\n};\nexports.useInsertionEffect = function (create, deps) {\n  return ReactSharedInternals.H.useInsertionEffect(create, deps);\n};\nexports.useLayoutEffect = function (create, deps) {\n  return ReactSharedInternals.H.useLayoutEffect(create, deps);\n};\nexports.useMemo = function (create, deps) {\n  return ReactSharedInternals.H.useMemo(create, deps);\n};\nexports.useOptimistic = function (passthrough, reducer) {\n  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);\n};\nexports.useReducer = function (reducer, initialArg, init) {\n  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);\n};\nexports.useRef = function (initialValue) {\n  return ReactSharedInternals.H.useRef(initialValue);\n};\nexports.useState = function (initialState) {\n  return ReactSharedInternals.H.useState(initialState);\n};\nexports.useSyncExternalStore = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot\n) {\n  return ReactSharedInternals.H.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot\n  );\n};\nexports.useTransition = function () {\n  return ReactSharedInternals.H.useTransition();\n};\nexports.version = "19.0.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24uanM/NmY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKSByZXR1cm4gbnVsbDtcbiAgbWF5YmVJdGVyYWJsZSA9XG4gICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG59XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSxcbiAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKCkge31cbiAgfSxcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgZW1wdHlPYmplY3QgPSB7fTtcbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKFxuICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICBudWxsICE9IHBhcnRpYWxTdGF0ZVxuICApXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcInRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiXG4gICAgKTtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xufTtcbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgXCJmb3JjZVVwZGF0ZVwiKTtcbn07XG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSAoUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbmFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0geyBIOiBudWxsLCBBOiBudWxsLCBUOiBudWxsLCBTOiBudWxsIH0sXG4gIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHNlbGYgPSBwcm9wcy5yZWY7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogdm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwsXG4gICAgcHJvcHM6IHByb3BzXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgb2xkRWxlbWVudC50eXBlLFxuICAgIG5ld0tleSxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIHZvaWQgMCxcbiAgICBvbGRFbGVtZW50LnByb3BzXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgbnVsbCAhPT0gb2JqZWN0ICYmXG4gICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgcmV0dXJuIChcbiAgICBcIiRcIiArXG4gICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gICAgfSlcbiAgKTtcbn1cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIHJldHVybiBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJiBudWxsICE9PSBlbGVtZW50ICYmIG51bGwgIT0gZWxlbWVudC5rZXlcbiAgICA/IGVzY2FwZShcIlwiICsgZWxlbWVudC5rZXkpXG4gICAgOiBpbmRleC50b1N0cmluZygzNik7XG59XG5mdW5jdGlvbiBub29wJDEoKSB7fVxuZnVuY3Rpb24gcmVzb2x2ZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKFxuICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSlcbiAgICAgICAgICA6ICgodGhlbmFibGUuc3RhdHVzID0gXCJwZW5kaW5nXCIpLFxuICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICgodGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSwgKHRoZW5hYmxlLnJlYXNvbiA9IGVycm9yKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpLFxuICAgICAgICB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICApIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgfVxuICB9XG4gIHRocm93IHRoZW5hYmxlO1xufVxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGUgfHwgXCJib29sZWFuXCIgPT09IHR5cGUpIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGludm9rZUNhbGxiYWNrID0gITE7XG4gIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgZWxzZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgPSBjaGlsZHJlbi5faW5pdCksXG4gICAgICAgICAgICAgIG1hcEludG9BcnJheShcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCxcbiAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgaWYgKGludm9rZUNhbGxiYWNrKVxuICAgIHJldHVybiAoXG4gICAgICAoY2FsbGJhY2sgPSBjYWxsYmFjayhjaGlsZHJlbikpLFxuICAgICAgKGludm9rZUNhbGxiYWNrID1cbiAgICAgICAgXCJcIiA9PT0gbmFtZVNvRmFyID8gXCIuXCIgKyBnZXRFbGVtZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0ZhciksXG4gICAgICBpc0FycmF5SW1wbChjYWxsYmFjaylcbiAgICAgICAgPyAoKGVzY2FwZWRQcmVmaXggPSBcIlwiKSxcbiAgICAgICAgICBudWxsICE9IGludm9rZUNhbGxiYWNrICYmXG4gICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9XG4gICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsIFwiJCYvXCIpICsgXCIvXCIpLFxuICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICB9KSlcbiAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgKGlzVmFsaWRFbGVtZW50KGNhbGxiYWNrKSAmJlxuICAgICAgICAgICAgKGNhbGxiYWNrID0gY2xvbmVBbmRSZXBsYWNlS2V5KFxuICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCArXG4gICAgICAgICAgICAgICAgKG51bGwgPT0gY2FsbGJhY2sua2V5IHx8XG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICA6IChcIlwiICsgY2FsbGJhY2sua2V5KS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgIFwiJCYvXCJcbiAgICAgICAgICAgICAgICAgICAgKSArIFwiL1wiKSArXG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2tcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIGFycmF5LnB1c2goY2FsbGJhY2spKSxcbiAgICAgIDFcbiAgICApO1xuICBpbnZva2VDYWxsYmFjayA9IDA7XG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiIDogbmFtZVNvRmFyICsgXCI6XCI7XG4gIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgIChuYW1lU29GYXIgPSBjaGlsZHJlbltpXSksXG4gICAgICAgICh0eXBlID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KG5hbWVTb0ZhciwgaSkpLFxuICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICBhcnJheSxcbiAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKSk7XG4gIGVsc2UgaWYgKCgoaSA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpXG4gICAgZm9yIChcbiAgICAgIGNoaWxkcmVuID0gaS5jYWxsKGNoaWxkcmVuKSwgaSA9IDA7XG4gICAgICAhKG5hbWVTb0ZhciA9IGNoaWxkcmVuLm5leHQoKSkuZG9uZTtcblxuICAgIClcbiAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAodHlwZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShuYW1lU29GYXIsIGkrKykpLFxuICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICBhcnJheSxcbiAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKSk7XG4gIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGRyZW4udGhlbilcbiAgICAgIHJldHVybiBtYXBJbnRvQXJyYXkoXG4gICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgIGFycmF5LFxuICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgIDogYXJyYXkpICtcbiAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBpbnZva2VDYWxsYmFjaztcbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIGN0b3IgPSBjdG9yKCk7XG4gICAgY3Rvci50aGVuKFxuICAgICAgZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDEpLCAocGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgIChwYXlsb2FkLl9zdGF0dXMgPSAyKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGVycm9yKTtcbiAgICAgIH1cbiAgICApO1xuICAgIC0xID09PSBwYXlsb2FkLl9zdGF0dXMgJiYgKChwYXlsb2FkLl9zdGF0dXMgPSAwKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGN0b3IpKTtcbiAgfVxuICBpZiAoMSA9PT0gcGF5bG9hZC5fc3RhdHVzKSByZXR1cm4gcGF5bG9hZC5fcmVzdWx0LmRlZmF1bHQ7XG4gIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbn1cbnZhciByZXBvcnRHbG9iYWxFcnJvciA9XG4gIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlcG9ydEVycm9yXG4gICAgPyByZXBvcnRFcnJvclxuICAgIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygd2luZG93ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCkpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvY2VzcyAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByb2Nlc3MuZW1pdFxuICAgICAgICApIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfTtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZXhwb3J0cy5DaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZnVuY3Rpb24gKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgICBtYXBDaGlsZHJlbihcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2hDb250ZXh0XG4gICAgKTtcbiAgfSxcbiAgY291bnQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHZhciBuID0gMDtcbiAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgbisrO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gKFxuICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9KSB8fCBbXVxuICAgICk7XG4gIH0sXG4gIG9ubHk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG59O1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG5leHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbmV4cG9ydHMuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgRXJyb3IoXCJhY3QoLi4uKSBpcyBub3Qgc3VwcG9ydGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIFJlYWN0LlwiKTtcbn07XG5leHBvcnRzLmNhY2hlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAobnVsbCA9PT0gZWxlbWVudCB8fCB2b2lkIDAgPT09IGVsZW1lbnQpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIlRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCJcbiAgICApO1xuICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpLFxuICAgIGtleSA9IGVsZW1lbnQua2V5LFxuICAgIG93bmVyID0gdm9pZCAwO1xuICBpZiAobnVsbCAhPSBjb25maWcpXG4gICAgZm9yIChwcm9wTmFtZSBpbiAodm9pZCAwICE9PSBjb25maWcucmVmICYmIChvd25lciA9IHZvaWQgMCksXG4gICAgdm9pZCAwICE9PSBjb25maWcua2V5ICYmIChrZXkgPSBcIlwiICsgY29uZmlnLmtleSksXG4gICAgY29uZmlnKSlcbiAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpIHx8XG4gICAgICAgIFwia2V5XCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgIFwiX19zZWxmXCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgIFwiX19zb3VyY2VcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgKFwicmVmXCIgPT09IHByb3BOYW1lICYmIHZvaWQgMCA9PT0gY29uZmlnLnJlZikgfHxcbiAgICAgICAgKHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICB2YXIgcHJvcE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKDEgPT09IHByb3BOYW1lKSBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICBlbHNlIGlmICgxIDwgcHJvcE5hbWUpIHtcbiAgICBmb3IgKHZhciBjaGlsZEFycmF5ID0gQXJyYXkocHJvcE5hbWUpLCBpID0gMDsgaSA8IHByb3BOYW1lOyBpKyspXG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgdm9pZCAwLCB2b2lkIDAsIG93bmVyLCBwcm9wcyk7XG59O1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICBkZWZhdWx0VmFsdWUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgZGVmYXVsdFZhbHVlLlByb3ZpZGVyID0gZGVmYXVsdFZhbHVlO1xuICBkZWZhdWx0VmFsdWUuQ29uc3VtZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlNVTUVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufTtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGtleSA9IG51bGw7XG4gIGlmIChudWxsICE9IGNvbmZpZylcbiAgICBmb3IgKHByb3BOYW1lIGluICh2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KSwgY29uZmlnKSlcbiAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiZcbiAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgXCJfX3NlbGZcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgXCJfX3NvdXJjZVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAocHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoMSA9PT0gY2hpbGRyZW5MZW5ndGgpIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIGVsc2UgaWYgKDEgPCBjaGlsZHJlbkxlbmd0aCkge1xuICAgIGZvciAodmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCksIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKylcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcylcbiAgICBmb3IgKHByb3BOYW1lIGluICgoY2hpbGRyZW5MZW5ndGggPSB0eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkcmVuTGVuZ3RoKSlcbiAgICAgIHZvaWQgMCA9PT0gcHJvcHNbcHJvcE5hbWVdICYmXG4gICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjaGlsZHJlbkxlbmd0aFtwcm9wTmFtZV0pO1xuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgdm9pZCAwLCB2b2lkIDAsIG51bGwsIHByb3BzKTtcbn07XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufTtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgcmV0dXJuIHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogcmVuZGVyIH07XG59O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBjdG9yIH0sXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xufTtcbmV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IHZvaWQgMCA9PT0gY29tcGFyZSA/IG51bGwgOiBjb21wYXJlXG4gIH07XG59O1xuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gIHRyeSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gc2NvcGUoKSxcbiAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgICByZXR1cm5WYWx1ZS50aGVuKG5vb3AsIHJlcG9ydEdsb2JhbEVycm9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICB9XG59O1xuZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUNhY2hlUmVmcmVzaCgpO1xufTtcbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKHVzYWJsZSkge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2UodXNhYmxlKTtcbn07XG5leHBvcnRzLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluayk7XG59O1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VDb250ZXh0ID0gZnVuY3Rpb24gKENvbnRleHQpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlQ29udGV4dChDb250ZXh0KTtcbn07XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG59O1xuZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufTtcbmV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUlkKCk7XG59O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufTtcbmV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn07XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufTtcbmV4cG9ydHMudXNlUmVkdWNlciA9IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59O1xuZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVJlZihpbml0aWFsVmFsdWUpO1xufTtcbmV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59O1xuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uIChcbiAgc3Vic2NyaWJlLFxuICBnZXRTbmFwc2hvdCxcbiAgZ2V0U2VydmVyU25hcHNob3Rcbikge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3RcbiAgKTtcbn07XG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVRyYW5zaXRpb24oKTtcbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///869\n')},540:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(869);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBcUQ7QUFDdkQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzP2FiNWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///540\n")},848:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(698);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBaUU7QUFDbkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzljYTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///848\n")},477:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * scheduler.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  a: for (; 0 < index; ) {\n    var parentIndex = (index - 1) >>> 1,\n      parent = heap[parentIndex];\n    if (0 < compare(parent, node))\n      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);\n    else break a;\n  }\n}\nfunction peek(heap) {\n  return 0 === heap.length ? null : heap[0];\n}\nfunction pop(heap) {\n  if (0 === heap.length) return null;\n  var first = heap[0],\n    last = heap.pop();\n  if (last !== first) {\n    heap[0] = last;\n    a: for (\n      var index = 0, length = heap.length, halfLength = length >>> 1;\n      index < halfLength;\n\n    ) {\n      var leftIndex = 2 * (index + 1) - 1,\n        left = heap[leftIndex],\n        rightIndex = leftIndex + 1,\n        right = heap[rightIndex];\n      if (0 > compare(left, last))\n        rightIndex < length && 0 > compare(right, left)\n          ? ((heap[index] = right),\n            (heap[rightIndex] = last),\n            (index = rightIndex))\n          : ((heap[index] = left),\n            (heap[leftIndex] = last),\n            (index = leftIndex));\n      else if (rightIndex < length && 0 > compare(right, last))\n        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);\n      else break a;\n    }\n  }\n  return first;\n}\nfunction compare(a, b) {\n  var diff = a.sortIndex - b.sortIndex;\n  return 0 !== diff ? diff : a.id - b.id;\n}\nexports.unstable_now = void 0;\nif ("object" === typeof performance && "function" === typeof performance.now) {\n  var localPerformance = performance;\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date,\n    initialTime = localDate.now();\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n}\nvar taskQueue = [],\n  timerQueue = [],\n  taskIdCounter = 1,\n  currentTask = null,\n  currentPriorityLevel = 3,\n  isPerformingWork = !1,\n  isHostCallbackScheduled = !1,\n  isHostTimeoutScheduled = !1,\n  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,\n  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,\n  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;\nfunction advanceTimers(currentTime) {\n  for (var timer = peek(timerQueue); null !== timer; ) {\n    if (null === timer.callback) pop(timerQueue);\n    else if (timer.startTime <= currentTime)\n      pop(timerQueue),\n        (timer.sortIndex = timer.expirationTime),\n        push(taskQueue, timer);\n    else break;\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = !1;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled)\n    if (null !== peek(taskQueue))\n      (isHostCallbackScheduled = !0), requestHostCallback();\n    else {\n      var firstTimer = peek(timerQueue);\n      null !== firstTimer &&\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n}\nvar isMessageLoopRunning = !1,\n  taskTimeoutID = -1,\n  frameInterval = 5,\n  startTime = -1;\nfunction shouldYieldToHost() {\n  return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n}\nfunction performWorkUntilDeadline() {\n  if (isMessageLoopRunning) {\n    var currentTime = exports.unstable_now();\n    startTime = currentTime;\n    var hasMoreWork = !0;\n    try {\n      a: {\n        isHostCallbackScheduled = !1;\n        isHostTimeoutScheduled &&\n          ((isHostTimeoutScheduled = !1),\n          localClearTimeout(taskTimeoutID),\n          (taskTimeoutID = -1));\n        isPerformingWork = !0;\n        var previousPriorityLevel = currentPriorityLevel;\n        try {\n          b: {\n            advanceTimers(currentTime);\n            for (\n              currentTask = peek(taskQueue);\n              null !== currentTask &&\n              !(\n                currentTask.expirationTime > currentTime && shouldYieldToHost()\n              );\n\n            ) {\n              var callback = currentTask.callback;\n              if ("function" === typeof callback) {\n                currentTask.callback = null;\n                currentPriorityLevel = currentTask.priorityLevel;\n                var continuationCallback = callback(\n                  currentTask.expirationTime <= currentTime\n                );\n                currentTime = exports.unstable_now();\n                if ("function" === typeof continuationCallback) {\n                  currentTask.callback = continuationCallback;\n                  advanceTimers(currentTime);\n                  hasMoreWork = !0;\n                  break b;\n                }\n                currentTask === peek(taskQueue) && pop(taskQueue);\n                advanceTimers(currentTime);\n              } else pop(taskQueue);\n              currentTask = peek(taskQueue);\n            }\n            if (null !== currentTask) hasMoreWork = !0;\n            else {\n              var firstTimer = peek(timerQueue);\n              null !== firstTimer &&\n                requestHostTimeout(\n                  handleTimeout,\n                  firstTimer.startTime - currentTime\n                );\n              hasMoreWork = !1;\n            }\n          }\n          break a;\n        } finally {\n          (currentTask = null),\n            (currentPriorityLevel = previousPriorityLevel),\n            (isPerformingWork = !1);\n        }\n        hasMoreWork = void 0;\n      }\n    } finally {\n      hasMoreWork\n        ? schedulePerformWorkUntilDeadline()\n        : (isMessageLoopRunning = !1);\n    }\n  }\n}\nvar schedulePerformWorkUntilDeadline;\nif ("function" === typeof localSetImmediate)\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\nelse if ("undefined" !== typeof MessageChannel) {\n  var channel = new MessageChannel(),\n    port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\nfunction requestHostCallback() {\n  isMessageLoopRunning ||\n    ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n}\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\nexports.unstable_IdlePriority = 5;\nexports.unstable_ImmediatePriority = 1;\nexports.unstable_LowPriority = 4;\nexports.unstable_NormalPriority = 3;\nexports.unstable_Profiling = null;\nexports.unstable_UserBlockingPriority = 2;\nexports.unstable_cancelCallback = function (task) {\n  task.callback = null;\n};\nexports.unstable_continueExecution = function () {\n  isHostCallbackScheduled ||\n    isPerformingWork ||\n    ((isHostCallbackScheduled = !0), requestHostCallback());\n};\nexports.unstable_forceFrameRate = function (fps) {\n  0 > fps || 125 < fps\n    ? console.error(\n        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"\n      )\n    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n};\nexports.unstable_getCurrentPriorityLevel = function () {\n  return currentPriorityLevel;\n};\nexports.unstable_getFirstCallbackNode = function () {\n  return peek(taskQueue);\n};\nexports.unstable_next = function (eventHandler) {\n  switch (currentPriorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n      var priorityLevel = 3;\n      break;\n    default:\n      priorityLevel = currentPriorityLevel;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_pauseExecution = function () {};\nexports.unstable_requestPaint = function () {};\nexports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      break;\n    default:\n      priorityLevel = 3;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_scheduleCallback = function (\n  priorityLevel,\n  callback,\n  options\n) {\n  var currentTime = exports.unstable_now();\n  "object" === typeof options && null !== options\n    ? ((options = options.delay),\n      (options =\n        "number" === typeof options && 0 < options\n          ? currentTime + options\n          : currentTime))\n    : (options = currentTime);\n  switch (priorityLevel) {\n    case 1:\n      var timeout = -1;\n      break;\n    case 2:\n      timeout = 250;\n      break;\n    case 5:\n      timeout = 1073741823;\n      break;\n    case 4:\n      timeout = 1e4;\n      break;\n    default:\n      timeout = 5e3;\n  }\n  timeout = options + timeout;\n  priorityLevel = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: options,\n    expirationTime: timeout,\n    sortIndex: -1\n  };\n  options > currentTime\n    ? ((priorityLevel.sortIndex = options),\n      push(timerQueue, priorityLevel),\n      null === peek(taskQueue) &&\n        priorityLevel === peek(timerQueue) &&\n        (isHostTimeoutScheduled\n          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n          : (isHostTimeoutScheduled = !0),\n        requestHostTimeout(handleTimeout, options - currentTime)))\n    : ((priorityLevel.sortIndex = timeout),\n      push(taskQueue, priorityLevel),\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback()));\n  return priorityLevel;\n};\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = function (callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDc3LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLDBCQUEwQjtBQUMxQixxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24uanM/MDU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gKGluZGV4IC0gMSkgPj4+IDEsXG4gICAgICBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcbiAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgIChoZWFwW3BhcmVudEluZGV4XSA9IG5vZGUpLCAoaGVhcFtpbmRleF0gPSBwYXJlbnQpLCAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgZWxzZSBicmVhayBhO1xuICB9XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIDAgPT09IGhlYXAubGVuZ3RoID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoMCA9PT0gaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgIGxhc3QgPSBoZWFwLnBvcCgpO1xuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBhOiBmb3IgKFxuICAgICAgdmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gaGVhcC5sZW5ndGgsIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICApIHtcbiAgICAgIHZhciBsZWZ0SW5kZXggPSAyICogKGluZGV4ICsgMSkgLSAxLFxuICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMSxcbiAgICAgICAgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdO1xuICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICByaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsZWZ0KVxuICAgICAgICAgID8gKChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAoaW5kZXggPSByaWdodEluZGV4KSlcbiAgICAgICAgICA6ICgoaGVhcFtpbmRleF0gPSBsZWZ0KSxcbiAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgIChpbmRleCA9IGxlZnRJbmRleCkpO1xuICAgICAgZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGFzdCkpXG4gICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSwgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSwgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICBlbHNlIGJyZWFrIGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiAwICE9PSBkaWZmID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuZXhwb3J0cy51bnN0YWJsZV9ub3cgPSB2b2lkIDA7XG5pZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBsb2NhbERhdGUgPSBEYXRlLFxuICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59XG52YXIgdGFza1F1ZXVlID0gW10sXG4gIHRpbWVyUXVldWUgPSBbXSxcbiAgdGFza0lkQ291bnRlciA9IDEsXG4gIGN1cnJlbnRUYXNrID0gbnVsbCxcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICBpc1BlcmZvcm1pbmdXb3JrID0gITEsXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITEsXG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgbG9jYWxTZXRUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiBudWxsLFxuICBsb2NhbENsZWFyVGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNsZWFyVGltZW91dCA/IGNsZWFyVGltZW91dCA6IG51bGwsXG4gIGxvY2FsU2V0SW1tZWRpYXRlID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGw7XG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgIGlmIChudWxsID09PSB0aW1lci5jYWxsYmFjaykgcG9wKHRpbWVyUXVldWUpO1xuICAgIGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSlcbiAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgKHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lKSxcbiAgICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICBlbHNlIGJyZWFrO1xuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITE7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKVxuICAgIGlmIChudWxsICE9PSBwZWVrKHRhc2tRdWV1ZSkpXG4gICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbn1cbnZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICB0YXNrVGltZW91dElEID0gLTEsXG4gIGZyYW1lSW50ZXJ2YWwgPSA1LFxuICBzdGFydFRpbWUgPSAtMTtcbmZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuICByZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZSA8IGZyYW1lSW50ZXJ2YWwgPyAhMSA6ICEwO1xufVxuZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICBpZiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHZhciBoYXNNb3JlV29yayA9ICEwO1xuICAgIHRyeSB7XG4gICAgICBhOiB7XG4gICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITE7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgJiZcbiAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksXG4gICAgICAgICAgKHRhc2tUaW1lb3V0SUQgPSAtMSkpO1xuICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiOiB7XG4gICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50VGFzayAmJlxuICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkgJiYgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRhc2spIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICBudWxsICE9PSBmaXJzdFRpbWVyICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChjdXJyZW50VGFzayA9IG51bGwpLFxuICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgIChpc1BlcmZvcm1pbmdXb3JrID0gITEpO1xuICAgICAgICB9XG4gICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBoYXNNb3JlV29ya1xuICAgICAgICA/IHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKClcbiAgICAgICAgOiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMSk7XG4gICAgfVxuICB9XG59XG52YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5pZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gIH07XG5lbHNlIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgTWVzc2FnZUNoYW5uZWwpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2VcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG5mdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKCkge1xuICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICgoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMCksIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkpO1xufVxuZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgfSwgbXMpO1xufVxuZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IDE7XG5leHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gNDtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgdGFzay5jYWxsYmFjayA9IG51bGw7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgfHxcbiAgICBpc1BlcmZvcm1pbmdXb3JrIHx8XG4gICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKTtcbn07XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKGZwcykge1xuICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIlxuICAgICAgKVxuICAgIDogKGZyYW1lSW50ZXJ2YWwgPSAwIDwgZnBzID8gTWF0aC5mbG9vcigxZTMgLyBmcHMpIDogNSk7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufTtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgICB2YXIgcHJpb3JpdHlMZXZlbCA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICB9XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufTtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNTpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gMztcbiAgfVxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gIHByaW9yaXR5TGV2ZWwsXG4gIGNhbGxiYWNrLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5kZWxheSksXG4gICAgICAob3B0aW9ucyA9XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgPyBjdXJyZW50VGltZSArIG9wdGlvbnNcbiAgICAgICAgICA6IGN1cnJlbnRUaW1lKSlcbiAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gNWUzO1xuICB9XG4gIHRpbWVvdXQgPSBvcHRpb25zICsgdGltZW91dDtcbiAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHN0YXJ0VGltZTogb3B0aW9ucyxcbiAgICBleHBpcmF0aW9uVGltZTogdGltZW91dCxcbiAgICBzb3J0SW5kZXg6IC0xXG4gIH07XG4gIG9wdGlvbnMgPiBjdXJyZW50VGltZVxuICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgcHVzaCh0aW1lclF1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgIG51bGwgPT09IHBlZWsodGFza1F1ZXVlKSAmJlxuICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkXG4gICAgICAgICAgPyAobG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksICh0YXNrVGltZW91dElEID0gLTEpKVxuICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBvcHRpb25zIC0gY3VycmVudFRpbWUpKSlcbiAgICA6ICgocHJpb3JpdHlMZXZlbC5zb3J0SW5kZXggPSB0aW1lb3V0KSxcbiAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKSk7XG4gIHJldHVybiBwcmlvcml0eUxldmVsO1xufTtcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbmV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///477\n')},982:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(477);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz80MDI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///982\n")},72:module=>{"use strict";eval('\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzJkYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n')},659:module=>{"use strict";eval('\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzP2IyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///659\n')},159:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzP2RlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///159\n')},56:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzP2RkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n')},825:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n  var needLayer = typeof obj.layer !== "undefined";\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += "}";\n  }\n  if (obj.media) {\n    css += "}";\n  }\n  if (obj.supports) {\n    css += "}";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === "undefined") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///825\n')},113:module=>{"use strict";eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///113\n")}},__webpack_module_cache__={};function __webpack_require__(I){var n=__webpack_module_cache__[I];if(void 0!==n)return n.exports;var g=__webpack_module_cache__[I]={id:I,exports:{}};return __webpack_modules__[I](g,g.exports,__webpack_require__),g.exports}__webpack_require__.n=I=>{var n=I&&I.__esModule?()=>I.default:()=>I;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(I,n)=>{for(var g in n)__webpack_require__.o(n,g)&&!__webpack_require__.o(I,g)&&Object.defineProperty(I,g,{enumerable:!0,get:n[g]})},__webpack_require__.o=(I,n)=>Object.prototype.hasOwnProperty.call(I,n),__webpack_require__.nc=void 0;var __webpack_exports__=__webpack_require__(108)})();