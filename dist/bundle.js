(()=>{var __webpack_modules__={270:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(540);\n// EXTERNAL MODULE: ./node_modules/react-dom/client.js\nvar client = __webpack_require__(338);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(961);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\nvar injectStylesIntoStyleTag = __webpack_require__(72);\nvar injectStylesIntoStyleTag_default = /*#__PURE__*/__webpack_require__.n(injectStylesIntoStyleTag);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleDomAPI.js\nvar styleDomAPI = __webpack_require__(825);\nvar styleDomAPI_default = /*#__PURE__*/__webpack_require__.n(styleDomAPI);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertBySelector.js\nvar insertBySelector = __webpack_require__(659);\nvar insertBySelector_default = /*#__PURE__*/__webpack_require__.n(insertBySelector);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js\nvar setAttributesWithoutAttributes = __webpack_require__(56);\nvar setAttributesWithoutAttributes_default = /*#__PURE__*/__webpack_require__.n(setAttributesWithoutAttributes);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/insertStyleElement.js\nvar insertStyleElement = __webpack_require__(159);\nvar insertStyleElement_default = /*#__PURE__*/__webpack_require__.n(insertStyleElement);\n// EXTERNAL MODULE: ./node_modules/style-loader/dist/runtime/styleTagTransform.js\nvar styleTagTransform = __webpack_require__(113);\nvar styleTagTransform_default = /*#__PURE__*/__webpack_require__.n(styleTagTransform);\n// EXTERNAL MODULE: ./node_modules/css-loader/dist/cjs.js!./node_modules/postcss-loader/dist/cjs.js!./src/styles.css\nvar styles = __webpack_require__(408);\n;// ./src/styles.css\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n\nvar options = {};\n\noptions.styleTagTransform = (styleTagTransform_default());\noptions.setAttributes = (setAttributesWithoutAttributes_default());\noptions.insert = insertBySelector_default().bind(null, "head");\noptions.domAPI = (styleDomAPI_default());\noptions.insertStyleElement = (insertStyleElement_default());\n\nvar update = injectStylesIntoStyleTag_default()(styles/* default */.A, options);\n\n\n\n\n       /* harmony default export */ const src_styles = (styles/* default */.A && styles/* default */.A.locals ? styles/* default */.A.locals : undefined);\n\n;// ./node_modules/framer-motion/dist/es/render/components/create-proxy.mjs\n\n\nfunction createDOMMotionComponentProxy(componentFactory) {\n    if (typeof Proxy === "undefined") {\n        return componentFactory;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    const componentCache = new Map();\n    const deprecatedFactoryFunction = (...args) => {\n        if (false) {}\n        return componentFactory(...args);\n    };\n    return new Proxy(deprecatedFactoryFunction, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: (_target, key) => {\n            if (key === "create")\n                return componentFactory;\n            /**\n             * If this element doesn\'t exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, componentFactory(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n    return (v !== null &&\n        typeof v === "object" &&\n        typeof v.start === "function");\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nconst isKeyframesTarget = (v) => {\n    return Array.isArray(v);\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    const prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (let i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === "string" || Array.isArray(v);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs\nfunction getValueState(visualElement) {\n    const state = [{}, {}];\n    visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {\n        state[0][key] = value.get();\n        state[1][key] = value.getVelocity();\n    });\n    return state;\n}\nfunction resolveVariantFromProps(props, definition, custom, visualElement) {\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === "function") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === "string") {\n        definition = props.variants && props.variants[definition];\n    }\n    /**\n     * At this point we\'ve resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === "function") {\n        const [current, velocity] = getValueState(visualElement);\n        definition = definition(custom !== undefined ? custom : props.custom, current, velocity);\n    }\n    return definition;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs\n\n\nfunction resolveVariant(visualElement, definition, custom) {\n    const props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/variant-props.mjs\nconst variantPriorityOrder = [\n    "animate",\n    "whileInView",\n    "whileFocus",\n    "whileHover",\n    "whileTap",\n    "whileDrag",\n    "exit",\n];\nconst variantProps = ["initial", ...variantPriorityOrder];\n\n\n\n;// ./node_modules/motion-utils/dist/es/memo.mjs\n/*#__NO_SIDE_EFFECTS__*/\nfunction memo(callback) {\n    let result;\n    return () => {\n        if (result === undefined)\n            result = callback();\n        return result;\n    };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs\n\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/controls/BaseGroup.mjs\n\n\nclass BaseGroup_BaseGroupPlaybackControls {\n    constructor(animations) {\n        // Bound to accomodate common `return animation.stop` pattern\n        this.stop = () => this.runAll("stop");\n        this.animations = animations.filter(Boolean);\n    }\n    get finished() {\n        // Support for new finished Promise and legacy thennable API\n        return Promise.all(this.animations.map((animation) => "finished" in animation ? animation.finished : animation));\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline, fallback) {\n        const subscriptions = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                return animation.attachTimeline(timeline);\n            }\n            else if (typeof fallback === "function") {\n                return fallback(animation);\n            }\n        });\n        return () => {\n            subscriptions.forEach((cancel, i) => {\n                cancel && cancel();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll("time");\n    }\n    set time(time) {\n        this.setAll("time", time);\n    }\n    get speed() {\n        return this.getAll("speed");\n    }\n    set speed(speed) {\n        this.setAll("speed", speed);\n    }\n    get startTime() {\n        return this.getAll("startTime");\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    flatten() {\n        this.runAll("flatten");\n    }\n    play() {\n        this.runAll("play");\n    }\n    pause() {\n        this.runAll("pause");\n    }\n    cancel() {\n        this.runAll("cancel");\n    }\n    complete() {\n        this.runAll("complete");\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/controls/Group.mjs\n\n\n/**\n * TODO: This is a temporary class to support the legacy\n * thennable API\n */\nclass GroupPlaybackControls extends BaseGroup_BaseGroupPlaybackControls {\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs\nfunction get_value_transition_getValueTransition(transition, key) {\n    return transition\n        ? transition[key] ||\n            transition["default"] ||\n            transition\n        : undefined;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs\nfunction isGenerator(type) {\n    return typeof type === "function";\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/attach-timeline.mjs\nfunction attachTimeline(animation, timeline) {\n    animation.timeline = timeline;\n    animation.onfinish = null;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/is-bezier-definition.mjs\nconst isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/flags.mjs\n/**\n * Add the ability for test suites to manually set support flags\n * to better test more environments.\n */\nconst supportsFlags = {\n    linearEasing: undefined,\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/memo.mjs\n\n\n\nfunction memoSupports(callback, supportsFlag) {\n    const memoized = memo(callback);\n    return () => { var _a; return (_a = supportsFlags[supportsFlag]) !== null && _a !== void 0 ? _a : memoized(); };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs\n\n\nconst supportsLinearEasing = /*@__PURE__*/ memoSupports(() => {\n    try {\n        document\n            .createElement("div")\n            .animate({ opacity: 0 }, { easing: "linear(0, 1)" });\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}, "linearEasing");\n\n\n\n;// ./node_modules/motion-utils/dist/es/progress.mjs\n/*\n  Progress within given range\n\n  Given a lower limit and an upper limit, we return the progress\n  (expressed as a number 0-1) represented by the given value, and\n  limit that progress to within 0-1.\n\n  @param [number]: Lower limit\n  @param [number]: Upper limit\n  @param [number]: Value to find progress within given range\n  @return [number]: Progress of value within range as expressed 0-1\n*/\n/*#__NO_SIDE_EFFECTS__*/\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs\n\n\nconst generateLinearEasing = (easing, duration, // as milliseconds\nresolution = 10 // as milliseconds\n) => {\n    let points = "";\n    const numPoints = Math.max(Math.round(duration / resolution), 2);\n    for (let i = 0; i < numPoints; i++) {\n        points += easing(progress(0, numPoints - 1, i)) + ", ";\n    }\n    return `linear(${points.substring(0, points.length - 2)})`;\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/easing.mjs\n\n\n\n\nfunction isWaapiSupportedEasing(easing) {\n    return Boolean((typeof easing === "function" && supportsLinearEasing()) ||\n        !easing ||\n        (typeof easing === "string" &&\n            (easing in supportedWaapiEasing || supportsLinearEasing())) ||\n        isBezierDefinition(easing) ||\n        (Array.isArray(easing) && easing.every(isWaapiSupportedEasing)));\n}\nconst cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;\nconst supportedWaapiEasing = {\n    linear: "linear",\n    ease: "ease",\n    easeIn: "ease-in",\n    easeOut: "ease-out",\n    easeInOut: "ease-in-out",\n    circIn: /*@__PURE__*/ cubicBezierAsString([0, 0.65, 0.55, 1]),\n    circOut: /*@__PURE__*/ cubicBezierAsString([0.55, 0, 1, 0.45]),\n    backIn: /*@__PURE__*/ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),\n    backOut: /*@__PURE__*/ cubicBezierAsString([0.33, 1.53, 0.69, 0.99]),\n};\nfunction easing_mapEasingToNativeEasing(easing, duration) {\n    if (!easing) {\n        return undefined;\n    }\n    else if (typeof easing === "function" && supportsLinearEasing()) {\n        return generateLinearEasing(easing, duration);\n    }\n    else if (isBezierDefinition(easing)) {\n        return cubicBezierAsString(easing);\n    }\n    else if (Array.isArray(easing)) {\n        return easing.map((segmentEasing) => easing_mapEasingToNativeEasing(segmentEasing, duration) ||\n            supportedWaapiEasing.easeOut);\n    }\n    else {\n        return supportedWaapiEasing[easing];\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs\nconst isDragging = {\n    x: false,\n    y: false,\n};\nfunction isDragActive() {\n    return isDragging.x || isDragging.y;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/utils/resolve-elements.mjs\nfunction resolveElements(elementOrSelector, scope, selectorCache) {\n    var _a;\n    if (elementOrSelector instanceof Element) {\n        return [elementOrSelector];\n    }\n    else if (typeof elementOrSelector === "string") {\n        let root = document;\n        if (scope) {\n            // TODO: Refactor to utils package\n            // invariant(\n            //     Boolean(scope.current),\n            //     "Scope provided, but no element detected."\n            // )\n            root = scope.current;\n        }\n        const elements = (_a = selectorCache === null || selectorCache === void 0 ? void 0 : selectorCache[elementOrSelector]) !== null && _a !== void 0 ? _a : root.querySelectorAll(elementOrSelector);\n        return elements ? Array.from(elements) : [];\n    }\n    return Array.from(elementOrSelector);\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/utils/setup.mjs\n\n\nfunction setupGesture(elementOrSelector, options) {\n    const elements = resolveElements(elementOrSelector);\n    const gestureAbortController = new AbortController();\n    const eventOptions = {\n        passive: true,\n        ...options,\n        signal: gestureAbortController.signal,\n    };\n    const cancel = () => gestureAbortController.abort();\n    return [elements, eventOptions, cancel];\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/hover.mjs\n\n\n\nfunction isValidHover(event) {\n    return !(event.pointerType === "touch" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener("pointerenter")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the "pointerennd" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n    const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n    const onPointerEnter = (enterEvent) => {\n        if (!isValidHover(enterEvent))\n            return;\n        const { target } = enterEvent;\n        const onHoverEnd = onHoverStart(target, enterEvent);\n        if (typeof onHoverEnd !== "function" || !target)\n            return;\n        const onPointerLeave = (leaveEvent) => {\n            if (!isValidHover(leaveEvent))\n                return;\n            onHoverEnd(leaveEvent);\n            target.removeEventListener("pointerleave", onPointerLeave);\n        };\n        target.addEventListener("pointerleave", onPointerLeave, eventOptions);\n    };\n    elements.forEach((element) => {\n        element.addEventListener("pointerenter", onPointerEnter, eventOptions);\n    });\n    return cancel;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nconst isNodeOrChild = (parent, child) => {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs\nconst isPrimaryPointer = (event) => {\n    if (event.pointerType === "mouse") {\n        return typeof event.button !== "number" || event.button <= 0;\n    }\n    else {\n        /**\n         * isPrimary is true for all mice buttons, whereas every touch point\n         * is regarded as its own input. So subsequent concurrent touch points\n         * will be false.\n         *\n         * Specifically match against false here as incomplete versions of\n         * PointerEvents in very old browser might have it set as undefined.\n         */\n        return event.isPrimary !== false;\n    }\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs\nconst focusableElements = new Set([\n    "BUTTON",\n    "INPUT",\n    "SELECT",\n    "TEXTAREA",\n    "A",\n]);\nfunction isElementKeyboardAccessible(element) {\n    return (focusableElements.has(element.tagName) ||\n        element.tabIndex !== -1);\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs\nconst isPressing = new WeakSet();\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs\n\n\n/**\n * Filter out events that are not "Enter" keys.\n */\nfunction filterEvents(callback) {\n    return (event) => {\n        if (event.key !== "Enter")\n            return;\n        callback(event);\n    };\n}\nfunction firePointerEvent(target, type) {\n    target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));\n}\nconst enableKeyboardPress = (focusEvent, eventOptions) => {\n    const element = focusEvent.currentTarget;\n    if (!element)\n        return;\n    const handleKeydown = filterEvents(() => {\n        if (isPressing.has(element))\n            return;\n        firePointerEvent(element, "down");\n        const handleKeyup = filterEvents(() => {\n            firePointerEvent(element, "up");\n        });\n        const handleBlur = () => firePointerEvent(element, "cancel");\n        element.addEventListener("keyup", handleKeyup, eventOptions);\n        element.addEventListener("blur", handleBlur, eventOptions);\n    });\n    element.addEventListener("keydown", handleKeydown, eventOptions);\n    /**\n     * Add an event listener that fires on blur to remove the keydown events.\n     */\n    element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/press/index.mjs\n\n\n\n\n\n\n\n\n/**\n * Filter out events that are not primary pointer events, or are triggering\n * while a Motion gesture is active.\n */\nfunction isValidPressEvent(event) {\n    return isPrimaryPointer(event) && !isDragActive();\n}\n/**\n * Create a press gesture.\n *\n * Press is different to `"pointerdown"`, `"pointerup"` in that it\n * automatically filters out secondary pointer events like right\n * click and multitouch.\n *\n * It also adds accessibility support for keyboards, where\n * an element with a press gesture will receive focus and\n *  trigger on Enter `"keydown"` and `"keyup"` events.\n *\n * This is different to a browser\'s `"click"` event, which does\n * respond to keyboards but only for the `"click"` itself, rather\n * than the press start and end/cancel. The element also needs\n * to be focusable for this to work, whereas a press gesture will\n * make an element focusable by default.\n *\n * @public\n */\nfunction press(elementOrSelector, onPressStart, options = {}) {\n    const [elements, eventOptions, cancelEvents] = setupGesture(elementOrSelector, options);\n    const startPress = (startEvent) => {\n        const element = startEvent.currentTarget;\n        if (!isValidPressEvent(startEvent) || isPressing.has(element))\n            return;\n        isPressing.add(element);\n        const onPressEnd = onPressStart(element, startEvent);\n        const onPointerEnd = (endEvent, success) => {\n            window.removeEventListener("pointerup", onPointerUp);\n            window.removeEventListener("pointercancel", onPointerCancel);\n            if (!isValidPressEvent(endEvent) || !isPressing.has(element)) {\n                return;\n            }\n            isPressing.delete(element);\n            if (typeof onPressEnd === "function") {\n                onPressEnd(endEvent, { success });\n            }\n        };\n        const onPointerUp = (upEvent) => {\n            onPointerEnd(upEvent, options.useGlobalTarget ||\n                isNodeOrChild(element, upEvent.target));\n        };\n        const onPointerCancel = (cancelEvent) => {\n            onPointerEnd(cancelEvent, false);\n        };\n        window.addEventListener("pointerup", onPointerUp, eventOptions);\n        window.addEventListener("pointercancel", onPointerCancel, eventOptions);\n    };\n    elements.forEach((element) => {\n        if (!isElementKeyboardAccessible(element) &&\n            element.getAttribute("tabindex") === null) {\n            element.tabIndex = 0;\n        }\n        const target = options.useGlobalTarget ? window : element;\n        target.addEventListener("pointerdown", startPress, eventOptions);\n        element.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions), eventOptions);\n    });\n    return cancelEvents;\n}\n\n\n\n;// ./node_modules/motion-utils/dist/es/time-conversion.mjs\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\n/*#__NO_SIDE_EFFECTS__*/\nconst time_conversion_secondsToMilliseconds = (seconds) => seconds * 1000;\n/*#__NO_SIDE_EFFECTS__*/\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\n\n\n;// ./node_modules/motion-utils/dist/es/noop.mjs\n/*#__NO_SIDE_EFFECTS__*/\nconst noop_noop = (any) => any;\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/NativeAnimationControls.mjs\n\n\n\nclass NativeAnimationControls_NativeAnimationControls {\n    constructor(animation) {\n        this.animation = animation;\n    }\n    get duration() {\n        var _a, _b, _c;\n        const durationInMs = ((_b = (_a = this.animation) === null || _a === void 0 ? void 0 : _a.effect) === null || _b === void 0 ? void 0 : _b.getComputedTiming().duration) ||\n            ((_c = this.options) === null || _c === void 0 ? void 0 : _c.duration) ||\n            300;\n        return millisecondsToSeconds(Number(durationInMs));\n    }\n    get time() {\n        var _a;\n        if (this.animation) {\n            return millisecondsToSeconds(((_a = this.animation) === null || _a === void 0 ? void 0 : _a.currentTime) || 0);\n        }\n        return 0;\n    }\n    set time(newTime) {\n        if (this.animation) {\n            this.animation.currentTime = time_conversion_secondsToMilliseconds(newTime);\n        }\n    }\n    get speed() {\n        return this.animation ? this.animation.playbackRate : 1;\n    }\n    set speed(newSpeed) {\n        if (this.animation) {\n            this.animation.playbackRate = newSpeed;\n        }\n    }\n    get state() {\n        return this.animation ? this.animation.playState : "finished";\n    }\n    get startTime() {\n        return this.animation ? this.animation.startTime : null;\n    }\n    get finished() {\n        return this.animation ? this.animation.finished : Promise.resolve();\n    }\n    play() {\n        this.animation && this.animation.play();\n    }\n    pause() {\n        this.animation && this.animation.pause();\n    }\n    stop() {\n        if (!this.animation ||\n            this.state === "idle" ||\n            this.state === "finished") {\n            return;\n        }\n        if (this.animation.commitStyles) {\n            this.animation.commitStyles();\n        }\n        this.cancel();\n    }\n    flatten() {\n        var _a;\n        if (!this.animation)\n            return;\n        (_a = this.animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming({ easing: "linear" });\n    }\n    attachTimeline(timeline) {\n        if (this.animation)\n            attachTimeline(this.animation, timeline);\n        return noop_noop;\n    }\n    complete() {\n        this.animation && this.animation.finish();\n    }\n    cancel() {\n        try {\n            this.animation && this.animation.cancel();\n        }\n        catch (e) { }\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs\n\n\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100, createGenerator) {\n    const generator = createGenerator({ ...options, keyframes: [0, scale] });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: "keyframes",\n        ease: (progress) => {\n            return generator.next(duration * progress).value / scale;\n        },\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/utils/convert-options.mjs\n\n\n\n\n\n\nconst defaultEasing = "easeOut";\nfunction convert_options_applyGeneratorOptions(options) {\n    var _a;\n    if (isGenerator(options.type)) {\n        const generatorOptions = createGeneratorEasing(options, 100, options.type);\n        options.ease = supportsLinearEasing()\n            ? generatorOptions.ease\n            : defaultEasing;\n        options.duration = time_conversion_secondsToMilliseconds(generatorOptions.duration);\n        options.type = "keyframes";\n    }\n    else {\n        options.duration = time_conversion_secondsToMilliseconds((_a = options.duration) !== null && _a !== void 0 ? _a : 0.3);\n        options.ease = options.ease || defaultEasing;\n    }\n}\n// TODO: Reuse for NativeAnimation\nfunction convertMotionOptionsToNative(valueName, keyframes, options) {\n    var _a;\n    const nativeKeyframes = {};\n    const nativeOptions = {\n        fill: "both",\n        easing: "linear",\n        composite: "replace",\n    };\n    nativeOptions.delay = time_conversion_secondsToMilliseconds((_a = options.delay) !== null && _a !== void 0 ? _a : 0);\n    convert_options_applyGeneratorOptions(options);\n    nativeOptions.duration = options.duration;\n    const { ease, times } = options;\n    if (times)\n        nativeKeyframes.offset = times;\n    nativeKeyframes[valueName] = keyframes;\n    const easing = easing_mapEasingToNativeEasing(ease, options.duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing)) {\n        nativeKeyframes.easing = easing;\n    }\n    else {\n        nativeOptions.easing = easing;\n    }\n    return {\n        keyframes: nativeKeyframes,\n        options: nativeOptions,\n    };\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/animation/waapi/PseudoAnimation.mjs\n\n\n\nclass PseudoAnimation_PseudoAnimation extends NativeAnimationControls_NativeAnimationControls {\n    constructor(target, pseudoElement, valueName, keyframes, options) {\n        const animationOptions = convertMotionOptionsToNative(valueName, keyframes, options);\n        const animation = target.animate(animationOptions.keyframes, {\n            pseudoElement,\n            ...animationOptions.options,\n        });\n        super(animation);\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/view/utils/css.mjs\nlet pendingRules = {};\nlet style = null;\nconst css_css = {\n    set: (selector, values) => {\n        pendingRules[selector] = values;\n    },\n    commit: () => {\n        if (!style) {\n            style = document.createElement("style");\n            style.id = "motion-view";\n        }\n        let cssText = "";\n        for (const selector in pendingRules) {\n            const rule = pendingRules[selector];\n            cssText += `${selector} {\\n`;\n            for (const [property, value] of Object.entries(rule)) {\n                cssText += `  ${property}: ${value};\\n`;\n            }\n            cssText += "}\\n";\n        }\n        style.textContent = cssText;\n        document.head.appendChild(style);\n        pendingRules = {};\n    },\n    remove: () => {\n        if (style && style.parentElement) {\n            style.parentElement.removeChild(style);\n        }\n    },\n};\n\n\n\n;// ./node_modules/motion-dom/dist/es/view/start.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst definitionNames = (/* unused pure expression or super */ null && (["layout", "enter", "exit", "new", "old"]));\nfunction start_startViewAnimation(update, defaultOptions, targets) {\n    if (!document.startViewTransition) {\n        return new Promise(async (resolve) => {\n            await update();\n            resolve(new BaseGroupPlaybackControls([]));\n        });\n    }\n    // TODO: Go over existing targets and ensure they all have ids\n    /**\n     * If we don\'t have any animations defined for the root target,\n     * remove it from being captured.\n     */\n    if (!hasTarget("root", targets)) {\n        css.set(":root", {\n            "view-transition-name": "none",\n        });\n    }\n    /**\n     * Set the timing curve to linear for all view transition layers.\n     * This gets baked into the keyframes, which can\'t be changed\n     * without breaking the generated animation.\n     *\n     * This allows us to set easing via updateTiming - which can be changed.\n     */\n    css.set("::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)", { "animation-timing-function": "linear !important" });\n    css.commit(); // Write\n    const transition = document.startViewTransition(async () => {\n        await update();\n        // TODO: Go over new targets and ensure they all have ids\n    });\n    transition.finished.finally(() => {\n        css.remove(); // Write\n    });\n    return new Promise((resolve) => {\n        transition.ready.then(() => {\n            var _a;\n            const generatedViewAnimations = getViewAnimations();\n            const animations = [];\n            /**\n             * Create animations for our definitions\n             */\n            targets.forEach((definition, target) => {\n                // TODO: If target is not "root", resolve elements\n                // and iterate over each\n                for (const key of definitionNames) {\n                    if (!definition[key])\n                        continue;\n                    const { keyframes, options } = definition[key];\n                    for (let [valueName, valueKeyframes] of Object.entries(keyframes)) {\n                        if (!valueKeyframes)\n                            continue;\n                        const valueOptions = {\n                            ...getValueTransition(defaultOptions, valueName),\n                            ...getValueTransition(options, valueName),\n                        };\n                        const type = chooseLayerType(key);\n                        /**\n                         * If this is an opacity animation, and keyframes are not an array,\n                         * we need to convert them into an array and set an initial value.\n                         */\n                        if (valueName === "opacity" &&\n                            !Array.isArray(valueKeyframes)) {\n                            const initialValue = type === "new" ? 0 : 1;\n                            valueKeyframes = [initialValue, valueKeyframes];\n                        }\n                        /**\n                         * Resolve stagger function if provided.\n                         */\n                        if (typeof valueOptions.delay === "function") {\n                            valueOptions.delay = valueOptions.delay(0, 1);\n                        }\n                        const animation = new PseudoAnimation(document.documentElement, `::view-transition-${type}(${target})`, valueName, valueKeyframes, valueOptions);\n                        animations.push(animation);\n                    }\n                }\n            });\n            /**\n             * Handle browser generated animations\n             */\n            for (const animation of generatedViewAnimations) {\n                if (animation.playState === "finished")\n                    continue;\n                const { effect } = animation;\n                if (!effect || !(effect instanceof KeyframeEffect))\n                    continue;\n                const { pseudoElement } = effect;\n                if (!pseudoElement)\n                    continue;\n                const name = getLayerName(pseudoElement);\n                if (!name)\n                    continue;\n                const targetDefinition = targets.get(name.layer);\n                if (!targetDefinition) {\n                    /**\n                     * If transition name is group then update the timing of the animation\n                     * whereas if it\'s old or new then we could possibly replace it using\n                     * the above method.\n                     */\n                    const transitionName = name.type === "group" ? "layout" : "";\n                    const animationTransition = {\n                        ...getValueTransition(defaultOptions, transitionName),\n                    };\n                    applyGeneratorOptions(animationTransition);\n                    const easing = mapEasingToNativeEasing(animationTransition.ease, animationTransition.duration);\n                    effect.updateTiming({\n                        delay: secondsToMilliseconds((_a = animationTransition.delay) !== null && _a !== void 0 ? _a : 0),\n                        duration: animationTransition.duration,\n                        easing,\n                    });\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else if (hasOpacity(targetDefinition, "enter") &&\n                    hasOpacity(targetDefinition, "exit") &&\n                    effect\n                        .getKeyframes()\n                        .some((keyframe) => keyframe.mixBlendMode)) {\n                    animations.push(new NativeAnimationControls(animation));\n                }\n                else {\n                    animation.cancel();\n                }\n            }\n            resolve(new BaseGroupPlaybackControls(animations));\n        });\n    });\n}\nfunction hasOpacity(target, key) {\n    var _a;\n    return (_a = target === null || target === void 0 ? void 0 : target[key]) === null || _a === void 0 ? void 0 : _a.keyframes.opacity;\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/view/index.mjs\n\n\n\n/**\n * TODO:\n * - Create view transition on next tick\n * - Replace animations with Motion animations\n * - Return GroupAnimation on next tick\n */\nclass ViewTransitionBuilder {\n    constructor(update, options = {}) {\n        this.currentTarget = "root";\n        this.targets = new Map();\n        this.notifyReady = noop;\n        this.readyPromise = new Promise((resolve) => {\n            this.notifyReady = resolve;\n        });\n        queueMicrotask(() => {\n            startViewAnimation(update, options, this.targets).then((animation) => this.notifyReady(animation));\n        });\n    }\n    get(selector) {\n        this.currentTarget = selector;\n        return this;\n    }\n    layout(keyframes, options) {\n        this.updateTarget("layout", keyframes, options);\n        return this;\n    }\n    new(keyframes, options) {\n        this.updateTarget("new", keyframes, options);\n        return this;\n    }\n    old(keyframes, options) {\n        this.updateTarget("old", keyframes, options);\n        return this;\n    }\n    enter(keyframes, options) {\n        this.updateTarget("enter", keyframes, options);\n        return this;\n    }\n    exit(keyframes, options) {\n        this.updateTarget("exit", keyframes, options);\n        return this;\n    }\n    crossfade(options) {\n        this.updateTarget("enter", { opacity: 1 }, options);\n        this.updateTarget("exit", { opacity: 0 }, options);\n        return this;\n    }\n    updateTarget(target, keyframes, options = {}) {\n        const { currentTarget, targets } = this;\n        if (!targets.has(currentTarget)) {\n            targets.set(currentTarget, {});\n        }\n        const targetData = targets.get(currentTarget);\n        targetData[target] = { keyframes, options };\n    }\n    then(resolve, reject) {\n        return this.readyPromise.then(resolve, reject);\n    }\n}\nfunction view(update, defaultOptions = {}) {\n    return new ViewTransitionBuilder(update, defaultOptions);\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs\n\n\nfunction setDragLock(axis) {\n    if (axis === "x" || axis === "y") {\n        if (isDragging[axis]) {\n            return null;\n        }\n        else {\n            isDragging[axis] = true;\n            return () => {\n                isDragging[axis] = false;\n            };\n        }\n    }\n    else {\n        if (isDragging.x || isDragging.y) {\n            return null;\n        }\n        else {\n            isDragging.x = isDragging.y = true;\n            return () => {\n                isDragging.x = isDragging.y = false;\n            };\n        }\n    }\n}\n\n\n\n;// ./node_modules/motion-dom/dist/es/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/keys-transform.mjs\n/**\n * Generate a list of every possible transform key.\n */\nconst transformPropOrder = [\n    "transformPerspective",\n    "x",\n    "y",\n    "z",\n    "translateX",\n    "translateY",\n    "translateZ",\n    "scale",\n    "scaleX",\n    "scaleY",\n    "rotate",\n    "rotateX",\n    "rotateY",\n    "rotateZ",\n    "skew",\n    "skewX",\n    "skewY",\n];\n/**\n * A quick lookup for transform props.\n */\nconst transformProps = new Set(transformPropOrder);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/keys-position.mjs\n\n\nconst positionalKeys = new Set([\n    "width",\n    "height",\n    "top",\n    "left",\n    "right",\n    "bottom",\n    ...transformPropOrder,\n]);\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/resolve-value.mjs\n\n\nconst isCustomValue = (v) => {\n    return Boolean(v && typeof v === "object" && v.mix && v.toValue);\n};\nconst resolveFinalValueInKeyframes = (v) => {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/GlobalConfig.mjs\nconst MotionGlobalConfig = {\n    skipAnimations: false,\n    useManualTiming: false,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/render-step.mjs\nfunction createRenderStep(runNextFrame) {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set();\n    let nextFrame = new Set();\n    /**\n     * Track whether we\'re currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false;\n    let flushNextFrame = false;\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet();\n    let latestFrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    function triggerCallback(callback) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n        }\n        callback(latestFrameData);\n    }\n    const step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (!queue.has(callback))\n                queue.add(callback);\n            return callback;\n        },\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback);\n            toKeepAlive.delete(callback);\n        },\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData;\n            /**\n             * If we\'re already processing we\'ve probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\n            // Execute this frame\n            thisFrame.forEach(triggerCallback);\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear();\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/batcher.mjs\n\n\n\nconst stepsOrder = [\n    "read", // Read\n    "resolveKeyframes", // Write/Read/Write/Read\n    "update", // Compute\n    "preRender", // Compute\n    "render", // Write\n    "postRender", // Compute\n];\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame);\n        return acc;\n    }, {});\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        read.process(state);\n        resolveKeyframes.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/frame.mjs\n\n\n\nconst { schedule: frame_frame, cancel: cancelFrame, state: frameData, steps: frameSteps, } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop_noop, true);\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/sync-time.mjs\n\n\n\nlet now;\nfunction clearTime() {\n    now = undefined;\n}\n/**\n * An eventloop-synchronous alternative to performance.now().\n *\n * Ensures that time measurements remain consistent within a synchronous context.\n * Usually calling performance.now() twice within the same synchronous context\n * will return different values which isn\'t useful for animations when we\'re usually\n * trying to sync animations to the same frame.\n */\nconst time = {\n    now: () => {\n        if (now === undefined) {\n            time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming\n                ? frameData.timestamp\n                : performance.now());\n        }\n        return now;\n    },\n    set: (newTime) => {\n        now = newTime;\n        queueMicrotask(clearTime);\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/array.mjs\nfunction addUniqueItem(arr, item) {\n    if (arr.indexOf(item) === -1)\n        arr.push(item);\n}\nfunction removeItem(arr, item) {\n    const index = arr.indexOf(item);\n    if (index > -1)\n        arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem([...arr], fromIndex, toIndex) {\n    const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        const [item] = arr.splice(fromIndex, 1);\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\n\n\nclass SubscriptionManager {\n    constructor() {\n        this.subscriptions = [];\n    }\n    add(handler) {\n        addUniqueItem(this.subscriptions, handler);\n        return () => removeItem(this.subscriptions, handler);\n    }\n    notify(a, b, c) {\n        const numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there\'s only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (let i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it\'s possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                const handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    }\n    getSize() {\n        return this.subscriptions.length;\n    }\n    clear() {\n        this.subscriptions.length = 0;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/velocity-per-second.mjs\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/index.mjs\n\n\n\n\n\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = (value) => {\n    return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n    current: undefined,\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    constructor(init, options = {}) {\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = "12.0.6";\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = null;\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        this.updateAndNotify = (v, render = true) => {\n            const currentTime = time.now();\n            /**\n             * If we\'re updating the value during another frame or eventloop\n             * than the previous frame, then the we set the previous frame value\n             * to current.\n             */\n            if (this.updatedAt !== currentTime) {\n                this.setPrevFrameValue();\n            }\n            this.prev = this.current;\n            this.setCurrent(v);\n            // Update update subscribers\n            if (this.current !== this.prev && this.events.change) {\n                this.events.change.notify(this.current);\n            }\n            // Update render subscribers\n            if (render && this.events.renderRequest) {\n                this.events.renderRequest.notify(this.current);\n            }\n        };\n        this.hasAnimated = false;\n        this.setCurrent(init);\n        this.owner = options.owner;\n    }\n    setCurrent(current) {\n        this.current = current;\n        this.updatedAt = time.now();\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current);\n        }\n    }\n    setPrevFrameValue(prevFrameValue = this.current) {\n        this.prevFrameValue = prevFrameValue;\n        this.prevUpdatedAt = this.updatedAt;\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don\'t add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on("change", updateOpacity)\n     *     const unsubscribeY = y.on("change", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription) {\n        if (false) {}\n        return this.on("change", subscription);\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        const unsubscribe = this.events[eventName].add(callback);\n        if (eventName === "change") {\n            return () => {\n                unsubscribe();\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame_frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop();\n                    }\n                });\n            };\n        }\n        return unsubscribe;\n    }\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear();\n        }\n    }\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    attach(passiveEffect, stopPassiveEffect) {\n        this.passiveEffect = passiveEffect;\n        this.stopPassiveEffect = stopPassiveEffect;\n    }\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v, render = true) {\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    }\n    setWithVelocity(prev, current, delta) {\n        this.set(current);\n        this.prev = undefined;\n        this.prevFrameValue = prev;\n        this.prevUpdatedAt = this.updatedAt - delta;\n    }\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v, endAnimation = true) {\n        this.updateAndNotify(v);\n        this.prev = v;\n        this.prevUpdatedAt = this.prevFrameValue = undefined;\n        endAnimation && this.stop();\n        if (this.stopPassiveEffect)\n            this.stopPassiveEffect();\n    }\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this);\n        }\n        return this.current;\n    }\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev;\n    }\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now();\n        if (!this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n            return 0;\n        }\n        const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n        // Casts because of parseFloat\'s poor typing\n        return velocityPerSecond(parseFloat(this.current) -\n            parseFloat(this.prevFrameValue), delta);\n    }\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    start(startAnimation) {\n        this.stop();\n        return new Promise((resolve) => {\n            this.hasAnimated = true;\n            this.animation = startAnimation(resolve);\n            if (this.events.animationStart) {\n                this.events.animationStart.notify();\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify();\n            }\n            this.clearAnimation();\n        });\n    }\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop();\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify();\n            }\n        }\n        this.clearAnimation();\n    }\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation;\n    }\n    clearAnimation() {\n        delete this.animation;\n    }\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you\'ve manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.clearListeners();\n        this.stop();\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect();\n        }\n    }\n}\nfunction motionValue(init, options) {\n    return new MotionValue(init, options);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/setters.mjs\n\n\n\n\n/**\n * Set VisualElement\'s MotionValue, creating a new MotionValue for it if\n * it doesn\'t exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    const resolved = resolveVariant(visualElement, definition);\n    let { transitionEnd = {}, transition = {}, ...target } = resolved || {};\n    target = { ...target, ...transitionEnd };\n    for (const key in target) {\n        const value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nconst isMotionValue = (value) => Boolean(value && value.getVelocity);\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/use-will-change/is.mjs\n\n\nfunction isWillChangeMotionValue(value) {\n    return Boolean(isMotionValue(value) && value.add);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs\n\n\nfunction addValueToWillChange(visualElement, key) {\n    const willChange = visualElement.getValue("willChange");\n    /**\n     * It could be that a user has set willChange to a regular MotionValue,\n     * in which case we can\'t add the value to it.\n     */\n    if (isWillChangeMotionValue(willChange)) {\n        return willChange.add(key);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\n/**\n * Convert camelCase to dash-case properties.\n */\nconst camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs\n\n\nconst optimizedAppearDataId = "framerAppearId";\nconst optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs\n\n\nfunction getOptimisedAppearId(visualElement) {\n    return visualElement.props[optimizedAppearDataAttribute];\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nconst instantAnimationState = {\n    current: false,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs\n\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau\'s BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I\'ve removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn\'t noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we\'re\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop_noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs\n// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs\n// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/back.mjs\n\n\n\n\nconst backOut = /*@__PURE__*/ cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = /*@__PURE__*/ reverseEasing(backOut);\nconst backInOut = /*@__PURE__*/ mirrorEasing(backIn);\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/anticipate.mjs\n\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/circ.mjs\n\n\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circIn);\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\n/**\n * Check if the value is a zero value string like "0px" or "0%"\n */\nconst isZeroValueString = (v) => /^0[^.\\s]+$/u.test(v);\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-none.mjs\n\n\nfunction isNone(value) {\n    if (typeof value === "number") {\n        return value === 0;\n    }\n    else if (value !== null) {\n        return value === "none" || value === "0" || isZeroValueString(value);\n    }\n    else {\n        return true;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/clamp.mjs\nconst clamp = (min, max, v) => {\n    if (v > max)\n        return max;\n    if (v < min)\n        return min;\n    return v;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/numbers/index.mjs\n\n\nconst number = {\n    test: (v) => typeof v === "number",\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = {\n    ...number,\n    transform: (v) => clamp(0, 1, v),\n};\nconst scale = {\n    ...number,\n    default: 1,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/sanitize.mjs\n// If this number is a decimal, make it just five decimal places\n// to avoid exponents\nconst sanitize = (v) => Math.round(v * 100000) / 100000;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/float-regex.mjs\nconst floatRegex = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/is-nullish.mjs\nfunction isNullish(v) {\n    return v == null;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/single-color-regex.mjs\nconst singleColorRegex = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/utils.mjs\n\n\n\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((typeof v === "string" &&\n        singleColorRegex.test(v) &&\n        v.startsWith(type)) ||\n        (testProp &&\n            !isNullish(v) &&\n            Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (typeof v !== "string")\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/rgba.mjs\n\n\n\n\n\nconst clampRgbUnit = (v) => clamp(0, 255, v);\nconst rgbUnit = {\n    ...number,\n    transform: (v) => Math.round(clampRgbUnit(v)),\n};\nconst rgba = {\n    test: /*@__PURE__*/ isColorString("rgb", "red"),\n    parse: /*@__PURE__*/ splitColor("red", "green", "blue"),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" +\n        rgbUnit.transform(red) +\n        ", " +\n        rgbUnit.transform(green) +\n        ", " +\n        rgbUnit.transform(blue) +\n        ", " +\n        sanitize(alpha.transform(alpha$1)) +\n        ")",\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/hex.mjs\n\n\n\nfunction parseHex(v) {\n    let r = "";\n    let g = "";\n    let b = "";\n    let a = "";\n    // If we have 6 characters, ie #FF0000\n    if (v.length > 5) {\n        r = v.substring(1, 3);\n        g = v.substring(3, 5);\n        b = v.substring(5, 7);\n        a = v.substring(7, 9);\n        // Or we have 3 characters, ie #F00\n    }\n    else {\n        r = v.substring(1, 2);\n        g = v.substring(2, 3);\n        b = v.substring(3, 4);\n        a = v.substring(4, 5);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: /*@__PURE__*/ isColorString("#"),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/numbers/units.mjs\nconst createUnitType = (unit) => ({\n    test: (v) => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = /*@__PURE__*/ createUnitType("deg");\nconst percent = /*@__PURE__*/ createUnitType("%");\nconst px = /*@__PURE__*/ createUnitType("px");\nconst vh = /*@__PURE__*/ createUnitType("vh");\nconst vw = /*@__PURE__*/ createUnitType("vw");\nconst progressPercentage = {\n    ...percent,\n    parse: (v) => percent.parse(v) / 100,\n    transform: (v) => percent.transform(v * 100),\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/hsla.mjs\n\n\n\n\n\nconst hsla = {\n    test: /*@__PURE__*/ isColorString("hsl", "hue"),\n    parse: /*@__PURE__*/ splitColor("hue", "saturation", "lightness"),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return ("hsla(" +\n            Math.round(hue) +\n            ", " +\n            percent.transform(sanitize(saturation)) +\n            ", " +\n            percent.transform(sanitize(lightness)) +\n            ", " +\n            sanitize(alpha.transform(alpha$1)) +\n            ")");\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/color/index.mjs\n\n\n\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return typeof v === "string"\n            ? v\n            : v.hasOwnProperty("red")\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/utils/color-regex.mjs\nconst colorRegex = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/complex/index.mjs\n\n\n\n\n\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        typeof v === "string" &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nconst NUMBER_TOKEN = "number";\nconst COLOR_TOKEN = "color";\nconst VAR_TOKEN = "var";\nconst VAR_FUNCTION_TOKEN = "var(";\nconst SPLIT_TOKEN = "${}";\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction analyseComplexValue(value) {\n    const originalValue = value.toString();\n    const values = [];\n    const indexes = {\n        color: [],\n        number: [],\n        var: [],\n    };\n    const types = [];\n    let i = 0;\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\n        if (color.test(parsedValue)) {\n            indexes.color.push(i);\n            types.push(COLOR_TOKEN);\n            values.push(color.parse(parsedValue));\n        }\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n            indexes.var.push(i);\n            types.push(VAR_TOKEN);\n            values.push(parsedValue);\n        }\n        else {\n            indexes.number.push(i);\n            types.push(NUMBER_TOKEN);\n            values.push(parseFloat(parsedValue));\n        }\n        ++i;\n        return SPLIT_TOKEN;\n    });\n    const split = tokenised.split(SPLIT_TOKEN);\n    return { values, split, indexes, types };\n}\nfunction parseComplexValue(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { split, types } = analyseComplexValue(source);\n    const numSections = split.length;\n    return (v) => {\n        let output = "";\n        for (let i = 0; i < numSections; i++) {\n            output += split[i];\n            if (v[i] !== undefined) {\n                const type = types[i];\n                if (type === NUMBER_TOKEN) {\n                    output += sanitize(v[i]);\n                }\n                else if (type === COLOR_TOKEN) {\n                    output += color.transform(v[i]);\n                }\n                else {\n                    output += v[i];\n                }\n            }\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === "number" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parseComplexValue(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = {\n    test,\n    parse: parseComplexValue,\n    createTransformer,\n    getAnimatableNone,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/types/complex/filter.mjs\n\n\n\n/**\n * Properties that should default to 1 or 100%\n */\nconst maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);\nfunction applyDefaultFilter(v) {\n    const [name, value] = v.slice(0, -1).split("(");\n    if (name === "drop-shadow")\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, "");\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + "(" + defaultValue + unit + ")";\n}\nconst functionRegex = /\\b([a-z-]*)\\(.*?\\)/gu;\nconst filter = {\n    ...complex,\n    getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(" ") : v;\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/number-browser.mjs\n\n\nconst browserNumberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Misc\n    backgroundPositionX: px,\n    backgroundPositionY: px,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/transform.mjs\n\n\n\nconst transformValueTypes = {\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\n\n\nconst type_int_int = {\n    ...number,\n    transform: Math.round,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\n\n\n\n\n\n\nconst numberValueTypes = {\n    ...browserNumberValueTypes,\n    ...transformValueTypes,\n    zIndex: type_int_int,\n    size: px,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: type_int_int,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\n\n\n\n\n/**\n * A map of default value types for common values\n */\nconst defaultValueTypes = {\n    ...numberValueTypes,\n    // Color props\n    color: color,\n    backgroundColor: color,\n    outlineColor: color,\n    fill: color,\n    stroke: color,\n    // Border props\n    borderColor: color,\n    borderTopColor: color,\n    borderRightColor: color,\n    borderBottomColor: color,\n    borderLeftColor: color,\n    filter: filter,\n    WebkitFilter: filter,\n};\n/**\n * Gets the default ValueType for the provided value key\n */\nconst getDefaultValueType = (key) => defaultValueTypes[key];\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\n\n\n\n\nfunction animatable_none_getAnimatableNone(key, value) {\n    let defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target\n    return defaultValueType.getAnimatableNone\n        ? defaultValueType.getAnimatableNone(value)\n        : undefined;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/make-none-animatable.mjs\n\n\n\n/**\n * If we encounter keyframes like "none" or "0" and we also have keyframes like\n * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for\n * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into\n * zero equivalents, i.e. "#fff0" or "0px 0px".\n */\nconst invalidTemplates = new Set(["auto", "none", "0"]);\nfunction makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {\n    let i = 0;\n    let animatableTemplate = undefined;\n    while (i < unresolvedKeyframes.length && !animatableTemplate) {\n        const keyframe = unresolvedKeyframes[i];\n        if (typeof keyframe === "string" &&\n            !invalidTemplates.has(keyframe) &&\n            analyseComplexValue(keyframe).values.length) {\n            animatableTemplate = unresolvedKeyframes[i];\n        }\n        i++;\n    }\n    if (animatableTemplate && name) {\n        for (const noneIndex of noneKeyframeIndexes) {\n            unresolvedKeyframes[noneIndex] = animatable_none_getAnimatableNone(name, animatableTemplate);\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\n\n\n\n\nconst isNumOrPxType = (v) => v === number || v === px;\nconst getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);\nconst getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {\n    if (transform === "none" || !transform)\n        return 0;\n    const matrix3d = transform.match(/^matrix3d\\((.+)\\)$/u);\n    if (matrix3d) {\n        return getPosFromMatrix(matrix3d[1], pos3);\n    }\n    else {\n        const matrix = transform.match(/^matrix\\((.+)\\)$/u);\n        if (matrix) {\n            return getPosFromMatrix(matrix[1], pos2);\n        }\n        else {\n            return 0;\n        }\n    }\n};\nconst transformKeys = new Set(["x", "y", "z"]);\nconst nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));\nfunction removeNonTranslationalTransform(visualElement) {\n    const removedTransforms = [];\n    nonTranslationalTransformKeys.forEach((key) => {\n        const value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith("scale") ? 1 : 0);\n        }\n    });\n    return removedTransforms;\n}\nconst positionalValues = {\n    // Dimensions\n    width: ({ x }, { paddingLeft = "0", paddingRight = "0" }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),\n    height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),\n    top: (_bbox, { top }) => parseFloat(top),\n    left: (_bbox, { left }) => parseFloat(left),\n    bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),\n    right: ({ x }, { left }) => parseFloat(left) + (x.max - x.min),\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\n// Alias translate longform names\npositionalValues.translateX = positionalValues.x;\npositionalValues.translateY = positionalValues.y;\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs\n\n\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we\'re measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it\'ll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren\'t going\n         * to trigger read/write thrashing don\'t need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame_frame.read(readAllKeyframes);\n                frame_frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */\n                if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    }\n                    else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                }\n                else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\n\n\n;// ./node_modules/motion-utils/dist/es/errors.mjs\n\n\nlet warning = noop_noop;\nlet invariant = noop_noop;\nif (false) {}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"\n */\nconst isNumericalString = (v) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(v);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\nconst checkStringStartsWith = (token) => (key) => typeof key === "string" && key.startsWith(token);\nconst isCSSVariableName = \n/*@__PURE__*/ checkStringStartsWith("--");\nconst startsAsVariableToken = \n/*@__PURE__*/ checkStringStartsWith("var(--");\nconst isCSSVariableToken = (value) => {\n    const startsWithToken = startsAsVariableToken(value);\n    if (!startsWithToken)\n        return false;\n    // Ensure any comments are stripped from the value as this can harm performance of the regex.\n    return singleCssVariableRegex.test(value.split("/*")[0].trim());\n};\nconst singleCssVariableRegex = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu;\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\n\n\n\n\n/**\n * Parse Framer\'s special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, \'#fff\']\n * ```\n *\n * @param current\n */\nconst splitCSSVariableRegex = \n// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n/^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u;\nfunction parseCSSVariable(current) {\n    const match = splitCSSVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    const [, token1, token2, fallback] = match;\n    return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];\n}\nconst maxDepth = 4;\nfunction getVariableValue(current, element, depth = 1) {\n    invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);\n    const [token, fallback] = parseCSSVariable(current);\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    const resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        const trimmed = resolved.trim();\n        return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;\n    }\n    return isCSSVariableToken(fallback)\n        ? getVariableValue(fallback, element, depth + 1)\n        : fallback;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\n/**\n * Tests a provided value against a ValueType\n */\nconst testValueType = (v) => (type) => type.test(v);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\n/**\n * ValueType for "auto"\n */\nconst auto = {\n    test: (v) => v === "auto",\n    parse: (v) => v,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\n\n\n\n\n\n/**\n * A list of value types commonly used for dimensions\n */\nconst dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nconst findDimensionValueType = (v) => dimensionValueTypes.find(testValueType(v));\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs\n\n\n\n\n\n\n\n\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === "string") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it\'s a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn\'t a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don\'t recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === "string") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === "height") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\n\n\n/**\n * Check if a value is animatable. Examples:\n *\n * ✅: 100, "100px", "#fff"\n * ❌: "block", "url(2.jpg)"\n * @param value\n *\n * @internal\n */\nconst isAnimatable = (value, name) => {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (name === "zIndex")\n        return false;\n    // If it\'s a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === "number" || Array.isArray(value))\n        return true;\n    if (typeof value === "string" && // It\'s animatable if we have a string\n        (complex.test(value) || value === "0") && // And it contains numbers and/or colors\n        !value.startsWith("url(") // Unless it starts with "url("\n    ) {\n        return true;\n    }\n    return false;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/utils/can-animate.mjs\n\n\n\n\nfunction hasKeyframesChanged(keyframes) {\n    const current = keyframes[0];\n    if (keyframes.length === 1)\n        return true;\n    for (let i = 0; i < keyframes.length; i++) {\n        if (keyframes[i] !== current)\n            return true;\n    }\n}\nfunction canAnimate(keyframes, name, type, velocity) {\n    /**\n     * Check if we\'re able to animate between the start and end keyframes,\n     * and throw a warning if we\'re attempting to animate between one that\'s\n     * animatable and another that isn\'t.\n     */\n    const originKeyframe = keyframes[0];\n    if (originKeyframe === null)\n        return false;\n    /**\n     * These aren\'t traditionally animatable but we do support them.\n     * In future we could look into making this more generic or replacing\n     * this function with mix() === mixImmediate\n     */\n    if (name === "display" || name === "visibility")\n        return true;\n    const targetKeyframe = keyframes[keyframes.length - 1];\n    const isOriginAnimatable = isAnimatable(originKeyframe, name);\n    const isTargetAnimatable = isAnimatable(targetKeyframe, name);\n    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n    // Always skip if any of these are true\n    if (!isOriginAnimatable || !isTargetAnimatable) {\n        return false;\n    }\n    return (hasKeyframesChanged(keyframes) ||\n        ((type === "spring" || isGenerator(type)) && velocity));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs\nconst isNotNull = (value) => value !== null;\nfunction getFinalKeyframe(keyframes, { repeat, repeatType = "loop" }, finalKeyframe) {\n    const resolvedKeyframes = keyframes.filter(isNotNull);\n    const index = repeat && repeatType !== "loop" && repeat % 2 === 1\n        ? 0\n        : resolvedKeyframes.length - 1;\n    return !index || finalKeyframe === undefined\n        ? resolvedKeyframes[index]\n        : finalKeyframe;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs\n\n\n\n\n\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to "start" an animation as soon\n * as it\'s triggered, we also want to avoid a visual jump if there\'s a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won\'t restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there\'s a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can\'t animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate &&\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = "keyframes";\n        this.options.ease = "linear";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/number.mjs\n/*\n  Value in range from progress\n\n  Given a lower limit and an upper limit, we return the value within\n  that range as expressed by progress (usually a number from 0 to 1)\n\n  So progress = 0.5 would change\n\n  from -------- to\n\n  to\n\n  from ---- to\n\n  E.g. from = 10, to = 20, progress = 0.5 => 15\n\n  @param [number]: Lower limit of range\n  @param [number]: Upper limit of range\n  @param [number]: The progress between lower and upper limits expressed 0-1\n  @return [number]: Value as calculated from progress within range (not limited within range)\n*/\nconst mixNumber = (from, to, progress) => {\n    return from + (to - from) * progress;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/hsla-to-rgba.mjs\n// Adapted from https://gist.github.com/mjackson/5311256\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/immediate.mjs\nfunction mixImmediate(a, b) {\n    return (p) => (p > 0 ? b : a);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/color.mjs\n\n\n\n\n\n\n\n\n// Linear color space blending\n// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw\n// Demonstrated http://codepen.io/osublake/pen/xGVVaN\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const expo = v * (to * to - fromExpo) + fromExpo;\n    return expo < 0 ? 0 : Math.sqrt(expo);\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nfunction asRGBA(color) {\n    const type = getColorType(color);\n    warning(Boolean(type), `\'${color}\' is not an animatable color. Use the equivalent color code instead.`);\n    if (!Boolean(type))\n        return false;\n    let model = type.parse(color);\n    if (type === hsla) {\n        // TODO Remove this cast - needed since Motion\'s stricter typing\n        model = hslaToRgba(model);\n    }\n    return model;\n}\nconst mixColor = (from, to) => {\n    const fromRGBA = asRGBA(from);\n    const toRGBA = asRGBA(to);\n    if (!fromRGBA || !toRGBA) {\n        return mixImmediate(from, to);\n    }\n    const blended = { ...fromRGBA };\n    return (v) => {\n        blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);\n        blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);\n        blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);\n        blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v);\n        return rgba.transform(blended);\n    };\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/pipe.mjs\n/**\n * Pipe\n * Compose other transformers to run linearily\n * pipe(min(20), max(40))\n * @param  {...functions} transformers\n * @return {function}\n */\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/visibility.mjs\nconst invisibleValues = new Set(["none", "hidden"]);\n/**\n * Returns a function that, when provided a progress value between 0 and 1,\n * will return the "none" or "hidden" string only when the progress is that of\n * the origin or target.\n */\nfunction mixVisibility(origin, target) {\n    if (invisibleValues.has(origin)) {\n        return (p) => (p <= 0 ? origin : target);\n    }\n    else {\n        return (p) => (p >= 1 ? target : origin);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/complex.mjs\n\n\n\n\n\n\n\n\n\n\nfunction complex_mixNumber(a, b) {\n    return (p) => mixNumber(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === "number") {\n        return complex_mixNumber;\n    }\n    else if (typeof a === "string") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === "object") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values \'${origin}\' and \'${target}\' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/mix/index.mjs\n\n\n\nfunction mix(from, to, p) {\n    if (typeof from === "number" &&\n        typeof to === "number" &&\n        typeof p === "number") {\n        return mixNumber(from, to, p);\n    }\n    const mixer = getMixer(from);\n    return mixer(from, to);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs\n\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/spring/defaults.mjs\nconst springDefaults = {\n    // Default spring physics\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    velocity: 0.0,\n    // Default duration/bounce-based options\n    duration: 800, // in ms\n    bounce: 0.3,\n    visualDuration: 0.3, // in seconds\n    // Rest thresholds\n    restSpeed: {\n        granular: 0.01,\n        default: 2,\n    },\n    restDelta: {\n        granular: 0.005,\n        default: 0.5,\n    },\n    // Limits\n    minDuration: 0.01, // in seconds\n    maxDuration: 10.0, // in seconds\n    minDamping: 0.05,\n    maxDamping: 1,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs\n\n\n\n\nconst safeMin = 0.001;\nfunction findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= time_conversion_secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);\n    duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = time_conversion_secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: springDefaults.stiffness,\n            damping: springDefaults.damping,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs\n\n\n\n\n\n\n\nconst durationKeys = ["duration", "bounce"];\nconst physicsKeys = ["stiffness", "damping", "mass"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== "object"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it\'s mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we\'re working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can\'t overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? time_conversion_secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + "ms " + easing;\n        },\n    };\n    return generator;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/inertia.mjs\n\n\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don\'t want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/ease.mjs\n\n\nconst easeIn = /*@__PURE__*/ cubicBezier(0.42, 0, 1, 1);\nconst easeOut = /*@__PURE__*/ cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = /*@__PURE__*/ cubicBezier(0.42, 0, 0.58, 1);\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs\nconst isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== "number";\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/easing/utils/map.mjs\n\n\n\n\n\n\n\n\nconst easingLookup = {\n    linear: noop_noop,\n    easeIn: easeIn,\n    easeInOut: easeInOut,\n    easeOut: easeOut,\n    circIn: circIn,\n    circInOut: circInOut,\n    circOut: circOut,\n    backIn: backIn,\n    backInOut: backInOut,\n    backOut: backOut,\n    anticipate: anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (isBezierDefinition(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === "string") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type \'${definition}\'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/interpolate.mjs\n\n\n\n\n\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || mix;\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop_noop : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\n/**\n * Create a function that maps from a numerical input array to a generic output array.\n *\n * Accepts:\n *   - Numbers\n *   - Colors (hex, hsl, hsla, rgb, rgba)\n *   - Complex (combinations of one or more numbers or strings)\n *\n * ```jsx\n * const mixColor = interpolate([0, 1], [\'#fff\', \'#000\'])\n *\n * mixColor(0.5) // \'rgba(128, 128, 128, 1)\'\n * ```\n *\n * TODO Revist this approach once we\'ve moved to data models for values,\n * probably not needed to pregenerate mixer functions.\n *\n * @public\n */\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, "Both input and output ranges must be the same length");\n    /**\n     * If we\'re only provided a single input, we can just make a function\n     * that returns the output.\n     */\n    if (inputLength === 1)\n        return () => output[0];\n    if (inputLength === 2 && output[0] === output[1])\n        return () => output[1];\n    const isZeroDeltaRange = input[0] === input[1];\n    // If input runs highest -> lowest, reverse both arrays\n    if (input[0] > input[inputLength - 1]) {\n        input = [...input].reverse();\n        output = [...output].reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const numMixers = mixers.length;\n    const interpolator = (v) => {\n        if (isZeroDeltaRange && v < input[0])\n            return output[0];\n        let i = 0;\n        if (numMixers > 1) {\n            for (; i < input.length - 2; i++) {\n                if (v < input[i + 1])\n                    break;\n            }\n        }\n        const progressInRange = progress(input[i], input[i + 1], v);\n        return mixers[i](progressInRange);\n    };\n    return isClamp\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/offsets/fill.mjs\n\n\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress(0, remaining, i);\n        offset.push(mixNumber(min, 1, offsetProgress));\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/offsets/default.mjs\n\n\nfunction defaultOffset(arr) {\n    const offset = [0];\n    fillOffset(offset, arr.length - 1);\n    return offset;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/offsets/time.mjs\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs\n\n\n\n\n\n\n\nfunction keyframes_defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = "easeInOut", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it\'s mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they\'re the correct length\n    // TODO Maybe we should warn here if there\'s a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : keyframes_defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/drivers/driver-frameloop.mjs\n\n\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame_frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we\'re processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => (frameData.isProcessing ? frameData.timestamp : time.now()),\n    };\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst generators = {\n    decay: inertia,\n    inertia: inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring: spring,\n};\nconst percentToProgress = (percent) => percent / 100;\n/**\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\n * features we expose publically. Mostly the compatibility is to ensure visual identity\n * between both WAAPI and main thread animations.\n */\nclass MainThreadAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        /**\n         * The time at which the animation was paused.\n         */\n        this.holdTime = null;\n        /**\n         * The time at which the animation was cancelled.\n         */\n        this.cancelTime = null;\n        /**\n         * The current time of the animation.\n         */\n        this.currentTime = 0;\n        /**\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\n         */\n        this.playbackSpeed = 1;\n        /**\n         * The state of the animation to apply when the animation is resolved. This\n         * allows calls to the public API to control the animation before it is resolved,\n         * without us having to resolve it first.\n         */\n        this.pendingPlayState = "running";\n        /**\n         * The time at which the animation was started.\n         */\n        this.startTime = null;\n        this.state = "idle";\n        /**\n         * This method is bound to the instance to fix a pattern where\n         * animation.stop is returned as a reference from a useEffect.\n         */\n        this.stop = () => {\n            this.resolver.cancel();\n            this.isStopped = true;\n            if (this.state === "idle")\n                return;\n            this.teardown();\n            const { onStop } = this.options;\n            onStop && onStop();\n        };\n        const { name, motionValue, element, keyframes } = this.options;\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    flatten() {\n        super.flatten();\n        // If we\'ve already resolved the animation, re-initialise it\n        if (this._resolved) {\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n        }\n    }\n    initPlayback(keyframes$1) {\n        const { type = "keyframes", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\n        const generatorFactory = isGenerator(type)\n            ? type\n            : generators[type] || keyframes;\n        /**\n         * If our generator doesn\'t support mixing numbers, we need to replace keyframes with\n         * [0, 100] and then make a function that maps that to the actual keyframes.\n         *\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\n         */\n        let mapPercentToKeyframes;\n        let mirroredGenerator;\n        if (generatorFactory !== keyframes &&\n            typeof keyframes$1[0] !== "number") {\n            if (false) {}\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n            keyframes$1 = [0, 100];\n        }\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\n        /**\n         * If we have a mirror repeat type we need to create a second generator that outputs the\n         * mirrored (not reversed) animation and later ping pong between the two generators.\n         */\n        if (repeatType === "mirror") {\n            mirroredGenerator = generatorFactory({\n                ...this.options,\n                keyframes: [...keyframes$1].reverse(),\n                velocity: -velocity,\n            });\n        }\n        /**\n         * If duration is undefined and we have repeat options,\n         * we need to calculate a duration from the generator.\n         *\n         * We set it to the generator itself to cache the duration.\n         * Any timeline resolver will need to have already precalculated\n         * the duration by this step.\n         */\n        if (generator.calculatedDuration === null) {\n            generator.calculatedDuration = calcGeneratorDuration(generator);\n        }\n        const { calculatedDuration } = generator;\n        const resolvedDuration = calculatedDuration + repeatDelay;\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n        return {\n            generator,\n            mirroredGenerator,\n            mapPercentToKeyframes,\n            calculatedDuration,\n            resolvedDuration,\n            totalDuration,\n        };\n    }\n    onPostResolved() {\n        const { autoplay = true } = this.options;\n        this.play();\n        if (this.pendingPlayState === "paused" || !autoplay) {\n            this.pause();\n        }\n        else {\n            this.state = this.pendingPlayState;\n        }\n    }\n    tick(timestamp, sample = false) {\n        const { resolved } = this;\n        // If the animations has failed to resolve, return the final keyframe.\n        if (!resolved) {\n            const { keyframes } = this.options;\n            return { done: true, value: keyframes[keyframes.length - 1] };\n        }\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\n        if (this.startTime === null)\n            return generator.next(0);\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (this.speed > 0) {\n            this.startTime = Math.min(this.startTime, timestamp);\n        }\n        else if (this.speed < 0) {\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n        }\n        // Update currentTime\n        if (sample) {\n            this.currentTime = timestamp;\n        }\n        else if (this.holdTime !== null) {\n            this.currentTime = this.holdTime;\n        }\n        else {\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n            // example.\n            this.currentTime =\n                Math.round(timestamp - this.startTime) * this.speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n        const isInDelayPhase = this.speed >= 0\n            ? timeWithoutDelay < 0\n            : timeWithoutDelay > totalDuration;\n        this.currentTime = Math.max(timeWithoutDelay, 0);\n        // If this animation has finished, set the current time  to the total duration.\n        if (this.state === "finished" && this.holdTime === null) {\n            this.currentTime = totalDuration;\n        }\n        let elapsed = this.currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we\'ll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we\'re not running in "normal" direction\n             */\n            const isOddIteration = Boolean(currentIteration % 2);\n            if (isOddIteration) {\n                if (repeatType === "reverse") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === "mirror") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n        }\n        /**\n         * If we\'re in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes[0] }\n            : frameGenerator.next(elapsed);\n        if (mapPercentToKeyframes) {\n            state.value = mapPercentToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done =\n                this.speed >= 0\n                    ? this.currentTime >= totalDuration\n                    : this.currentTime <= 0;\n        }\n        const isAnimationFinished = this.holdTime === null &&\n            (this.state === "finished" || (this.state === "running" && done));\n        if (isAnimationFinished && finalKeyframe !== undefined) {\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n        }\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            this.finish();\n        }\n        return state;\n    }\n    get duration() {\n        const { resolved } = this;\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n    }\n    get time() {\n        return millisecondsToSeconds(this.currentTime);\n    }\n    set time(newTime) {\n        newTime = time_conversion_secondsToMilliseconds(newTime);\n        this.currentTime = newTime;\n        if (this.holdTime !== null || this.speed === 0) {\n            this.holdTime = newTime;\n        }\n        else if (this.driver) {\n            this.startTime = this.driver.now() - newTime / this.speed;\n        }\n    }\n    get speed() {\n        return this.playbackSpeed;\n    }\n    set speed(newSpeed) {\n        const hasChanged = this.playbackSpeed !== newSpeed;\n        this.playbackSpeed = newSpeed;\n        if (hasChanged) {\n            this.time = millisecondsToSeconds(this.currentTime);\n        }\n    }\n    play() {\n        if (!this.resolver.isScheduled) {\n            this.resolver.resume();\n        }\n        if (!this._resolved) {\n            this.pendingPlayState = "running";\n            return;\n        }\n        if (this.isStopped)\n            return;\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\n        if (!this.driver) {\n            this.driver = driver((timestamp) => this.tick(timestamp));\n        }\n        onPlay && onPlay();\n        const now = this.driver.now();\n        if (this.holdTime !== null) {\n            this.startTime = now - this.holdTime;\n        }\n        else if (!this.startTime) {\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        }\n        else if (this.state === "finished") {\n            this.startTime = now;\n        }\n        if (this.state === "finished") {\n            this.updateFinishedPromise();\n        }\n        this.cancelTime = this.startTime;\n        this.holdTime = null;\n        /**\n         * Set playState to running only after we\'ve used it in\n         * the previous logic.\n         */\n        this.state = "running";\n        this.driver.start();\n    }\n    pause() {\n        var _a;\n        if (!this._resolved) {\n            this.pendingPlayState = "paused";\n            return;\n        }\n        this.state = "paused";\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n    }\n    complete() {\n        if (this.state !== "running") {\n            this.play();\n        }\n        this.pendingPlayState = this.state = "finished";\n        this.holdTime = null;\n    }\n    finish() {\n        this.teardown();\n        this.state = "finished";\n        const { onComplete } = this.options;\n        onComplete && onComplete();\n    }\n    cancel() {\n        if (this.cancelTime !== null) {\n            this.tick(this.cancelTime);\n        }\n        this.teardown();\n        this.updateFinishedPromise();\n    }\n    teardown() {\n        this.state = "idle";\n        this.stopDriver();\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        this.startTime = this.cancelTime = null;\n        this.resolver.cancel();\n    }\n    stopDriver() {\n        if (!this.driver)\n            return;\n        this.driver.stop();\n        this.driver = undefined;\n    }\n    sample(time) {\n        this.startTime = 0;\n        return this.tick(time, true);\n    }\n}\n// Legacy interface\nfunction animateValue(options) {\n    return new MainThreadAnimation(options);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/utils/accelerated-values.mjs\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\n    "opacity",\n    "clipPath",\n    "filter",\n    "transform",\n    // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved\n    // or until we implement support for linear() easing.\n    // "background-color"\n]);\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/waapi/index.mjs\n\n\nfunction startWaapiAnimation(element, valueName, keyframes, { delay = 0, duration = 300, repeat = 0, repeatType = "loop", ease = "easeInOut", times, } = {}) {\n    const keyframeOptions = { [valueName]: keyframes };\n    if (times)\n        keyframeOptions.offset = times;\n    const easing = easing_mapEasingToNativeEasing(ease, duration);\n    /**\n     * If this is an easing array, apply to keyframes, not animation as a whole\n     */\n    if (Array.isArray(easing))\n        keyframeOptions.easing = easing;\n    return element.animate(keyframeOptions, {\n        delay,\n        duration,\n        easing: !Array.isArray(easing) ? easing : "linear",\n        fill: "both",\n        iterations: repeat + 1,\n        direction: repeatType === "reverse" ? "alternate" : "normal",\n    });\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/waapi/utils/supports-waapi.mjs\n\n\nconst supportsWaapi = /*@__PURE__*/ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn\'t support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === "spring" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it\'s likely\n     * we\'re heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: "linear",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate: anticipate,\n    backInOut: backInOut,\n    circInOut: circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!motionValue.owner || !motionValue.owner.current) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn\'t supported\n         * by WAAPI (like "anticipate"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === "string" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can\'t animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = "keyframes";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it\'s more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn\'t, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = time_conversion_secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return "idle";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop_noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop_noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === "finished") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === "idle")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === "idle" ||\n            animation.playState === "finished") {\n            return;\n        }\n        /**\n         * WAAPI doesn\'t natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, "previous" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = time_conversion_secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        if (!motionValue ||\n            !motionValue.owner ||\n            !(motionValue.owner.current instanceof HTMLElement)) {\n            return false;\n        }\n        const { onUpdate, transformTemplate } = motionValue.owner.getProps();\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            /**\n             * If we\'re outputting values to onUpdate then we can\'t use WAAPI as there\'s\n             * no way to read the value from WAAPI every frame.\n             */\n            !onUpdate &&\n            !transformTemplate &&\n            !repeatDelay &&\n            repeatType !== "mirror" &&\n            damping !== 0 &&\n            type !== "inertia");\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\n\n\nconst underDampedSpring = {\n    type: "spring",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n};\nconst criticallyDampedSpring = (target) => ({\n    type: "spring",\n    stiffness: 550,\n    damping: target === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n});\nconst keyframesTransition = {\n    type: "keyframes",\n    duration: 0.8,\n};\n/**\n * Default easing curve is a slightly shallower version of\n * the default browser easing curve.\n */\nconst ease = {\n    type: "keyframes",\n    ease: [0.25, 0.1, 0.35, 1],\n    duration: 0.3,\n};\nconst getDefaultTransition = (valueKey, { keyframes }) => {\n    if (keyframes.length > 2) {\n        return keyframesTransition;\n    }\n    else if (transformProps.has(valueKey)) {\n        return valueKey.startsWith("scale")\n            ? criticallyDampedSpring(keyframes[1])\n            : underDampedSpring;\n    }\n    return ease;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from, elapsed, ...transition }) {\n    return !!Object.keys(transition).length;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs\n\n\n\n\n\n\n\n\n\n\n\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {\n    const valueTransition = get_value_transition_getValueTransition(transition, name) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it\'d be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    const delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn\'t a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    let { elapsed = 0 } = transition;\n    elapsed = elapsed - time_conversion_secondsToMilliseconds(delay);\n    let options = {\n        keyframes: Array.isArray(target) ? target : [null, target],\n        ease: "easeOut",\n        velocity: value.getVelocity(),\n        ...valueTransition,\n        delay: -elapsed,\n        onUpdate: (v) => {\n            value.set(v);\n            valueTransition.onUpdate && valueTransition.onUpdate(v);\n        },\n        onComplete: () => {\n            onComplete();\n            valueTransition.onComplete && valueTransition.onComplete();\n        },\n        name,\n        motionValue: value,\n        element: isHandoff ? undefined : element,\n    };\n    /**\n     * If there\'s no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n        options = {\n            ...options,\n            ...getDefaultTransition(name, options),\n        };\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n        options.duration = time_conversion_secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n        options.repeatDelay = time_conversion_secondsToMilliseconds(options.repeatDelay);\n    }\n    if (options.from !== undefined) {\n        options.keyframes[0] = options.from;\n    }\n    let shouldSkip = false;\n    if (options.type === false ||\n        (options.duration === 0 && !options.repeatDelay)) {\n        options.duration = 0;\n        if (options.delay === 0) {\n            shouldSkip = true;\n        }\n    }\n    if (instantAnimationState.current ||\n        MotionGlobalConfig.skipAnimations) {\n        shouldSkip = true;\n        options.duration = 0;\n        options.delay = 0;\n    }\n    /**\n     * If we can or must skip creating the animation, and apply only\n     * the final keyframe, do so. We also check once keyframes are resolved but\n     * this early check prevents the need to create an animation at all.\n     */\n    if (shouldSkip && !isHandoff && value.get() !== undefined) {\n        const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n        if (finalKeyframe !== undefined) {\n            frame_frame.update(() => {\n                options.onUpdate(finalKeyframe);\n                options.onComplete();\n            });\n            // We still want to return some animation controls here rather\n            // than returning undefined\n            return new GroupPlaybackControls([]);\n        }\n    }\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the\n     * optimised animation.\n     */\n    if (!isHandoff && AcceleratedAnimation.supports(options)) {\n        return new AcceleratedAnimation(options);\n    }\n    else {\n        return new MainThreadAnimation(options);\n    }\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs\n\n\n\n\n\n\n\n\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\nfunction animateTarget(visualElement, targetAndTransition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type &&\n        visualElement.animationState &&\n        visualElement.animationState.getState()[type];\n    for (const key in target) {\n        const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);\n        const valueTarget = target[key];\n        if (valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = {\n            delay,\n            ...get_value_transition_getValueTransition(transition || {}, key),\n        };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we\'re handling off from an existing animation.\n         */\n        let isHandoff = false;\n        if (window.MotionHandoffAnimation) {\n            const appearId = getOptimisedAppearId(visualElement);\n            if (appearId) {\n                const startTime = window.MotionHandoffAnimation(appearId, key, frame_frame);\n                if (startTime !== null) {\n                    valueTransition.startTime = startTime;\n                    isHandoff = true;\n                }\n            }\n        }\n        addValueToWillChange(visualElement, key);\n        value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key)\n            ? { type: false }\n            : valueTransition, visualElement, isHandoff));\n        const animation = value.animation;\n        if (animation) {\n            animations.push(animation);\n        }\n    }\n    if (transitionEnd) {\n        Promise.all(animations).then(() => {\n            frame_frame.update(() => {\n                transitionEnd && setTarget(visualElement, transitionEnd);\n            });\n        });\n    }\n    return animations;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs\n\n\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === "exit"\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a "when" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === "beforeChildren"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify("AnimationStart", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify("AnimationComplete", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs\n\n\n\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify("AnimationStart", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === "string") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === "function"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));\n    }\n    return animation.then(() => {\n        visualElement.notify("AnimationComplete", definition);\n    });\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs\n\n\n\nconst numVariantProps = variantProps.length;\nfunction getVariantContext(visualElement) {\n    if (!visualElement)\n        return undefined;\n    if (!visualElement.isControllingVariants) {\n        const context = visualElement.parent\n            ? getVariantContext(visualElement.parent) || {}\n            : {};\n        if (visualElement.props.initial !== undefined) {\n            context.initial = visualElement.props.initial;\n        }\n        return context;\n    }\n    const context = {};\n    for (let i = 0; i < numVariantProps; i++) {\n        const name = variantProps[i];\n        const prop = visualElement.props[name];\n        if (isVariantLabel(prop) || prop === false) {\n            context[name] = prop;\n        }\n    }\n    return context;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\n\n\n\n\n\n\n\n\n\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\n}\nfunction createAnimationState(visualElement) {\n    let animate = animateList(visualElement);\n    let state = createState();\n    let isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\n        var _a;\n        const resolved = resolveVariant(visualElement, definition, type === "exit"\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n            : undefined);\n        if (resolved) {\n            const { transition, transitionEnd, ...target } = resolved;\n            acc = { ...acc, ...target, ...transitionEnd };\n        }\n        return acc;\n    };\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being "handled" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(changedActiveType) {\n        const { props } = visualElement;\n        const context = getVariantContext(visualElement.parent) || {};\n        /**\n         * A list of animations that we\'ll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        const animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        const removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        let encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        let removedVariantIndex = Infinity;\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it\'s handling and whether or not they\'ve changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (let i = 0; i < numAnimationTypes; i++) {\n            const type = reversePriorityOrder[i];\n            const typeState = state[type];\n            const prop = props[type] !== undefined\n                ? props[type]\n                : context[type];\n            const propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            let isInherited = prop === context[type] &&\n                prop !== props[type] &&\n                propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = { ...encounteredKeys };\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn\'t active and hasn\'t *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn\'t and don\'t have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn\'t define an animation\n                isAnimationControls(prop) ||\n                typeof prop === "boolean") {\n                continue;\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            let shouldAnimateType = variantDidChange ||\n                // If we\'re making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            let handledRemovedValues = false;\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn\'t one already\n             */\n            const definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We\'ll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn\'t been removed in a higher priority but hasn\'t changed, and\n             *    needs adding to the type\'s protectedKeys list.\n             */\n            const { prevResolvedValues = {} } = typeState;\n            const allKeys = {\n                ...prevResolvedValues,\n                ...resolvedValues,\n            };\n            const markToAnimate = (key) => {\n                shouldAnimateType = true;\n                if (removedKeys.has(key)) {\n                    handledRemovedValues = true;\n                    removedKeys.delete(key);\n                }\n                typeState.needsAnimating[key] = true;\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = false;\n            };\n            for (const key in allKeys) {\n                const next = resolvedValues[key];\n                const prev = prevResolvedValues[key];\n                // If we\'ve already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                let valueHasChanged = false;\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                    valueHasChanged = !shallowCompare(next, prev);\n                }\n                else {\n                    valueHasChanged = next !== prev;\n                }\n                if (valueHasChanged) {\n                    if (next !== undefined && next !== null) {\n                        // If next is defined and doesn\'t equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it\'s undefined, it\'s been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn\'t changed and it isn\'t undefined, we want to check if it\'s\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn\'t changed, we add it to the list of protected values\n                     * to ensure it doesn\'t get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to skip this animation\n             * unless the inherited variants haven\'t changed on this render.\n             */\n            const willAnimateViaParent = isInherited && variantDidChange;\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n            if (shouldAnimateType && needsAnimating) {\n                animations.push(...definitionList.map((animation) => ({\n                    animation: animation,\n                    options: { type },\n                })));\n            }\n        }\n        /**\n         * If there are some removed value that haven\'t been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            const fallbackAnimation = {};\n            removedKeys.forEach((key) => {\n                const fallbackTarget = visualElement.getBaseTarget(key);\n                const motionValue = visualElement.getValue(key);\n                if (motionValue)\n                    motionValue.liveStyle = true;\n                // @ts-expect-error - @mattgperry to figure if we should do something here\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n            });\n            animations.push({ animation: fallbackAnimation });\n        }\n        let shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            (props.initial === false || props.initial === props.animate) &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive) {\n        var _a;\n        // If the active state hasn\'t changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        const animations = animateChanges(type);\n        for (const key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        animateChanges,\n        setActive,\n        setAnimateFunction,\n        getState: () => state,\n        reset: () => {\n            state = createState();\n            isInitialRender = true;\n        },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === "string") {\n        return next !== prev;\n    }\n    else if (Array.isArray(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive = false) {\n    return {\n        isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    return {\n        animate: createTypeState(true),\n        whileInView: createTypeState(),\n        whileHover: createTypeState(),\n        whileTap: createTypeState(),\n        whileDrag: createTypeState(),\n        whileFocus: createTypeState(),\n        exit: createTypeState(),\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/Feature.mjs\nclass Feature {\n    constructor(node) {\n        this.isMounted = false;\n        this.node = node;\n    }\n    update() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/animation/index.mjs\n\n\n\n\nclass AnimationFeature extends Feature {\n    /**\n     * We dynamically generate the AnimationState manager as it contains a reference\n     * to the underlying animation library. We only want to load that if we load this,\n     * so people can optionally code split it out using the `m` component.\n     */\n    constructor(node) {\n        super(node);\n        node.animationState || (node.animationState = createAnimationState(node));\n    }\n    updateAnimationControlsSubscription() {\n        const { animate } = this.node.getProps();\n        if (isAnimationControls(animate)) {\n            this.unmountControls = animate.subscribe(this.node);\n        }\n    }\n    /**\n     * Subscribe any provided AnimationControls to the component\'s VisualElement\n     */\n    mount() {\n        this.updateAnimationControlsSubscription();\n    }\n    update() {\n        const { animate } = this.node.getProps();\n        const { animate: prevAnimate } = this.node.prevProps || {};\n        if (animate !== prevAnimate) {\n            this.updateAnimationControlsSubscription();\n        }\n    }\n    unmount() {\n        var _a;\n        this.node.animationState.reset();\n        (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs\n\n\nlet id = 0;\nclass ExitAnimationFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.id = id++;\n    }\n    update() {\n        if (!this.node.presenceContext)\n            return;\n        const { isPresent, onExitComplete } = this.node.presenceContext;\n        const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};\n        if (!this.node.animationState || isPresent === prevIsPresent) {\n            return;\n        }\n        const exitAnimation = this.node.animationState.setActive("exit", !isPresent);\n        if (onExitComplete && !isPresent) {\n            exitAnimation.then(() => onExitComplete(this.id));\n        }\n    }\n    mount() {\n        const { register } = this.node.presenceContext || {};\n        if (register) {\n            this.unmount = register(this.id);\n        }\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/animations.mjs\n\n\n\nconst animations = {\n    animation: {\n        Feature: AnimationFeature,\n    },\n    exit: {\n        Feature: ExitAnimationFeature,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/events/add-dom-event.mjs\nfunction addDomEvent(target, eventName, handler, options = { passive: true }) {\n    target.addEventListener(eventName, handler, options);\n    return () => target.removeEventListener(eventName, handler);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/events/event-info.mjs\n\n\nfunction extractEventInfo(event) {\n    return {\n        point: {\n            x: event.pageX,\n            y: event.pageY,\n        },\n    };\n}\nconst addPointerInfo = (handler) => {\n    return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/events/add-pointer-event.mjs\n\n\n\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, eventName, addPointerInfo(handler), options);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/distance.mjs\nconst distance = (a, b) => Math.abs(a - b);\nfunction distance2D(a, b) {\n    // Multi-dimensional\n    const xDelta = distance(a.x, b.x);\n    const yDelta = distance(a.y, b.y);\n    return Math.sqrt(xDelta ** 2 + yDelta ** 2);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false, } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        /**\n         * @internal\n         */\n        this.contextWindow = window;\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we\'ll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance2D(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = frameData;\n            this.history.push({ ...point, timestamp });\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Throttle mouse move event to once per frame\n            frame_frame.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;\n            if (this.dragSnapToOrigin)\n                resumeAnimation && resumeAnimation();\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const panInfo = getPanInfo(event.type === "pointercancel"\n                ? this.lastMoveEventInfo\n                : transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don\'t start detecting this gesture\n        if (!isPrimaryPointer(event))\n            return;\n        this.dragSnapToOrigin = dragSnapToOrigin;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        this.contextWindow = contextWindow || window;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = frameData;\n        this.history = [{ ...point, timestamp }];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelFrame(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            time_conversion_secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n    return (ref &&\n        typeof ref === "object" &&\n        Object.prototype.hasOwnProperty.call(ref, "current"));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\n\n\nconst SCALE_PRECISION = 0.0001;\nconst SCALE_MIN = 1 - SCALE_PRECISION;\nconst SCALE_MAX = 1 + SCALE_PRECISION;\nconst TRANSLATE_PRECISION = 0.01;\nconst TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;\nconst TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    return Math.abs(value - target) <= maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin = 0.5) {\n    delta.origin = origin;\n    delta.originPoint = mixNumber(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    delta.translate =\n        mixNumber(target.min, target.max, delta.origin) - delta.originPoint;\n    if ((delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX) ||\n        isNaN(delta.scale)) {\n        delta.scale = 1.0;\n    }\n    if ((delta.translate >= TRANSLATE_MIN &&\n        delta.translate <= TRANSLATE_MAX) ||\n        isNaN(delta.translate)) {\n        delta.translate = 0.0;\n    }\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);\n    calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\n\n\n\n\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(min, point, elastic.min)\n            : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic\n            ? mixNumber(max, point, elastic.max)\n            : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, "left", "right"),\n        y: resolveAxisElastic(dragElastic, "top", "bottom"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    return typeof dragElastic === "number"\n        ? dragElastic\n        : dragElastic[label] || 0;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nconst createAxisDelta = () => ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n});\nconst createDelta = () => ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n});\nconst createAxis = () => ({ min: 0, max: 0 });\nconst createBox = () => ({\n    x: createAxis(),\n    y: createAxis(),\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n    return [callback("x"), callback("y")];\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it\'s easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox({ top, left, right, bottom, }) {\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox({ x, y }) {\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    const topLeft = transformPoint({ x: point.left, y: point.top });\n    const bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale({ scale, scaleX, scaleY }) {\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        has2DTranslate(values) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY ||\n        values.skewX ||\n        values.skewY);\n}\nfunction has2DTranslate(values) {\n    return is2DTranslate(values.x) || is2DTranslate(values.y);\n}\nfunction is2DTranslate(value) {\n    return value && value !== "0%";\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\n\n\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const { visualElement } = node.options;\n        if (visualElement &&\n            visualElement.props.style &&\n            visualElement.props.style.display === "contents") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor\'s scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor\'s calculated delta into this component\'s recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it\'s within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\n        treeScale.x = 1.0;\n    }\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\n        treeScale.y = 1.0;\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/utils/measure.mjs\n\n\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    const viewportBox = measureViewportBox(element, transformPagePoint);\n    const { scroll } = rootProjectionNode;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.offset.x);\n        translateAxis(viewportBox.y, scroll.offset.y);\n    }\n    return viewportBox;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/get-context-window.mjs\n// Fixes https://github.com/motiondivision/motion/issues/2270\nconst getContextWindow = ({ current }) => {\n    return current ? current.ownerDocument.defaultView : null;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: PointerEvent\nclass VisualElementDragControls {\n    constructor(visualElement) {\n        this.openDragLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    start(originEvent, { snapToCursor = false } = {}) {\n        /**\n         * Don\'t start dragging if this component is exiting\n         */\n        const { presenceContext } = this.visualElement;\n        if (presenceContext && presenceContext.isPresent === false)\n            return;\n        const onSessionStart = (event) => {\n            const { dragSnapToOrigin } = this.getProps();\n            // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();\n            if (snapToCursor) {\n                this.snapToCursor(extractEventInfo(event).point);\n            }\n        };\n        const onStart = (event, info) => {\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            const { drag, dragPropagation, onDragStart } = this.getProps();\n            if (drag && !dragPropagation) {\n                if (this.openDragLock)\n                    this.openDragLock();\n                this.openDragLock = setDragLock(drag);\n                // If we don \'t have the lock, don\'t start dragging\n                if (!this.openDragLock)\n                    return;\n            }\n            this.isDragging = true;\n            this.currentDirection = null;\n            this.resolveConstraints();\n            if (this.visualElement.projection) {\n                this.visualElement.projection.isAnimationBlocked = true;\n                this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis((axis) => {\n                let current = this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    const { projection } = this.visualElement;\n                    if (projection && projection.layout) {\n                        const measuredAxis = projection.layout.layoutBox[axis];\n                        if (measuredAxis) {\n                            const length = calcLength(measuredAxis);\n                            current = length * (parseFloat(current) / 100);\n                        }\n                    }\n                }\n                this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            if (onDragStart) {\n                frame_frame.postRender(() => onDragStart(event, info));\n            }\n            addValueToWillChange(this.visualElement, "transform");\n            const { animationState } = this.visualElement;\n            animationState && animationState.setActive("whileDrag", true);\n        };\n        const onMove = (event, info) => {\n            // latestPointerEvent = event\n            const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag, } = this.getProps();\n            // If we didn\'t successfully receive the gesture lock, early return.\n            if (!dragPropagation && !this.openDragLock)\n                return;\n            const { offset } = info;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && this.currentDirection === null) {\n                this.currentDirection = getCurrentDirection(offset);\n                // If we\'ve successfully set a direction, notify listener\n                if (this.currentDirection !== null) {\n                    onDirectionLock && onDirectionLock(this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            this.updateAxis("x", info.point, offset);\n            this.updateAxis("y", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don\'t fall out of sync.\n             */\n            this.visualElement.render();\n            /**\n             * This must fire after the render call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag && onDrag(event, info);\n        };\n        const onSessionEnd = (event, info) => this.stop(event, info);\n        const resumeAnimation = () => eachAxis((axis) => {\n            var _a;\n            return this.getAnimationState(axis) === "paused" &&\n                ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());\n        });\n        const { dragSnapToOrigin } = this.getProps();\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart,\n            onStart,\n            onMove,\n            onSessionEnd,\n            resumeAnimation,\n        }, {\n            transformPagePoint: this.visualElement.getTransformPagePoint(),\n            dragSnapToOrigin,\n            contextWindow: getContextWindow(this.visualElement),\n        });\n    }\n    stop(event, info) {\n        const isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        const { velocity } = info;\n        this.startAnimation(velocity);\n        const { onDragEnd } = this.getProps();\n        if (onDragEnd) {\n            frame_frame.postRender(() => onDragEnd(event, info));\n        }\n    }\n    cancel() {\n        this.isDragging = false;\n        const { projection, animationState } = this.visualElement;\n        if (projection) {\n            projection.isAnimationBlocked = false;\n        }\n        this.panSession && this.panSession.end();\n        this.panSession = undefined;\n        const { dragPropagation } = this.getProps();\n        if (!dragPropagation && this.openDragLock) {\n            this.openDragLock();\n            this.openDragLock = null;\n        }\n        animationState && animationState.setActive("whileDrag", false);\n    }\n    updateAxis(axis, _point, offset) {\n        const { drag } = this.getProps();\n        // If we\'re not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        const axisValue = this.getAxisMotionValue(axis);\n        let next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    }\n    resolveConstraints() {\n        var _a;\n        const { dragConstraints, dragElastic } = this.getProps();\n        const layout = this.visualElement.projection &&\n            !this.visualElement.projection.layout\n            ? this.visualElement.projection.measure(false)\n            : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;\n        const prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we\'re outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis((axis) => {\n                if (this.constraints !== false &&\n                    this.getAxisMotionValue(axis)) {\n                    this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);\n                }\n            });\n        }\n    }\n    resolveRefConstraints() {\n        const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        const constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component\'s `ref` prop.");\n        const { projection } = this.visualElement;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);\n        /**\n         * If there\'s an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    }\n    startAnimation(velocity) {\n        const { drag, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd, } = this.getProps();\n        const constraints = this.constraints || {};\n        const momentumAnimations = eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, this.currentDirection)) {\n                return;\n            }\n            let transition = (constraints && constraints[axis]) || {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There\'s still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            const bounceStiffness = dragElastic ? 200 : 1000000;\n            const bounceDamping = dragElastic ? 40 : 10000000;\n            const inertia = {\n                type: "inertia",\n                velocity: dragMomentum ? velocity[axis] : 0,\n                bounceStiffness,\n                bounceDamping,\n                timeConstant: 750,\n                restDelta: 1,\n                restSpeed: 10,\n                ...dragTransition,\n                ...transition,\n            };\n            // If we\'re not animating on an externally-provided `MotionValue` we can use the\n            // component\'s animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    }\n    startAxisValueAnimation(axis, transition) {\n        const axisValue = this.getAxisMotionValue(axis);\n        addValueToWillChange(this.visualElement, axis);\n        return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));\n    }\n    stopAnimation() {\n        eachAxis((axis) => this.getAxisMotionValue(axis).stop());\n    }\n    pauseAnimation() {\n        eachAxis((axis) => { var _a; return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause(); });\n    }\n    getAnimationState(axis) {\n        var _a;\n        return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;\n    }\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    getAxisMotionValue(axis) {\n        const dragKey = `_drag${axis.toUpperCase()}`;\n        const props = this.visualElement.getProps();\n        const externalMotionValue = props[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (props.initial\n                ? props.initial[axis]\n                : undefined) || 0);\n    }\n    snapToCursor(point) {\n        eachAxis((axis) => {\n            const { drag } = this.getProps();\n            // If we\'re not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, this.currentDirection))\n                return;\n            const { projection } = this.visualElement;\n            const axisValue = this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                const { min, max } = projection.layout.layoutBox[axis];\n                axisValue.set(point[axis] - mixNumber(min, max, 0.5));\n            }\n        });\n    }\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    scalePositionWithinConstraints() {\n        if (!this.visualElement.current)\n            return;\n        const { drag, dragConstraints } = this.getProps();\n        const { projection } = this.visualElement;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        const boxProgress = { x: 0, y: 0 };\n        eachAxis((axis) => {\n            const axisValue = this.getAxisMotionValue(axis);\n            if (axisValue && this.constraints !== false) {\n                const latest = axisValue.get();\n                boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        const { transformTemplate } = this.visualElement.getProps();\n        this.visualElement.current.style.transform = transformTemplate\n            ? transformTemplate({}, "")\n            : "none";\n        projection.root && projection.root.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis((axis) => {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            const axisValue = this.getAxisMotionValue(axis);\n            const { min, max } = this.constraints[axis];\n            axisValue.set(mixNumber(min, max, boxProgress[axis]));\n        });\n    }\n    addListeners() {\n        if (!this.visualElement.current)\n            return;\n        elementDragControls.set(this.visualElement, this);\n        const element = this.visualElement.current;\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {\n            const { drag, dragListener = true } = this.getProps();\n            drag && dragListener && this.start(event);\n        });\n        const measureDragConstraints = () => {\n            const { dragConstraints } = this.getProps();\n            if (isRefObject(dragConstraints) && dragConstraints.current) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        };\n        const { projection } = this.visualElement;\n        const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);\n        if (projection && !projection.layout) {\n            projection.root && projection.root.updateScroll();\n            projection.updateLayout();\n        }\n        frame_frame.read(measureDragConstraints);\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());\n        /**\n         * If the element\'s layout changes, calculate the delta and apply that to\n         * the drag gesture\'s origin point.\n         */\n        const stopLayoutUpdateListener = projection.addEventListener("didUpdate", (({ delta, hasLayoutChanged }) => {\n            if (this.isDragging && hasLayoutChanged) {\n                eachAxis((axis) => {\n                    const motionValue = this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                this.visualElement.render();\n            }\n        }));\n        return () => {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n            stopLayoutUpdateListener && stopLayoutUpdateListener();\n        };\n    }\n    getProps() {\n        const props = this.visualElement.getProps();\n        const { drag = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true, } = props;\n        return {\n            ...props,\n            drag,\n            dragDirectionLock,\n            dragPropagation,\n            dragConstraints,\n            dragElastic,\n            dragMomentum,\n        };\n    }\n}\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis\' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold = 10) {\n    let direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = "y";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = "x";\n    }\n    return direction;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/drag/index.mjs\n\n\n\n\nclass DragGesture extends Feature {\n    constructor(node) {\n        super(node);\n        this.removeGroupControls = noop_noop;\n        this.removeListeners = noop_noop;\n        this.controls = new VisualElementDragControls(node);\n    }\n    mount() {\n        // If we\'ve been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps();\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls);\n        }\n        this.removeListeners = this.controls.addListeners() || noop_noop;\n    }\n    unmount() {\n        this.removeGroupControls();\n        this.removeListeners();\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/pan/index.mjs\n\n\n\n\n\n\n\nconst asyncHandler = (handler) => (event, info) => {\n    if (handler) {\n        frame_frame.postRender(() => handler(event, info));\n    }\n};\nclass PanGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.removePointerDownListener = noop_noop;\n    }\n    onPointerDown(pointerDownEvent) {\n        this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {\n            transformPagePoint: this.node.getTransformPagePoint(),\n            contextWindow: getContextWindow(this.node),\n        });\n    }\n    createPanHandlers() {\n        const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();\n        return {\n            onSessionStart: asyncHandler(onPanSessionStart),\n            onStart: asyncHandler(onPanStart),\n            onMove: onPan,\n            onEnd: (event, info) => {\n                delete this.session;\n                if (onPanEnd) {\n                    frame_frame.postRender(() => onPanEnd(event, info));\n                }\n            },\n        };\n    }\n    mount() {\n        this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));\n    }\n    update() {\n        this.session && this.session.updateHandlers(this.createPanHandlers());\n    }\n    unmount() {\n        this.removePointerDownListener();\n        this.session && this.session.end();\n    }\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/react/jsx-runtime.js\nvar jsx_runtime = __webpack_require__(848);\n;// ./node_modules/framer-motion/dist/es/context/PresenceContext.mjs\n"use client";\n\n\n/**\n * @public\n */\nconst PresenceContext_PresenceContext = (0,react.createContext)(null);\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\n\n\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it\'s still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from "framer-motion"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won\'t really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence(subscribe = true) {\n    const context = (0,react.useContext)(PresenceContext_PresenceContext);\n    if (context === null)\n        return [true, null];\n    const { isPresent, onExitComplete, register } = context;\n    // It\'s safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    const id = (0,react.useId)();\n    (0,react.useEffect)(() => {\n        if (subscribe)\n            register(id);\n    }, [subscribe]);\n    const safeToRemove = (0,react.useCallback)(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from "framer-motion"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log("I\'ve been removed!")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent(useContext(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\n"use client";\n\n\nconst LayoutGroupContext = (0,react.createContext)({});\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\n"use client";\n\n\n/**\n * Internal, exported only for usage in Framer\n */\nconst SwitchLayoutGroupContext = (0,react.createContext)({});\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/state.mjs\n/**\n * This should only ever be modified on the client otherwise it\'ll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nconst globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\n\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we\'ll avoid a paint.\n */\nconst correctBorderRadius = {\n    correct: (latest, node) => {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it\'s a percentage we can return immediately as it\'s\n         * going to be stretched appropriately. Otherwise, if it\'s a pixel, convert it to a number.\n         */\n        if (typeof latest === "string") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it\'s a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        const x = pixelsToPercent(latest, node.target.x);\n        const y = pixelsToPercent(latest, node.target.y);\n        return `${x}% ${y}%`;\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\n\n\n\nconst correctBoxShadow = {\n    correct: (latest, { treeScale, projectionDelta }) => {\n        const original = latest;\n        const shadow = complex.parse(latest);\n        // TODO: Doesn\'t support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        const template = complex.createTransformer(latest);\n        const offset = typeof shadow[0] !== "number" ? 1 : 0;\n        // Calculate the overall context scale\n        const xScale = projectionDelta.x.scale * treeScale.x;\n        const yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we\'d correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        const averageScale = mixNumber(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === "number")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === "number")\n            shadow[3 + offset] /= averageScale;\n        return template(shadow);\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\n\n\nconst scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    for (const key in correctors) {\n        scaleCorrectors[key] = correctors[key];\n        if (isCSSVariableName(key)) {\n            scaleCorrectors[key].isCSSVariable = true;\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/frameloop/microtask.mjs\n\n\nconst { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\n"use client";\n\n\n\n\n\n\n\n\n\n\n\n\nclass MeasureLayoutWithContext extends react.Component {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\n        const { projection } = visualElement;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener("animationComplete", () => {\n                this.safeToRemove();\n            });\n            projection.setOptions({\n                ...projection.options,\n                onExitComplete: () => this.safeToRemove(),\n            });\n        }\n        globalProjectionState.hasEverUpdated = true;\n    }\n    getSnapshotBeforeUpdate(prevProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\n        const projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There\'s no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there\'s another stack member taking over from this one,\n                 * it\'s in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame_frame.postRender(() => {\n                    const stack = projection.getStack();\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    }\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement;\n        if (projection) {\n            projection.root.didUpdate();\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove();\n                }\n            });\n        }\n    }\n    componentWillUnmount() {\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\n        const { projection } = visualElement;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    }\n    safeToRemove() {\n        const { safeToRemove } = this.props;\n        safeToRemove && safeToRemove();\n    }\n    render() {\n        return null;\n    }\n}\nfunction MeasureLayout(props) {\n    const [isPresent, safeToRemove] = usePresence();\n    const layoutGroup = (0,react.useContext)(LayoutGroupContext);\n    return ((0,jsx_runtime.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup: layoutGroup, switchLayoutGroup: (0,react.useContext)(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove }));\n}\nconst defaultScaleCorrectors = {\n    borderRadius: {\n        ...correctBorderRadius,\n        applyTo: [\n            "borderTopLeftRadius",\n            "borderTopRightRadius",\n            "borderBottomLeftRadius",\n            "borderBottomRightRadius",\n        ],\n    },\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/animation/animate/single-value.mjs\n\n\n\n\nfunction animateSingleValue(value, keyframes, options) {\n    const motionValue$1 = isMotionValue(value) ? value : motionValue(value);\n    motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));\n    return motionValue$1.animation;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-element.mjs\nfunction isSVGElement(element) {\n    return element instanceof SVGElement && element.tagName !== "svg";\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nconst compareByDepth = (a, b) => a.depth - b.depth;\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\n\n\n\nclass FlatTree {\n    constructor() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    add(child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    }\n    remove(child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    }\n    forEach(callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/delay.mjs\n\n\n\n\n/**\n * Timeout defined in ms\n */\nfunction delay(callback, timeout) {\n    const start = time.now();\n    const checkElapsed = ({ timestamp }) => {\n        const elapsed = timestamp - start;\n        if (elapsed >= timeout) {\n            cancelFrame(checkElapsed);\n            callback(elapsed - timeout);\n        }\n    };\n    frame_frame.read(checkElapsed, true);\n    return () => cancelFrame(checkElapsed);\n}\nfunction delayInSeconds(callback, timeout) {\n    return delay(callback, secondsToMilliseconds(timeout));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\n\n\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    const unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\n\n\n\n\n\nconst borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === "number" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, \n        // TODO Reinstate this if only child\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += "%";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there\'s a follow element\n//  * that we\'re not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn\'t ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop_noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n/**\n * Reset a delta to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisDeltaInto(delta, originDelta) {\n    delta.translate = originDelta.translate;\n    delta.scale = originDelta.scale;\n    delta.originPoint = originDelta.originPoint;\n    delta.origin = originDelta.origin;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\n\n\n\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== "number")\n        return;\n    let originPoint = mixNumber(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = ["x", "scaleX", "originX"];\nconst yKeys = ["y", "scaleY", "originY"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);\n    removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\n\n\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction axisEquals(a, b) {\n    return a.min === b.min && a.max === b.max;\n}\nfunction boxEquals(a, b) {\n    return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);\n}\nfunction axisEqualsRounded(a, b) {\n    return (Math.round(a.min) === Math.round(b.min) &&\n        Math.round(a.max) === Math.round(b.max));\n}\nfunction boxEqualsRounded(a, b) {\n    return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);\n}\nfunction aspectRatio(box) {\n    return calcLength(box.x) / calcLength(box.y);\n}\nfunction axisDeltaEquals(a, b) {\n    return (a.translate === b.translate &&\n        a.scale === b.scale &&\n        a.originPoint === b.originPoint);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/shared/stack.mjs\n\n\nclass NodeStack {\n    constructor() {\n        this.members = [];\n    }\n    add(node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    }\n    remove(node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            const prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    }\n    relegate(node) {\n        const indexOfNode = this.members.findIndex((member) => node === member);\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        let prevLead;\n        for (let i = indexOfNode; i >= 0; i--) {\n            const member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    promote(node, preserveFollowOpacity) {\n        const prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n            }\n            if (node.root && node.root.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            const { crossfade } = node.options;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    }\n    exitAnimationComplete() {\n        this.members.forEach((node) => {\n            const { options, resumingFrom } = node;\n            options.onExitComplete && options.onExitComplete();\n            if (resumingFrom) {\n                resumingFrom.options.onExitComplete &&\n                    resumingFrom.options.onExitComplete();\n            }\n        });\n    }\n    scheduleRender() {\n        this.members.forEach((node) => {\n            node.instance && node.scheduleRender(false);\n        });\n    }\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    removeLeadSnapshot() {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = "";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || "none";\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst metrics = {\n    type: "projectionFrame",\n    totalNodes: 0,\n    resolvedTargetDeltas: 0,\n    recalculatedProjection: 0,\n};\nconst isDebug = typeof window !== "undefined" && window.MotionDebug !== undefined;\nconst transformAxes = ["", "X", "Y", "Z"];\nconst hiddenVisibility = { visibility: "hidden" };\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nconst animationTarget = 1000;\nlet create_projection_node_id = 0;\nfunction resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {\n    const { latestValues } = visualElement;\n    // Record the distorting transform and then temporarily set it to 0\n    if (latestValues[key]) {\n        values[key] = latestValues[key];\n        visualElement.setStaticValue(key, 0);\n        if (sharedAnimationValues) {\n            sharedAnimationValues[key] = 0;\n        }\n    }\n}\nfunction cancelTreeOptimisedTransformAnimations(projectionNode) {\n    projectionNode.hasCheckedOptimisedAppear = true;\n    if (projectionNode.root === projectionNode)\n        return;\n    const { visualElement } = projectionNode.options;\n    if (!visualElement)\n        return;\n    const appearId = getOptimisedAppearId(visualElement);\n    if (window.MotionHasOptimisedAnimation(appearId, "transform")) {\n        const { layout, layoutId } = projectionNode.options;\n        window.MotionCancelOptimisedAnimation(appearId, "transform", frame_frame, !(layout || layoutId));\n    }\n    const { parent } = projectionNode;\n    if (parent && !parent.hasCheckedOptimisedAppear) {\n        cancelTreeOptimisedTransformAnimations(parent);\n    }\n}\nfunction createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform, }) {\n    return class ProjectionNode {\n        constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {\n            /**\n             * A unique ID generated for every projection node.\n             */\n            this.id = create_projection_node_id++;\n            /**\n             * An id that represents a unique session instigated by startUpdate.\n             */\n            this.animationId = 0;\n            /**\n             * A Set containing all this component\'s children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can\'t always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Flag to true if we think the projection calculations for this node needs\n             * recalculating as a result of an updated transform or layout animation.\n             */\n            this.isProjectionDirty = false;\n            /**\n             * Flag to true if the layout *or* transform has changed. This then gets propagated\n             * throughout the projection tree, forcing any element below to recalculate on the next frame.\n             */\n            this.isSharedProjectionDirty = false;\n            /**\n             * Flag transform dirty. This gets propagated throughout the whole tree but is only\n             * respected by shared nodes.\n             */\n            this.isTransformDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * Store whether this node has been checked for optimised appear animations. As\n             * effects fire bottom-up, and we want to look up the tree for appear animations,\n             * this makes sure we only check each path once, stopping at nodes that\n             * have already been checked.\n             */\n            this.hasCheckedOptimisedAppear = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to layoutly\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            this.hasTreeAnimated = false;\n            // Note: Currently only running on root node\n            this.updateScheduled = false;\n            this.scheduleUpdate = () => this.update();\n            this.projectionUpdateScheduled = false;\n            this.checkUpdateFailed = () => {\n                if (this.isUpdating) {\n                    this.isUpdating = false;\n                    this.clearAllSnapshots();\n                }\n            };\n            /**\n             * This is a multi-step process as shared nodes might be of different depths. Nodes\n             * are sorted by depth order, so we need to resolve the entire tree before moving to\n             * the next step.\n             */\n            this.updateProjection = () => {\n                this.projectionUpdateScheduled = false;\n                /**\n                 * Reset debug counts. Manually resetting rather than creating a new\n                 * object each frame.\n                 */\n                if (isDebug) {\n                    metrics.totalNodes =\n                        metrics.resolvedTargetDeltas =\n                            metrics.recalculatedProjection =\n                                0;\n                }\n                this.nodes.forEach(propagateDirtyNodes);\n                this.nodes.forEach(resolveTargetDelta);\n                this.nodes.forEach(calcProjection);\n                this.nodes.forEach(cleanDirtyNodes);\n                if (isDebug) {\n                    window.MotionDebug.record(metrics);\n                }\n            };\n            /**\n             * Frame calculations\n             */\n            this.resolvedRelativeTargetAt = 0.0;\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? [...parent.path, parent] : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            for (let i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        addEventListener(name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        }\n        notifyListeners(name, ...args) {\n            const subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager && subscriptionManager.notify(...args);\n        }\n        hasListeners(name) {\n            return this.eventHandlers.has(name);\n        }\n        /**\n         * Lifecycles\n         */\n        mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {\n            if (this.instance)\n                return;\n            this.isSVG = isSVGElement(instance);\n            this.instance = instance;\n            const { layoutId, layout, visualElement } = this.options;\n            if (visualElement && !visualElement.current) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            this.parent && this.parent.children.add(this);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                let cancelDelay;\n                const resizeUnblockUpdate = () => (this.root.updateBlockedByResize = false);\n                attachResizeListener(instance, () => {\n                    this.root.updateBlockedByResize = true;\n                    cancelDelay && cancelDelay();\n                    cancelDelay = delay(resizeUnblockUpdate, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout, }) => {\n                    if (this.isTreeAnimationBlocked()) {\n                        this.target = undefined;\n                        this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    const layoutTransition = this.options.transition ||\n                        visualElement.getDefaultTransition() ||\n                        defaultLayoutTransition;\n                    const { onLayoutAnimationStart, onLayoutAnimationComplete, } = visualElement.getProps();\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    const hasTargetChanged = !this.targetLayout ||\n                        !boxEqualsRounded(this.targetLayout, newLayout);\n                    /*\n                     * Note: Disabled to fix relative animations always triggering new\n                     * layout animations. If this causes further issues, we can try\n                     * a different approach to detecting relative target changes.\n                     */\n                    // || hasRelativeLayoutChanged\n                    /**\n                     * If the layout hasn\'t seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;\n                    if (this.options.layoutRoot ||\n                        this.resumeFrom ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (hasTargetChanged || !this.currentAnimation))) {\n                        if (this.resumeFrom) {\n                            this.resumingFrom = this.resumeFrom;\n                            this.resumingFrom.resumingFrom = undefined;\n                        }\n                        this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        const animationOptions = {\n                            ...get_value_transition_getValueTransition(layoutTransition, "layout"),\n                            onPlay: onLayoutAnimationStart,\n                            onComplete: onLayoutAnimationComplete,\n                        };\n                        if (visualElement.shouldReduceMotion ||\n                            this.options.layoutRoot) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn\'t changed and we have an animation that hasn\'t started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged) {\n                            finishAnimation(this);\n                        }\n                        if (this.isLead() && this.options.onExitComplete) {\n                            this.options.onExitComplete();\n                        }\n                    }\n                    this.targetLayout = newLayout;\n                });\n            }\n        }\n        unmount() {\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            const stack = this.getStack();\n            stack && stack.remove(this);\n            this.parent && this.parent.children.delete(this);\n            this.instance = undefined;\n            cancelFrame(this.updateProjection);\n        }\n        // only on the root\n        blockUpdate() {\n            this.updateManuallyBlocked = true;\n        }\n        unblockUpdate() {\n            this.updateManuallyBlocked = false;\n        }\n        isUpdateBlocked() {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        }\n        isTreeAnimationBlocked() {\n            return (this.isAnimationBlocked ||\n                (this.parent && this.parent.isTreeAnimationBlocked()) ||\n                false);\n        }\n        // Note: currently only running on root node\n        startUpdate() {\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            this.nodes && this.nodes.forEach(resetSkewAndRotation);\n            this.animationId++;\n        }\n        getTransformTemplate() {\n            const { visualElement } = this.options;\n            return visualElement && visualElement.getProps().transformTemplate;\n        }\n        willUpdate(shouldNotifyListeners = true) {\n            this.root.hasTreeAnimated = true;\n            if (this.root.isUpdateBlocked()) {\n                this.options.onExitComplete && this.options.onExitComplete();\n                return;\n            }\n            /**\n             * If we\'re running optimised appear animations then these must be\n             * cancelled before measuring the DOM. This is so we can measure\n             * the true layout of the element rather than the WAAPI animation\n             * which will be unaffected by the resetSkewAndRotate step.\n             *\n             * Note: This is a DOM write. Worst case scenario is this is sandwiched\n             * between other snapshot reads which will cause unnecessary style recalculations.\n             * This has to happen here though, as we don\'t yet know which nodes will need\n             * snapshots in startUpdate(), but we only want to cancel optimised animations\n             * if a layout animation measurement is actually going to be affected by them.\n             */\n            if (window.MotionCancelOptimisedAnimation &&\n                !this.hasCheckedOptimisedAppear) {\n                cancelTreeOptimisedTransformAnimations(this);\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                node.shouldResetTransform = true;\n                node.updateScroll("snapshot");\n                if (node.options.layoutRoot) {\n                    node.willUpdate(false);\n                }\n            }\n            const { layoutId, layout } = this.options;\n            if (layoutId === undefined && !layout)\n                return;\n            const transformTemplate = this.getTransformTemplate();\n            this.prevTransformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, "")\n                : undefined;\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners("willUpdate");\n        }\n        update() {\n            this.updateScheduled = false;\n            const updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating) {\n                this.nodes.forEach(clearIsLayoutDirty);\n            }\n            this.isUpdating = false;\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            /**\n             * Manually flush any pending updates. Ideally\n             * we could leave this to the following requestAnimationFrame but this seems\n             * to leave a flash of incorrectly styled content.\n             */\n            const now = time.now();\n            frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);\n            frameData.timestamp = now;\n            frameData.isProcessing = true;\n            frameSteps.update.process(frameData);\n            frameSteps.preRender.process(frameData);\n            frameSteps.render.process(frameData);\n            frameData.isProcessing = false;\n        }\n        didUpdate() {\n            if (!this.updateScheduled) {\n                this.updateScheduled = true;\n                microtask.read(this.scheduleUpdate);\n            }\n        }\n        clearAllSnapshots() {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        }\n        scheduleUpdateProjection() {\n            if (!this.projectionUpdateScheduled) {\n                this.projectionUpdateScheduled = true;\n                frame_frame.preRender(this.updateProjection, false, true);\n            }\n        }\n        scheduleCheckAfterUnmount() {\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            frame_frame.postRender(() => {\n                if (this.isLayoutDirty) {\n                    this.root.didUpdate();\n                }\n                else {\n                    this.root.checkUpdateFailed();\n                }\n            });\n        }\n        /**\n         * Update measurements\n         */\n        updateSnapshot() {\n            if (this.snapshot || !this.instance)\n                return;\n            this.snapshot = this.measure();\n            if (this.snapshot &&\n                !calcLength(this.snapshot.measuredBox.x) &&\n                !calcLength(this.snapshot.measuredBox.y)) {\n                this.snapshot = undefined;\n            }\n        }\n        updateLayout() {\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead\'s\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (let i = 0; i < this.path.length; i++) {\n                    const node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            const prevLayout = this.layout;\n            this.layout = this.measure(false);\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners("measure", this.layout.layoutBox);\n            const { visualElement } = this.options;\n            visualElement &&\n                visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);\n        }\n        updateScroll(phase = "measure") {\n            let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);\n            if (this.scroll &&\n                this.scroll.animationId === this.root.animationId &&\n                this.scroll.phase === phase) {\n                needsMeasurement = false;\n            }\n            if (needsMeasurement) {\n                const isRoot = checkIsScrollRoot(this.instance);\n                this.scroll = {\n                    animationId: this.root.animationId,\n                    phase,\n                    isRoot,\n                    offset: measureScroll(this.instance),\n                    wasRoot: this.scroll ? this.scroll.isRoot : isRoot,\n                };\n            }\n        }\n        resetTransform() {\n            if (!resetTransform)\n                return;\n            const isResetRequested = this.isLayoutDirty ||\n                this.shouldResetTransform ||\n                this.options.alwaysMeasureLayout;\n            const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            const transformTemplate = this.getTransformTemplate();\n            const transformTemplateValue = transformTemplate\n                ? transformTemplate(this.latestValues, "")\n                : undefined;\n            const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        }\n        measure(removeTransform = true) {\n            const pageBox = this.measurePageBox();\n            let layoutBox = this.removeElementScroll(pageBox);\n            /**\n             * Measurements taken during the pre-render stage\n             * still have transforms applied so we remove them\n             * via calculation.\n             */\n            if (removeTransform) {\n                layoutBox = this.removeTransform(layoutBox);\n            }\n            roundBox(layoutBox);\n            return {\n                animationId: this.root.animationId,\n                measuredBox: pageBox,\n                layoutBox,\n                latestValues: {},\n                source: this.id,\n            };\n        }\n        measurePageBox() {\n            var _a;\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return createBox();\n            const box = visualElement.measureViewportBox();\n            const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);\n            if (!wasInScrollRoot) {\n                // Remove viewport scroll to give page-relative coordinates\n                const { scroll } = this.root;\n                if (scroll) {\n                    translateAxis(box.x, scroll.offset.x);\n                    translateAxis(box.y, scroll.offset.y);\n                }\n            }\n            return box;\n        }\n        removeElementScroll(box) {\n            var _a;\n            const boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {\n                return boxWithoutScroll;\n            }\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                const { scroll, options } = node;\n                if (node !== this.root && scroll && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (scroll.wasRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll.offset.x);\n                    translateAxis(boxWithoutScroll.y, scroll.offset.y);\n                }\n            }\n            return boxWithoutScroll;\n        }\n        applyTransform(box, transformOnly = false) {\n            const withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.offset.x,\n                        y: -node.scroll.offset.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        }\n        removeTransform(box) {\n            const boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (let i = 0; i < this.path.length; i++) {\n                const node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                const sourceBox = createBox();\n                const nodeBox = node.measurePageBox();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        }\n        setTargetDelta(delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n            this.isProjectionDirty = true;\n        }\n        setOptions(options) {\n            this.options = {\n                ...this.options,\n                ...options,\n                crossfade: options.crossfade !== undefined ? options.crossfade : true,\n            };\n        }\n        clearMeasurements() {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        }\n        forceRelativeParentToResolveTarget() {\n            if (!this.relativeParent)\n                return;\n            /**\n             * If the parent target isn\'t up-to-date, force it to update.\n             * This is an unfortunate de-optimisation as it means any updating relative\n             * projection will cause all the relative parents to recalculate back\n             * up the tree.\n             */\n            if (this.relativeParent.resolvedRelativeTargetAt !==\n                frameData.timestamp) {\n                this.relativeParent.resolveTargetDelta(true);\n            }\n        }\n        resolveTargetDelta(forceRecalculation = false) {\n            var _a;\n            /**\n             * Once the dirty status of nodes has been spread through the tree, we also\n             * need to check if we have a shared node of a different depth that has itself\n             * been dirtied.\n             */\n            const lead = this.getLead();\n            this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);\n            this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);\n            this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            /**\n             * We don\'t use transform for this step of processing so we don\'t\n             * need to check whether any nodes have changed transform.\n             */\n            const canSkip = !(forceRecalculation ||\n                (isShared && this.isSharedProjectionDirty) ||\n                this.isProjectionDirty ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) ||\n                this.attemptToResolveRelativeTarget ||\n                this.root.updateBlockedByResize);\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If we have no layout, we can\'t perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            this.resolvedRelativeTargetAt = frameData.timestamp;\n            /**\n             * If we don\'t have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            if (!this.targetDelta && !this.relativeTarget) {\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    relativeParent.layout &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn\'t valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we\'ve got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                this.relativeParent &&\n                this.relativeParent.target) {\n                this.forceRelativeParentToResolveTarget();\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we\'ve only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.layoutBox);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.layoutBox);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.layoutBox);\n            }\n            /**\n             * If we\'ve been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                const relativeParent = this.getClosestProjectingParent();\n                if (relativeParent &&\n                    Boolean(relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !relativeParent.options.layoutScroll &&\n                    relativeParent.target &&\n                    this.animationProgress !== 1) {\n                    this.relativeParent = relativeParent;\n                    this.forceRelativeParentToResolveTarget();\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n                else {\n                    this.relativeParent = this.relativeTarget = undefined;\n                }\n            }\n            /**\n             * Increase debug counter for resolved target deltas\n             */\n            if (isDebug) {\n                metrics.resolvedTargetDeltas++;\n            }\n        }\n        getClosestProjectingParent() {\n            if (!this.parent ||\n                hasScale(this.parent.latestValues) ||\n                has2DTranslate(this.parent.latestValues)) {\n                return undefined;\n            }\n            if (this.parent.isProjecting()) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        }\n        isProjecting() {\n            return Boolean((this.relativeTarget ||\n                this.targetDelta ||\n                this.options.layoutRoot) &&\n                this.layout);\n        }\n        calcProjection() {\n            var _a;\n            const lead = this.getLead();\n            const isShared = Boolean(this.resumingFrom) || this !== lead;\n            let canSkip = true;\n            /**\n             * If this is a normal layout animation and neither this node nor its nearest projecting\n             * is dirty then we can\'t skip.\n             */\n            if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If this is a shared layout animation and this node\'s shared projection is dirty then\n             * we can\'t skip.\n             */\n            if (isShared &&\n                (this.isSharedProjectionDirty || this.isTransformDirty)) {\n                canSkip = false;\n            }\n            /**\n             * If we have resolved the target this frame we must recalculate the\n             * projection to ensure it visually represents the internal calculations.\n             */\n            if (this.resolvedRelativeTargetAt === frameData.timestamp) {\n                canSkip = false;\n            }\n            if (canSkip)\n                return;\n            const { layout, layoutId } = this.options;\n            /**\n             * If this section of the tree isn\'t animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean((this.parent && this.parent.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * Reset the corrected box with the latest values from box, as we\'re then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.layoutBox);\n            /**\n             * Record previous tree scales before updating.\n             */\n            const prevTreeScaleX = this.treeScale.x;\n            const prevTreeScaleY = this.treeScale.y;\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);\n            /**\n             * If this layer needs to perform scale correction but doesn\'t have a target,\n             * use the layout as the target.\n             */\n            if (lead.layout &&\n                !lead.target &&\n                (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {\n                lead.target = lead.layout.layoutBox;\n                lead.targetWithTransforms = createBox();\n            }\n            const { target } = lead;\n            if (!target) {\n                /**\n                 * If we don\'t have a target to project into, but we were previously\n                 * projecting, we want to remove the stored transform and schedule\n                 * a render to ensure the elements reflect the removed transform.\n                 */\n                if (this.prevProjectionDelta) {\n                    this.createProjectionDeltas();\n                    this.scheduleRender();\n                }\n                return;\n            }\n            if (!this.projectionDelta || !this.prevProjectionDelta) {\n                this.createProjectionDeltas();\n            }\n            else {\n                copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);\n                copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);\n            }\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn\'t have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            if (this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY ||\n                !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) ||\n                !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners("projectionUpdate", target);\n            }\n            /**\n             * Increase debug counter for recalculated projections\n             */\n            if (isDebug) {\n                metrics.recalculatedProjection++;\n            }\n        }\n        hide() {\n            this.isVisible = false;\n            // TODO: Schedule render\n        }\n        show() {\n            this.isVisible = true;\n            // TODO: Schedule render\n        }\n        scheduleRender(notifyAll = true) {\n            var _a;\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();\n            if (notifyAll) {\n                const stack = this.getStack();\n                stack && stack.scheduleRender();\n            }\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        }\n        createProjectionDeltas() {\n            this.prevProjectionDelta = createDelta();\n            this.projectionDelta = createDelta();\n            this.projectionDeltaWithTransform = createDelta();\n        }\n        setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {\n            const snapshot = this.snapshot;\n            const snapshotLatestValues = snapshot\n                ? snapshot.latestValues\n                : {};\n            const mixedValues = { ...this.latestValues };\n            const targetDelta = createDelta();\n            if (!this.relativeParent ||\n                !this.relativeParent.options.layoutRoot) {\n                this.relativeTarget = this.relativeTargetOrigin = undefined;\n            }\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            const relativeLayout = createBox();\n            const snapshotSource = snapshot ? snapshot.source : undefined;\n            const layoutSource = this.layout ? this.layout.source : undefined;\n            const isSharedLayoutAnimation = snapshotSource !== layoutSource;\n            const stack = this.getStack();\n            const isOnlyMember = !stack || stack.members.length <= 1;\n            const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            let prevRelativeTarget;\n            this.mixTargetDelta = (latest) => {\n                const progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                this.setTargetDelta(targetDelta);\n                if (this.relativeTarget &&\n                    this.relativeTargetOrigin &&\n                    this.layout &&\n                    this.relativeParent &&\n                    this.relativeParent.layout) {\n                    calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);\n                    mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);\n                    /**\n                     * If this is an unchanged relative target we can consider the\n                     * projection not dirty.\n                     */\n                    if (prevRelativeTarget &&\n                        boxEquals(this.relativeTarget, prevRelativeTarget)) {\n                        this.isProjectionDirty = false;\n                    }\n                    if (!prevRelativeTarget)\n                        prevRelativeTarget = createBox();\n                    copyBoxInto(prevRelativeTarget, this.relativeTarget);\n                }\n                if (isSharedLayoutAnimation) {\n                    this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                this.root.scheduleUpdateProjection();\n                this.scheduleRender();\n                this.animationProgress = progress;\n            };\n            this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);\n        }\n        startAnimation(options) {\n            this.notifyListeners("animationStart");\n            this.currentAnimation && this.currentAnimation.stop();\n            if (this.resumingFrom && this.resumingFrom.currentAnimation) {\n                this.resumingFrom.currentAnimation.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelFrame(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = frame_frame.update(() => {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                this.currentAnimation = animateSingleValue(0, animationTarget, {\n                    ...options,\n                    onUpdate: (latest) => {\n                        this.mixTargetDelta(latest);\n                        options.onUpdate && options.onUpdate(latest);\n                    },\n                    onComplete: () => {\n                        options.onComplete && options.onComplete();\n                        this.completeAnimation();\n                    },\n                });\n                if (this.resumingFrom) {\n                    this.resumingFrom.currentAnimation = this.currentAnimation;\n                }\n                this.pendingAnimation = undefined;\n            });\n        }\n        completeAnimation() {\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            const stack = this.getStack();\n            stack && stack.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners("animationComplete");\n        }\n        finishAnimation() {\n            if (this.currentAnimation) {\n                this.mixTargetDelta && this.mixTargetDelta(animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        }\n        applyTransformsToTarget() {\n            const lead = this.getLead();\n            let { targetWithTransforms, target, layout, latestValues } = lead;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            /**\n             * If we\'re only animating position, and this element isn\'t the lead element,\n             * then instead of projecting into the lead box we instead want to calculate\n             * a new target that aligns the two boxes but maintains the layout shape.\n             */\n            if (this !== lead &&\n                this.layout &&\n                layout &&\n                shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {\n                target = this.target || createBox();\n                const xLength = calcLength(this.layout.layoutBox.x);\n                target.x.min = lead.target.x.min;\n                target.x.max = target.x.min + xLength;\n                const yLength = calcLength(this.layout.layoutBox.y);\n                target.y.min = lead.target.y.min;\n                target.y.max = target.y.min + yLength;\n            }\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its layout layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        }\n        registerSharedNode(layoutId, node) {\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            const stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            const config = node.options.initialPromotionConfig;\n            node.promote({\n                transition: config ? config.transition : undefined,\n                preserveFollowOpacity: config && config.shouldPreserveFollowOpacity\n                    ? config.shouldPreserveFollowOpacity(node)\n                    : undefined,\n            });\n        }\n        isLead() {\n            const stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        }\n        getLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        }\n        getPrevLead() {\n            var _a;\n            const { layoutId } = this.options;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        }\n        getStack() {\n            const { layoutId } = this.options;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        }\n        promote({ needsReset, transition, preserveFollowOpacity, } = {}) {\n            const stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition });\n        }\n        relegate() {\n            const stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        }\n        resetSkewAndRotation() {\n            const { visualElement } = this.options;\n            if (!visualElement)\n                return;\n            // If there\'s no detected skew or rotation values, we can early return without a forced render.\n            let hasDistortingTransform = false;\n            /**\n             * An unrolled check for rotation values. Most elements don\'t have any rotation and\n             * skipping the nested loop and new object creation is 50% faster.\n             */\n            const { latestValues } = visualElement;\n            if (latestValues.z ||\n                latestValues.rotate ||\n                latestValues.rotateX ||\n                latestValues.rotateY ||\n                latestValues.rotateZ ||\n                latestValues.skewX ||\n                latestValues.skewY) {\n                hasDistortingTransform = true;\n            }\n            // If there\'s no distorting values, we don\'t need to do any more.\n            if (!hasDistortingTransform)\n                return;\n            const resetValues = {};\n            if (latestValues.z) {\n                resetDistortingTransform("z", visualElement, resetValues, this.animationValues);\n            }\n            // Check the skew and rotate value of all axes and reset to 0\n            for (let i = 0; i < transformAxes.length; i++) {\n                resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n                resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);\n            }\n            // Force a render of this element to apply the transform with all skews and rotations\n            // set to 0.\n            visualElement.render();\n            // Put back all the values we reset\n            for (const key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n                if (this.animationValues) {\n                    this.animationValues[key] = resetValues[key];\n                }\n            }\n            // Schedule a render for the next frame. This ensures we won\'t visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        }\n        getProjectionStyles(styleProp) {\n            var _a, _b;\n            if (!this.instance || this.isSVG)\n                return undefined;\n            if (!this.isVisible) {\n                return hiddenVisibility;\n            }\n            const styles = {\n                visibility: "",\n            };\n            const transformTemplate = this.getTransformTemplate();\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = "";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, "")\n                    : "none";\n                return styles;\n            }\n            const lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                const emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity =\n                        this.latestValues.opacity !== undefined\n                            ? this.latestValues.opacity\n                            : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, "")\n                        : "none";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            const valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            const { x, y } = this.projectionDelta;\n            styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we\'re not animating at all, set the lead component to its layout\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? valuesToRender.opacity !== undefined\n                            ? valuesToRender.opacity\n                            : ""\n                        : valuesToRender.opacityExit !== undefined\n                            ? valuesToRender.opacityExit\n                            : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (const key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                const { correct, applyTo, isCSSVariable } = scaleCorrectors[key];\n                /**\n                 * Only apply scale correction to the value if we have an\n                 * active projection transform. Otherwise these values become\n                 * vulnerable to distortion if the element changes size without\n                 * a corresponding layout animation.\n                 */\n                const corrected = styles.transform === "none"\n                    ? valuesToRender[key]\n                    : correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    const num = applyTo.length;\n                    for (let i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    // If this is a CSS variable, set it directly on the instance.\n                    // Replacing this function from creating styles to setting them\n                    // would be a good place to remove per frame object creation\n                    if (isCSSVariable) {\n                        this.options.visualElement.renderState.vars[key] = corrected;\n                    }\n                    else {\n                        styles[key] = corrected;\n                    }\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn\'t block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || ""\n                        : "none";\n            }\n            return styles;\n        }\n        clearSnapshot() {\n            this.resumeFrom = this.snapshot = undefined;\n        }\n        // Only run on root\n        resetTree() {\n            this.root.nodes.forEach((node) => { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        }\n    };\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a;\n    const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners("didUpdate")) {\n        const { layoutBox: layout, measuredBox: measuredLayout } = node.layout;\n        const { animationType } = node.options;\n        const isShared = snapshot.source !== node.layout.source;\n        // TODO Maybe we want to also resize the layout snapshot so we don\'t trigger\n        // animations for instance if layout="size" and an element has only changed position\n        if (animationType === "size") {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {\n            eachAxis((axis) => {\n                const axisSnapshot = isShared\n                    ? snapshot.measuredBox[axis]\n                    : snapshot.layoutBox[axis];\n                const length = calcLength(layout[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n                /**\n                 * Ensure relative target gets resized and rerendererd\n                 */\n                if (node.relativeTarget && !node.currentAnimation) {\n                    node.isProjectionDirty = true;\n                    node.relativeTarget[axis].max =\n                        node.relativeTarget[axis].min + length;\n                }\n            });\n        }\n        const layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);\n        const visualDelta = createDelta();\n        if (isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout, snapshot.layoutBox);\n        }\n        const hasLayoutChanged = !isDeltaZero(layoutDelta);\n        let hasRelativeLayoutChanged = false;\n        if (!node.resumeFrom) {\n            const relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (relativeParent && !relativeParent.resumeFrom) {\n                const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;\n                if (parentSnapshot && parentLayout) {\n                    const relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);\n                    const relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);\n                    if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {\n                        hasRelativeLayoutChanged = true;\n                    }\n                    if (relativeParent.options.layoutRoot) {\n                        node.relativeTarget = relativeLayout;\n                        node.relativeTargetOrigin = relativeSnapshot;\n                        node.relativeParent = relativeParent;\n                    }\n                }\n            }\n        }\n        node.notifyListeners("didUpdate", {\n            layout,\n            snapshot,\n            delta: visualDelta,\n            layoutDelta,\n            hasLayoutChanged,\n            hasRelativeLayoutChanged,\n        });\n    }\n    else if (node.isLead()) {\n        const { onExitComplete } = node.options;\n        onExitComplete && onExitComplete();\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction propagateDirtyNodes(node) {\n    /**\n     * Increase debug counter for nodes encountered this frame\n     */\n    if (isDebug) {\n        metrics.totalNodes++;\n    }\n    if (!node.parent)\n        return;\n    /**\n     * If this node isn\'t projecting, propagate isProjectionDirty. It will have\n     * no performance impact but it will allow the next child that *is* projecting\n     * but *isn\'t* dirty to just check its parent to see if *any* ancestor needs\n     * correcting.\n     */\n    if (!node.isProjecting()) {\n        node.isProjectionDirty = node.parent.isProjectionDirty;\n    }\n    /**\n     * Propagate isSharedProjectionDirty and isTransformDirty\n     * throughout the whole tree. A future revision can take another look at\n     * this but for safety we still recalcualte shared nodes.\n     */\n    node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty ||\n        node.parent.isProjectionDirty ||\n        node.parent.isSharedProjectionDirty));\n    node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);\n}\nfunction cleanDirtyNodes(node) {\n    node.isProjectionDirty =\n        node.isSharedProjectionDirty =\n            node.isTransformDirty =\n                false;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction clearIsLayoutDirty(node) {\n    node.isLayoutDirty = false;\n}\nfunction resetTransformStyle(node) {\n    const { visualElement } = node.options;\n    if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notify("BeforeLayoutMeasure");\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n    node.isProjectionDirty = true;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetSkewAndRotation(node) {\n    node.resetSkewAndRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mixNumber(delta.translate, 0, p);\n    output.scale = mixNumber(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mixNumber(from.min, to.min, p);\n    output.max = mixNumber(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nconst defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nconst userAgentContains = (string) => typeof navigator !== "undefined" &&\n    navigator.userAgent &&\n    navigator.userAgent.toLowerCase().includes(string);\n/**\n * Measured bounding boxes must be rounded in Safari and\n * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements\n * can appear to jump.\n */\nconst roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/")\n    ? Math.round\n    : noop_noop;\nfunction roundAxis(axis) {\n    // Round to the nearest .5 pixels to support subpixel layouts\n    axis.min = roundPoint(axis.min);\n    axis.max = roundPoint(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\nfunction shouldAnimatePositionOnly(animationType, snapshot, layout) {\n    return (animationType === "position" ||\n        (animationType === "preserve-aspect" &&\n            !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2)));\n}\nfunction checkNodeWasScrollRoot(node) {\n    var _a;\n    return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\n\n\n\nconst DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),\n    measureScroll: () => ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }),\n    checkIsScrollRoot: () => true,\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\n\n\n\nconst rootProjectionNode = {\n    current: undefined,\n};\nconst HTMLProjectionNode = createProjectionNode({\n    measureScroll: (instance) => ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }),\n    defaultParent: () => {\n        if (!rootProjectionNode.current) {\n            const documentNode = new DocumentProjectionNode({});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: (instance, value) => {\n        instance.style.transform = value !== undefined ? value : "none";\n    },\n    checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed"),\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/drag.mjs\n\n\n\n\n\nconst drag = {\n    pan: {\n        Feature: PanGesture,\n    },\n    drag: {\n        Feature: DragGesture,\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout: MeasureLayout,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/hover.mjs\n\n\n\n\n\nfunction handleHoverEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileHover) {\n        node.animationState.setActive("whileHover", lifecycle === "Start");\n    }\n    const eventName = ("onHover" + lifecycle);\n    const callback = props[eventName];\n    if (callback) {\n        frame_frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass HoverGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = hover(current, (_element, startEvent) => {\n            handleHoverEvent(this.node, startEvent, "Start");\n            return (endEvent) => handleHoverEvent(this.node, endEvent, "End");\n        });\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/focus.mjs\n\n\n\n\nclass FocusGesture extends Feature {\n    constructor() {\n        super(...arguments);\n        this.isActive = false;\n    }\n    onFocus() {\n        let isFocusVisible = false;\n        /**\n         * If this element doesn\'t match focus-visible then don\'t\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current.matches(":focus-visible");\n        }\n        catch (e) {\n            isFocusVisible = true;\n        }\n        if (!isFocusVisible || !this.node.animationState)\n            return;\n        this.node.animationState.setActive("whileFocus", true);\n        this.isActive = true;\n    }\n    onBlur() {\n        if (!this.isActive || !this.node.animationState)\n            return;\n        this.node.animationState.setActive("whileFocus", false);\n        this.isActive = false;\n    }\n    mount() {\n        this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/gestures/press.mjs\n\n\n\n\n\nfunction handlePressEvent(node, event, lifecycle) {\n    const { props } = node;\n    if (node.animationState && props.whileTap) {\n        node.animationState.setActive("whileTap", lifecycle === "Start");\n    }\n    const eventName = ("onTap" + (lifecycle === "End" ? "" : lifecycle));\n    const callback = props[eventName];\n    if (callback) {\n        frame_frame.postRender(() => callback(event, extractEventInfo(event)));\n    }\n}\nclass PressGesture extends Feature {\n    mount() {\n        const { current } = this.node;\n        if (!current)\n            return;\n        this.unmount = press(current, (_element, startEvent) => {\n            handlePressEvent(this.node, startEvent, "Start");\n            return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");\n        }, { useGlobalTarget: this.node.props.globalTapTarget });\n    }\n    unmount() { }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = (entry) => {\n    const callback = observerCallbacks.get(entry.target);\n    callback && callback(entry);\n};\nconst fireAllObserverCallbacks = (entries) => {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({ root, ...options }) {\n    const lookupRoot = root || document;\n    /**\n     * If we don\'t have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    const rootObservers = observers.get(lookupRoot);\n    const key = JSON.stringify(options);\n    /**\n     * If we don\'t have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    const rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return () => {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs\n\n\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nclass InViewFeature extends Feature {\n    constructor() {\n        super(...arguments);\n        this.hasEnteredView = false;\n        this.isInView = false;\n    }\n    startObserver() {\n        this.unmount();\n        const { viewport = {} } = this.node.getProps();\n        const { root, margin: rootMargin, amount = "some", once } = viewport;\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold: typeof amount === "number" ? amount : thresholdNames[amount],\n        };\n        const onIntersectionUpdate = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there\'s been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting)\n                return;\n            this.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn\'t visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                this.hasEnteredView = true;\n            }\n            if (this.node.animationState) {\n                this.node.animationState.setActive("whileInView", isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps();\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(this.node.current, options, onIntersectionUpdate);\n    }\n    mount() {\n        this.startObserver();\n    }\n    update() {\n        if (typeof IntersectionObserver === "undefined")\n            return;\n        const { props, prevProps } = this.node;\n        const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));\n        if (hasOptionsChanged) {\n            this.startObserver();\n        }\n    }\n    unmount() { }\n}\nfunction hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {\n    return (name) => viewport[name] !== prevViewport[name];\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/gestures.mjs\n\n\n\n\n\nconst gestureAnimations = {\n    inView: {\n        Feature: InViewFeature,\n    },\n    tap: {\n        Feature: PressGesture,\n    },\n    focus: {\n        Feature: FocusGesture,\n    },\n    hover: {\n        Feature: HoverGesture,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/layout.mjs\n\n\n\nconst layout = {\n    layout: {\n        ProjectionNode: HTMLProjectionNode,\n        MeasureLayout: MeasureLayout,\n    },\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/LazyContext.mjs\n"use client";\n\n\nconst LazyContext = (0,react.createContext)({ strict: false });\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\n"use client";\n\n\n/**\n * @public\n */\nconst MotionConfigContext = (0,react.createContext)({\n    transformPagePoint: (p) => p,\n    isStatic: false,\n    reducedMotion: "never",\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\n"use client";\n\n\nconst MotionContext = (0,react.createContext)({});\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs\n\n\n\n\nfunction isControllingVariants(props) {\n    return (isAnimationControls(props.animate) ||\n        variantProps.some((name) => isVariantLabel(props[name])));\n}\nfunction isVariantNode(props) {\n    return Boolean(isControllingVariants(props) || props.variants);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\n\n\n\nfunction getCurrentTreeVariants(props, context) {\n    if (isControllingVariants(props)) {\n        const { initial, animate } = props;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\n\n\n\n\nfunction useCreateMotionContext(props) {\n    const { initial, animate } = getCurrentTreeVariants(props, (0,react.useContext)(MotionContext));\n    return (0,react.useMemo)(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(" ") : prop;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/is-browser.mjs\nconst isBrowser = typeof window !== "undefined";\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nconst featureProps = {\n    animation: [\n        "animate",\n        "variants",\n        "whileHover",\n        "whileTap",\n        "exit",\n        "whileInView",\n        "whileFocus",\n        "whileDrag",\n    ],\n    exit: ["exit"],\n    drag: ["drag", "dragControls"],\n    focus: ["whileFocus"],\n    hover: ["whileHover", "onHoverStart", "onHoverEnd"],\n    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],\n    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],\n    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],\n    layout: ["layout", "layoutId"],\n};\nconst featureDefinitions = {};\nfor (const key in featureProps) {\n    featureDefinitions[key] = {\n        isEnabled: (props) => featureProps[key].some((name) => !!props[name]),\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/features/load-features.mjs\n\n\nfunction loadFeatures(features) {\n    for (const key in features) {\n        featureDefinitions[key] = {\n            ...featureDefinitions[key],\n            ...features[key],\n        };\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/symbol.mjs\nconst motionComponentSymbol = Symbol.for("motionComponentSymbol");\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\n\n\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return (0,react.useCallback)((instance) => {\n        if (instance) {\n            visualState.onMount && visualState.onMount(instance);\n        }\n        if (visualElement) {\n            if (instance) {\n                visualElement.mount(instance);\n            }\n            else {\n                visualElement.unmount();\n            }\n        }\n        if (externalRef) {\n            if (typeof externalRef === "function") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we\'ve received a visual element\n     * factory. Otherwise we\'ll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\n\n\n\nconst useIsomorphicLayoutEffect = isBrowser ? react.useLayoutEffect : react.useEffect;\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\n\n\n\n\n\n\n\n\n\n\n\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {\n    var _a, _b;\n    const { visualElement: parent } = (0,react.useContext)(MotionContext);\n    const lazyContext = (0,react.useContext)(LazyContext);\n    const presenceContext = (0,react.useContext)(PresenceContext_PresenceContext);\n    const reducedMotionConfig = (0,react.useContext)(MotionConfigContext).reducedMotion;\n    const visualElementRef = (0,react.useRef)(null);\n    /**\n     * If we haven\'t preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement = createVisualElement || lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n        });\n    }\n    const visualElement = visualElementRef.current;\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = (0,react.useContext)(SwitchLayoutGroupContext);\n    if (visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === "html" || visualElement.type === "svg")) {\n        use_visual_element_createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n    }\n    const isMounted = (0,react.useRef)(false);\n    (0,react.useInsertionEffect)(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext);\n        }\n    });\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId = props[optimizedAppearDataAttribute];\n    const wantsHandoff = (0,react.useRef)(Boolean(optimisedAppearId) &&\n        !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) &&\n        ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));\n    useIsomorphicLayoutEffect(() => {\n        if (!visualElement)\n            return;\n        isMounted.current = true;\n        window.MotionIsMounted = true;\n        visualElement.updateFeatures();\n        microtask.render(visualElement.render);\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there\'s no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n    });\n    (0,react.useEffect)(() => {\n        if (!visualElement)\n            return;\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges();\n        }\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                var _a;\n                (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);\n            });\n            wantsHandoff.current = false;\n        }\n    });\n    return visualElement;\n}\nfunction use_visual_element_createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n    const { layoutId, layout, drag, dragConstraints, layoutScroll, layoutRoot, } = props;\n    visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"]\n        ? undefined\n        : getClosestProjectingNode(visualElement.parent));\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it\'ll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there\'s no potential layout animations.\n         *\n         */\n        animationType: typeof layout === "string" ? layout : "both",\n        initialPromotionConfig,\n        layoutScroll,\n        layoutRoot,\n    });\n}\nfunction getClosestProjectingNode(visualElement) {\n    if (!visualElement)\n        return undefined;\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent);\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/index.mjs\n"use client";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie "div"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component "offline", or outside the React render cycle.\n */\nfunction createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState, Component, }) {\n    var _a, _b;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        /**\n         * If we need to measure the element we load this functionality in a\n         * separate class component in order to gain access to getSnapshotBeforeUpdate.\n         */\n        let MeasureLayout;\n        const configAndProps = {\n            ...(0,react.useContext)(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        const context = useCreateMotionContext(props);\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            useStrictMode(configAndProps, preloadedFeatures);\n            const layoutProjection = getProjectionFunctionality(configAndProps);\n            MeasureLayout = layoutProjection.MeasureLayout;\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return ((0,jsx_runtime.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout && context.visualElement ? ((0,jsx_runtime.jsx)(MeasureLayout, { visualElement: context.visualElement, ...configAndProps })) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] }));\n    }\n    MotionComponent.displayName = `motion.${typeof Component === "string"\n        ? Component\n        : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : ""})`}`;\n    const ForwardRefMotionComponent = (0,react.forwardRef)(MotionComponent);\n    ForwardRefMotionComponent[motionComponentSymbol] = Component;\n    return ForwardRefMotionComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = (0,react.useContext)(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + "-" + layoutId\n        : layoutId;\n}\nfunction useStrictMode(configAndProps, preloadedFeatures) {\n    const isStrict = (0,react.useContext)(LazyContext).strict;\n    /**\n     * If we\'re in development mode, check to make sure we\'re not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (false) {}\n}\nfunction getProjectionFunctionality(props) {\n    const { drag, layout } = featureDefinitions;\n    if (!drag && !layout)\n        return {};\n    const combined = { ...drag, ...layout };\n    return {\n        MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props))\n            ? combined.MeasureLayout\n            : undefined,\n        ProjectionNode: combined.ProjectionNode,\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\n/**\n * We keep these listed separately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nconst lowercaseSVGElements = [\n    "animate",\n    "circle",\n    "defs",\n    "desc",\n    "ellipse",\n    "g",\n    "image",\n    "line",\n    "filter",\n    "marker",\n    "mask",\n    "metadata",\n    "path",\n    "pattern",\n    "polygon",\n    "polyline",\n    "rect",\n    "stop",\n    "switch",\n    "symbol",\n    "svg",\n    "text",\n    "tspan",\n    "use",\n    "view",\n];\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\n\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it\'s not a string, it\'s a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== "string" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes("-")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it\'s in our list of lowercase SVG tags, it\'s an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it\'s an SVG component\n         */\n        /[A-Z]/u.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/use-constant.mjs\n\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn\'t offer\n * a guarantee that it won\'t re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don\'t execute twice or more.\n */\nfunction useConstant(init) {\n    const ref = (0,react.useRef)(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\n\n\n\n\n\n\n\n\n\nfunction makeState({ scrapeMotionValuesFromProps, createRenderState, onUpdate, }, props, context, presenceContext) {\n    const state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onUpdate) {\n        /**\n         * onMount works without the VisualElement because it could be\n         * called before the VisualElement payload has been hydrated.\n         * (e.g. if someone is using m components <m.circle />)\n         */\n        state.onMount = (instance) => onUpdate({ props, current: instance, ...state });\n        state.onUpdate = (visualElement) => onUpdate(visualElement);\n    }\n    return state;\n}\nconst makeUseVisualState = (config) => (props, isStatic) => {\n    const context = (0,react.useContext)(MotionContext);\n    const presenceContext = (0,react.useContext)(PresenceContext_PresenceContext);\n    const make = () => makeState(config, props, context, presenceContext);\n    return isStatic ? make() : useConstant(make);\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    const values = {};\n    const motionValues = scrapeMotionValues(props, {});\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    let { initial, animate } = props;\n    const isControllingVariants$1 = isControllingVariants(props);\n    const isVariantNode$1 = isVariantNode(props);\n    if (context &&\n        isVariantNode$1 &&\n        !isControllingVariants$1 &&\n        props.inherit !== false) {\n        if (initial === undefined)\n            initial = context.initial;\n        if (animate === undefined)\n            animate = context.animate;\n    }\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false;\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n    const variantToSet = isInitialAnimationBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== "boolean" &&\n        !isAnimationControls(variantToSet)) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i]);\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved;\n                for (const key in target) {\n                    let valueTarget = target[key];\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0;\n                        valueTarget = valueTarget[index];\n                    }\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget;\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[key];\n                }\n            }\n        }\n    }\n    return values;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nconst getValueAsType = (value, type) => {\n    return type && typeof value === "number"\n        ? type.transform(value)\n        : value;\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\n\n\n\n\nconst translateAlias = {\n    x: "translateX",\n    y: "translateY",\n    z: "translateZ",\n    transformPerspective: "perspective",\n};\nconst numTransforms = transformPropOrder.length;\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(latestValues, transform, transformTemplate) {\n    // The transform string we\'re going to build into.\n    let transformString = "";\n    let transformIsDefault = true;\n    /**\n     * Loop over all possible transforms in order, adding the ones that\n     * are present to the transform string.\n     */\n    for (let i = 0; i < numTransforms; i++) {\n        const key = transformPropOrder[i];\n        const value = latestValues[key];\n        if (value === undefined)\n            continue;\n        let valueIsDefault = true;\n        if (typeof value === "number") {\n            valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);\n        }\n        else {\n            valueIsDefault = parseFloat(value) === 0;\n        }\n        if (!valueIsDefault || transformTemplate) {\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (!valueIsDefault) {\n                transformIsDefault = false;\n                const transformName = translateAlias[key] || key;\n                transformString += `${transformName}(${valueAsType}) `;\n            }\n            if (transformTemplate) {\n                transform[key] = valueAsType;\n            }\n        }\n    }\n    transformString = transformString.trim();\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);\n    }\n    else if (transformIsDefault) {\n        transformString = "none";\n    }\n    return transformString;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\n\n\n\n\n\n\nfunction buildHTMLStyles(state, latestValues, transformTemplate) {\n    const { style, vars, transformOrigin } = state;\n    // Track whether we encounter any transform or transformOrigin values.\n    let hasTransform = false;\n    let hasTransformOrigin = false;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept separately for further processing.\n     */\n    for (const key in latestValues) {\n        const value = latestValues[key];\n        if (transformProps.has(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            continue;\n        }\n        else if (isCSSVariableName(key)) {\n            vars[key] = value;\n            continue;\n        }\n        else {\n            // Convert the value to its default value type, ie 0 -> "0px"\n            const valueAsType = getValueAsType(value, numberValueTypes[key]);\n            if (key.startsWith("origin")) {\n                // If this is a transform origin, flag and enable further transform-origin processing\n                hasTransformOrigin = true;\n                transformOrigin[key] =\n                    valueAsType;\n            }\n            else {\n                style[key] = valueAsType;\n            }\n        }\n    }\n    if (!latestValues.transform) {\n        if (hasTransform || transformTemplate) {\n            style.transform = buildTransform(latestValues, state.transform, transformTemplate);\n        }\n        else if (style.transform) {\n            /**\n             * If we have previously created a transform but currently don\'t have any,\n             * reset transform style to none.\n             */\n            style.transform = "none";\n        }\n    }\n    /**\n     * Build a transformOrigin style. Uses the same defaults as the browser for\n     * undefined origins.\n     */\n    if (hasTransformOrigin) {\n        const { originX = "50%", originY = "50%", originZ = 0, } = transformOrigin;\n        style.transformOrigin = `${originX} ${originY} ${originZ}`;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\n\n\nconst dashKeys = {\n    offset: "stroke-dashoffset",\n    array: "stroke-dasharray",\n};\nconst camelKeys = {\n    offset: "strokeDashoffset",\n    array: "strokeDasharray",\n};\n/**\n * Build SVG path properties. Uses the path\'s measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    const keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    const pathLength = px.transform(length);\n    const pathSpacing = px.transform(spacing);\n    attrs[keys.array] = `${pathLength} ${pathSpacing}`;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\n\n\nfunction transform_origin_calcOrigin(origin, offset, size) {\n    return typeof origin === "string"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    const pxOriginX = transform_origin_calcOrigin(originX, dimensions.x, dimensions.width);\n    const pxOriginY = transform_origin_calcOrigin(originY, dimensions.y, dimensions.height);\n    return `${pxOriginX} ${pxOriginY}`;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\n\n\n\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, { attrX, attrY, attrScale, originX, originY, pathLength, pathSpacing = 1, pathOffset = 0, \n// This is object creation, which we try to avoid per-frame.\n...latest }, isSVGTag, transformTemplate) {\n    buildHTMLStyles(state, latest, transformTemplate);\n    /**\n     * For svg tags we just want to make sure viewBox is animatable and treat all the styles\n     * as normal HTML tags.\n     */\n    if (isSVGTag) {\n        if (state.style.viewBox) {\n            state.attrs.viewBox = state.style.viewBox;\n        }\n        return;\n    }\n    state.attrs = state.style;\n    state.style = {};\n    const { attrs, style, dimensions } = state;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Render attrX/attrY/attrScale as attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    if (attrScale !== undefined)\n        attrs.scale = attrScale;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nconst createHtmlRenderState = () => ({\n    style: {},\n    transform: {},\n    transformOrigin: {},\n    vars: {},\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\n\n\nconst createSvgRenderState = () => ({\n    ...createHtmlRenderState(),\n    attrs: {},\n});\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs\nconst isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, { style, vars }, styleProp, projection) {\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (const key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nconst camelCaseAttributes = new Set([\n    "baseFrequency",\n    "diffuseConstant",\n    "kernelMatrix",\n    "kernelUnitLength",\n    "keySplines",\n    "keyTimes",\n    "limitingConeAngle",\n    "markerHeight",\n    "markerWidth",\n    "numOctaves",\n    "targetX",\n    "targetY",\n    "surfaceScale",\n    "specularConstant",\n    "specularExponent",\n    "stdDeviation",\n    "tableValues",\n    "viewBox",\n    "gradientTransform",\n    "pathLength",\n    "startOffset",\n    "textLength",\n    "lengthAdjust",\n]);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\n\n\n\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (const key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\n\n\n\nfunction isForcedMotionValue(key, { layout, layoutId }) {\n    return (transformProps.has(key) ||\n        key.startsWith("origin") ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === "opacity")));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\n\n\n\nfunction scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    var _a;\n    const { style } = props;\n    const newValues = {};\n    for (const key in style) {\n        if (isMotionValue(style[key]) ||\n            (prevProps.style &&\n                isMotionValue(prevProps.style[key])) ||\n            isForcedMotionValue(key, props) ||\n            ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\n\n\n\n\nfunction scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n    const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    for (const key in props) {\n        if (isMotionValue(props[key]) ||\n            isMotionValue(prevProps[key])) {\n            const targetKey = transformPropOrder.indexOf(key) !== -1\n                ? "attr" + key.charAt(0).toUpperCase() + key.substring(1)\n                : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\n\n\n\n\n\n\n\n\n\nfunction updateSVGDimensions(instance, renderState) {\n    try {\n        renderState.dimensions =\n            typeof instance.getBBox === "function"\n                ? instance.getBBox()\n                : instance.getBoundingClientRect();\n    }\n    catch (e) {\n        // Most likely trying to measure an unrendered element under Firefox\n        renderState.dimensions = {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n        };\n    }\n}\nconst layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];\nconst svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onUpdate: ({ props, prevProps, current, renderState, latestValues, }) => {\n            if (!current)\n                return;\n            let hasTransform = !!props.drag;\n            if (!hasTransform) {\n                for (const key in latestValues) {\n                    if (transformProps.has(key)) {\n                        hasTransform = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasTransform)\n                return;\n            let needsMeasure = !prevProps;\n            if (prevProps) {\n                /**\n                 * Check the layout props for changes, if any are found we need to\n                 * measure the element again.\n                 */\n                for (let i = 0; i < layoutProps.length; i++) {\n                    const key = layoutProps[i];\n                    if (props[key] !==\n                        prevProps[key]) {\n                        needsMeasure = true;\n                    }\n                }\n            }\n            if (!needsMeasure)\n                return;\n            frame_frame.read(() => {\n                updateSVGDimensions(current, renderState);\n                frame_frame.render(() => {\n                    buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);\n                    renderSVG(current, renderState);\n                });\n            });\n        },\n    }),\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/config-motion.mjs\n\n\n\n\nconst htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/use-props.mjs\n\n\n\n\n\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues({ transformTemplate }, visualState) {\n    return (0,react.useMemo)(() => {\n        const state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, transformTemplate);\n        return Object.assign({}, state.vars, state.style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n    const styleProp = props.style || {};\n    const style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState));\n    return style;\n}\nfunction useHTMLProps(props, visualState) {\n    // The `any` isn\'t ideal but it is the type of createElement props argument\n    const htmlProps = {};\n    const style = useStyle(props, visualState);\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    "none";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? "none"\n                : `pan-${props.drag === "x" ? "y" : "x"}`;\n    }\n    if (props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)) {\n        htmlProps.tabIndex = 0;\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn\'t throw if a `MotionProp` name is missing - it should.\n */\nconst validMotionProps = new Set([\n    "animate",\n    "exit",\n    "variants",\n    "initial",\n    "style",\n    "values",\n    "variants",\n    "transition",\n    "transformTemplate",\n    "custom",\n    "inherit",\n    "onBeforeLayoutMeasure",\n    "onAnimationStart",\n    "onAnimationComplete",\n    "onUpdate",\n    "onDragStart",\n    "onDrag",\n    "onDragEnd",\n    "onMeasureDragConstraints",\n    "onDirectionLock",\n    "onDragTransitionEnd",\n    "_dragX",\n    "_dragY",\n    "onHoverStart",\n    "onHoverEnd",\n    "onViewportEnter",\n    "onViewportLeave",\n    "globalTapTarget",\n    "ignoreStrict",\n    "viewport",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return (key.startsWith("while") ||\n        (key.startsWith("drag") && key !== "draggable") ||\n        key.startsWith("layout") ||\n        key.startsWith("onTap") ||\n        key.startsWith("onPan") ||\n        key.startsWith("onLayout") ||\n        validMotionProps.has(key));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\n\n\nlet shouldForward = (key) => !isValidMotionProp(key);\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp)\n        return;\n    // Explicitly filter our events\n    shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it\'s seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn\'t *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it\'s\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won\'t be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);\n}\ncatch (_a) {\n    // We don\'t need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    const filteredProps = {};\n    for (const key in props) {\n        /**\n         * values is considered a valid prop by Emotion, so if it\'s present\n         * this will be rendered out to the DOM unless explicitly filtered.\n         *\n         * We check the type as it could be used with the `feColorMatrix`\n         * element, which we support.\n         */\n        if (key === "values" && typeof props.values === "object")\n            continue;\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props["draggable"] &&\n                key.startsWith("onDrag"))) {\n            filteredProps[key] =\n                props[key];\n        }\n    }\n    return filteredProps;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/use-props.mjs\n\n\n\n\n\n\nfunction useSVGProps(props, visualState, _isStatic, Component) {\n    const visualProps = (0,react.useMemo)(() => {\n        const state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);\n        return {\n            ...state.attrs,\n            style: { ...state.style },\n        };\n    }, [visualState]);\n    if (props.style) {\n        const rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = { ...rawStyles, ...visualProps.style };\n    }\n    return visualProps;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/use-render.mjs\n\n\n\n\n\n\n\nfunction createUseRender(forwardMotionProps = false) {\n    const useRender = (Component, props, ref, { latestValues }, isStatic) => {\n        const useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        const visualProps = useVisualProps(props, latestValues, isStatic, Component);\n        const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);\n        const elementProps = Component !== react.Fragment\n            ? { ...filteredProps, ...visualProps, ref }\n            : {};\n        /**\n         * If component has been handed a motion value as its child,\n         * memoise its initial value and render that. Subsequent updates\n         * will be handled by the onChange handler\n         */\n        const { children } = props;\n        const renderedChildren = (0,react.useMemo)(() => (isMotionValue(children) ? children.get() : children), [children]);\n        return (0,react.createElement)(Component, {\n            ...elementProps,\n            children: renderedChildren,\n        });\n    };\n    return useRender;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/components/create-factory.mjs\n\n\n\n\n\n\nfunction createMotionComponentFactory(preloadedFeatures, createVisualElement) {\n    return function createMotionComponent(Component, { forwardMotionProps } = { forwardMotionProps: false }) {\n        const baseConfig = isSVGComponent(Component)\n            ? svgMotionConfig\n            : htmlMotionConfig;\n        const config = {\n            ...baseConfig,\n            preloadedFeatures,\n            useRender: createUseRender(forwardMotionProps),\n            createVisualElement,\n            Component,\n        };\n        return createRendererMotionComponent(config);\n    };\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs\n// Does this device prefer reduced motion? Returns `null` server-side.\nconst prefersReducedMotion = { current: null };\nconst hasReducedMotionListener = { current: false };\n\n\n\n;// ./node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs\n\n\n\nfunction initPrefersReducedMotion() {\n    hasReducedMotionListener.current = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");\n        const setReducedMotionPreferences = () => (prefersReducedMotion.current = motionMediaQuery.matches);\n        motionMediaQuery.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\n\n\n\n\n\n/**\n * A list of all ValueTypes\n */\nconst valueTypes = [...dimensionValueTypes, color, complex];\n/**\n * Tests a value against the list of ValueTypes\n */\nconst findValueType = (v) => valueTypes.find(testValueType(v));\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/store.mjs\nconst visualElementStore = new WeakMap();\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\n\n\n\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    for (const key in next) {\n        const nextValue = next[key];\n        const prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element\'s motion value map.\n             */\n            element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (false) {}\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we\'re swapping from a motion value to a static value,\n             * create a new motion value from that\n             */\n            element.addValue(key, motionValue(nextValue, { owner: element }));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn\'t exist. We only want to do this if we\'re\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                const existingValue = element.getValue(key);\n                if (existingValue.liveStyle === true) {\n                    existingValue.jump(nextValue);\n                }\n                else if (!existingValue.hasAnimated) {\n                    existingValue.set(nextValue);\n                }\n            }\n            else {\n                const latestValue = element.getStaticValue(key);\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\n            }\n        }\n    }\n    // Handle removed values\n    for (const key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/VisualElement.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst propEventHandlers = [\n    "AnimationStart",\n    "AnimationComplete",\n    "Update",\n    "BeforeLayoutMeasure",\n    "LayoutMeasure",\n    "LayoutAnimationStart",\n    "LayoutAnimationComplete",\n];\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn\'t an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n        return {};\n    }\n    constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState, }, options = {}) {\n        /**\n         * A reference to the current underlying Instance, e.g. a HTMLElement\n         * or Three.Mesh etc.\n         */\n        this.current = null;\n        /**\n         * A set containing references to this VisualElement\'s children.\n         */\n        this.children = new Set();\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        this.isVariantNode = false;\n        this.isControllingVariants = false;\n        /**\n         * Decides whether this VisualElement should animate in reduced motion\n         * mode.\n         *\n         * TODO: This is currently set on every individual VisualElement but feels\n         * like it could be set globally.\n         */\n        this.shouldReduceMotion = null;\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        this.values = new Map();\n        this.KeyframeResolver = KeyframeResolver;\n        /**\n         * Cleanup functions for active features (hover/tap/exit etc)\n         */\n        this.features = {};\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        this.valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        this.prevMotionValues = {};\n        /**\n         * An object containing a SubscriptionManager for each active event.\n         */\n        this.events = {};\n        /**\n         * An object containing an unsubscribe function for each prop event subscription.\n         * For example, every "Update" event can have multiple subscribers via\n         * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n         */\n        this.propEventSubscriptions = {};\n        this.notifyUpdate = () => this.notify("Update", this.latestValues);\n        this.render = () => {\n            if (!this.current)\n                return;\n            this.triggerBuild();\n            this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n        };\n        this.renderScheduledAt = 0.0;\n        this.scheduleRender = () => {\n            const now = time.now();\n            if (this.renderScheduledAt < now) {\n                this.renderScheduledAt = now;\n                frame_frame.render(this.render, false, true);\n            }\n        };\n        const { latestValues, renderState, onUpdate } = visualState;\n        this.onUpdate = onUpdate;\n        this.latestValues = latestValues;\n        this.baseTarget = { ...latestValues };\n        this.initialValues = props.initial ? { ...latestValues } : {};\n        this.renderState = renderState;\n        this.parent = parent;\n        this.props = props;\n        this.presenceContext = presenceContext;\n        this.depth = parent ? parent.depth + 1 : 0;\n        this.reducedMotionConfig = reducedMotionConfig;\n        this.options = options;\n        this.blockInitialAnimation = Boolean(blockInitialAnimation);\n        this.isControllingVariants = isControllingVariants(props);\n        this.isVariantNode = isVariantNode(props);\n        if (this.isVariantNode) {\n            this.variantChildren = new Set();\n        }\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n        /**\n         * Any motion values that are provided to the element when created\n         * aren\'t yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn\'t necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n    }\n    mount(instance) {\n        this.current = instance;\n        visualElementStore.set(instance, this);\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance);\n        }\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this);\n        }\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n        if (!hasReducedMotionListener.current) {\n            initPrefersReducedMotion();\n        }\n        this.shouldReduceMotion =\n            this.reducedMotionConfig === "never"\n                ? false\n                : this.reducedMotionConfig === "always"\n                    ? true\n                    : prefersReducedMotion.current;\n        if (false) {}\n        if (this.parent)\n            this.parent.children.add(this);\n        this.update(this.props, this.presenceContext);\n    }\n    unmount() {\n        visualElementStore.delete(this.current);\n        this.projection && this.projection.unmount();\n        cancelFrame(this.notifyUpdate);\n        cancelFrame(this.render);\n        this.valueSubscriptions.forEach((remove) => remove());\n        this.valueSubscriptions.clear();\n        this.removeFromVariantTree && this.removeFromVariantTree();\n        this.parent && this.parent.children.delete(this);\n        for (const key in this.events) {\n            this.events[key].clear();\n        }\n        for (const key in this.features) {\n            const feature = this.features[key];\n            if (feature) {\n                feature.unmount();\n                feature.isMounted = false;\n            }\n        }\n        this.current = null;\n    }\n    bindToMotionValue(key, value) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)();\n        }\n        const valueIsTransform = transformProps.has(key);\n        const removeOnChange = value.on("change", (latestValue) => {\n            this.latestValues[key] = latestValue;\n            this.props.onUpdate && frame_frame.preRender(this.notifyUpdate);\n            if (valueIsTransform && this.projection) {\n                this.projection.isTransformDirty = true;\n            }\n        });\n        const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);\n        let removeSyncCheck;\n        if (window.MotionCheckAppearSync) {\n            removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n        }\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange();\n            removeOnRenderRequest();\n            if (removeSyncCheck)\n                removeSyncCheck();\n            if (value.owner)\n                value.stop();\n        });\n    }\n    sortNodePosition(other) {\n        /**\n         * If these nodes aren\'t even of the same type we can\'t compare their depth.\n         */\n        if (!this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type) {\n            return 0;\n        }\n        return this.sortInstanceNodePosition(this.current, other.current);\n    }\n    updateFeatures() {\n        let key = "animation";\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key];\n            if (!featureDefinition)\n                continue;\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition;\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (!this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)) {\n                this.features[key] = new FeatureConstructor(this);\n            }\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key];\n                if (feature.isMounted) {\n                    feature.update();\n                }\n                else {\n                    feature.mount();\n                    feature.isMounted = true;\n                }\n            }\n        }\n    }\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props);\n    }\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox();\n    }\n    getStaticValue(key) {\n        return this.latestValues[key];\n    }\n    setStaticValue(key, value) {\n        this.latestValues[key] = value;\n    }\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(props, presenceContext) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender();\n        }\n        this.prevProps = this.props;\n        this.props = props;\n        this.prevPresenceContext = this.presenceContext;\n        this.presenceContext = presenceContext;\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i];\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]();\n                delete this.propEventSubscriptions[key];\n            }\n            const listenerName = ("on" + key);\n            const listener = props[listenerName];\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key, listener);\n            }\n        }\n        this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue();\n        }\n        this.onUpdate && this.onUpdate(this);\n    }\n    getProps() {\n        return this.props;\n    }\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name) {\n        return this.props.variants ? this.props.variants[name] : undefined;\n    }\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition;\n    }\n    getTransformPagePoint() {\n        return this.props.transformPagePoint;\n    }\n    getClosestVariantNode() {\n        return this.isVariantNode\n            ? this\n            : this.parent\n                ? this.parent.getClosestVariantNode()\n                : undefined;\n    }\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child) {\n        const closestVariantNode = this.getClosestVariantNode();\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child);\n            return () => closestVariantNode.variantChildren.delete(child);\n        }\n    }\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key, value) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key);\n        if (value !== existingValue) {\n            if (existingValue)\n                this.removeValue(key);\n            this.bindToMotionValue(key, value);\n            this.values.set(key, value);\n            this.latestValues[key] = value.get();\n        }\n    }\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key) {\n        this.values.delete(key);\n        const unsubscribe = this.valueSubscriptions.get(key);\n        if (unsubscribe) {\n            unsubscribe();\n            this.valueSubscriptions.delete(key);\n        }\n        delete this.latestValues[key];\n        this.removeValueFromRenderState(key, this.renderState);\n    }\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key) {\n        return this.values.has(key);\n    }\n    getValue(key, defaultValue) {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key];\n        }\n        let value = this.values.get(key);\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(defaultValue === null ? undefined : defaultValue, { owner: this });\n            this.addValue(key, value);\n        }\n        return value;\n    }\n    /**\n     * If we\'re trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key, target) {\n        var _a;\n        let value = this.latestValues[key] !== undefined || !this.current\n            ? this.latestValues[key]\n            : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);\n        if (value !== undefined && value !== null) {\n            if (typeof value === "string" &&\n                (isNumericalString(value) || isZeroValueString(value))) {\n                // If this is a number read as a string, ie "0" or "200", convert it to a number\n                value = parseFloat(value);\n            }\n            else if (!findValueType(value) && complex.test(target)) {\n                value = animatable_none_getAnimatableNone(key, target);\n            }\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n        }\n        return isMotionValue(value) ? value.get() : value;\n    }\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key, value) {\n        this.baseTarget[key] = value;\n    }\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key) {\n        var _a;\n        const { initial } = this.props;\n        let valueFromInitial;\n        if (typeof initial === "string" || typeof initial === "object") {\n            const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);\n            if (variant) {\n                valueFromInitial = variant[key];\n            }\n        }\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial;\n        }\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key);\n        if (target !== undefined && !isMotionValue(target))\n            return target;\n        /**\n         * If the value was initially defined on initial, but it doesn\'t any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key];\n    }\n    on(eventName, callback) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager();\n        }\n        return this.events[eventName].add(callback);\n    }\n    notify(eventName, ...args) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args);\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs\n\n\n\n\nclass DOMVisualElement extends VisualElement {\n    constructor() {\n        super(...arguments);\n        this.KeyframeResolver = DOMKeyframesResolver;\n    }\n    sortInstanceNodePosition(a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we\'re returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props.style\n            ? props.style[key]\n            : undefined;\n    }\n    removeValueFromRenderState(key, { vars, style }) {\n        delete vars[key];\n        delete style[key];\n    }\n    handleChildMotionValue() {\n        if (this.childSubscription) {\n            this.childSubscription();\n            delete this.childSubscription;\n        }\n        const { children } = this.props;\n        if (isMotionValue(children)) {\n            this.childSubscription = children.on("change", (latest) => {\n                if (this.current) {\n                    this.current.textContent = `${latest}`;\n                }\n            });\n        }\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs\n\n\n\n\n\n\n\n\n\nfunction getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nclass HTMLVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = "html";\n        this.renderInstance = renderHTML;\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            const computedStyle = getComputedStyle(instance);\n            const value = (isCSSVariableName(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0;\n            return typeof value === "string" ? value.trim() : value;\n        }\n    }\n    measureInstanceViewportBox(instance, { transformPagePoint }) {\n        return measureViewportBox(instance, transformPagePoint);\n    }\n    build(renderState, latestValues, props) {\n        buildHTMLStyles(renderState, latestValues, props.transformTemplate);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs\n\n\n\n\n\n\n\n\n\n\n\nclass SVGVisualElement extends DOMVisualElement {\n    constructor() {\n        super(...arguments);\n        this.type = "svg";\n        this.isSVGTag = false;\n        this.measureInstanceViewportBox = createBox;\n    }\n    getBaseTargetFromProps(props, key) {\n        return props[key];\n    }\n    readValueFromInstance(instance, key) {\n        if (transformProps.has(key)) {\n            const defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return instance.getAttribute(key);\n    }\n    scrapeMotionValuesFromProps(props, prevProps, visualElement) {\n        return scrape_motion_values_scrapeMotionValuesFromProps(props, prevProps, visualElement);\n    }\n    build(renderState, latestValues, props) {\n        buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);\n    }\n    renderInstance(instance, renderState, styleProp, projection) {\n        renderSVG(instance, renderState, styleProp, projection);\n    }\n    mount(instance) {\n        this.isSVGTag = isSVGTag(instance.tagName);\n        super.mount(instance);\n    }\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\n\n\n\n\n\nconst createDomVisualElement = (Component, options) => {\n    return isSVGComponent(Component)\n        ? new SVGVisualElement(options)\n        : new HTMLVisualElement(options, {\n            allowProjection: Component !== react.Fragment,\n        });\n};\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/components/motion/create.mjs\n\n\n\n\n\n\n\nconst createMotionComponent = /*@__PURE__*/ createMotionComponentFactory({\n    ...animations,\n    ...gestureAnimations,\n    ...drag,\n    ...layout,\n}, createDomVisualElement);\n\n\n\n;// ./node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs\n\n\n\nconst motion = /*@__PURE__*/ createDOMMotionComponentProxy(createMotionComponent);\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs\n"use client";\n\n\n\n\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends react.Component {\n    getSnapshotBeforeUpdate(prevProps) {\n        const element = this.props.childRef.current;\n        if (element && prevProps.isPresent && !this.props.isPresent) {\n            const parent = element.offsetParent;\n            const parentWidth = parent instanceof HTMLElement ? parent.offsetWidth || 0 : 0;\n            const size = this.props.sizeRef.current;\n            size.height = element.offsetHeight || 0;\n            size.width = element.offsetWidth || 0;\n            size.top = element.offsetTop;\n            size.left = element.offsetLeft;\n            size.right = parentWidth - size.width - size.left;\n        }\n        return null;\n    }\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() { }\n    render() {\n        return this.props.children;\n    }\n}\nfunction PopChild({ children, isPresent, anchorX }) {\n    const id = (0,react.useId)();\n    const ref = (0,react.useRef)(null);\n    const size = (0,react.useRef)({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n    });\n    const { nonce } = (0,react.useContext)(MotionConfigContext);\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can\'t apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    (0,react.useInsertionEffect)(() => {\n        const { width, height, top, left, right } = size.current;\n        if (isPresent || !ref.current || !width || !height)\n            return;\n        const x = anchorX === "left" ? `left: ${left}` : `right: ${right}`;\n        ref.current.dataset.motionPopId = id;\n        const style = document.createElement("style");\n        if (nonce)\n            style.nonce = nonce;\n        document.head.appendChild(style);\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id="${id}"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            top: ${top}px !important;\n          }\n        `);\n        }\n        return () => {\n            document.head.removeChild(style);\n        };\n    }, [isPresent]);\n    return ((0,jsx_runtime.jsx)(PopChildMeasure, { isPresent: isPresent, childRef: ref, sizeRef: size, children: react.cloneElement(children, { ref }) }));\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs\n"use client";\n\n\n\n\n\n\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = (0,react.useId)();\n    const memoizedOnExitComplete = (0,react.useCallback)((childId) => {\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()) {\n            if (!isComplete)\n                return; // can stop searching when any is incomplete\n        }\n        onExitComplete && onExitComplete();\n    }, [presenceChildren, onExitComplete]);\n    const context = (0,react.useMemo)(() => ({\n        id,\n        initial,\n        isPresent,\n        custom,\n        onExitComplete: memoizedOnExitComplete,\n        register: (childId) => {\n            presenceChildren.set(childId, false);\n            return () => presenceChildren.delete(childId);\n        },\n    }), \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout\n        ? [Math.random(), memoizedOnExitComplete]\n        : [isPresent, memoizedOnExitComplete]);\n    (0,react.useMemo)(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there\'s no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    react.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === "popLayout") {\n        children = ((0,jsx_runtime.jsx)(PopChild, { isPresent: isPresent, anchorX: anchorX, children: children }));\n    }\n    return ((0,jsx_runtime.jsx)(PresenceContext_PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs\n\n\nconst getChildKey = (child) => child.key || "";\nfunction onlyElements(children) {\n    const filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    react.Children.forEach(children, (child) => {\n        if ((0,react.isValidElement)(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n\n\n\n;// ./node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\n"use client";\n\n\n\n\n\n\n\n\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from \'framer-motion\'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left", }) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate);\n    /**\n     * Filter any children that aren\'t ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = (0,react.useMemo)(() => onlyElements(children), [children]);\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = (0,react.useRef)(true);\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = (0,react.useRef)(presentChildren);\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map());\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = (0,react.useState)(presentChildren);\n    const [renderedChildren, setRenderedChildren] = (0,react.useState)(presentChildren);\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false;\n        pendingPresentChildren.current = presentChildren;\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i]);\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false);\n                }\n            }\n            else {\n                exitComplete.delete(key);\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);\n    const exitingChildren = [];\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren];\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i];\n            const key = getChildKey(child);\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child);\n                exitingChildren.push(child);\n            }\n        }\n        /**\n         * If we\'re in "wait" mode, and we have exiting children, we want to\n         * only render these until they\'ve all exited.\n         */\n        if (mode === "wait" && exitingChildren.length) {\n            nextChildren = exitingChildren;\n        }\n        setRenderedChildren(onlyElements(nextChildren));\n        setDiffedChildren(presentChildren);\n        /**\n         * Early return to ensure once we\'ve set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return;\n    }\n    if (false) {}\n    /**\n     * If we\'ve been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = (0,react.useContext)(LayoutGroupContext);\n    return ((0,jsx_runtime.jsx)(jsx_runtime.Fragment, { children: renderedChildren.map((child) => {\n            const key = getChildKey(child);\n            const isPresent = propagate && !isParentPresent\n                ? false\n                : presentChildren === renderedChildren ||\n                    presentKeys.includes(key);\n            const onExit = () => {\n                if (exitComplete.has(key)) {\n                    exitComplete.set(key, true);\n                }\n                else {\n                    return;\n                }\n                let isEveryExitComplete = true;\n                exitComplete.forEach((isExitComplete) => {\n                    if (!isExitComplete)\n                        isEveryExitComplete = false;\n                });\n                if (isEveryExitComplete) {\n                    forceRender === null || forceRender === void 0 ? void 0 : forceRender();\n                    setRenderedChildren(pendingPresentChildren.current);\n                    propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());\n                    onExitComplete && onExitComplete();\n                }\n            };\n            return ((0,jsx_runtime.jsx)(PresenceChild, { isPresent: isPresent, initial: !isInitialRender.current || initial\n                    ? undefined\n                    : false, custom: isPresent ? undefined : custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode, onExitComplete: isPresent ? undefined : onExit, anchorX: anchorX, children: child }, key));\n        }) }));\n};\n\n\n\n;// ./src/context/FileUploadContext.tsx\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nvar FileUploadContext = /*#__PURE__*/(0,react.createContext)(undefined);\nfunction useFileUpload() {\n  var context = (0,react.useContext)(FileUploadContext);\n  if (context === undefined) {\n    throw new Error("useFileUpload must be used within a FileUploadProvider");\n  }\n  return context;\n}\nfunction FileUploadProvider(_ref) {\n  var children = _ref.children,\n    _ref$maxSize = _ref.maxSize,\n    maxSize = _ref$maxSize === void 0 ? 45 * 1024 : _ref$maxSize;\n  var _useState = (0,react.useState)(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    file = _useState2[0],\n    setFile = _useState2[1];\n  var _useState3 = (0,react.useState)(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    error = _useState4[0],\n    setError = _useState4[1];\n  var validateFile = (0,react.useCallback)(function (file) {\n    var validTypes = ["image/jpeg", "image/png", "image/pdg", "video/mp4"];\n    if (!validTypes.includes(file.type)) {\n      setError("File type not supported");\n      return false;\n    }\n    if (file.size > maxSize) {\n      setError("File size exceeds 45KB limit");\n      return false;\n    }\n    return true;\n  }, [maxSize]);\n  var addFile = (0,react.useCallback)(function (newFiles) {\n    setError(null);\n    // Se toma solo el primer archivo\n    var fileToAdd = Array.from(newFiles)[0];\n    if (!validateFile(fileToAdd)) return;\n    var fileWithPreview = fileToAdd;\n    if (fileToAdd.type.startsWith("image/")) {\n      fileWithPreview = Object.assign(fileToAdd, {\n        preview: URL.createObjectURL(fileToAdd)\n      });\n    }\n    // Si ya existe un archivo, se revoca su URL de preview\n    if (file && file.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n    setFile(fileWithPreview);\n  }, [validateFile, file]);\n  var removeFile = (0,react.useCallback)(function () {\n    if (file && file.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n    setFile(null);\n  }, [file]);\n  var clearFile = (0,react.useCallback)(function () {\n    if (file && file.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n    setFile(null);\n  }, [file]);\n  return /*#__PURE__*/react.createElement(FileUploadContext.Provider, {\n    value: {\n      file: file,\n      error: error,\n      addFile: addFile,\n      removeFile: removeFile,\n      clearFile: clearFile\n    }\n  }, children);\n}\n;// ./src/icons/UploadIcon.tsx\n\nvar UploadIcon = function UploadIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    width: "46",\n    height: "47",\n    viewBox: "0 0 46 47",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M14.2991 37.5685H10.619C4.984 37.166 2.4541 32.8343 2.4541 28.9818C2.4541 25.1293 4.98403 20.7785 10.5232 20.3951C11.309 20.3185 11.999 20.9318 12.0565 21.7368C12.114 22.5226 11.5199 23.2126 10.7149 23.2701C6.9966 23.5385 5.3291 26.3368 5.3291 29.001C5.3291 31.6651 6.9966 34.4635 10.7149 34.7318H14.2991C15.0849 34.7318 15.7366 35.3835 15.7366 36.1693C15.7366 36.9551 15.0849 37.5685 14.2991 37.5685Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M31.9507 37.5682C31.9124 37.5682 31.8932 37.5682 31.8549 37.5682C31.0691 37.5682 30.3408 36.9166 30.3408 36.1307C30.3408 35.3066 30.9541 34.6932 31.7591 34.6932C34.1166 34.6932 36.2249 33.8691 37.8733 32.3933C40.8633 29.7866 41.0549 26.0299 40.2499 23.3849C39.4449 20.7591 37.2024 17.7499 33.2924 17.2708C32.6599 17.1941 32.1615 16.7149 32.0465 16.0824C31.2799 11.4824 28.8074 8.30076 25.0508 7.15076C21.1791 5.94326 16.6557 7.13159 13.8382 10.0833C11.0974 12.9391 10.4649 16.9449 12.0557 21.3533C12.324 22.1008 11.9408 22.9249 11.1933 23.1932C10.4458 23.4616 9.62159 23.0783 9.35326 22.3308C7.41743 16.9258 8.29911 11.7508 11.7683 8.10909C15.3141 4.39076 21.0066 2.91491 25.8941 4.40991C30.3791 5.78991 33.5415 9.48908 34.6915 14.6257C38.6015 15.5074 41.7449 18.4783 42.9907 22.5799C44.3516 27.0458 43.1249 31.6458 39.7707 34.5591C37.6432 36.4758 34.864 37.5682 31.9507 37.5682Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M22.9998 43.2033C19.1473 43.2033 15.544 41.1524 13.5699 37.8366C13.359 37.5108 13.1482 37.1275 12.9757 36.7058C12.324 35.345 11.979 33.7925 11.979 32.1825C11.979 26.1066 16.924 21.1616 22.9998 21.1616C29.0757 21.1616 34.0207 26.1066 34.0207 32.1825C34.0207 33.8116 33.6757 35.345 32.9857 36.7633C32.8324 37.1275 32.6216 37.5108 32.3916 37.875C30.4557 41.1525 26.8523 43.2033 22.9998 43.2033ZM22.9998 24.0366C18.5148 24.0366 14.854 27.6975 14.854 32.1825C14.854 33.3708 15.1032 34.4824 15.5823 35.4983C15.7357 35.8241 15.8698 36.0925 16.0231 36.3416C17.4798 38.8141 20.144 40.3283 22.9807 40.3283C25.8173 40.3283 28.4815 38.8141 29.919 36.38C30.0915 36.0925 30.2449 35.8241 30.3599 35.5558C30.8774 34.5016 31.1265 33.3899 31.1265 32.2016C31.1457 27.6974 27.4848 24.0366 22.9998 24.0366Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M21.9074 35.5175C21.5432 35.5175 21.1791 35.3834 20.8916 35.0959L18.994 33.1984C18.4382 32.6425 18.4382 31.7225 18.994 31.1667C19.5499 30.6109 20.4699 30.6109 21.0257 31.1667L21.9458 32.0867L25.0124 29.25C25.6066 28.7134 26.5074 28.7517 27.044 29.3267C27.5807 29.9017 27.5424 30.8217 26.9674 31.3584L22.8849 35.1342C22.5974 35.3834 22.2524 35.5175 21.9074 35.5175Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/context/TxStatusContext.tsx\n// TxStatusContext.tsx\n"use client";\n\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }\nfunction _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction TxStatusContext_slicedToArray(r, e) { return TxStatusContext_arrayWithHoles(r) || TxStatusContext_iterableToArrayLimit(r, e) || TxStatusContext_unsupportedIterableToArray(r, e) || TxStatusContext_nonIterableRest(); }\nfunction TxStatusContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction TxStatusContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TxStatusContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TxStatusContext_arrayLikeToArray(r, a) : void 0; } }\nfunction TxStatusContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TxStatusContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction TxStatusContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\nvar TxStatusContext = /*#__PURE__*/(0,react.createContext)(undefined);\nvar TxStatusProvider = function TxStatusProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)({\n      isProcessing: false,\n      currentStep: "prepare/construct",\n      nextStep: "prepare/retrieve"\n    }),\n    _useState2 = TxStatusContext_slicedToArray(_useState, 2),\n    preparation = _useState2[0],\n    setPreparation = _useState2[1];\n  var _useState3 = (0,react.useState)({\n      isProcessing: false,\n      currentStep: "inscription/construct",\n      nextStep: "inscription/retrieve"\n    }),\n    _useState4 = TxStatusContext_slicedToArray(_useState3, 2),\n    inscription = _useState4[0],\n    setInscription = _useState4[1];\n  var setPreparationStatus = (0,react.useCallback)(function (status) {\n    setPreparation(function (prev) {\n      return _objectSpread(_objectSpread({}, prev), status);\n    });\n  }, []);\n  var setInscriptionStatus = (0,react.useCallback)(function (status) {\n    setInscription(function (prev) {\n      return _objectSpread(_objectSpread({}, prev), status);\n    });\n  }, []);\n  var moveToNextStep = function moveToNextStep(flow) {\n    if (flow === "preparation" && preparation.nextStep) {\n      var nextStepMap = {\n        "prepare/construct": "prepare/retrieve",\n        "prepare/retrieve": "prepare/submit",\n        "prepare/submit": "prepare/retrieve-submission",\n        "prepare/retrieve-submission": null\n      };\n      var currentStep = preparation.nextStep;\n      var nextStep = nextStepMap[currentStep];\n      setPreparationStatus({\n        currentStep: currentStep,\n        nextStep: nextStep\n      });\n    } else if (flow === "inscription" && inscription.nextStep) {\n      var _nextStepMap = {\n        "inscription/construct": "inscription/retrieve",\n        "inscription/retrieve": "inscription/submit",\n        "inscription/submit": "inscription/retrieve-submission",\n        "inscription/retrieve-submission": null\n      };\n      var _currentStep = inscription.nextStep;\n      var _nextStep = _nextStepMap[_currentStep];\n      setInscriptionStatus({\n        currentStep: _currentStep,\n        nextStep: _nextStep\n      });\n    } else if (flow === "end") {\n      // Al llegar al final, reiniciamos los estados\n      setPreparation({\n        isProcessing: false,\n        currentStep: "prepare/construct",\n        nextStep: "prepare/retrieve"\n      });\n      setInscription({\n        isProcessing: false,\n        currentStep: "inscription/construct",\n        nextStep: "inscription/retrieve"\n      });\n    }\n  };\n  var resetStatus = function resetStatus(flow) {\n    if (flow === "preparation") {\n      setPreparation({\n        isProcessing: false,\n        currentStep: "prepare/construct",\n        nextStep: "prepare/retrieve"\n      });\n    } else {\n      setInscription({\n        isProcessing: false,\n        currentStep: "inscription/construct",\n        nextStep: "inscription/retrieve"\n      });\n    }\n  };\n  return /*#__PURE__*/react.createElement(TxStatusContext.Provider, {\n    value: {\n      preparation: preparation,\n      inscription: inscription,\n      setPreparationStatus: setPreparationStatus,\n      setInscriptionStatus: setInscriptionStatus,\n      moveToNextStep: moveToNextStep,\n      resetStatus: resetStatus\n    }\n  }, children);\n};\nvar useTxStatus = function useTxStatus() {\n  var context = (0,react.useContext)(TxStatusContext);\n  if (!context) {\n    throw new Error("useTxStatus must be used within a TxStatusProvider");\n  }\n  return context;\n};\n;// ./src/components/uploader/upload-box.tsx\n"use client";\n\nfunction upload_box_slicedToArray(r, e) { return upload_box_arrayWithHoles(r) || upload_box_iterableToArrayLimit(r, e) || upload_box_unsupportedIterableToArray(r, e) || upload_box_nonIterableRest(); }\nfunction upload_box_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction upload_box_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return upload_box_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? upload_box_arrayLikeToArray(r, a) : void 0; } }\nfunction upload_box_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction upload_box_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction upload_box_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\nfunction UploadBox() {\n  var _useFileUpload = useFileUpload(),\n    addFile = _useFileUpload.addFile,\n    error = _useFileUpload.error;\n  var _useState = (0,react.useState)(false),\n    _useState2 = upload_box_slicedToArray(_useState, 2),\n    isDragging = _useState2[0],\n    setIsDragging = _useState2[1];\n  var _useState3 = (0,react.useState)(0),\n    _useState4 = upload_box_slicedToArray(_useState3, 2),\n    dragCounter = _useState4[0],\n    setDragCounter = _useState4[1];\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation;\n  var handleDragEnter = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragCounter(function (prev) {\n      return prev + 1;\n    });\n    setIsDragging(true);\n  }, []);\n  var handleDragLeave = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragCounter(function (prev) {\n      return prev - 1;\n    });\n    if (dragCounter === 0) {\n      setIsDragging(false);\n    }\n  }, [dragCounter]);\n  var handleDragOver = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n  }, []);\n  var handleDrop = (0,react.useCallback)(function (e) {\n    e.preventDefault();\n    e.stopPropagation();\n    setIsDragging(false);\n    setDragCounter(0);\n    var files = e.dataTransfer.files;\n    if (files && files.length > 0) {\n      var file = files[0];\n      if (file.size > 45 * 1024) {\n        // 45KB in bytes\n        alert("File too big");\n        return;\n      }\n      addFile(files);\n    }\n  }, [addFile]);\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "relative border-2 border-dashed border-white rounded-3xl p-12 text-center transition-all ".concat(isDragging ? "bg-white/20" : ""),\n    onDragEnter: handleDragEnter,\n    onDragLeave: handleDragLeave,\n    onDragOver: handleDragOver,\n    onDrop: handleDrop,\n    initial: {\n      opacity: 0,\n      y: 20\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement("input", {\n    type: "file",\n    id: "file-upload",\n    className: "absolute inset-0 w-full h-full opacity-0 ".concat(preparation.currentStep == "prepare/construct" ? "cursor-pointer" : "cursor-not-allowed", " "),\n    onChange: function onChange(e) {\n      if (e.target.files) {\n        var file = e.target.files[0];\n        if (file && file.size > 45 * 1024) {\n          // 45KB in bytes\n\n          return;\n        }\n        addFile(e.target.files);\n      }\n    },\n    accept: ".jpg,.jpeg,.png,.pdg,.mp4",\n    disabled: preparation.currentStep != "prepare/construct"\n  }), /*#__PURE__*/react.createElement(motion.div, {\n    className: "flex flex-col items-center gap-6",\n    whileHover: {\n      scale: 1.05\n    },\n    transition: {\n      type: "spring",\n      stiffness: 300\n    }\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-[2.875rem] h-[2.875rem] rounded-full flex items-center justify-center",\n    whileHover: {\n      rotate: 360\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement(UploadIcon, {\n    className: "w-full h-full text-white"\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4"\n  }, /*#__PURE__*/react.createElement(AnimatePresence, {\n    mode: "wait"\n  }, isDragging ? /*#__PURE__*/react.createElement(motion.p, {\n    key: "dragging",\n    className: "text-2xl font-medium !text-white",\n    initial: {\n      opacity: 0,\n      y: 10\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    exit: {\n      opacity: 0,\n      y: -10\n    },\n    transition: {\n      duration: 0.2\n    }\n  }, "Drop here your file") : /*#__PURE__*/react.createElement(motion.p, {\n    key: "not-dragging",\n    className: "text-2xl !text-white font-medium",\n    initial: {\n      opacity: 0,\n      y: 10\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    exit: {\n      opacity: 0,\n      y: -10\n    },\n    transition: {\n      duration: 0.2\n    }\n  }, "Choose a file or drag & drop it here")), /*#__PURE__*/react.createElement("p", {\n    className: "text-base text-light"\n  }, "JPEG, PNG, PDG, and MP4 formats, up to 45KB")), error && /*#__PURE__*/react.createElement(motion.p, {\n    className: "text-red-500 text-sm",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    transition: {\n      duration: 0.3\n    }\n  }, error)));\n}\n;// ./src/context/WalletContext.tsx\nfunction WalletContext_typeof(o) { "@babel/helpers - typeof"; return WalletContext_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, WalletContext_typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || WalletContext_unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return WalletContext_arrayLikeToArray(r); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == WalletContext_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(WalletContext_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction WalletContext_slicedToArray(r, e) { return WalletContext_arrayWithHoles(r) || WalletContext_iterableToArrayLimit(r, e) || WalletContext_unsupportedIterableToArray(r, e) || WalletContext_nonIterableRest(); }\nfunction WalletContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction WalletContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return WalletContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? WalletContext_arrayLikeToArray(r, a) : void 0; } }\nfunction WalletContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction WalletContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction WalletContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\nvar allSupportedWallets = {\n  /*   yoroi: {\n    name: "Yoroi",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efbed9abdf9cf7e01d4_YoroiWallet.png",\n    url: "https://yoroi-wallet.com/",\n  }, */\n  /*   flint: {\n      name: "Flint",\n      icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95d7c5fb03f2d4b32b3ed_FlintWallet.svg",\n      url: "https://flint-wallet.com/",\n    },\n  \n    eternl: {\n      name: "Eternl",\n      icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efca0ebecfedfca8599_EternlWallet.png",\n      url: "https://eternl.io/",\n    }, */\n  gero: {\n    name: "Gero",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efb91d542e643bf5ed4_GeroWallet.png",\n    url: "https://gerowallet.io/"\n  },\n  nufi: {\n    name: "Nufi",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efbbee1abc10aea26ad_NufiWallet.png",\n    url: "https://nu.fi/"\n  },\n  begin: {\n    name: "Begin",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efb08b6a125a4af479b_BeginWallet.png",\n    url: "https://begin.is/"\n  },\n  lace: {\n    name: "Lace",\n    icon: "https://uploads-ssl.webflow.com/66c3b779674915c288ca9998/66c95efbf25ef16633cdd528_LaceWallet.png",\n    url: "https://www.lace.io/"\n  }\n};\nvar WalletContext = /*#__PURE__*/(0,react.createContext)(undefined);\nfunction useWallet() {\n  var context = (0,react.useContext)(WalletContext);\n  if (context === undefined) {\n    throw new Error("useWallet must be used within a WalletProvider");\n  }\n  return context;\n}\nfunction WalletProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)(false),\n    _useState2 = WalletContext_slicedToArray(_useState, 2),\n    isMenuOpen = _useState2[0],\n    setIsMenuOpen = _useState2[1];\n  var _useState3 = (0,react.useState)([]),\n    _useState4 = WalletContext_slicedToArray(_useState3, 2),\n    connectedWallets = _useState4[0],\n    setConnectedWallets = _useState4[1];\n  var _useState5 = (0,react.useState)(localStorage.getItem("defaultWallet")),\n    _useState6 = WalletContext_slicedToArray(_useState5, 2),\n    defaultWallet = _useState6[0],\n    setDefaultWallet = _useState6[1];\n  var _useState7 = (0,react.useState)([]),\n    _useState8 = WalletContext_slicedToArray(_useState7, 2),\n    installedWallets = _useState8[0],\n    setInstalledWallets = _useState8[1];\n  var detectConnectedWallets = (0,react.useCallback)(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var cardano, connected, _i, _Object$entries, _Object$entries$_i, key, wallet, isEnabled, api;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          cardano = window.cardano;\n          if (cardano) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt("return");\n        case 3:\n          connected = [];\n          _i = 0, _Object$entries = Object.entries(allSupportedWallets);\n        case 5:\n          if (!(_i < _Object$entries.length)) {\n            _context.next = 25;\n            break;\n          }\n          _Object$entries$_i = WalletContext_slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], wallet = _Object$entries$_i[1];\n          if (!cardano[key]) {\n            _context.next = 22;\n            break;\n          }\n          _context.prev = 8;\n          _context.next = 11;\n          return cardano[key].isEnabled();\n        case 11:\n          isEnabled = _context.sent;\n          if (!isEnabled) {\n            _context.next = 17;\n            break;\n          }\n          _context.next = 15;\n          return cardano[key].enable();\n        case 15:\n          api = _context.sent;\n          connected.push({\n            name: wallet.name,\n            api: api\n          });\n        case 17:\n          _context.next = 22;\n          break;\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context["catch"](8);\n          console.error("Error detecting ".concat(wallet.name, " connection:"), _context.t0);\n        case 22:\n          _i++;\n          _context.next = 5;\n          break;\n        case 25:\n          setConnectedWallets(connected);\n        case 26:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[8, 19]]);\n  })), []);\n  var connectWallet = (0,react.useCallback)(/*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(walletName) {\n      var cardano, wallet, api;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            cardano = window.cardano;\n            if (cardano) {\n              _context2.next = 3;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 3:\n            wallet = cardano[walletName.toLowerCase()];\n            if (wallet) {\n              _context2.next = 6;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 6:\n            _context2.prev = 6;\n            _context2.next = 9;\n            return wallet.enable();\n          case 9:\n            api = _context2.sent;\n            console.log("Connected wallet:", walletName, api);\n            setConnectedWallets(function (prev) {\n              return [].concat(_toConsumableArray(prev), [{\n                name: walletName,\n                api: api\n              }]);\n            });\n            if (!defaultWallet) {\n              setDefaultWallet(walletName);\n              localStorage.setItem("defaultWallet", walletName);\n            }\n            _context2.next = 18;\n            break;\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2["catch"](6);\n            console.error("Error connecting wallet:", _context2.t0);\n          case 18:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[6, 15]]);\n    }));\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [defaultWallet]);\n  (0,react.useEffect)(function () {\n    if (!defaultWallet && connectedWallets.length > 0) {\n      setDefaultWallet(connectedWallets[0].name);\n    }\n  }, [defaultWallet, connectedWallets]);\n  var disconnectWallet = (0,react.useCallback)(function (walletName) {\n    setConnectedWallets(function (prev) {\n      return prev.filter(function (wallet) {\n        return wallet.name !== walletName;\n      });\n    });\n    if (defaultWallet === walletName) {\n      setDefaultWallet(null);\n      localStorage.removeItem("defaultWallet");\n    }\n  }, [defaultWallet]);\n  (0,react.useEffect)(function () {\n    console.log("defaultWallet", defaultWallet);\n  }, [defaultWallet]);\n  var handleSetDefaultWallet = (0,react.useCallback)(function (walletName) {\n    setDefaultWallet(walletName);\n    localStorage.setItem("defaultWallet", walletName);\n  }, []);\n  var openMenu = (0,react.useCallback)(function () {\n    return setIsMenuOpen(true);\n  }, []);\n  var closeMenu = (0,react.useCallback)(function () {\n    return setIsMenuOpen(false);\n  }, []);\n  var detectInstalledWallets = (0,react.useCallback)(function () {\n    var installed = Object.keys(allSupportedWallets).filter(function (key) {\n      return window.cardano && window.cardano[key];\n    });\n    setInstalledWallets(installed);\n  }, []);\n  var getWalletApi = (0,react.useCallback)(function (walletName) {\n    var wallet = connectedWallets.find(function (w) {\n      return w.name.toLowerCase() === walletName.toLowerCase();\n    });\n    return wallet ? wallet.api : null;\n  }, [connectedWallets]);\n  (0,react.useEffect)(function () {\n    detectInstalledWallets();\n    detectConnectedWallets();\n    window.addEventListener("cardano", detectInstalledWallets);\n    return function () {\n      return window.removeEventListener("cardano", detectInstalledWallets);\n    };\n  }, [detectInstalledWallets, detectConnectedWallets]);\n  return /*#__PURE__*/react.createElement(WalletContext.Provider, {\n    value: {\n      isMenuOpen: isMenuOpen,\n      openMenu: openMenu,\n      closeMenu: closeMenu,\n      wallets: allSupportedWallets,\n      connectedWallets: connectedWallets,\n      defaultWallet: defaultWallet,\n      connectWallet: connectWallet,\n      disconnectWallet: disconnectWallet,\n      setDefaultWallet: handleSetDefaultWallet,\n      installedWallets: installedWallets,\n      getWalletApi: getWalletApi\n    }\n  }, children);\n}\n;// ./src/utils/apiConsumption.ts\n/**\n * @author: Erick Hernández Silva (erick@yungle.com.mx)\n * @created: 01/01/2025\n * @updated: 01/01/2025       \n * @file fileUpload.ts\n */\n\n// Main path for the API\nvar API_PATH = "https://1rozp64iaj.execute-api.us-east-1.amazonaws.com/preproduction";\nfunction buildApiUrl(path) {\n  return "".concat(API_PATH).concat(path);\n}\nvar API_KEY = "ZfQ7BY7pbwAQGGq5FAON6AxLWfwMl729Qp3W5Fq6";\nfunction toHex(input) {\n  console.log(input);\n  var encoder = new TextEncoder();\n  var encodeToHex = function encodeToHex(str) {\n    return Array.from(encoder.encode(str)).map(function (_byte) {\n      return _byte.toString(16).padStart(2, \'0\');\n    }).join(\'\');\n  };\n  if (typeof input === \'string\') {\n    return encodeToHex(input);\n  } else {\n    return input.map(encodeToHex);\n  }\n}\nfunction base64ToHex(str) {\n  var raw = atob(str);\n  var result = \'\';\n  for (var i = 0; i < raw.length; i++) {\n    var hex = raw.charCodeAt(i).toString(16);\n    result += hex.length === 2 ? hex : \'0\' + hex;\n  }\n  return result.toUpperCase();\n}\nvar ENVIRONMENT =  false || \'preproduction\';\n;// ./src/context/TxPreparationContext.tsx\n"use client";\n\nfunction TxPreparationContext_typeof(o) { "@babel/helpers - typeof"; return TxPreparationContext_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, TxPreparationContext_typeof(o); }\nfunction TxPreparationContext_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ TxPreparationContext_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == TxPreparationContext_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(TxPreparationContext_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction TxPreparationContext_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction TxPreparationContext_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { TxPreparationContext_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { TxPreparationContext_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction TxPreparationContext_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction TxPreparationContext_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TxPreparationContext_ownKeys(Object(t), !0).forEach(function (r) { TxPreparationContext_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TxPreparationContext_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction TxPreparationContext_defineProperty(e, r, t) { return (r = TxPreparationContext_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction TxPreparationContext_toPropertyKey(t) { var i = TxPreparationContext_toPrimitive(t, "string"); return "symbol" == TxPreparationContext_typeof(i) ? i : i + ""; }\nfunction TxPreparationContext_toPrimitive(t, r) { if ("object" != TxPreparationContext_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != TxPreparationContext_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction TxPreparationContext_slicedToArray(r, e) { return TxPreparationContext_arrayWithHoles(r) || TxPreparationContext_iterableToArrayLimit(r, e) || TxPreparationContext_unsupportedIterableToArray(r, e) || TxPreparationContext_nonIterableRest(); }\nfunction TxPreparationContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction TxPreparationContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TxPreparationContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TxPreparationContext_arrayLikeToArray(r, a) : void 0; } }\nfunction TxPreparationContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TxPreparationContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction TxPreparationContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\nvar TxPreparationContext = /*#__PURE__*/(0,react.createContext)(undefined);\nfunction useTxPreparation() {\n  var context = (0,react.useContext)(TxPreparationContext);\n  if (!context) {\n    throw new Error("useTxPreparation must be used within a TxPreparationProvider");\n  }\n  return context;\n}\nfunction TxPreparationProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)([]),\n    _useState2 = TxPreparationContext_slicedToArray(_useState, 2),\n    fileProgress = _useState2[0],\n    setFileProgress = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = TxPreparationContext_slicedToArray(_useState3, 2),\n    isProcessing = _useState4[0],\n    setIsProcessing = _useState4[1];\n  var _useState5 = (0,react.useState)(null),\n    _useState6 = TxPreparationContext_slicedToArray(_useState5, 2),\n    error = _useState6[0],\n    setError = _useState6[1];\n  var _useWallet = useWallet(),\n    getWalletApi = _useWallet.getWalletApi,\n    defaultWallet = _useWallet.defaultWallet;\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation,\n    moveToNextStep = _useTxStatus.moveToNextStep;\n  var _useState7 = (0,react.useState)(),\n    _useState8 = TxPreparationContext_slicedToArray(_useState7, 2),\n    submissionStatus = _useState8[0],\n    setSubmissionStatus = _useState8[1];\n  var _useState9 = (0,react.useState)(null),\n    _useState10 = TxPreparationContext_slicedToArray(_useState9, 2),\n    unsignedTxId = _useState10[0],\n    setUnsignedTxId = _useState10[1];\n  var updateFileProgress = (0,react.useCallback)(function (index, updates) {\n    setFileProgress(function (prev) {\n      return prev.map(function (item, i) {\n        return i === index ? TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, item), updates) : item;\n      });\n    });\n  }, []);\n  var clearError = (0,react.useCallback)(function () {\n    setError(null);\n  }, []);\n  var constructTx = /*#__PURE__*/function () {\n    var _ref2 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee(api, data, dataType) {\n      var rewardAddresses, utxos, targetAddress, body, response, errorData, errorResponse;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return api.getRewardAddresses();\n          case 2:\n            rewardAddresses = _context.sent;\n            _context.next = 5;\n            return api.getUtxos();\n          case 5:\n            _context.t0 = _context.sent;\n            if (_context.t0) {\n              _context.next = 8;\n              break;\n            }\n            _context.t0 = [];\n          case 8:\n            utxos = _context.t0;\n            console.log("UTXOs:", utxos);\n            _context.next = 12;\n            return api.getUsedAddresses();\n          case 12:\n            targetAddress = _context.sent[0];\n            if (!(!utxos || utxos.length === 0)) {\n              _context.next = 16;\n              break;\n            }\n            setError("No hay UTXOs disponibles");\n            throw new Error("No UTXOs available");\n          case 16:\n            body = {\n              data: data,\n              dataType: dataType,\n              rewardAddresses: rewardAddresses,\n              targetAddress: targetAddress,\n              utxos: utxos\n            };\n            console.log("Body:", body);\n            _context.next = 20;\n            return fetch(buildApiUrl("/prepare-utxos/construct-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(body)\n            });\n          case 20:\n            response = _context.sent;\n            if (response.ok) {\n              _context.next = 35;\n              break;\n            }\n            _context.prev = 22;\n            errorResponse = response.clone();\n            _context.next = 26;\n            return errorResponse.json();\n          case 26:\n            errorData = _context.sent;\n            _context.next = 34;\n            break;\n          case 29:\n            _context.prev = 29;\n            _context.t1 = _context["catch"](22);\n            _context.next = 33;\n            return response.text();\n          case 33:\n            errorData = _context.sent;\n          case 34:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/prepare-utxos/construct-tx"\n            }));\n          case 35:\n            // Se avanza al siguiente paso en el flujo de preparación\n            moveToNextStep("preparation");\n            _context.next = 38;\n            return response.json();\n          case 38:\n            return _context.abrupt("return", _context.sent);\n          case 39:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee, null, [[22, 29]]);\n    }));\n    return function constructTx(_x, _x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var prepareFiles = /*#__PURE__*/function () {\n    var _ref3 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee2(files) {\n      var api, _loop, i;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee2$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            if (defaultWallet) {\n              _context3.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context3.prev = 4;\n            setFileProgress(files.map(function (file) {\n              return {\n                file: file,\n                status: "pending",\n                progress: 0\n              };\n            }));\n            _loop = /*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _loop(i) {\n              var reader, fileAsBase64, base64Content, constructedTx;\n              return TxPreparationContext_regeneratorRuntime().wrap(function _loop$(_context2) {\n                while (1) switch (_context2.prev = _context2.next) {\n                  case 0:\n                    updateFileProgress(i, {\n                      status: "constructing",\n                      progress: 25\n                    });\n                    reader = new FileReader();\n                    _context2.next = 4;\n                    return new Promise(function (resolve, reject) {\n                      reader.onload = function () {\n                        return resolve(reader.result);\n                      };\n                      reader.onerror = reject;\n                      reader.readAsDataURL(files[i]);\n                    });\n                  case 4:\n                    fileAsBase64 = _context2.sent;\n                    base64Content = fileAsBase64.split(",")[1];\n                    _context2.next = 8;\n                    return constructTx(api, base64Content, files[i].type);\n                  case 8:\n                    constructedTx = _context2.sent;\n                    updateFileProgress(0, {\n                      status: "unsigned",\n                      progress: 50,\n                      txInfo: {\n                        constructedTx: constructedTx\n                      }\n                    });\n                  case 10:\n                  case "end":\n                    return _context2.stop();\n                }\n              }, _loop);\n            });\n            i = 0;\n          case 8:\n            if (!(i < files.length)) {\n              _context3.next = 13;\n              break;\n            }\n            return _context3.delegateYield(_loop(i), "t0", 10);\n          case 10:\n            i++;\n            _context3.next = 8;\n            break;\n          case 13:\n            moveToNextStep("preparation");\n            _context3.next = 20;\n            break;\n          case 16:\n            _context3.prev = 16;\n            _context3.t1 = _context3["catch"](4);\n            console.error("Error preparing files:", _context3.t1);\n            setError(_context3.t1 instanceof Error ? _context3.t1.message : JSON.stringify(_context3.t1));\n          case 20:\n            _context3.prev = 20;\n            setIsProcessing(false);\n            return _context3.finish(20);\n          case 23:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee2, null, [[4, 16, 20, 23]]);\n    }));\n    return function prepareFiles(_x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var prepareText = /*#__PURE__*/function () {\n    var _ref4 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee3(text) {\n      var api, textFile, base64Content, constructedTx;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee3$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            if (defaultWallet) {\n              _context4.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context4.prev = 4;\n            textFile = new File([text], "delegate.txt", {\n              type: "text/plain"\n            });\n            setFileProgress([{\n              file: textFile,\n              status: "pending",\n              progress: 0\n            }]);\n            updateFileProgress(0, {\n              status: "constructing",\n              progress: 25\n            });\n            console.log("text", text);\n            base64Content = btoa(unescape(encodeURIComponent(text)));\n            console.log("base64Content", base64Content);\n            _context4.next = 13;\n            return constructTx(api, base64Content, "text/plain");\n          case 13:\n            constructedTx = _context4.sent;\n            console.log("constructedTx", constructedTx);\n            updateFileProgress(0, {\n              status: "unsigned",\n              progress: 50,\n              txInfo: {\n                constructedTx: constructedTx\n              }\n            });\n            moveToNextStep("preparation");\n            _context4.next = 23;\n            break;\n          case 19:\n            _context4.prev = 19;\n            _context4.t0 = _context4["catch"](4);\n            console.error("Error preparing text:", _context4.t0);\n            setError(_context4.t0 instanceof Error ? _context4.t0.message : JSON.stringify(_context4.t0));\n          case 23:\n            _context4.prev = 23;\n            setIsProcessing(false);\n            return _context4.finish(23);\n          case 26:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee3, null, [[4, 19, 23, 26]]);\n    }));\n    return function prepareText(_x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var pollForConfirmation = /*#__PURE__*/function () {\n    var _ref5 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee4(preparedTx) {\n      var retryInterval, response, errorData, errorResponse, status;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee4$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            retryInterval = 9000;\n          case 1:\n            if (false) {}\n            _context5.prev = 2;\n            _context5.next = 5;\n            return fetch(buildApiUrl("/prepare-utxos/retrieve-submission-status"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(preparedTx.executionArn)\n            });\n          case 5:\n            response = _context5.sent;\n            if (response.ok) {\n              _context5.next = 21;\n              break;\n            }\n            errorData = void 0;\n            _context5.prev = 8;\n            errorResponse = response.clone();\n            _context5.next = 12;\n            return errorResponse.json();\n          case 12:\n            errorData = _context5.sent;\n            _context5.next = 20;\n            break;\n          case 15:\n            _context5.prev = 15;\n            _context5.t0 = _context5["catch"](8);\n            _context5.next = 19;\n            return response.text();\n          case 19:\n            errorData = _context5.sent;\n          case 20:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/prepare-utxos/retrieve-submission-status"\n            }));\n          case 21:\n            _context5.next = 23;\n            return response.json();\n          case 23:\n            status = _context5.sent;\n            if (!(status.success && status.success.onchain === "on-chain")) {\n              _context5.next = 30;\n              break;\n            }\n            setSubmissionStatus(status);\n            setIsProcessing(false);\n            moveToNextStep("preparation");\n            clearError();\n            return _context5.abrupt("return", true);\n          case 30:\n            _context5.next = 32;\n            return new Promise(function (res) {\n              return setTimeout(res, retryInterval);\n            });\n          case 32:\n            _context5.next = 39;\n            break;\n          case 34:\n            _context5.prev = 34;\n            _context5.t1 = _context5["catch"](2);\n            console.error("Polling attempt failed:", _context5.t1);\n            setError(_context5.t1 instanceof Error ? _context5.t1.message : JSON.stringify(_context5.t1));\n            throw _context5.t1;\n          case 39:\n            _context5.next = 1;\n            break;\n          case 41:\n          case "end":\n            return _context5.stop();\n        }\n      }, _callee4, null, [[2, 34], [8, 15]]);\n    }));\n    return function pollForConfirmation(_x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitError = function handleSignAndSubmitError(error) {\n    console.error("Error in sign and submit:", error);\n\n    // Format the error message based on the error type\n    var errorMessage;\n\n    // Handle TxSignError from wallet\n    if (error && error.name === "TxSignError") {\n      errorMessage = "Wallet signing error: ".concat(error.info || error.message || "Failed to sign transaction");\n    }\n    // Handle Error objects\n    else if (error instanceof Error) {\n      try {\n        var _parsedError$error;\n        // Try to parse the error message as JSON\n        var parsedError = JSON.parse(error.message);\n        errorMessage = ((_parsedError$error = parsedError.error) === null || _parsedError$error === void 0 ? void 0 : _parsedError$error.message) || parsedError.message || error.message;\n      } catch (e) {\n        // If parsing fails, use the original error message\n        errorMessage = error.message || "Unknown error occurred";\n      }\n    }\n    // Handle other error types\n    else {\n      try {\n        errorMessage = JSON.stringify(error);\n      } catch (e) {\n        errorMessage = "Unknown error occurred";\n      }\n    }\n    setError(errorMessage);\n    setFileProgress(function (prev) {\n      return prev.map(function (file) {\n        return TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file), {}, {\n          status: "failed",\n          progress: 0\n        });\n      });\n    });\n    // Don\'t reset the step to the beginning for wallet signing errors\n    // This allows users to retry from the current step\n    if (error && error.name === "TxSignError") {\n      console.log("Wallet signing error detected, keeping current step");\n      // Just set processing to false but don\'t change the step\n      setIsProcessing(false);\n    } else {\n      // For other errors, we can reset processing state\n      setIsProcessing(false);\n    }\n  };\n  var signAndSubmit = /*#__PURE__*/function () {\n    var _ref6 = TxPreparationContext_asyncToGenerator(/*#__PURE__*/TxPreparationContext_regeneratorRuntime().mark(function _callee5() {\n      var i, _file$txInfo, file, executionArn, unsignedTxResponse, errorData, errorResponse, unsignedTx, retryResponse, _errorData, _errorResponse, hexTx, signedTx, api, submitResponse, _errorData2, _errorResponse2, submittedTx, confirmed;\n      return TxPreparationContext_regeneratorRuntime().wrap(function _callee5$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            if (defaultWallet) {\n              _context6.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            setIsProcessing(true);\n            _context6.prev = 3;\n            i = 0;\n          case 5:\n            if (!(i < fileProgress.length)) {\n              _context6.next = 118;\n              break;\n            }\n            file = fileProgress[i];\n            console.log("file", file);\n            if ((_file$txInfo = file.txInfo) !== null && _file$txInfo !== void 0 && _file$txInfo.constructedTx) {\n              _context6.next = 10;\n              break;\n            }\n            return _context6.abrupt("continue", 115);\n          case 10:\n            executionArn = file.txInfo.constructedTx.executionArn;\n            console.log("executionArn", executionArn);\n            _context6.next = 14;\n            return fetch(buildApiUrl("/prepare-utxos/retrieve-unsigned-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(executionArn)\n            });\n          case 14:\n            unsignedTxResponse = _context6.sent;\n            if (unsignedTxResponse.ok) {\n              _context6.next = 30;\n              break;\n            }\n            errorData = void 0;\n            _context6.prev = 17;\n            errorResponse = unsignedTxResponse.clone();\n            _context6.next = 21;\n            return errorResponse.json();\n          case 21:\n            errorData = _context6.sent;\n            _context6.next = 29;\n            break;\n          case 24:\n            _context6.prev = 24;\n            _context6.t0 = _context6["catch"](17);\n            _context6.next = 28;\n            return unsignedTxResponse.text();\n          case 28:\n            errorData = _context6.sent;\n          case 29:\n            throw new Error(JSON.stringify({\n              status: unsignedTxResponse.status,\n              statusText: unsignedTxResponse.statusText,\n              error: errorData,\n              endpoint: "/prepare-utxos/retrieve-unsigned-tx"\n            }));\n          case 30:\n            _context6.next = 32;\n            return unsignedTxResponse.json();\n          case 32:\n            unsignedTx = _context6.sent;\n            console.log("Unsigned TX:", unsignedTx);\n\n            // Guardar el txid cuando está disponible\n            if (unsignedTx.success && unsignedTx.success.txid) {\n              setUnsignedTxId(unsignedTx.success.txid);\n            }\n            if (!unsignedTx.inProgress) {\n              _context6.next = 64;\n              break;\n            }\n          case 36:\n            if (!unsignedTx.inProgress) {\n              _context6.next = 64;\n              break;\n            }\n            console.log("Unsigned transaction still in progress...");\n            _context6.next = 40;\n            return new Promise(function (res) {\n              return setTimeout(res, 5000);\n            });\n          case 40:\n            _context6.next = 42;\n            return fetch(buildApiUrl("/prepare-utxos/retrieve-unsigned-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(executionArn)\n            });\n          case 42:\n            retryResponse = _context6.sent;\n            if (retryResponse.ok) {\n              _context6.next = 58;\n              break;\n            }\n            _errorData = void 0;\n            _context6.prev = 45;\n            _errorResponse = retryResponse.clone();\n            _context6.next = 49;\n            return _errorResponse.json();\n          case 49:\n            _errorData = _context6.sent;\n            _context6.next = 57;\n            break;\n          case 52:\n            _context6.prev = 52;\n            _context6.t1 = _context6["catch"](45);\n            _context6.next = 56;\n            return retryResponse.text();\n          case 56:\n            _errorData = _context6.sent;\n          case 57:\n            throw new Error(JSON.stringify({\n              status: retryResponse.status,\n              statusText: retryResponse.statusText,\n              error: _errorData,\n              endpoint: "/prepare-utxos/retrieve-unsigned-tx"\n            }));\n          case 58:\n            _context6.next = 60;\n            return retryResponse.json();\n          case 60:\n            unsignedTx = _context6.sent;\n            console.log("Retry Unsigned TX:", unsignedTx);\n            _context6.next = 36;\n            break;\n          case 64:\n            updateFileProgress(i, {\n              progress: 75,\n              txInfo: TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file.txInfo), {}, {\n                unsignedTx: unsignedTx\n              })\n            });\n            hexTx = base64ToHex(unsignedTx.success.tx);\n            console.log("Hex TX:", hexTx);\n            signedTx = void 0;\n            _context6.prev = 68;\n            // Clear any previous error state before attempting to sign again\n            clearError();\n\n            // Get a fresh wallet API instance to ensure the popup appears again\n            api = getWalletApi(defaultWallet);\n            _context6.next = 73;\n            return api.signTx(hexTx);\n          case 73:\n            signedTx = _context6.sent;\n            console.log("Signed TX:", signedTx);\n            updateFileProgress(i, {\n              status: "signed",\n              progress: 85,\n              txInfo: TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file.txInfo), {}, {\n                unsignedTx: unsignedTx,\n                signedTx: signedTx\n              })\n            });\n            // Move to the next step only after successful signing\n            moveToNextStep("preparation");\n            _context6.next = 87;\n            break;\n          case 79:\n            _context6.prev = 79;\n            _context6.t2 = _context6["catch"](68);\n            console.error("Error signing transaction:", _context6.t2);\n            // Don\'t move to the next step if there\'s a signing error\n            // This allows the user to retry signing from the same step\n            if (!(_context6.t2 && _context6.t2.name === "TxSignError")) {\n              _context6.next = 86;\n              break;\n            }\n            throw _context6.t2;\n          case 86:\n            throw new Error("Failed to sign transaction: ".concat(_context6.t2.message || JSON.stringify(_context6.t2)));\n          case 87:\n            _context6.next = 89;\n            return fetch(buildApiUrl("/prepare-utxos/submit"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify({\n                tx: unsignedTx.success.tx,\n                ulid: unsignedTx.success.ulid,\n                witnessSet: signedTx\n              })\n            });\n          case 89:\n            submitResponse = _context6.sent;\n            if (submitResponse.ok) {\n              _context6.next = 105;\n              break;\n            }\n            _errorData2 = void 0;\n            _context6.prev = 92;\n            _errorResponse2 = submitResponse.clone();\n            _context6.next = 96;\n            return _errorResponse2.json();\n          case 96:\n            _errorData2 = _context6.sent;\n            _context6.next = 104;\n            break;\n          case 99:\n            _context6.prev = 99;\n            _context6.t3 = _context6["catch"](92);\n            _context6.next = 103;\n            return submitResponse.text();\n          case 103:\n            _errorData2 = _context6.sent;\n          case 104:\n            throw new Error(JSON.stringify({\n              status: submitResponse.status,\n              statusText: submitResponse.statusText,\n              error: _errorData2,\n              endpoint: "/prepare-utxos/submit"\n            }));\n          case 105:\n            _context6.next = 107;\n            return submitResponse.json();\n          case 107:\n            submittedTx = _context6.sent;\n            console.log("Submitted TX:", submittedTx);\n            // Move to the next step after successful submission\n            moveToNextStep("preparation");\n            updateFileProgress(i, {\n              status: "submitted",\n              progress: 95,\n              txInfo: TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file.txInfo), {}, {\n                unsignedTx: unsignedTx,\n                signedTx: signedTx,\n                submittedTx: submittedTx\n              })\n            });\n            _context6.next = 113;\n            return pollForConfirmation(submittedTx);\n          case 113:\n            confirmed = _context6.sent;\n            updateFileProgress(i, {\n              status: confirmed ? "confirmed" : "failed",\n              progress: confirmed ? 100 : 0\n            });\n          case 115:\n            i++;\n            _context6.next = 5;\n            break;\n          case 118:\n            _context6.next = 123;\n            break;\n          case 120:\n            _context6.prev = 120;\n            _context6.t4 = _context6["catch"](3);\n            handleSignAndSubmitError(_context6.t4);\n          case 123:\n            _context6.prev = 123;\n            setIsProcessing(false);\n            return _context6.finish(123);\n          case 126:\n          case "end":\n            return _context6.stop();\n        }\n      }, _callee5, null, [[3, 120, 123, 126], [17, 24], [45, 52], [68, 79], [92, 99]]);\n    }));\n    return function signAndSubmit() {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  var reset = (0,react.useCallback)(function () {\n    setFileProgress([]);\n    setIsProcessing(false);\n    setSubmissionStatus(undefined);\n    setUnsignedTxId(null);\n    setError(null);\n  }, []);\n  (0,react.useEffect)(function () {\n    if (error) {\n      console.log("Error detected in TxPreparationContext:", error);\n\n      // Update all file progress to failed status when an error occurs\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxPreparationContext_objectSpread(TxPreparationContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n\n      // Ensure processing state is reset\n      setIsProcessing(false);\n    }\n  }, [error]);\n  return /*#__PURE__*/react.createElement(TxPreparationContext.Provider, {\n    value: {\n      fileProgress: fileProgress,\n      prepareFiles: prepareFiles,\n      prepareText: prepareText,\n      signAndSubmit: signAndSubmit,\n      isProcessing: isProcessing,\n      currentStep: preparation.currentStep,\n      nextStep: preparation.nextStep,\n      error: error,\n      clearError: clearError,\n      reset: reset,\n      submissionStatus: submissionStatus,\n      setSubmissionStatus: setSubmissionStatus,\n      unsignedTxId: unsignedTxId,\n      setUnsignedTxId: setUnsignedTxId\n    }\n  }, children);\n}\n;// ./src/icons/CloseIcon.tsx\n\nvar CloseIcon = function CloseIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "30",\n    height: "30",\n    viewBox: "0 0 30 30",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M15 28.4375C7.5875 28.4375 1.5625 22.4125 1.5625 15C1.5625 7.5875 7.5875 1.5625 15 1.5625C22.4125 1.5625 28.4375 7.5875 28.4375 15C28.4375 22.4125 22.4125 28.4375 15 28.4375ZM15 3.4375C8.625 3.4375 3.4375 8.625 3.4375 15C3.4375 21.375 8.625 26.5625 15 26.5625C21.375 26.5625 26.5625 21.375 26.5625 15C26.5625 8.625 21.375 3.4375 15 3.4375Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M11.4627 19.475C11.2252 19.475 10.9877 19.3875 10.8002 19.2C10.4377 18.8375 10.4377 18.2375 10.8002 17.875L17.8752 10.8C18.2377 10.4375 18.8377 10.4375 19.2002 10.8C19.5627 11.1625 19.5627 11.7625 19.2002 12.125L12.1252 19.2C11.9502 19.3875 11.7002 19.475 11.4627 19.475Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M18.5377 19.475C18.3002 19.475 18.0627 19.3875 17.8752 19.2L10.8002 12.125C10.4377 11.7625 10.4377 11.1625 10.8002 10.8C11.1627 10.4375 11.7627 10.4375 12.1252 10.8L19.2002 17.875C19.5627 18.2375 19.5627 18.8375 19.2002 19.2C19.0127 19.3875 18.7752 19.475 18.5377 19.475Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/components/ui/Button.tsx\nfunction Button_typeof(o) { "@babel/helpers - typeof"; return Button_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, Button_typeof(o); }\nvar _excluded = ["children", "variant", "loadingText", "successText", "iconBefore", "iconAfter", "onClick", "animate", "className"];\nfunction _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }\nfunction Button_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ Button_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == Button_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(Button_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction Button_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction Button_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { Button_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { Button_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction Button_slicedToArray(r, e) { return Button_arrayWithHoles(r) || Button_iterableToArrayLimit(r, e) || Button_unsupportedIterableToArray(r, e) || Button_nonIterableRest(); }\nfunction Button_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction Button_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return Button_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? Button_arrayLikeToArray(r, a) : void 0; } }\nfunction Button_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction Button_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction Button_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }\nfunction _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }\n\n\n\nvar Button = function Button(_ref) {\n  var children = _ref.children,\n    _ref$variant = _ref.variant,\n    variant = _ref$variant === void 0 ? "primary" : _ref$variant,\n    loadingText = _ref.loadingText,\n    successText = _ref.successText,\n    iconBefore = _ref.iconBefore,\n    iconAfter = _ref.iconAfter,\n    onClick = _ref.onClick,\n    _ref$animate = _ref.animate,\n    animate = _ref$animate === void 0 ? true : _ref$animate,\n    _ref$className = _ref.className,\n    className = _ref$className === void 0 ? "" : _ref$className,\n    props = _objectWithoutProperties(_ref, _excluded);\n  var _useState = (0,react.useState)(false),\n    _useState2 = Button_slicedToArray(_useState, 2),\n    isLoading = _useState2[0],\n    setIsLoading = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = Button_slicedToArray(_useState3, 2),\n    isSuccess = _useState4[0],\n    setIsSuccess = _useState4[1];\n  var handleClick = /*#__PURE__*/function () {\n    var _ref2 = Button_asyncToGenerator(/*#__PURE__*/Button_regeneratorRuntime().mark(function _callee(event) {\n      return Button_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!onClick) {\n              _context.next = 7;\n              break;\n            }\n            setIsLoading(animate);\n            _context.next = 4;\n            return onClick(event);\n          case 4:\n            setIsLoading(false);\n            setIsSuccess(animate);\n            setTimeout(function () {\n              return setIsSuccess(false);\n            }, 2000);\n          case 7:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function handleClick(_x) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var baseClasses = "!flex !justify-center !items-center !gap-2 !rounded-full !transition-colors !duration-300 !focus:outline-none !font-bold cursor-pointer";\n  var variantClasses = {\n    primary: "!border !border-white !bg-white !text-primary-tw hover:!bg-transparent hover:!text-white",\n    secondary: "!border !border-white !bg-transparent !text-white hover:!text-white",\n    ghost: "!bg-transparent !text-white hover:!bg-white/10",\n    icon: "!rounded-full !w-10 !h-10 !p-2"\n  };\n  var disabledClasses = "!opacity-50 !cursor-not-allowed";\n  var sizeClasses = variant === "icon" ? "" : "px-5 py-2";\n  var buttonClasses = "".concat(baseClasses, " ").concat(variantClasses[variant], " ").concat(sizeClasses, " ").concat(className, " ").concat(props.disabled ? disabledClasses : "");\n  return /*#__PURE__*/react.createElement(motion.button, _extends({\n    className: buttonClasses,\n    onClick: handleClick,\n    whileTap: {\n      scale: 0.95\n    }\n  }, props), isLoading ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-5 h-5 border-t-2 border-b-2 border-current rounded-full",\n    animate: {\n      rotate: 360\n    },\n    transition: {\n      duration: 1,\n      repeat: Number.POSITIVE_INFINITY,\n      ease: "linear"\n    }\n  }), loadingText) : isSuccess ? /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(motion.div, {\n    initial: {\n      scale: 0\n    },\n    animate: {\n      scale: 1\n    },\n    transition: {\n      type: "spring",\n      stiffness: 500,\n      damping: 30\n    }\n  }, "\\u2713"), successText) : /*#__PURE__*/react.createElement(react.Fragment, null, iconBefore, Array.isArray(children) ? children.map(function (child, index) {\n    return child instanceof MotionValue ? /*#__PURE__*/react.createElement(motion.span, {\n      key: index\n    }, child) : child;\n  }) : children instanceof MotionValue ? /*#__PURE__*/react.createElement(motion.span, null, children) : children, iconAfter));\n};\n;// ./src/icons/PdfIcon.tsx\n\nvar PdfIcon = function PdfIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M42 28.5C42 28.8978 41.842 29.2794 41.5607 29.5607C41.2794 29.842 40.8978 30 40.5 30H36V33H39C39.3978 33 39.7794 33.158 40.0607 33.4393C40.342 33.7206 40.5 34.1022 40.5 34.5C40.5 34.8978 40.342 35.2794 40.0607 35.5607C39.7794 35.842 39.3978 36 39 36H36V39C36 39.3978 35.842 39.7794 35.5607 40.0607C35.2794 40.342 34.8978 40.5 34.5 40.5C34.1022 40.5 33.7206 40.342 33.4393 40.0607C33.158 39.7794 33 39.3978 33 39V28.5C33 28.1022 33.158 27.7206 33.4393 27.4393C33.7206 27.158 34.1022 27 34.5 27H40.5C40.8978 27 41.2794 27.158 41.5607 27.4393C41.842 27.7206 42 28.1022 42 28.5ZM17.25 32.25C17.25 33.6424 16.6969 34.9777 15.7123 35.9623C14.7277 36.9469 13.3924 37.5 12 37.5H10.5V39C10.5 39.3978 10.342 39.7794 10.0607 40.0607C9.77936 40.342 9.39782 40.5 9 40.5C8.60218 40.5 8.22064 40.342 7.93934 40.0607C7.65804 39.7794 7.5 39.3978 7.5 39V28.5C7.5 28.1022 7.65804 27.7206 7.93934 27.4393C8.22064 27.158 8.60218 27 9 27H12C13.3924 27 14.7277 27.5531 15.7123 28.5377C16.6969 29.5223 17.25 30.8576 17.25 32.25ZM14.25 32.25C14.25 31.6533 14.0129 31.081 13.591 30.659C13.169 30.2371 12.5967 30 12 30H10.5V34.5H12C12.5967 34.5 13.169 34.2629 13.591 33.841C14.0129 33.419 14.25 32.8467 14.25 32.25ZM30.75 33.75C30.75 35.5402 30.0388 37.2571 28.773 38.523C27.5071 39.7888 25.7902 40.5 24 40.5H21C20.6022 40.5 20.2206 40.342 19.9393 40.0607C19.658 39.7794 19.5 39.3978 19.5 39V28.5C19.5 28.1022 19.658 27.7206 19.9393 27.4393C20.2206 27.158 20.6022 27 21 27H24C25.7902 27 27.5071 27.7112 28.773 28.977C30.0388 30.2429 30.75 31.9598 30.75 33.75ZM27.75 33.75C27.75 32.7554 27.3549 31.8016 26.6516 31.0984C25.9484 30.3951 24.9946 30 24 30H22.5V37.5H24C24.9946 37.5 25.9484 37.1049 26.6516 36.4016C27.3549 35.6984 27.75 34.7446 27.75 33.75ZM7.5 21V7.5C7.5 6.70435 7.81607 5.94129 8.37868 5.37868C8.94129 4.81607 9.70435 4.5 10.5 4.5H28.5C28.697 4.49985 28.8922 4.53851 29.0743 4.6138C29.2564 4.68908 29.4218 4.7995 29.5613 4.93875L40.0612 15.4388C40.2005 15.5782 40.3109 15.7436 40.3862 15.9257C40.4615 16.1078 40.5002 16.303 40.5 16.5V21C40.5 21.3978 40.342 21.7794 40.0607 22.0607C39.7794 22.342 39.3978 22.5 39 22.5C38.6022 22.5 38.2206 22.342 37.9393 22.0607C37.658 21.7794 37.5 21.3978 37.5 21V18H28.5C28.1022 18 27.7206 17.842 27.4393 17.5607C27.158 17.2794 27 16.8978 27 16.5V7.5H10.5V21C10.5 21.3978 10.342 21.7794 10.0607 22.0607C9.77936 22.342 9.39782 22.5 9 22.5C8.60218 22.5 8.22064 22.342 7.93934 22.0607C7.65804 21.7794 7.5 21.3978 7.5 21ZM30 15H35.3794L30 9.62063V15Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/icons/PngIcon.tsx\n\nvar PngIcon = function PngIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M11.25 27H8.25C7.85218 27 7.47064 27.158 7.18934 27.4393C6.90804 27.7206 6.75 28.1022 6.75 28.5V39C6.75 39.3978 6.90804 39.7794 7.18934 40.0607C7.47064 40.342 7.85218 40.5 8.25 40.5C8.64782 40.5 9.02936 40.342 9.31066 40.0607C9.59196 39.7794 9.75 39.3978 9.75 39V37.5H11.25C12.6424 37.5 13.9777 36.9469 14.9623 35.9623C15.9469 34.9777 16.5 33.6424 16.5 32.25C16.5 30.8576 15.9469 29.5223 14.9623 28.5377C13.9777 27.5531 12.6424 27 11.25 27ZM11.25 34.5H9.75V30H11.25C11.8467 30 12.419 30.2371 12.841 30.659C13.2629 31.081 13.5 31.6533 13.5 32.25C13.5 32.8467 13.2629 33.419 12.841 33.841C12.419 34.2629 11.8467 34.5 11.25 34.5ZM42 37.6631C42 38.0495 41.8508 38.4209 41.5837 38.7C41.0615 39.2622 40.4298 39.7119 39.7276 40.0214C39.0254 40.3309 38.2674 40.4938 37.5 40.5C34.1906 40.5 31.5 37.4719 31.5 33.75C31.5 30.0281 34.1906 27 37.5 27C38.6026 27.0037 39.6788 27.3374 40.59 27.9581C40.9199 28.1819 41.1475 28.5276 41.2226 28.9191C41.2976 29.3107 41.2141 29.716 40.9903 30.0459C40.7665 30.3759 40.4209 30.6034 40.0293 30.6785C39.6378 30.7536 39.2324 30.67 38.9025 30.4463C38.4911 30.1587 38.0019 30.0031 37.5 30C35.8463 30 34.5 31.6875 34.5 33.75C34.5 35.8125 35.8463 37.5 37.5 37.5C38.0415 37.494 38.567 37.3153 39 36.99V36C38.6022 36 38.2206 35.842 37.9393 35.5607C37.658 35.2794 37.5 34.8978 37.5 34.5C37.5 34.1022 37.658 33.7206 37.9393 33.4393C38.2206 33.158 38.6022 33 39 33H40.5C40.8978 33 41.2794 33.158 41.5607 33.4393C41.842 33.7206 42 34.1022 42 34.5V37.6631ZM29.25 28.5V39C29.25 39.3179 29.1491 39.6276 28.9617 39.8844C28.7744 40.1412 28.5102 40.3318 28.2075 40.4288C28.0597 40.4763 27.9053 40.5004 27.75 40.5C27.5112 40.5 27.2759 40.443 27.0636 40.3338C26.8513 40.2245 26.6682 40.0662 26.5294 39.8719L21.75 33.1875V39C21.75 39.3978 21.592 39.7794 21.3107 40.0607C21.0294 40.342 20.6478 40.5 20.25 40.5C19.8522 40.5 19.4706 40.342 19.1893 40.0607C18.908 39.7794 18.75 39.3978 18.75 39V28.5C18.75 28.1822 18.8509 27.8726 19.0382 27.6158C19.2256 27.3591 19.4896 27.1685 19.7922 27.0715C20.0949 26.9745 20.4205 26.9762 20.7222 27.0762C21.0238 27.1762 21.2859 27.3695 21.4706 27.6281L26.25 34.3125V28.5C26.25 28.1022 26.408 27.7206 26.6893 27.4393C26.9706 27.158 27.3522 27 27.75 27C28.1478 27 28.5294 27.158 28.8107 27.4393C29.092 27.7206 29.25 28.1022 29.25 28.5ZM9 22.5C9.39782 22.5 9.77936 22.342 10.0607 22.0607C10.342 21.7794 10.5 21.3978 10.5 21V7.5H27V16.5C27 16.8978 27.158 17.2794 27.4393 17.5607C27.7206 17.842 28.1022 18 28.5 18H37.5V21C37.5 21.3978 37.658 21.7794 37.9393 22.0607C38.2206 22.342 38.6022 22.5 39 22.5C39.3978 22.5 39.7794 22.342 40.0607 22.0607C40.342 21.7794 40.5 21.3978 40.5 21V16.5C40.5002 16.303 40.4615 16.1078 40.3862 15.9257C40.3109 15.7436 40.2005 15.5782 40.0612 15.4388L29.5613 4.93875C29.4218 4.7995 29.2564 4.68908 29.0743 4.6138C28.8922 4.53851 28.697 4.49985 28.5 4.5H10.5C9.70435 4.5 8.94129 4.81607 8.37868 5.37868C7.81607 5.94129 7.5 6.70435 7.5 7.5V21C7.5 21.3978 7.65804 21.7794 7.93934 22.0607C8.22064 22.342 8.60218 22.5 9 22.5ZM30 9.62063L35.3794 15H30V9.62063Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/icons/PdgIcon.tsx\n\nvar PdgIcon = function PdgIcon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M11.25 27H8.25C7.85218 27 7.47064 27.158 7.18934 27.4393C6.90804 27.7206 6.75 28.1022 6.75 28.5V39C6.75 39.3978 6.90804 39.7794 7.18934 40.0607C7.47064 40.342 7.85218 40.5 8.25 40.5C8.64782 40.5 9.02936 40.342 9.31066 40.0607C9.59196 39.7794 9.75 39.3978 9.75 39V37.5H11.25C12.6424 37.5 13.9777 36.9469 14.9623 35.9623C15.9469 34.9777 16.5 33.6424 16.5 32.25C16.5 30.8576 15.9469 29.5223 14.9623 28.5377C13.9777 27.5531 12.6424 27 11.25 27ZM11.25 34.5H9.75V30H11.25C11.8467 30 12.419 30.2371 12.841 30.659C13.2629 31.081 13.5 31.6533 13.5 32.25C13.5 32.8467 13.2629 33.419 12.841 33.841C12.419 34.2629 11.8467 34.5 11.25 34.5ZM42 37.6631C42 38.0495 41.8508 38.4209 41.5837 38.7C41.0615 39.2622 40.4298 39.7119 39.7276 40.0214C39.0254 40.3309 38.2674 40.4938 37.5 40.5C34.1906 40.5 31.5 37.4719 31.5 33.75C31.5 30.0281 34.1906 27 37.5 27C38.6026 27.0037 39.6788 27.3374 40.59 27.9581C40.9199 28.1819 41.1475 28.5276 41.2226 28.9191C41.2976 29.3107 41.2141 29.716 40.9903 30.0459C40.7665 30.3759 40.4209 30.6034 40.0293 30.6785C39.6378 30.7536 39.2324 30.67 38.9025 30.4463C38.4911 30.1587 38.0019 30.0031 37.5 30C35.8463 30 34.5 31.6875 34.5 33.75C34.5 35.8125 35.8463 37.5 37.5 37.5C38.0415 37.494 38.567 37.3153 39 36.99V36C38.6022 36 38.2206 35.842 37.9393 35.5607C37.658 35.2794 37.5 34.8978 37.5 34.5C37.5 34.1022 37.658 33.7206 37.9393 33.4393C38.2206 33.158 38.6022 33 39 33H40.5C40.8978 33 41.2794 33.158 41.5607 33.4393C41.842 33.7206 42 34.1022 42 34.5V37.6631ZM29.25 28.5V39C29.25 39.3179 29.1491 39.6276 28.9617 39.8844C28.7744 40.1412 28.5102 40.3318 28.2075 40.4288C28.0597 40.4763 27.9053 40.5004 27.75 40.5C27.5112 40.5 27.2759 40.443 27.0636 40.3338C26.8513 40.2245 26.6682 40.0662 26.5294 39.8719L21.75 33.1875V39C21.75 39.3978 21.592 39.7794 21.3107 40.0607C21.0294 40.342 20.6478 40.5 20.25 40.5C19.8522 40.5 19.4706 40.342 19.1893 40.0607C18.908 39.7794 18.75 39.3978 18.75 39V28.5C18.75 28.1822 18.8509 27.8726 19.0382 27.6158C19.2256 27.3591 19.4896 27.1685 19.7922 27.0715C20.0949 26.9745 20.4205 26.9762 20.7222 27.0762C21.0238 27.1762 21.2859 27.3695 21.4706 27.6281L26.25 34.3125V28.5C26.25 28.1022 26.408 27.7206 26.6893 27.4393C26.9706 27.158 27.3522 27 27.75 27C28.1478 27 28.5294 27.158 28.8107 27.4393C29.092 27.7206 29.25 28.1022 29.25 28.5ZM9 22.5C9.39782 22.5 9.77936 22.342 10.0607 22.0607C10.342 21.7794 10.5 21.3978 10.5 21V7.5H27V16.5C27 16.8978 27.158 17.2794 27.4393 17.5607C27.7206 17.842 28.1022 18 28.5 18H37.5V21C37.5 21.3978 37.658 21.7794 37.9393 22.0607C38.2206 22.342 38.6022 22.5 39 22.5C39.3978 22.5 39.7794 22.342 40.0607 22.0607C40.342 21.7794 40.5 21.3978 40.5 21V16.5C40.5002 16.303 40.4615 16.1078 40.3862 15.9257C40.3109 15.7436 40.2005 15.5782 40.0612 15.4388L29.5613 4.93875C29.4218 4.7995 29.2564 4.68908 29.0743 4.6138C28.8922 4.53851 28.697 4.49985 28.5 4.5H10.5C9.70435 4.5 8.94129 4.81607 8.37868 5.37868C7.81607 5.94129 7.5 6.70435 7.5 7.5V21C7.5 21.3978 7.65804 21.7794 7.93934 22.0607C8.22064 22.342 8.60218 22.5 9 22.5ZM30 9.62063L35.3794 15H30V9.62063Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/icons/Mp4Icon.tsx\n\nvar Mp4Icon = function Mp4Icon(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "48",\n    height: "48",\n    viewBox: "0 0 48 48",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M42 28.5C42 28.8978 41.842 29.2794 41.5607 29.5607C41.2794 29.842 40.8978 30 40.5 30H36V33H39C39.3978 33 39.7794 33.158 40.0607 33.4393C40.342 33.7206 40.5 34.1022 40.5 34.5C40.5 34.8978 40.342 35.2794 40.0607 35.5607C39.7794 35.842 39.3978 36 39 36H36V39C36 39.3978 35.842 39.7794 35.5607 40.0607C35.2794 40.342 34.8978 40.5 34.5 40.5C34.1022 40.5 33.7206 40.342 33.4393 40.0607C33.158 39.7794 33 39.3978 33 39V28.5C33 28.1022 33.158 27.7206 33.4393 27.4393C33.7206 27.158 34.1022 27 34.5 27H40.5C40.8978 27 41.2794 27.158 41.5607 27.4393C41.842 27.7206 42 28.1022 42 28.5ZM17.25 32.25C17.25 33.6424 16.6969 34.9777 15.7123 35.9623C14.7277 36.9469 13.3924 37.5 12 37.5H10.5V39C10.5 39.3978 10.342 39.7794 10.0607 40.0607C9.77936 40.342 9.39782 40.5 9 40.5C8.60218 40.5 8.22064 40.342 7.93934 40.0607C7.65804 39.7794 7.5 39.3978 7.5 39V28.5C7.5 28.1022 7.65804 27.7206 7.93934 27.4393C8.22064 27.158 8.60218 27 9 27H12C13.3924 27 14.7277 27.5531 15.7123 28.5377C16.6969 29.5223 17.25 30.8576 17.25 32.25ZM14.25 32.25C14.25 31.6533 14.0129 31.081 13.591 30.659C13.169 30.2371 12.5967 30 12 30H10.5V34.5H12C12.5967 34.5 13.169 34.2629 13.591 33.841C14.0129 33.419 14.25 32.8467 14.25 32.25ZM30.75 33.75C30.75 35.5402 30.0388 37.2571 28.773 38.523C27.5071 39.7888 25.7902 40.5 24 40.5H21C20.6022 40.5 20.2206 40.342 19.9393 40.0607C19.658 39.7794 19.5 39.3978 19.5 39V28.5C19.5 28.1022 19.658 27.7206 19.9393 27.4393C20.2206 27.158 20.6022 27 21 27H24C25.7902 27 27.5071 27.7112 28.773 28.977C30.0388 30.2429 30.75 31.9598 30.75 33.75ZM27.75 33.75C27.75 32.7554 27.3549 31.8016 26.6516 31.0984C25.9484 30.3951 24.9946 30 24 30H22.5V37.5H24C24.9946 37.5 25.9484 37.1049 26.6516 36.4016C27.3549 35.6984 27.75 34.7446 27.75 33.75ZM7.5 21V7.5C7.5 6.70435 7.81607 5.94129 8.37868 5.37868C8.94129 4.81607 9.70435 4.5 10.5 4.5H28.5C28.697 4.49985 28.8922 4.53851 29.0743 4.6138C29.2564 4.68908 29.4218 4.7995 29.5613 4.93875L40.0612 15.4388C40.2005 15.5782 40.3109 15.7436 40.3862 15.9257C40.4615 16.1078 40.5002 16.303 40.5 16.5V21C40.5 21.3978 40.342 21.7794 40.0607 22.0607C39.7794 22.342 39.3978 22.5 39 22.5C38.6022 22.5 38.2206 22.342 37.9393 22.0607C37.658 21.7794 37.5 21.3978 37.5 21V18H28.5C28.1022 18 27.7206 17.842 27.4393 17.5607C27.158 17.2794 27 16.8978 27 16.5V7.5H10.5V21C10.5 21.3978 10.342 21.7794 10.0607 22.0607C9.77936 22.342 9.39782 22.5 9 22.5C8.60218 22.5 8.22064 22.342 7.93934 22.0607C7.65804 21.7794 7.5 21.3978 7.5 21ZM30 15H35.3794L30 9.62063V15Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/components/uploader/file-list.tsx\n"use client";\n\n\n\n\n\n\n\n\n\n\n\n\nfunction FileList() {\n  var _useFileUpload = useFileUpload(),\n    file = _useFileUpload.file,\n    removeFile = _useFileUpload.removeFile;\n  var _useTxPreparation = useTxPreparation(),\n    fileProgress = _useTxPreparation.fileProgress,\n    isProcessing = _useTxPreparation.isProcessing,\n    currentStep = _useTxPreparation.currentStep;\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation;\n  if (!file) return null;\n\n  // Como solo se admite un archivo, se usa el primer elemento de fileProgress (si existe)\n  var progress = fileProgress[0];\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "flex flex-col gap-4",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement(AnimatePresence, null, /*#__PURE__*/react.createElement(motion.div, {\n    key: file.name,\n    className: "flex flex-col gap-2 p-4 bg-white/5 rounded-lg",\n    initial: {\n      opacity: 0,\n      y: 20\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    exit: {\n      opacity: 0,\n      x: -20\n    },\n    transition: {\n      duration: 0.3\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center justify-between"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center gap-4"\n  }, file.preview ? /*#__PURE__*/react.createElement("img", {\n    src: file.preview,\n    alt: "Preview",\n    className: "w-10 h-10 rounded object-cover"\n  }) : /*#__PURE__*/react.createElement("div", {\n    className: "w-10 h-10 flex items-center justify-center"\n  }, file.type === "application/pdf" ? /*#__PURE__*/react.createElement(PdfIcon, {\n    className: "w-full h-full text-white"\n  }) : file.type === "image/png" ? /*#__PURE__*/react.createElement(PngIcon, {\n    className: "w-full h-full text-white"\n  }) : file.type === "image/pdg" ? /*#__PURE__*/react.createElement(PdgIcon, {\n    className: "w-full h-full text-white"\n  }) : file.type === "video/mp4" ? /*#__PURE__*/react.createElement(Mp4Icon, {\n    className: "w-full h-full text-white"\n  }) : /*#__PURE__*/react.createElement("span", {\n    className: "text-xs text-white"\n  }, file.type.split("/")[1].toUpperCase())), /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("p", {\n    className: "font-medium !text-white"\n  }, file.name), /*#__PURE__*/react.createElement("p", {\n    className: "text-sm !text-white/80"\n  }, (file.size / 1024 / 1024).toFixed(2), " MB"))), /*#__PURE__*/react.createElement(Button, {\n    variant: "icon",\n    onClick: removeFile,\n    className: "text-white hover:bg-white/10",\n    disabled: preparation.currentStep != "prepare/construct"\n  }, /*#__PURE__*/react.createElement(CloseIcon, {\n    className: "w-6 h-6"\n  }))), isProcessing && currentStep === "prepare/construct" && progress && /*#__PURE__*/react.createElement("div", {\n    className: "space-y-1"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "h-1 bg-white/10 rounded-full overflow-hidden"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "h-full bg-primary-tw",\n    initial: {\n      width: 0\n    },\n    animate: {\n      width: "".concat(progress.progress, "%")\n    },\n    transition: {\n      duration: 0.5\n    }\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "text-xs text-white/60"\n  }, progress.status === "constructing" ? "Constructing transaction..." : progress.status === "unsigned" ? "Retrieving unsigned transaction..." : "Processing...")))));\n}\n;// ./src/components/uploader/delegate-view.tsx\n"use client";\n\n\n\n\nfunction DelegateView(_ref) {\n  var text = _ref.text,\n    setText = _ref.setText,\n    isProcessing = _ref.isProcessing;\n  var _useTxStatus = useTxStatus(),\n    preparation = _useTxStatus.preparation;\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "space-y-4",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    transition: {\n      duration: 0.3\n    }\n  }, /*#__PURE__*/react.createElement("textarea", {\n    value: text,\n    onChange: function onChange(e) {\n      return setText(e.target.value);\n    },\n    placeholder: "Enter your text here...",\n    className: "w-full h-48 p-4 bg-white/5 rounded-xl text-white placeholder:text-white/40 focus:outline-none focus:ring-2 focus:ring-[#447BF4]",\n    disabled: preparation.currentStep != "prepare/construct"\n  }));\n}\n;// ./src/context/TxInscriptionContext.tsx\n"use client";\n\nfunction TxInscriptionContext_typeof(o) { "@babel/helpers - typeof"; return TxInscriptionContext_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, TxInscriptionContext_typeof(o); }\nfunction TxInscriptionContext_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction TxInscriptionContext_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? TxInscriptionContext_ownKeys(Object(t), !0).forEach(function (r) { TxInscriptionContext_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : TxInscriptionContext_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction TxInscriptionContext_defineProperty(e, r, t) { return (r = TxInscriptionContext_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction TxInscriptionContext_toPropertyKey(t) { var i = TxInscriptionContext_toPrimitive(t, "string"); return "symbol" == TxInscriptionContext_typeof(i) ? i : i + ""; }\nfunction TxInscriptionContext_toPrimitive(t, r) { if ("object" != TxInscriptionContext_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != TxInscriptionContext_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction TxInscriptionContext_slicedToArray(r, e) { return TxInscriptionContext_arrayWithHoles(r) || TxInscriptionContext_iterableToArrayLimit(r, e) || TxInscriptionContext_unsupportedIterableToArray(r, e) || TxInscriptionContext_nonIterableRest(); }\nfunction TxInscriptionContext_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction TxInscriptionContext_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return TxInscriptionContext_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? TxInscriptionContext_arrayLikeToArray(r, a) : void 0; } }\nfunction TxInscriptionContext_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction TxInscriptionContext_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction TxInscriptionContext_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction TxInscriptionContext_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ TxInscriptionContext_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == TxInscriptionContext_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(TxInscriptionContext_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction TxInscriptionContext_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction TxInscriptionContext_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { TxInscriptionContext_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { TxInscriptionContext_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\n\n\n\n\nvar TxInscriptionContext = /*#__PURE__*/(0,react.createContext)({\n  fileProgress: [],\n  inscribeFiles: function () {\n    var _inscribeFiles = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee() {\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    function inscribeFiles() {\n      return _inscribeFiles.apply(this, arguments);\n    }\n    return inscribeFiles;\n  }(),\n  inscribeText: function () {\n    var _inscribeText = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee2() {\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    function inscribeText() {\n      return _inscribeText.apply(this, arguments);\n    }\n    return inscribeText;\n  }(),\n  signAndSubmit: function () {\n    var _signAndSubmit = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee3() {\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n    function signAndSubmit() {\n      return _signAndSubmit.apply(this, arguments);\n    }\n    return signAndSubmit;\n  }(),\n  isProcessing: false,\n  currentStep: "inscription/construct",\n  nextStep: null,\n  error: null,\n  clearError: function clearError() {},\n  reset: function reset() {},\n  submissionStatus: undefined,\n  unsignedTx: undefined,\n  setUnsignedTx: function setUnsignedTx() {}\n});\nfunction useTxInscription() {\n  var context = (0,react.useContext)(TxInscriptionContext);\n  if (!context) {\n    throw new Error("useTxInscription must be used within a TxInscriptionProvider");\n  }\n  return context;\n}\nfunction TxInscriptionProvider(_ref) {\n  var children = _ref.children;\n  var _useState = (0,react.useState)([]),\n    _useState2 = TxInscriptionContext_slicedToArray(_useState, 2),\n    fileProgress = _useState2[0],\n    setFileProgress = _useState2[1];\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = TxInscriptionContext_slicedToArray(_useState3, 2),\n    isProcessing = _useState4[0],\n    setIsProcessing = _useState4[1];\n  var _useState5 = (0,react.useState)(null),\n    _useState6 = TxInscriptionContext_slicedToArray(_useState5, 2),\n    error = _useState6[0],\n    setError = _useState6[1];\n  var _useState7 = (0,react.useState)(),\n    _useState8 = TxInscriptionContext_slicedToArray(_useState7, 2),\n    submissionStatus = _useState8[0],\n    setSubmissionStatus = _useState8[1];\n  var _useState9 = (0,react.useState)(),\n    _useState10 = TxInscriptionContext_slicedToArray(_useState9, 2),\n    unsignedTx = _useState10[0],\n    setUnsignedTx = _useState10[1];\n  var _useWallet = useWallet(),\n    getWalletApi = _useWallet.getWalletApi,\n    defaultWallet = _useWallet.defaultWallet;\n  var _useTxStatus = useTxStatus(),\n    inscription = _useTxStatus.inscription,\n    moveToNextStep = _useTxStatus.moveToNextStep;\n  var updateFileProgress = (0,react.useCallback)(function (index, updates) {\n    setFileProgress(function (prev) {\n      return prev.map(function (item, i) {\n        return i === index ? TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, item), updates) : item;\n      });\n    });\n  }, []);\n  var clearError = (0,react.useCallback)(function () {\n    setError(null);\n  }, []);\n  var reset = (0,react.useCallback)(function () {\n    setFileProgress([]);\n    setIsProcessing(false);\n    setSubmissionStatus(undefined);\n    setUnsignedTx(undefined);\n    setError(null);\n  }, []);\n  var constructInscriptionTx = /*#__PURE__*/function () {\n    var _ref2 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee4(api, data, dataType) {\n      var rewardAddresses, utxos, targetAddress, body, response, errorData, errorResponse, constructedTx;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return api.getRewardAddresses();\n          case 2:\n            rewardAddresses = _context4.sent;\n            _context4.next = 5;\n            return api.getUtxos();\n          case 5:\n            _context4.t0 = _context4.sent;\n            if (_context4.t0) {\n              _context4.next = 8;\n              break;\n            }\n            _context4.t0 = [];\n          case 8:\n            utxos = _context4.t0;\n            console.log("UTXOs:", utxos);\n            _context4.next = 12;\n            return api.getUsedAddresses();\n          case 12:\n            targetAddress = _context4.sent[0];\n            if (!(!utxos || utxos.length === 0)) {\n              _context4.next = 16;\n              break;\n            }\n            setError("No hay UTXOs disponibles");\n            throw new Error("No UTXOs available");\n          case 16:\n            body = {\n              payload: data,\n              payloadType: dataType,\n              rewardAddresses: rewardAddresses,\n              changeAddress: targetAddress,\n              utxos: utxos,\n              mintTokenForPayload: "NoMinting"\n            };\n            console.log("Body:", body);\n            _context4.next = 20;\n            return fetch(buildApiUrl("/inscriptions/construct-tx"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(body)\n            });\n          case 20:\n            response = _context4.sent;\n            if (response.ok) {\n              _context4.next = 35;\n              break;\n            }\n            _context4.prev = 22;\n            errorResponse = response.clone();\n            _context4.next = 26;\n            return errorResponse.json();\n          case 26:\n            errorData = _context4.sent;\n            _context4.next = 34;\n            break;\n          case 29:\n            _context4.prev = 29;\n            _context4.t1 = _context4["catch"](22);\n            _context4.next = 33;\n            return response.text();\n          case 33:\n            errorData = _context4.sent;\n          case 34:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/inscriptions/construct-tx"\n            }));\n          case 35:\n            // Avanzamos en el flujo de inscripción\n            moveToNextStep("inscription");\n            _context4.next = 38;\n            return response.json();\n          case 38:\n            constructedTx = _context4.sent;\n            console.log("Constructed TX:", constructedTx);\n            setIsProcessing(false);\n            return _context4.abrupt("return", constructedTx);\n          case 42:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[22, 29]]);\n    }));\n    return function constructInscriptionTx(_x, _x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var inscribeFiles = /*#__PURE__*/function () {\n    var _ref3 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee5(files) {\n      var api, _loop, i;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee5$(_context6) {\n        while (1) switch (_context6.prev = _context6.next) {\n          case 0:\n            if (defaultWallet) {\n              _context6.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context6.prev = 4;\n            setFileProgress(files.map(function (file) {\n              return {\n                file: file,\n                status: "pending",\n                progress: 0\n              };\n            }));\n            _loop = /*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _loop(i) {\n              var reader, fileAsBase64, base64Content, constructedTx;\n              return TxInscriptionContext_regeneratorRuntime().wrap(function _loop$(_context5) {\n                while (1) switch (_context5.prev = _context5.next) {\n                  case 0:\n                    updateFileProgress(i, {\n                      status: "constructing",\n                      progress: 25\n                    });\n                    reader = new FileReader();\n                    _context5.next = 4;\n                    return new Promise(function (resolve, reject) {\n                      reader.onload = function () {\n                        return resolve(reader.result);\n                      };\n                      reader.onerror = reject;\n                      reader.readAsDataURL(files[i]);\n                    });\n                  case 4:\n                    fileAsBase64 = _context5.sent;\n                    base64Content = fileAsBase64.split(",")[1];\n                    _context5.next = 8;\n                    return constructInscriptionTx(api, base64Content, files[i].type);\n                  case 8:\n                    constructedTx = _context5.sent;\n                    updateFileProgress(i, {\n                      status: "unsigned",\n                      progress: 50,\n                      txInfo: {\n                        constructedTx: constructedTx\n                      }\n                    });\n                  case 10:\n                  case "end":\n                    return _context5.stop();\n                }\n              }, _loop);\n            });\n            i = 0;\n          case 8:\n            if (!(i < files.length)) {\n              _context6.next = 13;\n              break;\n            }\n            return _context6.delegateYield(_loop(i), "t0", 10);\n          case 10:\n            i++;\n            _context6.next = 8;\n            break;\n          case 13:\n            moveToNextStep("inscription");\n            _context6.next = 21;\n            break;\n          case 16:\n            _context6.prev = 16;\n            _context6.t1 = _context6["catch"](4);\n            console.error("Error inscribing files:", _context6.t1);\n            setError(_context6.t1 instanceof Error ? _context6.t1.message : JSON.stringify(_context6.t1));\n            setIsProcessing(false);\n          case 21:\n          case "end":\n            return _context6.stop();\n        }\n      }, _callee5, null, [[4, 16]]);\n    }));\n    return function inscribeFiles(_x4) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var inscribeText = /*#__PURE__*/function () {\n    var _ref4 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee6(text) {\n      var api, textFile, base64Content, constructedTx;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee6$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            if (defaultWallet) {\n              _context7.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context7.prev = 4;\n            textFile = new File([text], "inscription.txt", {\n              type: "text/plain"\n            });\n            setFileProgress([{\n              file: textFile,\n              status: "pending",\n              progress: 0\n            }]);\n            updateFileProgress(0, {\n              status: "constructing",\n              progress: 25\n            });\n            console.log("text", text);\n            base64Content = btoa(unescape(encodeURIComponent(text)));\n            console.log("base64Content", base64Content);\n            _context7.next = 13;\n            return constructInscriptionTx(api, base64Content, "text/plain");\n          case 13:\n            constructedTx = _context7.sent;\n            console.log("constructedTx", constructedTx);\n            updateFileProgress(0, {\n              status: "unsigned",\n              progress: 50,\n              txInfo: {\n                constructedTx: constructedTx\n              }\n            });\n            moveToNextStep("inscription");\n            _context7.next = 24;\n            break;\n          case 19:\n            _context7.prev = 19;\n            _context7.t0 = _context7["catch"](4);\n            console.error("Error inscribing text:", _context7.t0);\n            setError(_context7.t0 instanceof Error ? _context7.t0.message : JSON.stringify(_context7.t0));\n            setIsProcessing(false);\n          case 24:\n            _context7.prev = 24;\n            setIsProcessing(false);\n            return _context7.finish(24);\n          case 27:\n          case "end":\n            return _context7.stop();\n        }\n      }, _callee6, null, [[4, 19, 24, 27]]);\n    }));\n    return function inscribeText(_x5) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var pollForConfirmation = /*#__PURE__*/function () {\n    var _ref5 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee7(preparedTx) {\n      var retryInterval, response, errorData, errorResponse, status, responseText, errorMessage, _errorMessage, parsedError;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee7$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            retryInterval = 9000;\n            setIsProcessing(true);\n          case 2:\n            if (false) {}\n            _context8.prev = 3;\n            _context8.next = 6;\n            return fetch(buildApiUrl("/inscriptions/retrieve-submission-status"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY || ""\n              },\n              body: JSON.stringify(preparedTx.executionArn)\n            });\n          case 6:\n            response = _context8.sent;\n            if (response.ok) {\n              _context8.next = 22;\n              break;\n            }\n            errorData = void 0;\n            _context8.prev = 9;\n            errorResponse = response.clone();\n            _context8.next = 13;\n            return errorResponse.json();\n          case 13:\n            errorData = _context8.sent;\n            _context8.next = 21;\n            break;\n          case 16:\n            _context8.prev = 16;\n            _context8.t0 = _context8["catch"](9);\n            _context8.next = 20;\n            return response.text();\n          case 20:\n            errorData = _context8.sent;\n          case 21:\n            throw new Error(JSON.stringify({\n              status: response.status,\n              statusText: response.statusText,\n              error: errorData,\n              endpoint: "/inscriptions/retrieve-submission-status"\n            }));\n          case 22:\n            // Parse the response carefully to handle potential JSON decoding errors\n            status = void 0;\n            _context8.prev = 23;\n            _context8.next = 26;\n            return response.text();\n          case 26:\n            responseText = _context8.sent;\n            if (!(responseText.includes("States.Timeout") || responseText.includes("JsonDecodeError"))) {\n              _context8.next = 33;\n              break;\n            }\n            console.error("Timeout or JSON decode error detected:", responseText);\n            errorMessage = "Transaction processing timed out or encountered a decoding error. Please try again later.";\n            setError(errorMessage);\n            setIsProcessing(false);\n            return _context8.abrupt("return", false);\n          case 33:\n            status = JSON.parse(responseText);\n            _context8.next = 40;\n            break;\n          case 36:\n            _context8.prev = 36;\n            _context8.t1 = _context8["catch"](23);\n            console.error("Error parsing response:", _context8.t1);\n            throw new Error(JSON.stringify({\n              message: "Failed to parse submission status response",\n              error: _context8.t1 instanceof Error ? _context8.t1.message : String(_context8.t1),\n              endpoint: "/inscriptions/retrieve-submission-status"\n            }));\n          case 40:\n            if (!(status.success && status.success.onchain)) {\n              _context8.next = 46;\n              break;\n            }\n            setSubmissionStatus(status);\n            setIsProcessing(false);\n            moveToNextStep("inscription");\n            console.log("Transaction retrieved:", status);\n            return _context8.abrupt("return", true);\n          case 46:\n            if (!status.inProgress) {\n              _context8.next = 50;\n              break;\n            }\n            console.log("Transaction still in progress...");\n            _context8.next = 51;\n            break;\n          case 50:\n            throw new Error(JSON.stringify({\n              message: "Unexpected submission status response",\n              status: status,\n              endpoint: "/inscriptions/retrieve-submission-status"\n            }));\n          case 51:\n            _context8.next = 53;\n            return new Promise(function (res) {\n              return setTimeout(res, retryInterval);\n            });\n          case 53:\n            _context8.next = 64;\n            break;\n          case 55:\n            _context8.prev = 55;\n            _context8.t2 = _context8["catch"](3);\n            console.error("Polling attempt failed:", _context8.t2);\n\n            // Format the error message for better readability\n            _errorMessage = void 0;\n            if (_context8.t2 instanceof Error) {\n              try {\n                // Try to parse the error message as JSON for better formatting\n                parsedError = JSON.parse(_context8.t2.message);\n                if (parsedError.error && TxInscriptionContext_typeof(parsedError.error) === "object") {\n                  // Handle the specific JsonDecodeError case\n                  if (parsedError.error.message && parsedError.error.message.includes(\'key "onchain" not found\')) {\n                    _errorMessage = "Transaction processing error: The transaction data is incomplete. Please try again later.";\n                  } else {\n                    _errorMessage = "Error: ".concat(JSON.stringify(parsedError.error, null, 2));\n                  }\n                } else {\n                  _errorMessage = _context8.t2.message;\n                }\n              } catch (e) {\n                // If parsing fails, use the original error message\n                _errorMessage = _context8.t2.message;\n              }\n            } else {\n              _errorMessage = JSON.stringify(_context8.t2);\n            }\n            setError(_errorMessage);\n            setIsProcessing(false);\n\n            // Update file progress to failed\n            setFileProgress(function (prev) {\n              return prev.map(function (file) {\n                return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n                  status: "failed",\n                  progress: 0\n                });\n              });\n            });\n            return _context8.abrupt("return", false);\n          case 64:\n            _context8.next = 2;\n            break;\n          case 66:\n          case "end":\n            return _context8.stop();\n        }\n      }, _callee7, null, [[3, 55], [9, 16], [23, 36]]);\n    }));\n    return function pollForConfirmation(_x6) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitError = function handleSignAndSubmitError(error) {\n    console.error("Error in sign and submit for inscription:", error);\n\n    // Format the error message based on the error type\n    var errorMessage;\n\n    // Handle TxSignError from wallet\n    if (error && error.name === "TxSignError") {\n      errorMessage = "Wallet signing error: ".concat(error.info || error.message || "Failed to sign transaction");\n      // No actualizamos el estado de los archivos aquí ya que lo hacemos en el catch del sign\n      // Solo limpiamos el error y permitimos reintentar\n      setError(errorMessage);\n      setIsProcessing(false);\n      console.log("Wallet signing error detected, keeping current step for retry");\n    }\n    // Handle Error objects\n    else if (error instanceof Error) {\n      try {\n        var _parsedError$error;\n        // Try to parse the error message as JSON\n        var parsedError = JSON.parse(error.message);\n        errorMessage = ((_parsedError$error = parsedError.error) === null || _parsedError$error === void 0 ? void 0 : _parsedError$error.message) || parsedError.message || error.message;\n      } catch (e) {\n        // If parsing fails, use the original error message\n        errorMessage = error.message || "Unknown error occurred";\n      }\n      setError(errorMessage);\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n      setIsProcessing(false);\n      // For other errors, reset to the beginning\n      console.log("Other error detected, moving to end: ", error);\n      moveToNextStep("end");\n    }\n    // Handle other error types\n    else {\n      try {\n        errorMessage = JSON.stringify(error);\n      } catch (e) {\n        errorMessage = "Unknown error occurred";\n      }\n      setError(errorMessage);\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n      setIsProcessing(false);\n      // For other errors, reset to the beginning\n      console.log("Other error detected, moving to end: ", error);\n      moveToNextStep("end");\n    }\n  };\n  var signAndSubmit = /*#__PURE__*/function () {\n    var _ref6 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee9() {\n      var api, _loop2, i;\n      return TxInscriptionContext_regeneratorRuntime().wrap(function _callee9$(_context11) {\n        while (1) switch (_context11.prev = _context11.next) {\n          case 0:\n            if (defaultWallet) {\n              _context11.next = 2;\n              break;\n            }\n            throw new Error("No wallet connected");\n          case 2:\n            api = getWalletApi(defaultWallet);\n            setIsProcessing(true);\n            _context11.prev = 4;\n            _loop2 = /*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _loop2(i) {\n              var _file$txInfo;\n              var file, executionArn, unsignedTx, unsignedTxResponse, errorData, errorResponse, signedTx, _api, signedShardTxs, inscribeSubmitBody, submitResponse, _errorData, _errorResponse, submittedTx, confirmed;\n              return TxInscriptionContext_regeneratorRuntime().wrap(function _loop2$(_context10) {\n                while (1) switch (_context10.prev = _context10.next) {\n                  case 0:\n                    file = fileProgress[i];\n                    if ((_file$txInfo = file.txInfo) !== null && _file$txInfo !== void 0 && _file$txInfo.constructedTx) {\n                      _context10.next = 3;\n                      break;\n                    }\n                    return _context10.abrupt("return", 1);\n                  case 3:\n                    executionArn = file.txInfo.constructedTx.executionArn;\n                    console.log("executionArn", executionArn);\n\n                    // Solo obtener unsignedTx si no lo tenemos ya\n                    unsignedTx = file.txInfo.unsignedTx;\n                    if (unsignedTx) {\n                      _context10.next = 45;\n                      break;\n                    }\n                  case 7:\n                    if (false) {}\n                    _context10.next = 10;\n                    return fetch(buildApiUrl("/inscriptions/retrieve-unsigned-tx"), {\n                      method: "POST",\n                      headers: {\n                        "Content-Type": "application/json",\n                        "x-api-key": API_KEY || ""\n                      },\n                      body: JSON.stringify(executionArn)\n                    });\n                  case 10:\n                    unsignedTxResponse = _context10.sent;\n                    if (unsignedTxResponse.ok) {\n                      _context10.next = 26;\n                      break;\n                    }\n                    errorData = void 0;\n                    _context10.prev = 13;\n                    errorResponse = unsignedTxResponse.clone();\n                    _context10.next = 17;\n                    return errorResponse.json();\n                  case 17:\n                    errorData = _context10.sent;\n                    _context10.next = 25;\n                    break;\n                  case 20:\n                    _context10.prev = 20;\n                    _context10.t0 = _context10["catch"](13);\n                    _context10.next = 24;\n                    return unsignedTxResponse.text();\n                  case 24:\n                    errorData = _context10.sent;\n                  case 25:\n                    throw new Error(JSON.stringify({\n                      status: unsignedTxResponse.status,\n                      statusText: unsignedTxResponse.statusText,\n                      error: errorData,\n                      endpoint: "/inscriptions/retrieve-unsigned-tx"\n                    }));\n                  case 26:\n                    _context10.next = 28;\n                    return unsignedTxResponse.json();\n                  case 28:\n                    unsignedTx = _context10.sent;\n                    console.log("Unsigned TX:", unsignedTx);\n                    if (!(unsignedTx.success && unsignedTx.success.indexingTx)) {\n                      _context10.next = 36;\n                      break;\n                    }\n                    console.log("Unsigned transaction retrieved:", unsignedTx);\n                    setUnsignedTx(unsignedTx);\n                    moveToNextStep("inscription");\n                    setIsProcessing(false);\n                    return _context10.abrupt("break", 45);\n                  case 36:\n                    if (!unsignedTx.inProgress) {\n                      _context10.next = 42;\n                      break;\n                    }\n                    console.log("Unsigned transaction still in progress...");\n                    _context10.next = 40;\n                    return new Promise(function (res) {\n                      return setTimeout(res, 5000);\n                    });\n                  case 40:\n                    _context10.next = 43;\n                    break;\n                  case 42:\n                    throw new Error(JSON.stringify({\n                      message: "Unexpected response while retrieving unsigned transaction",\n                      response: unsignedTx,\n                      endpoint: "/inscriptions/retrieve-unsigned-tx"\n                    }));\n                  case 43:\n                    _context10.next = 7;\n                    break;\n                  case 45:\n                    updateFileProgress(i, {\n                      progress: 75,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx\n                      })\n                    });\n                    _context10.prev = 46;\n                    // Clear any previous error state before attempting to sign again\n                    clearError();\n\n                    // Get a fresh wallet API instance to ensure the popup appears again\n                    _api = getWalletApi(defaultWallet);\n                    _context10.next = 51;\n                    return _api.signTx(base64ToHex(unsignedTx.success.indexingTx));\n                  case 51:\n                    signedTx = _context10.sent;\n                    console.log("Signed TX:", signedTx);\n                    updateFileProgress(i, {\n                      status: "signed",\n                      progress: 85,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx,\n                        signedTx: signedTx\n                      })\n                    });\n                    moveToNextStep("inscription");\n                    _context10.next = 66;\n                    break;\n                  case 57:\n                    _context10.prev = 57;\n                    _context10.t1 = _context10["catch"](46);\n                    console.error("Error signing transaction:", _context10.t1);\n                    // Don\'t move to the next step if there\'s a signing error\n                    // This allows the user to retry signing from the same step\n                    if (!(_context10.t1 && _context10.t1.name === "TxSignError")) {\n                      _context10.next = 65;\n                      break;\n                    }\n                    // Mantener el estado actual y permitir reintentar\n                    setFileProgress(function (prev) {\n                      return prev.map(function (item, idx) {\n                        return idx === i ? TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, item), {}, {\n                          status: "unsigned",\n                          progress: 75,\n                          error: _context10.t1.message\n                        }) : item;\n                      });\n                    });\n                    throw _context10.t1;\n                  case 65:\n                    throw new Error("Failed to sign transaction: ".concat(_context10.t1.message || JSON.stringify(_context10.t1)));\n                  case 66:\n                    _context10.next = 68;\n                    return Promise.all(unsignedTx.success.shardTxs.map(/*#__PURE__*/function () {\n                      var _ref7 = TxInscriptionContext_asyncToGenerator(/*#__PURE__*/TxInscriptionContext_regeneratorRuntime().mark(function _callee8(shardTx) {\n                        var hexShardTx, _api2;\n                        return TxInscriptionContext_regeneratorRuntime().wrap(function _callee8$(_context9) {\n                          while (1) switch (_context9.prev = _context9.next) {\n                            case 0:\n                              hexShardTx = base64ToHex(shardTx);\n                              console.log("Hex Shard TX:", hexShardTx);\n                              _context9.prev = 2;\n                              // Get a fresh wallet API instance for each shard transaction\n                              _api2 = getWalletApi(defaultWallet);\n                              _context9.next = 6;\n                              return _api2.signTx(hexShardTx);\n                            case 6:\n                              return _context9.abrupt("return", _context9.sent);\n                            case 9:\n                              _context9.prev = 9;\n                              _context9.t0 = _context9["catch"](2);\n                              console.error("Error signing shard transaction:", _context9.t0);\n                              // Mantener el estado actual y permitir reintentar\n                              if (!(_context9.t0 && _context9.t0.name === "TxSignError")) {\n                                _context9.next = 17;\n                                break;\n                              }\n                              setFileProgress(function (prev) {\n                                return prev.map(function (item, idx) {\n                                  return idx === i ? TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, item), {}, {\n                                    status: "unsigned",\n                                    progress: 75,\n                                    error: _context9.t0.message\n                                  }) : item;\n                                });\n                              });\n                              throw _context9.t0;\n                            case 17:\n                              throw new Error("Failed to sign shard transaction: ".concat(_context9.t0.message || JSON.stringify(_context9.t0)));\n                            case 18:\n                            case "end":\n                              return _context9.stop();\n                          }\n                        }, _callee8, null, [[2, 9]]);\n                      }));\n                      return function (_x7) {\n                        return _ref7.apply(this, arguments);\n                      };\n                    }()));\n                  case 68:\n                    signedShardTxs = _context10.sent;\n                    console.log("Signed Shard TXs:", signedShardTxs);\n                    updateFileProgress(i, {\n                      status: "signed",\n                      progress: 90,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx,\n                        signedTx: signedTx\n                      })\n                    });\n                    // Move to the next step after successful signing of all transactions\n                    moveToNextStep("inscription");\n                    inscribeSubmitBody = {\n                      indexingTxToSubmit: [unsignedTx.success.indexingTx, signedTx],\n                      txsToSubmit: unsignedTx.success.shardTxs.map(function (shardTx, index) {\n                        return [shardTx, signedShardTxs[index]];\n                      }),\n                      ulidOfObject: unsignedTx.success.objectUlid\n                    };\n                    console.log("Inscribe submit body:", inscribeSubmitBody);\n                    _context10.next = 76;\n                    return fetch(buildApiUrl("/inscriptions/submit"), {\n                      method: "POST",\n                      headers: {\n                        "Content-Type": "application/json",\n                        "x-api-key": API_KEY || ""\n                      },\n                      body: JSON.stringify(inscribeSubmitBody)\n                    });\n                  case 76:\n                    submitResponse = _context10.sent;\n                    if (submitResponse.ok) {\n                      _context10.next = 91;\n                      break;\n                    }\n                    _context10.prev = 78;\n                    _errorResponse = submitResponse.clone();\n                    _context10.next = 82;\n                    return _errorResponse.json();\n                  case 82:\n                    _errorData = _context10.sent;\n                    _context10.next = 90;\n                    break;\n                  case 85:\n                    _context10.prev = 85;\n                    _context10.t2 = _context10["catch"](78);\n                    _context10.next = 89;\n                    return submitResponse.text();\n                  case 89:\n                    _errorData = _context10.sent;\n                  case 90:\n                    throw new Error(JSON.stringify({\n                      status: submitResponse.status,\n                      statusText: submitResponse.statusText,\n                      error: _errorData,\n                      endpoint: "/inscriptions/submit"\n                    }));\n                  case 91:\n                    _context10.next = 93;\n                    return submitResponse.json();\n                  case 93:\n                    submittedTx = _context10.sent;\n                    console.log("Submitted TX:", submittedTx);\n                    // Move to the next step after successful submission\n                    moveToNextStep("inscription");\n                    updateFileProgress(i, {\n                      status: "submitted",\n                      progress: 95,\n                      txInfo: TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file.txInfo), {}, {\n                        unsignedTx: unsignedTx,\n                        signedTx: signedTx,\n                        submittedTx: submittedTx\n                      })\n                    });\n                    _context10.next = 99;\n                    return pollForConfirmation(submittedTx);\n                  case 99:\n                    confirmed = _context10.sent;\n                    updateFileProgress(i, {\n                      status: confirmed ? "confirmed" : "failed",\n                      progress: confirmed ? 100 : 0\n                    });\n                    moveToNextStep("inscription");\n                  case 102:\n                  case "end":\n                    return _context10.stop();\n                }\n              }, _loop2, null, [[13, 20], [46, 57], [78, 85]]);\n            });\n            i = 0;\n          case 7:\n            if (!(i < fileProgress.length)) {\n              _context11.next = 14;\n              break;\n            }\n            return _context11.delegateYield(_loop2(i), "t0", 9);\n          case 9:\n            if (!_context11.t0) {\n              _context11.next = 11;\n              break;\n            }\n            return _context11.abrupt("continue", 11);\n          case 11:\n            i++;\n            _context11.next = 7;\n            break;\n          case 14:\n            // Al finalizar, se establece el estado final "end"\n            moveToNextStep("end");\n            setIsProcessing(false);\n            _context11.next = 21;\n            break;\n          case 18:\n            _context11.prev = 18;\n            _context11.t1 = _context11["catch"](4);\n            handleSignAndSubmitError(_context11.t1);\n          case 21:\n          case "end":\n            return _context11.stop();\n        }\n      }, _callee9, null, [[4, 18]]);\n    }));\n    return function signAndSubmit() {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  (0,react.useEffect)(function () {\n    if (error) {\n      console.error("Error occurred:", error);\n      setFileProgress(function (prev) {\n        return prev.map(function (file) {\n          return TxInscriptionContext_objectSpread(TxInscriptionContext_objectSpread({}, file), {}, {\n            status: "failed",\n            progress: 0\n          });\n        });\n      });\n      setIsProcessing(false);\n    }\n  }, [error]);\n  return /*#__PURE__*/react.createElement(TxInscriptionContext.Provider, {\n    value: {\n      fileProgress: fileProgress,\n      inscribeFiles: inscribeFiles,\n      inscribeText: inscribeText,\n      signAndSubmit: signAndSubmit,\n      isProcessing: isProcessing,\n      currentStep: inscription.currentStep,\n      nextStep: inscription.nextStep,\n      error: error,\n      clearError: clearError,\n      reset: reset,\n      submissionStatus: submissionStatus,\n      unsignedTx: unsignedTx,\n      setUnsignedTx: setUnsignedTx\n    }\n  }, children);\n}\n;// ./src/components/ui/LoadingScreen.tsx\n"use client";\n\n\n\nfunction LoadingScreen(_ref) {\n  var _ref$text = _ref.text,\n    text = _ref$text === void 0 ? "Loading..." : _ref$text,\n    _ref$className = _ref.className,\n    className = _ref$className === void 0 ? "" : _ref$className;\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-full h-full  z-50 flex flex-col items-center justify-center rounded-4xl !text-white ".concat(className, " py-8 "),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center gap-6"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-20 h-20",\n    animate: {\n      rotateY: 360\n    },\n    transition: {\n      duration: 2.5,\n      repeat: Number.POSITIVE_INFINITY,\n      ease: "linear" //"easeInOut",\n    }\n  }, /*#__PURE__*/react.createElement("img", {\n    src: "https://cdn.prod.website-files.com/66c3b779674915c288ca9998/66c63fa6307332e239106044_Logo%20(11).png",\n    alt: "Loading spinner",\n    className: "w-full h-full"\n  })), /*#__PURE__*/react.createElement(motion.p, {\n    initial: {\n      opacity: 0,\n      x: -10\n    },\n    animate: {\n      opacity: 1,\n      x: 0\n    },\n    transition: {\n      delay: 0.2\n    },\n    className: "text-[1.25rem] font-medium !text-white"\n  }, text), /*#__PURE__*/react.createElement(motion.p, {\n    initial: {\n      opacity: 0,\n      x: -10\n    },\n    animate: {\n      opacity: 1,\n      x: 0\n    },\n    transition: {\n      delay: 0.2\n    },\n    className: " text-[0.875rem] !text-white"\n  }, "\\xBFHave questions? See our", " ", /*#__PURE__*/react.createElement("a", {\n    className: "underline !text-white",\n    href: "/faq"\n  }, "FAQs"), ".")));\n}\n;// ./src/components/ui/FinishScreen.tsx\n"use client";\n\n\n\n\n\n\n\n\nvar ExplorerLink = function ExplorerLink(_ref) {\n  var txId = _ref.txId;\n  return /*#__PURE__*/react.createElement("a", {\n    href: "https://preprod.cardanoscan.io/transaction/".concat(txId),\n    target: "_blank",\n    rel: "noopener noreferrer",\n    className: "!text-white/80  hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("svg", {\n    className: "w-4 h-4",\n    viewBox: "0 0 24 24",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M12 12V3M12 3L9 6M12 3L15 6",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  })), txId);\n};\nfunction FinishScreen(_ref2) {\n  var _ref2$text = _ref2.text,\n    text = _ref2$text === void 0 ? "Your submissions are now inscribed Onchain." : _ref2$text,\n    _ref2$className = _ref2.className,\n    className = _ref2$className === void 0 ? "" : _ref2$className,\n    setIsPrepared = _ref2.setIsPrepared,\n    setIsInscribed = _ref2.setIsInscribed,\n    setDelegateText = _ref2.setDelegateText,\n    submissionStatus = _ref2.submissionStatus,\n    preparationTxId = _ref2.preparationTxId,\n    unsignedTxId = _ref2.unsignedTxId,\n    indexingTxId = _ref2.indexingTxId,\n    shardTxIds = _ref2.shardTxIds;\n  var _useTxStatus = useTxStatus(),\n    resetStatus = _useTxStatus.resetStatus,\n    setInscriptionStatus = _useTxStatus.setInscriptionStatus,\n    setPreparationStatus = _useTxStatus.setPreparationStatus;\n  var _useFileUpload = useFileUpload(),\n    clearFile = _useFileUpload.clearFile;\n  var _useTxInscription = useTxInscription(),\n    reset = _useTxInscription.reset;\n  var _useTxPreparation = useTxPreparation(),\n    resetPreparation = _useTxPreparation.reset;\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-full h-full z-50 flex flex-col items-center justify-center rounded-4xl !text-white ".concat(className),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center gap-6"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "w-[1.45456rem] h-[1rem]"\n  }, /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "100%",\n    height: "100%",\n    viewBox: "0 0 28 20",\n    fill: "none"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M25.6364 2L9.63637 18L2.36365 10.7273",\n    stroke: "#2B80FF",\n    strokeWidth: "2.90909",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  }))), /*#__PURE__*/react.createElement("p", {\n    className: "text-center text-[1.25rem]"\n  }, text), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 items-center text-sm w-full mt-4"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Preparation Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "border-t border-white/20 my-1"\n  }), preparationTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Preparation Transaction:"), /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: preparationTxId\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-4"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Inscription Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "border-t border-white/20 my-1"\n  }), indexingTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Indexing Transaction:"), /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: indexingTxId\n  })), shardTxIds && shardTxIds.length > 0 && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80"\n  }, "Shard Transactions:"), shardTxIds.map(function (shardTxId, index) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      key: index,\n      txId: shardTxId\n    });\n  })), (submissionStatus === null || submissionStatus === void 0 ? void 0 : submissionStatus.success) && !indexingTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Indexing Transaction:"), /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: submissionStatus.success.indexingTxId\n  })), (submissionStatus === null || submissionStatus === void 0 ? void 0 : submissionStatus.success) && submissionStatus.success.allShardSubmissions.length > 0 && !shardTxIds && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80"\n  }, "Shard Transactions:"), submissionStatus.success.allShardSubmissions.map(function (shard, index) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      key: index,\n      txId: shard.shardSubmittedTxid\n    });\n  })))), /*#__PURE__*/react.createElement(Button, {\n    onClick: function onClick() {\n      resetStatus("preparation");\n      resetStatus("inscription");\n      setInscriptionStatus({});\n      setPreparationStatus({});\n      reset();\n      resetPreparation();\n      clearFile();\n      setIsPrepared(false);\n      setIsInscribed(false);\n      setDelegateText("");\n    },\n    className: "mt-4"\n  }, "Inscribe more")));\n}\n;// ./src/components/ui/ProgressBar.tsx\n\nvar ProgressBar = function ProgressBar(_ref) {\n  var currentStep = _ref.currentStep,\n    totalSteps = _ref.totalSteps,\n    stepText = _ref.stepText,\n    phase = _ref.phase;\n  var progress = currentStep / totalSteps * 100;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex justify-between items-center mb-2"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-sm text-white/80 font-bold"\n  }, "Step ", currentStep, " of ", totalSteps, ": ", stepText), /*#__PURE__*/react.createElement("span", {\n    className: "text-sm text-white/80"\n  }, phase)), /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-2 bg-white/20 rounded-full overflow-hidden"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "h-full bg-blue-500 rounded-full transition-all duration-300 ease-in-out",\n    style: {\n      width: "".concat(progress, "%")\n    }\n  })));\n};\n;// ./src/components/uploader/mainUploader.tsx\n"use client";\n\nfunction mainUploader_typeof(o) { "@babel/helpers - typeof"; return mainUploader_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, mainUploader_typeof(o); }\nfunction mainUploader_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ mainUploader_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == mainUploader_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(mainUploader_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction mainUploader_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction mainUploader_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { mainUploader_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { mainUploader_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction mainUploader_slicedToArray(r, e) { return mainUploader_arrayWithHoles(r) || mainUploader_iterableToArrayLimit(r, e) || mainUploader_unsupportedIterableToArray(r, e) || mainUploader_nonIterableRest(); }\nfunction mainUploader_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction mainUploader_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return mainUploader_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? mainUploader_arrayLikeToArray(r, a) : void 0; } }\nfunction mainUploader_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction mainUploader_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction mainUploader_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction MainUploader() {\n  var _preparationSubmissio2, _unsignedTx$success, _unsignedTx$success2;\n  var _useState = (0,react.useState)("files"),\n    _useState2 = mainUploader_slicedToArray(_useState, 2),\n    activeView = _useState2[0],\n    setActiveView = _useState2[1];\n  // Se usa el nuevo contexto que maneja un solo archivo\n  var _useFileUpload = useFileUpload(),\n    file = _useFileUpload.file,\n    clearFile = _useFileUpload.clearFile;\n  var _useWallet = useWallet(),\n    defaultWallet = _useWallet.defaultWallet;\n  var _useTxPreparation = useTxPreparation(),\n    isPreparing = _useTxPreparation.isProcessing,\n    prepareStep = _useTxPreparation.currentStep,\n    prepareNextStep = _useTxPreparation.nextStep,\n    prepareError = _useTxPreparation.error,\n    clearPrepareError = _useTxPreparation.clearError,\n    prepareFiles = _useTxPreparation.prepareFiles,\n    prepareText = _useTxPreparation.prepareText,\n    signAndSubmitPreparation = _useTxPreparation.signAndSubmit,\n    resetPreparation = _useTxPreparation.reset,\n    preparationSubmissionStatus = _useTxPreparation.submissionStatus,\n    unsignedTxId = _useTxPreparation.unsignedTxId;\n  var _useTxInscription = useTxInscription(),\n    isInscribePreparing = _useTxInscription.isProcessing,\n    inscribeStep = _useTxInscription.currentStep,\n    inscribeNextStep = _useTxInscription.nextStep,\n    inscribeError = _useTxInscription.error,\n    clearInscribeError = _useTxInscription.clearError,\n    inscribeFiles = _useTxInscription.inscribeFiles,\n    signAndSubmitInscription = _useTxInscription.signAndSubmit,\n    resetInscription = _useTxInscription.reset,\n    submissionStatus = _useTxInscription.submissionStatus,\n    unsignedTx = _useTxInscription.unsignedTx;\n  var _useState3 = (0,react.useState)(false),\n    _useState4 = mainUploader_slicedToArray(_useState3, 2),\n    isPrepared = _useState4[0],\n    setIsPrepared = _useState4[1];\n  var _useState5 = (0,react.useState)(false),\n    _useState6 = mainUploader_slicedToArray(_useState5, 2),\n    isInscribed = _useState6[0],\n    setIsInscribed = _useState6[1];\n  var _useState7 = (0,react.useState)(""),\n    _useState8 = mainUploader_slicedToArray(_useState7, 2),\n    delegateText = _useState8[0],\n    setDelegateText = _useState8[1];\n  var _useTxStatus = useTxStatus(),\n    resetStatus = _useTxStatus.resetStatus;\n  (0,react.useEffect)(function () {\n    console.log("prepareError", prepareError);\n    console.log("inscribeError", inscribeError);\n  }, [prepareError, inscribeError, clearPrepareError, clearInscribeError]);\n\n  // Consolidated state management logic\n  (0,react.useEffect)(function () {\n    var _preparationSubmissio;\n    if (prepareError) {\n      console.log("Resetting isPrepared due to error:", prepareError);\n      setIsPrepared(false);\n    } else if (prepareStep === "prepare/retrieve-submission" || (preparationSubmissionStatus === null || preparationSubmissionStatus === void 0 || (_preparationSubmissio = preparationSubmissionStatus.success) === null || _preparationSubmissio === void 0 ? void 0 : _preparationSubmissio.onchain) === "on-chain") {\n      console.log("Final preparation step reached with no errors or transaction is on-chain, setting isPrepared to true");\n      setIsPrepared(true);\n    }\n    if (inscribeError) {\n      console.log("Resetting isInscribed due to error:", inscribeError);\n      setIsInscribed(false);\n    }\n    console.log("prepareStep", prepareStep);\n    console.log("inscribeStep", inscribeStep);\n    console.log("isPrepared", isPrepared);\n    console.log("isInscribed", isInscribed);\n  }, [prepareError, prepareStep, preparationSubmissionStatus, inscribeError]);\n  var getLoadingText = function getLoadingText() {\n    if (!isPrepared) {\n      switch (prepareStep) {\n        case "prepare/construct":\n          return "Preparing and constructing transaction...";\n        case "prepare/retrieve":\n          return "Retrieving utxo preparation transaction for signing...";\n        case "prepare/submit":\n          return "Submitting signed transaction...";\n        case "prepare/retrieve-submission":\n          return "Retrieving preparation submission status...";\n        default:\n          return "Processing...";\n      }\n    } else {\n      switch (inscribeStep) {\n        case "inscription/construct":\n          return "Constructing inscription transaction...";\n        case "inscription/retrieve":\n          return "Retrieving utxo inscription transaction for signing...";\n        case "inscription/submit":\n          return "Submitting signed transaction...";\n        case "inscription/retrieve-submission":\n          return "Retrieving inscription submission status...";\n        case "end":\n          return "Transaction submitted!";\n        default:\n          return "Processing...";\n      }\n    }\n  };\n  var getProgressText = function getProgressText() {\n    if (isInscribed) {\n      return "Inscription completed successfully!";\n    }\n    if (!isPrepared) {\n      switch (prepareStep) {\n        case "prepare/construct":\n          return "Select content to upload";\n        case "prepare/retrieve":\n          return "Sign your transaction(s)";\n        case "prepare/submit":\n          return "Submitting your signed transaction(s)...";\n        case "prepare/retrieve-submission":\n          return "Validating your transaction(s) on chain...";\n        default:\n          return "Processing...";\n      }\n    } else {\n      switch (inscribeStep) {\n        case "inscription/construct":\n          return "Confirm your inscription content";\n        case "inscription/retrieve":\n          return "Sign your transaction(s)";\n        case "inscription/submit":\n          return "Submitting your signed transaction(s)...";\n        case "inscription/retrieve-submission":\n          return "Validating your transaction(s) on chain...";\n        case "end":\n          return "Transaction submitted!";\n        default:\n          return "Processing...";\n      }\n    }\n  };\n  var getButtonText = function getButtonText() {\n    // If there\'s a wallet signing error, show "Retry Signing" button\n    if (inscribeError && inscribeError.includes("Wallet signing error")) {\n      return "Retry Signing";\n    }\n    if (prepareError && prepareError.includes("Wallet signing error")) {\n      return "Retry Signing";\n    }\n    if (!isPrepared) {\n      if (prepareStep === "prepare/construct") {\n        return "Prepare UTxOs for inscription";\n      } else if (prepareStep === "prepare/retrieve") {\n        return "Sign and submit utxo preparation transaction";\n      }\n    } else if (isPrepared && !isInscribed) {\n      if (inscribeStep === "inscription/construct") {\n        return "Inscribe Onchain";\n      } else if (inscribeStep === "inscription/retrieve") {\n        return "Sign and Inscribe";\n      }\n    }\n    return "Processing...";\n  };\n  var isInFinalStep = function isInFinalStep() {\n    return inscribeStep === "inscription/retrieve-submission" || isInscribePreparing;\n  };\n  var handlePrepare = /*#__PURE__*/function () {\n    var _ref = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!(activeView === "files")) {\n              _context.next = 7;\n              break;\n            }\n            if (file) {\n              _context.next = 3;\n              break;\n            }\n            return _context.abrupt("return");\n          case 3:\n            _context.next = 5;\n            return prepareFiles([file]);\n          case 5:\n            _context.next = 9;\n            break;\n          case 7:\n            _context.next = 9;\n            return prepareText(delegateText);\n          case 9:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function handlePrepare() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var handleInscribe = /*#__PURE__*/function () {\n    var _ref2 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee2() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(activeView === "files")) {\n              _context2.next = 7;\n              break;\n            }\n            if (file) {\n              _context2.next = 3;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 3:\n            _context2.next = 5;\n            return inscribeFiles([file]);\n          case 5:\n            _context2.next = 9;\n            break;\n          case 7:\n            _context2.next = 9;\n            return inscribeFiles([new File([delegateText], "inscription.txt", {\n              type: "text/plain"\n            })]);\n          case 9:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2);\n    }));\n    return function handleInscribe() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitPreparation = /*#__PURE__*/function () {\n    var _ref3 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee3() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            setIsPrepared(false); // Reset the state before starting\n            _context3.next = 4;\n            return signAndSubmitPreparation();\n          case 4:\n            _context3.next = 10;\n            break;\n          case 6:\n            _context3.prev = 6;\n            _context3.t0 = _context3["catch"](0);\n            console.error("Error during preparation:", _context3.t0);\n            // Make sure isPrepared is false in case of error\n            setIsPrepared(false);\n          case 10:\n          case "end":\n            return _context3.stop();\n        }\n      }, _callee3, null, [[0, 6]]);\n    }));\n    return function handleSignAndSubmitPreparation() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var handleSignAndSubmitInscription = /*#__PURE__*/function () {\n    var _ref4 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee4() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return signAndSubmitInscription();\n          case 3:\n            // Only set isInscribed to true if there was no error\n            if (!inscribeError) {\n              setIsInscribed(true);\n            }\n            _context4.next = 10;\n            break;\n          case 6:\n            _context4.prev = 6;\n            _context4.t0 = _context4["catch"](0);\n            console.error("Error during inscription:", _context4.t0);\n            // Make sure isInscribed is false in case of error\n            setIsInscribed(false);\n          case 10:\n          case "end":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[0, 6]]);\n    }));\n    return function handleSignAndSubmitInscription() {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var handleBack = function handleBack() {\n    resetPreparation();\n    setIsPrepared(false);\n    // Solo reiniciamos el estado de preparación\n    resetStatus("preparation");\n  };\n  var handleCancel = function handleCancel() {\n    resetPreparation();\n    resetInscription();\n    setIsPrepared(false);\n    setIsInscribed(false);\n    clearFile();\n    setDelegateText("");\n    resetStatus("preparation");\n    resetStatus("inscription");\n    setDelegateText("");\n  };\n  var showLoader = isPreparing || isInFinalStep();\n  var handleMainButtonClick = /*#__PURE__*/function () {\n    var _ref5 = mainUploader_asyncToGenerator(/*#__PURE__*/mainUploader_regeneratorRuntime().mark(function _callee5() {\n      return mainUploader_regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            if (!(prepareError && prepareError.includes("Wallet signing error"))) {\n              _context5.next = 4;\n              break;\n            }\n            _context5.next = 3;\n            return handleSignAndSubmitPreparation();\n          case 3:\n            return _context5.abrupt("return");\n          case 4:\n            if (!(inscribeError && inscribeError.includes("Wallet signing error"))) {\n              _context5.next = 8;\n              break;\n            }\n            _context5.next = 7;\n            return handleSignAndSubmitInscription();\n          case 7:\n            return _context5.abrupt("return");\n          case 8:\n            if (isPrepared) {\n              _context5.next = 19;\n              break;\n            }\n            if (!(prepareStep === "prepare/construct")) {\n              _context5.next = 14;\n              break;\n            }\n            _context5.next = 12;\n            return handlePrepare();\n          case 12:\n            _context5.next = 17;\n            break;\n          case 14:\n            if (!(prepareStep === "prepare/retrieve")) {\n              _context5.next = 17;\n              break;\n            }\n            _context5.next = 17;\n            return handleSignAndSubmitPreparation();\n          case 17:\n            _context5.next = 28;\n            break;\n          case 19:\n            if (!(isPrepared && !isInscribed)) {\n              _context5.next = 28;\n              break;\n            }\n            if (!(inscribeStep === "inscription/construct")) {\n              _context5.next = 25;\n              break;\n            }\n            _context5.next = 23;\n            return handleInscribe();\n          case 23:\n            _context5.next = 28;\n            break;\n          case 25:\n            if (!(inscribeStep === "inscription/retrieve")) {\n              _context5.next = 28;\n              break;\n            }\n            _context5.next = 28;\n            return handleSignAndSubmitInscription();\n          case 28:\n          case "end":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    return function handleMainButtonClick() {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var getTotalSteps = function getTotalSteps() {\n    return 8; // 4 prepare steps + 4 inscription steps\n  };\n  var getCurrentStep = function getCurrentStep() {\n    if (isInscribed) {\n      return 8; // Stay at final step when inscription is complete\n    }\n    var prepareSteps = {\n      "prepare/construct": 1,\n      "prepare/retrieve": 2,\n      "prepare/submit": 3,\n      "prepare/retrieve-submission": 4\n    };\n    var inscribeSteps = {\n      "inscription/construct": 5,\n      "inscription/retrieve": 6,\n      "inscription/submit": 7,\n      "inscription/retrieve-submission": 8,\n      end: 8\n    };\n    if (!isPrepared) {\n      return prepareSteps[prepareStep] || 1;\n    } else {\n      return inscribeSteps[inscribeStep] || 5;\n    }\n  };\n  var getStepPhase = function getStepPhase() {\n    var currentStep = getCurrentStep();\n    return currentStep <= 4 ? "Preparation" : "Inscription";\n  };\n  return /*#__PURE__*/react.createElement(motion.div, {\n    className: "bg-white/10 rounded-4xl backdrop-blur-[10px] p-8 max-w-5xl w-full mx-auto text-white",\n    initial: {\n      opacity: 0,\n      scale: 0.9\n    },\n    animate: {\n      opacity: 1,\n      scale: 1\n    },\n    transition: {\n      duration: 0.5\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "mb-6"\n  }, /*#__PURE__*/react.createElement(ProgressBar, {\n    currentStep: getCurrentStep(),\n    totalSteps: getTotalSteps(),\n    stepText: getProgressText(),\n    phase: getStepPhase()\n  })), !showLoader && !isInscribed && /*#__PURE__*/react.createElement("div", {\n    className: "space-y-6"\n  }, /*#__PURE__*/react.createElement(motion.div, {\n    className: "flex items-center justify-between",\n    initial: {\n      opacity: 0,\n      y: -20\n    },\n    animate: {\n      opacity: 1,\n      y: 0\n    },\n    transition: {\n      duration: 0.5,\n      delay: 0.2\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-[1.25rem]"\n  }, prepareStep == "prepare/construct" ? "Add File or Text to inscribe" : prepareStep == "prepare/retrieve" ? "Preparing your UTxOs." : /*#__PURE__*/react.createElement("strong", null, "Please double check the text items below before continuing:")), /*#__PURE__*/react.createElement("div", {\n    className: "flex "\n  }, /*#__PURE__*/react.createElement("button", {\n    className: "px-2 py-[0.125rem] ".concat(activeView === "files" ? "bg-[#051023] text-white" : "bg-[#051023]/20 text-white/60"),\n    onClick: function onClick() {\n      return setActiveView("files");\n    },\n    style: {\n      borderRadius: "0.25rem"\n    },\n    disabled: prepareStep !== "prepare/construct"\n  }, "Files"), /*#__PURE__*/react.createElement("button", {\n    className: "px-2 py-[0.125rem] ".concat(activeView === "delegate" ? "bg-[#051023] text-white" : "bg-[#051023]/20 text-white/60"),\n    onClick: function onClick() {\n      return setActiveView("delegate");\n    },\n    style: {\n      borderRadius: "0.25rem"\n    },\n    disabled: prepareStep !== "prepare/construct"\n  }, "Text"))), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4"\n  }, (prepareError || inscribeError) && /*#__PURE__*/react.createElement("div", {\n    className: "text-sm text-red-600 bg-white p-4 rounded-md overflow-auto"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "mb-2 font-semibold"\n  }, "Error occurred:"), /*#__PURE__*/react.createElement("pre", {\n    className: "whitespace-pre-wrap"\n  }, JSON.stringify({\n    error: prepareError || inscribeError\n  }, null, 2)), /*#__PURE__*/react.createElement("button", {\n    onClick: prepareError ? clearPrepareError : clearInscribeError,\n    className: "!mt-4 px-3 py-1 bg-blue-600 !text-white rounded hover:bg-blue-700"\n  }, "Clear Error")), inscribeStep === "inscription/retrieve" || inscribeStep === "inscription/submit" || inscribeStep === "inscription/construct" && isPrepared && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 text-[1.25rem]"\n  }, /*#__PURE__*/react.createElement("div", null, "We take no responsibility for typos or wrong punctuation. We are also not checking for any previous inscriptions containing the same text.")), activeView === "files" ? /*#__PURE__*/react.createElement(react.Fragment, null, prepareStep === "prepare/construct" && /*#__PURE__*/react.createElement(UploadBox, null), file && /*#__PURE__*/react.createElement(FileList, null)) : /*#__PURE__*/react.createElement(DelegateView, {\n    text: delegateText,\n    setText: function setText(text) {\n      return setDelegateText(text);\n    },\n    isProcessing: isPreparing || isInFinalStep()\n  })), /*#__PURE__*/react.createElement("div", {\n    className: "flex gap-4"\n  }, (prepareStep === "prepare/retrieve" || inscribeStep === "inscription/retrieve") && /*#__PURE__*/react.createElement(Button, {\n    onClick: handleBack,\n    animate: false,\n    className: "w-1/4",\n    variant: "secondary"\n  }, "Back"), /*#__PURE__*/react.createElement(Button, {\n    onClick: handleMainButtonClick,\n    className: "w-full",\n    disabled: activeView === "files" && !file || activeView === "delegate" && !delegateText.trim() || !defaultWallet ||\n    // Don\'t disable the button when there\'s a wallet signing error\n    isPreparing && !(prepareError && prepareError.includes("Wallet signing error")) && !(inscribeError && inscribeError.includes("Wallet signing error")) || isInFinalStep()\n  }, getButtonText()))), showLoader && /*#__PURE__*/react.createElement(LoadingScreen, {\n    text: getLoadingText()\n  }), unsignedTxId && !isInscribed && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 items-center text-sm w-full mt-8"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold self-start"\n  }, "Preparation Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full"\n  }, unsignedTxId && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 "\n  }, "Preparation Transaction:"), /*#__PURE__*/react.createElement("a", {\n    href: "https://preprod.cardanoscan.io/transaction/".concat(unsignedTxId),\n    target: "_blank",\n    rel: "noopener noreferrer",\n    className: "!text-white/80 hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("svg", {\n    className: "w-4 h-4",\n    viewBox: "0 0 24 24",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M12 12V3M12 3L9 6M12 3L15 6",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  })), unsignedTxId)))), (inscribeStep === "inscription/retrieve" || inscribeStep === "inscription/submit") && (unsignedTx === null || unsignedTx === void 0 ? void 0 : unsignedTx.success) && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 items-center text-sm w-full mt-8"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Inscription Phase"), /*#__PURE__*/react.createElement("div", {\n    className: "border-t border-white/20 my-1"\n  }), /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 mt-2"\n  }, "Inscription Indexing Transaction:"), /*#__PURE__*/react.createElement("a", {\n    href: "https://preprod.cardanoscan.io/transaction/".concat(unsignedTx.success.indexingTxId),\n    target: "_blank",\n    rel: "noopener noreferrer",\n    className: "!text-white/80 hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n  }, /*#__PURE__*/react.createElement("svg", {\n    className: "w-4 h-4",\n    viewBox: "0 0 24 24",\n    fill: "none",\n    xmlns: "http://www.w3.org/2000/svg"\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M12 12V3M12 3L9 6M12 3L15 6",\n    stroke: "currentColor",\n    strokeWidth: "2",\n    strokeLinecap: "round",\n    strokeLinejoin: "round"\n  })), unsignedTx.success.indexingTxId)), unsignedTx.success.shardTxIds && unsignedTx.success.shardTxIds.length > 0 && /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2 w-full mt-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "!text-white/80 font-semibold"\n  }, "Shard Transactions:"), unsignedTx.success.shardTxIds.map(function (shardTxId, index) {\n    return /*#__PURE__*/react.createElement("a", {\n      key: index,\n      href: "https://preprod.cardanoscan.io/transaction/".concat(shardTxId),\n      target: "_blank",\n      rel: "noopener noreferrer",\n      className: "!text-white/80 hover:opacity-80 transition-colors flex items-center gap-2 w-full"\n    }, /*#__PURE__*/react.createElement("svg", {\n      className: "w-4 h-4",\n      viewBox: "0 0 24 24",\n      fill: "none",\n      xmlns: "http://www.w3.org/2000/svg"\n    }, /*#__PURE__*/react.createElement("path", {\n      d: "M9 5H7C5.89543 5 5 5.89543 5 7V19C5 20.1046 5.89543 21 7 21H17C18.1046 21 19 20.1046 19 19V7C19 5.89543 18.1046 5 17 5H15",\n      stroke: "currentColor",\n      strokeWidth: "2",\n      strokeLinecap: "round"\n    }), /*#__PURE__*/react.createElement("path", {\n      d: "M12 12V3M12 3L9 6M12 3L15 6",\n      stroke: "currentColor",\n      strokeWidth: "2",\n      strokeLinecap: "round",\n      strokeLinejoin: "round"\n    })), shardTxId);\n  }))), isInscribed && /*#__PURE__*/react.createElement(FinishScreen, {\n    setIsPrepared: setIsPrepared,\n    setIsInscribed: setIsInscribed,\n    setDelegateText: setDelegateText,\n    submissionStatus: submissionStatus,\n    preparationTxId: preparationSubmissionStatus === null || preparationSubmissionStatus === void 0 || (_preparationSubmissio2 = preparationSubmissionStatus.success) === null || _preparationSubmissio2 === void 0 ? void 0 : _preparationSubmissio2.txid,\n    unsignedTxId: unsignedTxId !== null && unsignedTxId !== void 0 ? unsignedTxId : undefined,\n    indexingTxId: unsignedTx === null || unsignedTx === void 0 || (_unsignedTx$success = unsignedTx.success) === null || _unsignedTx$success === void 0 ? void 0 : _unsignedTx$success.indexingTxId,\n    shardTxIds: unsignedTx === null || unsignedTx === void 0 || (_unsignedTx$success2 = unsignedTx.success) === null || _unsignedTx$success2 === void 0 ? void 0 : _unsignedTx$success2.shardTxIds\n  }));\n}\n;// ./src/components/wallet/ConnectWallet.tsx\n\n\n\nfunction ConnectWallet() {\n  var _useWallet = useWallet(),\n    openMenu = _useWallet.openMenu,\n    defaultWallet = _useWallet.defaultWallet;\n  return /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Button, {\n    onClick: openMenu,\n    animate: false\n  }, defaultWallet ? "Connected to ".concat(defaultWallet) : "Connect Wallet"));\n}\n;// ./src/icons/CloseIconSecondary.tsx\n\nvar CloseIconSecondary = function CloseIconSecondary(_ref) {\n  var className = _ref.className;\n  return /*#__PURE__*/react.createElement("svg", {\n    xmlns: "http://www.w3.org/2000/svg",\n    width: "30",\n    height: "30",\n    viewBox: "0 0 20 20",\n    fill: "none",\n    className: className\n  }, /*#__PURE__*/react.createElement("path", {\n    d: "M18.0553 0.333831C18.5002 -0.111047 19.2215 -0.111047 19.6663 0.33383C20.1112 0.778708 20.1112 1.5 19.6663 1.94487L1.94486 19.6664C1.49998 20.1112 0.778695 20.1112 0.333818 19.6664C-0.111059 19.2215 -0.111059 18.5002 0.333818 18.0553L18.0553 0.333831Z",\n    fill: "currentColor"\n  }), /*#__PURE__*/react.createElement("path", {\n    d: "M0.333658 1.9447C-0.111219 1.49982 -0.11122 0.778535 0.333658 0.333658C0.778535 -0.111219 1.49982 -0.111219 1.9447 0.333658L19.6662 18.0551C20.1111 18.5 20.1111 19.2213 19.6662 19.6662C19.2213 20.1111 18.5 20.1111 18.0551 19.6662L0.333658 1.9447Z",\n    fill: "currentColor"\n  }));\n};\n;// ./src/components/wallet/WalletMenu.tsx\nfunction WalletMenu_slicedToArray(r, e) { return WalletMenu_arrayWithHoles(r) || WalletMenu_iterableToArrayLimit(r, e) || WalletMenu_unsupportedIterableToArray(r, e) || WalletMenu_nonIterableRest(); }\nfunction WalletMenu_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction WalletMenu_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return WalletMenu_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? WalletMenu_arrayLikeToArray(r, a) : void 0; } }\nfunction WalletMenu_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction WalletMenu_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction WalletMenu_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n\nfunction WalletMenu() {\n  var _useWallet = useWallet(),\n    isMenuOpen = _useWallet.isMenuOpen,\n    closeMenu = _useWallet.closeMenu,\n    wallets = _useWallet.wallets,\n    connectedWallets = _useWallet.connectedWallets,\n    defaultWallet = _useWallet.defaultWallet,\n    connectWallet = _useWallet.connectWallet,\n    disconnectWallet = _useWallet.disconnectWallet,\n    setDefaultWallet = _useWallet.setDefaultWallet,\n    installedWallets = _useWallet.installedWallets;\n  var availableWallets = Object.entries(wallets).filter(function (_ref) {\n    var _ref2 = WalletMenu_slicedToArray(_ref, 2),\n      key = _ref2[0],\n      _ = _ref2[1];\n    return installedWallets.includes(key) && !connectedWallets.some(function (w) {\n      return w.name.toLowerCase() === key;\n    });\n  });\n  var walletsToInstall = Object.entries(wallets).filter(function (_ref3) {\n    var _ref4 = WalletMenu_slicedToArray(_ref3, 2),\n      key = _ref4[0],\n      _ = _ref4[1];\n    return !installedWallets.includes(key);\n  });\n  return /*#__PURE__*/react.createElement(AnimatePresence, null, isMenuOpen && /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(motion.div, {\n    className: "fixed inset-0  backdrop-blur-[2px] z-40",\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    },\n    onClick: closeMenu\n  }), /*#__PURE__*/react.createElement(motion.div, {\n    className: "fixed top-0 right-0 h-full w-full max-w-md bg-white/10 backdrop-blur-xl p-6 z-50 text-white overflow-y-auto",\n    initial: {\n      x: "100%"\n    },\n    animate: {\n      x: 0\n    },\n    exit: {\n      x: "100%"\n    },\n    transition: {\n      type: "spring",\n      damping: 20,\n      stiffness: 100\n    }\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "h-full flex flex-col"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center justify-between mb-2"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-[2rem] font-medium"\n  }, "Connect wallet"), /*#__PURE__*/react.createElement(Button, {\n    variant: "ghost",\n    className: "p-1 hover:bg-white/10 rounded-full",\n    onClick: closeMenu\n  }, /*#__PURE__*/react.createElement(CloseIconSecondary, {\n    className: "w-6 h-6"\n  }))), /*#__PURE__*/react.createElement("p", {\n    className: "!text-sm !text-light !mb-6"\n  }, "By connecting your wallet you agree to our", " ", /*#__PURE__*/react.createElement("a", {\n    href: "#",\n    className: "!text-light underline"\n  }, "Terms"), " ", "and", " ", /*#__PURE__*/react.createElement("a", {\n    href: "#",\n    className: "!text-light underline"\n  }, "Privacy Policy"), "."), /*#__PURE__*/react.createElement("div", {\n    className: "overflow-y-auto flex flex-col gap-8"\n  }, connectedWallets.length > 0 && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {\n    className: "text-xl font-medium mb-3"\n  }, "Connected wallets"), /*#__PURE__*/react.createElement("div", {\n    className: "space-y-2"\n  }, connectedWallets.map(function (connectedWallet) {\n    var wallet = wallets[connectedWallet.name.toLowerCase()];\n    var isDefault = (defaultWallet === null || defaultWallet === void 0 ? void 0 : defaultWallet.toLowerCase()) === connectedWallet.name.toLowerCase();\n    return /*#__PURE__*/react.createElement("div", {\n      key: connectedWallet.name,\n      className: "w-full flex items-center justify-between p-3 rounded-xl transition-colors ".concat(isDefault ? "bg-blue-500/20" : "bg-white/5")\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-3"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "w-8 h-8 bg-white/10 rounded-full flex items-center justify-center"\n    }, /*#__PURE__*/react.createElement("img", {\n      src: wallet.icon || "/placeholder.svg",\n      alt: wallet.name,\n      className: "w-5 h-5"\n    })), /*#__PURE__*/react.createElement("span", null, wallet.name)), /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-2"\n    }, !isDefault && /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm hover:bg-white/10",\n      onClick: function onClick() {\n        return setDefaultWallet(wallet.name);\n      }\n    }, "Make default"), /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm text-red-400 hover:bg-red-500/10 !hidden",\n      onClick: function onClick() {\n        return disconnectWallet(wallet.name);\n      }\n    }, "Disconnect")));\n  }))), availableWallets.length > 0 && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {\n    className: "text-xl font-medium mb-3"\n  }, "Available wallets"), /*#__PURE__*/react.createElement("div", {\n    className: "space-y-2"\n  }, availableWallets.map(function (_ref5) {\n    var _ref6 = WalletMenu_slicedToArray(_ref5, 2),\n      key = _ref6[0],\n      wallet = _ref6[1];\n    return /*#__PURE__*/react.createElement("div", {\n      key: key,\n      className: "w-full flex items-center justify-between p-3 bg-white/5 hover:bg-white/10 rounded-xl transition-colors"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-3"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "w-8 h-8 bg-white/10 rounded-full flex items-center justify-center"\n    }, /*#__PURE__*/react.createElement("img", {\n      src: wallet.icon || "/placeholder.svg",\n      alt: wallet.name,\n      className: "w-5 h-5"\n    })), /*#__PURE__*/react.createElement("span", null, wallet.name)), /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm hover:bg-white/10",\n      onClick: function onClick() {\n        return connectWallet(wallet.name);\n      },\n      successText: "Connected"\n    }, "Connect"));\n  }))), walletsToInstall.length > 0 && /*#__PURE__*/react.createElement("div", null, /*#__PURE__*/react.createElement("div", {\n    className: "text-xl font-medium mb-3"\n  }, "Select a wallet to install"), /*#__PURE__*/react.createElement("div", {\n    className: "space-y-2"\n  }, walletsToInstall.map(function (_ref7) {\n    var _ref8 = WalletMenu_slicedToArray(_ref7, 2),\n      key = _ref8[0],\n      wallet = _ref8[1];\n    return /*#__PURE__*/react.createElement("div", {\n      key: key,\n      className: "w-full flex items-center justify-between p-3 bg-white/5 hover:bg-white/10 rounded-xl transition-colors"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "flex items-center gap-3"\n    }, /*#__PURE__*/react.createElement("div", {\n      className: "w-8 h-8 bg-white/10 rounded-full flex items-center justify-center"\n    }, /*#__PURE__*/react.createElement("img", {\n      src: wallet.icon || "/placeholder.svg",\n      alt: wallet.name,\n      className: "w-5 h-5"\n    })), /*#__PURE__*/react.createElement("span", null, wallet.name)), /*#__PURE__*/react.createElement(Button, {\n      variant: "ghost",\n      className: "text-sm hover:bg-white/10",\n      onClick: function onClick(e) {\n        e.stopPropagation();\n        window.open(wallet.url, "_blank");\n      }\n    }, "Install"));\n  }))))))));\n}\n;// ./src/utils/decoder.ts\nfunction decoder_typeof(o) { "@babel/helpers - typeof"; return decoder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, decoder_typeof(o); }\nfunction decoder_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ decoder_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == decoder_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(decoder_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction decoder_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction decoder_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { decoder_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { decoder_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\n// src/utils/decoder.ts\n// No need for WASI imports anymore\n\n/**\n * Type definition for the WASM instance with exported functions\n */\n\n/**\n * Initialize the WASM decoder by fetching and instantiating the WASM module\n * @param wasmModuleUrl Optional URL to the WASM module, defaults to the S3 URL\n * @returns Object containing the instantiated WASM module\n */\nfunction initializeWasmDecoder(_x) {\n  return _initializeWasmDecoder.apply(this, arguments);\n}\n\n/**\n * Validates if a string is a valid hexadecimal string\n */\nfunction _initializeWasmDecoder() {\n  _initializeWasmDecoder = decoder_asyncToGenerator(/*#__PURE__*/decoder_regeneratorRuntime().mark(function _callee(wasmModuleUrl) {\n    var wasmUrl, response, compiledWasmDecoder, wasiHandler, baseWasi, importObject, wasmInstance, _response, wasmBytes, wasmModule, _wasiHandler, _baseWasi, _importObject, _wasmInstance;\n    return decoder_regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _context.prev = 0;\n          wasmUrl = wasmModuleUrl || \'https://metadata-decoder-wasm.s3.us-east-1.amazonaws.com/wasm-decoder.wasm\';\n          console.log("Loading WASM from URL:", wasmUrl);\n\n          // First try the streaming approach\n          _context.prev = 3;\n          _context.next = 6;\n          return fetch(wasmUrl);\n        case 6:\n          response = _context.sent;\n          console.log("Response:", response);\n          // Check if the response is ok\n          if (response.ok) {\n            _context.next = 10;\n            break;\n          }\n          throw new Error("HTTP error! status: ".concat(response.status));\n        case 10:\n          _context.next = 12;\n          return WebAssembly.compileStreaming(response);\n        case 12:\n          compiledWasmDecoder = _context.sent;\n          // Create a dynamic WASI import object with a Proxy\n          // This will automatically handle any WASI function that the module requires\n          wasiHandler = {\n            get: function get(target, prop) {\n              // If the property already exists, return it\n              if (prop in target) {\n                return target[prop];\n              }\n\n              // Otherwise, create a function that returns 0 (success in WASI)\n              console.log("Auto-creating WASI function: ".concat(prop));\n              return function () {\n                console.log("Called auto-created WASI function: ".concat(prop, " with ").concat(arguments.length, " args"));\n                return 0; // Return success for any function\n              };\n            }\n          }; // Base WASI functions with explicit implementations\n          baseWasi = {\n            proc_exit: function proc_exit(code) {\n              console.log("proc_exit called with code: ".concat(code));\n            },\n            fd_write: function fd_write(fd, iovs, iovsLen, nwritten) {\n              console.log("fd_write called: fd=".concat(fd, ", iovs=").concat(iovs, ", iovsLen=").concat(iovsLen, ", nwritten=").concat(nwritten));\n              return 0;\n            }\n          }; // Create the import object with a Proxy for wasi_snapshot_preview1\n          importObject = {\n            wasi_snapshot_preview1: new Proxy(baseWasi, wasiHandler)\n          };\n          _context.next = 18;\n          return WebAssembly.instantiate(compiledWasmDecoder, importObject);\n        case 18:\n          wasmInstance = _context.sent;\n          console.log("WASM initialized successfully via streaming");\n          return _context.abrupt("return", {\n            wasmInstance: wasmInstance\n          });\n        case 23:\n          _context.prev = 23;\n          _context.t0 = _context["catch"](3);\n          console.warn("Streaming compilation failed, falling back to ArrayBuffer approach:", _context.t0);\n\n          // Fallback to ArrayBuffer approach if streaming fails\n          _context.next = 28;\n          return fetch(wasmUrl);\n        case 28:\n          _response = _context.sent;\n          console.log("Response:", _response);\n          if (_response.ok) {\n            _context.next = 32;\n            break;\n          }\n          throw new Error("HTTP error! status: ".concat(_response.status));\n        case 32:\n          _context.next = 34;\n          return _response.arrayBuffer();\n        case 34:\n          wasmBytes = _context.sent;\n          _context.next = 37;\n          return WebAssembly.compile(wasmBytes);\n        case 37:\n          wasmModule = _context.sent;\n          // Reuse the same dynamic WASI handler approach\n          _wasiHandler = {\n            get: function get(target, prop) {\n              // If the property already exists, return it\n              if (prop in target) {\n                return target[prop];\n              }\n\n              // Otherwise, create a function that returns 0 (success in WASI)\n              console.log("Auto-creating WASI function: ".concat(prop));\n              return function () {\n                console.log("Called auto-created WASI function: ".concat(prop, " with ").concat(arguments.length, " args"));\n                return 0; // Return success for any function\n              };\n            }\n          }; // Base WASI functions with explicit implementations\n          _baseWasi = {\n            proc_exit: function proc_exit(code) {\n              console.log("proc_exit called with code: ".concat(code));\n            },\n            fd_write: function fd_write(fd, iovs, iovsLen, nwritten) {\n              console.log("fd_write called: fd=".concat(fd, ", iovs=").concat(iovs, ", iovsLen=").concat(iovsLen, ", nwritten=").concat(nwritten));\n              return 0;\n            }\n          }; // Create the import object with a Proxy for wasi_snapshot_preview1\n          _importObject = {\n            wasi_snapshot_preview1: new Proxy(_baseWasi, _wasiHandler)\n          };\n          _context.next = 43;\n          return WebAssembly.instantiate(wasmModule, _importObject);\n        case 43:\n          _wasmInstance = _context.sent;\n          console.log("WASM initialized successfully via ArrayBuffer");\n          return _context.abrupt("return", {\n            wasmInstance: _wasmInstance\n          });\n        case 46:\n          _context.next = 52;\n          break;\n        case 48:\n          _context.prev = 48;\n          _context.t1 = _context["catch"](0);\n          console.error("WASM initialization failed:", _context.t1);\n          throw _context.t1;\n        case 52:\n        case "end":\n          return _context.stop();\n      }\n    }, _callee, null, [[0, 48], [3, 23]]);\n  }));\n  return _initializeWasmDecoder.apply(this, arguments);\n}\nfunction isValidHexString(hex) {\n  return true;\n  return /^[0-9A-Fa-f]*$/.test(hex);\n}\n\n/**\n * Pure JavaScript implementation for reconstructing bytes from hex strings\n * This is used as a fallback when WASM initialization fails\n */\nfunction hexToBytes(hex) {\n  // Remove any non-hex characters (like spaces or line breaks)\n  hex = hex.replace(/[^0-9A-Fa-f]/g, \'\');\n\n  // Ensure we have an even number of characters\n  if (hex.length % 2 !== 0) {\n    hex = \'0\' + hex;\n  }\n  var bytes = new Uint8Array(hex.length / 2);\n  for (var i = 0; i < hex.length; i += 2) {\n    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n  }\n  return bytes;\n}\n\n/**\n * Convert a byte array to a base64 string\n */\nfunction bytesToBase64(bytes) {\n  var binString = Array.from(bytes).map(function (_byte) {\n    return String.fromCharCode(_byte);\n  }).join(\'\');\n  return btoa(binString);\n}\n\n/**\n * Reconstructs the original bytes from an array of hex strings\n * First tries to use the WASM implementation, falls back to pure JS if that fails\n */\nfunction reconstructOriginalBytes(_x2, _x3) {\n  return _reconstructOriginalBytes.apply(this, arguments);\n}\n\n/**\n * Helper: Read a null-terminated C string from WASM memory\n */\nfunction _reconstructOriginalBytes() {\n  _reconstructOriginalBytes = decoder_asyncToGenerator(/*#__PURE__*/decoder_regeneratorRuntime().mark(function _callee2(wInstance, hexStringArray) {\n    var validHexStrings, hexStringPtrs, hexStringArrayPtrAddr, base64Ptr, mem, view, i, _base, combinedHex, bytes, base64;\n    return decoder_regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          console.log(\'Reconstructing bytes from hex strings:\', hexStringArray);\n          _context2.prev = 1;\n          // Validate hex strings\n          validHexStrings = hexStringArray.filter(function (hex) {\n            return isValidHexString(hex);\n          });\n          if (!(validHexStrings.length === 0)) {\n            _context2.next = 5;\n            break;\n          }\n          throw new Error(\'No valid hex strings provided\');\n        case 5:\n          console.log(\'Valid hex strings:\', validHexStrings);\n\n          // Try WASM implementation first if available\n          if (!(wInstance && wInstance.exports && wInstance.exports.memory)) {\n            _context2.next = 42;\n            break;\n          }\n          _context2.prev = 7;\n          console.log(\'Attempting to use WASM implementation...\');\n\n          // Initialize the Haskell runtime\n          wInstance.exports.hs_init(0, 0);\n          hexStringPtrs = [];\n          hexStringArrayPtrAddr = 0;\n          base64Ptr = 0;\n          _context2.prev = 13;\n          // Allocate and write each hex string to WASM memory\n          hexStringPtrs = validHexStrings.map(function (str) {\n            return writeCString(str, wInstance);\n          });\n\n          // Allocate memory for the array of pointers\n          hexStringArrayPtrAddr = wInstance.exports.malloc_bytes_hs(hexStringPtrs.length * 4); // 4 bytes per pointer\n\n          // Write the array of pointers to WASM memory\n          mem = new Uint8Array(wInstance.exports.memory.buffer);\n          view = new DataView(wInstance.exports.memory.buffer);\n          for (i = 0; i < hexStringPtrs.length; i++) {\n            view.setUint32(hexStringArrayPtrAddr + i * 4, hexStringPtrs[i], true); // true for little-endian\n          }\n\n          // Call the WASM function to reconstruct the bytes\n          console.log("Calling reconstructOriginalBytesC with count=".concat(hexStringPtrs.length, ", ptrArray=").concat(hexStringArrayPtrAddr));\n          base64Ptr = wInstance.exports.reconstructOriginalBytesC(hexStringPtrs.length, hexStringArrayPtrAddr);\n          if (!(base64Ptr === 0)) {\n            _context2.next = 23;\n            break;\n          }\n          throw new Error(\'WASM function returned null pointer\');\n        case 23:\n          // Read the result from WASM memory\n          _base = readCString(wInstance.exports.memory.buffer, base64Ptr);\n          console.log("Successfully reconstructed bytes, base64 length: ".concat(_base.length));\n\n          // Free the allocated memory\n          wInstance.exports.free_hs(base64Ptr);\n          wInstance.exports.free_hs(hexStringArrayPtrAddr);\n\n          // Free individual hex strings\n          hexStringPtrs.forEach(function (ptr) {\n            if (ptr !== 0) wInstance.exports.free_hs(ptr);\n          });\n\n          // Shut down the Haskell runtime\n          wInstance.exports.hs_exit();\n          return _context2.abrupt("return", _base);\n        case 32:\n          _context2.prev = 32;\n          _context2.t0 = _context2["catch"](13);\n          console.warn(\'Error during WASM execution:\', _context2.t0);\n\n          // Clean up any allocated memory if possible\n          try {\n            if (base64Ptr !== 0) wInstance.exports.free_hs(base64Ptr);\n            if (hexStringArrayPtrAddr !== 0) wInstance.exports.free_hs(hexStringArrayPtrAddr);\n\n            // Free individual hex strings\n            hexStringPtrs.forEach(function (ptr) {\n              if (ptr !== 0) wInstance.exports.free_hs(ptr);\n            });\n\n            // Shut down the Haskell runtime\n            wInstance.exports.hs_exit();\n          } catch (cleanupError) {\n            console.warn(\'Error during cleanup:\', cleanupError);\n          }\n          throw _context2.t0;\n        case 37:\n          _context2.next = 42;\n          break;\n        case 39:\n          _context2.prev = 39;\n          _context2.t1 = _context2["catch"](7);\n          console.warn(\'WASM implementation failed, falling back to JS:\', _context2.t1);\n          // Fall back to JS implementation\n        case 42:\n          // JavaScript fallback implementation\n          console.log(\'Using JavaScript fallback implementation\');\n\n          // Concatenate all hex strings\n          combinedHex = validHexStrings.join(\'\');\n          console.log(\'Combined hex:\', combinedHex);\n\n          // Convert to bytes\n          bytes = hexToBytes(combinedHex);\n          console.log(\'Converted to bytes, length:\', bytes.length);\n\n          // Convert to base64\n          base64 = bytesToBase64(bytes);\n          console.log(\'Converted to base64, length:\', base64.length);\n          return _context2.abrupt("return", base64);\n        case 52:\n          _context2.prev = 52;\n          _context2.t2 = _context2["catch"](1);\n          console.error(\'Error in reconstructOriginalBytes:\', _context2.t2);\n          throw new Error("Failed to reconstruct bytes: ".concat(_context2.t2.message || String(_context2.t2)));\n        case 56:\n        case "end":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[1, 52], [7, 39], [13, 32]]);\n  }));\n  return _reconstructOriginalBytes.apply(this, arguments);\n}\nfunction readCString(memory, ptr) {\n  if (!memory) {\n    throw new Error(\'Memory buffer is undefined in readCString\');\n  }\n  try {\n    console.log("Reading C string from memory at pointer: ".concat(ptr));\n    console.log("Memory buffer size: ".concat(memory.byteLength));\n    var mem = new Uint8Array(memory);\n    var end = ptr;\n    var memLength = mem.length;\n\n    // Check for out-of-bounds access\n    if (ptr >= memLength) {\n      throw new Error("readCString: Pointer ".concat(ptr, " is outside WASM memory bounds."));\n    }\n\n    // Find null terminator, but stop at memory boundary\n    while (end < memLength && mem[end] !== 0) {\n      end++;\n    }\n    if (end >= mem.length) {\n      throw new Error("readCString: Unterminated string (no null byte found).");\n    }\n\n    // Decode the string\n    var result = new TextDecoder().decode(mem.subarray(ptr, end));\n    console.log("Successfully read string of length ".concat(end - ptr));\n    return result;\n  } catch (error) {\n    console.error(\'Error in readCString:\', error);\n    throw new Error("Error in readCString: ".concat(error.message || String(error)));\n  }\n}\n\n/**\n * Helper: Write a JS string to WASM memory (returns pointer)\n */\nfunction writeCString(str, wInstance) {\n  if (!wInstance || !wInstance.exports || !wInstance.exports.memory || !wInstance.exports.memory.buffer) {\n    console.error(\'WASM instance structure:\', wInstance);\n    throw new Error(\'Invalid WASM instance structure in writeCString\');\n  }\n  try {\n    var lengthNeeded = str.length + 1;\n    var ptr = wInstance.exports.malloc_bytes_hs(str.length + 1); // +1 for null terminator\n    console.log("Allocated memory at pointer: ".concat(ptr, " for string length: ").concat(str.length));\n    var mem = new Uint8Array(wInstance.exports.memory.buffer);\n    console.log("Memory buffer size: ".concat(mem.length));\n\n    // Check if pointer is valid and space is sufficient\n    if (ptr + lengthNeeded >= mem.length) {\n      wInstance.exports.free_hs(ptr); // Avoid leaking memory\n      throw new Error("writeCString: String \'".concat(str, "\' exceeds allocated WASM memory."));\n    }\n    for (var i = 0; i < str.length; i++) {\n      mem[ptr + i] = str.charCodeAt(i);\n    }\n    mem[ptr + str.length] = 0; // Null-terminate\n    return ptr;\n  } catch (error) {\n    console.error(\'Error in writeCString:\', error);\n    throw new Error("Error in writeCString: ".concat(error.message || String(error)));\n  }\n}\n\n/**\n * Helper: Convert base64 string to byte array\n */\nfunction base64ToBytes(base64) {\n  var binStr = atob(base64);\n  var bytes = new Uint8Array(binStr.length);\n  for (var i = 0; i < binStr.length; i++) {\n    bytes[i] = binStr.charCodeAt(i);\n  }\n  return bytes;\n}\n;// ./src/components/decoder/HexDecoder.tsx\nfunction HexDecoder_typeof(o) { "@babel/helpers - typeof"; return HexDecoder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, HexDecoder_typeof(o); }\nfunction HexDecoder_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ HexDecoder_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == HexDecoder_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(HexDecoder_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction HexDecoder_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction HexDecoder_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { HexDecoder_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { HexDecoder_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction HexDecoder_slicedToArray(r, e) { return HexDecoder_arrayWithHoles(r) || HexDecoder_iterableToArrayLimit(r, e) || HexDecoder_unsupportedIterableToArray(r, e) || HexDecoder_nonIterableRest(); }\nfunction HexDecoder_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction HexDecoder_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return HexDecoder_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? HexDecoder_arrayLikeToArray(r, a) : void 0; } }\nfunction HexDecoder_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction HexDecoder_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction HexDecoder_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n// Import from our new TypeScript implementation\n\nvar HexDecoder = function HexDecoder() {\n  var _useState = (0,react.useState)(""),\n    _useState2 = HexDecoder_slicedToArray(_useState, 2),\n    input = _useState2[0],\n    setInput = _useState2[1];\n  var _useState3 = (0,react.useState)("utf8"),\n    _useState4 = HexDecoder_slicedToArray(_useState3, 2),\n    format = _useState4[0],\n    setFormat = _useState4[1];\n  var _useState5 = (0,react.useState)(false),\n    _useState6 = HexDecoder_slicedToArray(_useState5, 2),\n    loading = _useState6[0],\n    setLoading = _useState6[1];\n  var _useState7 = (0,react.useState)(null),\n    _useState8 = HexDecoder_slicedToArray(_useState7, 2),\n    result = _useState8[0],\n    setResult = _useState8[1];\n  var _useState9 = (0,react.useState)(null),\n    _useState10 = HexDecoder_slicedToArray(_useState9, 2),\n    error = _useState10[0],\n    setError = _useState10[1];\n  var wasmInstance = (0,react.useRef)(null);\n  var lastHexInput = (0,react.useRef)("");\n  var lastBase64 = (0,react.useRef)("");\n  var initWasm = /*#__PURE__*/function () {\n    var _ref = HexDecoder_asyncToGenerator(/*#__PURE__*/HexDecoder_regeneratorRuntime().mark(function _callee() {\n      var _yield$initializeWasm, inst;\n      return HexDecoder_regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (wasmInstance.current) {\n              _context.next = 13;\n              break;\n            }\n            _context.prev = 1;\n            _context.next = 4;\n            return initializeWasmDecoder();\n          case 4:\n            _yield$initializeWasm = _context.sent;\n            inst = _yield$initializeWasm.wasmInstance;\n            wasmInstance.current = inst;\n            console.log("WASM decoder initialized successfully");\n            _context.next = 13;\n            break;\n          case 10:\n            _context.prev = 10;\n            _context.t0 = _context["catch"](1);\n            console.warn("Failed to initialize WASM decoder, will use JS fallback:", _context.t0);\n            // We\'ll continue without a WASM instance and use the JS fallback\n          case 13:\n            return _context.abrupt("return", wasmInstance.current);\n          case 14:\n          case "end":\n            return _context.stop();\n        }\n      }, _callee, null, [[1, 10]]);\n    }));\n    return function initWasm() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  var decode = /*#__PURE__*/function () {\n    var _ref2 = HexDecoder_asyncToGenerator(/*#__PURE__*/HexDecoder_regeneratorRuntime().mark(function _callee2() {\n      var inst, hexs, txt, arr, out;\n      return HexDecoder_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            setError(null);\n            setResult(null);\n            if (input.trim()) {\n              _context2.next = 5;\n              break;\n            }\n            setError("Please paste some hexadecimal strings first.");\n            return _context2.abrupt("return");\n          case 5:\n            setLoading(true);\n            _context2.prev = 6;\n            _context2.next = 9;\n            return initWasm();\n          case 9:\n            inst = _context2.sent;\n            txt = input.trim();\n            if (txt.startsWith("[") && txt.endsWith("]")) {\n              try {\n                arr = JSON.parse(txt);\n                hexs = Array.isArray(arr) ? arr : [String(arr)];\n              } catch (_unused) {\n                hexs = txt.split("\\n").filter(function (l) {\n                  return l.trim();\n                });\n              }\n            } else {\n              hexs = txt.split("\\n").map(function (l) {\n                return l.trim();\n              }).filter(Boolean);\n            }\n\n            // Only process if input has changed\n            if (!(txt !== lastHexInput.current)) {\n              _context2.next = 20;\n              break;\n            }\n            console.log("Processing new hex input");\n            // Our reconstructOriginalBytes function can now handle a null WASM instance\n            _context2.next = 16;\n            return reconstructOriginalBytes(inst, hexs);\n          case 16:\n            lastBase64.current = _context2.sent;\n            lastHexInput.current = txt;\n            _context2.next = 21;\n            break;\n          case 20:\n            console.log("Using cached result");\n          case 21:\n            if (format === "utf8") {\n              try {\n                out = atob(lastBase64.current);\n                console.log("Converted base64 to UTF-8 text");\n              } catch (err) {\n                console.warn("Failed to decode base64 as UTF-8, using raw base64:", err);\n                out = lastBase64.current;\n              }\n            } else {\n              // For binary formats we still hold base64; user can download or preview elsewhere\n              out = lastBase64.current;\n            }\n            setResult(out);\n            _context2.next = 29;\n            break;\n          case 25:\n            _context2.prev = 25;\n            _context2.t0 = _context2["catch"](6);\n            console.error("Decoding error:", _context2.t0);\n            setError("Decoding error: " + (_context2.t0.message || _context2.t0.toString()));\n          case 29:\n            _context2.prev = 29;\n            setLoading(false);\n            return _context2.finish(29);\n          case 32:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[6, 25, 29, 32]]);\n    }));\n    return function decode() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var tabs = [{\n    key: "utf8",\n    label: "Text (UTF‑8)"\n  }, {\n    key: "base64",\n    label: "Base64"\n  }, {\n    key: "png",\n    label: "PNG"\n  }, {\n    key: "jpeg",\n    label: "JPEG"\n  }, {\n    key: "pdf",\n    label: "PDF"\n  }];\n  return /*#__PURE__*/react.createElement("div", {\n    className: "bg-white/10 rounded-4xl backdrop-blur-[10px] p-8 max-w-5xl w-full mx-auto text-white"\n  }, /*#__PURE__*/react.createElement("h2", {\n    className: "text-2xl font-bold text-white mb-4"\n  }, "Metadata:"), /*#__PURE__*/react.createElement("div", {\n    className: "mb-6"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "rounded-3xl bg-white/10 backdrop-blur-[10px] flex flex-col gap-2 relative"\n  }, input.trim() === "" && /*#__PURE__*/react.createElement("div", {\n    className: "font-mono text-base text-[#C3D5F7] mb-1 absolute inset-0 p-8 flex flex-col pointer-events-none"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "block mb-1"\n  }, "Paste your hex strings here, one per line or as an array:"), /*#__PURE__*/react.createElement("span", {\n    className: "italic mt-6"\n  }, "Example (line by line):"), /*#__PURE__*/react.createElement("pre", {\n    className: "mb-1"\n  }, "48656C6C6F20576F726C64", "\\n", "4D756C74694C696E65"), /*#__PURE__*/react.createElement("span", {\n    className: "italic mt-6"\n  }, "Or (array format):"), /*#__PURE__*/react.createElement("pre", null, "[\\"48656C6C6F\\", \\"576F726C64\\"]")), /*#__PURE__*/react.createElement("textarea", {\n    value: input,\n    onChange: function onChange(e) {\n      return setInput(e.target.value);\n    },\n    className: "w-full min-h-[20rem] p-8 font-mono text-sm text-gray-200 bg-transparent rounded-lg resize-y focus:outline-none focus:border-blue-400"\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "mb-6"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-white font-medium mb-2"\n  }, "Output:"), /*#__PURE__*/react.createElement("div", {\n    className: "inline-flex rounded-lg p-1 gap-2"\n  }, tabs.map(function (tab) {\n    return /*#__PURE__*/react.createElement("button", {\n      key: tab.key,\n      onClick: function onClick() {\n        return setFormat(tab.key);\n      },\n      className: "px-2 py-1 text-sm font-medium rounded-lg transition ".concat(format === tab.key ? "bg-[#051023] bg-opacity-50 text-white" : "text-gray-200 bg-white/10")\n    }, tab.label);\n  }))), /*#__PURE__*/react.createElement("button", {\n    onClick: decode,\n    disabled: loading,\n    className: "w-full py-3 rounded-full bg-blue-600 hover:bg-blue-700 text-white font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed"\n  }, loading ? "Decoding…" : "Decode"), (result || error) && /*#__PURE__*/react.createElement("div", {\n    className: "mt-8"\n  }, /*#__PURE__*/react.createElement("h3", {\n    className: "text-lg font-semibold text-white mb-2"\n  }, error ? "Error" : "Decoded Result"), /*#__PURE__*/react.createElement("div", {\n    className: "mt-4 bg-white/10 rounded-4xl backdrop-blur-[10px] border-l-4 border-blue-500 p-5 font-mono text-sm text-gray-100 max-h-64 overflow-y-auto whitespace-pre-wrap"\n  }, error ? error : format === "png" || format === "jpeg" ? /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center"\n  }, /*#__PURE__*/react.createElement("img", {\n    src: "data:image/".concat(format, ";base64,").concat(result),\n    alt: "Decoded image",\n    className: "max-w-full max-h-56 object-contain"\n  }), /*#__PURE__*/react.createElement("a", {\n    href: "data:image/".concat(format, ";base64,").concat(result),\n    download: "decoded.".concat(format),\n    className: "mt-3 text-blue-400 hover:text-blue-300 underline text-sm"\n  }, "Download Image")) : format === "pdf" ? /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col items-center"\n  }, /*#__PURE__*/react.createElement("iframe", {\n    src: "data:application/pdf;base64,".concat(result),\n    className: "w-full h-56 border-0",\n    title: "PDF Viewer"\n  }), /*#__PURE__*/react.createElement("a", {\n    href: "data:application/pdf;base64,".concat(result),\n    download: "decoded.pdf",\n    className: "mt-3 text-blue-400 hover:text-blue-300 underline text-sm"\n  }, "Download PDF")) : result)));\n};\n/* harmony default export */ const decoder_HexDecoder = (HexDecoder);\n;// ./src/components/uploads/useRewardAccounts.ts\nfunction useRewardAccounts_typeof(o) { "@babel/helpers - typeof"; return useRewardAccounts_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, useRewardAccounts_typeof(o); }\nfunction useRewardAccounts_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ useRewardAccounts_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == useRewardAccounts_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(useRewardAccounts_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction useRewardAccounts_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction useRewardAccounts_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { useRewardAccounts_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { useRewardAccounts_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction useRewardAccounts_slicedToArray(r, e) { return useRewardAccounts_arrayWithHoles(r) || useRewardAccounts_iterableToArrayLimit(r, e) || useRewardAccounts_unsupportedIterableToArray(r, e) || useRewardAccounts_nonIterableRest(); }\nfunction useRewardAccounts_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction useRewardAccounts_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return useRewardAccounts_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? useRewardAccounts_arrayLikeToArray(r, a) : void 0; } }\nfunction useRewardAccounts_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction useRewardAccounts_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction useRewardAccounts_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\nfunction useRewardAccounts() {\n  var _useState = (0,react.useState)([]),\n    _useState2 = useRewardAccounts_slicedToArray(_useState, 2),\n    rewardAccounts = _useState2[0],\n    setRewardAccounts = _useState2[1];\n  var _useWallet = useWallet(),\n    defaultWallet = _useWallet.defaultWallet,\n    getWalletApi = _useWallet.getWalletApi,\n    connectedWallets = _useWallet.connectedWallets;\n  (0,react.useEffect)(function () {\n    var fetchRewardAccounts = /*#__PURE__*/function () {\n      var _ref = useRewardAccounts_asyncToGenerator(/*#__PURE__*/useRewardAccounts_regeneratorRuntime().mark(function _callee() {\n        var api, rewardAddresses;\n        return useRewardAccounts_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!(!connectedWallets.length || !defaultWallet)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt("return");\n            case 3:\n              api = getWalletApi(defaultWallet);\n              if (api) {\n                _context.next = 6;\n                break;\n              }\n              throw new Error("Wallet API not found");\n            case 6:\n              _context.next = 8;\n              return api.getRewardAddresses();\n            case 8:\n              rewardAddresses = _context.sent;\n              setRewardAccounts(rewardAddresses);\n              _context.next = 15;\n              break;\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context["catch"](0);\n              console.error("Error fetching reward accounts:", _context.t0);\n            case 15:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 12]]);\n      }));\n      return function fetchRewardAccounts() {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    if (connectedWallets.length > 0) fetchRewardAccounts();\n  }, [defaultWallet, connectedWallets, getWalletApi]);\n  return rewardAccounts;\n}\n;// ./src/components/uploads/useUploads.ts\nfunction useUploads_typeof(o) { "@babel/helpers - typeof"; return useUploads_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, useUploads_typeof(o); }\nfunction useUploads_ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction useUploads_objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? useUploads_ownKeys(Object(t), !0).forEach(function (r) { useUploads_defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : useUploads_ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction useUploads_defineProperty(e, r, t) { return (r = useUploads_toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction useUploads_toPropertyKey(t) { var i = useUploads_toPrimitive(t, "string"); return "symbol" == useUploads_typeof(i) ? i : i + ""; }\nfunction useUploads_toPrimitive(t, r) { if ("object" != useUploads_typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != useUploads_typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction useUploads_toConsumableArray(r) { return useUploads_arrayWithoutHoles(r) || useUploads_iterableToArray(r) || useUploads_unsupportedIterableToArray(r) || useUploads_nonIterableSpread(); }\nfunction useUploads_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction useUploads_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction useUploads_arrayWithoutHoles(r) { if (Array.isArray(r)) return useUploads_arrayLikeToArray(r); }\nfunction useUploads_regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ useUploads_regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == useUploads_typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a \'" + n + "\' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(useUploads_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }\nfunction useUploads_asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction useUploads_asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { useUploads_asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { useUploads_asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }\nfunction useUploads_slicedToArray(r, e) { return useUploads_arrayWithHoles(r) || useUploads_iterableToArrayLimit(r, e) || useUploads_unsupportedIterableToArray(r, e) || useUploads_nonIterableRest(); }\nfunction useUploads_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction useUploads_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return useUploads_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? useUploads_arrayLikeToArray(r, a) : void 0; } }\nfunction useUploads_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction useUploads_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction useUploads_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\nfunction useUploads(_ref) {\n  var _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? 9 : _ref$limit,\n    rewardAccounts = _ref.rewardAccounts;\n  var _useState = (0,react.useState)([]),\n    _useState2 = useUploads_slicedToArray(_useState, 2),\n    allUploads = _useState2[0],\n    setAllUploads = _useState2[1];\n  var _useState3 = (0,react.useState)([]),\n    _useState4 = useUploads_slicedToArray(_useState3, 2),\n    filteredUploads = _useState4[0],\n    setFilteredUploads = _useState4[1];\n  var _useState5 = (0,react.useState)([]),\n    _useState6 = useUploads_slicedToArray(_useState5, 2),\n    displayedUploads = _useState6[0],\n    setDisplayedUploads = _useState6[1];\n  var _useState7 = (0,react.useState)(true),\n    _useState8 = useUploads_slicedToArray(_useState7, 2),\n    loading = _useState8[0],\n    setLoading = _useState8[1];\n  var _useState9 = (0,react.useState)(null),\n    _useState10 = useUploads_slicedToArray(_useState9, 2),\n    error = _useState10[0],\n    setError = _useState10[1];\n  var _useState11 = (0,react.useState)({}),\n    _useState12 = useUploads_slicedToArray(_useState11, 2),\n    pagesData = _useState12[0],\n    setPagesData = _useState12[1];\n  var _useState13 = (0,react.useState)({}),\n    _useState14 = useUploads_slicedToArray(_useState13, 2),\n    lastObjectUlids = _useState14[0],\n    setLastObjectUlids = _useState14[1];\n  var _useState15 = (0,react.useState)(1),\n    _useState16 = useUploads_slicedToArray(_useState15, 2),\n    currentPage = _useState16[0],\n    setCurrentPage = _useState16[1];\n  var _useState17 = (0,react.useState)(false),\n    _useState18 = useUploads_slicedToArray(_useState17, 2),\n    hasMorePages = _useState18[0],\n    setHasMorePages = _useState18[1];\n  (0,react.useEffect)(function () {\n    var fetchInitialUploads = /*#__PURE__*/function () {\n      var _ref2 = useUploads_asyncToGenerator(/*#__PURE__*/useUploads_regeneratorRuntime().mark(function _callee() {\n        var body, response, data, formattedUploads, lastUlid;\n        return useUploads_regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              if (!(rewardAccounts.length === 0)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt("return");\n            case 3:\n              setLoading(true);\n              setError(null);\n              body = {\n                limit: limit,\n                rewardAccounts: rewardAccounts\n              };\n              _context.next = 8;\n              return fetch(buildApiUrl("/account-uploads"), {\n                method: "POST",\n                headers: {\n                  "Content-Type": "application/json",\n                  "x-api-key": API_KEY\n                },\n                body: JSON.stringify(body)\n              });\n            case 8:\n              response = _context.sent;\n              if (response.ok) {\n                _context.next = 11;\n                break;\n              }\n              throw new Error("API error: ".concat(response.status));\n            case 11:\n              _context.next = 13;\n              return response.json();\n            case 13:\n              data = _context.sent;\n              formattedUploads = data.objects;\n              setAllUploads(formattedUploads);\n              setFilteredUploads(formattedUploads);\n              setDisplayedUploads(formattedUploads);\n              setPagesData({\n                1: formattedUploads\n              });\n              lastUlid = data.mLastObjectUlid;\n              setLastObjectUlids({\n                1: lastUlid\n              });\n              setHasMorePages(lastUlid !== null);\n              setCurrentPage(1);\n              _context.next = 29;\n              break;\n            case 25:\n              _context.prev = 25;\n              _context.t0 = _context["catch"](0);\n              setError(_context.t0 instanceof Error ? _context.t0.message : "An unknown error occurred");\n              console.error("Error fetching initial uploads:", _context.t0);\n            case 29:\n              _context.prev = 29;\n              setLoading(false);\n              return _context.finish(29);\n            case 32:\n            case "end":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 25, 29, 32]]);\n      }));\n      return function fetchInitialUploads() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    fetchInitialUploads();\n  }, [rewardAccounts, limit]);\n  var fetchNextPage = (0,react.useCallback)(/*#__PURE__*/function () {\n    var _ref3 = useUploads_asyncToGenerator(/*#__PURE__*/useUploads_regeneratorRuntime().mark(function _callee2(pageNumber) {\n      var lastUlid, body, response, data, formattedUploads, newLastUlid;\n      return useUploads_regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!pagesData[pageNumber]) {\n              _context2.next = 4;\n              break;\n            }\n            setDisplayedUploads(pagesData[pageNumber]);\n            setCurrentPage(pageNumber);\n            return _context2.abrupt("return");\n          case 4:\n            lastUlid = lastObjectUlids[pageNumber - 1];\n            if (lastUlid) {\n              _context2.next = 7;\n              break;\n            }\n            return _context2.abrupt("return");\n          case 7:\n            _context2.prev = 7;\n            setLoading(true);\n            body = {\n              lastObjectUlid: lastUlid,\n              limit: limit,\n              rewardAccounts: rewardAccounts\n            };\n            _context2.next = 12;\n            return fetch(buildApiUrl("/account-uploads"), {\n              method: "POST",\n              headers: {\n                "Content-Type": "application/json",\n                "x-api-key": API_KEY\n              },\n              body: JSON.stringify(body)\n            });\n          case 12:\n            response = _context2.sent;\n            if (response.ok) {\n              _context2.next = 15;\n              break;\n            }\n            throw new Error("API error: ".concat(response.status));\n          case 15:\n            _context2.next = 17;\n            return response.json();\n          case 17:\n            data = _context2.sent;\n            formattedUploads = data.objects;\n            setAllUploads(function (prev) {\n              return [].concat(useUploads_toConsumableArray(prev), useUploads_toConsumableArray(formattedUploads));\n            });\n            setPagesData(function (prev) {\n              return useUploads_objectSpread(useUploads_objectSpread({}, prev), {}, useUploads_defineProperty({}, pageNumber, formattedUploads));\n            });\n            newLastUlid = data.mLastObjectUlid;\n            setLastObjectUlids(function (prev) {\n              return useUploads_objectSpread(useUploads_objectSpread({}, prev), {}, useUploads_defineProperty({}, pageNumber, newLastUlid));\n            });\n            setHasMorePages(newLastUlid !== null);\n            setDisplayedUploads(formattedUploads);\n            setCurrentPage(pageNumber);\n            _context2.next = 32;\n            break;\n          case 28:\n            _context2.prev = 28;\n            _context2.t0 = _context2["catch"](7);\n            setError(_context2.t0 instanceof Error ? _context2.t0.message : "An unknown error occurred");\n            console.error("Error fetching page ".concat(pageNumber, ":"), _context2.t0);\n          case 32:\n            _context2.prev = 32;\n            setLoading(false);\n            return _context2.finish(32);\n          case 35:\n          case "end":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[7, 28, 32, 35]]);\n    }));\n    return function (_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }(), [pagesData, lastObjectUlids, limit, rewardAccounts]);\n  return {\n    allUploads: allUploads,\n    filteredUploads: filteredUploads,\n    displayedUploads: displayedUploads,\n    setFilteredUploads: setFilteredUploads,\n    setDisplayedUploads: setDisplayedUploads,\n    loading: loading,\n    error: error,\n    pagesData: pagesData,\n    lastObjectUlids: lastObjectUlids,\n    currentPage: currentPage,\n    setCurrentPage: setCurrentPage,\n    hasMorePages: hasMorePages,\n    setAllUploads: setAllUploads,\n    setPagesData: setPagesData,\n    setLastObjectUlids: setLastObjectUlids,\n    setHasMorePages: setHasMorePages,\n    fetchNextPage: fetchNextPage\n  };\n}\n;// ./src/components/uploads/UploadCard.tsx\n\n\nvar getImageSrc = function getImageSrc(upload) {\n  if (upload.thumbnailUrl) return upload.thumbnailUrl;\n  if (upload.objectData && upload.objectType && upload.objectType.startsWith("image/")) {\n    return "data:".concat(upload.objectType, ";base64,").concat(upload.objectData);\n  }\n  return undefined;\n};\nvar formatDate = function formatDate(dateString) {\n  if (!dateString) return "Uncompleted";\n  var date = new Date(dateString);\n  if (isNaN(date.getTime())) return "Uncompleted";\n  return date.toLocaleDateString();\n};\nvar UploadCard = function UploadCard(_ref) {\n  var upload = _ref.upload,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "bg-card-gradient rounded-lg p-4 flex flex-col h-full border border-border-light transition-all duration-200 hover:transform hover:-translate-y-1.5 hover:shadow-lg"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-xs text-text-muted mb-1.5"\n  }, formatDate(upload.indexingTxSubmittedAt || "")), /*#__PURE__*/react.createElement("div", {\n    className: "text-lg font-bold mb-2.5"\n  }, upload.name), /*#__PURE__*/react.createElement("p", {\n    className: "text-sm text-text-secondary mb-4 flex-grow overflow-hidden text-ellipsis line-clamp-3"\n  }, upload.description), /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-[150px] bg-primary-800 rounded-md flex items-center justify-center mb-4 overflow-hidden"\n  }, upload.objectType === "text/plain" && upload.objectData ? /*#__PURE__*/react.createElement("pre", {\n    className: "whitespace-pre-wrap break-all bg-[#f6f6f6] p-3 rounded-md max-h-[300px] overflow-auto w-full h-full"\n  }, atob(upload.objectData)) : upload.fileType && upload.fileType.toLowerCase().includes("pdf") && upload.objectData ? /*#__PURE__*/react.createElement("iframe", {\n    src: "data:application/pdf;base64,".concat(upload.objectData),\n    title: upload.name,\n    className: "w-full h-full object-cover"\n  }) : getImageSrc(upload) ? /*#__PURE__*/react.createElement("img", {\n    src: getImageSrc(upload),\n    alt: upload.name,\n    className: "w-full h-full object-cover"\n  }) : /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-full flex items-center justify-center bg-primary-800"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-3xl text-text-muted"\n  }, "\\uD83D\\uDDBC\\uFE0F"))), upload.fileType && upload.fileType.toLowerCase().includes("text") && /*#__PURE__*/react.createElement("button", {\n    className: "bg-transparent border border-border-light text-text-primary py-2 px-3 rounded-md cursor-pointer transition-colors duration-200 hover:bg-border-light/50 text-sm",\n    onClick: function onClick() {\n      return onCopyText(upload.description || "");\n    }\n  }, "Copy text"), upload.indexingTxId && /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: upload.indexingTxId\n  }), upload.shardTxIds && upload.shardTxIds.length > 0 && upload.shardTxIds.map(function (txId, index) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      txId: txId,\n      key: index\n    });\n  }));\n};\n/* harmony default export */ const uploads_UploadCard = (UploadCard);\n;// ./src/components/uploads/UploadsGrid.tsx\n\n\nvar UploadsGrid = function UploadsGrid(_ref) {\n  var uploads = _ref.uploads,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "grid grid-cols-3 gap-5 mb-8 md:grid-cols-2 sm:grid-cols-1"\n  }, uploads.map(function (upload) {\n    return /*#__PURE__*/react.createElement(uploads_UploadCard, {\n      key: upload.id,\n      upload: upload,\n      onCopyText: onCopyText\n    });\n  }));\n};\n/* harmony default export */ const uploads_UploadsGrid = (UploadsGrid);\n;// ./src/components/uploads/UploadListItem.tsx\n\n\nvar UploadListItem_getImageSrc = function getImageSrc(upload) {\n  if (upload.thumbnailUrl) return upload.thumbnailUrl;\n  if (upload.objectData && upload.objectType && upload.objectType.startsWith("image/")) {\n    return "data:".concat(upload.objectType, ";base64,").concat(upload.objectData);\n  }\n  return undefined;\n};\nvar UploadListItem_formatDate = function formatDate(dateString) {\n  if (!dateString) return "Uncompleted";\n  var date = new Date(dateString);\n  if (isNaN(date.getTime())) return "Uncompleted";\n  return date.toLocaleDateString();\n};\nvar UploadListItem = function UploadListItem(_ref) {\n  var upload = _ref.upload,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "bg-list-gradient rounded-lg p-4 grid grid-cols-[1fr_2fr_100px] gap-4 border border-border-light transition-all duration-200 hover:transform hover:-translate-y-0.5 hover:shadow-lg items-center md:grid-cols-1 md:grid-rows-[auto_auto_auto]"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-1.5"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "text-xs text-text-muted"\n  }, UploadListItem_formatDate(upload.indexingTxSubmittedAt || "")), /*#__PURE__*/react.createElement("div", {\n    className: "text-lg font-bold"\n  }, upload.name)), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-2.5"\n  }, /*#__PURE__*/react.createElement("p", {\n    className: "text-sm text-text-secondary overflow-hidden text-ellipsis line-clamp-2"\n  }, upload.description), upload.fileType && upload.fileType.toLowerCase().includes("text") && /*#__PURE__*/react.createElement("button", {\n    className: "bg-transparent border border-border-light text-text-primary py-2 px-3 rounded-md cursor-pointer transition-colors duration-200 hover:bg-border-light/50 text-sm",\n    onClick: function onClick() {\n      return onCopyText(upload.description || "");\n    }\n  }, "Copy text")), /*#__PURE__*/react.createElement("div", {\n    className: "w-[100px] h-[100px] bg-primary-800 rounded-md flex items-center justify-center overflow-hidden md:w-full md:h-[150px] md:order-first"\n  }, upload.objectType === "text/plain" && upload.objectData ? /*#__PURE__*/react.createElement("pre", {\n    className: "whitespace-pre-wrap break-all bg-[#f6f6f6] p-3 rounded-md max-h-[300px] overflow-auto w-full h-full"\n  }, atob(upload.objectData)) : upload.fileType && upload.fileType.toLowerCase().includes("pdf") && upload.objectData ? /*#__PURE__*/react.createElement("iframe", {\n    src: "data:application/pdf;base64,".concat(upload.objectData),\n    title: upload.name,\n    className: "w-full h-full object-cover"\n  }) : UploadListItem_getImageSrc(upload) ? /*#__PURE__*/react.createElement("img", {\n    src: UploadListItem_getImageSrc(upload),\n    alt: upload.name,\n    className: "w-full h-full object-cover"\n  }) : /*#__PURE__*/react.createElement("div", {\n    className: "w-full h-full flex items-center justify-center bg-[#1a1a2a]"\n  }, /*#__PURE__*/react.createElement("span", {\n    className: "text-3xl text-gray-500"\n  }, "\\uD83D\\uDDBC\\uFE0F")), upload.indexingTxId && /*#__PURE__*/react.createElement(ExplorerLink, {\n    txId: upload.indexingTxId\n  }), upload.shardTxIds && upload.shardTxIds.length > 0 && upload.shardTxIds.map(function (txId, idx) {\n    return /*#__PURE__*/react.createElement(ExplorerLink, {\n      txId: txId,\n      key: idx\n    });\n  })));\n};\n/* harmony default export */ const uploads_UploadListItem = (UploadListItem);\n;// ./src/components/uploads/UploadsList.tsx\n\n\nvar UploadsList = function UploadsList(_ref) {\n  var uploads = _ref.uploads,\n    onCopyText = _ref.onCopyText;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 mb-8"\n  }, uploads.map(function (upload, idx) {\n    return /*#__PURE__*/react.createElement(uploads_UploadListItem, {\n      key: upload.id || idx,\n      upload: upload,\n      onCopyText: onCopyText\n    });\n  }));\n};\n/* harmony default export */ const uploads_UploadsList = (UploadsList);\n;// ./src/components/uploads/UploadsFilters.tsx\n\nvar UploadsFilters = function UploadsFilters(_ref) {\n  var dateFilter = _ref.dateFilter,\n    setDateFilter = _ref.setDateFilter,\n    typeFilter = _ref.typeFilter,\n    setTypeFilter = _ref.setTypeFilter,\n    searchQuery = _ref.searchQuery,\n    setSearchQuery = _ref.setSearchQuery,\n    onSearch = _ref.onSearch,\n    dateFilterOptions = _ref.dateFilterOptions,\n    typeFilterOptions = _ref.typeFilterOptions,\n    viewMode = _ref.viewMode,\n    setViewMode = _ref.setViewMode;\n  return /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-4 w-full max-w-[800px]"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "w-full mb-2.5"\n  }, /*#__PURE__*/react.createElement("form", {\n    onSubmit: onSearch,\n    className: "flex w-full"\n  }, /*#__PURE__*/react.createElement("input", {\n    type: "text",\n    placeholder: "Search",\n    value: searchQuery,\n    onChange: function onChange(e) {\n      return setSearchQuery(e.target.value);\n    },\n    className: "flex-grow py-2.5 px-4 rounded-l-md bg-primary-800 text-text-primary border border-border border-r-0"\n  }), /*#__PURE__*/react.createElement("button", {\n    type: "submit",\n    className: "py-2.5 px-4 rounded-r-md bg-primary-700 text-text-primary border border-border cursor-pointer transition-colors duration-200 hover:bg-primary-600"\n  }, /*#__PURE__*/react.createElement("span", {\n    role: "img",\n    "aria-label": "search"\n  }, "\\uD83D\\uDD0D")))), /*#__PURE__*/react.createElement("div", {\n    className: "flex gap-4 items-center flex-wrap justify-between"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-1.5"\n  }, /*#__PURE__*/react.createElement("label", {\n    className: "text-sm text-text-muted"\n  }, "Filter by Date"), /*#__PURE__*/react.createElement("select", {\n    value: dateFilter,\n    onChange: function onChange(e) {\n      return setDateFilter(e.target.value);\n    },\n    className: "py-2 px-3 rounded-md bg-primary-800 text-text-primary border border-border min-w-[120px]"\n  }, dateFilterOptions.map(function (option) {\n    return /*#__PURE__*/react.createElement("option", {\n      key: option.id,\n      value: option.id\n    }, option.label);\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "flex flex-col gap-1.5"\n  }, /*#__PURE__*/react.createElement("label", {\n    className: "text-sm text-text-muted"\n  }, "Filter by Type"), /*#__PURE__*/react.createElement("select", {\n    value: typeFilter,\n    onChange: function onChange(e) {\n      return setTypeFilter(e.target.value);\n    },\n    className: "py-2 px-3 rounded-md bg-primary-800 text-text-primary border border-border min-w-[120px]"\n  }, typeFilterOptions.map(function (option) {\n    return /*#__PURE__*/react.createElement("option", {\n      key: option.id,\n      value: option.id\n    }, option.label);\n  }))), /*#__PURE__*/react.createElement("div", {\n    className: "flex gap-1.5"\n  }, /*#__PURE__*/react.createElement("button", {\n    className: "w-10 h-10 flex items-center justify-center bg-primary-800 border border-border text-text-primary rounded-md cursor-pointer transition-colors duration-200 hover:bg-primary-700 ".concat(viewMode === "grid" ? "bg-primary-600 border-border-active" : ""),\n    onClick: function onClick() {\n      return setViewMode("grid");\n    },\n    "aria-label": "Grid view"\n  }, /*#__PURE__*/react.createElement("span", {\n    role: "img",\n    "aria-hidden": "true"\n  }, "\\u229E")), /*#__PURE__*/react.createElement("button", {\n    className: "w-10 h-10 flex items-center justify-center bg-primary-800 border border-border text-text-primary rounded-md cursor-pointer transition-colors duration-200 hover:bg-primary-700 ".concat(viewMode === "list" ? "bg-primary-600 border-border-active" : ""),\n    onClick: function onClick() {\n      return setViewMode("list");\n    },\n    "aria-label": "List view"\n  }, /*#__PURE__*/react.createElement("span", {\n    role: "img",\n    "aria-hidden": "true"\n  }, "\\u2630")))));\n};\n/* harmony default export */ const uploads_UploadsFilters = (UploadsFilters);\n;// ./src/components/uploads/mockData.ts\nvar mockUploads = [{\n  id: "1",\n  name: "Chart Image",\n  dateUploaded: "2025-03-15T10:30:00Z",\n  description: "A chart showing data visualization",\n  fileType: "png",\n  indexingTxId: undefined,\n  indexingTxSubmittedAt: undefined,\n  objectData: "iVBORw0KGgoAAAANSUhEUgAAA+kAAAIjCAYAAAB/OVoZAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjEsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvc2/+5QAAAAlwSFlzAAAPYQAAD2EBqD+naQAAWmlJREFUeJzt3Qmc3PP9P/BP7kMSEYmECCHu+yaoow1RSumFHkJbWkW1jpK2RLRFVdFD0QO9Hb+i/5aqiJu4qauoM64cjojItcnO//H+rlmzm83KsbvznZnn8/GY7M53vjvzmfl+ZjKv7+fqVCgUCgkAAAAou87lLgAAAADQQEgHAACAnBDSAQAAICeEdAAAAMgJIR0AAAByQkgHAACAnBDSAQAAICeEdAAAAMgJIR0AAAByQkgHaGOdOnVKp512Wpve52WXXZbd74svvpjy7Cc/+Ulae+21U5cuXdIWW2xR7uJAE/H+ifdRvJ+qxa233po9p/i5pPv+3//9XyqHSvkc6+jPd4DmhHSgKhW/DC7ucs8996Q8OuOMM9K1116bKtGNN96YvvOd76SddtopXXrppdlzWZxDDz10scfmhhtuSLXk9ddfTyeffHLafffdU9++fT80cN19991p5513Tr17905DhgxJ3/zmN9OsWbM6tMx595e//CWdf/75qVbV8vN/7bXXshD9yCOPLPN9XH/99YI4UFZdy/vwAO3r9NNPT2uttdYi29dZZ52URxFsP/OZz6T999+/yfYvfelL6aCDDko9evRIeXXzzTenzp07p9/97nepe/fuH7p/PJff/va3i2zffPPNUy15+umn049//OO07rrrpk033TRNmjRpsftG8PjYxz6WNtxww3TuueemV155JZ1zzjnpf//7X/rXv/7VoeXOe0h9/PHH07e+9a0m29dcc800Z86c1K1bt1Qtdtlll+w5lb7nFvf8ayWkjx8/Pg0fPnyZe/NESL/gggtaDOrxWnft6usz0L58ygBV7eMf/3jaZpttUqWL7uNxybNp06alXr16LVFAD/FF94tf/GKqZO+9915aYYUVlus+tt566/Tmm2+mAQMGZN2QP/vZzy523+9+97tppZVWylra+/Xrl22LMHL44YdnPRn23HPPVI1mz56d9RxYXtFLoWfPnqmaxImxantOeea1BjqC7u5Azaqrq8uC0WGHHbbIbTNnzsy+jJ1wwglNQuhXvvKVNHjw4Oy2aPH9/e9//6GPE127I0g1F600ERqK4vcIfXGfxa7f8betjeX81a9+lTbeeOOsVXq11VZLRx11VJoxY0aTfXbbbbe0ySabpCeffDLrUh1hZ+jQoenss89eotdpwYIF6Qc/+EEaMWJE9jjxXCIszps3r0nZo4t7lL9Y9vYc9/unP/0pC7dxUiCOYfQyePnllxtvP/roo1OfPn2ycNfcwQcfnHUTX7hwYeO2aIX+yEc+kgXu6HK+zz77pCeeeKLJ38WxiPt87rnn0t57753t94UvfCGNGzcua5mdPn36Io91xBFHpP79+6e5c+cu9rnE/cRz+DBRJydMmJCd2CgG9HDIIYdk5bryyis/9D5eeumltN9++2XPc5VVVknf/va307///e8Wu9jfe++9aa+99korrrhiVmd23XXXdNddd7VYh5999tns9YnnGvvHe6ql1/7DjltpfX3wwQezVuJ47Khv4e9//3t2bKKuR12MOhl1s/RYxt9fd9112XMt1sXi+29xY9KjF0jx+Mdz+OQnP5n++9//LvNzjeMUQxJinzg266+/fuNzWJxPfepTaauttmqybd99980e8//9v//X5LjEtmLPieZj0lt7/kX19fXpRz/6UVp99dWzz7LonRHP68PEfX7jG9/Ink8cw5VXXjk7qdTSGPN4/3z0ox/N9ovH+eEPf5g9bnNLckyb14sdd9wxu9/oJXXRRRc17hOvwbbbbpv9Hsel+WfRHXfckZV3jTXWyB5r2LBh2XsgWseL4thGK3ooHYbT2pj0hx9+ODshHO/LON7xejYfUlX8DI/30HHHHZcGDRqU1bcDDjigxc8OoLZpSQeq2jvvvJPeeOONJtvii1J8uYxgFV+Qrr766nTxxRc3aQGOceERQiNEhPgSF18S44tsBMD4cnjVVVdlX+giFB977LHLXdY//vGP6atf/WrabrvtsnAX4gvr4sQXxejWOWrUqHTkkUdm3aYvvPDCdP/992dfBEu79L799ttZ4Iog8LnPfS5rsT3ppJOy7tXx5bI1UaY4cRDd8I8//vgsJJx55plZiLnmmmsay/7rX/863XfffY1d2OOL9IdpfmyizBF8WhPh4pRTTsmeR5QtvuD+4he/yAJdfFmOYHTggQdmX7QjrJS2TEeY+sc//pEdt2LPhCj7mDFj0ujRo7Nu57FPvI4RsuL+SgNOnLCI/eK26GYeAXLkyJHZsIorrrgiqxtF8+fPz17nT3/6023S+vbYY49lj9+8Z0jU2+jWG2VtTZxAidAUY+CjvsaJiugWfcsttyyyb4TWqBcRqOMkRLTWxkmY+PsIOlFHS8WxiPdE1IuHHnooqwNxEiBez6U5bkXRsyAeP95/cVIiTowVg06EoAg58TPKeeqpp2YnMGLSwvC9730ve9/HUIDzzjsv2xb7Ls5NN92UPVZMeBjvqXivR7liboV4Ls0D7oc91winn/jEJ9Jmm22W1YsIg/G50fwER3NxkiACazyXCHuFQiH7m3jt4zWPkyshfo9tUb6WLMnzP+uss7L7iJOQsW+csIsTTvHebk18tsScCHFcInhHOI/3Snw2xknAYm+HKVOmZCcEo77GfAsRRuPzIYJ1c0tyTEs/x+IEWRyDONkWJ6bisy/eA1/+8pezYSDxmsffx2dovKaln0XxmR3v7/ib+D8gPq/iWMdrFbeFr33ta1mX+TjREp8NHyaOdzxOHLOYkyM+w+L/k3hNbrvttrT99ts32f+YY47JesPE+ypev5g7ID434vMDoFEBoApdeumlhfiIa+nSo0ePxv3+/e9/Z9v+8Y9/NPn7vffeu7D22ms3Xj///POz/f70pz81bps/f35h5MiRhT59+hRmzpzZuD32GzduXOP1MWPGFNZcc81Fyhj7NP8YXmGFFbL9F/d8Xnjhhez6tGnTCt27dy/sueeehYULFzbu98tf/jLb75JLLmnctuuuu2bb/vCHPzRumzdvXmHIkCGFT3/6062+jo888kj2t1/96lebbD/hhBOy7TfffHOT5xnlXxKxb0vHJsramhdffLHQpUuXwo9+9KMm2x977LFC165dG7fX19cXhg4dusjzu/LKK7PHuf3227Pr7777bqF///6Fww8/vMl+U6ZMKay44opNthfLfPLJJy9SrqgH22+/fZNtV199dbb/LbfcUlhSV1111WL/pnhbseylPvvZz2bHszU//elPs7+/9tprG7fNmTOnsMEGGzR5zHjt1l133cLo0aOz34tmz55dWGuttQp77LHHInX4y1/+cpPHOuCAAworr7zyUh+30vp60UUXLfIcogzNfe1rXyv07t27MHfu3MZt++yzT4vvuXj/xH3H+6loiy22KKyyyiqFN998s3Hbf/7z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1zR37tzstSinGBPfpUuX5b4fIR0AAKACzZo1K73yyivZGty1qlAopCFDhmSrdy3JpGztKR4/llfr06fPct2PkA4AAFBhotU4AnrMbD5o0KCyB9Ryqa+vz05WRDDu3LlzWU8WTJ8+PTsm66677nK1qAvpAAAAFdjNO4JhBPRevXqlWlVfX5/mz5+fevbsWdaQHuJYvPjii9mxWZ6QbuI4AACAClWrLejVfCyEdAAAAMgJIR0AAAByQkgHAACAnBDSAQAA6BCHHnpoNna7+eXZZ58td9Fyw+zuAAAAdJi99torXXrppYvMjE4DLekAAAB0mB49eqQhQ4Y0uSxuybLLLrss9e/fP/3zn/9M66+/frYu/Gc+85k0e/bs9Pvf/z6tvfbaafjw4enYY4/N1o4vmjdvXjrhhBPS0KFD0worrJC23377dOuttzbe/uabb6aDDz44uz3uc9NNN01//etfmzz2brvtlr75zW+m73znO2nAgAFZOU877bRUEy3pF1xwQfrJT36SpkyZkjbffPP0i1/8Im233XaLPUiHHXbYIgd57ty5HVRaAACA/Nlmm22yTNXRIrw+8MAD7Xb/s2fPTj//+c/T5Zdfnt599930qU99Kh1wwAGN4f3xxx9PY8aMSTvvvHM68MADs785+uij05NPPpn9zWqrrZauueaarAX/scceS+uuu26WH7feeut00kknpX79+qXrrrsufelLX0ojRoxokkXjRMBxxx2X7r333jRp0qSsu/5OO+2U9thjj+oN6VdccUX2pC+66KLs7Mb555+fRo8enZ5++um0yiqrtPg38SLG7UXWBgQAAGpdBPRXX3015V0E6z59+jRe//jHP56uuuqqxe5fV1eXLrzwwixAh2hJ/+Mf/5imTp2atYKvvvrqWav3LbfckoX0yZMnZ93p42cE9BCt6jfccEO2/Ywzzsha0GNb0THHHJP+/e9/pyuvvLJJSN9ss83SuHHjst8j3P/yl79MEydOrO6Qfu6556bDDz+8sXU8wnqcxbjkkkvSySef3OLfRCiPszVVbdas1OOtt1J6/fWUunVLKbp/DByYUmcjFAAAgEWVKyMt7ePuvvvuWeguiu7orendu3djQA+DBw/OurhH0K+vr2/cNm3atOz3aC2Pru/rrbdek/uJLvArr7xy9nvcHmE9Qnmc2Jg/f352ezxWqQjppVZd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vjBw4MDC2LFjG/d5/vnnC7179y4cd9xxhSeffLLwi1/8otClS5fCDTfc0OHPl/yLOvS9732vcPXVV8fKI4Vrrrmmye1nnXVWYcUVVyxce+21hf/85z+F/fbbr7DWWmsV5syZ07jPXnvtVdh8880L99xzT+GOO+4orLPOOoWDDz648fZ33nmnMHjw4MIXvvCFwuOPP17461//WujVq1fh4osvbtznrrvuyurp2WefndXb73//+4Vu3boVHnvssQ56JajkejpmzJisHpZ+tr711ltN9lFPaS+jR48uXHrppVm9eeSRRwp77713YY011ijMmjWrw/9/952WZa2ju+66a1ZfSj9H43OxVuqokJ5D2223XeGoo45qvL5w4cLCaqutVjjzzDPLWi6qT4T0+JLYkhkzZmRf9q666qrGbf/973+zL6STJk3KrscHYufOnQtTpkxp3OfCCy8s9OvXrzBv3rzs+ne+853sRECpAw88MPuAhtY0Dz/19fWFIUOGFH7yk580qac9evTIAkyI/4Tj7+6///7Gff71r38VOnXqVHj11Vez67/61a8KK620UmMdDSeddFJh/fXXb7z+uc99rrDPPvs0Kc/2229f+NrXvtZOz5ZKtbiQ/slPfnKxf6Oe0pGmTZuW1bfbbrutw/9/952WZamjxZB+7LHHFhan2uuo7u45M3/+/PTggw9mXTiLOnfunF2fNGlSWctGdYquwtFlc+211866XkbXoRD1sK6urkldjC6Va6yxRmNdjJ/RvXLw4MGN+4wePTrNnDkzPfHEE437lN5HcR/1maX1wgsvpClTpjSpTyuuuGLWNa20TkbX4W222aZxn9g/Pkfvvffexn122WWX1L179yZ1Mrravf322437qLcsj+hiGd0v119//XTkkUemN998s/E29ZSO9M4772Q/BwwY0KH/v/tOy7LW0aI///nPaeDAgWmTTTZJY8eOTbNnz268rdrraNeyPjqLeOONN9LChQubVLgQ15966qmylYvqFOEmxubEl8jXX389jR8/Phv/+Pjjj2dhKL4cxhfJ5nUxbgvxs6W6WryttX3iQ3TOnDnZuGJYEsU61VJ9Kq1vEYxKde3aNfuPv3SftdZaa5H7KN620korLbbeFu8DWhPjzz/1qU9l9ey5555L3/3ud9PHP/7x7Etfly5d1FM6TH19ffrWt76VdtpppyzohI76/z1OJvlOy7LU0fD5z38+rbnmmllDUszPcdJJJ2UnKa+++uqaqKNCOtSw+NJYtNlmm2WhPT4Qr7zySuEZYBkddNBBjb9HS098vo4YMSJrXf/Yxz5W1rJRW2JyuDjxfuedd5a7KLBUdfSII45o8jkaE8bG52ec+IzP02qnu3vORJeOOMvefIbNuD5kyJCylYvaEGfV11tvvfTss89m9S26Ac2YMWOxdTF+tlRXi7e1tk/MaOxEAEujWKda+3yMn9OmTWtye8z0GjNpt0W99TnMsojhRPH/e3y2BvWUjnD00Uenf/7zn+mWW25Jq6++euP2jvr/3XdalrWOtiQakkLp52g111EhPWei+9HWW2+dJk6c2KQbSFwfOXJkWctG9Yvlf+IMZZytjHrYrVu3JnUxuhnFmPViXYyfjz32WJMvmxMmTMg+/DbaaKPGfUrvo7iP+szSiq6/8Z9maX2KLmsxhre0TsYXzxhjVnTzzTdnn6PF/+Bjn1hCK8ZkltbJGPYRXYiL+6i3tJVXXnklG5Men61BPaU9xXyGEX6uueaarF41HzbRUf+/+07LstbRljzyyCPZz9LP0aquo2Wdto4WxVIAMVvxZZddls0Ae8QRR2RLAZTOXght4fjjjy/ceuuthRdeeCFbyieWsYjlK2KWzeISLbEkxs0335wt0TJy5Mjs0nz5iz333DNbQiOWtBg0aFCLy1+ceOKJ2eyxF1xwgSXYWKx33303W0olLvFf1Lnnnpv9/tJLLzUuwRafh3//+98Ljz76aDaDdktLsG255ZaFe++9t3DnnXcW1l133SZLW8XMxrG01Ze+9KVs+Zf4zI062nxpq65duxbOOeecrN7GSgiWtmJJ6mncdsIJJ2SzZMdn60033VTYaqutsno4d+7cxvtQT2kvRx55ZLZUZfz/Xrp81ezZsxv36aj/332nZVnq6LPPPls4/fTTs7oZn6Pxf/7aa69d2GWXXWqmjgrpORXr+MWHZ6zbF0sDxDqq0NZiGYpVV101q2dDhw7NrscHY1EEn2984xvZMkDxIXfAAQdkH6KlXnzxxcLHP/7xbP3eCPgR/Ovq6prsc8sttxS22GKL7HHiQzbWxoSWRF2J0NP8EktaFZdhO+WUU7LwEv+pfuxjHys8/fTTTe7jzTffzMJOnz59sqVYDjvssCw4lYo11nfeeefsPqLuR/hv7sorryyst956Wb2NJVyuu+66dn72VEM9jS+Z8aUxvixGYF5zzTWzdXebf+FTT2kvLdXNuJT+39uR/7/7TsvS1tHJkydngXzAgAHZ598666yTBe3SddKrvY52in/K25YPAAAABGPSAQAAICeEdAAAAMgJIR0AAAByQkgHAACAnBDSAQAAICeEdAAAAMgJIR0AAAByQkgHAACAnBDSAYAOd9lll6X+/fuXuxgAkDtCOgDk2JQpU9Kxxx6b1llnndSzZ880ePDgtNNOO6ULL7wwzZ49O1WC4cOHp/PPP7/JtgMPPDA988wzZSsTAORV13IXAABo2fPPP58F8mhxPuOMM9Kmm26aevTokR577LH061//Og0dOjTtt99+ZSlboVBICxcuTF27LttXiV69emUXAKApLekAkFPf+MY3shD8wAMPpM997nNpww03TGuvvXb65Cc/ma677rq07777ZvvNmDEjffWrX02DBg1K/fr1Sx/96EfTf/7zn8b7Oe2009IWW2yR/vjHP2at2iuuuGI66KCD0rvvvtu4T319fTrzzDPTWmutlYXnzTffPP3f//1f4+233npr6tSpU/rXv/6Vtt566+xkwZ133pmee+65rDzRwt+nT5+07bbbpptuuqnx73bbbbf00ksvpW9/+9vZ38dlcd3do3fAiBEjUvfu3dP666+flbdU/O1vf/vbdMABB6TevXunddddN/2///f/2uGVB4DyEdIBIIfefPPNdOONN6ajjjoqrbDCCi3uUwy8n/3sZ9O0adOyAP3ggw+mrbbaKn3sYx9Lb731VuO+Eaavvfba9M9//jO73Hbbbemss85qvD0C+h/+8Id00UUXpSeeeCIL1V/84hez/UqdfPLJ2d/997//TZtttlmaNWtW2nvvvdPEiRPTww8/nPbaa6/s5MHkyZOz/a+++uq0+uqrp9NPPz29/vrr2aUl11xzTdat//jjj0+PP/54+trXvpYOO+ywdMsttzTZb/z48dkJi0cffTR73C984QtNnicAVLwCAJA799xzTyH+m7766qubbF955ZULK6ywQnb5zne+U7jjjjsK/fr1K8ydO7fJfiNGjChcfPHF2e/jxo0r9O7duzBz5szG20888cTC9ttvn/0efxu333333U3u4ytf+Urh4IMPzn6/5ZZbsvJce+21H1r2jTfeuPCLX/yi8fqaa65ZOO+885rsc+mllxZWXHHFxus77rhj4fDDD2+yz2c/+9nC3nvv3Xg9Hv/73/9+4/VZs2Zl2/71r399aJkAoFIYkw4AFeS+++7LuqZHC/K8efOybu3Rmr3yyis32W/OnDlZ63lRdHPv27dv4/VVV101a30Pzz77bDYJ3R577NHkPubPn5+23HLLJtu22WabJtfjsaM7fXS/j1byBQsWZI9dbElfUtEyf8QRRzTZFuPxf/aznzXZFq33RdHDILr3F58HAFQDIR0Acihmc4/u7E8//XST7TEmPRQnXYuQHIE7xow3Vzrmu1u3bk1ui/uOsF+8jxBBOyajKxVjz0s173p/wgknpAkTJqRzzjknK3OU6zOf+UwW8NtDa88DAKqBkA4AORQt49Gy/ctf/jIdc8wxix2XHuPPY5m2mGAuWsuXxUYbbZSF8Wj93nXXXZfqb++666506KGHZpO5FQP/iy++2GSfmAguZoJvTUyKF/c1ZsyYJvcdZQOAWiKkA0BO/epXv8q6fEcX8+hSHl29O3funO6///701FNPZbOsjxo1Ko0cOTLtv//+6eyzz07rrbdeeu2117JW8QjOzbuntyS6wUeLeEwWF63SO++8c3rnnXeykBzdyUuDc3Mxw3pMDheTxUWr9imnnLJIy3acPLj99tuzGeXjZMDAgQMXuZ8TTzwxmxAuutfHc/rHP/6R3W/pTPEAUAuEdADIqViOLGZMjzXSx44dm1555ZUs5EbrcoTqWKItgvH111+fvve972WzoU+fPj0NGTIk7bLLLtmyaEvqBz/4QbaEW8zyHuuzR1f5aKX/7ne/2+rfnXvuuenLX/5y2nHHHbPwfdJJJ6WZM2c22Sdmdo/Z2uP5xDj6hjngmoqTDDH+PLrNxyzvsRTcpZdemi3hBgC1pFPMHlfuQgAAAADWSQcAAIDcENIBAAAgJ4R0AAAAyAkhHQAAAHJCSAcAAICcENIBAAAgJ4R0AAAAyAkhHQAAAHJCSAcAAICcENIBAAAgJ4R0AAAASPnw/wGhg5nU9W+vawAAAABJRU5ErkJggg==",\n  objectType: "image/png",\n  objectUlid: "01JTHRT2RNYTQHNDNS0VPX442S",\n  shardTxIds: []\n}, {\n  id: "2",\n  name: "Graph Visualization",\n  dateUploaded: "2025-03-18T11:45:00Z",\n  description: "Complex graph data visualization",\n  fileType: "png",\n  indexingTxId: undefined,\n  indexingTxSubmittedAt: undefined,\n  objectData: "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lYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpMdHOQDTFxMY1BpAJoC2APlHNDBERERERkTYHgFMA9lRXVTqinJeouEGSpGjnIeKuBawvAZgQ7bwQERERERGZsBfArLoWwNa5wDUmNs4OYA+ARPFeh/Z3osPtt+PGGxN1v0dERERERBRp3333LY796184eeokfqi4ovxoYnVV5dooZSvi6lTgei1o3QvgRgDIGj8Jf/zT02hhax7djBEREREREfmx+Oln8dKKFbh48UvxVp0JXuta4OoAkPqT+AZ4a/Nm9O3fJ9pZIiIiIiIiMqzc9SV+2a0Hzp47Jd7qXBduG64zowrHxMZlAUgFgBefe55BKxERERER1TgtbM3x/oF38ZP4BuKtBVHMTsTUmcAVwCzA/Tzrw9OnRDsvREREREREAWlh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30hfYoR6nlgiqnnqUuB6gyRJ0b7oG3YxsXF9AOwGgOqqyuhmhoiioiCvCBMmTQBQ9/qBmNg4AO7nKznQC9VGbONEVFd16tQFxz77BAAWVldVLohydsKKz7gSERERERGRpTFwJaI6RcwTXJfUxW2muoVtnIio9uOtwkRERERERDUQbxUmIiIiIiIisggGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaUxcCUiIiIiIiJLY+BKRERERERElsbAlYiIiIiIiCyNgSsRERERERFZGgNXIiIiIiIisjQGrkRERERERGRpDFyJiIiIiIjI0hi4EhERERERkaXVlcD1lPjPhvUbo5gNIiIiIiKi0Dh56qT47zfRzEck1InAtbqq8hSA0wCwYePfopsZIiIiIiKiIG1YvxE/VFwRf+6JYlYiok4ErtdsBoAt27fiSMkn0c4LERERERFRwBYt/qP47+nqqkpHNPMSCXUpcH0JwHc/VFzBrzLvR7nry2jnh4iIiIiIyLR7B2Xg2GfyxbgFUcxKxNSZwPXa7cKPAsDZc6fwy249sHvXnqjmiYiIiIiIyKhy15e4d1AGdu0uFm/9vbqqcm0UsxQxN0iSFO08RFRMbNxLuBbAAkDa3fegxz33IC3t7ijmioiIiIiISNvxE5/jnX37sP//3lU+11oCoE91VWWtH5gJqIOBKwDExMZlAlgLIDHKWSEiIiIiIjJrYXVV5YJoZyKS6mTgCgAxsXGNAWRee/UBg1giIiIiIrKuvQAcAF669hhknVJnA1ciIiIiIiKqGerM4ExERERERERUMzFwJSIiIiIiIktj4EpERERERESWxsCViIiIiIiILI2BKxEREREREVkaA1ciIiIiIiKyNAauREREREREZGkMXImIiIiIiMjSGLgSERERERGRpTFwJSIiIiIiIkv7/23ZtH5VPDHFAAAAAElFTkSuQmCC",\n  objectType: "image/png",\n  objectUlid: "01JTKET54305R2GHEHECW33A0C",\n  shardTxIds: []\n}, {\n  id: "3",\n  name: "Company Logo",\n  dateUploaded: "2025-05-06T23:20:15Z",\n  description: "Official company logo in PNG format",\n  fileType: "png",\n  indexingTxId: "8dbc61bfd92f4832d7fac744b661ca45bab8e08726cae03be86658c6016bac1f",\n  indexingTxSubmittedAt: "2025-05-06T23:26:25Z",\n  objectData: "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",\n  objectType: "image/png",\n  objectUlid: "01JTKYKXJX5C0Z7J0QX9JVDB6Y",\n  shardTxIds: ["391ebd902eb2d952d42c7642273f08fb89ac7a789ddf3e7fe0d52779a6178835"]\n}, {\n  id: "4",\n  name: "Simple Text Note",\n  dateUploaded: "2025-05-07T10:30:00Z",\n  description: "A basic text note",\n  fileType: "text",\n  indexingTxId: "4c388550759784ef408cfc192453227f99d343bdbcd2f3c1f429cf815fd11125",\n  indexingTxSubmittedAt: undefined,\n  objectData: "SGVsbG8gdGhlcmU=",\n  objectType: "text/plain",\n  objectUlid: "01JTRF45NHFGMMDB0F0WHCMCR4",\n  shardTxIds: ["ac5db4d92ae51edd458008fae300570f102a6846f697fe181d96b62a19736b41"]\n}, {\n  id: "5",\n  name: "Greeting Note",\n  dateUploaded: "2025-05-07T14:22:00Z",\n  description: "A simple greeting message",\n  fileType: "text",\n  indexingTxId: undefined,\n  indexingTxSubmittedAt: undefined,\n  objectData: "SGVsbG8gdGhlcmUhISE=",\n  objectType: "text/plain",\n  objectUlid: "01JTRF9H4RQJ91HMSJ6E4TV2KQ",\n  shardTxIds: []\n}, {\n  id: "6",\n  name: "Important Note",\n  dateUploaded: "2025-05-08T17:40:00Z",\n  description: "An important text note with alphabet",\n  fileType: "text",\n  indexingTxId: "239a196d1b4dc1048c2ec022c71477b651ba3ab2eea5cf273f72304d257f0dbd",\n  indexingTxSubmittedAt: "2025-05-08T17:49:32Z",\n  objectData: "SGVsbG8gdGhlcmUhIEFCQ0RFRkdISUpLTE1OTw==",\n  objectType: "text/plain",\n  objectUlid: "01JTRFBTQZXXABTD6KBTVW75BJ",\n  shardTxIds: ["4491478fc8714213d3d8ecd3e6438f49c2a9cc5d5b5f8ae358834f43980f7127"]\n}];\n;// ./src/components/uploads/uploads.tsx\nfunction uploads_toConsumableArray(r) { return uploads_arrayWithoutHoles(r) || uploads_iterableToArray(r) || uploads_unsupportedIterableToArray(r) || uploads_nonIterableSpread(); }\nfunction uploads_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction uploads_iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction uploads_arrayWithoutHoles(r) { if (Array.isArray(r)) return uploads_arrayLikeToArray(r); }\nfunction uploads_slicedToArray(r, e) { return uploads_arrayWithHoles(r) || uploads_iterableToArrayLimit(r, e) || uploads_unsupportedIterableToArray(r, e) || uploads_nonIterableRest(); }\nfunction uploads_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction uploads_unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return uploads_arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? uploads_arrayLikeToArray(r, a) : void 0; } }\nfunction uploads_arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction uploads_iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction uploads_arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n/**\n * Uploads component\n * This component fetches account uploads data from the API and displays them in a grid\n * with filtering and pagination options\n */\n\n\n\n\n\n\n\n\n\nvar dateFilterOptions = [{\n  id: "select",\n  label: "Select"\n}, {\n  id: "today",\n  label: "Today"\n}, {\n  id: "week",\n  label: "This Week"\n}, {\n  id: "month",\n  label: "This Month"\n}, {\n  id: "year",\n  label: "This Year"\n}];\nvar typeFilterOptions = [{\n  id: "all",\n  label: "All"\n}, {\n  id: "pdf",\n  label: "PDF"\n}, {\n  id: "text",\n  label: "Text"\n}, {\n  id: "png",\n  label: "PNG"\n}, {\n  id: "jpeg",\n  label: "JPEG/JPG"\n}];\nvar Uploads = function Uploads(_ref) {\n  var _ref$limit = _ref.limit,\n    limit = _ref$limit === void 0 ? 9 : _ref$limit;\n  var _useState = (0,react.useState)("select"),\n    _useState2 = uploads_slicedToArray(_useState, 2),\n    dateFilter = _useState2[0],\n    setDateFilter = _useState2[1];\n  var _useState3 = (0,react.useState)("all"),\n    _useState4 = uploads_slicedToArray(_useState3, 2),\n    typeFilter = _useState4[0],\n    setTypeFilter = _useState4[1];\n  var _useState5 = (0,react.useState)(""),\n    _useState6 = uploads_slicedToArray(_useState5, 2),\n    searchQuery = _useState6[0],\n    setSearchQuery = _useState6[1];\n  var _useState7 = (0,react.useState)("grid"),\n    _useState8 = uploads_slicedToArray(_useState7, 2),\n    viewMode = _useState8[0],\n    setViewMode = _useState8[1];\n  var _useWallet = useWallet(),\n    defaultWallet = _useWallet.defaultWallet;\n  var rewardAccounts = useRewardAccounts();\n  var _useUploads = useUploads({\n      limit: limit,\n      rewardAccounts: rewardAccounts\n    }),\n    allUploads = _useUploads.allUploads,\n    filteredUploads = _useUploads.filteredUploads,\n    displayedUploads = _useUploads.displayedUploads,\n    setFilteredUploads = _useUploads.setFilteredUploads,\n    setDisplayedUploads = _useUploads.setDisplayedUploads,\n    loading = _useUploads.loading,\n    error = _useUploads.error,\n    pagesData = _useUploads.pagesData,\n    lastObjectUlids = _useUploads.lastObjectUlids,\n    currentPage = _useUploads.currentPage,\n    setCurrentPage = _useUploads.setCurrentPage,\n    hasMorePages = _useUploads.hasMorePages,\n    setAllUploads = _useUploads.setAllUploads,\n    setPagesData = _useUploads.setPagesData,\n    setLastObjectUlids = _useUploads.setLastObjectUlids,\n    setHasMorePages = _useUploads.setHasMorePages,\n    fetchNextPage = _useUploads.fetchNextPage;\n\n  // Filtering logic\n  // Use mockData cuando no hay datos reales\n  (0,react.useEffect)(function () {\n    if (allUploads.length === 0 && !loading) {\n      setAllUploads(mockUploads);\n    }\n  }, [allUploads.length, loading, setAllUploads]);\n  (0,react.useEffect)(function () {\n    var filtered = uploads_toConsumableArray(allUploads);\n    // Date filter\n    if (dateFilter !== "select") {\n      var now = new Date();\n      var today = new Date(now.getFullYear(), now.getMonth(), now.getDate());\n      var thisWeek = new Date(today);\n      thisWeek.setDate(today.getDate() - 7);\n      var thisMonth = new Date(today);\n      thisMonth.setMonth(today.getMonth() - 1);\n      var thisYear = new Date(today);\n      thisYear.setFullYear(today.getFullYear() - 1);\n      filtered = filtered.filter(function (upload) {\n        var uploadDate = new Date(upload.dateUploaded);\n        switch (dateFilter) {\n          case "today":\n            return uploadDate >= today;\n          case "week":\n            return uploadDate >= thisWeek;\n          case "month":\n            return uploadDate >= thisMonth;\n          case "year":\n            return uploadDate >= thisYear;\n          default:\n            return true;\n        }\n      });\n    }\n    // Type filter\n    if (typeFilter !== "all") {\n      filtered = filtered.filter(function (upload) {\n        if (!upload.fileType) return false;\n        var lowerFileType = upload.fileType.toLowerCase();\n        switch (typeFilter) {\n          case "pdf":\n            return lowerFileType.includes("pdf");\n          case "text":\n            return lowerFileType.includes("text");\n          case "png":\n            return lowerFileType.includes("png");\n          case "jpeg":\n            return lowerFileType.includes("jpeg") || lowerFileType.includes("jpg");\n          default:\n            return true;\n        }\n      });\n    }\n    // Search\n    if (searchQuery.trim() !== "") {\n      var query = searchQuery.toLowerCase();\n      filtered = filtered.filter(function (upload) {\n        return upload.name && upload.name.toLowerCase().includes(query) || upload.description && upload.description.toLowerCase().includes(query);\n      });\n    }\n    setFilteredUploads(filtered);\n    setDisplayedUploads(filtered.slice(0, limit));\n    setCurrentPage(1);\n  }, [allUploads, dateFilter, typeFilter, searchQuery, limit, setFilteredUploads, setDisplayedUploads, setCurrentPage]);\n  var handleSearch = function handleSearch(e) {\n    e.preventDefault();\n  };\n  var handleCopyText = function handleCopyText(text) {\n    navigator.clipboard.writeText(text).then(function () {\n      // Optional: toast notification\n    });\n  };\n  var loadMore = function loadMore() {\n    if (hasMorePages) fetchNextPage(currentPage + 1);\n  };\n  var goToPreviousPage = function goToPreviousPage() {\n    if (currentPage > 1) {\n      setDisplayedUploads(pagesData[currentPage - 1] || []);\n      setCurrentPage(currentPage - 1);\n    }\n  };\n  var goToPage = function goToPage(page) {\n    if (page === currentPage) return;\n    if (page < currentPage) {\n      setDisplayedUploads(pagesData[page] || []);\n      setCurrentPage(page);\n    } else {\n      fetchNextPage(page);\n    }\n  };\n\n  // if (!defaultWallet) {\n  //   return <div className="uploads-error">Please connect a wallet</div>;\n  // }\n\n  return /*#__PURE__*/react.createElement("div", {\n    className: "max-w-7xl mx-auto p-5 text-text-primary bg-primary-900 min-h-screen"\n  }, /*#__PURE__*/react.createElement("div", {\n    className: "flex justify-between items-center mb-8 flex-wrap"\n  }, /*#__PURE__*/react.createElement("h1", {\n    className: "text-3xl font-bold text-text-primary m-0"\n  }, "My uploads"), /*#__PURE__*/react.createElement(uploads_UploadsFilters, {\n    dateFilter: dateFilter,\n    setDateFilter: setDateFilter,\n    typeFilter: typeFilter,\n    setTypeFilter: setTypeFilter,\n    searchQuery: searchQuery,\n    setSearchQuery: setSearchQuery,\n    onSearch: handleSearch,\n    dateFilterOptions: dateFilterOptions,\n    typeFilterOptions: typeFilterOptions,\n    viewMode: viewMode,\n    setViewMode: setViewMode\n  })), loading ? /*#__PURE__*/react.createElement("div", {\n    className: "text-center py-12 text-text-muted text-lg"\n  }, "Loading uploads...") : error ? /*#__PURE__*/react.createElement("div", {\n    className: "text-center py-12 text-text-muted text-lg"\n  }, "Error loading uploads. Using mock data instead.") : displayedUploads.length === 0 ? /*#__PURE__*/react.createElement("div", {\n    className: "text-center py-12 text-text-muted text-lg"\n  }, "No uploads found.") : viewMode === "grid" ? /*#__PURE__*/react.createElement(uploads_UploadsGrid, {\n    uploads: displayedUploads,\n    onCopyText: handleCopyText\n  }) : /*#__PURE__*/react.createElement(uploads_UploadsList, {\n    uploads: displayedUploads,\n    onCopyText: handleCopyText\n  }), displayedUploads.length > 0 && /*#__PURE__*/react.createElement("div", {\n    className: "flex justify-center items-center mt-8 gap-2.5"\n  }, /*#__PURE__*/react.createElement("button", {\n    onClick: goToPreviousPage,\n    disabled: currentPage === 1 || loading,\n    className: "bg-primary-800 border border-border px-4 py-2 rounded-md cursor-pointer transition-colors duration-200 hover:bg-primary-700 text-text-primary disabled:opacity-50 disabled:cursor-not-allowed"\n  }, "Previous"), /*#__PURE__*/react.createElement("div", {\n    className: "flex items-center gap-1.5"\n  }, currentPage > 2 && /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return goToPage(1);\n    },\n    className: "w-8 h-8 flex items-center justify-center bg-primary-800 border border-border text-text-primary rounded-md cursor-pointer"\n  }, "1"), currentPage > 3 && /*#__PURE__*/react.createElement("span", {\n    className: "text-text-muted"\n  }, "..."), currentPage > 1 && /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return goToPage(currentPage - 1);\n    },\n    className: "w-8 h-8 flex items-center justify-center bg-primary-800 border border-border text-text-primary rounded-md cursor-pointer"\n  }, currentPage - 1), /*#__PURE__*/react.createElement("button", {\n    className: "w-8 h-8 flex items-center justify-center bg-primary-600 border border-border-active text-text-primary rounded-md cursor-pointer"\n  }, currentPage), hasMorePages && /*#__PURE__*/react.createElement("button", {\n    onClick: function onClick() {\n      return goToPage(currentPage + 1);\n    },\n    className: "w-8 h-8 flex items-center justify-center bg-primary-800 border border-border text-text-primary rounded-md cursor-pointer"\n  }, currentPage + 1), hasMorePages && /*#__PURE__*/react.createElement("span", {\n    className: "text-text-muted"\n  }, "...")), /*#__PURE__*/react.createElement("button", {\n    onClick: loadMore,\n    disabled: !hasMorePages || loading,\n    className: "bg-primary-800 border border-border text-text-primary px-4 py-2 rounded-md cursor-pointer transition-colors duration-200 hover:bg-primary-700 disabled:opacity-50 disabled:cursor-not-allowed"\n  }, "Next")));\n};\n/* harmony default export */ const uploads = (Uploads);\n;// ./src/index.tsx\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar App = function App() {\n  return /*#__PURE__*/react.createElement(MainUploader, null);\n};\nvar ConnectWalletApp = function ConnectWalletApp() {\n  return /*#__PURE__*/react.createElement(ConnectWallet, null);\n};\n\n// Self-executing function that works whether DOM is already loaded or not\n(function () {\n  var currentExecutingEnvironment = window.location.host.includes("webflow.io") || window.location.host.includes("localhost") ? "preproduction" : "production";\n  if (currentExecutingEnvironment !== ENVIRONMENT) {\n    /* console.error(`Mismatched environment: Expected ${ENVIRONMENT}, found ${currentExecutingEnvironment}`); */\n    console.warn("YOU ARE WORKING IN ".concat(currentExecutingEnvironment, " ENVIRONMENT"));\n    return;\n  }\n  console.log("HELLO THERE FROM PREPROD");\n  var renderApp = function renderApp() {\n    var rootElement = document.getElementById("react-target");\n    var connectWalletElement = document.getElementById("connect-wallet");\n    //const inscriptorElement = document.getElementById("inscriptor-root");\n    var decoderElement = document.getElementById("decoder");\n    console.log("decoderElement", decoderElement);\n    /**\n     * HTML element where the <Uploads /> component will be rendered.\n     * This element should have an id of "uploads" and should be present in the\n     * HTML document.\n     */\n\n    var uploadsElement = document.getElementById("uploads");\n    console.log("uploadsElement", uploadsElement);\n    if (rootElement /* && inscriptorElement */) {\n      var root = client.createRoot(rootElement);\n      console.log("React target element found");\n      console.log("Connect wallet element found");\n      root.render(/*#__PURE__*/react.createElement(react.StrictMode, null, /*#__PURE__*/react.createElement(WalletProvider, null, /*#__PURE__*/react.createElement(TxStatusProvider, null, /*#__PURE__*/react.createElement(FileUploadProvider, null, /*#__PURE__*/react.createElement(TxPreparationProvider, null, /*#__PURE__*/react.createElement(TxInscriptionProvider, null, connectWalletElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(ConnectWalletApp, null), connectWalletElement), rootElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(App, null), rootElement), document.body && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(WalletMenu, null), document.body), uploadsElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(uploads, null), uploadsElement), decoderElement && /*#__PURE__*/(0,react_dom.createPortal)(/*#__PURE__*/react.createElement(decoder_HexDecoder, null), decoderElement))))))));\n    }\n  };\n\n  // Check if DOM is already loaded\n  if (document.readyState === "loading") {\n    // If not loaded yet, wait for DOMContentLoaded\n    document.addEventListener("DOMContentLoaded", renderApp);\n  } else {\n    // If already loaded, run immediately\n    renderApp();\n  }\n})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBQUMyVSxxQkFBcUIscUJBQ3BCM1UsbUJBQUEsQ0FBQ2dnQixxQkFBcUIsUUFDbkJ1VixvQkFBb0IsaUJBQ25CViwwQkFBWSxjQUFDNzBCLG1CQUFBLENBQUMrMEIsZ0JBQWdCLE1BQUUsQ0FBQyxFQUFFUSxvQkFBb0IsQ0FBQyxFQUN6REgsV0FBVyxpQkFBSVAsMEJBQVksY0FBQzcwQixtQkFBQSxDQUFDODBCLEdBQUcsTUFBRSxDQUFDLEVBQUVNLFdBQVcsQ0FBQyxFQUNqREMsUUFBUSxDQUFDbmYsSUFBSSxpQkFBSTJlLDBCQUFZLGNBQUM3MEIsbUJBQUEsQ0FBQ3FuQixVQUFVLE1BQUUsQ0FBQyxFQUFFZ08sUUFBUSxDQUFDbmYsSUFBSSxDQUFDLEVBQzVEdWYsY0FBYyxpQkFDYlosMEJBQVksY0FBQzcwQixtQkFBQSxDQUFDa3pCLE9BQU8sTUFBRSxDQUFDLEVBQUV1QyxjQUFjLENBQUMsRUFDMUNELGNBQWMsaUJBQ2JYLDBCQUFZLGNBQUM3MEIsbUJBQUEsQ0FBQzZzQixrQkFBVSxNQUFFLENBQUMsRUFBRTJJLGNBQWMsQ0FFeEIsQ0FDRixDQUNMLENBQ0osQ0FDSixDQUNBLENBQ3BCLENBQUM7SUFDSDtFQUNGLENBQUM7O0VBRUQ7RUFDQSxJQUFJSCxRQUFRLENBQUNTLFVBQVUsS0FBSyxTQUFTLEVBQUU7SUFDckM7SUFDQVQsUUFBUSxDQUFDeGlCLGdCQUFnQixDQUFDLGtCQUFrQixFQUFFc2lCLFNBQVMsQ0FBQztFQUMxRCxDQUFDLE1BQU07SUFDTDtJQUNBQSxTQUFTLENBQUMsQ0FBQztFQUNiO0FBQ0YsQ0FBQyxFQUFFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL3N0eWxlcy5jc3M/YThkMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvY29tcG9uZW50cy9jcmVhdGUtcHJveHkubWpzP2Y4Y2MiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanM/YzY3MyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5tanM/NTYyYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9zaGFsbG93LWNvbXBhcmUubWpzPzM1MmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2lzLXZhcmlhbnQtbGFiZWwubWpzPzgwYmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3Jlc29sdmUtdmFyaWFudHMubWpzPzlhM2UiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL3Jlc29sdmUtZHluYW1pYy12YXJpYW50cy5tanM/NjBmZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvdmFyaWFudC1wcm9wcy5tanM/OTYzYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi11dGlscy9kaXN0L2VzL21lbW8ubWpzPzViM2MiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvdXRpbHMvc3VwcG9ydHMvc2Nyb2xsLXRpbWVsaW5lLm1qcz9kNTg5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi9jb250cm9scy9CYXNlR3JvdXAubWpzPzE0YjUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvYW5pbWF0aW9uL2NvbnRyb2xzL0dyb3VwLm1qcz8xZGY3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9nZXQtdmFsdWUtdHJhbnNpdGlvbi5tanM/NDIxYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy91dGlscy9jYWxjLWR1cmF0aW9uLm1qcz9kMjNlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3V0aWxzL2lzLWdlbmVyYXRvci5tanM/ZjA3YSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vd2FhcGkvdXRpbHMvYXR0YWNoLXRpbWVsaW5lLm1qcz80MWNiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3V0aWxzL2lzLWJlemllci1kZWZpbml0aW9uLm1qcz9iZDdhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3V0aWxzL3N1cHBvcnRzL2ZsYWdzLm1qcz83ODM5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL3V0aWxzL3N1cHBvcnRzL21lbW8ubWpzP2IwYWUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvdXRpbHMvc3VwcG9ydHMvbGluZWFyLWVhc2luZy5tanM/ZWNkMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi11dGlscy9kaXN0L2VzL3Byb2dyZXNzLm1qcz80MGNlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi93YWFwaS91dGlscy9saW5lYXIubWpzP2JiOTkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvYW5pbWF0aW9uL3dhYXBpL3V0aWxzL2Vhc2luZy5tanM/MTY5NSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3N0YXRlL2lzLWFjdGl2ZS5tanM/YmU1ZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy91dGlscy9yZXNvbHZlLWVsZW1lbnRzLm1qcz85ZTZmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL3NldHVwLm1qcz8yMGI3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL2hvdmVyLm1qcz9jMTc1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzPzRiNmYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvZ2VzdHVyZXMvdXRpbHMvaXMtcHJpbWFyeS1wb2ludGVyLm1qcz8xYjRmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL3ByZXNzL3V0aWxzL2lzLWtleWJvYXJkLWFjY2Vzc2libGUubWpzPzBkMGEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvZ2VzdHVyZXMvcHJlc3MvdXRpbHMvc3RhdGUubWpzPzNiZDMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvZ2VzdHVyZXMvcHJlc3MvdXRpbHMva2V5Ym9hcmQubWpzPzUzNjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvZ2VzdHVyZXMvcHJlc3MvaW5kZXgubWpzPzgwZGIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tdXRpbHMvZGlzdC9lcy90aW1lLWNvbnZlcnNpb24ubWpzPzQxM2UiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tdXRpbHMvZGlzdC9lcy9ub29wLm1qcz83ZTc3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi93YWFwaS9OYXRpdmVBbmltYXRpb25Db250cm9scy5tanM/OGFiYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy91dGlscy9jcmVhdGUtZ2VuZXJhdG9yLWVhc2luZy5tanM/ZjVlZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9hbmltYXRpb24vd2FhcGkvdXRpbHMvY29udmVydC1vcHRpb25zLm1qcz8zMjM2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2FuaW1hdGlvbi93YWFwaS9Qc2V1ZG9BbmltYXRpb24ubWpzPzUwZDkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvdmlldy91dGlscy9jc3MubWpzPzBhMDgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tZG9tL2Rpc3QvZXMvdmlldy9zdGFydC5tanM/MWI1MSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy92aWV3L2luZGV4Lm1qcz8zNTU4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvbW90aW9uLWRvbS9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvc3RhdGUvc2V0LWFjdGl2ZS5tanM/ZDUyOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL21vdGlvbi1kb20vZGlzdC9lcy9pbmRleC5tanM/MWI1ZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9rZXlzLXRyYW5zZm9ybS5tanM/MzQ0OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9rZXlzLXBvc2l0aW9uLm1qcz9hZmVkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzPzY4NzIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvR2xvYmFsQ29uZmlnLm1qcz8xZWY4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2ZyYW1lbG9vcC9yZW5kZXItc3RlcC5tanM/YTViMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9mcmFtZWxvb3AvYmF0Y2hlci5tanM/ZDM0MSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9mcmFtZWxvb3AvZnJhbWUubWpzPzViNjciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL3N5bmMtdGltZS5tanM/NTRkMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9hcnJheS5tanM/YWI0YSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9zdWJzY3JpcHRpb24tbWFuYWdlci5tanM/ZDg3YyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qcz8zYjk3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL2luZGV4Lm1qcz8xMTM5Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qcz9kZDIyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanM/ZDhjZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2Utd2lsbC1jaGFuZ2UvaXMubWpzPzE3ZmQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXdpbGwtY2hhbmdlL2FkZC13aWxsLWNoYW5nZS5tanM/MzY3NiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzPzUzYjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL29wdGltaXplZC1hcHBlYXIvZGF0YS1pZC5tanM/NDE4NiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vb3B0aW1pemVkLWFwcGVhci9nZXQtYXBwZWFyLWlkLm1qcz80ZmVmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzPzNiODciLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2N1YmljLWJlemllci5tanM/ZDYyYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9lYXNpbmcvbW9kaWZpZXJzL21pcnJvci5tanM/YjA4MiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9lYXNpbmcvbW9kaWZpZXJzL3JldmVyc2UubWpzP2NiNzMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2JhY2subWpzP2U1NGYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2FudGljaXBhdGUubWpzP2EwYzMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL2NpcmMubWpzPzMxOWQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtemVyby12YWx1ZS1zdHJpbmcubWpzPzk5MDgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLW5vbmUubWpzPzk1NDYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvY2xhbXAubWpzP2E0NzUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvbnVtYmVycy9pbmRleC5tanM/YjRmMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy91dGlscy9zYW5pdGl6ZS5tanM/NTBkMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy91dGlscy9mbG9hdC1yZWdleC5tanM/ZDQyYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy91dGlscy9pcy1udWxsaXNoLm1qcz9mOTU0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL3V0aWxzL3NpbmdsZS1jb2xvci1yZWdleC5tanM/ZWRmMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy9jb2xvci91dGlscy5tanM/MzQ2OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy9jb2xvci9yZ2JhLm1qcz83Mzg0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL2NvbG9yL2hleC5tanM/YWRjMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy9udW1iZXJzL3VuaXRzLm1qcz8wYzE2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3R5cGVzL2NvbG9yL2hzbGEubWpzP2UyZWMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvY29sb3IvaW5kZXgubWpzPzZhYzYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvdXRpbHMvY29sb3ItcmVnZXgubWpzP2UyODAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdHlwZXMvY29tcGxleC9pbmRleC5tanM/Mzc2YiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS90eXBlcy9jb21wbGV4L2ZpbHRlci5tanM/NjJhNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL251bWJlci1icm93c2VyLm1qcz82MmY3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHJhbnNmb3JtLm1qcz8wMzdkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvdHlwZS1pbnQubWpzPzdhN2QiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzPzUyMTUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9kZWZhdWx0cy5tanM/MzA2NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2FuaW1hdGFibGUtbm9uZS5tanM/M2VkNCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9tYWtlLW5vbmUtYW5pbWF0YWJsZS5tanM/NGQ1NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL3VuaXQtY29udmVyc2lvbi5tanM/YTJjMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvS2V5ZnJhbWVzUmVzb2x2ZXIubWpzP2FlZDAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9tb3Rpb24tdXRpbHMvZGlzdC9lcy9lcnJvcnMubWpzPzY3NzAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtbnVtZXJpY2FsLXN0cmluZy5tanM/MTRmYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanM/NjM3NSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2Nzcy12YXJpYWJsZXMtY29udmVyc2lvbi5tanM/ZTVkOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3Rlc3QubWpzPzYwMjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90eXBlLWF1dG8ubWpzPzBkODYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9kaW1lbnNpb25zLm1qcz83YzUwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vRE9NS2V5ZnJhbWVzUmVzb2x2ZXIubWpzPzA2NDYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGFibGUubWpzP2QyOGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy91dGlscy9jYW4tYW5pbWF0ZS5tanM/Y2YzZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0b3JzL3dhYXBpL3V0aWxzL2dldC1maW5hbC1rZXlmcmFtZS5tanM/NzgzMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0b3JzL0Jhc2VBbmltYXRpb24ubWpzP2RiNjYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4L251bWJlci5tanM/ZDA3OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9oc2xhLXRvLXJnYmEubWpzP2I0YmUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvbWl4L2ltbWVkaWF0ZS5tanM/NDQ4OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9taXgvY29sb3IubWpzPzg2NGEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcGlwZS5tanM/ZmRiYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9taXgvdmlzaWJpbGl0eS5tanM/MTIxNyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9taXgvY29tcGxleC5tanM/ZGNjNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9taXgvaW5kZXgubWpzP2Y4MmUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2dlbmVyYXRvcnMvdXRpbHMvdmVsb2NpdHkubWpzP2I5N2UiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2dlbmVyYXRvcnMvc3ByaW5nL2RlZmF1bHRzLm1qcz8xYzJiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3NwcmluZy9maW5kLm1qcz8yZDZjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3NwcmluZy9pbmRleC5tanM/NmVjOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy9pbmVydGlhLm1qcz80YTJhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy9lYXNlLm1qcz84YmZhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2Vhc2luZy91dGlscy9pcy1lYXNpbmctYXJyYXkubWpzPzMyMGMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZWFzaW5nL3V0aWxzL21hcC5tanM/ZWQwZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pbnRlcnBvbGF0ZS5tanM/MjI2MyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9vZmZzZXRzL2ZpbGwubWpzPzlkMjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvb2Zmc2V0cy9kZWZhdWx0Lm1qcz9iYzU4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL29mZnNldHMvdGltZS5tanM/OGNiYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzPzg1YjgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy9kcml2ZXJzL2RyaXZlci1mcmFtZWxvb3AubWpzP2I0MzMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy9NYWluVGhyZWFkQW5pbWF0aW9uLm1qcz83YWY2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRvcnMvdXRpbHMvYWNjZWxlcmF0ZWQtdmFsdWVzLm1qcz8wM2U3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRvcnMvd2FhcGkvaW5kZXgubWpzP2U1OWEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdG9ycy93YWFwaS91dGlscy9zdXBwb3J0cy13YWFwaS5tanM/N2IyYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vYW5pbWF0b3JzL0FjY2VsZXJhdGVkQW5pbWF0aW9uLm1qcz82M2QxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9kZWZhdWx0LXRyYW5zaXRpb25zLm1qcz9iYTU3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy10cmFuc2l0aW9uLWRlZmluZWQubWpzP2Q4ZjYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2ludGVyZmFjZXMvbW90aW9uLXZhbHVlLm1qcz83ZDU1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9pbnRlcmZhY2VzL3Zpc3VhbC1lbGVtZW50LXRhcmdldC5tanM/OWQ5MSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vaW50ZXJmYWNlcy92aXN1YWwtZWxlbWVudC12YXJpYW50Lm1qcz9lOTVjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9pbnRlcmZhY2VzL3Zpc3VhbC1lbGVtZW50Lm1qcz8wMzUyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9nZXQtdmFyaWFudC1jb250ZXh0Lm1qcz83YThhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9hbmltYXRpb24tc3RhdGUubWpzPzAzY2MiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL0ZlYXR1cmUubWpzPzY2N2IiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbi9pbmRleC5tanM/NTkzYyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9uL2V4aXQubWpzP2EwY2YiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzPzFhMGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL2FkZC1kb20tZXZlbnQubWpzP2QxZTEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL2V2ZW50LWluZm8ubWpzP2UwZjEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL2FkZC1wb2ludGVyLWV2ZW50Lm1qcz85YmRlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2Rpc3RhbmNlLm1qcz82NzJhIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3Bhbi9QYW5TZXNzaW9uLm1qcz9iNTlkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzPzBhZTYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1jYWxjLm1qcz82YTJlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvdXRpbHMvY29uc3RyYWludHMubWpzPzA1NjkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzP2ExZmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi91dGlscy9lYWNoLWF4aXMubWpzP2U2MmYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9jb252ZXJzaW9uLm1qcz9hMjAxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvaGFzLXRyYW5zZm9ybS5tanM/NTZmMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qcz82ZWZkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvbWVhc3VyZS5tanM/OGEzOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9nZXQtY29udGV4dC13aW5kb3cubWpzP2M4MGMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvZHJhZy9WaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLm1qcz80NjY3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvaW5kZXgubWpzP2E4ZDEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvcGFuL2luZGV4Lm1qcz82NzEyIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcz80ODM4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL3VzZS1wcmVzZW5jZS5tanM/ODBkMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanM/OWFiMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanM/ZGFhZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvc3RhdGUubWpzPzUzYzIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm9yZGVyLXJhZGl1cy5tanM/MGE5ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3gtc2hhZG93Lm1qcz82YTUxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzP2VmYmQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZnJhbWVsb29wL21pY3JvdGFzay5tanM/NmI3NCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0L01lYXN1cmVMYXlvdXQubWpzP2FlZTYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL2FuaW1hdGUvc2luZ2xlLXZhbHVlLm1qcz9mMWEzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtc3ZnLWVsZW1lbnQubWpzPzE0ODkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2NvbXBhcmUtYnktZGVwdGgubWpzPzg4NzgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2ZsYXQtdHJlZS5tanM/ZDk3YiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9kZWxheS5tanM/OTYyOCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5tanM/MjBiNCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2FuaW1hdGlvbi9taXgtdmFsdWVzLm1qcz83MzA0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29weS5tanM/MmYzZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLXJlbW92ZS5tanM/NTUzZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L3V0aWxzLm1qcz84ZWVkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc2hhcmVkL3N0YWNrLm1qcz80ZDZlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3RyYW5zZm9ybS5tanM/ZGVmYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvY3JlYXRlLXByb2plY3Rpb24tbm9kZS5tanM/Zjk0MCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvRG9jdW1lbnRQcm9qZWN0aW9uTm9kZS5tanM/ZGNlZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvSFRNTFByb2plY3Rpb25Ob2RlLm1qcz9kMmZiIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9kcmFnLm1qcz85MDAwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2hvdmVyLm1qcz8yMjBkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2ZvY3VzLm1qcz8zYzAzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3ByZXNzLm1qcz8xNjk0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy92aWV3cG9ydC9vYnNlcnZlcnMubWpzP2Y2OGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L2luZGV4Lm1qcz85YmM2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9nZXN0dXJlcy5tanM/Y2RjNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0Lm1qcz84Zjc0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTGF6eUNvbnRleHQubWpzP2EyNGQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcz85OGQzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9pbmRleC5tanM/MDY3OSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvaXMtY29udHJvbGxpbmctdmFyaWFudHMubWpzPzFlNmEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L3V0aWxzLm1qcz81NDJlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTW90aW9uQ29udGV4dC9jcmVhdGUubWpzP2ViMDUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtYnJvd3Nlci5tanM/ZWU4ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvZGVmaW5pdGlvbnMubWpzP2JiNTgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xvYWQtZmVhdHVyZXMubWpzPzY4NzMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3N5bWJvbC5tanM/NDJmYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLW1vdGlvbi1yZWYubWpzPzI4M2EiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qcz9jMWM2Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzP2U3ZDMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2luZGV4Lm1qcz85NTUzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvbG93ZXJjYXNlLWVsZW1lbnRzLm1qcz83Yjc1Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvaXMtc3ZnLWNvbXBvbmVudC5tanM/MDgzYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtY29uc3RhbnQubWpzPzFjYTEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtc3RhdGUubWpzPzI4YTIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanM/YzVlYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC10cmFuc2Zvcm0ubWpzPzNjZjIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLm1qcz9hN2EzIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvcGF0aC5tanM/NzFkNiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3RyYW5zZm9ybS1vcmlnaW4ubWpzPzQ3NWQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9idWlsZC1hdHRycy5tanM/YTQ4OCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcz85ZjIxIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanM/Mjk2ZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2lzLXN2Zy10YWcubWpzPzhhNTYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvcmVuZGVyLm1qcz8yM2JmIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdXRpbHMvY2FtZWwtY2FzZS1hdHRycy5tanM/OTQwOCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3JlbmRlci5tanM/MWRiMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvaXMtZm9yY2VkLW1vdGlvbi12YWx1ZS5tanM/MDQ0ZiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanM/ZWJkZSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcz9kODViIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvY29uZmlnLW1vdGlvbi5tanM/NTRmYiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC9jb25maWctbW90aW9uLm1qcz9hN2UwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5tanM/MTIwMyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdmFsaWQtcHJvcC5tanM/NWM5MSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5tanM/Y2E1ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3VzZS1wcm9wcy5tanM/OWI2NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3VzZS1yZW5kZXIubWpzP2Q0ZDIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2NvbXBvbmVudHMvY3JlYXRlLWZhY3RvcnkubWpzP2NiZGYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcmVkdWNlZC1tb3Rpb24vc3RhdGUubWpzPzE2ODgiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcmVkdWNlZC1tb3Rpb24vaW5kZXgubWpzPzdkYjAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy9maW5kLm1qcz83NDFlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdG9yZS5tanM/ZTU3NyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvbW90aW9uLXZhbHVlcy5tanM/MjIzNSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvVmlzdWFsRWxlbWVudC5tanM/YzQzZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL0RPTVZpc3VhbEVsZW1lbnQubWpzPzAzZmQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvSFRNTFZpc3VhbEVsZW1lbnQubWpzPzdlNTAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy9TVkdWaXN1YWxFbGVtZW50Lm1qcz84YjZkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vY3JlYXRlLXZpc3VhbC1lbGVtZW50Lm1qcz8zNTVlIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9jb21wb25lbnRzL21vdGlvbi9jcmVhdGUubWpzPzZjOWEiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2NvbXBvbmVudHMvbW90aW9uL3Byb3h5Lm1qcz8yNGFjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL1BvcENoaWxkLm1qcz84YzE4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL1ByZXNlbmNlQ2hpbGQubWpzPzgxODkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXRpbHMubWpzPzZkNDUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvaW5kZXgubWpzPzcwNTYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb250ZXh0L0ZpbGVVcGxvYWRDb250ZXh0LnRzeD8yMWNjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvaWNvbnMvVXBsb2FkSWNvbi50c3g/N2JjZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbnRleHQvVHhTdGF0dXNDb250ZXh0LnRzeD8yZDFkIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91cGxvYWRlci91cGxvYWQtYm94LnRzeD8zMDQwIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29udGV4dC9XYWxsZXRDb250ZXh0LnRzeD82YTk0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvdXRpbHMvYXBpQ29uc3VtcHRpb24udHM/ZTQ5MiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbnRleHQvVHhQcmVwYXJhdGlvbkNvbnRleHQudHN4Pzc3OTUiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9pY29ucy9DbG9zZUljb24udHN4PzA5NzkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VpL0J1dHRvbi50c3g/ZDE5NSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2ljb25zL1BkZkljb24udHN4PzMzYTAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9pY29ucy9QbmdJY29uLnRzeD80MDk0Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvaWNvbnMvUGRnSWNvbi50c3g/M2IzYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2ljb25zL01wNEljb24udHN4PzA4ZGIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZGVyL2ZpbGUtbGlzdC50c3g/ODA3MCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2FkZXIvZGVsZWdhdGUtdmlldy50c3g/NzQxMCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbnRleHQvVHhJbnNjcmlwdGlvbkNvbnRleHQudHN4PzkxZjYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VpL0xvYWRpbmdTY3JlZW4udHN4PzI1NjQiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VpL0ZpbmlzaFNjcmVlbi50c3g/NDQxMSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdWkvUHJvZ3Jlc3NCYXIudHN4PzY0YjYiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZGVyL21haW5VcGxvYWRlci50c3g/YjI1YiIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvd2FsbGV0L0Nvbm5lY3RXYWxsZXQudHN4PzBmMmIiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9pY29ucy9DbG9zZUljb25TZWNvbmRhcnkudHN4PzRiOGMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3dhbGxldC9XYWxsZXRNZW51LnRzeD8wMjI3Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvdXRpbHMvZGVjb2Rlci50cz85MGY4Iiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy9kZWNvZGVyL0hleERlY29kZXIudHN4P2U1MTkiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvdXNlUmV3YXJkQWNjb3VudHMudHM/NTFlNCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy91c2VVcGxvYWRzLnRzP2YzZDMiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9jb21wb25lbnRzL3VwbG9hZHMvVXBsb2FkQ2FyZC50c3g/NGEwZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9VcGxvYWRzR3JpZC50c3g/ZmI1YyIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9VcGxvYWRMaXN0SXRlbS50c3g/M2UyYSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9VcGxvYWRzTGlzdC50c3g/ZGU4ZCIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9VcGxvYWRzRmlsdGVycy50c3g/NDYwOSIsIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL2NvbXBvbmVudHMvdXBsb2Fkcy9tb2NrRGF0YS50cz9kZDFjIiwid2VicGFjazovL29ubHktb24tY2hhaW4vLi9zcmMvY29tcG9uZW50cy91cGxvYWRzL3VwbG9hZHMudHN4P2FkZTAiLCJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL3NyYy9pbmRleC50c3g/ZDk4NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlcy5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcbm9wdGlvbnMuaW5zZXJ0ID0gaW5zZXJ0Rm4uYmluZChudWxsLCBcImhlYWRcIik7XG5vcHRpb25zLmRvbUFQSSA9IGRvbUFQSTtcbm9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50ID0gaW5zZXJ0U3R5bGVFbGVtZW50O1xuXG52YXIgdXBkYXRlID0gQVBJKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0ICogZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGVzLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2Fybi1vbmNlLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTU1vdGlvbkNvbXBvbmVudFByb3h5KGNvbXBvbmVudEZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIGdlbmVyYXRlZCBgbW90aW9uYCBjb21wb25lbnRzLCBlLmcgYG1vdGlvbi5kaXZgLCBgbW90aW9uLmlucHV0YCBldGMuXG4gICAgICogUmF0aGVyIHRoYW4gZ2VuZXJhdGluZyB0aGVtIGFuZXcgZXZlcnkgcmVuZGVyLlxuICAgICAqL1xuICAgIGNvbnN0IGNvbXBvbmVudENhY2hlID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRGYWN0b3J5RnVuY3Rpb24gPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB3YXJuT25jZShmYWxzZSwgXCJtb3Rpb24oKSBpcyBkZXByZWNhdGVkLiBVc2UgbW90aW9uLmNyZWF0ZSgpIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wb25lbnRGYWN0b3J5KC4uLmFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm94eShkZXByZWNhdGVkRmFjdG9yeUZ1bmN0aW9uLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBgbW90aW9uYCBpcyByZWZlcmVuY2VkIHdpdGggYSBwcm9wOiBgbW90aW9uLmRpdmAsIGBtb3Rpb24uaW5wdXRgIGV0Yy5cbiAgICAgICAgICogVGhlIHByb3AgbmFtZSBpcyBwYXNzZWQgdGhyb3VnaCBhcyBga2V5YCBhbmQgd2UgY2FuIHVzZSB0aGF0IHRvIGdlbmVyYXRlIGEgYG1vdGlvbmBcbiAgICAgICAgICogRE9NIGNvbXBvbmVudCB3aXRoIHRoYXQgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogKF90YXJnZXQsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJjcmVhdGVcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50RmFjdG9yeTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGNvbXBvbmVudCBjYWNoZSwgY3JlYXRlIGl0IGFuZCBjYWNoZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFjb21wb25lbnRDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudENhY2hlLnNldChrZXksIGNvbXBvbmVudEZhY3Rvcnkoa2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tcG9uZW50Q2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZURPTU1vdGlvbkNvbXBvbmVudFByb3h5IH07XG4iLCJmdW5jdGlvbiBpc0FuaW1hdGlvbkNvbnRyb2xzKHYpIHtcbiAgICByZXR1cm4gKHYgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgdHlwZW9mIHYuc3RhcnQgPT09IFwiZnVuY3Rpb25cIik7XG59XG5cbmV4cG9ydCB7IGlzQW5pbWF0aW9uQ29udHJvbHMgfTtcbiIsImNvbnN0IGlzS2V5ZnJhbWVzVGFyZ2V0ID0gKHYpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbn07XG5cbmV4cG9ydCB7IGlzS2V5ZnJhbWVzVGFyZ2V0IH07XG4iLCJmdW5jdGlvbiBzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICAgIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgc2hhbGxvd0NvbXBhcmUgfTtcbiIsIi8qKlxuICogRGVjaWRlcyBpZiB0aGUgc3VwcGxpZWQgdmFyaWFibGUgaXMgdmFyaWFudCBsYWJlbFxuICovXG5mdW5jdGlvbiBpc1ZhcmlhbnRMYWJlbCh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodik7XG59XG5cbmV4cG9ydCB7IGlzVmFyaWFudExhYmVsIH07XG4iLCJmdW5jdGlvbiBnZXRWYWx1ZVN0YXRlKHZpc3VhbEVsZW1lbnQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IFt7fSwge31dO1xuICAgIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBzdGF0ZVswXVtrZXldID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIHN0YXRlWzFdW2tleV0gPSB2YWx1ZS5nZXRWZWxvY2l0eSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20sIHZpc3VhbEVsZW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBkZWZpbml0aW9uIGlzIGEgZnVuY3Rpb24sIHJlc29sdmUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgW2N1cnJlbnQsIHZlbG9jaXR5XSA9IGdldFZhbHVlU3RhdGUodmlzdWFsRWxlbWVudCk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50LCB2ZWxvY2l0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGRlZmluaXRpb24gaXMgYSB2YXJpYW50IGxhYmVsLCBvclxuICAgICAqIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBhIHZhcmlhbnQgbGFiZWwsIHJlc29sdmUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBwcm9wcy52YXJpYW50cyAmJiBwcm9wcy52YXJpYW50c1tkZWZpbml0aW9uXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSd2ZSByZXNvbHZlZCBib3RoIGZ1bmN0aW9ucyBhbmQgdmFyaWFudCBsYWJlbHMsXG4gICAgICogYnV0IHRoZSByZXNvbHZlZCB2YXJpYW50IGxhYmVsIG1pZ2h0IGl0c2VsZiBoYXZlIGJlZW4gYSBmdW5jdGlvbi5cbiAgICAgKiBJZiBzbywgcmVzb2x2ZS4gVGhpcyBjYW4gb25seSBoYXZlIHJldHVybmVkIGEgdmFsaWQgdGFyZ2V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjb25zdCBbY3VycmVudCwgdmVsb2NpdHldID0gZ2V0VmFsdWVTdGF0ZSh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgZGVmaW5pdGlvbiA9IGRlZmluaXRpb24oY3VzdG9tICE9PSB1bmRlZmluZWQgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGN1cnJlbnQsIHZlbG9jaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59XG5cbmV4cG9ydCB7IHJlc29sdmVWYXJpYW50RnJvbVByb3BzIH07XG4iLCJpbXBvcnQgeyByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS12YXJpYW50cy5tanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICByZXR1cm4gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCB2aXN1YWxFbGVtZW50KTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZVZhcmlhbnQgfTtcbiIsImNvbnN0IHZhcmlhbnRQcmlvcml0eU9yZGVyID0gW1xuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwid2hpbGVJblZpZXdcIixcbiAgICBcIndoaWxlRm9jdXNcIixcbiAgICBcIndoaWxlSG92ZXJcIixcbiAgICBcIndoaWxlVGFwXCIsXG4gICAgXCJ3aGlsZURyYWdcIixcbiAgICBcImV4aXRcIixcbl07XG5jb25zdCB2YXJpYW50UHJvcHMgPSBbXCJpbml0aWFsXCIsIC4uLnZhcmlhbnRQcmlvcml0eU9yZGVyXTtcblxuZXhwb3J0IHsgdmFyaWFudFByaW9yaXR5T3JkZXIsIHZhcmlhbnRQcm9wcyB9O1xuIiwiLyojX19OT19TSURFX0VGRkVDVFNfXyovXG5mdW5jdGlvbiBtZW1vKGNhbGxiYWNrKSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXN1bHQgPSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG1lbW8gfTtcbiIsImltcG9ydCB7IG1lbW8gfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuXG5jb25zdCBzdXBwb3J0c1Njcm9sbFRpbWVsaW5lID0gbWVtbygoKSA9PiB3aW5kb3cuU2Nyb2xsVGltZWxpbmUgIT09IHVuZGVmaW5lZCk7XG5cbmV4cG9ydCB7IHN1cHBvcnRzU2Nyb2xsVGltZWxpbmUgfTtcbiIsImltcG9ydCB7IHN1cHBvcnRzU2Nyb2xsVGltZWxpbmUgfSBmcm9tICcuLi8uLi91dGlscy9zdXBwb3J0cy9zY3JvbGwtdGltZWxpbmUubWpzJztcblxuY2xhc3MgQmFzZUdyb3VwUGxheWJhY2tDb250cm9scyB7XG4gICAgY29uc3RydWN0b3IoYW5pbWF0aW9ucykge1xuICAgICAgICAvLyBCb3VuZCB0byBhY2NvbW9kYXRlIGNvbW1vbiBgcmV0dXJuIGFuaW1hdGlvbi5zdG9wYCBwYXR0ZXJuXG4gICAgICAgIHRoaXMuc3RvcCA9ICgpID0+IHRoaXMucnVuQWxsKFwic3RvcFwiKTtcbiAgICAgICAgdGhpcy5hbmltYXRpb25zID0gYW5pbWF0aW9ucy5maWx0ZXIoQm9vbGVhbik7XG4gICAgfVxuICAgIGdldCBmaW5pc2hlZCgpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgbmV3IGZpbmlzaGVkIFByb21pc2UgYW5kIGxlZ2FjeSB0aGVubmFibGUgQVBJXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmFuaW1hdGlvbnMubWFwKChhbmltYXRpb24pID0+IFwiZmluaXNoZWRcIiBpbiBhbmltYXRpb24gPyBhbmltYXRpb24uZmluaXNoZWQgOiBhbmltYXRpb24pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVE9ETzogRmlsdGVyIG91dCBjYW5jZWxsZWQgb3Igc3RvcHBlZCBhbmltYXRpb25zIGJlZm9yZSByZXR1cm5pbmdcbiAgICAgKi9cbiAgICBnZXRBbGwocHJvcE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uc1swXVtwcm9wTmFtZV07XG4gICAgfVxuICAgIHNldEFsbChwcm9wTmFtZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1tpXVtwcm9wTmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdHRhY2hUaW1lbGluZSh0aW1lbGluZSwgZmFsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHRoaXMuYW5pbWF0aW9ucy5tYXAoKGFuaW1hdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzU2Nyb2xsVGltZWxpbmUoKSAmJiBhbmltYXRpb24uYXR0YWNoVGltZWxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uLmF0dGFjaFRpbWVsaW5lKHRpbWVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrKGFuaW1hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5mb3JFYWNoKChjYW5jZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjYW5jZWwgJiYgY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW2ldLnN0b3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKFwidGltZVwiKTtcbiAgICB9XG4gICAgc2V0IHRpbWUodGltZSkge1xuICAgICAgICB0aGlzLnNldEFsbChcInRpbWVcIiwgdGltZSk7XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKFwic3BlZWRcIik7XG4gICAgfVxuICAgIHNldCBzcGVlZChzcGVlZCkge1xuICAgICAgICB0aGlzLnNldEFsbChcInNwZWVkXCIsIHNwZWVkKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsKFwic3RhcnRUaW1lXCIpO1xuICAgIH1cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCB0aGlzLmFuaW1hdGlvbnNbaV0uZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIHJ1bkFsbChtZXRob2ROYW1lKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucy5mb3JFYWNoKChjb250cm9scykgPT4gY29udHJvbHNbbWV0aG9kTmFtZV0oKSk7XG4gICAgfVxuICAgIGZsYXR0ZW4oKSB7XG4gICAgICAgIHRoaXMucnVuQWxsKFwiZmxhdHRlblwiKTtcbiAgICB9XG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy5ydW5BbGwoXCJwbGF5XCIpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5ydW5BbGwoXCJwYXVzZVwiKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLnJ1bkFsbChcImNhbmNlbFwiKTtcbiAgICB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMucnVuQWxsKFwiY29tcGxldGVcIik7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzIH07XG4iLCJpbXBvcnQgeyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzIH0gZnJvbSAnLi9CYXNlR3JvdXAubWpzJztcblxuLyoqXG4gKiBUT0RPOiBUaGlzIGlzIGEgdGVtcG9yYXJ5IGNsYXNzIHRvIHN1cHBvcnQgdGhlIGxlZ2FjeVxuICogdGhlbm5hYmxlIEFQSVxuICovXG5jbGFzcyBHcm91cFBsYXliYWNrQ29udHJvbHMgZXh0ZW5kcyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzIHtcbiAgICB0aGVuKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuYW5pbWF0aW9ucykudGhlbihvblJlc29sdmUpLmNhdGNoKG9uUmVqZWN0KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEdyb3VwUGxheWJhY2tDb250cm9scyB9O1xuIiwiZnVuY3Rpb24gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uXG4gICAgICAgID8gdHJhbnNpdGlvbltrZXldIHx8XG4gICAgICAgICAgICB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fFxuICAgICAgICAgICAgdHJhbnNpdGlvblxuICAgICAgICA6IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IHsgZ2V0VmFsdWVUcmFuc2l0aW9uIH07XG4iLCIvKipcbiAqIEltcGxlbWVudCBhIHByYWN0aWNhbCBtYXggZHVyYXRpb24gZm9yIGtleWZyYW1lIGdlbmVyYXRpb25cbiAqIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAqL1xuY29uc3QgbWF4R2VuZXJhdG9yRHVyYXRpb24gPSAyMDAwMDtcbmZ1bmN0aW9uIGNhbGNHZW5lcmF0b3JEdXJhdGlvbihnZW5lcmF0b3IpIHtcbiAgICBsZXQgZHVyYXRpb24gPSAwO1xuICAgIGNvbnN0IHRpbWVTdGVwID0gNTA7XG4gICAgbGV0IHN0YXRlID0gZ2VuZXJhdG9yLm5leHQoZHVyYXRpb24pO1xuICAgIHdoaWxlICghc3RhdGUuZG9uZSAmJiBkdXJhdGlvbiA8IG1heEdlbmVyYXRvckR1cmF0aW9uKSB7XG4gICAgICAgIGR1cmF0aW9uICs9IHRpbWVTdGVwO1xuICAgICAgICBzdGF0ZSA9IGdlbmVyYXRvci5uZXh0KGR1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGR1cmF0aW9uID49IG1heEdlbmVyYXRvckR1cmF0aW9uID8gSW5maW5pdHkgOiBkdXJhdGlvbjtcbn1cblxuZXhwb3J0IHsgY2FsY0dlbmVyYXRvckR1cmF0aW9uLCBtYXhHZW5lcmF0b3JEdXJhdGlvbiB9O1xuIiwiZnVuY3Rpb24gaXNHZW5lcmF0b3IodHlwZSkge1xuICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5leHBvcnQgeyBpc0dlbmVyYXRvciB9O1xuIiwiZnVuY3Rpb24gYXR0YWNoVGltZWxpbmUoYW5pbWF0aW9uLCB0aW1lbGluZSkge1xuICAgIGFuaW1hdGlvbi50aW1lbGluZSA9IHRpbWVsaW5lO1xuICAgIGFuaW1hdGlvbi5vbmZpbmlzaCA9IG51bGw7XG59XG5cbmV4cG9ydCB7IGF0dGFjaFRpbWVsaW5lIH07XG4iLCJjb25zdCBpc0JlemllckRlZmluaXRpb24gPSAoZWFzaW5nKSA9PiBBcnJheS5pc0FycmF5KGVhc2luZykgJiYgdHlwZW9mIGVhc2luZ1swXSA9PT0gXCJudW1iZXJcIjtcblxuZXhwb3J0IHsgaXNCZXppZXJEZWZpbml0aW9uIH07XG4iLCIvKipcbiAqIEFkZCB0aGUgYWJpbGl0eSBmb3IgdGVzdCBzdWl0ZXMgdG8gbWFudWFsbHkgc2V0IHN1cHBvcnQgZmxhZ3NcbiAqIHRvIGJldHRlciB0ZXN0IG1vcmUgZW52aXJvbm1lbnRzLlxuICovXG5jb25zdCBzdXBwb3J0c0ZsYWdzID0ge1xuICAgIGxpbmVhckVhc2luZzogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IHsgc3VwcG9ydHNGbGFncyB9O1xuIiwiaW1wb3J0IHsgbWVtbyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBzdXBwb3J0c0ZsYWdzIH0gZnJvbSAnLi9mbGFncy5tanMnO1xuXG5mdW5jdGlvbiBtZW1vU3VwcG9ydHMoY2FsbGJhY2ssIHN1cHBvcnRzRmxhZykge1xuICAgIGNvbnN0IG1lbW9pemVkID0gbWVtbyhjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gc3VwcG9ydHNGbGFnc1tzdXBwb3J0c0ZsYWddKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBtZW1vaXplZCgpOyB9O1xufVxuXG5leHBvcnQgeyBtZW1vU3VwcG9ydHMgfTtcbiIsImltcG9ydCB7IG1lbW9TdXBwb3J0cyB9IGZyb20gJy4vbWVtby5tanMnO1xuXG5jb25zdCBzdXBwb3J0c0xpbmVhckVhc2luZyA9IC8qQF9fUFVSRV9fKi8gbWVtb1N1cHBvcnRzKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBkb2N1bWVudFxuICAgICAgICAgICAgLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgICAgIC5hbmltYXRlKHsgb3BhY2l0eTogMCB9LCB7IGVhc2luZzogXCJsaW5lYXIoMCwgMSlcIiB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn0sIFwibGluZWFyRWFzaW5nXCIpO1xuXG5leHBvcnQgeyBzdXBwb3J0c0xpbmVhckVhc2luZyB9O1xuIiwiLypcbiAgUHJvZ3Jlc3Mgd2l0aGluIGdpdmVuIHJhbmdlXG5cbiAgR2l2ZW4gYSBsb3dlciBsaW1pdCBhbmQgYW4gdXBwZXIgbGltaXQsIHdlIHJldHVybiB0aGUgcHJvZ3Jlc3NcbiAgKGV4cHJlc3NlZCBhcyBhIG51bWJlciAwLTEpIHJlcHJlc2VudGVkIGJ5IHRoZSBnaXZlbiB2YWx1ZSwgYW5kXG4gIGxpbWl0IHRoYXQgcHJvZ3Jlc3MgdG8gd2l0aGluIDAtMS5cblxuICBAcGFyYW0gW251bWJlcl06IExvd2VyIGxpbWl0XG4gIEBwYXJhbSBbbnVtYmVyXTogVXBwZXIgbGltaXRcbiAgQHBhcmFtIFtudW1iZXJdOiBWYWx1ZSB0byBmaW5kIHByb2dyZXNzIHdpdGhpbiBnaXZlbiByYW5nZVxuICBAcmV0dXJuIFtudW1iZXJdOiBQcm9ncmVzcyBvZiB2YWx1ZSB3aXRoaW4gcmFuZ2UgYXMgZXhwcmVzc2VkIDAtMVxuKi9cbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuY29uc3QgcHJvZ3Jlc3MgPSAoZnJvbSwgdG8sIHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdG9Gcm9tRGlmZmVyZW5jZSA9IHRvIC0gZnJvbTtcbiAgICByZXR1cm4gdG9Gcm9tRGlmZmVyZW5jZSA9PT0gMCA/IDEgOiAodmFsdWUgLSBmcm9tKSAvIHRvRnJvbURpZmZlcmVuY2U7XG59O1xuXG5leHBvcnQgeyBwcm9ncmVzcyB9O1xuIiwiaW1wb3J0IHsgcHJvZ3Jlc3MgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuXG5jb25zdCBnZW5lcmF0ZUxpbmVhckVhc2luZyA9IChlYXNpbmcsIGR1cmF0aW9uLCAvLyBhcyBtaWxsaXNlY29uZHNcbnJlc29sdXRpb24gPSAxMCAvLyBhcyBtaWxsaXNlY29uZHNcbikgPT4ge1xuICAgIGxldCBwb2ludHMgPSBcIlwiO1xuICAgIGNvbnN0IG51bVBvaW50cyA9IE1hdGgubWF4KE1hdGgucm91bmQoZHVyYXRpb24gLyByZXNvbHV0aW9uKSwgMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICBwb2ludHMgKz0gZWFzaW5nKHByb2dyZXNzKDAsIG51bVBvaW50cyAtIDEsIGkpKSArIFwiLCBcIjtcbiAgICB9XG4gICAgcmV0dXJuIGBsaW5lYXIoJHtwb2ludHMuc3Vic3RyaW5nKDAsIHBvaW50cy5sZW5ndGggLSAyKX0pYDtcbn07XG5cbmV4cG9ydCB7IGdlbmVyYXRlTGluZWFyRWFzaW5nIH07XG4iLCJpbXBvcnQgeyBpc0JlemllckRlZmluaXRpb24gfSBmcm9tICcuLi8uLi8uLi91dGlscy9pcy1iZXppZXItZGVmaW5pdGlvbi5tanMnO1xuaW1wb3J0IHsgc3VwcG9ydHNMaW5lYXJFYXNpbmcgfSBmcm9tICcuLi8uLi8uLi91dGlscy9zdXBwb3J0cy9saW5lYXItZWFzaW5nLm1qcyc7XG5pbXBvcnQgeyBnZW5lcmF0ZUxpbmVhckVhc2luZyB9IGZyb20gJy4vbGluZWFyLm1qcyc7XG5cbmZ1bmN0aW9uIGlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcoZWFzaW5nKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiBlYXNpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiBzdXBwb3J0c0xpbmVhckVhc2luZygpKSB8fFxuICAgICAgICAhZWFzaW5nIHx8XG4gICAgICAgICh0eXBlb2YgZWFzaW5nID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAoZWFzaW5nIGluIHN1cHBvcnRlZFdhYXBpRWFzaW5nIHx8IHN1cHBvcnRzTGluZWFyRWFzaW5nKCkpKSB8fFxuICAgICAgICBpc0JlemllckRlZmluaXRpb24oZWFzaW5nKSB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShlYXNpbmcpICYmIGVhc2luZy5ldmVyeShpc1dhYXBpU3VwcG9ydGVkRWFzaW5nKSkpO1xufVxuY29uc3QgY3ViaWNCZXppZXJBc1N0cmluZyA9IChbYSwgYiwgYywgZF0pID0+IGBjdWJpYy1iZXppZXIoJHthfSwgJHtifSwgJHtjfSwgJHtkfSlgO1xuY29uc3Qgc3VwcG9ydGVkV2FhcGlFYXNpbmcgPSB7XG4gICAgbGluZWFyOiBcImxpbmVhclwiLFxuICAgIGVhc2U6IFwiZWFzZVwiLFxuICAgIGVhc2VJbjogXCJlYXNlLWluXCIsXG4gICAgZWFzZU91dDogXCJlYXNlLW91dFwiLFxuICAgIGVhc2VJbk91dDogXCJlYXNlLWluLW91dFwiLFxuICAgIGNpcmNJbjogLypAX19QVVJFX18qLyBjdWJpY0JlemllckFzU3RyaW5nKFswLCAwLjY1LCAwLjU1LCAxXSksXG4gICAgY2lyY091dDogLypAX19QVVJFX18qLyBjdWJpY0JlemllckFzU3RyaW5nKFswLjU1LCAwLCAxLCAwLjQ1XSksXG4gICAgYmFja0luOiAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyQXNTdHJpbmcoWzAuMzEsIDAuMDEsIDAuNjYsIC0wLjU5XSksXG4gICAgYmFja091dDogLypAX19QVVJFX18qLyBjdWJpY0JlemllckFzU3RyaW5nKFswLjMzLCAxLjUzLCAwLjY5LCAwLjk5XSksXG59O1xuZnVuY3Rpb24gbWFwRWFzaW5nVG9OYXRpdmVFYXNpbmcoZWFzaW5nLCBkdXJhdGlvbikge1xuICAgIGlmICghZWFzaW5nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBlYXNpbmcgPT09IFwiZnVuY3Rpb25cIiAmJiBzdXBwb3J0c0xpbmVhckVhc2luZygpKSB7XG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUxpbmVhckVhc2luZyhlYXNpbmcsIGR1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCZXppZXJEZWZpbml0aW9uKGVhc2luZykpIHtcbiAgICAgICAgcmV0dXJuIGN1YmljQmV6aWVyQXNTdHJpbmcoZWFzaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlYXNpbmcpKSB7XG4gICAgICAgIHJldHVybiBlYXNpbmcubWFwKChzZWdtZW50RWFzaW5nKSA9PiBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyhzZWdtZW50RWFzaW5nLCBkdXJhdGlvbikgfHxcbiAgICAgICAgICAgIHN1cHBvcnRlZFdhYXBpRWFzaW5nLmVhc2VPdXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRlZFdhYXBpRWFzaW5nW2Vhc2luZ107XG4gICAgfVxufVxuXG5leHBvcnQgeyBjdWJpY0JlemllckFzU3RyaW5nLCBpc1dhYXBpU3VwcG9ydGVkRWFzaW5nLCBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZywgc3VwcG9ydGVkV2FhcGlFYXNpbmcgfTtcbiIsImNvbnN0IGlzRHJhZ2dpbmcgPSB7XG4gICAgeDogZmFsc2UsXG4gICAgeTogZmFsc2UsXG59O1xuZnVuY3Rpb24gaXNEcmFnQWN0aXZlKCkge1xuICAgIHJldHVybiBpc0RyYWdnaW5nLnggfHwgaXNEcmFnZ2luZy55O1xufVxuXG5leHBvcnQgeyBpc0RyYWdBY3RpdmUsIGlzRHJhZ2dpbmcgfTtcbiIsImZ1bmN0aW9uIHJlc29sdmVFbGVtZW50cyhlbGVtZW50T3JTZWxlY3Rvciwgc2NvcGUsIHNlbGVjdG9yQ2FjaGUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGVsZW1lbnRPclNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gW2VsZW1lbnRPclNlbGVjdG9yXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGVsZW1lbnRPclNlbGVjdG9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxldCByb290ID0gZG9jdW1lbnQ7XG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdG8gdXRpbHMgcGFja2FnZVxuICAgICAgICAgICAgLy8gaW52YXJpYW50KFxuICAgICAgICAgICAgLy8gICAgIEJvb2xlYW4oc2NvcGUuY3VycmVudCksXG4gICAgICAgICAgICAvLyAgICAgXCJTY29wZSBwcm92aWRlZCwgYnV0IG5vIGVsZW1lbnQgZGV0ZWN0ZWQuXCJcbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIHJvb3QgPSBzY29wZS5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gKF9hID0gc2VsZWN0b3JDYWNoZSA9PT0gbnVsbCB8fCBzZWxlY3RvckNhY2hlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RvckNhY2hlW2VsZW1lbnRPclNlbGVjdG9yXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcm9vdC5xdWVyeVNlbGVjdG9yQWxsKGVsZW1lbnRPclNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzID8gQXJyYXkuZnJvbShlbGVtZW50cykgOiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudE9yU2VsZWN0b3IpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRWxlbWVudHMgfTtcbiIsImltcG9ydCB7IHJlc29sdmVFbGVtZW50cyB9IGZyb20gJy4uLy4uL3V0aWxzL3Jlc29sdmUtZWxlbWVudHMubWpzJztcblxuZnVuY3Rpb24gc2V0dXBHZXN0dXJlKGVsZW1lbnRPclNlbGVjdG9yLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSByZXNvbHZlRWxlbWVudHMoZWxlbWVudE9yU2VsZWN0b3IpO1xuICAgIGNvbnN0IGdlc3R1cmVBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgZXZlbnRPcHRpb25zID0ge1xuICAgICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzaWduYWw6IGdlc3R1cmVBYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIH07XG4gICAgY29uc3QgY2FuY2VsID0gKCkgPT4gZ2VzdHVyZUFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgIHJldHVybiBbZWxlbWVudHMsIGV2ZW50T3B0aW9ucywgY2FuY2VsXTtcbn1cblxuZXhwb3J0IHsgc2V0dXBHZXN0dXJlIH07XG4iLCJpbXBvcnQgeyBpc0RyYWdBY3RpdmUgfSBmcm9tICcuL2RyYWcvc3RhdGUvaXMtYWN0aXZlLm1qcyc7XG5pbXBvcnQgeyBzZXR1cEdlc3R1cmUgfSBmcm9tICcuL3V0aWxzL3NldHVwLm1qcyc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRIb3ZlcihldmVudCkge1xuICAgIHJldHVybiAhKGV2ZW50LnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgaXNEcmFnQWN0aXZlKCkpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBob3ZlciBnZXN0dXJlLiBob3ZlcigpIGlzIGRpZmZlcmVudCB0byAuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiKVxuICogaW4gdGhhdCBpdCBoYXMgYW4gZWFzaWVyIHN5bnRheCwgZmlsdGVycyBvdXQgcG9seWZpbGxlZCB0b3VjaCBldmVudHMsIGludGVyb3BlcmF0ZXNcbiAqIHdpdGggZHJhZyBnZXN0dXJlcywgYW5kIGF1dG9tYXRpY2FsbHkgcmVtb3ZlcyB0aGUgXCJwb2ludGVyZW5uZFwiIGV2ZW50IGxpc3RlbmVyIHdoZW4gdGhlIGhvdmVyIGVuZHMuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBob3ZlcihlbGVtZW50T3JTZWxlY3Rvciwgb25Ib3ZlclN0YXJ0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBbZWxlbWVudHMsIGV2ZW50T3B0aW9ucywgY2FuY2VsXSA9IHNldHVwR2VzdHVyZShlbGVtZW50T3JTZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgY29uc3Qgb25Qb2ludGVyRW50ZXIgPSAoZW50ZXJFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIWlzVmFsaWRIb3ZlcihlbnRlckV2ZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQgfSA9IGVudGVyRXZlbnQ7XG4gICAgICAgIGNvbnN0IG9uSG92ZXJFbmQgPSBvbkhvdmVyU3RhcnQodGFyZ2V0LCBlbnRlckV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkhvdmVyRW5kICE9PSBcImZ1bmN0aW9uXCIgfHwgIXRhcmdldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb25Qb2ludGVyTGVhdmUgPSAobGVhdmVFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSG92ZXIobGVhdmVFdmVudCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgb25Ib3ZlckVuZChsZWF2ZUV2ZW50KTtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIG9uUG9pbnRlckxlYXZlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgb25Qb2ludGVyTGVhdmUsIGV2ZW50T3B0aW9ucyk7XG4gICAgfTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCBvblBvaW50ZXJFbnRlciwgZXZlbnRPcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsO1xufVxuXG5leHBvcnQgeyBob3ZlciB9O1xuIiwiLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSB1cCB0aGUgdHJlZSB0byBjaGVjayB3aGV0aGVyIHRoZSBwcm92aWRlZCBjaGlsZCBub2RlXG4gKiBpcyB0aGUgcGFyZW50IG9yIGEgZGVzY2VuZGFudCBvZiBpdC5cbiAqXG4gKiBAcGFyYW0gcGFyZW50IC0gRWxlbWVudCB0byBmaW5kXG4gKiBAcGFyYW0gY2hpbGQgLSBFbGVtZW50IHRvIHRlc3QgYWdhaW5zdCBwYXJlbnRcbiAqL1xuY29uc3QgaXNOb2RlT3JDaGlsZCA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcmVudCA9PT0gY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNOb2RlT3JDaGlsZChwYXJlbnQsIGNoaWxkLnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGlzTm9kZU9yQ2hpbGQgfTtcbiIsImNvbnN0IGlzUHJpbWFyeVBvaW50ZXIgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGV2ZW50LmJ1dHRvbiAhPT0gXCJudW1iZXJcIiB8fCBldmVudC5idXR0b24gPD0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpc1ByaW1hcnkgaXMgdHJ1ZSBmb3IgYWxsIG1pY2UgYnV0dG9ucywgd2hlcmVhcyBldmVyeSB0b3VjaCBwb2ludFxuICAgICAgICAgKiBpcyByZWdhcmRlZCBhcyBpdHMgb3duIGlucHV0LiBTbyBzdWJzZXF1ZW50IGNvbmN1cnJlbnQgdG91Y2ggcG9pbnRzXG4gICAgICAgICAqIHdpbGwgYmUgZmFsc2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNwZWNpZmljYWxseSBtYXRjaCBhZ2FpbnN0IGZhbHNlIGhlcmUgYXMgaW5jb21wbGV0ZSB2ZXJzaW9ucyBvZlxuICAgICAgICAgKiBQb2ludGVyRXZlbnRzIGluIHZlcnkgb2xkIGJyb3dzZXIgbWlnaHQgaGF2ZSBpdCBzZXQgYXMgdW5kZWZpbmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGV2ZW50LmlzUHJpbWFyeSAhPT0gZmFsc2U7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgaXNQcmltYXJ5UG9pbnRlciB9O1xuIiwiY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBuZXcgU2V0KFtcbiAgICBcIkJVVFRPTlwiLFxuICAgIFwiSU5QVVRcIixcbiAgICBcIlNFTEVDVFwiLFxuICAgIFwiVEVYVEFSRUFcIixcbiAgICBcIkFcIixcbl0pO1xuZnVuY3Rpb24gaXNFbGVtZW50S2V5Ym9hcmRBY2Nlc3NpYmxlKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gKGZvY3VzYWJsZUVsZW1lbnRzLmhhcyhlbGVtZW50LnRhZ05hbWUpIHx8XG4gICAgICAgIGVsZW1lbnQudGFiSW5kZXggIT09IC0xKTtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50S2V5Ym9hcmRBY2Nlc3NpYmxlIH07XG4iLCJjb25zdCBpc1ByZXNzaW5nID0gbmV3IFdlYWtTZXQoKTtcblxuZXhwb3J0IHsgaXNQcmVzc2luZyB9O1xuIiwiaW1wb3J0IHsgaXNQcmVzc2luZyB9IGZyb20gJy4vc3RhdGUubWpzJztcblxuLyoqXG4gKiBGaWx0ZXIgb3V0IGV2ZW50cyB0aGF0IGFyZSBub3QgXCJFbnRlclwiIGtleXMuXG4gKi9cbmZ1bmN0aW9uIGZpbHRlckV2ZW50cyhjYWxsYmFjaykge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gXCJFbnRlclwiKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxsYmFjayhldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZpcmVQb2ludGVyRXZlbnQodGFyZ2V0LCB0eXBlKSB7XG4gICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IFBvaW50ZXJFdmVudChcInBvaW50ZXJcIiArIHR5cGUsIHsgaXNQcmltYXJ5OiB0cnVlLCBidWJibGVzOiB0cnVlIH0pKTtcbn1cbmNvbnN0IGVuYWJsZUtleWJvYXJkUHJlc3MgPSAoZm9jdXNFdmVudCwgZXZlbnRPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IGZvY3VzRXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBpZiAoIWVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCBoYW5kbGVLZXlkb3duID0gZmlsdGVyRXZlbnRzKCgpID0+IHtcbiAgICAgICAgaWYgKGlzUHJlc3NpbmcuaGFzKGVsZW1lbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmaXJlUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwiZG93blwiKTtcbiAgICAgICAgY29uc3QgaGFuZGxlS2V5dXAgPSBmaWx0ZXJFdmVudHMoKCkgPT4ge1xuICAgICAgICAgICAgZmlyZVBvaW50ZXJFdmVudChlbGVtZW50LCBcInVwXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFuZGxlQmx1ciA9ICgpID0+IGZpcmVQb2ludGVyRXZlbnQoZWxlbWVudCwgXCJjYW5jZWxcIik7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGhhbmRsZUtleXVwLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGhhbmRsZUJsdXIsIGV2ZW50T3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBoYW5kbGVLZXlkb3duLCBldmVudE9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0aGF0IGZpcmVzIG9uIGJsdXIgdG8gcmVtb3ZlIHRoZSBrZXlkb3duIGV2ZW50cy5cbiAgICAgKi9cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsICgpID0+IGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5ZG93biksIGV2ZW50T3B0aW9ucyk7XG59O1xuXG5leHBvcnQgeyBlbmFibGVLZXlib2FyZFByZXNzIH07XG4iLCJpbXBvcnQgeyBpc0RyYWdBY3RpdmUgfSBmcm9tICcuLi9kcmFnL3N0YXRlL2lzLWFjdGl2ZS5tanMnO1xuaW1wb3J0IHsgaXNOb2RlT3JDaGlsZCB9IGZyb20gJy4uL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzJztcbmltcG9ydCB7IGlzUHJpbWFyeVBvaW50ZXIgfSBmcm9tICcuLi91dGlscy9pcy1wcmltYXJ5LXBvaW50ZXIubWpzJztcbmltcG9ydCB7IHNldHVwR2VzdHVyZSB9IGZyb20gJy4uL3V0aWxzL3NldHVwLm1qcyc7XG5pbXBvcnQgeyBpc0VsZW1lbnRLZXlib2FyZEFjY2Vzc2libGUgfSBmcm9tICcuL3V0aWxzL2lzLWtleWJvYXJkLWFjY2Vzc2libGUubWpzJztcbmltcG9ydCB7IGVuYWJsZUtleWJvYXJkUHJlc3MgfSBmcm9tICcuL3V0aWxzL2tleWJvYXJkLm1qcyc7XG5pbXBvcnQgeyBpc1ByZXNzaW5nIH0gZnJvbSAnLi91dGlscy9zdGF0ZS5tanMnO1xuXG4vKipcbiAqIEZpbHRlciBvdXQgZXZlbnRzIHRoYXQgYXJlIG5vdCBwcmltYXJ5IHBvaW50ZXIgZXZlbnRzLCBvciBhcmUgdHJpZ2dlcmluZ1xuICogd2hpbGUgYSBNb3Rpb24gZ2VzdHVyZSBpcyBhY3RpdmUuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRQcmVzc0V2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIGlzUHJpbWFyeVBvaW50ZXIoZXZlbnQpICYmICFpc0RyYWdBY3RpdmUoKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgcHJlc3MgZ2VzdHVyZS5cbiAqXG4gKiBQcmVzcyBpcyBkaWZmZXJlbnQgdG8gYFwicG9pbnRlcmRvd25cImAsIGBcInBvaW50ZXJ1cFwiYCBpbiB0aGF0IGl0XG4gKiBhdXRvbWF0aWNhbGx5IGZpbHRlcnMgb3V0IHNlY29uZGFyeSBwb2ludGVyIGV2ZW50cyBsaWtlIHJpZ2h0XG4gKiBjbGljayBhbmQgbXVsdGl0b3VjaC5cbiAqXG4gKiBJdCBhbHNvIGFkZHMgYWNjZXNzaWJpbGl0eSBzdXBwb3J0IGZvciBrZXlib2FyZHMsIHdoZXJlXG4gKiBhbiBlbGVtZW50IHdpdGggYSBwcmVzcyBnZXN0dXJlIHdpbGwgcmVjZWl2ZSBmb2N1cyBhbmRcbiAqICB0cmlnZ2VyIG9uIEVudGVyIGBcImtleWRvd25cImAgYW5kIGBcImtleXVwXCJgIGV2ZW50cy5cbiAqXG4gKiBUaGlzIGlzIGRpZmZlcmVudCB0byBhIGJyb3dzZXIncyBgXCJjbGlja1wiYCBldmVudCwgd2hpY2ggZG9lc1xuICogcmVzcG9uZCB0byBrZXlib2FyZHMgYnV0IG9ubHkgZm9yIHRoZSBgXCJjbGlja1wiYCBpdHNlbGYsIHJhdGhlclxuICogdGhhbiB0aGUgcHJlc3Mgc3RhcnQgYW5kIGVuZC9jYW5jZWwuIFRoZSBlbGVtZW50IGFsc28gbmVlZHNcbiAqIHRvIGJlIGZvY3VzYWJsZSBmb3IgdGhpcyB0byB3b3JrLCB3aGVyZWFzIGEgcHJlc3MgZ2VzdHVyZSB3aWxsXG4gKiBtYWtlIGFuIGVsZW1lbnQgZm9jdXNhYmxlIGJ5IGRlZmF1bHQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwcmVzcyhlbGVtZW50T3JTZWxlY3Rvciwgb25QcmVzc1N0YXJ0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBbZWxlbWVudHMsIGV2ZW50T3B0aW9ucywgY2FuY2VsRXZlbnRzXSA9IHNldHVwR2VzdHVyZShlbGVtZW50T3JTZWxlY3Rvciwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc3RhcnRQcmVzcyA9IChzdGFydEV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBzdGFydEV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGlmICghaXNWYWxpZFByZXNzRXZlbnQoc3RhcnRFdmVudCkgfHwgaXNQcmVzc2luZy5oYXMoZWxlbWVudCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzUHJlc3NpbmcuYWRkKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBvblByZXNzRW5kID0gb25QcmVzc1N0YXJ0KGVsZW1lbnQsIHN0YXJ0RXZlbnQpO1xuICAgICAgICBjb25zdCBvblBvaW50ZXJFbmQgPSAoZW5kRXZlbnQsIHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmNhbmNlbFwiLCBvblBvaW50ZXJDYW5jZWwpO1xuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkUHJlc3NFdmVudChlbmRFdmVudCkgfHwgIWlzUHJlc3NpbmcuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcmVzc2luZy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUHJlc3NFbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIG9uUHJlc3NFbmQoZW5kRXZlbnQsIHsgc3VjY2VzcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Qb2ludGVyVXAgPSAodXBFdmVudCkgPT4ge1xuICAgICAgICAgICAgb25Qb2ludGVyRW5kKHVwRXZlbnQsIG9wdGlvbnMudXNlR2xvYmFsVGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgaXNOb2RlT3JDaGlsZChlbGVtZW50LCB1cEV2ZW50LnRhcmdldCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblBvaW50ZXJDYW5jZWwgPSAoY2FuY2VsRXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uUG9pbnRlckVuZChjYW5jZWxFdmVudCwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBvblBvaW50ZXJVcCwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyY2FuY2VsXCIsIG9uUG9pbnRlckNhbmNlbCwgZXZlbnRPcHRpb25zKTtcbiAgICB9O1xuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgaWYgKCFpc0VsZW1lbnRLZXlib2FyZEFjY2Vzc2libGUoZWxlbWVudCkgJiZcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIikgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMudXNlR2xvYmFsVGFyZ2V0ID8gd2luZG93IDogZWxlbWVudDtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBzdGFydFByZXNzLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoZXZlbnQpID0+IGVuYWJsZUtleWJvYXJkUHJlc3MoZXZlbnQsIGV2ZW50T3B0aW9ucyksIGV2ZW50T3B0aW9ucyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbmNlbEV2ZW50cztcbn1cblxuZXhwb3J0IHsgcHJlc3MgfTtcbiIsIi8qKlxuICogQ29udmVydHMgc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcbiAqXG4gKiBAcGFyYW0gc2Vjb25kcyAtIFRpbWUgaW4gc2Vjb25kcy5cbiAqIEByZXR1cm4gbWlsbGlzZWNvbmRzIC0gQ29udmVydGVkIHRpbWUgaW4gbWlsbGlzZWNvbmRzLlxuICovXG4vKiNfX05PX1NJREVfRUZGRUNUU19fKi9cbmNvbnN0IHNlY29uZHNUb01pbGxpc2Vjb25kcyA9IChzZWNvbmRzKSA9PiBzZWNvbmRzICogMTAwMDtcbi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuY29uc3QgbWlsbGlzZWNvbmRzVG9TZWNvbmRzID0gKG1pbGxpc2Vjb25kcykgPT4gbWlsbGlzZWNvbmRzIC8gMTAwMDtcblxuZXhwb3J0IHsgbWlsbGlzZWNvbmRzVG9TZWNvbmRzLCBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfTtcbiIsIi8qI19fTk9fU0lERV9FRkZFQ1RTX18qL1xuY29uc3Qgbm9vcCA9IChhbnkpID0+IGFueTtcblxuZXhwb3J0IHsgbm9vcCB9O1xuIiwiaW1wb3J0IHsgbWlsbGlzZWNvbmRzVG9TZWNvbmRzLCBzZWNvbmRzVG9NaWxsaXNlY29uZHMsIG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgYXR0YWNoVGltZWxpbmUgfSBmcm9tICcuL3V0aWxzL2F0dGFjaC10aW1lbGluZS5tanMnO1xuXG5jbGFzcyBOYXRpdmVBbmltYXRpb25Db250cm9scyB7XG4gICAgY29uc3RydWN0b3IoYW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gYW5pbWF0aW9uO1xuICAgIH1cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBkdXJhdGlvbkluTXMgPSAoKF9iID0gKF9hID0gdGhpcy5hbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lZmZlY3QpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRDb21wdXRlZFRpbWluZygpLmR1cmF0aW9uKSB8fFxuICAgICAgICAgICAgKChfYyA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmR1cmF0aW9uKSB8fFxuICAgICAgICAgICAgMzAwO1xuICAgICAgICByZXR1cm4gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKE51bWJlcihkdXJhdGlvbkluTXMpKTtcbiAgICB9XG4gICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKCgoX2EgPSB0aGlzLmFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1cnJlbnRUaW1lKSB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc2V0IHRpbWUobmV3VGltZSkge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmN1cnJlbnRUaW1lID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG5ld1RpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uID8gdGhpcy5hbmltYXRpb24ucGxheWJhY2tSYXRlIDogMTtcbiAgICB9XG4gICAgc2V0IHNwZWVkKG5ld1NwZWVkKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24ucGxheWJhY2tSYXRlID0gbmV3U3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRpb24gPyB0aGlzLmFuaW1hdGlvbi5wbGF5U3RhdGUgOiBcImZpbmlzaGVkXCI7XG4gICAgfVxuICAgIGdldCBzdGFydFRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbiA/IHRoaXMuYW5pbWF0aW9uLnN0YXJ0VGltZSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBmaW5pc2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uID8gdGhpcy5hbmltYXRpb24uZmluaXNoZWQgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgcGxheSgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gJiYgdGhpcy5hbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb24gJiYgdGhpcy5hbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbiB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gXCJpZGxlXCIgfHxcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbi5jb21taXRTdHlsZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLmNvbW1pdFN0eWxlcygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICAgIGZsYXR0ZW4oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLmFuaW1hdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgKF9hID0gdGhpcy5hbmltYXRpb24uZWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlVGltaW5nKHsgZWFzaW5nOiBcImxpbmVhclwiIH0pO1xuICAgIH1cbiAgICBhdHRhY2hUaW1lbGluZSh0aW1lbGluZSkge1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pXG4gICAgICAgICAgICBhdHRhY2hUaW1lbGluZSh0aGlzLmFuaW1hdGlvbiwgdGltZWxpbmUpO1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uICYmIHRoaXMuYW5pbWF0aW9uLmZpbmlzaCgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbiAmJiB0aGlzLmFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBOYXRpdmVBbmltYXRpb25Db250cm9scyB9O1xuIiwiaW1wb3J0IHsgbWlsbGlzZWNvbmRzVG9TZWNvbmRzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGNhbGNHZW5lcmF0b3JEdXJhdGlvbiwgbWF4R2VuZXJhdG9yRHVyYXRpb24gfSBmcm9tICcuL2NhbGMtZHVyYXRpb24ubWpzJztcblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9ncmVzcyA9PiBwcm9ncmVzcyBlYXNpbmcgZnVuY3Rpb24gZnJvbSBhIGdlbmVyYXRvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR2VuZXJhdG9yRWFzaW5nKG9wdGlvbnMsIHNjYWxlID0gMTAwLCBjcmVhdGVHZW5lcmF0b3IpIHtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSBjcmVhdGVHZW5lcmF0b3IoeyAuLi5vcHRpb25zLCBrZXlmcmFtZXM6IFswLCBzY2FsZV0gfSk7XG4gICAgY29uc3QgZHVyYXRpb24gPSBNYXRoLm1pbihjYWxjR2VuZXJhdG9yRHVyYXRpb24oZ2VuZXJhdG9yKSwgbWF4R2VuZXJhdG9yRHVyYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gICAgICAgIGVhc2U6IChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRvci5uZXh0KGR1cmF0aW9uICogcHJvZ3Jlc3MpLnZhbHVlIC8gc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIGR1cmF0aW9uOiBtaWxsaXNlY29uZHNUb1NlY29uZHMoZHVyYXRpb24pLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUdlbmVyYXRvckVhc2luZyB9O1xuIiwiaW1wb3J0IHsgc2Vjb25kc1RvTWlsbGlzZWNvbmRzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IHN1cHBvcnRzTGluZWFyRWFzaW5nIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvc3VwcG9ydHMvbGluZWFyLWVhc2luZy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlR2VuZXJhdG9yRWFzaW5nIH0gZnJvbSAnLi4vLi4vZ2VuZXJhdG9ycy91dGlscy9jcmVhdGUtZ2VuZXJhdG9yLWVhc2luZy5tanMnO1xuaW1wb3J0IHsgaXNHZW5lcmF0b3IgfSBmcm9tICcuLi8uLi9nZW5lcmF0b3JzL3V0aWxzL2lzLWdlbmVyYXRvci5tanMnO1xuaW1wb3J0IHsgbWFwRWFzaW5nVG9OYXRpdmVFYXNpbmcgfSBmcm9tICcuL2Vhc2luZy5tanMnO1xuXG5jb25zdCBkZWZhdWx0RWFzaW5nID0gXCJlYXNlT3V0XCI7XG5mdW5jdGlvbiBhcHBseUdlbmVyYXRvck9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaXNHZW5lcmF0b3Iob3B0aW9ucy50eXBlKSkge1xuICAgICAgICBjb25zdCBnZW5lcmF0b3JPcHRpb25zID0gY3JlYXRlR2VuZXJhdG9yRWFzaW5nKG9wdGlvbnMsIDEwMCwgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgb3B0aW9ucy5lYXNlID0gc3VwcG9ydHNMaW5lYXJFYXNpbmcoKVxuICAgICAgICAgICAgPyBnZW5lcmF0b3JPcHRpb25zLmVhc2VcbiAgICAgICAgICAgIDogZGVmYXVsdEVhc2luZztcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhnZW5lcmF0b3JPcHRpb25zLmR1cmF0aW9uKTtcbiAgICAgICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSBzZWNvbmRzVG9NaWxsaXNlY29uZHMoKF9hID0gb3B0aW9ucy5kdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMC4zKTtcbiAgICAgICAgb3B0aW9ucy5lYXNlID0gb3B0aW9ucy5lYXNlIHx8IGRlZmF1bHRFYXNpbmc7XG4gICAgfVxufVxuLy8gVE9ETzogUmV1c2UgZm9yIE5hdGl2ZUFuaW1hdGlvblxuZnVuY3Rpb24gY29udmVydE1vdGlvbk9wdGlvbnNUb05hdGl2ZSh2YWx1ZU5hbWUsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBuYXRpdmVLZXlmcmFtZXMgPSB7fTtcbiAgICBjb25zdCBuYXRpdmVPcHRpb25zID0ge1xuICAgICAgICBmaWxsOiBcImJvdGhcIixcbiAgICAgICAgZWFzaW5nOiBcImxpbmVhclwiLFxuICAgICAgICBjb21wb3NpdGU6IFwicmVwbGFjZVwiLFxuICAgIH07XG4gICAgbmF0aXZlT3B0aW9ucy5kZWxheSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcygoX2EgPSBvcHRpb25zLmRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKTtcbiAgICBhcHBseUdlbmVyYXRvck9wdGlvbnMob3B0aW9ucyk7XG4gICAgbmF0aXZlT3B0aW9ucy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG4gICAgY29uc3QgeyBlYXNlLCB0aW1lcyB9ID0gb3B0aW9ucztcbiAgICBpZiAodGltZXMpXG4gICAgICAgIG5hdGl2ZUtleWZyYW1lcy5vZmZzZXQgPSB0aW1lcztcbiAgICBuYXRpdmVLZXlmcmFtZXNbdmFsdWVOYW1lXSA9IGtleWZyYW1lcztcbiAgICBjb25zdCBlYXNpbmcgPSBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyhlYXNlLCBvcHRpb25zLmR1cmF0aW9uKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGFuIGVhc2luZyBhcnJheSwgYXBwbHkgdG8ga2V5ZnJhbWVzLCBub3QgYW5pbWF0aW9uIGFzIGEgd2hvbGVcbiAgICAgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlYXNpbmcpKSB7XG4gICAgICAgIG5hdGl2ZUtleWZyYW1lcy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuYXRpdmVPcHRpb25zLmVhc2luZyA9IGVhc2luZztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5ZnJhbWVzOiBuYXRpdmVLZXlmcmFtZXMsXG4gICAgICAgIG9wdGlvbnM6IG5hdGl2ZU9wdGlvbnMsXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYXBwbHlHZW5lcmF0b3JPcHRpb25zLCBjb252ZXJ0TW90aW9uT3B0aW9uc1RvTmF0aXZlIH07XG4iLCJpbXBvcnQgeyBOYXRpdmVBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4vTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMubWpzJztcbmltcG9ydCB7IGNvbnZlcnRNb3Rpb25PcHRpb25zVG9OYXRpdmUgfSBmcm9tICcuL3V0aWxzL2NvbnZlcnQtb3B0aW9ucy5tanMnO1xuXG5jbGFzcyBQc2V1ZG9BbmltYXRpb24gZXh0ZW5kcyBOYXRpdmVBbmltYXRpb25Db250cm9scyB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBwc2V1ZG9FbGVtZW50LCB2YWx1ZU5hbWUsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY29udmVydE1vdGlvbk9wdGlvbnNUb05hdGl2ZSh2YWx1ZU5hbWUsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRhcmdldC5hbmltYXRlKGFuaW1hdGlvbk9wdGlvbnMua2V5ZnJhbWVzLCB7XG4gICAgICAgICAgICBwc2V1ZG9FbGVtZW50LFxuICAgICAgICAgICAgLi4uYW5pbWF0aW9uT3B0aW9ucy5vcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgc3VwZXIoYW5pbWF0aW9uKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBzZXVkb0FuaW1hdGlvbiB9O1xuIiwibGV0IHBlbmRpbmdSdWxlcyA9IHt9O1xubGV0IHN0eWxlID0gbnVsbDtcbmNvbnN0IGNzcyA9IHtcbiAgICBzZXQ6IChzZWxlY3RvciwgdmFsdWVzKSA9PiB7XG4gICAgICAgIHBlbmRpbmdSdWxlc1tzZWxlY3Rvcl0gPSB2YWx1ZXM7XG4gICAgfSxcbiAgICBjb21taXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKCFzdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICAgICAgICBzdHlsZS5pZCA9IFwibW90aW9uLXZpZXdcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3NzVGV4dCA9IFwiXCI7XG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3IgaW4gcGVuZGluZ1J1bGVzKSB7XG4gICAgICAgICAgICBjb25zdCBydWxlID0gcGVuZGluZ1J1bGVzW3NlbGVjdG9yXTtcbiAgICAgICAgICAgIGNzc1RleHQgKz0gYCR7c2VsZWN0b3J9IHtcXG5gO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhydWxlKSkge1xuICAgICAgICAgICAgICAgIGNzc1RleHQgKz0gYCAgJHtwcm9wZXJ0eX06ICR7dmFsdWV9O1xcbmA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjc3NUZXh0ICs9IFwifVxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIHBlbmRpbmdSdWxlcyA9IHt9O1xuICAgIH0sXG4gICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgIGlmIChzdHlsZSAmJiBzdHlsZS5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBzdHlsZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuXG5leHBvcnQgeyBjc3MgfTtcbiIsImltcG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBCYXNlR3JvdXBQbGF5YmFja0NvbnRyb2xzIH0gZnJvbSAnLi4vYW5pbWF0aW9uL2NvbnRyb2xzL0Jhc2VHcm91cC5tanMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVUcmFuc2l0aW9uIH0gZnJvbSAnLi4vYW5pbWF0aW9uL3V0aWxzL2dldC12YWx1ZS10cmFuc2l0aW9uLm1qcyc7XG5pbXBvcnQgeyBOYXRpdmVBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4uL2FuaW1hdGlvbi93YWFwaS9OYXRpdmVBbmltYXRpb25Db250cm9scy5tanMnO1xuaW1wb3J0IHsgUHNldWRvQW5pbWF0aW9uIH0gZnJvbSAnLi4vYW5pbWF0aW9uL3dhYXBpL1BzZXVkb0FuaW1hdGlvbi5tanMnO1xuaW1wb3J0IHsgYXBwbHlHZW5lcmF0b3JPcHRpb25zIH0gZnJvbSAnLi4vYW5pbWF0aW9uL3dhYXBpL3V0aWxzL2NvbnZlcnQtb3B0aW9ucy5tanMnO1xuaW1wb3J0IHsgbWFwRWFzaW5nVG9OYXRpdmVFYXNpbmcgfSBmcm9tICcuLi9hbmltYXRpb24vd2FhcGkvdXRpbHMvZWFzaW5nLm1qcyc7XG5pbXBvcnQgeyBjaG9vc2VMYXllclR5cGUgfSBmcm9tICcuL3V0aWxzL2Nob29zZS1sYXllci10eXBlLm1qcyc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICcuL3V0aWxzL2Nzcy5tanMnO1xuaW1wb3J0IHsgZ2V0TGF5ZXJOYW1lIH0gZnJvbSAnLi91dGlscy9nZXQtbGF5ZXItbmFtZS5tanMnO1xuaW1wb3J0IHsgZ2V0Vmlld0FuaW1hdGlvbnMgfSBmcm9tICcuL3V0aWxzL2dldC12aWV3LWFuaW1hdGlvbnMubWpzJztcbmltcG9ydCB7IGhhc1RhcmdldCB9IGZyb20gJy4vdXRpbHMvaGFzLXRhcmdldC5tanMnO1xuXG5jb25zdCBkZWZpbml0aW9uTmFtZXMgPSBbXCJsYXlvdXRcIiwgXCJlbnRlclwiLCBcImV4aXRcIiwgXCJuZXdcIiwgXCJvbGRcIl07XG5mdW5jdGlvbiBzdGFydFZpZXdBbmltYXRpb24odXBkYXRlLCBkZWZhdWx0T3B0aW9ucywgdGFyZ2V0cykge1xuICAgIGlmICghZG9jdW1lbnQuc3RhcnRWaWV3VHJhbnNpdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHVwZGF0ZSgpO1xuICAgICAgICAgICAgcmVzb2x2ZShuZXcgQmFzZUdyb3VwUGxheWJhY2tDb250cm9scyhbXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVE9ETzogR28gb3ZlciBleGlzdGluZyB0YXJnZXRzIGFuZCBlbnN1cmUgdGhleSBhbGwgaGF2ZSBpZHNcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFueSBhbmltYXRpb25zIGRlZmluZWQgZm9yIHRoZSByb290IHRhcmdldCxcbiAgICAgKiByZW1vdmUgaXQgZnJvbSBiZWluZyBjYXB0dXJlZC5cbiAgICAgKi9cbiAgICBpZiAoIWhhc1RhcmdldChcInJvb3RcIiwgdGFyZ2V0cykpIHtcbiAgICAgICAgY3NzLnNldChcIjpyb290XCIsIHtcbiAgICAgICAgICAgIFwidmlldy10cmFuc2l0aW9uLW5hbWVcIjogXCJub25lXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHRpbWluZyBjdXJ2ZSB0byBsaW5lYXIgZm9yIGFsbCB2aWV3IHRyYW5zaXRpb24gbGF5ZXJzLlxuICAgICAqIFRoaXMgZ2V0cyBiYWtlZCBpbnRvIHRoZSBrZXlmcmFtZXMsIHdoaWNoIGNhbid0IGJlIGNoYW5nZWRcbiAgICAgKiB3aXRob3V0IGJyZWFraW5nIHRoZSBnZW5lcmF0ZWQgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBhbGxvd3MgdXMgdG8gc2V0IGVhc2luZyB2aWEgdXBkYXRlVGltaW5nIC0gd2hpY2ggY2FuIGJlIGNoYW5nZWQuXG4gICAgICovXG4gICAgY3NzLnNldChcIjo6dmlldy10cmFuc2l0aW9uLWdyb3VwKCopLCA6OnZpZXctdHJhbnNpdGlvbi1vbGQoKiksIDo6dmlldy10cmFuc2l0aW9uLW5ldygqKVwiLCB7IFwiYW5pbWF0aW9uLXRpbWluZy1mdW5jdGlvblwiOiBcImxpbmVhciAhaW1wb3J0YW50XCIgfSk7XG4gICAgY3NzLmNvbW1pdCgpOyAvLyBXcml0ZVxuICAgIGNvbnN0IHRyYW5zaXRpb24gPSBkb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgdXBkYXRlKCk7XG4gICAgICAgIC8vIFRPRE86IEdvIG92ZXIgbmV3IHRhcmdldHMgYW5kIGVuc3VyZSB0aGV5IGFsbCBoYXZlIGlkc1xuICAgIH0pO1xuICAgIHRyYW5zaXRpb24uZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGNzcy5yZW1vdmUoKTsgLy8gV3JpdGVcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgdHJhbnNpdGlvbi5yZWFkeS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRlZFZpZXdBbmltYXRpb25zID0gZ2V0Vmlld0FuaW1hdGlvbnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGFuaW1hdGlvbnMgZm9yIG91ciBkZWZpbml0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0YXJnZXRzLmZvckVhY2goKGRlZmluaXRpb24sIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IElmIHRhcmdldCBpcyBub3QgXCJyb290XCIsIHJlc29sdmUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICAvLyBhbmQgaXRlcmF0ZSBvdmVyIGVhY2hcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBkZWZpbml0aW9uTmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWZpbml0aW9uW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBrZXlmcmFtZXMsIG9wdGlvbnMgfSA9IGRlZmluaXRpb25ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgW3ZhbHVlTmFtZSwgdmFsdWVLZXlmcmFtZXNdIG9mIE9iamVjdC5lbnRyaWVzKGtleWZyYW1lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWVLZXlmcmFtZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2V0VmFsdWVUcmFuc2l0aW9uKGRlZmF1bHRPcHRpb25zLCB2YWx1ZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdldFZhbHVlVHJhbnNpdGlvbihvcHRpb25zLCB2YWx1ZU5hbWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBjaG9vc2VMYXllclR5cGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBvcGFjaXR5IGFuaW1hdGlvbiwgYW5kIGtleWZyYW1lcyBhcmUgbm90IGFuIGFycmF5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byBjb252ZXJ0IHRoZW0gaW50byBhbiBhcnJheSBhbmQgc2V0IGFuIGluaXRpYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZU5hbWUgPT09IFwib3BhY2l0eVwiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkodmFsdWVLZXlmcmFtZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gdHlwZSA9PT0gXCJuZXdcIiA/IDAgOiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlS2V5ZnJhbWVzID0gW2luaXRpYWxWYWx1ZSwgdmFsdWVLZXlmcmFtZXNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBSZXNvbHZlIHN0YWdnZXIgZnVuY3Rpb24gaWYgcHJvdmlkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVPcHRpb25zLmRlbGF5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZU9wdGlvbnMuZGVsYXkgPSB2YWx1ZU9wdGlvbnMuZGVsYXkoMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgUHNldWRvQW5pbWF0aW9uKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYDo6dmlldy10cmFuc2l0aW9uLSR7dHlwZX0oJHt0YXJnZXR9KWAsIHZhbHVlTmFtZSwgdmFsdWVLZXlmcmFtZXMsIHZhbHVlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGUgYnJvd3NlciBnZW5lcmF0ZWQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFuaW1hdGlvbiBvZiBnZW5lcmF0ZWRWaWV3QW5pbWF0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24ucGxheVN0YXRlID09PSBcImZpbmlzaGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWZmZWN0IH0gPSBhbmltYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKCFlZmZlY3QgfHwgIShlZmZlY3QgaW5zdGFuY2VvZiBLZXlmcmFtZUVmZmVjdCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcHNldWRvRWxlbWVudCB9ID0gZWZmZWN0O1xuICAgICAgICAgICAgICAgIGlmICghcHNldWRvRWxlbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGdldExheWVyTmFtZShwc2V1ZG9FbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldERlZmluaXRpb24gPSB0YXJnZXRzLmdldChuYW1lLmxheWVyKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldERlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRyYW5zaXRpb24gbmFtZSBpcyBncm91cCB0aGVuIHVwZGF0ZSB0aGUgdGltaW5nIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICogd2hlcmVhcyBpZiBpdCdzIG9sZCBvciBuZXcgdGhlbiB3ZSBjb3VsZCBwb3NzaWJseSByZXBsYWNlIGl0IHVzaW5nXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBhYm92ZSBtZXRob2QuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uTmFtZSA9IG5hbWUudHlwZSA9PT0gXCJncm91cFwiID8gXCJsYXlvdXRcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvblRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5nZXRWYWx1ZVRyYW5zaXRpb24oZGVmYXVsdE9wdGlvbnMsIHRyYW5zaXRpb25OYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbHlHZW5lcmF0b3JPcHRpb25zKGFuaW1hdGlvblRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlYXNpbmcgPSBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyhhbmltYXRpb25UcmFuc2l0aW9uLmVhc2UsIGFuaW1hdGlvblRyYW5zaXRpb24uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBlZmZlY3QudXBkYXRlVGltaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBzZWNvbmRzVG9NaWxsaXNlY29uZHMoKF9hID0gYW5pbWF0aW9uVHJhbnNpdGlvbi5kZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogYW5pbWF0aW9uVHJhbnNpdGlvbi5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChuZXcgTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0aW9uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhc09wYWNpdHkodGFyZ2V0RGVmaW5pdGlvbiwgXCJlbnRlclwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBoYXNPcGFjaXR5KHRhcmdldERlZmluaXRpb24sIFwiZXhpdFwiKSAmJlxuICAgICAgICAgICAgICAgICAgICBlZmZlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRLZXlmcmFtZXMoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvbWUoKGtleWZyYW1lKSA9PiBrZXlmcmFtZS5taXhCbGVuZE1vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChuZXcgTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0aW9uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShuZXcgQmFzZUdyb3VwUGxheWJhY2tDb250cm9scyhhbmltYXRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFzT3BhY2l0eSh0YXJnZXQsIGtleSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGFyZ2V0ID09PSBudWxsIHx8IHRhcmdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0W2tleV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5rZXlmcmFtZXMub3BhY2l0eTtcbn1cblxuZXhwb3J0IHsgc3RhcnRWaWV3QW5pbWF0aW9uIH07XG4iLCJpbXBvcnQgeyBub29wIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IHN0YXJ0Vmlld0FuaW1hdGlvbiB9IGZyb20gJy4vc3RhcnQubWpzJztcblxuLyoqXG4gKiBUT0RPOlxuICogLSBDcmVhdGUgdmlldyB0cmFuc2l0aW9uIG9uIG5leHQgdGlja1xuICogLSBSZXBsYWNlIGFuaW1hdGlvbnMgd2l0aCBNb3Rpb24gYW5pbWF0aW9uc1xuICogLSBSZXR1cm4gR3JvdXBBbmltYXRpb24gb24gbmV4dCB0aWNrXG4gKi9cbmNsYXNzIFZpZXdUcmFuc2l0aW9uQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IodXBkYXRlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gXCJyb290XCI7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlSZWFkeSA9IG5vb3A7XG4gICAgICAgIHRoaXMucmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5UmVhZHkgPSByZXNvbHZlO1xuICAgICAgICB9KTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgc3RhcnRWaWV3QW5pbWF0aW9uKHVwZGF0ZSwgb3B0aW9ucywgdGhpcy50YXJnZXRzKS50aGVuKChhbmltYXRpb24pID0+IHRoaXMubm90aWZ5UmVhZHkoYW5pbWF0aW9uKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQoc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gc2VsZWN0b3I7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsYXlvdXQoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KFwibGF5b3V0XCIsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBuZXcoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KFwibmV3XCIsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvbGQoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGFyZ2V0KFwib2xkXCIsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbnRlcihrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoXCJlbnRlclwiLCBrZXlmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZXhpdChrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoXCJleGl0XCIsIGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjcm9zc2ZhZGUob3B0aW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRhcmdldChcImVudGVyXCIsIHsgb3BhY2l0eTogMSB9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy51cGRhdGVUYXJnZXQoXCJleGl0XCIsIHsgb3BhY2l0eTogMCB9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVwZGF0ZVRhcmdldCh0YXJnZXQsIGtleWZyYW1lcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudFRhcmdldCwgdGFyZ2V0cyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF0YXJnZXRzLmhhcyhjdXJyZW50VGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0cy5zZXQoY3VycmVudFRhcmdldCwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldERhdGEgPSB0YXJnZXRzLmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgICAgdGFyZ2V0RGF0YVt0YXJnZXRdID0geyBrZXlmcmFtZXMsIG9wdGlvbnMgfTtcbiAgICB9XG4gICAgdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVhZHlQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG59XG5mdW5jdGlvbiB2aWV3KHVwZGF0ZSwgZGVmYXVsdE9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgVmlld1RyYW5zaXRpb25CdWlsZGVyKHVwZGF0ZSwgZGVmYXVsdE9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBWaWV3VHJhbnNpdGlvbkJ1aWxkZXIsIHZpZXcgfTtcbiIsImltcG9ydCB7IGlzRHJhZ2dpbmcgfSBmcm9tICcuL2lzLWFjdGl2ZS5tanMnO1xuXG5mdW5jdGlvbiBzZXREcmFnTG9jayhheGlzKSB7XG4gICAgaWYgKGF4aXMgPT09IFwieFwiIHx8IGF4aXMgPT09IFwieVwiKSB7XG4gICAgICAgIGlmIChpc0RyYWdnaW5nW2F4aXNdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlzRHJhZ2dpbmdbYXhpc10gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nW2F4aXNdID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXNEcmFnZ2luZy54IHx8IGlzRHJhZ2dpbmcueSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc0RyYWdnaW5nLnggPSBpc0RyYWdnaW5nLnkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nLnggPSBpc0RyYWdnaW5nLnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IHNldERyYWdMb2NrIH07XG4iLCJleHBvcnQgeyBHcm91cFBsYXliYWNrQ29udHJvbHMgfSBmcm9tICcuL2FuaW1hdGlvbi9jb250cm9scy9Hcm91cC5tanMnO1xuZXhwb3J0IHsgZ2V0VmFsdWVUcmFuc2l0aW9uIH0gZnJvbSAnLi9hbmltYXRpb24vdXRpbHMvZ2V0LXZhbHVlLXRyYW5zaXRpb24ubWpzJztcbmV4cG9ydCB7IGNhbGNHZW5lcmF0b3JEdXJhdGlvbiwgbWF4R2VuZXJhdG9yRHVyYXRpb24gfSBmcm9tICcuL2FuaW1hdGlvbi9nZW5lcmF0b3JzL3V0aWxzL2NhbGMtZHVyYXRpb24ubWpzJztcbmV4cG9ydCB7IGNyZWF0ZUdlbmVyYXRvckVhc2luZyB9IGZyb20gJy4vYW5pbWF0aW9uL2dlbmVyYXRvcnMvdXRpbHMvY3JlYXRlLWdlbmVyYXRvci1lYXNpbmcubWpzJztcbmV4cG9ydCB7IGlzR2VuZXJhdG9yIH0gZnJvbSAnLi9hbmltYXRpb24vZ2VuZXJhdG9ycy91dGlscy9pcy1nZW5lcmF0b3IubWpzJztcbmV4cG9ydCB7IE5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi9hbmltYXRpb24vd2FhcGkvTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMubWpzJztcbmV4cG9ydCB7IGF0dGFjaFRpbWVsaW5lIH0gZnJvbSAnLi9hbmltYXRpb24vd2FhcGkvdXRpbHMvYXR0YWNoLXRpbWVsaW5lLm1qcyc7XG5leHBvcnQgeyBjdWJpY0JlemllckFzU3RyaW5nLCBpc1dhYXBpU3VwcG9ydGVkRWFzaW5nLCBtYXBFYXNpbmdUb05hdGl2ZUVhc2luZywgc3VwcG9ydGVkV2FhcGlFYXNpbmcgfSBmcm9tICcuL2FuaW1hdGlvbi93YWFwaS91dGlscy9lYXNpbmcubWpzJztcbmV4cG9ydCB7IGdlbmVyYXRlTGluZWFyRWFzaW5nIH0gZnJvbSAnLi9hbmltYXRpb24vd2FhcGkvdXRpbHMvbGluZWFyLm1qcyc7XG5leHBvcnQgeyBob3ZlciB9IGZyb20gJy4vZ2VzdHVyZXMvaG92ZXIubWpzJztcbmV4cG9ydCB7IHByZXNzIH0gZnJvbSAnLi9nZXN0dXJlcy9wcmVzcy9pbmRleC5tanMnO1xuZXhwb3J0IHsgaXNCZXppZXJEZWZpbml0aW9uIH0gZnJvbSAnLi91dGlscy9pcy1iZXppZXItZGVmaW5pdGlvbi5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZUVsZW1lbnRzIH0gZnJvbSAnLi91dGlscy9yZXNvbHZlLWVsZW1lbnRzLm1qcyc7XG5leHBvcnQgeyBzdXBwb3J0c0ZsYWdzIH0gZnJvbSAnLi91dGlscy9zdXBwb3J0cy9mbGFncy5tanMnO1xuZXhwb3J0IHsgc3VwcG9ydHNMaW5lYXJFYXNpbmcgfSBmcm9tICcuL3V0aWxzL3N1cHBvcnRzL2xpbmVhci1lYXNpbmcubWpzJztcbmV4cG9ydCB7IHN1cHBvcnRzU2Nyb2xsVGltZWxpbmUgfSBmcm9tICcuL3V0aWxzL3N1cHBvcnRzL3Njcm9sbC10aW1lbGluZS5tanMnO1xuZXhwb3J0IHsgVmlld1RyYW5zaXRpb25CdWlsZGVyLCB2aWV3IH0gZnJvbSAnLi92aWV3L2luZGV4Lm1qcyc7XG5leHBvcnQgeyBpc0RyYWdBY3RpdmUsIGlzRHJhZ2dpbmcgfSBmcm9tICcuL2dlc3R1cmVzL2RyYWcvc3RhdGUvaXMtYWN0aXZlLm1qcyc7XG5leHBvcnQgeyBzZXREcmFnTG9jayB9IGZyb20gJy4vZ2VzdHVyZXMvZHJhZy9zdGF0ZS9zZXQtYWN0aXZlLm1qcyc7XG5leHBvcnQgeyBpc05vZGVPckNoaWxkIH0gZnJvbSAnLi9nZXN0dXJlcy91dGlscy9pcy1ub2RlLW9yLWNoaWxkLm1qcyc7XG5leHBvcnQgeyBpc1ByaW1hcnlQb2ludGVyIH0gZnJvbSAnLi9nZXN0dXJlcy91dGlscy9pcy1wcmltYXJ5LXBvaW50ZXIubWpzJztcbiIsIi8qKlxuICogR2VuZXJhdGUgYSBsaXN0IG9mIGV2ZXJ5IHBvc3NpYmxlIHRyYW5zZm9ybSBrZXkuXG4gKi9cbmNvbnN0IHRyYW5zZm9ybVByb3BPcmRlciA9IFtcbiAgICBcInRyYW5zZm9ybVBlcnNwZWN0aXZlXCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ5XCIsXG4gICAgXCJ6XCIsXG4gICAgXCJ0cmFuc2xhdGVYXCIsXG4gICAgXCJ0cmFuc2xhdGVZXCIsXG4gICAgXCJ0cmFuc2xhdGVaXCIsXG4gICAgXCJzY2FsZVwiLFxuICAgIFwic2NhbGVYXCIsXG4gICAgXCJzY2FsZVlcIixcbiAgICBcInJvdGF0ZVwiLFxuICAgIFwicm90YXRlWFwiLFxuICAgIFwicm90YXRlWVwiLFxuICAgIFwicm90YXRlWlwiLFxuICAgIFwic2tld1wiLFxuICAgIFwic2tld1hcIixcbiAgICBcInNrZXdZXCIsXG5dO1xuLyoqXG4gKiBBIHF1aWNrIGxvb2t1cCBmb3IgdHJhbnNmb3JtIHByb3BzLlxuICovXG5jb25zdCB0cmFuc2Zvcm1Qcm9wcyA9IG5ldyBTZXQodHJhbnNmb3JtUHJvcE9yZGVyKTtcblxuZXhwb3J0IHsgdHJhbnNmb3JtUHJvcE9yZGVyLCB0cmFuc2Zvcm1Qcm9wcyB9O1xuIiwiaW1wb3J0IHsgdHJhbnNmb3JtUHJvcE9yZGVyIH0gZnJvbSAnLi9rZXlzLXRyYW5zZm9ybS5tanMnO1xuXG5jb25zdCBwb3NpdGlvbmFsS2V5cyA9IG5ldyBTZXQoW1xuICAgIFwid2lkdGhcIixcbiAgICBcImhlaWdodFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgLi4udHJhbnNmb3JtUHJvcE9yZGVyLFxuXSk7XG5cbmV4cG9ydCB7IHBvc2l0aW9uYWxLZXlzIH07XG4iLCJpbXBvcnQgeyBpc0tleWZyYW1lc1RhcmdldCB9IGZyb20gJy4uL2FuaW1hdGlvbi91dGlscy9pcy1rZXlmcmFtZXMtdGFyZ2V0Lm1qcyc7XG5cbmNvbnN0IGlzQ3VzdG9tVmFsdWUgPSAodikgPT4ge1xuICAgIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcbn07XG5jb25zdCByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzID0gKHYpID0+IHtcbiAgICAvLyBUT0RPIG1heWJlIHRocm93IGlmIHYubGVuZ3RoIC0gMSBpcyBwbGFjZWhvbGRlciB0b2tlbj9cbiAgICByZXR1cm4gaXNLZXlmcmFtZXNUYXJnZXQodikgPyB2W3YubGVuZ3RoIC0gMV0gfHwgMCA6IHY7XG59O1xuXG5leHBvcnQgeyBpc0N1c3RvbVZhbHVlLCByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzIH07XG4iLCJjb25zdCBNb3Rpb25HbG9iYWxDb25maWcgPSB7XG4gICAgc2tpcEFuaW1hdGlvbnM6IGZhbHNlLFxuICAgIHVzZU1hbnVhbFRpbWluZzogZmFsc2UsXG59O1xuXG5leHBvcnQgeyBNb3Rpb25HbG9iYWxDb25maWcgfTtcbiIsImZ1bmN0aW9uIGNyZWF0ZVJlbmRlclN0ZXAocnVuTmV4dEZyYW1lKSB7XG4gICAgLyoqXG4gICAgICogV2UgY3JlYXRlIGFuZCByZXVzZSB0d28gcXVldWVzLCBvbmUgdG8gcXVldWUgam9icyBmb3IgdGhlIGN1cnJlbnQgZnJhbWVcbiAgICAgKiBhbmQgb25lIGZvciB0aGUgbmV4dC4gV2UgcmV1c2UgdG8gYXZvaWQgdHJpZ2dlcmluZyBHQyBhZnRlciB4IGZyYW1lcy5cbiAgICAgKi9cbiAgICBsZXQgdGhpc0ZyYW1lID0gbmV3IFNldCgpO1xuICAgIGxldCBuZXh0RnJhbWUgPSBuZXcgU2V0KCk7XG4gICAgLyoqXG4gICAgICogVHJhY2sgd2hldGhlciB3ZSdyZSBjdXJyZW50bHkgcHJvY2Vzc2luZyBqb2JzIGluIHRoaXMgc3RlcC4gVGhpcyB3YXlcbiAgICAgKiB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG8gc2NoZWR1bGUgbmV3IGpvYnMgZm9yIHRoaXMgZnJhbWUgb3IgbmV4dC5cbiAgICAgKi9cbiAgICBsZXQgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgbGV0IGZsdXNoTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogQSBzZXQgb2YgcHJvY2Vzc2VzIHdoaWNoIHdlcmUgbWFya2VkIGtlZXBBbGl2ZSB3aGVuIHNjaGVkdWxlZC5cbiAgICAgKi9cbiAgICBjb25zdCB0b0tlZXBBbGl2ZSA9IG5ldyBXZWFrU2V0KCk7XG4gICAgbGV0IGxhdGVzdEZyYW1lRGF0YSA9IHtcbiAgICAgICAgZGVsdGE6IDAuMCxcbiAgICAgICAgdGltZXN0YW1wOiAwLjAsXG4gICAgICAgIGlzUHJvY2Vzc2luZzogZmFsc2UsXG4gICAgfTtcbiAgICBmdW5jdGlvbiB0cmlnZ2VyQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRvS2VlcEFsaXZlLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIHN0ZXAuc2NoZWR1bGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgcnVuTmV4dEZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobGF0ZXN0RnJhbWVEYXRhKTtcbiAgICB9XG4gICAgY29uc3Qgc3RlcCA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjaGVkdWxlIGEgcHJvY2VzcyB0byBydW4gb24gdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICBzY2hlZHVsZTogKGNhbGxiYWNrLCBrZWVwQWxpdmUgPSBmYWxzZSwgaW1tZWRpYXRlID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFkZFRvQ3VycmVudEZyYW1lID0gaW1tZWRpYXRlICYmIGlzUHJvY2Vzc2luZztcbiAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gYWRkVG9DdXJyZW50RnJhbWUgPyB0aGlzRnJhbWUgOiBuZXh0RnJhbWU7XG4gICAgICAgICAgICBpZiAoa2VlcEFsaXZlKVxuICAgICAgICAgICAgICAgIHRvS2VlcEFsaXZlLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoIXF1ZXVlLmhhcyhjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgcXVldWUuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbCB0aGUgcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBydW5uaW5nIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIG5leHRGcmFtZS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgdG9LZWVwQWxpdmUuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4ZWN1dGUgYWxsIHNjaGVkdWxlIGNhbGxiYWNrcy5cbiAgICAgICAgICovXG4gICAgICAgIHByb2Nlc3M6IChmcmFtZURhdGEpID0+IHtcbiAgICAgICAgICAgIGxhdGVzdEZyYW1lRGF0YSA9IGZyYW1lRGF0YTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgYWxyZWFkeSBwcm9jZXNzaW5nIHdlJ3ZlIHByb2JhYmx5IGJlZW4gdHJpZ2dlcmVkIGJ5IGEgZmx1c2hTeW5jXG4gICAgICAgICAgICAgKiBpbnNpZGUgYW4gZXhpc3RpbmcgcHJvY2Vzcy4gSW5zdGVhZCBvZiBleGVjdXRpbmcsIG1hcmsgZmx1c2hOZXh0RnJhbWVcbiAgICAgICAgICAgICAqIGFzIHRydWUgYW5kIGVuc3VyZSB3ZSBmbHVzaCB0aGUgZm9sbG93aW5nIGZyYW1lIGF0IHRoZSBlbmQgb2YgdGhpcyBvbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICBmbHVzaE5leHRGcmFtZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIFt0aGlzRnJhbWUsIG5leHRGcmFtZV0gPSBbbmV4dEZyYW1lLCB0aGlzRnJhbWVdO1xuICAgICAgICAgICAgLy8gRXhlY3V0ZSB0aGlzIGZyYW1lXG4gICAgICAgICAgICB0aGlzRnJhbWUuZm9yRWFjaCh0cmlnZ2VyQ2FsbGJhY2spO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIGZyYW1lIHNvIG5vIGNhbGxiYWNrcyByZW1haW4uIFRoaXMgaXMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIG1lbW9yeSBsZWFrcyBzaG91bGQgdGhpcyByZW5kZXIgc3RlcCBub3QgcnVuIGZvciBhIHdoaWxlLlxuICAgICAgICAgICAgdGhpc0ZyYW1lLmNsZWFyKCk7XG4gICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChmbHVzaE5leHRGcmFtZSkge1xuICAgICAgICAgICAgICAgIGZsdXNoTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3RlcC5wcm9jZXNzKGZyYW1lRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gc3RlcDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUmVuZGVyU3RlcCB9O1xuIiwiaW1wb3J0IHsgTW90aW9uR2xvYmFsQ29uZmlnIH0gZnJvbSAnLi4vdXRpbHMvR2xvYmFsQ29uZmlnLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVSZW5kZXJTdGVwIH0gZnJvbSAnLi9yZW5kZXItc3RlcC5tanMnO1xuXG5jb25zdCBzdGVwc09yZGVyID0gW1xuICAgIFwicmVhZFwiLCAvLyBSZWFkXG4gICAgXCJyZXNvbHZlS2V5ZnJhbWVzXCIsIC8vIFdyaXRlL1JlYWQvV3JpdGUvUmVhZFxuICAgIFwidXBkYXRlXCIsIC8vIENvbXB1dGVcbiAgICBcInByZVJlbmRlclwiLCAvLyBDb21wdXRlXG4gICAgXCJyZW5kZXJcIiwgLy8gV3JpdGVcbiAgICBcInBvc3RSZW5kZXJcIiwgLy8gQ29tcHV0ZVxuXTtcbmNvbnN0IG1heEVsYXBzZWQgPSA0MDtcbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlckJhdGNoZXIoc2NoZWR1bGVOZXh0QmF0Y2gsIGFsbG93S2VlcEFsaXZlKSB7XG4gICAgbGV0IHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xuICAgIGxldCB1c2VEZWZhdWx0RWxhcHNlZCA9IHRydWU7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGRlbHRhOiAwLjAsXG4gICAgICAgIHRpbWVzdGFtcDogMC4wLFxuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgZmxhZ1J1bk5leHRGcmFtZSA9ICgpID0+IChydW5OZXh0RnJhbWUgPSB0cnVlKTtcbiAgICBjb25zdCBzdGVwcyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICBhY2Nba2V5XSA9IGNyZWF0ZVJlbmRlclN0ZXAoZmxhZ1J1bk5leHRGcmFtZSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIGNvbnN0IHsgcmVhZCwgcmVzb2x2ZUtleWZyYW1lcywgdXBkYXRlLCBwcmVSZW5kZXIsIHJlbmRlciwgcG9zdFJlbmRlciB9ID0gc3RlcHM7XG4gICAgY29uc3QgcHJvY2Vzc0JhdGNoID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBNb3Rpb25HbG9iYWxDb25maWcudXNlTWFudWFsVGltaW5nXG4gICAgICAgICAgICA/IHN0YXRlLnRpbWVzdGFtcFxuICAgICAgICAgICAgOiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcnVuTmV4dEZyYW1lID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmRlbHRhID0gdXNlRGVmYXVsdEVsYXBzZWRcbiAgICAgICAgICAgID8gMTAwMCAvIDYwXG4gICAgICAgICAgICA6IE1hdGgubWF4KE1hdGgubWluKHRpbWVzdGFtcCAtIHN0YXRlLnRpbWVzdGFtcCwgbWF4RWxhcHNlZCksIDEpO1xuICAgICAgICBzdGF0ZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIHN0YXRlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgIC8vIFVucm9sbGVkIHJlbmRlciBsb29wIGZvciBiZXR0ZXIgcGVyLWZyYW1lIHBlcmZvcm1hbmNlXG4gICAgICAgIHJlYWQucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHJlc29sdmVLZXlmcmFtZXMucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZS5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgcHJlUmVuZGVyLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICByZW5kZXIucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHBvc3RSZW5kZXIucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAocnVuTmV4dEZyYW1lICYmIGFsbG93S2VlcEFsaXZlKSB7XG4gICAgICAgICAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2NoZWR1bGVOZXh0QmF0Y2gocHJvY2Vzc0JhdGNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2FrZSA9ICgpID0+IHtcbiAgICAgICAgcnVuTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXN0YXRlLmlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgc2NoZWR1bGVOZXh0QmF0Y2gocHJvY2Vzc0JhdGNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2NoZWR1bGUgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2tleV07XG4gICAgICAgIGFjY1trZXldID0gKHByb2Nlc3MsIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFydW5OZXh0RnJhbWUpXG4gICAgICAgICAgICAgICAgd2FrZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAuc2NoZWR1bGUocHJvY2Vzcywga2VlcEFsaXZlLCBpbW1lZGlhdGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBjYW5jZWwgPSAocHJvY2VzcykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0ZXBzW3N0ZXBzT3JkZXJbaV1dLmNhbmNlbChwcm9jZXNzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgc2NoZWR1bGUsIGNhbmNlbCwgc3RhdGUsIHN0ZXBzIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlbmRlckJhdGNoZXIsIHN0ZXBzT3JkZXIgfTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlUmVuZGVyQmF0Y2hlciB9IGZyb20gJy4vYmF0Y2hlci5tanMnO1xuXG5jb25zdCB7IHNjaGVkdWxlOiBmcmFtZSwgY2FuY2VsOiBjYW5jZWxGcmFtZSwgc3RhdGU6IGZyYW1lRGF0YSwgc3RlcHM6IGZyYW1lU3RlcHMsIH0gPSBjcmVhdGVSZW5kZXJCYXRjaGVyKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgIT09IFwidW5kZWZpbmVkXCIgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBub29wLCB0cnVlKTtcblxuZXhwb3J0IHsgY2FuY2VsRnJhbWUsIGZyYW1lLCBmcmFtZURhdGEsIGZyYW1lU3RlcHMgfTtcbiIsImltcG9ydCB7IE1vdGlvbkdsb2JhbENvbmZpZyB9IGZyb20gJy4uL3V0aWxzL0dsb2JhbENvbmZpZy5tanMnO1xuaW1wb3J0IHsgZnJhbWVEYXRhIH0gZnJvbSAnLi9mcmFtZS5tanMnO1xuXG5sZXQgbm93O1xuZnVuY3Rpb24gY2xlYXJUaW1lKCkge1xuICAgIG5vdyA9IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogQW4gZXZlbnRsb29wLXN5bmNocm9ub3VzIGFsdGVybmF0aXZlIHRvIHBlcmZvcm1hbmNlLm5vdygpLlxuICpcbiAqIEVuc3VyZXMgdGhhdCB0aW1lIG1lYXN1cmVtZW50cyByZW1haW4gY29uc2lzdGVudCB3aXRoaW4gYSBzeW5jaHJvbm91cyBjb250ZXh0LlxuICogVXN1YWxseSBjYWxsaW5nIHBlcmZvcm1hbmNlLm5vdygpIHR3aWNlIHdpdGhpbiB0aGUgc2FtZSBzeW5jaHJvbm91cyBjb250ZXh0XG4gKiB3aWxsIHJldHVybiBkaWZmZXJlbnQgdmFsdWVzIHdoaWNoIGlzbid0IHVzZWZ1bCBmb3IgYW5pbWF0aW9ucyB3aGVuIHdlJ3JlIHVzdWFsbHlcbiAqIHRyeWluZyB0byBzeW5jIGFuaW1hdGlvbnMgdG8gdGhlIHNhbWUgZnJhbWUuXG4gKi9cbmNvbnN0IHRpbWUgPSB7XG4gICAgbm93OiAoKSA9PiB7XG4gICAgICAgIGlmIChub3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGltZS5zZXQoZnJhbWVEYXRhLmlzUHJvY2Vzc2luZyB8fCBNb3Rpb25HbG9iYWxDb25maWcudXNlTWFudWFsVGltaW5nXG4gICAgICAgICAgICAgICAgPyBmcmFtZURhdGEudGltZXN0YW1wXG4gICAgICAgICAgICAgICAgOiBwZXJmb3JtYW5jZS5ub3coKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vdztcbiAgICB9LFxuICAgIHNldDogKG5ld1RpbWUpID0+IHtcbiAgICAgICAgbm93ID0gbmV3VGltZTtcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYXJUaW1lKTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgdGltZSB9O1xuIiwiZnVuY3Rpb24gYWRkVW5pcXVlSXRlbShhcnIsIGl0ZW0pIHtcbiAgICBpZiAoYXJyLmluZGV4T2YoaXRlbSkgPT09IC0xKVxuICAgICAgICBhcnIucHVzaChpdGVtKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICBpZiAoaW5kZXggPiAtMSlcbiAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XG59XG4vLyBBZGFwdGVkIGZyb20gYXJyYXktbW92ZVxuZnVuY3Rpb24gbW92ZUl0ZW0oWy4uLmFycl0sIGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBmcm9tSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIGZyb21JbmRleCA6IGZyb21JbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA+PSAwICYmIHN0YXJ0SW5kZXggPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdG9JbmRleCA8IDAgPyBhcnIubGVuZ3RoICsgdG9JbmRleCA6IHRvSW5kZXg7XG4gICAgICAgIGNvbnN0IFtpdGVtXSA9IGFyci5zcGxpY2UoZnJvbUluZGV4LCAxKTtcbiAgICAgICAgYXJyLnNwbGljZShlbmRJbmRleCwgMCwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCB7IGFkZFVuaXF1ZUl0ZW0sIG1vdmVJdGVtLCByZW1vdmVJdGVtIH07XG4iLCJpbXBvcnQgeyBhZGRVbmlxdWVJdGVtLCByZW1vdmVJdGVtIH0gZnJvbSAnLi9hcnJheS5tanMnO1xuXG5jbGFzcyBTdWJzY3JpcHRpb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XG4gICAgfVxuICAgIGFkZChoYW5kbGVyKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHJlbW92ZUl0ZW0odGhpcy5zdWJzY3JpcHRpb25zLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgbm90aWZ5KGEsIGIsIGMpIHtcbiAgICAgICAgY29uc3QgbnVtU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgICAgIGlmICghbnVtU3Vic2NyaXB0aW9ucylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG51bVN1YnNjcmlwdGlvbnMgPT09IDEpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUncyBvbmx5IGEgc2luZ2xlIGhhbmRsZXIgd2UgY2FuIGp1c3QgY2FsbCBpdCB3aXRob3V0IGludm9raW5nIGEgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zWzBdKGEsIGIsIGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TdWJzY3JpcHRpb25zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBoYW5kbGVyIGV4aXN0cyBiZWZvcmUgZmlyaW5nIGFzIGl0J3MgcG9zc2libGVcbiAgICAgICAgICAgICAgICAgKiB0aGUgc3Vic2NyaXB0aW9ucyB3ZXJlIG1vZGlmaWVkIGR1cmluZyB0aGlzIGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5zdWJzY3JpcHRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIgJiYgaGFuZGxlcihhLCBiLCBjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGggPSAwO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9O1xuIiwiLypcbiAgQ29udmVydCB2ZWxvY2l0eSBpbnRvIHZlbG9jaXR5IHBlciBzZWNvbmRcblxuICBAcGFyYW0gW251bWJlcl06IFVuaXQgcGVyIGZyYW1lXG4gIEBwYXJhbSBbbnVtYmVyXTogRnJhbWUgZHVyYXRpb24gaW4gbXNcbiovXG5mdW5jdGlvbiB2ZWxvY2l0eVBlclNlY29uZCh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICAgIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMTAwMCAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuZXhwb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQgfTtcbiIsImltcG9ydCB7IHRpbWUgfSBmcm9tICcuLi9mcmFtZWxvb3Avc3luYy10aW1lLm1qcyc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzJztcbmltcG9ydCB7IHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAnLi4vdXRpbHMvdmVsb2NpdHktcGVyLXNlY29uZC5tanMnO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi91dGlscy93YXJuLW9uY2UubWpzJztcbmltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbi8qKlxuICogTWF4aW11bSB0aW1lIGJldHdlZW4gdGhlIHZhbHVlIG9mIHR3byBmcmFtZXMsIGJleW9uZCB3aGljaCB3ZVxuICogYXNzdW1lIHRoZSB2ZWxvY2l0eSBoYXMgc2luY2UgYmVlbiAwLlxuICovXG5jb25zdCBNQVhfVkVMT0NJVFlfREVMVEEgPSAzMDtcbmNvbnN0IGlzRmxvYXQgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG5jb25zdCBjb2xsZWN0TW90aW9uVmFsdWVzID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG4vKipcbiAqIGBNb3Rpb25WYWx1ZWAgaXMgdXNlZCB0byB0cmFjayB0aGUgc3RhdGUgYW5kIHZlbG9jaXR5IG9mIG1vdGlvbiB2YWx1ZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBNb3Rpb25WYWx1ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGluaXQgLSBUaGUgaW5pdGlhdGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIC0gIGB0cmFuc2Zvcm1lcmA6IEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGluY29taW5nIHZhbHVlcyB3aXRoLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGJ1aWxkIHN0ZXAgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgKiBXaGVuIE1vdGlvblZhbHVlcyBhcmUgcHJvdmlkZWQgdG8gbW90aW9uIGNvbXBvbmVudHMsIHdhcm4gaWYgdmVyc2lvbnMgYXJlIG1peGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIxMi4wLjZcIjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyB3aGV0aGVyIHRoaXMgdmFsdWUgY2FuIG91dHB1dCBhIHZlbG9jaXR5LiBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHRydWVcbiAgICAgICAgICogaWYgdGhlIHZhbHVlIGlzIG51bWVyaWNhbCwgYnV0IHdlIG1pZ2h0IGJlIGFibGUgdG8gd2lkZW4gdGhlIHNjb3BlIGhlcmUgYW5kIHN1cHBvcnRcbiAgICAgICAgICogb3RoZXIgdmFsdWUgdHlwZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5UcmFja1ZlbG9jaXR5ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGEgU3Vic2NyaXB0aW9uTWFuYWdlciBmb3IgZWFjaCBhY3RpdmUgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9ICh2LCByZW5kZXIgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9IHRpbWUubm93KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHVwZGF0aW5nIHRoZSB2YWx1ZSBkdXJpbmcgYW5vdGhlciBmcmFtZSBvciBldmVudGxvb3BcbiAgICAgICAgICAgICAqIHRoYW4gdGhlIHByZXZpb3VzIGZyYW1lLCB0aGVuIHRoZSB3ZSBzZXQgdGhlIHByZXZpb3VzIGZyYW1lIHZhbHVlXG4gICAgICAgICAgICAgKiB0byBjdXJyZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVkQXQgIT09IGN1cnJlbnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRQcmV2RnJhbWVWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50KHYpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHVwZGF0ZSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudCAhPT0gdGhpcy5wcmV2ICYmIHRoaXMuZXZlbnRzLmNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmNoYW5nZS5ub3RpZnkodGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIGlmIChyZW5kZXIgJiYgdGhpcy5ldmVudHMucmVuZGVyUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLnJlbmRlclJlcXVlc3Qubm90aWZ5KHRoaXMuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXRDdXJyZW50KGluaXQpO1xuICAgICAgICB0aGlzLm93bmVyID0gb3B0aW9ucy5vd25lcjtcbiAgICB9XG4gICAgc2V0Q3VycmVudChjdXJyZW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG4gICAgICAgIHRoaXMudXBkYXRlZEF0ID0gdGltZS5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9PT0gbnVsbCAmJiBjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGlzRmxvYXQodGhpcy5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRQcmV2RnJhbWVWYWx1ZShwcmV2RnJhbWVWYWx1ZSA9IHRoaXMuY3VycmVudCkge1xuICAgICAgICB0aGlzLnByZXZGcmFtZVZhbHVlID0gcHJldkZyYW1lVmFsdWU7XG4gICAgICAgIHRoaXMucHJldlVwZGF0ZWRBdCA9IHRoaXMudXBkYXRlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIG5vdGlmaWVkIHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgaXMgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEl0IHJldHVybnMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgd2lsbCBjYW5jZWwgdGhlIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIFdoZW4gY2FsbGluZyBgb25DaGFuZ2VgIGluc2lkZSBhIFJlYWN0IGNvbXBvbmVudCwgaXQgc2hvdWxkIGJlIHdyYXBwZWQgd2l0aCB0aGVcbiAgICAgKiBgdXNlRWZmZWN0YCBob29rLiBBcyBpdCByZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uLCB0aGlzIHNob3VsZCBiZSByZXR1cm5lZFxuICAgICAqIGZyb20gdGhlIGB1c2VFZmZlY3RgIGZ1bmN0aW9uIHRvIGVuc3VyZSB5b3UgZG9uJ3QgYWRkIGR1cGxpY2F0ZSBzdWJzY3JpYmVycy4uXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gICAgICogICBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IHkgPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqICAgY29uc3Qgb3BhY2l0eSA9IHVzZU1vdGlvblZhbHVlKDEpXG4gICAgICpcbiAgICAgKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICogICAgIGZ1bmN0aW9uIHVwZGF0ZU9wYWNpdHkoKSB7XG4gICAgICogICAgICAgY29uc3QgbWF4WFkgPSBNYXRoLm1heCh4LmdldCgpLCB5LmdldCgpKVxuICAgICAqICAgICAgIGNvbnN0IG5ld09wYWNpdHkgPSB0cmFuc2Zvcm0obWF4WFksIFswLCAxMDBdLCBbMSwgMF0pXG4gICAgICogICAgICAgb3BhY2l0eS5zZXQobmV3T3BhY2l0eSlcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWCA9IHgub24oXCJjaGFuZ2VcIiwgdXBkYXRlT3BhY2l0eSlcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVZID0geS5vbihcImNoYW5nZVwiLCB1cGRhdGVPcGFjaXR5KVxuICAgICAqXG4gICAgICogICAgIHJldHVybiAoKSA9PiB7XG4gICAgICogICAgICAgdW5zdWJzY3JpYmVYKClcbiAgICAgKiAgICAgICB1bnN1YnNjcmliZVkoKVxuICAgICAqICAgICB9XG4gICAgICogICB9LCBbXSlcbiAgICAgKlxuICAgICAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IHggfX0gLz5cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBvbkNoYW5nZShzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgd2Fybk9uY2UoZmFsc2UsIGB2YWx1ZS5vbkNoYW5nZShjYWxsYmFjaykgaXMgZGVwcmVjYXRlZC4gU3dpdGNoIHRvIHZhbHVlLm9uKFwiY2hhbmdlXCIsIGNhbGxiYWNrKS5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5vbihcImNoYW5nZVwiLCBzdWJzY3JpcHRpb24pO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdLmFkZChjYWxsYmFjayk7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiY2hhbmdlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIG5vIG1vcmUgY2hhbmdlIGxpc3RlbmVycyBieSB0aGUgc3RhcnRcbiAgICAgICAgICAgICAgICAgKiBvZiB0aGUgbmV4dCBmcmFtZSwgc3RvcCBhY3RpdmUgYW5pbWF0aW9ucy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmcmFtZS5yZWFkKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50cy5jaGFuZ2UuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfVxuICAgIGNsZWFyTGlzdGVuZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGV2ZW50TWFuYWdlcnMgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TWFuYWdlcnNdLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSBwYXNzaXZlIGVmZmVjdCB0byB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGF0dGFjaChwYXNzaXZlRWZmZWN0LCBzdG9wUGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QgPSBwYXNzaXZlRWZmZWN0O1xuICAgICAgICB0aGlzLnN0b3BQYXNzaXZlRWZmZWN0ID0gc3RvcFBhc3NpdmVFZmZlY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YXRlIG9mIHRoZSBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGNvbnN0IHggPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqIHguc2V0KDEwKVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGxhdGVzdCAtIExhdGVzdCB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHJlbmRlciAtIFdoZXRoZXIgdG8gbm90aWZ5IHJlbmRlciBzdWJzY3JpYmVycy4gRGVmYXVsdHMgdG8gYHRydWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2V0KHYsIHJlbmRlciA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFyZW5kZXIgfHwgIXRoaXMucGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkodiwgcmVuZGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFzc2l2ZUVmZmVjdCh2LCB0aGlzLnVwZGF0ZUFuZE5vdGlmeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0V2l0aFZlbG9jaXR5KHByZXYsIGN1cnJlbnQsIGRlbHRhKSB7XG4gICAgICAgIHRoaXMuc2V0KGN1cnJlbnQpO1xuICAgICAgICB0aGlzLnByZXYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJldkZyYW1lVmFsdWUgPSBwcmV2O1xuICAgICAgICB0aGlzLnByZXZVcGRhdGVkQXQgPSB0aGlzLnVwZGF0ZWRBdCAtIGRlbHRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0YXRlIG9mIHRoZSBgTW90aW9uVmFsdWVgLCBzdG9wcGluZyBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsXG4gICAgICogZWZmZWN0cywgYW5kIHJlc2V0cyB2ZWxvY2l0eSB0byBgMGAuXG4gICAgICovXG4gICAganVtcCh2LCBlbmRBbmltYXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYpO1xuICAgICAgICB0aGlzLnByZXYgPSB2O1xuICAgICAgICB0aGlzLnByZXZVcGRhdGVkQXQgPSB0aGlzLnByZXZGcmFtZVZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICBlbmRBbmltYXRpb24gJiYgdGhpcy5zdG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnN0b3BQYXNzaXZlRWZmZWN0KVxuICAgICAgICAgICAgdGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3Qgc3RhdGUgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQoKSB7XG4gICAgICAgIGlmIChjb2xsZWN0TW90aW9uVmFsdWVzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNvbGxlY3RNb3Rpb25WYWx1ZXMuY3VycmVudC5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXRQcmV2aW91cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJldjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBgTW90aW9uVmFsdWVgLiBSZXR1cm5zIGAwYCBpZiB0aGUgc3RhdGUgaXMgbm9uLW51bWVyaWNhbC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXRWZWxvY2l0eSgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lLm5vdygpO1xuICAgICAgICBpZiAoIXRoaXMuY2FuVHJhY2tWZWxvY2l0eSB8fFxuICAgICAgICAgICAgdGhpcy5wcmV2RnJhbWVWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICBjdXJyZW50VGltZSAtIHRoaXMudXBkYXRlZEF0ID4gTUFYX1ZFTE9DSVRZX0RFTFRBKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWx0YSA9IE1hdGgubWluKHRoaXMudXBkYXRlZEF0IC0gdGhpcy5wcmV2VXBkYXRlZEF0LCBNQVhfVkVMT0NJVFlfREVMVEEpO1xuICAgICAgICAvLyBDYXN0cyBiZWNhdXNlIG9mIHBhcnNlRmxvYXQncyBwb29yIHR5cGluZ1xuICAgICAgICByZXR1cm4gdmVsb2NpdHlQZXJTZWNvbmQocGFyc2VGbG9hdCh0aGlzLmN1cnJlbnQpIC1cbiAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5wcmV2RnJhbWVWYWx1ZSksIGRlbHRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGFuaW1hdGlvbiB0byBjb250cm9sIHRoaXMgYE1vdGlvblZhbHVlYC4gT25seSBvbmVcbiAgICAgKiBhbmltYXRpb24gY2FuIGRyaXZlIGEgYE1vdGlvblZhbHVlYCBhdCBvbmUgdGltZS5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIHZhbHVlLnN0YXJ0KClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gLSBBIGZ1bmN0aW9uIHRoYXQgc3RhcnRzIHRoZSBwcm92aWRlZCBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHN0YXJ0KHN0YXJ0QW5pbWF0aW9uKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24gPSBzdGFydEFuaW1hdGlvbihyZXNvbHZlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5hbmltYXRpb25TdGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmFuaW1hdGlvblN0YXJ0Lm5vdGlmeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cy5hbmltYXRpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNvbXBsZXRlLm5vdGlmeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhckFuaW1hdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgY3VycmVudGx5IGFjdGl2ZSBhbmltYXRpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uQ2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuYW5pbWF0aW9uQ2FuY2VsLm5vdGlmeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhpcyB2YWx1ZSBpcyBjdXJyZW50bHkgYW5pbWF0aW5nLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGlzQW5pbWF0aW5nKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgY2xlYXJBbmltYXRpb24oKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmFuaW1hdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbmQgY2xlYW4gdXAgc3Vic2NyaWJlcnMgdG8gdGhpcyBgTW90aW9uVmFsdWVgLlxuICAgICAqXG4gICAgICogVGhlIGBNb3Rpb25WYWx1ZWAgaG9va3MgbGlrZSBgdXNlTW90aW9uVmFsdWVgIGFuZCBgdXNlVHJhbnNmb3JtYCBhdXRvbWF0aWNhbGx5XG4gICAgICogaGFuZGxlIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHJldHVybmVkIGBNb3Rpb25WYWx1ZWAsIHNvIHRoaXMgbWV0aG9kIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIHlvdSd2ZSBtYW51YWxseVxuICAgICAqIGNyZWF0ZWQgYSBgTW90aW9uVmFsdWVgIHZpYSB0aGUgYG1vdGlvblZhbHVlYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNsZWFyTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gbW90aW9uVmFsdWUoaW5pdCwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTW90aW9uVmFsdWUoaW5pdCwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IE1vdGlvblZhbHVlLCBjb2xsZWN0TW90aW9uVmFsdWVzLCBtb3Rpb25WYWx1ZSB9O1xuIiwiaW1wb3J0IHsgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyB9IGZyb20gJy4uLy4uL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzJztcbmltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvaW5kZXgubWpzJztcbmltcG9ydCB7IHJlc29sdmVWYXJpYW50IH0gZnJvbSAnLi9yZXNvbHZlLWR5bmFtaWMtdmFyaWFudHMubWpzJztcblxuLyoqXG4gKiBTZXQgVmlzdWFsRWxlbWVudCdzIE1vdGlvblZhbHVlLCBjcmVhdGluZyBhIG5ldyBNb3Rpb25WYWx1ZSBmb3IgaXQgaWZcbiAqIGl0IGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmlzdWFsRWxlbWVudC5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KS5zZXQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIGxldCB7IHRyYW5zaXRpb25FbmQgPSB7fSwgdHJhbnNpdGlvbiA9IHt9LCAuLi50YXJnZXQgfSA9IHJlc29sdmVkIHx8IHt9O1xuICAgIHRhcmdldCA9IHsgLi4udGFyZ2V0LCAuLi50cmFuc2l0aW9uRW5kIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXRba2V5XSk7XG4gICAgICAgIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgc2V0VGFyZ2V0IH07XG4iLCJjb25zdCBpc01vdGlvblZhbHVlID0gKHZhbHVlKSA9PiBCb29sZWFuKHZhbHVlICYmIHZhbHVlLmdldFZlbG9jaXR5KTtcblxuZXhwb3J0IHsgaXNNb3Rpb25WYWx1ZSB9O1xuIiwiaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuXG5mdW5jdGlvbiBpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKGlzTW90aW9uVmFsdWUodmFsdWUpICYmIHZhbHVlLmFkZCk7XG59XG5cbmV4cG9ydCB7IGlzV2lsbENoYW5nZU1vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyBpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSB9IGZyb20gJy4vaXMubWpzJztcblxuZnVuY3Rpb24gYWRkVmFsdWVUb1dpbGxDaGFuZ2UodmlzdWFsRWxlbWVudCwga2V5KSB7XG4gICAgY29uc3Qgd2lsbENoYW5nZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJ3aWxsQ2hhbmdlXCIpO1xuICAgIC8qKlxuICAgICAqIEl0IGNvdWxkIGJlIHRoYXQgYSB1c2VyIGhhcyBzZXQgd2lsbENoYW5nZSB0byBhIHJlZ3VsYXIgTW90aW9uVmFsdWUsXG4gICAgICogaW4gd2hpY2ggY2FzZSB3ZSBjYW4ndCBhZGQgdGhlIHZhbHVlIHRvIGl0LlxuICAgICAqL1xuICAgIGlmIChpc1dpbGxDaGFuZ2VNb3Rpb25WYWx1ZSh3aWxsQ2hhbmdlKSkge1xuICAgICAgICByZXR1cm4gd2lsbENoYW5nZS5hZGQoa2V5KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGFkZFZhbHVlVG9XaWxsQ2hhbmdlIH07XG4iLCIvKipcbiAqIENvbnZlcnQgY2FtZWxDYXNlIHRvIGRhc2gtY2FzZSBwcm9wZXJ0aWVzLlxuICovXG5jb25zdCBjYW1lbFRvRGFzaCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9ndSwgXCIkMS0kMlwiKS50b0xvd2VyQ2FzZSgpO1xuXG5leHBvcnQgeyBjYW1lbFRvRGFzaCB9O1xuIiwiaW1wb3J0IHsgY2FtZWxUb0Rhc2ggfSBmcm9tICcuLi8uLi9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzJztcblxuY29uc3Qgb3B0aW1pemVkQXBwZWFyRGF0YUlkID0gXCJmcmFtZXJBcHBlYXJJZFwiO1xuY29uc3Qgb3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZSA9IFwiZGF0YS1cIiArIGNhbWVsVG9EYXNoKG9wdGltaXplZEFwcGVhckRhdGFJZCk7XG5cbmV4cG9ydCB7IG9wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGUsIG9wdGltaXplZEFwcGVhckRhdGFJZCB9O1xuIiwiaW1wb3J0IHsgb3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZSB9IGZyb20gJy4vZGF0YS1pZC5tanMnO1xuXG5mdW5jdGlvbiBnZXRPcHRpbWlzZWRBcHBlYXJJZCh2aXN1YWxFbGVtZW50KSB7XG4gICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQucHJvcHNbb3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZV07XG59XG5cbmV4cG9ydCB7IGdldE9wdGltaXNlZEFwcGVhcklkIH07XG4iLCJjb25zdCBpbnN0YW50QW5pbWF0aW9uU3RhdGUgPSB7XG4gICAgY3VycmVudDogZmFsc2UsXG59O1xuXG5leHBvcnQgeyBpbnN0YW50QW5pbWF0aW9uU3RhdGUgfTtcbiIsImltcG9ydCB7IG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuXG4vKlxuICBCZXppZXIgZnVuY3Rpb24gZ2VuZXJhdG9yXG4gIFRoaXMgaGFzIGJlZW4gbW9kaWZpZWQgZnJvbSBHYcOrdGFuIFJlbmF1ZGVhdSdzIEJlemllckVhc2luZ1xuICBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmcvYmxvYi9tYXN0ZXIvc3JjL2luZGV4LmpzXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gIFxuICBJJ3ZlIHJlbW92ZWQgdGhlIG5ld3RvblJhcGhzb25JdGVyYXRlIGFsZ28gYmVjYXVzZSBpbiBiZW5jaG1hcmtpbmcgaXRcbiAgd2Fzbid0IG5vdGljaWFibHkgZmFzdGVyIHRoYW4gYmluYXJ5U3ViZGl2aXNpb24sIGluZGVlZCByZW1vdmluZyBpdFxuICB1c3VhbGx5IGltcHJvdmVkIHRpbWVzLCBkZXBlbmRpbmcgb24gdGhlIGN1cnZlLlxuICBJIGFsc28gcmVtb3ZlZCB0aGUgbG9va3VwIHRhYmxlLCBhcyBmb3IgdGhlIGFkZGVkIGJ1bmRsZSBzaXplIGFuZCBsb29wIHdlJ3JlXG4gIG9ubHkgY3V0dGluZyB+NCBvciBzbyBzdWJkaXZpc2lvbiBpdGVyYXRpb25zLiBJIGJ1bXBlZCB0aGUgbWF4IGl0ZXJhdGlvbnMgdXBcbiAgdG8gMTIgdG8gY29tcGVuc2F0ZSBhbmQgdGhpcyBzdGlsbCB0ZW5kZWQgdG8gYmUgZmFzdGVyIGZvciBubyBwZXJjZWl2YWJsZVxuICBsb3NzIGluIGFjY3VyYWN5LlxuICBVc2FnZVxuICAgIGNvbnN0IGVhc2VPdXQgPSBjdWJpY0JlemllciguMTcsLjY3LC44MywuNjcpO1xuICAgIGNvbnN0IHggPSBlYXNlT3V0KDAuNSk7IC8vIHJldHVybnMgMC42MjcuLi5cbiovXG4vLyBSZXR1cm5zIHgodCkgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgeSh0KSBnaXZlbiB0LCB5MSwgYW5kIHkyLlxuY29uc3QgY2FsY0JlemllciA9ICh0LCBhMSwgYTIpID0+ICgoKDEuMCAtIDMuMCAqIGEyICsgMy4wICogYTEpICogdCArICgzLjAgKiBhMiAtIDYuMCAqIGExKSkgKiB0ICsgMy4wICogYTEpICpcbiAgICB0O1xuY29uc3Qgc3ViZGl2aXNpb25QcmVjaXNpb24gPSAwLjAwMDAwMDE7XG5jb25zdCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMgPSAxMjtcbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSh4LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kLCBtWDEsIG1YMikge1xuICAgIGxldCBjdXJyZW50WDtcbiAgICBsZXQgY3VycmVudFQ7XG4gICAgbGV0IGkgPSAwO1xuICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBsb3dlckJvdW5kICsgKHVwcGVyQm91bmQgLSBsb3dlckJvdW5kKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSB4O1xuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICAgIHVwcGVyQm91bmQgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvd2VyQm91bmQgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IHN1YmRpdmlzaW9uUHJlY2lzaW9uICYmXG4gICAgICAgICsraSA8IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xufVxuZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGxpbmVhciBncmFkaWVudCwgcmV0dXJuIGxpbmVhciBlYXNpbmdcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpXG4gICAgICAgIHJldHVybiBub29wO1xuICAgIGNvbnN0IGdldFRGb3JYID0gKGFYKSA9PiBiaW5hcnlTdWJkaXZpZGUoYVgsIDAsIDEsIG1YMSwgbVgyKTtcbiAgICAvLyBJZiBhbmltYXRpb24gaXMgYXQgc3RhcnQvZW5kLCByZXR1cm4gdCB3aXRob3V0IGVhc2luZ1xuICAgIHJldHVybiAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IGNhbGNCZXppZXIoZ2V0VEZvclgodCksIG1ZMSwgbVkyKTtcbn1cblxuZXhwb3J0IHsgY3ViaWNCZXppZXIgfTtcbiIsIi8vIEFjY2VwdHMgYW4gZWFzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9uZSB0aGF0IG91dHB1dHMgbWlycm9yZWQgdmFsdWVzIGZvclxuLy8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBhbmltYXRpb24uIFR1cm5zIGVhc2VJbiBpbnRvIGVhc2VJbk91dC5cbmNvbnN0IG1pcnJvckVhc2luZyA9IChlYXNpbmcpID0+IChwKSA9PiBwIDw9IDAuNSA/IGVhc2luZygyICogcCkgLyAyIDogKDIgLSBlYXNpbmcoMiAqICgxIC0gcCkpKSAvIDI7XG5cbmV4cG9ydCB7IG1pcnJvckVhc2luZyB9O1xuIiwiLy8gQWNjZXB0cyBhbiBlYXNpbmcgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb25lIHRoYXQgb3V0cHV0cyByZXZlcnNlZCB2YWx1ZXMuXG4vLyBUdXJucyBlYXNlSW4gaW50byBlYXNlT3V0LlxuY29uc3QgcmV2ZXJzZUVhc2luZyA9IChlYXNpbmcpID0+IChwKSA9PiAxIC0gZWFzaW5nKDEgLSBwKTtcblxuZXhwb3J0IHsgcmV2ZXJzZUVhc2luZyB9O1xuIiwiaW1wb3J0IHsgY3ViaWNCZXppZXIgfSBmcm9tICcuL2N1YmljLWJlemllci5tanMnO1xuaW1wb3J0IHsgbWlycm9yRWFzaW5nIH0gZnJvbSAnLi9tb2RpZmllcnMvbWlycm9yLm1qcyc7XG5pbXBvcnQgeyByZXZlcnNlRWFzaW5nIH0gZnJvbSAnLi9tb2RpZmllcnMvcmV2ZXJzZS5tanMnO1xuXG5jb25zdCBiYWNrT3V0ID0gLypAX19QVVJFX18qLyBjdWJpY0JlemllcigwLjMzLCAxLjUzLCAwLjY5LCAwLjk5KTtcbmNvbnN0IGJhY2tJbiA9IC8qQF9fUFVSRV9fKi8gcmV2ZXJzZUVhc2luZyhiYWNrT3V0KTtcbmNvbnN0IGJhY2tJbk91dCA9IC8qQF9fUFVSRV9fKi8gbWlycm9yRWFzaW5nKGJhY2tJbik7XG5cbmV4cG9ydCB7IGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0IH07XG4iLCJpbXBvcnQgeyBiYWNrSW4gfSBmcm9tICcuL2JhY2subWpzJztcblxuY29uc3QgYW50aWNpcGF0ZSA9IChwKSA9PiAocCAqPSAyKSA8IDEgPyAwLjUgKiBiYWNrSW4ocCkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcblxuZXhwb3J0IHsgYW50aWNpcGF0ZSB9O1xuIiwiaW1wb3J0IHsgbWlycm9yRWFzaW5nIH0gZnJvbSAnLi9tb2RpZmllcnMvbWlycm9yLm1qcyc7XG5pbXBvcnQgeyByZXZlcnNlRWFzaW5nIH0gZnJvbSAnLi9tb2RpZmllcnMvcmV2ZXJzZS5tanMnO1xuXG5jb25zdCBjaXJjSW4gPSAocCkgPT4gMSAtIE1hdGguc2luKE1hdGguYWNvcyhwKSk7XG5jb25zdCBjaXJjT3V0ID0gcmV2ZXJzZUVhc2luZyhjaXJjSW4pO1xuY29uc3QgY2lyY0luT3V0ID0gbWlycm9yRWFzaW5nKGNpcmNJbik7XG5cbmV4cG9ydCB7IGNpcmNJbiwgY2lyY0luT3V0LCBjaXJjT3V0IH07XG4iLCIvKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIHplcm8gdmFsdWUgc3RyaW5nIGxpa2UgXCIwcHhcIiBvciBcIjAlXCJcbiAqL1xuY29uc3QgaXNaZXJvVmFsdWVTdHJpbmcgPSAodikgPT4gL14wW14uXFxzXSskL3UudGVzdCh2KTtcblxuZXhwb3J0IHsgaXNaZXJvVmFsdWVTdHJpbmcgfTtcbiIsImltcG9ydCB7IGlzWmVyb1ZhbHVlU3RyaW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtemVyby12YWx1ZS1zdHJpbmcubWpzJztcblxuZnVuY3Rpb24gaXNOb25lKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJub25lXCIgfHwgdmFsdWUgPT09IFwiMFwiIHx8IGlzWmVyb1ZhbHVlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgaXNOb25lIH07XG4iLCJjb25zdCBjbGFtcCA9IChtaW4sIG1heCwgdikgPT4ge1xuICAgIGlmICh2ID4gbWF4KVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIGlmICh2IDwgbWluKVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIHJldHVybiB2O1xufTtcblxuZXhwb3J0IHsgY2xhbXAgfTtcbiIsImltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2xhbXAubWpzJztcblxuY29uc3QgbnVtYmVyID0ge1xuICAgIHRlc3Q6ICh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIixcbiAgICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiB2LFxufTtcbmNvbnN0IGFscGhhID0ge1xuICAgIC4uLm51bWJlcixcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiBjbGFtcCgwLCAxLCB2KSxcbn07XG5jb25zdCBzY2FsZSA9IHtcbiAgICAuLi5udW1iZXIsXG4gICAgZGVmYXVsdDogMSxcbn07XG5cbmV4cG9ydCB7IGFscGhhLCBudW1iZXIsIHNjYWxlIH07XG4iLCIvLyBJZiB0aGlzIG51bWJlciBpcyBhIGRlY2ltYWwsIG1ha2UgaXQganVzdCBmaXZlIGRlY2ltYWwgcGxhY2VzXG4vLyB0byBhdm9pZCBleHBvbmVudHNcbmNvbnN0IHNhbml0aXplID0gKHYpID0+IE1hdGgucm91bmQodiAqIDEwMDAwMCkgLyAxMDAwMDA7XG5cbmV4cG9ydCB7IHNhbml0aXplIH07XG4iLCJjb25zdCBmbG9hdFJlZ2V4ID0gLy0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKS9ndTtcblxuZXhwb3J0IHsgZmxvYXRSZWdleCB9O1xuIiwiZnVuY3Rpb24gaXNOdWxsaXNoKHYpIHtcbiAgICByZXR1cm4gdiA9PSBudWxsO1xufVxuXG5leHBvcnQgeyBpc051bGxpc2ggfTtcbiIsImNvbnN0IHNpbmdsZUNvbG9yUmVnZXggPSAvXig/OiNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCkpJC9pdTtcblxuZXhwb3J0IHsgc2luZ2xlQ29sb3JSZWdleCB9O1xuIiwiaW1wb3J0IHsgZmxvYXRSZWdleCB9IGZyb20gJy4uL3V0aWxzL2Zsb2F0LXJlZ2V4Lm1qcyc7XG5pbXBvcnQgeyBpc051bGxpc2ggfSBmcm9tICcuLi91dGlscy9pcy1udWxsaXNoLm1qcyc7XG5pbXBvcnQgeyBzaW5nbGVDb2xvclJlZ2V4IH0gZnJvbSAnLi4vdXRpbHMvc2luZ2xlLWNvbG9yLXJlZ2V4Lm1qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSBjb2xvciwgaWUgcmdiYSgwLDAsMCwwKSBvciAjMDAwLFxuICogYnV0IGZhbHNlIGlmIGEgbnVtYmVyIG9yIG11bHRpcGxlIGNvbG9yc1xuICovXG5jb25zdCBpc0NvbG9yU3RyaW5nID0gKHR5cGUsIHRlc3RQcm9wKSA9PiAodikgPT4ge1xuICAgIHJldHVybiBCb29sZWFuKCh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICBzaW5nbGVDb2xvclJlZ2V4LnRlc3QodikgJiZcbiAgICAgICAgdi5zdGFydHNXaXRoKHR5cGUpKSB8fFxuICAgICAgICAodGVzdFByb3AgJiZcbiAgICAgICAgICAgICFpc051bGxpc2godikgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCB0ZXN0UHJvcCkpKTtcbn07XG5jb25zdCBzcGxpdENvbG9yID0gKGFOYW1lLCBiTmFtZSwgY05hbWUpID0+ICh2KSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2ICE9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gdjtcbiAgICBjb25zdCBbYSwgYiwgYywgYWxwaGFdID0gdi5tYXRjaChmbG9hdFJlZ2V4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbYU5hbWVdOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICBbYk5hbWVdOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICBbY05hbWVdOiBwYXJzZUZsb2F0KGMpLFxuICAgICAgICBhbHBoYTogYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcnNlRmxvYXQoYWxwaGEpIDogMSxcbiAgICB9O1xufTtcblxuZXhwb3J0IHsgaXNDb2xvclN0cmluZywgc3BsaXRDb2xvciB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jbGFtcC5tanMnO1xuaW1wb3J0IHsgYWxwaGEsIG51bWJlciB9IGZyb20gJy4uL251bWJlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHNhbml0aXplIH0gZnJvbSAnLi4vdXRpbHMvc2FuaXRpemUubWpzJztcbmltcG9ydCB7IGlzQ29sb3JTdHJpbmcsIHNwbGl0Q29sb3IgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNvbnN0IGNsYW1wUmdiVW5pdCA9ICh2KSA9PiBjbGFtcCgwLCAyNTUsIHYpO1xuY29uc3QgcmdiVW5pdCA9IHtcbiAgICAuLi5udW1iZXIsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gTWF0aC5yb3VuZChjbGFtcFJnYlVuaXQodikpLFxufTtcbmNvbnN0IHJnYmEgPSB7XG4gICAgdGVzdDogLypAX19QVVJFX18qLyBpc0NvbG9yU3RyaW5nKFwicmdiXCIsIFwicmVkXCIpLFxuICAgIHBhcnNlOiAvKkBfX1BVUkVfXyovIHNwbGl0Q29sb3IoXCJyZWRcIiwgXCJncmVlblwiLCBcImJsdWVcIiksXG4gICAgdHJhbnNmb3JtOiAoeyByZWQsIGdyZWVuLCBibHVlLCBhbHBoYTogYWxwaGEkMSA9IDEgfSkgPT4gXCJyZ2JhKFwiICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0ocmVkKSArXG4gICAgICAgIFwiLCBcIiArXG4gICAgICAgIHJnYlVuaXQudHJhbnNmb3JtKGdyZWVuKSArXG4gICAgICAgIFwiLCBcIiArXG4gICAgICAgIHJnYlVuaXQudHJhbnNmb3JtKGJsdWUpICtcbiAgICAgICAgXCIsIFwiICtcbiAgICAgICAgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArXG4gICAgICAgIFwiKVwiLFxufTtcblxuZXhwb3J0IHsgcmdiVW5pdCwgcmdiYSB9O1xuIiwiaW1wb3J0IHsgcmdiYSB9IGZyb20gJy4vcmdiYS5tanMnO1xuaW1wb3J0IHsgaXNDb2xvclN0cmluZyB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuZnVuY3Rpb24gcGFyc2VIZXgodikge1xuICAgIGxldCByID0gXCJcIjtcbiAgICBsZXQgZyA9IFwiXCI7XG4gICAgbGV0IGIgPSBcIlwiO1xuICAgIGxldCBhID0gXCJcIjtcbiAgICAvLyBJZiB3ZSBoYXZlIDYgY2hhcmFjdGVycywgaWUgI0ZGMDAwMFxuICAgIGlmICh2Lmxlbmd0aCA+IDUpIHtcbiAgICAgICAgciA9IHYuc3Vic3RyaW5nKDEsIDMpO1xuICAgICAgICBnID0gdi5zdWJzdHJpbmcoMywgNSk7XG4gICAgICAgIGIgPSB2LnN1YnN0cmluZyg1LCA3KTtcbiAgICAgICAgYSA9IHYuc3Vic3RyaW5nKDcsIDkpO1xuICAgICAgICAvLyBPciB3ZSBoYXZlIDMgY2hhcmFjdGVycywgaWUgI0YwMFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgciA9IHYuc3Vic3RyaW5nKDEsIDIpO1xuICAgICAgICBnID0gdi5zdWJzdHJpbmcoMiwgMyk7XG4gICAgICAgIGIgPSB2LnN1YnN0cmluZygzLCA0KTtcbiAgICAgICAgYSA9IHYuc3Vic3RyaW5nKDQsIDUpO1xuICAgICAgICByICs9IHI7XG4gICAgICAgIGcgKz0gZztcbiAgICAgICAgYiArPSBiO1xuICAgICAgICBhICs9IGE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZDogcGFyc2VJbnQociwgMTYpLFxuICAgICAgICBncmVlbjogcGFyc2VJbnQoZywgMTYpLFxuICAgICAgICBibHVlOiBwYXJzZUludChiLCAxNiksXG4gICAgICAgIGFscGhhOiBhID8gcGFyc2VJbnQoYSwgMTYpIC8gMjU1IDogMSxcbiAgICB9O1xufVxuY29uc3QgaGV4ID0ge1xuICAgIHRlc3Q6IC8qQF9fUFVSRV9fKi8gaXNDb2xvclN0cmluZyhcIiNcIiksXG4gICAgcGFyc2U6IHBhcnNlSGV4LFxuICAgIHRyYW5zZm9ybTogcmdiYS50cmFuc2Zvcm0sXG59O1xuXG5leHBvcnQgeyBoZXggfTtcbiIsImNvbnN0IGNyZWF0ZVVuaXRUeXBlID0gKHVuaXQpID0+ICh7XG4gICAgdGVzdDogKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdChcIiBcIikubGVuZ3RoID09PSAxLFxuICAgIHBhcnNlOiBwYXJzZUZsb2F0LFxuICAgIHRyYW5zZm9ybTogKHYpID0+IGAke3Z9JHt1bml0fWAsXG59KTtcbmNvbnN0IGRlZ3JlZXMgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVVuaXRUeXBlKFwiZGVnXCIpO1xuY29uc3QgcGVyY2VudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCIlXCIpO1xuY29uc3QgcHggPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVVuaXRUeXBlKFwicHhcIik7XG5jb25zdCB2aCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCJ2aFwiKTtcbmNvbnN0IHZ3ID0gLypAX19QVVJFX18qLyBjcmVhdGVVbml0VHlwZShcInZ3XCIpO1xuY29uc3QgcHJvZ3Jlc3NQZXJjZW50YWdlID0ge1xuICAgIC4uLnBlcmNlbnQsXG4gICAgcGFyc2U6ICh2KSA9PiBwZXJjZW50LnBhcnNlKHYpIC8gMTAwLFxuICAgIHRyYW5zZm9ybTogKHYpID0+IHBlcmNlbnQudHJhbnNmb3JtKHYgKiAxMDApLFxufTtcblxuZXhwb3J0IHsgZGVncmVlcywgcGVyY2VudCwgcHJvZ3Jlc3NQZXJjZW50YWdlLCBweCwgdmgsIHZ3IH07XG4iLCJpbXBvcnQgeyBhbHBoYSB9IGZyb20gJy4uL251bWJlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHBlcmNlbnQgfSBmcm9tICcuLi9udW1iZXJzL3VuaXRzLm1qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3Nhbml0aXplLm1qcyc7XG5pbXBvcnQgeyBpc0NvbG9yU3RyaW5nLCBzcGxpdENvbG9yIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5jb25zdCBoc2xhID0ge1xuICAgIHRlc3Q6IC8qQF9fUFVSRV9fKi8gaXNDb2xvclN0cmluZyhcImhzbFwiLCBcImh1ZVwiKSxcbiAgICBwYXJzZTogLypAX19QVVJFX18qLyBzcGxpdENvbG9yKFwiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiKSxcbiAgICB0cmFuc2Zvcm06ICh7IGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYTogYWxwaGEkMSA9IDEgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKFwiaHNsYShcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGh1ZSkgK1xuICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKHNhdHVyYXRpb24pKSArXG4gICAgICAgICAgICBcIiwgXCIgK1xuICAgICAgICAgICAgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUobGlnaHRuZXNzKSkgK1xuICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgK1xuICAgICAgICAgICAgXCIpXCIpO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBoc2xhIH07XG4iLCJpbXBvcnQgeyBoZXggfSBmcm9tICcuL2hleC5tanMnO1xuaW1wb3J0IHsgaHNsYSB9IGZyb20gJy4vaHNsYS5tanMnO1xuaW1wb3J0IHsgcmdiYSB9IGZyb20gJy4vcmdiYS5tanMnO1xuXG5jb25zdCBjb2xvciA9IHtcbiAgICB0ZXN0OiAodikgPT4gcmdiYS50ZXN0KHYpIHx8IGhleC50ZXN0KHYpIHx8IGhzbGEudGVzdCh2KSxcbiAgICBwYXJzZTogKHYpID0+IHtcbiAgICAgICAgaWYgKHJnYmEudGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJnYmEucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHNsYS50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHNsYS5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zZm9ybTogKHYpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHZcbiAgICAgICAgICAgIDogdi5oYXNPd25Qcm9wZXJ0eShcInJlZFwiKVxuICAgICAgICAgICAgICAgID8gcmdiYS50cmFuc2Zvcm0odilcbiAgICAgICAgICAgICAgICA6IGhzbGEudHJhbnNmb3JtKHYpO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBjb2xvciB9O1xuIiwiY29uc3QgY29sb3JSZWdleCA9IC8oPzojW1xcZGEtZl17Myw4fXwoPzpyZ2J8aHNsKWE/XFwoKD86LT9bXFxkLl0rJT9bLFxcc10rKXsyfS0/W1xcZC5dKyU/XFxzKig/OlssL11cXHMqKT8oPzpcXGJcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspPyU/XFwpKS9naXU7XG5cbmV4cG9ydCB7IGNvbG9yUmVnZXggfTtcbiIsImltcG9ydCB7IGNvbG9yIH0gZnJvbSAnLi4vY29sb3IvaW5kZXgubWpzJztcbmltcG9ydCB7IGNvbG9yUmVnZXggfSBmcm9tICcuLi91dGlscy9jb2xvci1yZWdleC5tanMnO1xuaW1wb3J0IHsgZmxvYXRSZWdleCB9IGZyb20gJy4uL3V0aWxzL2Zsb2F0LXJlZ2V4Lm1qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3Nhbml0aXplLm1qcyc7XG5cbmZ1bmN0aW9uIHRlc3Qodikge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChpc05hTih2KSAmJlxuICAgICAgICB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAoKChfYSA9IHYubWF0Y2goZmxvYXRSZWdleCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHx8IDApICtcbiAgICAgICAgICAgICgoKF9iID0gdi5tYXRjaChjb2xvclJlZ2V4KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkgfHwgMCkgPlxuICAgICAgICAgICAgMCk7XG59XG5jb25zdCBOVU1CRVJfVE9LRU4gPSBcIm51bWJlclwiO1xuY29uc3QgQ09MT1JfVE9LRU4gPSBcImNvbG9yXCI7XG5jb25zdCBWQVJfVE9LRU4gPSBcInZhclwiO1xuY29uc3QgVkFSX0ZVTkNUSU9OX1RPS0VOID0gXCJ2YXIoXCI7XG5jb25zdCBTUExJVF9UT0tFTiA9IFwiJHt9XCI7XG4vLyB0aGlzIHJlZ2V4IGNvbnNpc3RzIG9mIHRoZSBgc2luZ2xlQ3NzVmFyaWFibGVSZWdleHxyZ2JIU0xWYWx1ZVJlZ2V4fGRpZ2l0UmVnZXhgXG5jb25zdCBjb21wbGV4UmVnZXggPSAvdmFyXFxzKlxcKFxccyotLSg/OltcXHctXStcXHMqfFtcXHctXStcXHMqLCg/OlxccypbXikoXFxzXXxcXHMqXFwoKD86W14pKF18XFwoW14pKF0qXFwpKSpcXCkpK1xccyopXFwpfCNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCl8LT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspL2dpdTtcbmZ1bmN0aW9uIGFuYWx5c2VDb21wbGV4VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvcmlnaW5hbFZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBpbmRleGVzID0ge1xuICAgICAgICBjb2xvcjogW10sXG4gICAgICAgIG51bWJlcjogW10sXG4gICAgICAgIHZhcjogW10sXG4gICAgfTtcbiAgICBjb25zdCB0eXBlcyA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCB0b2tlbmlzZWQgPSBvcmlnaW5hbFZhbHVlLnJlcGxhY2UoY29tcGxleFJlZ2V4LCAocGFyc2VkVmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yLnRlc3QocGFyc2VkVmFsdWUpKSB7XG4gICAgICAgICAgICBpbmRleGVzLmNvbG9yLnB1c2goaSk7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKENPTE9SX1RPS0VOKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvbG9yLnBhcnNlKHBhcnNlZFZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VkVmFsdWUuc3RhcnRzV2l0aChWQVJfRlVOQ1RJT05fVE9LRU4pKSB7XG4gICAgICAgICAgICBpbmRleGVzLnZhci5wdXNoKGkpO1xuICAgICAgICAgICAgdHlwZXMucHVzaChWQVJfVE9LRU4pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5kZXhlcy5udW1iZXIucHVzaChpKTtcbiAgICAgICAgICAgIHR5cGVzLnB1c2goTlVNQkVSX1RPS0VOKTtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHBhcnNlRmxvYXQocGFyc2VkVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICArK2k7XG4gICAgICAgIHJldHVybiBTUExJVF9UT0tFTjtcbiAgICB9KTtcbiAgICBjb25zdCBzcGxpdCA9IHRva2VuaXNlZC5zcGxpdChTUExJVF9UT0tFTik7XG4gICAgcmV0dXJuIHsgdmFsdWVzLCBzcGxpdCwgaW5kZXhlcywgdHlwZXMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tcGxleFZhbHVlKHYpIHtcbiAgICByZXR1cm4gYW5hbHlzZUNvbXBsZXhWYWx1ZSh2KS52YWx1ZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2Zvcm1lcihzb3VyY2UpIHtcbiAgICBjb25zdCB7IHNwbGl0LCB0eXBlcyB9ID0gYW5hbHlzZUNvbXBsZXhWYWx1ZShzb3VyY2UpO1xuICAgIGNvbnN0IG51bVNlY3Rpb25zID0gc3BsaXQubGVuZ3RoO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBsZXQgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TZWN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gc3BsaXRbaV07XG4gICAgICAgICAgICBpZiAodltpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVzW2ldO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBOVU1CRVJfVE9LRU4pIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHNhbml0aXplKHZbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBDT0xPUl9UT0tFTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gY29sb3IudHJhbnNmb3JtKHZbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IHZbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn1cbmNvbnN0IGNvbnZlcnROdW1iZXJzVG9aZXJvID0gKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiID8gMCA6IHY7XG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZSh2KSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VDb21wbGV4VmFsdWUodik7XG4gICAgY29uc3QgdHJhbnNmb3JtZXIgPSBjcmVhdGVUcmFuc2Zvcm1lcih2KTtcbiAgICByZXR1cm4gdHJhbnNmb3JtZXIocGFyc2VkLm1hcChjb252ZXJ0TnVtYmVyc1RvWmVybykpO1xufVxuY29uc3QgY29tcGxleCA9IHtcbiAgICB0ZXN0LFxuICAgIHBhcnNlOiBwYXJzZUNvbXBsZXhWYWx1ZSxcbiAgICBjcmVhdGVUcmFuc2Zvcm1lcixcbiAgICBnZXRBbmltYXRhYmxlTm9uZSxcbn07XG5cbmV4cG9ydCB7IGFuYWx5c2VDb21wbGV4VmFsdWUsIGNvbXBsZXggfTtcbiIsImltcG9ydCB7IGNvbXBsZXggfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBmbG9hdFJlZ2V4IH0gZnJvbSAnLi4vdXRpbHMvZmxvYXQtcmVnZXgubWpzJztcblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGRlZmF1bHQgdG8gMSBvciAxMDAlXG4gKi9cbmNvbnN0IG1heERlZmF1bHRzID0gbmV3IFNldChbXCJicmlnaHRuZXNzXCIsIFwiY29udHJhc3RcIiwgXCJzYXR1cmF0ZVwiLCBcIm9wYWNpdHlcIl0pO1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0RmlsdGVyKHYpIHtcbiAgICBjb25zdCBbbmFtZSwgdmFsdWVdID0gdi5zbGljZSgwLCAtMSkuc3BsaXQoXCIoXCIpO1xuICAgIGlmIChuYW1lID09PSBcImRyb3Atc2hhZG93XCIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFtudW1iZXJdID0gdmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW107XG4gICAgaWYgKCFudW1iZXIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IHVuaXQgPSB2YWx1ZS5yZXBsYWNlKG51bWJlciwgXCJcIik7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IG1heERlZmF1bHRzLmhhcyhuYW1lKSA/IDEgOiAwO1xuICAgIGlmIChudW1iZXIgIT09IHZhbHVlKVxuICAgICAgICBkZWZhdWx0VmFsdWUgKj0gMTAwO1xuICAgIHJldHVybiBuYW1lICsgXCIoXCIgKyBkZWZhdWx0VmFsdWUgKyB1bml0ICsgXCIpXCI7XG59XG5jb25zdCBmdW5jdGlvblJlZ2V4ID0gL1xcYihbYS16LV0qKVxcKC4qP1xcKS9ndTtcbmNvbnN0IGZpbHRlciA9IHtcbiAgICAuLi5jb21wbGV4LFxuICAgIGdldEFuaW1hdGFibGVOb25lOiAodikgPT4ge1xuICAgICAgICBjb25zdCBmdW5jdGlvbnMgPSB2Lm1hdGNoKGZ1bmN0aW9uUmVnZXgpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25zID8gZnVuY3Rpb25zLm1hcChhcHBseURlZmF1bHRGaWx0ZXIpLmpvaW4oXCIgXCIpIDogdjtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgZmlsdGVyIH07XG4iLCJpbXBvcnQgeyBweCB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcblxuY29uc3QgYnJvd3Nlck51bWJlclZhbHVlVHlwZXMgPSB7XG4gICAgLy8gQm9yZGVyIHByb3BzXG4gICAgYm9yZGVyV2lkdGg6IHB4LFxuICAgIGJvcmRlclRvcFdpZHRoOiBweCxcbiAgICBib3JkZXJSaWdodFdpZHRoOiBweCxcbiAgICBib3JkZXJCb3R0b21XaWR0aDogcHgsXG4gICAgYm9yZGVyTGVmdFdpZHRoOiBweCxcbiAgICBib3JkZXJSYWRpdXM6IHB4LFxuICAgIHJhZGl1czogcHgsXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogcHgsXG4gICAgYm9yZGVyVG9wUmlnaHRSYWRpdXM6IHB4LFxuICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBweCxcbiAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBweCxcbiAgICAvLyBQb3NpdGlvbmluZyBwcm9wc1xuICAgIHdpZHRoOiBweCxcbiAgICBtYXhXaWR0aDogcHgsXG4gICAgaGVpZ2h0OiBweCxcbiAgICBtYXhIZWlnaHQ6IHB4LFxuICAgIHRvcDogcHgsXG4gICAgcmlnaHQ6IHB4LFxuICAgIGJvdHRvbTogcHgsXG4gICAgbGVmdDogcHgsXG4gICAgLy8gU3BhY2luZyBwcm9wc1xuICAgIHBhZGRpbmc6IHB4LFxuICAgIHBhZGRpbmdUb3A6IHB4LFxuICAgIHBhZGRpbmdSaWdodDogcHgsXG4gICAgcGFkZGluZ0JvdHRvbTogcHgsXG4gICAgcGFkZGluZ0xlZnQ6IHB4LFxuICAgIG1hcmdpbjogcHgsXG4gICAgbWFyZ2luVG9wOiBweCxcbiAgICBtYXJnaW5SaWdodDogcHgsXG4gICAgbWFyZ2luQm90dG9tOiBweCxcbiAgICBtYXJnaW5MZWZ0OiBweCxcbiAgICAvLyBNaXNjXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogcHgsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWTogcHgsXG59O1xuXG5leHBvcnQgeyBicm93c2VyTnVtYmVyVmFsdWVUeXBlcyB9O1xuIiwiaW1wb3J0IHsgc2NhbGUsIGFscGhhIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgZGVncmVlcywgcHgsIHByb2dyZXNzUGVyY2VudGFnZSB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcblxuY29uc3QgdHJhbnNmb3JtVmFsdWVUeXBlcyA9IHtcbiAgICByb3RhdGU6IGRlZ3JlZXMsXG4gICAgcm90YXRlWDogZGVncmVlcyxcbiAgICByb3RhdGVZOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVo6IGRlZ3JlZXMsXG4gICAgc2NhbGUsXG4gICAgc2NhbGVYOiBzY2FsZSxcbiAgICBzY2FsZVk6IHNjYWxlLFxuICAgIHNjYWxlWjogc2NhbGUsXG4gICAgc2tldzogZGVncmVlcyxcbiAgICBza2V3WDogZGVncmVlcyxcbiAgICBza2V3WTogZGVncmVlcyxcbiAgICBkaXN0YW5jZTogcHgsXG4gICAgdHJhbnNsYXRlWDogcHgsXG4gICAgdHJhbnNsYXRlWTogcHgsXG4gICAgdHJhbnNsYXRlWjogcHgsXG4gICAgeDogcHgsXG4gICAgeTogcHgsXG4gICAgejogcHgsXG4gICAgcGVyc3BlY3RpdmU6IHB4LFxuICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBweCxcbiAgICBvcGFjaXR5OiBhbHBoYSxcbiAgICBvcmlnaW5YOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWTogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIG9yaWdpblo6IHB4LFxufTtcblxuZXhwb3J0IHsgdHJhbnNmb3JtVmFsdWVUeXBlcyB9O1xuIiwiaW1wb3J0IHsgbnVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy9pbmRleC5tanMnO1xuXG5jb25zdCBpbnQgPSB7XG4gICAgLi4ubnVtYmVyLFxuICAgIHRyYW5zZm9ybTogTWF0aC5yb3VuZCxcbn07XG5cbmV4cG9ydCB7IGludCB9O1xuIiwiaW1wb3J0IHsgYWxwaGEgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBweCB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcbmltcG9ydCB7IGJyb3dzZXJOdW1iZXJWYWx1ZVR5cGVzIH0gZnJvbSAnLi9udW1iZXItYnJvd3Nlci5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtVmFsdWVUeXBlcyB9IGZyb20gJy4vdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBpbnQgfSBmcm9tICcuL3R5cGUtaW50Lm1qcyc7XG5cbmNvbnN0IG51bWJlclZhbHVlVHlwZXMgPSB7XG4gICAgLi4uYnJvd3Nlck51bWJlclZhbHVlVHlwZXMsXG4gICAgLi4udHJhbnNmb3JtVmFsdWVUeXBlcyxcbiAgICB6SW5kZXg6IGludCxcbiAgICBzaXplOiBweCxcbiAgICAvLyBTVkdcbiAgICBmaWxsT3BhY2l0eTogYWxwaGEsXG4gICAgc3Ryb2tlT3BhY2l0eTogYWxwaGEsXG4gICAgbnVtT2N0YXZlczogaW50LFxufTtcblxuZXhwb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9O1xuIiwiaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9jb2xvci9pbmRleC5tanMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvY29tcGxleC9maWx0ZXIubWpzJztcbmltcG9ydCB7IG51bWJlclZhbHVlVHlwZXMgfSBmcm9tICcuL251bWJlci5tanMnO1xuXG4vKipcbiAqIEEgbWFwIG9mIGRlZmF1bHQgdmFsdWUgdHlwZXMgZm9yIGNvbW1vbiB2YWx1ZXNcbiAqL1xuY29uc3QgZGVmYXVsdFZhbHVlVHlwZXMgPSB7XG4gICAgLi4ubnVtYmVyVmFsdWVUeXBlcyxcbiAgICAvLyBDb2xvciBwcm9wc1xuICAgIGNvbG9yLFxuICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgb3V0bGluZUNvbG9yOiBjb2xvcixcbiAgICBmaWxsOiBjb2xvcixcbiAgICBzdHJva2U6IGNvbG9yLFxuICAgIC8vIEJvcmRlciBwcm9wc1xuICAgIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgICBib3JkZXJUb3BDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICAgIGJvcmRlckxlZnRDb2xvcjogY29sb3IsXG4gICAgZmlsdGVyLFxuICAgIFdlYmtpdEZpbHRlcjogZmlsdGVyLFxufTtcbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCBWYWx1ZVR5cGUgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZSBrZXlcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdFZhbHVlVHlwZSA9IChrZXkpID0+IGRlZmF1bHRWYWx1ZVR5cGVzW2tleV07XG5cbmV4cG9ydCB7IGRlZmF1bHRWYWx1ZVR5cGVzLCBnZXREZWZhdWx0VmFsdWVUeXBlIH07XG4iLCJpbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvY29tcGxleC9pbmRleC5tanMnO1xuaW1wb3J0IHsgZmlsdGVyIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvY29tcGxleC9maWx0ZXIubWpzJztcbmltcG9ydCB7IGdldERlZmF1bHRWYWx1ZVR5cGUgfSBmcm9tICcuL2RlZmF1bHRzLm1qcyc7XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKGtleSwgdmFsdWUpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlVHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZSAhPT0gZmlsdGVyKVxuICAgICAgICBkZWZhdWx0VmFsdWVUeXBlID0gY29tcGxleDtcbiAgICAvLyBJZiB2YWx1ZSBpcyBub3QgcmVjb2duaXNlZCBhcyBhbmltYXRhYmxlLCBpZSBcIm5vbmVcIiwgY3JlYXRlIGFuIGFuaW1hdGFibGUgdmVyc2lvbiBvcmlnaW4gYmFzZWQgb24gdGhlIHRhcmdldFxuICAgIHJldHVybiBkZWZhdWx0VmFsdWVUeXBlLmdldEFuaW1hdGFibGVOb25lXG4gICAgICAgID8gZGVmYXVsdFZhbHVlVHlwZS5nZXRBbmltYXRhYmxlTm9uZSh2YWx1ZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB7IGdldEFuaW1hdGFibGVOb25lIH07XG4iLCJpbXBvcnQgeyBhbmFseXNlQ29tcGxleFZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvY29tcGxleC9pbmRleC5tanMnO1xuaW1wb3J0IHsgZ2V0QW5pbWF0YWJsZU5vbmUgfSBmcm9tICcuLi8uLi9kb20vdmFsdWUtdHlwZXMvYW5pbWF0YWJsZS1ub25lLm1qcyc7XG5cbi8qKlxuICogSWYgd2UgZW5jb3VudGVyIGtleWZyYW1lcyBsaWtlIFwibm9uZVwiIG9yIFwiMFwiIGFuZCB3ZSBhbHNvIGhhdmUga2V5ZnJhbWVzIGxpa2VcbiAqIFwiI2ZmZlwiIG9yIFwiMjAwcHggMjAwcHhcIiB3ZSB3YW50IHRvIGZpbmQgYSBrZXlmcmFtZSB0byBzZXJ2ZSBhcyBhIHRlbXBsYXRlIGZvclxuICogdGhlIFwibm9uZVwiIGtleWZyYW1lcy4gSW4gdGhpcyBjYXNlIFwiI2ZmZlwiIG9yIFwiMjAwcHggMjAwcHhcIiAtIHRoZW4gdGhlc2UgZ2V0IHR1cm5lZCBpbnRvXG4gKiB6ZXJvIGVxdWl2YWxlbnRzLCBpLmUuIFwiI2ZmZjBcIiBvciBcIjBweCAwcHhcIi5cbiAqL1xuY29uc3QgaW52YWxpZFRlbXBsYXRlcyA9IG5ldyBTZXQoW1wiYXV0b1wiLCBcIm5vbmVcIiwgXCIwXCJdKTtcbmZ1bmN0aW9uIG1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSh1bnJlc29sdmVkS2V5ZnJhbWVzLCBub25lS2V5ZnJhbWVJbmRleGVzLCBuYW1lKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBhbmltYXRhYmxlVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKGkgPCB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAmJiAhYW5pbWF0YWJsZVRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlmcmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIWludmFsaWRUZW1wbGF0ZXMuaGFzKGtleWZyYW1lKSAmJlxuICAgICAgICAgICAgYW5hbHlzZUNvbXBsZXhWYWx1ZShrZXlmcmFtZSkudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYW5pbWF0YWJsZVRlbXBsYXRlID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIGlmIChhbmltYXRhYmxlVGVtcGxhdGUgJiYgbmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vbmVJbmRleCBvZiBub25lS2V5ZnJhbWVJbmRleGVzKSB7XG4gICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW25vbmVJbmRleF0gPSBnZXRBbmltYXRhYmxlTm9uZShuYW1lLCBhbmltYXRhYmxlVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBtYWtlTm9uZUtleWZyYW1lc0FuaW1hdGFibGUgfTtcbiIsImltcG9ydCB7IG51bWJlciB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHB4IH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcE9yZGVyIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9rZXlzLXRyYW5zZm9ybS5tanMnO1xuXG5jb25zdCBpc051bU9yUHhUeXBlID0gKHYpID0+IHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcbmNvbnN0IGdldFBvc0Zyb21NYXRyaXggPSAobWF0cml4LCBwb3MpID0+IHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG5jb25zdCBnZXRUcmFuc2xhdGVGcm9tTWF0cml4ID0gKHBvczIsIHBvczMpID0+IChfYmJveCwgeyB0cmFuc2Zvcm0gfSkgPT4ge1xuICAgIGlmICh0cmFuc2Zvcm0gPT09IFwibm9uZVwiIHx8ICF0cmFuc2Zvcm0pXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC91KTtcbiAgICBpZiAobWF0cml4M2QpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4XFwoKC4rKVxcKSQvdSk7XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB0cmFuc2Zvcm1LZXlzID0gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpcIl0pO1xuY29uc3Qgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1Qcm9wT3JkZXIuZmlsdGVyKChrZXkpID0+ICF0cmFuc2Zvcm1LZXlzLmhhcyhrZXkpKTtcbmZ1bmN0aW9uIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCkge1xuICAgIGNvbnN0IHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gICAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybXMucHVzaChba2V5LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVtb3ZlZFRyYW5zZm9ybXM7XG59XG5jb25zdCBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICAgIC8vIERpbWVuc2lvbnNcbiAgICB3aWR0aDogKHsgeCB9LCB7IHBhZGRpbmdMZWZ0ID0gXCIwXCIsIHBhZGRpbmdSaWdodCA9IFwiMFwiIH0pID0+IHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KSxcbiAgICBoZWlnaHQ6ICh7IHkgfSwgeyBwYWRkaW5nVG9wID0gXCIwXCIsIHBhZGRpbmdCb3R0b20gPSBcIjBcIiB9KSA9PiB5Lm1heCAtIHkubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQocGFkZGluZ0JvdHRvbSksXG4gICAgdG9wOiAoX2Jib3gsIHsgdG9wIH0pID0+IHBhcnNlRmxvYXQodG9wKSxcbiAgICBsZWZ0OiAoX2Jib3gsIHsgbGVmdCB9KSA9PiBwYXJzZUZsb2F0KGxlZnQpLFxuICAgIGJvdHRvbTogKHsgeSB9LCB7IHRvcCB9KSA9PiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbiksXG4gICAgcmlnaHQ6ICh7IHggfSwgeyBsZWZ0IH0pID0+IHBhcnNlRmxvYXQobGVmdCkgKyAoeC5tYXggLSB4Lm1pbiksXG4gICAgLy8gVHJhbnNmb3JtXG4gICAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gICAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNCksXG59O1xuLy8gQWxpYXMgdHJhbnNsYXRlIGxvbmdmb3JtIG5hbWVzXG5wb3NpdGlvbmFsVmFsdWVzLnRyYW5zbGF0ZVggPSBwb3NpdGlvbmFsVmFsdWVzLng7XG5wb3NpdGlvbmFsVmFsdWVzLnRyYW5zbGF0ZVkgPSBwb3NpdGlvbmFsVmFsdWVzLnk7XG5cbmV4cG9ydCB7IGlzTnVtT3JQeFR5cGUsIHBvc2l0aW9uYWxWYWx1ZXMsIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0gfTtcbiIsImltcG9ydCB7IHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0gfSBmcm9tICcuLi9kb20vdXRpbHMvdW5pdC1jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5jb25zdCB0b1Jlc29sdmUgPSBuZXcgU2V0KCk7XG5sZXQgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBhbnlOZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG5mdW5jdGlvbiBtZWFzdXJlQWxsS2V5ZnJhbWVzKCkge1xuICAgIGlmIChhbnlOZWVkc01lYXN1cmVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVyc1RvTWVhc3VyZSA9IEFycmF5LmZyb20odG9SZXNvbHZlKS5maWx0ZXIoKHJlc29sdmVyKSA9PiByZXNvbHZlci5uZWVkc01lYXN1cmVtZW50KTtcbiAgICAgICAgY29uc3QgZWxlbWVudHNUb01lYXN1cmUgPSBuZXcgU2V0KHJlc29sdmVyc1RvTWVhc3VyZS5tYXAoKHJlc29sdmVyKSA9PiByZXNvbHZlci5lbGVtZW50KSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybXNUb1Jlc3RvcmUgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcml0ZSBwYXNzXG4gICAgICAgICAqIElmIHdlJ3JlIG1lYXN1cmluZyBlbGVtZW50cyB3ZSB3YW50IHRvIHJlbW92ZSBib3VuZGluZyBib3gtY2hhbmdpbmcgdHJhbnNmb3Jtcy5cbiAgICAgICAgICovXG4gICAgICAgIGVsZW1lbnRzVG9NZWFzdXJlLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZWRUcmFuc2Zvcm1zID0gcmVtb3ZlTm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghcmVtb3ZlZFRyYW5zZm9ybXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyYW5zZm9ybXNUb1Jlc3RvcmUuc2V0KGVsZW1lbnQsIHJlbW92ZWRUcmFuc2Zvcm1zKTtcbiAgICAgICAgICAgIGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWFkXG4gICAgICAgIHJlc29sdmVyc1RvTWVhc3VyZS5mb3JFYWNoKChyZXNvbHZlcikgPT4gcmVzb2x2ZXIubWVhc3VyZUluaXRpYWxTdGF0ZSgpKTtcbiAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgZWxlbWVudHNUb01lYXN1cmUuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmUgPSB0cmFuc2Zvcm1zVG9SZXN0b3JlLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChyZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgcmVzdG9yZS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBlbGVtZW50LmdldFZhbHVlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVhZFxuICAgICAgICByZXNvbHZlcnNUb01lYXN1cmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLm1lYXN1cmVFbmRTdGF0ZSgpKTtcbiAgICAgICAgLy8gV3JpdGVcbiAgICAgICAgcmVzb2x2ZXJzVG9NZWFzdXJlLmZvckVhY2goKHJlc29sdmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZXIuc3VzcGVuZGVkU2Nyb2xsWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHJlc29sdmVyLnN1c3BlbmRlZFNjcm9sbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYW55TmVlZHNNZWFzdXJlbWVudCA9IGZhbHNlO1xuICAgIGlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdG9SZXNvbHZlLmZvckVhY2goKHJlc29sdmVyKSA9PiByZXNvbHZlci5jb21wbGV0ZSgpKTtcbiAgICB0b1Jlc29sdmUuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIHJlYWRBbGxLZXlmcmFtZXMoKSB7XG4gICAgdG9SZXNvbHZlLmZvckVhY2goKHJlc29sdmVyKSA9PiB7XG4gICAgICAgIHJlc29sdmVyLnJlYWRLZXlmcmFtZXMoKTtcbiAgICAgICAgaWYgKHJlc29sdmVyLm5lZWRzTWVhc3VyZW1lbnQpIHtcbiAgICAgICAgICAgIGFueU5lZWRzTWVhc3VyZW1lbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmbHVzaEtleWZyYW1lUmVzb2x2ZXJzKCkge1xuICAgIHJlYWRBbGxLZXlmcmFtZXMoKTtcbiAgICBtZWFzdXJlQWxsS2V5ZnJhbWVzKCk7XG59XG5jbGFzcyBLZXlmcmFtZVJlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1bnJlc29sdmVkS2V5ZnJhbWVzLCBvbkNvbXBsZXRlLCBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwgaXNBc3luYyA9IGZhbHNlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFjayB3aGV0aGVyIHRoaXMgcmVzb2x2ZXIgaGFzIGNvbXBsZXRlZC4gT25jZSBjb21wbGV0ZSwgaXQgbmV2ZXJcbiAgICAgICAgICogbmVlZHMgdG8gYXR0ZW1wdCBrZXlmcmFtZSByZXNvbHV0aW9uIGFnYWluLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFjayB3aGV0aGVyIHRoaXMgcmVzb2x2ZXIgaXMgYXN5bmMuIElmIGl0IGlzLCBpdCdsbCBiZSBhZGRlZCB0byB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgcXVldWUgYW5kIGZsdXNoZWQgaW4gdGhlIG5leHQgZnJhbWUuIFJlc29sdmVycyB0aGF0IGFyZW4ndCBnb2luZ1xuICAgICAgICAgKiB0byB0cmlnZ2VyIHJlYWQvd3JpdGUgdGhyYXNoaW5nIGRvbid0IG5lZWQgdG8gYmUgYXN5bmMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBuZWVkcyB0byBwZXJmb3JtIGEgbWVhc3VyZW1lbnRcbiAgICAgICAgICogdG8gcmVzb2x2ZSBpdHMga2V5ZnJhbWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFjayB3aGV0aGVyIHRoaXMgcmVzb2x2ZXIgaXMgY3VycmVudGx5IHNjaGVkdWxlZCB0byByZXNvbHZlXG4gICAgICAgICAqIHRvIGFsbG93IGl0IHRvIGJlIGNhbmNlbGxlZCBhbmQgcmVzdW1lZCBleHRlcm5hbGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVucmVzb2x2ZWRLZXlmcmFtZXMgPSBbLi4udW5yZXNvbHZlZEtleWZyYW1lc107XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSA9IG9uQ29tcGxldGU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubW90aW9uVmFsdWUgPSBtb3Rpb25WYWx1ZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pc0FzeW5jID0gaXNBc3luYztcbiAgICB9XG4gICAgc2NoZWR1bGVSZXNvbHZlKCkge1xuICAgICAgICB0aGlzLmlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNBc3luYykge1xuICAgICAgICAgICAgdG9SZXNvbHZlLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIGlmICghaXNTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICBpc1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZnJhbWUucmVhZChyZWFkQWxsS2V5ZnJhbWVzKTtcbiAgICAgICAgICAgICAgICBmcmFtZS5yZXNvbHZlS2V5ZnJhbWVzKG1lYXN1cmVBbGxLZXlmcmFtZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZWFkS2V5ZnJhbWVzKCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZEtleWZyYW1lcygpIHtcbiAgICAgICAgY29uc3QgeyB1bnJlc29sdmVkS2V5ZnJhbWVzLCBuYW1lLCBlbGVtZW50LCBtb3Rpb25WYWx1ZSB9ID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEga2V5ZnJhbWUgaXMgbnVsbCwgd2UgaHlkcmF0ZSBpdCBlaXRoZXIgYnkgcmVhZGluZyBpdCBmcm9tXG4gICAgICAgICAqIHRoZSBpbnN0YW5jZSwgb3IgcHJvcGFnYXRpbmcgZnJvbSBwcmV2aW91cyBrZXlmcmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIGZpcnN0IGtleWZyYW1lIGlzIG51bGwsIHdlIG5lZWQgdG8gZmluZCBpdHMgdmFsdWUgYnkgc2FtcGxpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBtb3Rpb25WYWx1ZSA9PT0gbnVsbCB8fCBtb3Rpb25WYWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW90aW9uVmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsS2V5ZnJhbWUgPSB1bnJlc29sdmVkS2V5ZnJhbWVzW3VucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5yZXNvbHZlZEtleWZyYW1lc1swXSA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50ICYmIG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNSZWFkID0gZWxlbWVudC5yZWFkVmFsdWUobmFtZSwgZmluYWxLZXlmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVBc1JlYWQgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZUFzUmVhZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0gPSB2YWx1ZUFzUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodW5yZXNvbHZlZEtleWZyYW1lc1swXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID0gZmluYWxLZXlmcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobW90aW9uVmFsdWUgJiYgY3VycmVudFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLnNldCh1bnJlc29sdmVkS2V5ZnJhbWVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdW5yZXNvbHZlZEtleWZyYW1lc1tpXSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRGaW5hbEtleWZyYW1lKCkgeyB9XG4gICAgbWVhc3VyZUluaXRpYWxTdGF0ZSgpIHsgfVxuICAgIHJlbmRlckVuZFN0eWxlcygpIHsgfVxuICAgIG1lYXN1cmVFbmRTdGF0ZSgpIHsgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uQ29tcGxldGUodGhpcy51bnJlc29sdmVkS2V5ZnJhbWVzLCB0aGlzLmZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB0b1Jlc29sdmUuZGVsZXRlKHRoaXMpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0NvbXBsZXRlKSB7XG4gICAgICAgICAgICB0aGlzLmlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0b1Jlc29sdmUuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcGxldGUpXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVzb2x2ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgS2V5ZnJhbWVSZXNvbHZlciwgZmx1c2hLZXlmcmFtZVJlc29sdmVycyB9O1xuIiwiaW1wb3J0IHsgbm9vcCB9IGZyb20gJy4vbm9vcC5tanMnO1xuXG5sZXQgd2FybmluZyA9IG5vb3A7XG5sZXQgaW52YXJpYW50ID0gbm9vcDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB3YXJuaW5nID0gKGNoZWNrLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmICghY2hlY2sgJiYgdHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaW52YXJpYW50ID0gKGNoZWNrLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmICghY2hlY2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9O1xuIiwiLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhIG51bWVyaWNhbCBzdHJpbmcsIGllIGEgc3RyaW5nIHRoYXQgaXMgcHVyZWx5IGEgbnVtYmVyIGVnIFwiMTAwXCIgb3IgXCItMTAwLjFcIlxuICovXG5jb25zdCBpc051bWVyaWNhbFN0cmluZyA9ICh2KSA9PiAvXi0/KD86XFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKSQvdS50ZXN0KHYpO1xuXG5leHBvcnQgeyBpc051bWVyaWNhbFN0cmluZyB9O1xuIiwiY29uc3QgY2hlY2tTdHJpbmdTdGFydHNXaXRoID0gKHRva2VuKSA9PiAoa2V5KSA9PiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIGtleS5zdGFydHNXaXRoKHRva2VuKTtcbmNvbnN0IGlzQ1NTVmFyaWFibGVOYW1lID0gXG4vKkBfX1BVUkVfXyovIGNoZWNrU3RyaW5nU3RhcnRzV2l0aChcIi0tXCIpO1xuY29uc3Qgc3RhcnRzQXNWYXJpYWJsZVRva2VuID0gXG4vKkBfX1BVUkVfXyovIGNoZWNrU3RyaW5nU3RhcnRzV2l0aChcInZhcigtLVwiKTtcbmNvbnN0IGlzQ1NTVmFyaWFibGVUb2tlbiA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0c1dpdGhUb2tlbiA9IHN0YXJ0c0FzVmFyaWFibGVUb2tlbih2YWx1ZSk7XG4gICAgaWYgKCFzdGFydHNXaXRoVG9rZW4pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBFbnN1cmUgYW55IGNvbW1lbnRzIGFyZSBzdHJpcHBlZCBmcm9tIHRoZSB2YWx1ZSBhcyB0aGlzIGNhbiBoYXJtIHBlcmZvcm1hbmNlIG9mIHRoZSByZWdleC5cbiAgICByZXR1cm4gc2luZ2xlQ3NzVmFyaWFibGVSZWdleC50ZXN0KHZhbHVlLnNwbGl0KFwiLypcIilbMF0udHJpbSgpKTtcbn07XG5jb25zdCBzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4ID0gL3ZhclxcKC0tKD86W1xcdy1dK1xccyp8W1xcdy1dK1xccyosKD86XFxzKlteKShcXHNdfFxccypcXCgoPzpbXikoXXxcXChbXikoXSpcXCkpKlxcKSkrXFxzKilcXCkkL2l1O1xuXG5leHBvcnQgeyBpc0NTU1ZhcmlhYmxlTmFtZSwgaXNDU1NWYXJpYWJsZVRva2VuIH07XG4iLCJpbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgaXNOdW1lcmljYWxTdHJpbmcgfSBmcm9tICcuLi8uLi8uLi91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpc0NTU1ZhcmlhYmxlVG9rZW4gfSBmcm9tICcuL2lzLWNzcy12YXJpYWJsZS5tanMnO1xuXG4vKipcbiAqIFBhcnNlIEZyYW1lcidzIHNwZWNpYWwgQ1NTIHZhcmlhYmxlIGZvcm1hdCBpbnRvIGEgQ1NTIHRva2VuIGFuZCBhIGZhbGxiYWNrLlxuICpcbiAqIGBgYFxuICogYHZhcigtLWZvbywgI2ZmZilgID0+IFtgLS1mb29gLCAnI2ZmZiddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY3VycmVudFxuICovXG5jb25zdCBzcGxpdENTU1ZhcmlhYmxlUmVnZXggPSBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXggLS0gZmFsc2UgcG9zaXRpdmUsIGFzIGl0IGNhbiBtYXRjaCBhIGxvdCBvZiB3b3Jkc1xuL152YXJcXCgtLSg/OihbXFx3LV0rKXwoW1xcdy1dKyksID8oW2EtekEtWlxcZCAoKSUjLiwtXSspKVxcKS91O1xuZnVuY3Rpb24gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBzcGxpdENTU1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gWyxdO1xuICAgIGNvbnN0IFssIHRva2VuMSwgdG9rZW4yLCBmYWxsYmFja10gPSBtYXRjaDtcbiAgICByZXR1cm4gW2AtLSR7dG9rZW4xICE9PSBudWxsICYmIHRva2VuMSAhPT0gdm9pZCAwID8gdG9rZW4xIDogdG9rZW4yfWAsIGZhbGxiYWNrXTtcbn1cbmNvbnN0IG1heERlcHRoID0gNDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCwgZGVwdGggPSAxKSB7XG4gICAgaW52YXJpYW50KGRlcHRoIDw9IG1heERlcHRoLCBgTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcIiR7Y3VycmVudH1cIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LmApO1xuICAgIGNvbnN0IFt0b2tlbiwgZmFsbGJhY2tdID0gcGFyc2VDU1NWYXJpYWJsZShjdXJyZW50KTtcbiAgICAvLyBObyBDU1MgdmFyaWFibGUgZGV0ZWN0ZWRcbiAgICBpZiAoIXRva2VuKVxuICAgICAgICByZXR1cm47XG4gICAgLy8gQXR0ZW1wdCB0byByZWFkIHRoaXMgQ1NTIHZhcmlhYmxlIG9mZiB0aGUgZWxlbWVudFxuICAgIGNvbnN0IHJlc29sdmVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSh0b2tlbik7XG4gICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSByZXNvbHZlZC50cmltKCk7XG4gICAgICAgIHJldHVybiBpc051bWVyaWNhbFN0cmluZyh0cmltbWVkKSA/IHBhcnNlRmxvYXQodHJpbW1lZCkgOiB0cmltbWVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNDU1NWYXJpYWJsZVRva2VuKGZhbGxiYWNrKVxuICAgICAgICA/IGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSlcbiAgICAgICAgOiBmYWxsYmFjaztcbn1cblxuZXhwb3J0IHsgZ2V0VmFyaWFibGVWYWx1ZSwgcGFyc2VDU1NWYXJpYWJsZSB9O1xuIiwiLyoqXG4gKiBUZXN0cyBhIHByb3ZpZGVkIHZhbHVlIGFnYWluc3QgYSBWYWx1ZVR5cGVcbiAqL1xuY29uc3QgdGVzdFZhbHVlVHlwZSA9ICh2KSA9PiAodHlwZSkgPT4gdHlwZS50ZXN0KHYpO1xuXG5leHBvcnQgeyB0ZXN0VmFsdWVUeXBlIH07XG4iLCIvKipcbiAqIFZhbHVlVHlwZSBmb3IgXCJhdXRvXCJcbiAqL1xuY29uc3QgYXV0byA9IHtcbiAgICB0ZXN0OiAodikgPT4gdiA9PT0gXCJhdXRvXCIsXG4gICAgcGFyc2U6ICh2KSA9PiB2LFxufTtcblxuZXhwb3J0IHsgYXV0byB9O1xuIiwiaW1wb3J0IHsgbnVtYmVyIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcbmltcG9ydCB7IHRlc3RWYWx1ZVR5cGUgfSBmcm9tICcuL3Rlc3QubWpzJztcbmltcG9ydCB7IGF1dG8gfSBmcm9tICcuL3R5cGUtYXV0by5tanMnO1xuXG4vKipcbiAqIEEgbGlzdCBvZiB2YWx1ZSB0eXBlcyBjb21tb25seSB1c2VkIGZvciBkaW1lbnNpb25zXG4gKi9cbmNvbnN0IGRpbWVuc2lvblZhbHVlVHlwZXMgPSBbbnVtYmVyLCBweCwgcGVyY2VudCwgZGVncmVlcywgdncsIHZoLCBhdXRvXTtcbi8qKlxuICogVGVzdHMgYSBkaW1lbnNpb25hbCB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIGRpbWVuc2lvbiBWYWx1ZVR5cGVzXG4gKi9cbmNvbnN0IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUgPSAodikgPT4gZGltZW5zaW9uVmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xuXG5leHBvcnQgeyBkaW1lbnNpb25WYWx1ZVR5cGVzLCBmaW5kRGltZW5zaW9uVmFsdWVUeXBlIH07XG4iLCJpbXBvcnQgeyBpc05vbmUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvaXMtbm9uZS5tanMnO1xuaW1wb3J0IHsgcG9zaXRpb25hbEtleXMgfSBmcm9tICcuLi9odG1sL3V0aWxzL2tleXMtcG9zaXRpb24ubWpzJztcbmltcG9ydCB7IG1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSB9IGZyb20gJy4uL2h0bWwvdXRpbHMvbWFrZS1ub25lLWFuaW1hdGFibGUubWpzJztcbmltcG9ydCB7IEtleWZyYW1lUmVzb2x2ZXIgfSBmcm9tICcuLi91dGlscy9LZXlmcmFtZXNSZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgZ2V0VmFyaWFibGVWYWx1ZSB9IGZyb20gJy4vdXRpbHMvY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBpc0NTU1ZhcmlhYmxlVG9rZW4gfSBmcm9tICcuL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanMnO1xuaW1wb3J0IHsgaXNOdW1PclB4VHlwZSwgcG9zaXRpb25hbFZhbHVlcyB9IGZyb20gJy4vdXRpbHMvdW5pdC1jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBmaW5kRGltZW5zaW9uVmFsdWVUeXBlIH0gZnJvbSAnLi92YWx1ZS10eXBlcy9kaW1lbnNpb25zLm1qcyc7XG5cbmNsYXNzIERPTUtleWZyYW1lc1Jlc29sdmVyIGV4dGVuZHMgS2V5ZnJhbWVSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodW5yZXNvbHZlZEtleWZyYW1lcywgb25Db21wbGV0ZSwgbmFtZSwgbW90aW9uVmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIodW5yZXNvbHZlZEtleWZyYW1lcywgb25Db21wbGV0ZSwgbmFtZSwgbW90aW9uVmFsdWUsIGVsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICByZWFkS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIGVsZW1lbnQsIG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdXBlci5yZWFkS2V5ZnJhbWVzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhbnkga2V5ZnJhbWUgaXMgYSBDU1MgdmFyaWFibGUsIHdlIG5lZWQgdG8gZmluZCBpdHMgdmFsdWUgYnkgc2FtcGxpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ZnJhbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZSA9IGtleWZyYW1lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZVRva2VuKGtleWZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoa2V5ZnJhbWUsIGVsZW1lbnQuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbEtleWZyYW1lID0ga2V5ZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmUgXCJub25lXCIgdmFsdWVzLiBXZSBkbyB0aGlzIHBvdGVudGlhbGx5IHR3aWNlIC0gb25jZSBiZWZvcmUgYW5kIG9uY2UgYWZ0ZXIgbWVhc3VyaW5nIGtleWZyYW1lcy5cbiAgICAgICAgICogVGhpcyBjb3VsZCBiZSBzZWVuIGFzIGluZWZmaWNpZW50IGJ1dCBpdCdzIGEgdHJhZGUtb2ZmIHRvIGF2b2lkIG1lYXN1cmVtZW50cyBpbiBtb3JlIHNpdHVhdGlvbnMsIHdoaWNoXG4gICAgICAgICAqIGhhdmUgYSBmYXIgYmlnZ2VyIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZU5vbmVLZXlmcmFtZXMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHRvIHNlZSBpZiB1bml0IHR5cGUgaGFzIGNoYW5nZWQuIElmIHNvIHNjaGVkdWxlIGpvYnMgdGhhdCB3aWxsXG4gICAgICAgICAqIHRlbXBvcmFyaWx5IHNldCBzdHlsZXMgdG8gdGhlIGRlc3RpbmF0aW9uIGtleWZyYW1lcy5cbiAgICAgICAgICogU2tpcCBpZiB3ZSBoYXZlIG1vcmUgdGhhbiB0d28ga2V5ZnJhbWVzIG9yIHRoaXMgaXNuJ3QgYSBwb3NpdGlvbmFsIHZhbHVlLlxuICAgICAgICAgKiBUT0RPOiBXZSBjYW4gdGhyb3cgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGtleWZyYW1lcyBhbmQgdGhlIHZhbHVlIHR5cGUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghcG9zaXRpb25hbEtleXMuaGFzKG5hbWUpIHx8IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW29yaWdpbiwgdGFyZ2V0XSA9IHVucmVzb2x2ZWRLZXlmcmFtZXM7XG4gICAgICAgIGNvbnN0IG9yaWdpblR5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKG9yaWdpbik7XG4gICAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRhcmdldCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgd2UgZG9uJ3QgcmVjb2duaXNlIHRoZXNlIHZhbHVlIHR5cGVzIG9yIHdlIGNhbiBhbmltYXRlIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChvcmlnaW5UeXBlID09PSB0YXJnZXRUeXBlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYm90aCB2YWx1ZXMgYXJlIG51bWJlcnMgb3IgcGl4ZWxzLCB3ZSBjYW4gYW5pbWF0ZSBiZXR3ZWVuIHRoZW0gYnlcbiAgICAgICAgICogY29udmVydGluZyB0aGVtIHRvIG51bWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNOdW1PclB4VHlwZShvcmlnaW5UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRhcmdldFR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbHNlLCB0aGUgb25seSB3YXkgdG8gcmVzb2x2ZSB0aGlzIGlzIGJ5IG1lYXN1cmluZyB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uZWVkc01lYXN1cmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlTm9uZUtleWZyYW1lcygpIHtcbiAgICAgICAgY29uc3QgeyB1bnJlc29sdmVkS2V5ZnJhbWVzLCBuYW1lIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBub25lS2V5ZnJhbWVJbmRleGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzTm9uZSh1bnJlc29sdmVkS2V5ZnJhbWVzW2ldKSkge1xuICAgICAgICAgICAgICAgIG5vbmVLZXlmcmFtZUluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uZUtleWZyYW1lSW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSh1bnJlc29sdmVkS2V5ZnJhbWVzLCBub25lS2V5ZnJhbWVJbmRleGVzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlSW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJoZWlnaHRcIikge1xuICAgICAgICAgICAgdGhpcy5zdXNwZW5kZWRTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZWRPcmlnaW4gPSBwb3NpdGlvbmFsVmFsdWVzW25hbWVdKGVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCksIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQuY3VycmVudCkpO1xuICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID0gdGhpcy5tZWFzdXJlZE9yaWdpbjtcbiAgICAgICAgLy8gU2V0IGZpbmFsIGtleSBmcmFtZSB0byBtZWFzdXJlIGFmdGVyIG5leHQgcmVuZGVyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVLZXlmcmFtZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG1lYXN1cmVLZXlmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbGVtZW50LmdldFZhbHVlKG5hbWUsIG1lYXN1cmVLZXlmcmFtZSkuanVtcChtZWFzdXJlS2V5ZnJhbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlRW5kU3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBuYW1lLCB1bnJlc29sdmVkS2V5ZnJhbWVzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKG5hbWUpO1xuICAgICAgICB2YWx1ZSAmJiB2YWx1ZS5qdW1wKHRoaXMubWVhc3VyZWRPcmlnaW4sIGZhbHNlKTtcbiAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZUluZGV4ID0gdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBmaW5hbEtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1tmaW5hbEtleWZyYW1lSW5kZXhdO1xuICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ZpbmFsS2V5ZnJhbWVJbmRleF0gPSBwb3NpdGlvbmFsVmFsdWVzW25hbWVdKGVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCksIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQuY3VycmVudCkpO1xuICAgICAgICBpZiAoZmluYWxLZXlmcmFtZSAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsS2V5ZnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbEtleWZyYW1lID0gZmluYWxLZXlmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIHRyYW5zZm9ybSB2YWx1ZXMsIHJlYXBwbHkgdGhlbSBiZWZvcmUgdGhlIG5leHQgcmVuZGVyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnJlbW92ZWRUcmFuc2Zvcm1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZWRUcmFuc2Zvcm1zLmZvckVhY2goKFt1bnNldFRyYW5zZm9ybU5hbWUsIHVuc2V0VHJhbnNmb3JtVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAuZ2V0VmFsdWUodW5zZXRUcmFuc2Zvcm1OYW1lKVxuICAgICAgICAgICAgICAgICAgICAuc2V0KHVuc2V0VHJhbnNmb3JtVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlTm9uZUtleWZyYW1lcygpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIgfTtcbiIsImltcG9ydCB7IGNvbXBsZXggfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2luZGV4Lm1qcyc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbmltYXRhYmxlLiBFeGFtcGxlczpcbiAqXG4gKiDinIU6IDEwMCwgXCIxMDBweFwiLCBcIiNmZmZcIlxuICog4p2MOiBcImJsb2NrXCIsIFwidXJsKDIuanBnKVwiXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgaXNBbmltYXRhYmxlID0gKHZhbHVlLCBuYW1lKSA9PiB7XG4gICAgLy8gSWYgdGhlIGxpc3Qgb2Yga2V5cyB0YXQgbWlnaHQgYmUgbm9uLWFuaW1hdGFibGUgZ3Jvd3MsIHJlcGxhY2Ugd2l0aCBTZXRcbiAgICBpZiAobmFtZSA9PT0gXCJ6SW5kZXhcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIElmIGl0J3MgYSBudW1iZXIgb3IgYSBrZXlmcmFtZXMgYXJyYXksIHdlIGNhbiBhbmltYXRlIGl0LiBXZSBtaWdodCBhdCBzb21lIHBvaW50XG4gICAgLy8gbmVlZCB0byBkbyBhIGRlZXAgaXNBbmltYXRhYmxlIGNoZWNrIG9mIGtleWZyYW1lcywgb3IgbGV0IFBvcG1vdGlvbiBoYW5kbGUgdGhpcyxcbiAgICAvLyBidXQgZm9yIG5vdyBsZXRzIGxlYXZlIGl0IGxpa2UgdGhpcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgLy8gSXQncyBhbmltYXRhYmxlIGlmIHdlIGhhdmUgYSBzdHJpbmdcbiAgICAgICAgKGNvbXBsZXgudGVzdCh2YWx1ZSkgfHwgdmFsdWUgPT09IFwiMFwiKSAmJiAvLyBBbmQgaXQgY29udGFpbnMgbnVtYmVycyBhbmQvb3IgY29sb3JzXG4gICAgICAgICF2YWx1ZS5zdGFydHNXaXRoKFwidXJsKFwiKSAvLyBVbmxlc3MgaXQgc3RhcnRzIHdpdGggXCJ1cmwoXCJcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGlzQW5pbWF0YWJsZSB9O1xuIiwiaW1wb3J0IHsgaXNHZW5lcmF0b3IgfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgaXNBbmltYXRhYmxlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtYW5pbWF0YWJsZS5tanMnO1xuXG5mdW5jdGlvbiBoYXNLZXlmcmFtZXNDaGFuZ2VkKGtleWZyYW1lcykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBrZXlmcmFtZXNbMF07XG4gICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXlmcmFtZXNbaV0gIT09IGN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYW5BbmltYXRlKGtleWZyYW1lcywgbmFtZSwgdHlwZSwgdmVsb2NpdHkpIHtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB3ZSdyZSBhYmxlIHRvIGFuaW1hdGUgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBrZXlmcmFtZXMsXG4gICAgICogYW5kIHRocm93IGEgd2FybmluZyBpZiB3ZSdyZSBhdHRlbXB0aW5nIHRvIGFuaW1hdGUgYmV0d2VlbiBvbmUgdGhhdCdzXG4gICAgICogYW5pbWF0YWJsZSBhbmQgYW5vdGhlciB0aGF0IGlzbid0LlxuICAgICAqL1xuICAgIGNvbnN0IG9yaWdpbktleWZyYW1lID0ga2V5ZnJhbWVzWzBdO1xuICAgIGlmIChvcmlnaW5LZXlmcmFtZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZXNlIGFyZW4ndCB0cmFkaXRpb25hbGx5IGFuaW1hdGFibGUgYnV0IHdlIGRvIHN1cHBvcnQgdGhlbS5cbiAgICAgKiBJbiBmdXR1cmUgd2UgY291bGQgbG9vayBpbnRvIG1ha2luZyB0aGlzIG1vcmUgZ2VuZXJpYyBvciByZXBsYWNpbmdcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHdpdGggbWl4KCkgPT09IG1peEltbWVkaWF0ZVxuICAgICAqL1xuICAgIGlmIChuYW1lID09PSBcImRpc3BsYXlcIiB8fCBuYW1lID09PSBcInZpc2liaWxpdHlcIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgdGFyZ2V0S2V5ZnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGlzT3JpZ2luQW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZShvcmlnaW5LZXlmcmFtZSwgbmFtZSk7XG4gICAgY29uc3QgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKHRhcmdldEtleWZyYW1lLCBuYW1lKTtcbiAgICB3YXJuaW5nKGlzT3JpZ2luQW5pbWF0YWJsZSA9PT0gaXNUYXJnZXRBbmltYXRhYmxlLCBgWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSAke25hbWV9IGZyb20gXCIke29yaWdpbktleWZyYW1lfVwiIHRvIFwiJHt0YXJnZXRLZXlmcmFtZX1cIi4gJHtvcmlnaW5LZXlmcmFtZX0gaXMgbm90IGFuIGFuaW1hdGFibGUgdmFsdWUgLSB0byBlbmFibGUgdGhpcyBhbmltYXRpb24gc2V0ICR7b3JpZ2luS2V5ZnJhbWV9IHRvIGEgdmFsdWUgYW5pbWF0YWJsZSB0byAke3RhcmdldEtleWZyYW1lfSB2aWEgdGhlIFxcYHN0eWxlXFxgIHByb3BlcnR5LmApO1xuICAgIC8vIEFsd2F5cyBza2lwIGlmIGFueSBvZiB0aGVzZSBhcmUgdHJ1ZVxuICAgIGlmICghaXNPcmlnaW5BbmltYXRhYmxlIHx8ICFpc1RhcmdldEFuaW1hdGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGhhc0tleWZyYW1lc0NoYW5nZWQoa2V5ZnJhbWVzKSB8fFxuICAgICAgICAoKHR5cGUgPT09IFwic3ByaW5nXCIgfHwgaXNHZW5lcmF0b3IodHlwZSkpICYmIHZlbG9jaXR5KSk7XG59XG5cbmV4cG9ydCB7IGNhbkFuaW1hdGUgfTtcbiIsImNvbnN0IGlzTm90TnVsbCA9ICh2YWx1ZSkgPT4gdmFsdWUgIT09IG51bGw7XG5mdW5jdGlvbiBnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgeyByZXBlYXQsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiB9LCBmaW5hbEtleWZyYW1lKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRLZXlmcmFtZXMgPSBrZXlmcmFtZXMuZmlsdGVyKGlzTm90TnVsbCk7XG4gICAgY29uc3QgaW5kZXggPSByZXBlYXQgJiYgcmVwZWF0VHlwZSAhPT0gXCJsb29wXCIgJiYgcmVwZWF0ICUgMiA9PT0gMVxuICAgICAgICA/IDBcbiAgICAgICAgOiByZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiAhaW5kZXggfHwgZmluYWxLZXlmcmFtZSA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVzb2x2ZWRLZXlmcmFtZXNbaW5kZXhdXG4gICAgICAgIDogZmluYWxLZXlmcmFtZTtcbn1cblxuZXhwb3J0IHsgZ2V0RmluYWxLZXlmcmFtZSB9O1xuIiwiaW1wb3J0IHsgdGltZSB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9zeW5jLXRpbWUubWpzJztcbmltcG9ydCB7IGZsdXNoS2V5ZnJhbWVSZXNvbHZlcnMgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvS2V5ZnJhbWVzUmVzb2x2ZXIubWpzJztcbmltcG9ydCB7IGluc3RhbnRBbmltYXRpb25TdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzJztcbmltcG9ydCB7IGNhbkFuaW1hdGUgfSBmcm9tICcuL3V0aWxzL2Nhbi1hbmltYXRlLm1qcyc7XG5pbXBvcnQgeyBnZXRGaW5hbEtleWZyYW1lIH0gZnJvbSAnLi93YWFwaS91dGlscy9nZXQtZmluYWwta2V5ZnJhbWUubWpzJztcblxuLyoqXG4gKiBNYXhpbXVtIHRpbWUgYWxsb3dlZCBiZXR3ZWVuIGFuIGFuaW1hdGlvbiBiZWluZyBjcmVhdGVkIGFuZCBpdCBiZWluZ1xuICogcmVzb2x2ZWQgZm9yIHVzIHRvIHVzZSB0aGUgbGF0dGVyIGFzIHRoZSBzdGFydCB0aW1lLlxuICpcbiAqIFRoaXMgaXMgdG8gZW5zdXJlIHRoYXQgd2hpbGUgd2UgcHJlZmVyIHRvIFwic3RhcnRcIiBhbiBhbmltYXRpb24gYXMgc29vblxuICogYXMgaXQncyB0cmlnZ2VyZWQsIHdlIGFsc28gd2FudCB0byBhdm9pZCBhIHZpc3VhbCBqdW1wIGlmIHRoZXJlJ3MgYSBiaWcgZGVsYXlcbiAqIGJldHdlZW4gdGhlc2UgdHdvIG1vbWVudHMuXG4gKi9cbmNvbnN0IE1BWF9SRVNPTFZFX0RFTEFZID0gNDA7XG5jbGFzcyBCYXNlQW5pbWF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGF1dG9wbGF5ID0gdHJ1ZSwgZGVsYXkgPSAwLCB0eXBlID0gXCJrZXlmcmFtZXNcIiwgcmVwZWF0ID0gMCwgcmVwZWF0RGVsYXkgPSAwLCByZXBlYXRUeXBlID0gXCJsb29wXCIsIC4uLm9wdGlvbnMgfSkge1xuICAgICAgICAvLyBUcmFjayB3aGV0aGVyIHRoZSBhbmltYXRpb24gaGFzIGJlZW4gc3RvcHBlZC4gU3RvcHBlZCBhbmltYXRpb25zIHdvbid0IHJlc3RhcnQuXG4gICAgICAgIHRoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQXR0ZW1wdGVkUmVzb2x2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNyZWF0ZWRBdCA9IHRpbWUubm93KCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGF1dG9wbGF5LFxuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcmVwZWF0LFxuICAgICAgICAgICAgcmVwZWF0RGVsYXksXG4gICAgICAgICAgICByZXBlYXRUeXBlLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXNlcyB0aGUgY3JlYXRlZEF0IGFuZCByZXNvbHZlZEF0IHRvIGNhbGN1bGF0ZSB0aGVcbiAgICAgKiBhbmltYXRpb24gc3RhcnRUaW1lLiAqSWRlYWxseSosIHdlIHdvdWxkIHVzZSB0aGUgY3JlYXRlZEF0IHRpbWUgYXMgdD0wXG4gICAgICogYXMgdGhlIGZvbGxvd2luZyBmcmFtZSB3b3VsZCB0aGVuIGJlIHRoZSBmaXJzdCBmcmFtZSBvZiB0aGUgYW5pbWF0aW9uIGluXG4gICAgICogcHJvZ3Jlc3MsIHdoaWNoIHdvdWxkIGZlZWwgc25hcHBpZXIuXG4gICAgICpcbiAgICAgKiBIb3dldmVyLCBpZiB0aGVyZSdzIGEgZGVsYXkgKG1haW4gdGhyZWFkIHdvcmspIGJldHdlZW4gdGhlIGNyZWF0aW9uIG9mXG4gICAgICogdGhlIGFuaW1hdGlvbiBhbmQgdGhlIGZpcnN0IGNvbW1pdGVkIGZyYW1lLCB3ZSBwcmVmZXIgdG8gdXNlIHJlc29sdmVkQXRcbiAgICAgKiB0byBhdm9pZCBhIHN1ZGRlbiBqdW1wIGludG8gdGhlIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBjYWxjU3RhcnRUaW1lKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZWRBdClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZWRBdDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRBdCAtIHRoaXMuY3JlYXRlZEF0ID4gTUFYX1JFU09MVkVfREVMQVlcbiAgICAgICAgICAgID8gdGhpcy5yZXNvbHZlZEF0XG4gICAgICAgICAgICA6IHRoaXMuY3JlYXRlZEF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGdldHRlciBmb3IgcmVzb2x2ZWQgZGF0YS4gSWYga2V5ZnJhbWVzIGFyZSBub3QgeWV0IHJlc29sdmVkLCBhY2Nlc3NpbmdcbiAgICAgKiB0aGlzLnJlc29sdmVkIHdpbGwgc3luY2hyb25vdXNseSBmbHVzaCBhbGwgcGVuZGluZyBrZXlmcmFtZSByZXNvbHZlcnMuXG4gICAgICogVGhpcyBpcyBhIGRlb3B0aW1pc2F0aW9uLCBidXQgYXQgaXRzIHdvcnN0IHN0aWxsIGJhdGNoZXMgcmVhZC93cml0ZXMuXG4gICAgICovXG4gICAgZ2V0IHJlc29sdmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc29sdmVkICYmICF0aGlzLmhhc0F0dGVtcHRlZFJlc29sdmUpIHtcbiAgICAgICAgICAgIGZsdXNoS2V5ZnJhbWVSZXNvbHZlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgbWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBrZXlmcmFtZXMgcmVzb2x2ZXIgY29tcGxldGVzLiBUaGlzIG1ldGhvZFxuICAgICAqIHdpbGwgY2hlY2sgaWYgaXRzIHBvc3NpYmxlIHRvIHJ1biB0aGUgYW5pbWF0aW9uIGFuZCwgaWYgbm90LCBza2lwIGl0LlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCBjYWxsIGluaXRQbGF5YmFjayBvbiB0aGUgaW1wbGVtZW50aW5nIGNsYXNzLlxuICAgICAqL1xuICAgIG9uS2V5ZnJhbWVzUmVzb2x2ZWQoa2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRBdCA9IHRpbWUubm93KCk7XG4gICAgICAgIHRoaXMuaGFzQXR0ZW1wdGVkUmVzb2x2ZSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSwgdmVsb2NpdHksIGRlbGF5LCBvbkNvbXBsZXRlLCBvblVwZGF0ZSwgaXNHZW5lcmF0b3IsIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSBjYW4ndCBhbmltYXRlIHRoaXMgdmFsdWUgd2l0aCB0aGUgcmVzb2x2ZWQga2V5ZnJhbWVzXG4gICAgICAgICAqIHRoZW4gd2Ugc2hvdWxkIGNvbXBsZXRlIGl0IGltbWVkaWF0ZWx5LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFpc0dlbmVyYXRvciAmJiAhY2FuQW5pbWF0ZShrZXlmcmFtZXMsIG5hbWUsIHR5cGUsIHZlbG9jaXR5KSkge1xuICAgICAgICAgICAgLy8gRmluaXNoIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoaW5zdGFudEFuaW1hdGlvblN0YXRlLmN1cnJlbnQgfHwgIWRlbGF5KSB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGUgJiZcbiAgICAgICAgICAgICAgICAgICAgb25VcGRhdGUoZ2V0RmluYWxLZXlmcmFtZShrZXlmcmFtZXMsIHRoaXMub3B0aW9ucywgZmluYWxLZXlmcmFtZSkpO1xuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmlzaCBhZnRlciBhIGRlbGF5XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZHVyYXRpb24gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVkQW5pbWF0aW9uID0gdGhpcy5pbml0UGxheWJhY2soa2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgaWYgKHJlc29sdmVkQW5pbWF0aW9uID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZWQgPSB7XG4gICAgICAgICAgICBrZXlmcmFtZXMsXG4gICAgICAgICAgICBmaW5hbEtleWZyYW1lLFxuICAgICAgICAgICAgLi4ucmVzb2x2ZWRBbmltYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb3N0UmVzb2x2ZWQoKTtcbiAgICB9XG4gICAgb25Qb3N0UmVzb2x2ZWQoKSB7IH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdGhlIHJldHVybmVkIGFuaW1hdGlvbiB0byBiZSBhd2FpdGVkIG9yIHByb21pc2UtY2hhaW5lZC4gQ3VycmVudGx5XG4gICAgICogcmVzb2x2ZXMgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzIGF0IGFsbCBidXQgaW4gYSBmdXR1cmUgdXBkYXRlIGNvdWxkL3Nob3VsZFxuICAgICAqIHJlamVjdCBpZiBpdHMgY2FuY2Vscy5cbiAgICAgKi9cbiAgICB0aGVuKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50RmluaXNoZWRQcm9taXNlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgICAgICB0aGlzLm9wdGlvbnMuZWFzZSA9IFwibGluZWFyXCI7XG4gICAgfVxuICAgIHVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RmluaXNoZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQmFzZUFuaW1hdGlvbiB9O1xuIiwiLypcbiAgVmFsdWUgaW4gcmFuZ2UgZnJvbSBwcm9ncmVzc1xuXG4gIEdpdmVuIGEgbG93ZXIgbGltaXQgYW5kIGFuIHVwcGVyIGxpbWl0LCB3ZSByZXR1cm4gdGhlIHZhbHVlIHdpdGhpblxuICB0aGF0IHJhbmdlIGFzIGV4cHJlc3NlZCBieSBwcm9ncmVzcyAodXN1YWxseSBhIG51bWJlciBmcm9tIDAgdG8gMSlcblxuICBTbyBwcm9ncmVzcyA9IDAuNSB3b3VsZCBjaGFuZ2VcblxuICBmcm9tIC0tLS0tLS0tIHRvXG5cbiAgdG9cblxuICBmcm9tIC0tLS0gdG9cblxuICBFLmcuIGZyb20gPSAxMCwgdG8gPSAyMCwgcHJvZ3Jlc3MgPSAwLjUgPT4gMTVcblxuICBAcGFyYW0gW251bWJlcl06IExvd2VyIGxpbWl0IG9mIHJhbmdlXG4gIEBwYXJhbSBbbnVtYmVyXTogVXBwZXIgbGltaXQgb2YgcmFuZ2VcbiAgQHBhcmFtIFtudW1iZXJdOiBUaGUgcHJvZ3Jlc3MgYmV0d2VlbiBsb3dlciBhbmQgdXBwZXIgbGltaXRzIGV4cHJlc3NlZCAwLTFcbiAgQHJldHVybiBbbnVtYmVyXTogVmFsdWUgYXMgY2FsY3VsYXRlZCBmcm9tIHByb2dyZXNzIHdpdGhpbiByYW5nZSAobm90IGxpbWl0ZWQgd2l0aGluIHJhbmdlKVxuKi9cbmNvbnN0IG1peE51bWJlciA9IChmcm9tLCB0bywgcHJvZ3Jlc3MpID0+IHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogcHJvZ3Jlc3M7XG59O1xuXG5leHBvcnQgeyBtaXhOdW1iZXIgfTtcbiIsIi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tamFja3Nvbi81MzExMjU2XG5mdW5jdGlvbiBodWVUb1JnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKVxuICAgICAgICB0ICs9IDE7XG4gICAgaWYgKHQgPiAxKVxuICAgICAgICB0IC09IDE7XG4gICAgaWYgKHQgPCAxIC8gNilcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgaWYgKHQgPCAxIC8gMilcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgaWYgKHQgPCAyIC8gMylcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaHNsYVRvUmdiYSh7IGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSB9KSB7XG4gICAgaHVlIC89IDM2MDtcbiAgICBzYXR1cmF0aW9uIC89IDEwMDtcbiAgICBsaWdodG5lc3MgLz0gMTAwO1xuICAgIGxldCByZWQgPSAwO1xuICAgIGxldCBncmVlbiA9IDA7XG4gICAgbGV0IGJsdWUgPSAwO1xuICAgIGlmICghc2F0dXJhdGlvbikge1xuICAgICAgICByZWQgPSBncmVlbiA9IGJsdWUgPSBsaWdodG5lc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBxID0gbGlnaHRuZXNzIDwgMC41XG4gICAgICAgICAgICA/IGxpZ2h0bmVzcyAqICgxICsgc2F0dXJhdGlvbilcbiAgICAgICAgICAgIDogbGlnaHRuZXNzICsgc2F0dXJhdGlvbiAtIGxpZ2h0bmVzcyAqIHNhdHVyYXRpb247XG4gICAgICAgIGNvbnN0IHAgPSAyICogbGlnaHRuZXNzIC0gcTtcbiAgICAgICAgcmVkID0gaHVlVG9SZ2IocCwgcSwgaHVlICsgMSAvIDMpO1xuICAgICAgICBncmVlbiA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSk7XG4gICAgICAgIGJsdWUgPSBodWVUb1JnYihwLCBxLCBodWUgLSAxIC8gMyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZDogTWF0aC5yb3VuZChyZWQgKiAyNTUpLFxuICAgICAgICBncmVlbjogTWF0aC5yb3VuZChncmVlbiAqIDI1NSksXG4gICAgICAgIGJsdWU6IE1hdGgucm91bmQoYmx1ZSAqIDI1NSksXG4gICAgICAgIGFscGhhLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGhzbGFUb1JnYmEgfTtcbiIsImZ1bmN0aW9uIG1peEltbWVkaWF0ZShhLCBiKSB7XG4gICAgcmV0dXJuIChwKSA9PiAocCA+IDAgPyBiIDogYSk7XG59XG5cbmV4cG9ydCB7IG1peEltbWVkaWF0ZSB9O1xuIiwiaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi9udW1iZXIubWpzJztcbmltcG9ydCB7IHdhcm5pbmcgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgaHNsYVRvUmdiYSB9IGZyb20gJy4uL2hzbGEtdG8tcmdiYS5tanMnO1xuaW1wb3J0IHsgaGV4IH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvY29sb3IvaGV4Lm1qcyc7XG5pbXBvcnQgeyByZ2JhIH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvY29sb3IvcmdiYS5tanMnO1xuaW1wb3J0IHsgaHNsYSB9IGZyb20gJy4uLy4uL3ZhbHVlL3R5cGVzL2NvbG9yL2hzbGEubWpzJztcbmltcG9ydCB7IG1peEltbWVkaWF0ZSB9IGZyb20gJy4vaW1tZWRpYXRlLm1qcyc7XG5cbi8vIExpbmVhciBjb2xvciBzcGFjZSBibGVuZGluZ1xuLy8gRXhwbGFpbmVkIGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9TEtucUVDY2c2R3dcbi8vIERlbW9uc3RyYXRlZCBodHRwOi8vY29kZXBlbi5pby9vc3VibGFrZS9wZW4veEdWVmFOXG5jb25zdCBtaXhMaW5lYXJDb2xvciA9IChmcm9tLCB0bywgdikgPT4ge1xuICAgIGNvbnN0IGZyb21FeHBvID0gZnJvbSAqIGZyb207XG4gICAgY29uc3QgZXhwbyA9IHYgKiAodG8gKiB0byAtIGZyb21FeHBvKSArIGZyb21FeHBvO1xuICAgIHJldHVybiBleHBvIDwgMCA/IDAgOiBNYXRoLnNxcnQoZXhwbyk7XG59O1xuY29uc3QgY29sb3JUeXBlcyA9IFtoZXgsIHJnYmEsIGhzbGFdO1xuY29uc3QgZ2V0Q29sb3JUeXBlID0gKHYpID0+IGNvbG9yVHlwZXMuZmluZCgodHlwZSkgPT4gdHlwZS50ZXN0KHYpKTtcbmZ1bmN0aW9uIGFzUkdCQShjb2xvcikge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRDb2xvclR5cGUoY29sb3IpO1xuICAgIHdhcm5pbmcoQm9vbGVhbih0eXBlKSwgYCcke2NvbG9yfScgaXMgbm90IGFuIGFuaW1hdGFibGUgY29sb3IuIFVzZSB0aGUgZXF1aXZhbGVudCBjb2xvciBjb2RlIGluc3RlYWQuYCk7XG4gICAgaWYgKCFCb29sZWFuKHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG1vZGVsID0gdHlwZS5wYXJzZShjb2xvcik7XG4gICAgaWYgKHR5cGUgPT09IGhzbGEpIHtcbiAgICAgICAgLy8gVE9ETyBSZW1vdmUgdGhpcyBjYXN0IC0gbmVlZGVkIHNpbmNlIE1vdGlvbidzIHN0cmljdGVyIHR5cGluZ1xuICAgICAgICBtb2RlbCA9IGhzbGFUb1JnYmEobW9kZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG59XG5jb25zdCBtaXhDb2xvciA9IChmcm9tLCB0bykgPT4ge1xuICAgIGNvbnN0IGZyb21SR0JBID0gYXNSR0JBKGZyb20pO1xuICAgIGNvbnN0IHRvUkdCQSA9IGFzUkdCQSh0byk7XG4gICAgaWYgKCFmcm9tUkdCQSB8fCAhdG9SR0JBKSB7XG4gICAgICAgIHJldHVybiBtaXhJbW1lZGlhdGUoZnJvbSwgdG8pO1xuICAgIH1cbiAgICBjb25zdCBibGVuZGVkID0geyAuLi5mcm9tUkdCQSB9O1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBibGVuZGVkLnJlZCA9IG1peExpbmVhckNvbG9yKGZyb21SR0JBLnJlZCwgdG9SR0JBLnJlZCwgdik7XG4gICAgICAgIGJsZW5kZWQuZ3JlZW4gPSBtaXhMaW5lYXJDb2xvcihmcm9tUkdCQS5ncmVlbiwgdG9SR0JBLmdyZWVuLCB2KTtcbiAgICAgICAgYmxlbmRlZC5ibHVlID0gbWl4TGluZWFyQ29sb3IoZnJvbVJHQkEuYmx1ZSwgdG9SR0JBLmJsdWUsIHYpO1xuICAgICAgICBibGVuZGVkLmFscGhhID0gbWl4TnVtYmVyKGZyb21SR0JBLmFscGhhLCB0b1JHQkEuYWxwaGEsIHYpO1xuICAgICAgICByZXR1cm4gcmdiYS50cmFuc2Zvcm0oYmxlbmRlZCk7XG4gICAgfTtcbn07XG5cbmV4cG9ydCB7IG1peENvbG9yLCBtaXhMaW5lYXJDb2xvciB9O1xuIiwiLyoqXG4gKiBQaXBlXG4gKiBDb21wb3NlIG90aGVyIHRyYW5zZm9ybWVycyB0byBydW4gbGluZWFyaWx5XG4gKiBwaXBlKG1pbigyMCksIG1heCg0MCkpXG4gKiBAcGFyYW0gIHsuLi5mdW5jdGlvbnN9IHRyYW5zZm9ybWVyc1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmNvbnN0IGNvbWJpbmVGdW5jdGlvbnMgPSAoYSwgYikgPT4gKHYpID0+IGIoYSh2KSk7XG5jb25zdCBwaXBlID0gKC4uLnRyYW5zZm9ybWVycykgPT4gdHJhbnNmb3JtZXJzLnJlZHVjZShjb21iaW5lRnVuY3Rpb25zKTtcblxuZXhwb3J0IHsgcGlwZSB9O1xuIiwiY29uc3QgaW52aXNpYmxlVmFsdWVzID0gbmV3IFNldChbXCJub25lXCIsIFwiaGlkZGVuXCJdKTtcbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gcHJvdmlkZWQgYSBwcm9ncmVzcyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDEsXG4gKiB3aWxsIHJldHVybiB0aGUgXCJub25lXCIgb3IgXCJoaWRkZW5cIiBzdHJpbmcgb25seSB3aGVuIHRoZSBwcm9ncmVzcyBpcyB0aGF0IG9mXG4gKiB0aGUgb3JpZ2luIG9yIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gbWl4VmlzaWJpbGl0eShvcmlnaW4sIHRhcmdldCkge1xuICAgIGlmIChpbnZpc2libGVWYWx1ZXMuaGFzKG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIChwKSA9PiAocCA8PSAwID8gb3JpZ2luIDogdGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAocCkgPT4gKHAgPj0gMSA/IHRhcmdldCA6IG9yaWdpbik7XG4gICAgfVxufVxuXG5leHBvcnQgeyBpbnZpc2libGVWYWx1ZXMsIG1peFZpc2liaWxpdHkgfTtcbiIsImltcG9ydCB7IG1peE51bWJlciBhcyBtaXhOdW1iZXIkMSB9IGZyb20gJy4vbnVtYmVyLm1qcyc7XG5pbXBvcnQgeyBtaXhDb2xvciB9IGZyb20gJy4vY29sb3IubWpzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICcuLi9waXBlLm1qcyc7XG5pbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvY29sb3IvaW5kZXgubWpzJztcbmltcG9ydCB7IGNvbXBsZXgsIGFuYWx5c2VDb21wbGV4VmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS90eXBlcy9jb21wbGV4L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc0NTU1ZhcmlhYmxlVG9rZW4gfSBmcm9tICcuLi8uLi9yZW5kZXIvZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanMnO1xuaW1wb3J0IHsgaW52aXNpYmxlVmFsdWVzLCBtaXhWaXNpYmlsaXR5IH0gZnJvbSAnLi92aXNpYmlsaXR5Lm1qcyc7XG5pbXBvcnQgeyBtaXhJbW1lZGlhdGUgfSBmcm9tICcuL2ltbWVkaWF0ZS5tanMnO1xuXG5mdW5jdGlvbiBtaXhOdW1iZXIoYSwgYikge1xuICAgIHJldHVybiAocCkgPT4gbWl4TnVtYmVyJDEoYSwgYiwgcCk7XG59XG5mdW5jdGlvbiBnZXRNaXhlcihhKSB7XG4gICAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBtaXhOdW1iZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBpc0NTU1ZhcmlhYmxlVG9rZW4oYSlcbiAgICAgICAgICAgID8gbWl4SW1tZWRpYXRlXG4gICAgICAgICAgICA6IGNvbG9yLnRlc3QoYSlcbiAgICAgICAgICAgICAgICA/IG1peENvbG9yXG4gICAgICAgICAgICAgICAgOiBtaXhDb21wbGV4O1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIHJldHVybiBtaXhBcnJheTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yLnRlc3QoYSkgPyBtaXhDb2xvciA6IG1peE9iamVjdDtcbiAgICB9XG4gICAgcmV0dXJuIG1peEltbWVkaWF0ZTtcbn1cbmZ1bmN0aW9uIG1peEFycmF5KGEsIGIpIHtcbiAgICBjb25zdCBvdXRwdXQgPSBbLi4uYV07XG4gICAgY29uc3QgbnVtVmFsdWVzID0gb3V0cHV0Lmxlbmd0aDtcbiAgICBjb25zdCBibGVuZFZhbHVlID0gYS5tYXAoKHYsIGkpID0+IGdldE1peGVyKHYpKHYsIGJbaV0pKTtcbiAgICByZXR1cm4gKHApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gYmxlbmRWYWx1ZVtpXShwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtaXhPYmplY3QoYSwgYikge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGNvbnN0IGJsZW5kVmFsdWUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gdW5kZWZpbmVkICYmIGJba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibGVuZFZhbHVlW2tleV0gPSBnZXRNaXhlcihhW2tleV0pKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYmxlbmRWYWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBibGVuZFZhbHVlW2tleV0odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWF0Y2hPcmRlcihvcmlnaW4sIHRhcmdldCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBvcmRlcmVkT3JpZ2luID0gW107XG4gICAgY29uc3QgcG9pbnRlcnMgPSB7IGNvbG9yOiAwLCB2YXI6IDAsIG51bWJlcjogMCB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0LnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gdGFyZ2V0LnR5cGVzW2ldO1xuICAgICAgICBjb25zdCBvcmlnaW5JbmRleCA9IG9yaWdpbi5pbmRleGVzW3R5cGVdW3BvaW50ZXJzW3R5cGVdXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luVmFsdWUgPSAoX2EgPSBvcmlnaW4udmFsdWVzW29yaWdpbkluZGV4XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgb3JkZXJlZE9yaWdpbltpXSA9IG9yaWdpblZhbHVlO1xuICAgICAgICBwb2ludGVyc1t0eXBlXSsrO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXJlZE9yaWdpbjtcbn1cbmNvbnN0IG1peENvbXBsZXggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodGFyZ2V0KTtcbiAgICBjb25zdCBvcmlnaW5TdGF0cyA9IGFuYWx5c2VDb21wbGV4VmFsdWUob3JpZ2luKTtcbiAgICBjb25zdCB0YXJnZXRTdGF0cyA9IGFuYWx5c2VDb21wbGV4VmFsdWUodGFyZ2V0KTtcbiAgICBjb25zdCBjYW5JbnRlcnBvbGF0ZSA9IG9yaWdpblN0YXRzLmluZGV4ZXMudmFyLmxlbmd0aCA9PT0gdGFyZ2V0U3RhdHMuaW5kZXhlcy52YXIubGVuZ3RoICYmXG4gICAgICAgIG9yaWdpblN0YXRzLmluZGV4ZXMuY29sb3IubGVuZ3RoID09PSB0YXJnZXRTdGF0cy5pbmRleGVzLmNvbG9yLmxlbmd0aCAmJlxuICAgICAgICBvcmlnaW5TdGF0cy5pbmRleGVzLm51bWJlci5sZW5ndGggPj0gdGFyZ2V0U3RhdHMuaW5kZXhlcy5udW1iZXIubGVuZ3RoO1xuICAgIGlmIChjYW5JbnRlcnBvbGF0ZSkge1xuICAgICAgICBpZiAoKGludmlzaWJsZVZhbHVlcy5oYXMob3JpZ2luKSAmJlxuICAgICAgICAgICAgIXRhcmdldFN0YXRzLnZhbHVlcy5sZW5ndGgpIHx8XG4gICAgICAgICAgICAoaW52aXNpYmxlVmFsdWVzLmhhcyh0YXJnZXQpICYmXG4gICAgICAgICAgICAgICAgIW9yaWdpblN0YXRzLnZhbHVlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4VmlzaWJpbGl0eShvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpcGUobWl4QXJyYXkobWF0Y2hPcmRlcihvcmlnaW5TdGF0cywgdGFyZ2V0U3RhdHMpLCB0YXJnZXRTdGF0cy52YWx1ZXMpLCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHRydWUsIGBDb21wbGV4IHZhbHVlcyAnJHtvcmlnaW59JyBhbmQgJyR7dGFyZ2V0fScgdG9vIGRpZmZlcmVudCB0byBtaXguIEVuc3VyZSBhbGwgY29sb3JzIGFyZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgdGhhdCBlYWNoIGNvbnRhaW5zIHRoZSBzYW1lIHF1YW50aXR5IG9mIG51bWJlciBhbmQgY29sb3IgdmFsdWVzLiBGYWxsaW5nIGJhY2sgdG8gaW5zdGFudCB0cmFuc2l0aW9uLmApO1xuICAgICAgICByZXR1cm4gbWl4SW1tZWRpYXRlKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBnZXRNaXhlciwgbWl4QXJyYXksIG1peENvbXBsZXgsIG1peE9iamVjdCB9O1xuIiwiaW1wb3J0IHsgZ2V0TWl4ZXIgfSBmcm9tICcuL2NvbXBsZXgubWpzJztcbmltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4vbnVtYmVyLm1qcyc7XG5cbmZ1bmN0aW9uIG1peChmcm9tLCB0bywgcCkge1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIHAgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG1peE51bWJlcihmcm9tLCB0bywgcCk7XG4gICAgfVxuICAgIGNvbnN0IG1peGVyID0gZ2V0TWl4ZXIoZnJvbSk7XG4gICAgcmV0dXJuIG1peGVyKGZyb20sIHRvKTtcbn1cblxuZXhwb3J0IHsgbWl4IH07XG4iLCJpbXBvcnQgeyB2ZWxvY2l0eVBlclNlY29uZCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3ZlbG9jaXR5LXBlci1zZWNvbmQubWpzJztcblxuY29uc3QgdmVsb2NpdHlTYW1wbGVEdXJhdGlvbiA9IDU7IC8vIG1zXG5mdW5jdGlvbiBjYWxjR2VuZXJhdG9yVmVsb2NpdHkocmVzb2x2ZVZhbHVlLCB0LCBjdXJyZW50KSB7XG4gICAgY29uc3QgcHJldlQgPSBNYXRoLm1heCh0IC0gdmVsb2NpdHlTYW1wbGVEdXJhdGlvbiwgMCk7XG4gICAgcmV0dXJuIHZlbG9jaXR5UGVyU2Vjb25kKGN1cnJlbnQgLSByZXNvbHZlVmFsdWUocHJldlQpLCB0IC0gcHJldlQpO1xufVxuXG5leHBvcnQgeyBjYWxjR2VuZXJhdG9yVmVsb2NpdHkgfTtcbiIsImNvbnN0IHNwcmluZ0RlZmF1bHRzID0ge1xuICAgIC8vIERlZmF1bHQgc3ByaW5nIHBoeXNpY3NcbiAgICBzdGlmZm5lc3M6IDEwMCxcbiAgICBkYW1waW5nOiAxMCxcbiAgICBtYXNzOiAxLjAsXG4gICAgdmVsb2NpdHk6IDAuMCxcbiAgICAvLyBEZWZhdWx0IGR1cmF0aW9uL2JvdW5jZS1iYXNlZCBvcHRpb25zXG4gICAgZHVyYXRpb246IDgwMCwgLy8gaW4gbXNcbiAgICBib3VuY2U6IDAuMyxcbiAgICB2aXN1YWxEdXJhdGlvbjogMC4zLCAvLyBpbiBzZWNvbmRzXG4gICAgLy8gUmVzdCB0aHJlc2hvbGRzXG4gICAgcmVzdFNwZWVkOiB7XG4gICAgICAgIGdyYW51bGFyOiAwLjAxLFxuICAgICAgICBkZWZhdWx0OiAyLFxuICAgIH0sXG4gICAgcmVzdERlbHRhOiB7XG4gICAgICAgIGdyYW51bGFyOiAwLjAwNSxcbiAgICAgICAgZGVmYXVsdDogMC41LFxuICAgIH0sXG4gICAgLy8gTGltaXRzXG4gICAgbWluRHVyYXRpb246IDAuMDEsIC8vIGluIHNlY29uZHNcbiAgICBtYXhEdXJhdGlvbjogMTAuMCwgLy8gaW4gc2Vjb25kc1xuICAgIG1pbkRhbXBpbmc6IDAuMDUsXG4gICAgbWF4RGFtcGluZzogMSxcbn07XG5cbmV4cG9ydCB7IHNwcmluZ0RlZmF1bHRzIH07XG4iLCJpbXBvcnQgeyB3YXJuaW5nLCBzZWNvbmRzVG9NaWxsaXNlY29uZHMsIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBjbGFtcCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2NsYW1wLm1qcyc7XG5pbXBvcnQgeyBzcHJpbmdEZWZhdWx0cyB9IGZyb20gJy4vZGVmYXVsdHMubWpzJztcblxuY29uc3Qgc2FmZU1pbiA9IDAuMDAxO1xuZnVuY3Rpb24gZmluZFNwcmluZyh7IGR1cmF0aW9uID0gc3ByaW5nRGVmYXVsdHMuZHVyYXRpb24sIGJvdW5jZSA9IHNwcmluZ0RlZmF1bHRzLmJvdW5jZSwgdmVsb2NpdHkgPSBzcHJpbmdEZWZhdWx0cy52ZWxvY2l0eSwgbWFzcyA9IHNwcmluZ0RlZmF1bHRzLm1hc3MsIH0pIHtcbiAgICBsZXQgZW52ZWxvcGU7XG4gICAgbGV0IGRlcml2YXRpdmU7XG4gICAgd2FybmluZyhkdXJhdGlvbiA8PSBzZWNvbmRzVG9NaWxsaXNlY29uZHMoc3ByaW5nRGVmYXVsdHMubWF4RHVyYXRpb24pLCBcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtcbiAgICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgICAvKipcbiAgICAgKiBSZXN0cmljdCBkYW1waW5nUmF0aW8gYW5kIGR1cmF0aW9uIHRvIHdpdGhpbiBhY2NlcHRhYmxlIHJhbmdlcy5cbiAgICAgKi9cbiAgICBkYW1waW5nUmF0aW8gPSBjbGFtcChzcHJpbmdEZWZhdWx0cy5taW5EYW1waW5nLCBzcHJpbmdEZWZhdWx0cy5tYXhEYW1waW5nLCBkYW1waW5nUmF0aW8pO1xuICAgIGR1cmF0aW9uID0gY2xhbXAoc3ByaW5nRGVmYXVsdHMubWluRHVyYXRpb24sIHNwcmluZ0RlZmF1bHRzLm1heER1cmF0aW9uLCBtaWxsaXNlY29uZHNUb1NlY29uZHMoZHVyYXRpb24pKTtcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5kZXJkYW1wZWQgc3ByaW5nXG4gICAgICAgICAqL1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBleHBvbmVudGlhbERlY2F5IC0gdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBiID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVNaW4gLSAoYSAvIGIpICogYztcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkZWx0YSAqIHZlbG9jaXR5ICsgdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBlID0gTWF0aC5wb3coZGFtcGluZ1JhdGlvLCAyKSAqIE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgY29uc3QgZyA9IGNhbGNBbmd1bGFyRnJlcShNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gLWVudmVsb3BlKHVuZGFtcGVkRnJlcSkgKyBzYWZlTWluID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiAoZmFjdG9yICogKChkIC0gZSkgKiBmKSkgLyBnO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyaXRpY2FsbHktZGFtcGVkIHNwcmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodW5kYW1wZWRGcmVxIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIC1zYWZlTWluICsgYSAqIGI7XG4gICAgICAgIH07XG4gICAgICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodmVsb2NpdHkgLSB1bmRhbXBlZEZyZXEpICogKGR1cmF0aW9uICogZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsR3Vlc3MgPSA1IC8gZHVyYXRpb247XG4gICAgY29uc3QgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICAgIGR1cmF0aW9uID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGR1cmF0aW9uKTtcbiAgICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzOiBzcHJpbmdEZWZhdWx0cy5zdGlmZm5lc3MsXG4gICAgICAgICAgICBkYW1waW5nOiBzcHJpbmdEZWZhdWx0cy5kYW1waW5nLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdGlmZm5lc3MgPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogbWFzcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0aWZmbmVzcyxcbiAgICAgICAgICAgIGRhbXBpbmc6IGRhbXBpbmdSYXRpbyAqIDIgKiBNYXRoLnNxcnQobWFzcyAqIHN0aWZmbmVzcyksXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCByb290SXRlcmF0aW9ucyA9IDEyO1xuZnVuY3Rpb24gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm9vdEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgLSBlbnZlbG9wZShyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKSB7XG4gICAgcmV0dXJuIHVuZGFtcGVkRnJlcSAqIE1hdGguc3FydCgxIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbn1cblxuZXhwb3J0IHsgY2FsY0FuZ3VsYXJGcmVxLCBmaW5kU3ByaW5nIH07XG4iLCJpbXBvcnQgeyBjYWxjR2VuZXJhdG9yRHVyYXRpb24sIG1heEdlbmVyYXRvckR1cmF0aW9uLCBnZW5lcmF0ZUxpbmVhckVhc2luZyB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgbWlsbGlzZWNvbmRzVG9TZWNvbmRzLCBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi8uLi91dGlscy9jbGFtcC5tanMnO1xuaW1wb3J0IHsgY2FsY0dlbmVyYXRvclZlbG9jaXR5IH0gZnJvbSAnLi4vdXRpbHMvdmVsb2NpdHkubWpzJztcbmltcG9ydCB7IHNwcmluZ0RlZmF1bHRzIH0gZnJvbSAnLi9kZWZhdWx0cy5tanMnO1xuaW1wb3J0IHsgZmluZFNwcmluZywgY2FsY0FuZ3VsYXJGcmVxIH0gZnJvbSAnLi9maW5kLm1qcyc7XG5cbmNvbnN0IGR1cmF0aW9uS2V5cyA9IFtcImR1cmF0aW9uXCIsIFwiYm91bmNlXCJdO1xuY29uc3QgcGh5c2ljc0tleXMgPSBbXCJzdGlmZm5lc3NcIiwgXCJkYW1waW5nXCIsIFwibWFzc1wiXTtcbmZ1bmN0aW9uIGlzU3ByaW5nVHlwZShvcHRpb25zLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMuc29tZSgoa2V5KSA9PiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBsZXQgc3ByaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgdmVsb2NpdHk6IHNwcmluZ0RlZmF1bHRzLnZlbG9jaXR5LFxuICAgICAgICBzdGlmZm5lc3M6IHNwcmluZ0RlZmF1bHRzLnN0aWZmbmVzcyxcbiAgICAgICAgZGFtcGluZzogc3ByaW5nRGVmYXVsdHMuZGFtcGluZyxcbiAgICAgICAgbWFzczogc3ByaW5nRGVmYXVsdHMubWFzcyxcbiAgICAgICAgaXNSZXNvbHZlZEZyb21EdXJhdGlvbjogZmFsc2UsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICAvLyBzdGlmZm5lc3MvZGFtcGluZy9tYXNzIG92ZXJyaWRlcyBkdXJhdGlvbi9ib3VuY2VcbiAgICBpZiAoIWlzU3ByaW5nVHlwZShvcHRpb25zLCBwaHlzaWNzS2V5cykgJiZcbiAgICAgICAgaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGR1cmF0aW9uS2V5cykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudmlzdWFsRHVyYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHZpc3VhbER1cmF0aW9uID0gb3B0aW9ucy52aXN1YWxEdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSAoMiAqIE1hdGguUEkpIC8gKHZpc3VhbER1cmF0aW9uICogMS4yKTtcbiAgICAgICAgICAgIGNvbnN0IHN0aWZmbmVzcyA9IHJvb3QgKiByb290O1xuICAgICAgICAgICAgY29uc3QgZGFtcGluZyA9IDIgKlxuICAgICAgICAgICAgICAgIGNsYW1wKDAuMDUsIDEsIDEgLSAob3B0aW9ucy5ib3VuY2UgfHwgMCkpICpcbiAgICAgICAgICAgICAgICBNYXRoLnNxcnQoc3RpZmZuZXNzKTtcbiAgICAgICAgICAgIHNwcmluZ09wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3ByaW5nT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtYXNzOiBzcHJpbmdEZWZhdWx0cy5tYXNzLFxuICAgICAgICAgICAgICAgIHN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICBkYW1waW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlcml2ZWQgPSBmaW5kU3ByaW5nKG9wdGlvbnMpO1xuICAgICAgICAgICAgc3ByaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi5zcHJpbmdPcHRpb25zLFxuICAgICAgICAgICAgICAgIC4uLmRlcml2ZWQsXG4gICAgICAgICAgICAgICAgbWFzczogc3ByaW5nRGVmYXVsdHMubWFzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzcHJpbmdPcHRpb25zLmlzUmVzb2x2ZWRGcm9tRHVyYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcHJpbmdPcHRpb25zO1xufVxuZnVuY3Rpb24gc3ByaW5nKG9wdGlvbnNPclZpc3VhbER1cmF0aW9uID0gc3ByaW5nRGVmYXVsdHMudmlzdWFsRHVyYXRpb24sIGJvdW5jZSA9IHNwcmluZ0RlZmF1bHRzLmJvdW5jZSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uc09yVmlzdWFsRHVyYXRpb24gIT09IFwib2JqZWN0XCJcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB2aXN1YWxEdXJhdGlvbjogb3B0aW9uc09yVmlzdWFsRHVyYXRpb24sXG4gICAgICAgICAgICBrZXlmcmFtZXM6IFswLCAxXSxcbiAgICAgICAgICAgIGJvdW5jZSxcbiAgICAgICAgfVxuICAgICAgICA6IG9wdGlvbnNPclZpc3VhbER1cmF0aW9uO1xuICAgIGxldCB7IHJlc3RTcGVlZCwgcmVzdERlbHRhIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9yaWdpbiA9IG9wdGlvbnMua2V5ZnJhbWVzWzBdO1xuICAgIGNvbnN0IHRhcmdldCA9IG9wdGlvbnMua2V5ZnJhbWVzW29wdGlvbnMua2V5ZnJhbWVzLmxlbmd0aCAtIDFdO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIEl0ZXJhdG9yLXNwZWMgcmV0dXJuIHZhbHVlLiBXZSBlbnN1cmUgaXQncyBtdXRhYmxlIHJhdGhlciB0aGFuIHVzaW5nIGEgZ2VuZXJhdG9yXG4gICAgICogdG8gcmVkdWNlIEdDIGR1cmluZyBhbmltYXRpb24uXG4gICAgICovXG4gICAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb3JpZ2luIH07XG4gICAgY29uc3QgeyBzdGlmZm5lc3MsIGRhbXBpbmcsIG1hc3MsIGR1cmF0aW9uLCB2ZWxvY2l0eSwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbiwgfSA9IGdldFNwcmluZ09wdGlvbnMoe1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB2ZWxvY2l0eTogLW1pbGxpc2Vjb25kc1RvU2Vjb25kcyhvcHRpb25zLnZlbG9jaXR5IHx8IDApLFxuICAgIH0pO1xuICAgIGNvbnN0IGluaXRpYWxWZWxvY2l0eSA9IHZlbG9jaXR5IHx8IDAuMDtcbiAgICBjb25zdCBkYW1waW5nUmF0aW8gPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICAgIGNvbnN0IGluaXRpYWxEZWx0YSA9IHRhcmdldCAtIG9yaWdpbjtcbiAgICBjb25zdCB1bmRhbXBlZEFuZ3VsYXJGcmVxID0gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKE1hdGguc3FydChzdGlmZm5lc3MgLyBtYXNzKSk7XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgd29ya2luZyBvbiBhIGdyYW51bGFyIHNjYWxlLCB1c2Ugc21hbGxlciBkZWZhdWx0cyBmb3IgZGV0ZXJtaW5pbmdcbiAgICAgKiB3aGVuIHRoZSBzcHJpbmcgaXMgZmluaXNoZWQuXG4gICAgICpcbiAgICAgKiBUaGVzZSBkZWZhdWx0cyBoYXZlIGJlZW4gc2VsZWN0ZWQgZW1wcmljYWxseSBiYXNlZCBvbiB3aGF0IHN0cmlrZXMgYSBnb29kXG4gICAgICogcmF0aW8gYmV0d2VlbiBmZWVsaW5nIGdvb2QgYW5kIGZpbmlzaGluZyBhcyBzb29uIGFzIGNoYW5nZXMgYXJlIGltcGVyY2VwdGlibGUuXG4gICAgICovXG4gICAgY29uc3QgaXNHcmFudWxhclNjYWxlID0gTWF0aC5hYnMoaW5pdGlhbERlbHRhKSA8IDU7XG4gICAgcmVzdFNwZWVkIHx8IChyZXN0U3BlZWQgPSBpc0dyYW51bGFyU2NhbGVcbiAgICAgICAgPyBzcHJpbmdEZWZhdWx0cy5yZXN0U3BlZWQuZ3JhbnVsYXJcbiAgICAgICAgOiBzcHJpbmdEZWZhdWx0cy5yZXN0U3BlZWQuZGVmYXVsdCk7XG4gICAgcmVzdERlbHRhIHx8IChyZXN0RGVsdGEgPSBpc0dyYW51bGFyU2NhbGVcbiAgICAgICAgPyBzcHJpbmdEZWZhdWx0cy5yZXN0RGVsdGEuZ3JhbnVsYXJcbiAgICAgICAgOiBzcHJpbmdEZWZhdWx0cy5yZXN0RGVsdGEuZGVmYXVsdCk7XG4gICAgbGV0IHJlc29sdmVTcHJpbmc7XG4gICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgICAgY29uc3QgYW5ndWxhckZyZXEgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRBbmd1bGFyRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgLy8gVW5kZXJkYW1wZWQgc3ByaW5nXG4gICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgcmV0dXJuICh0YXJnZXQgLVxuICAgICAgICAgICAgICAgIGVudmVsb3BlICpcbiAgICAgICAgICAgICAgICAgICAgKCgoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJGcmVxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGFtcGluZ1JhdGlvID09PSAxKSB7XG4gICAgICAgIC8vIENyaXRpY2FsbHkgZGFtcGVkIHNwcmluZ1xuICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHRhcmdldCAtXG4gICAgICAgICAgICBNYXRoLmV4cCgtdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpICpcbiAgICAgICAgICAgICAgICAoaW5pdGlhbERlbHRhICtcbiAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxWZWxvY2l0eSArIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICogdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBPdmVyZGFtcGVkIHNwcmluZ1xuICAgICAgICBjb25zdCBkYW1wZWRBbmd1bGFyRnJlcSA9IHVuZGFtcGVkQW5ndWxhckZyZXEgKiBNYXRoLnNxcnQoZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvIC0gMSk7XG4gICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIHNpbmggb3IgY29zaCB2YWx1ZXMgY2FuIGhpdCBJbmZpbml0eSBzbyB3ZSBjYXAgdGhlbSBoZXJlXG4gICAgICAgICAgICBjb25zdCBmcmVxRm9yVCA9IE1hdGgubWluKGRhbXBlZEFuZ3VsYXJGcmVxICogdCwgMzAwKTtcbiAgICAgICAgICAgIHJldHVybiAodGFyZ2V0IC1cbiAgICAgICAgICAgICAgICAoZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAoKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbmgoZnJlcUZvclQpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY29zaChmcmVxRm9yVCkpKSAvXG4gICAgICAgICAgICAgICAgICAgIGRhbXBlZEFuZ3VsYXJGcmVxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgZ2VuZXJhdG9yID0ge1xuICAgICAgICBjYWxjdWxhdGVkRHVyYXRpb246IGlzUmVzb2x2ZWRGcm9tRHVyYXRpb24gPyBkdXJhdGlvbiB8fCBudWxsIDogbnVsbCxcbiAgICAgICAgbmV4dDogKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZXNvbHZlU3ByaW5nKHQpO1xuICAgICAgICAgICAgaWYgKCFpc1Jlc29sdmVkRnJvbUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRWZWxvY2l0eSA9IDAuMDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXZSBvbmx5IG5lZWQgdG8gY2FsY3VsYXRlIHZlbG9jaXR5IGZvciB1bmRlci1kYW1wZWQgc3ByaW5nc1xuICAgICAgICAgICAgICAgICAqIGFzIG92ZXItIGFuZCBjcml0aWNhbGx5LWRhbXBlZCBzcHJpbmdzIGNhbid0IG92ZXJzaG9vdCwgc29cbiAgICAgICAgICAgICAgICAgKiBjaGVja2luZyBvbmx5IGZvciBkaXNwbGFjZW1lbnQgaXMgZW5vdWdoLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWZWxvY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBzZWNvbmRzVG9NaWxsaXNlY29uZHMoaW5pdGlhbFZlbG9jaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY2FsY0dlbmVyYXRvclZlbG9jaXR5KHJlc29sdmVTcHJpbmcsIHQsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgPSBNYXRoLmFicyhjdXJyZW50VmVsb2NpdHkpIDw9IHJlc3RTcGVlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkID0gTWF0aC5hYnModGFyZ2V0IC0gY3VycmVudCkgPD0gcmVzdERlbHRhO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRvbmUgPVxuICAgICAgICAgICAgICAgICAgICBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgJiYgaXNCZWxvd0Rpc3BsYWNlbWVudFRocmVzaG9sZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBzdGF0ZS5kb25lID8gdGFyZ2V0IDogY3VycmVudDtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWREdXJhdGlvbiA9IE1hdGgubWluKGNhbGNHZW5lcmF0b3JEdXJhdGlvbihnZW5lcmF0b3IpLCBtYXhHZW5lcmF0b3JEdXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBlYXNpbmcgPSBnZW5lcmF0ZUxpbmVhckVhc2luZygocHJvZ3Jlc3MpID0+IGdlbmVyYXRvci5uZXh0KGNhbGN1bGF0ZWREdXJhdGlvbiAqIHByb2dyZXNzKS52YWx1ZSwgY2FsY3VsYXRlZER1cmF0aW9uLCAzMCk7XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZER1cmF0aW9uICsgXCJtcyBcIiArIGVhc2luZztcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG59XG5cbmV4cG9ydCB7IHNwcmluZyB9O1xuIiwiaW1wb3J0IHsgc3ByaW5nIH0gZnJvbSAnLi9zcHJpbmcvaW5kZXgubWpzJztcbmltcG9ydCB7IGNhbGNHZW5lcmF0b3JWZWxvY2l0eSB9IGZyb20gJy4vdXRpbHMvdmVsb2NpdHkubWpzJztcblxuZnVuY3Rpb24gaW5lcnRpYSh7IGtleWZyYW1lcywgdmVsb2NpdHkgPSAwLjAsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSAzMjUsIGJvdW5jZURhbXBpbmcgPSAxMCwgYm91bmNlU3RpZmZuZXNzID0gNTAwLCBtb2RpZnlUYXJnZXQsIG1pbiwgbWF4LCByZXN0RGVsdGEgPSAwLjUsIHJlc3RTcGVlZCwgfSkge1xuICAgIGNvbnN0IG9yaWdpbiA9IGtleWZyYW1lc1swXTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgfTtcbiAgICBjb25zdCBpc091dE9mQm91bmRzID0gKHYpID0+IChtaW4gIT09IHVuZGVmaW5lZCAmJiB2IDwgbWluKSB8fCAobWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IG1heCk7XG4gICAgY29uc3QgbmVhcmVzdEJvdW5kYXJ5ID0gKHYpID0+IHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1pbiAtIHYpIDwgTWF0aC5hYnMobWF4IC0gdikgPyBtaW4gOiBtYXg7XG4gICAgfTtcbiAgICBsZXQgYW1wbGl0dWRlID0gcG93ZXIgKiB2ZWxvY2l0eTtcbiAgICBjb25zdCBpZGVhbCA9IG9yaWdpbiArIGFtcGxpdHVkZTtcbiAgICBjb25zdCB0YXJnZXQgPSBtb2RpZnlUYXJnZXQgPT09IHVuZGVmaW5lZCA/IGlkZWFsIDogbW9kaWZ5VGFyZ2V0KGlkZWFsKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGhhcyBjaGFuZ2VkIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZSBhbXBsaXR1ZGUsIG90aGVyd2lzZVxuICAgICAqIHRoZSBhbmltYXRpb24gd2lsbCBzdGFydCBmcm9tIHRoZSB3cm9uZyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBpZiAodGFyZ2V0ICE9PSBpZGVhbClcbiAgICAgICAgYW1wbGl0dWRlID0gdGFyZ2V0IC0gb3JpZ2luO1xuICAgIGNvbnN0IGNhbGNEZWx0YSA9ICh0KSA9PiAtYW1wbGl0dWRlICogTWF0aC5leHAoLXQgLyB0aW1lQ29uc3RhbnQpO1xuICAgIGNvbnN0IGNhbGNMYXRlc3QgPSAodCkgPT4gdGFyZ2V0ICsgY2FsY0RlbHRhKHQpO1xuICAgIGNvbnN0IGFwcGx5RnJpY3Rpb24gPSAodCkgPT4ge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGNhbGNEZWx0YSh0KTtcbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gY2FsY0xhdGVzdCh0KTtcbiAgICAgICAgc3RhdGUuZG9uZSA9IE1hdGguYWJzKGRlbHRhKSA8PSByZXN0RGVsdGE7XG4gICAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRhcmdldCA6IGxhdGVzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElkZWFsbHkgdGhpcyB3b3VsZCByZXNvbHZlIGZvciB0IGluIGEgc3RhdGVsZXNzIHdheSwgd2UgY291bGRcbiAgICAgKiBkbyB0aGF0IGJ5IGFsd2F5cyBwcmVjYWxjdWxhdGluZyB0aGUgYW5pbWF0aW9uIGJ1dCBhcyB3ZSBrbm93XG4gICAgICogdGhpcyB3aWxsIGJlIGRvbmUgYW55d2F5IHdlIGNhbiBhc3N1bWUgdGhhdCBzcHJpbmcgd2lsbFxuICAgICAqIGJlIGRpc2NvdmVyZWQgZHVyaW5nIHRoYXQuXG4gICAgICovXG4gICAgbGV0IHRpbWVSZWFjaGVkQm91bmRhcnk7XG4gICAgbGV0IHNwcmluZyQxO1xuICAgIGNvbnN0IGNoZWNrQ2F0Y2hCb3VuZGFyeSA9ICh0KSA9PiB7XG4gICAgICAgIGlmICghaXNPdXRPZkJvdW5kcyhzdGF0ZS52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRpbWVSZWFjaGVkQm91bmRhcnkgPSB0O1xuICAgICAgICBzcHJpbmckMSA9IHNwcmluZyh7XG4gICAgICAgICAgICBrZXlmcmFtZXM6IFtzdGF0ZS52YWx1ZSwgbmVhcmVzdEJvdW5kYXJ5KHN0YXRlLnZhbHVlKV0sXG4gICAgICAgICAgICB2ZWxvY2l0eTogY2FsY0dlbmVyYXRvclZlbG9jaXR5KGNhbGNMYXRlc3QsIHQsIHN0YXRlLnZhbHVlKSwgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgcGFzc2luZyAqIDEwMDBcbiAgICAgICAgICAgIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsXG4gICAgICAgICAgICBzdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcyxcbiAgICAgICAgICAgIHJlc3REZWx0YSxcbiAgICAgICAgICAgIHJlc3RTcGVlZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjaGVja0NhdGNoQm91bmRhcnkoMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FsY3VsYXRlZER1cmF0aW9uOiBudWxsLFxuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBuZWVkIHRvIHJlc29sdmUgdGhlIGZyaWN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgd2UgbmVlZCBhXG4gICAgICAgICAgICAgKiBzcHJpbmcgYnV0IHdlIGRvbid0IHdhbnQgdG8gZG8gdGhpcyB0d2ljZSBwZXIgZnJhbWUuIFNvIGhlcmVcbiAgICAgICAgICAgICAqIHdlIGZsYWcgaWYgd2UgdXBkYXRlZCBmb3IgdGhpcyBmcmFtZSBhbmQgbGF0ZXIgaWYgd2UgZGlkXG4gICAgICAgICAgICAgKiB3ZSBjYW4gc2tpcCBkb2luZyBpdCBhZ2Fpbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGhhc1VwZGF0ZWRGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzcHJpbmckMSAmJiB0aW1lUmVhY2hlZEJvdW5kYXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYXNVcGRhdGVkRnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFwcGx5RnJpY3Rpb24odCk7XG4gICAgICAgICAgICAgICAgY2hlY2tDYXRjaEJvdW5kYXJ5KHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIGEgc3ByaW5nIGFuZCB0aGUgcHJvdmlkZWQgdCBpcyBiZXlvbmQgdGhlIG1vbWVudCB0aGUgZnJpY3Rpb25cbiAgICAgICAgICAgICAqIGFuaW1hdGlvbiBjcm9zc2VkIHRoZSBtaW4vbWF4IGJvdW5kYXJ5LCB1c2UgdGhlIHNwcmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRpbWVSZWFjaGVkQm91bmRhcnkgIT09IHVuZGVmaW5lZCAmJiB0ID49IHRpbWVSZWFjaGVkQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ByaW5nJDEubmV4dCh0IC0gdGltZVJlYWNoZWRCb3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAhaGFzVXBkYXRlZEZyYW1lICYmIGFwcGx5RnJpY3Rpb24odCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGluZXJ0aWEgfTtcbiIsImltcG9ydCB7IGN1YmljQmV6aWVyIH0gZnJvbSAnLi9jdWJpYy1iZXppZXIubWpzJztcblxuY29uc3QgZWFzZUluID0gLypAX19QVVJFX18qLyBjdWJpY0JlemllcigwLjQyLCAwLCAxLCAxKTtcbmNvbnN0IGVhc2VPdXQgPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAsIDAsIDAuNTgsIDEpO1xuY29uc3QgZWFzZUluT3V0ID0gLypAX19QVVJFX18qLyBjdWJpY0JlemllcigwLjQyLCAwLCAwLjU4LCAxKTtcblxuZXhwb3J0IHsgZWFzZUluLCBlYXNlSW5PdXQsIGVhc2VPdXQgfTtcbiIsImNvbnN0IGlzRWFzaW5nQXJyYXkgPSAoZWFzZSkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVhc2UpICYmIHR5cGVvZiBlYXNlWzBdICE9PSBcIm51bWJlclwiO1xufTtcblxuZXhwb3J0IHsgaXNFYXNpbmdBcnJheSB9O1xuIiwiaW1wb3J0IHsgaXNCZXppZXJEZWZpbml0aW9uIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBpbnZhcmlhbnQsIG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgYW50aWNpcGF0ZSB9IGZyb20gJy4uL2FudGljaXBhdGUubWpzJztcbmltcG9ydCB7IGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0IH0gZnJvbSAnLi4vYmFjay5tanMnO1xuaW1wb3J0IHsgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQgfSBmcm9tICcuLi9jaXJjLm1qcyc7XG5pbXBvcnQgeyBjdWJpY0JlemllciB9IGZyb20gJy4uL2N1YmljLWJlemllci5tanMnO1xuaW1wb3J0IHsgZWFzZUluLCBlYXNlSW5PdXQsIGVhc2VPdXQgfSBmcm9tICcuLi9lYXNlLm1qcyc7XG5cbmNvbnN0IGVhc2luZ0xvb2t1cCA9IHtcbiAgICBsaW5lYXI6IG5vb3AsXG4gICAgZWFzZUluLFxuICAgIGVhc2VJbk91dCxcbiAgICBlYXNlT3V0LFxuICAgIGNpcmNJbixcbiAgICBjaXJjSW5PdXQsXG4gICAgY2lyY091dCxcbiAgICBiYWNrSW4sXG4gICAgYmFja0luT3V0LFxuICAgIGJhY2tPdXQsXG4gICAgYW50aWNpcGF0ZSxcbn07XG5jb25zdCBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiA9IChkZWZpbml0aW9uKSA9PiB7XG4gICAgaWYgKGlzQmV6aWVyRGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAvLyBJZiBjdWJpYyBiZXppZXIgZGVmaW5pdGlvbiwgY3JlYXRlIGJlemllciBjdXJ2ZVxuICAgICAgICBpbnZhcmlhbnQoZGVmaW5pdGlvbi5sZW5ndGggPT09IDQsIGBDdWJpYyBiZXppZXIgYXJyYXlzIG11c3QgY29udGFpbiBmb3VyIG51bWVyaWNhbCB2YWx1ZXMuYCk7XG4gICAgICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBFbHNlIGxvb2t1cCBmcm9tIHRhYmxlXG4gICAgICAgIGludmFyaWFudChlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl0gIT09IHVuZGVmaW5lZCwgYEludmFsaWQgZWFzaW5nIHR5cGUgJyR7ZGVmaW5pdGlvbn0nYCk7XG4gICAgICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcblxuZXhwb3J0IHsgZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24gfTtcbiIsImltcG9ydCB7IGludmFyaWFudCwgbm9vcCwgcHJvZ3Jlc3MgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuL2NsYW1wLm1qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuL21peC9pbmRleC5tanMnO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJy4vcGlwZS5tanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBjdXN0b21NaXhlcikge1xuICAgIGNvbnN0IG1peGVycyA9IFtdO1xuICAgIGNvbnN0IG1peGVyRmFjdG9yeSA9IGN1c3RvbU1peGVyIHx8IG1peDtcbiAgICBjb25zdCBudW1NaXhlcnMgPSBvdXRwdXQubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1peGVyczsgaSsrKSB7XG4gICAgICAgIGxldCBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaV0sIG91dHB1dFtpICsgMV0pO1xuICAgICAgICBpZiAoZWFzZSkge1xuICAgICAgICAgICAgY29uc3QgZWFzaW5nRnVuY3Rpb24gPSBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZVtpXSB8fCBub29wIDogZWFzZTtcbiAgICAgICAgICAgIG1peGVyID0gcGlwZShlYXNpbmdGdW5jdGlvbiwgbWl4ZXIpO1xuICAgICAgICB9XG4gICAgICAgIG1peGVycy5wdXNoKG1peGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1peGVycztcbn1cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBtYXBzIGZyb20gYSBudW1lcmljYWwgaW5wdXQgYXJyYXkgdG8gYSBnZW5lcmljIG91dHB1dCBhcnJheS5cbiAqXG4gKiBBY2NlcHRzOlxuICogICAtIE51bWJlcnNcbiAqICAgLSBDb2xvcnMgKGhleCwgaHNsLCBoc2xhLCByZ2IsIHJnYmEpXG4gKiAgIC0gQ29tcGxleCAoY29tYmluYXRpb25zIG9mIG9uZSBvciBtb3JlIG51bWJlcnMgb3Igc3RyaW5ncylcbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IG1peENvbG9yID0gaW50ZXJwb2xhdGUoWzAsIDFdLCBbJyNmZmYnLCAnIzAwMCddKVxuICpcbiAqIG1peENvbG9yKDAuNSkgLy8gJ3JnYmEoMTI4LCAxMjgsIDEyOCwgMSknXG4gKiBgYGBcbiAqXG4gKiBUT0RPIFJldmlzdCB0aGlzIGFwcHJvYWNoIG9uY2Ugd2UndmUgbW92ZWQgdG8gZGF0YSBtb2RlbHMgZm9yIHZhbHVlcyxcbiAqIHByb2JhYmx5IG5vdCBuZWVkZWQgdG8gcHJlZ2VuZXJhdGUgbWl4ZXIgZnVuY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIG91dHB1dCwgeyBjbGFtcDogaXNDbGFtcCA9IHRydWUsIGVhc2UsIG1peGVyIH0gPSB7fSkge1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGludmFyaWFudChpbnB1dExlbmd0aCA9PT0gb3V0cHV0Lmxlbmd0aCwgXCJCb3RoIGlucHV0IGFuZCBvdXRwdXQgcmFuZ2VzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoXCIpO1xuICAgIC8qKlxuICAgICAqIElmIHdlJ3JlIG9ubHkgcHJvdmlkZWQgYSBzaW5nbGUgaW5wdXQsIHdlIGNhbiBqdXN0IG1ha2UgYSBmdW5jdGlvblxuICAgICAqIHRoYXQgcmV0dXJucyB0aGUgb3V0cHV0LlxuICAgICAqL1xuICAgIGlmIChpbnB1dExlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuICgpID0+IG91dHB1dFswXTtcbiAgICBpZiAoaW5wdXRMZW5ndGggPT09IDIgJiYgb3V0cHV0WzBdID09PSBvdXRwdXRbMV0pXG4gICAgICAgIHJldHVybiAoKSA9PiBvdXRwdXRbMV07XG4gICAgY29uc3QgaXNaZXJvRGVsdGFSYW5nZSA9IGlucHV0WzBdID09PSBpbnB1dFsxXTtcbiAgICAvLyBJZiBpbnB1dCBydW5zIGhpZ2hlc3QgLT4gbG93ZXN0LCByZXZlcnNlIGJvdGggYXJyYXlzXG4gICAgaWYgKGlucHV0WzBdID4gaW5wdXRbaW5wdXRMZW5ndGggLSAxXSkge1xuICAgICAgICBpbnB1dCA9IFsuLi5pbnB1dF0ucmV2ZXJzZSgpO1xuICAgICAgICBvdXRwdXQgPSBbLi4ub3V0cHV0XS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGNvbnN0IG1peGVycyA9IGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIG1peGVyKTtcbiAgICBjb25zdCBudW1NaXhlcnMgPSBtaXhlcnMubGVuZ3RoO1xuICAgIGNvbnN0IGludGVycG9sYXRvciA9ICh2KSA9PiB7XG4gICAgICAgIGlmIChpc1plcm9EZWx0YVJhbmdlICYmIHYgPCBpbnB1dFswXSlcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXRbMF07XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgaWYgKG51bU1peGVycyA+IDEpIHtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaW5wdXQubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHYgPCBpbnB1dFtpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSW5SYW5nZSA9IHByb2dyZXNzKGlucHV0W2ldLCBpbnB1dFtpICsgMV0sIHYpO1xuICAgICAgICByZXR1cm4gbWl4ZXJzW2ldKHByb2dyZXNzSW5SYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gaXNDbGFtcFxuICAgICAgICA/ICh2KSA9PiBpbnRlcnBvbGF0b3IoY2xhbXAoaW5wdXRbMF0sIGlucHV0W2lucHV0TGVuZ3RoIC0gMV0sIHYpKVxuICAgICAgICA6IGludGVycG9sYXRvcjtcbn1cblxuZXhwb3J0IHsgaW50ZXJwb2xhdGUgfTtcbiIsImltcG9ydCB7IHByb2dyZXNzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uL21peC9udW1iZXIubWpzJztcblxuZnVuY3Rpb24gZmlsbE9mZnNldChvZmZzZXQsIHJlbWFpbmluZykge1xuICAgIGNvbnN0IG1pbiA9IG9mZnNldFtvZmZzZXQubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVtYWluaW5nOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0UHJvZ3Jlc3MgPSBwcm9ncmVzcygwLCByZW1haW5pbmcsIGkpO1xuICAgICAgICBvZmZzZXQucHVzaChtaXhOdW1iZXIobWluLCAxLCBvZmZzZXRQcm9ncmVzcykpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZmlsbE9mZnNldCB9O1xuIiwiaW1wb3J0IHsgZmlsbE9mZnNldCB9IGZyb20gJy4vZmlsbC5tanMnO1xuXG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0KGFycikge1xuICAgIGNvbnN0IG9mZnNldCA9IFswXTtcbiAgICBmaWxsT2Zmc2V0KG9mZnNldCwgYXJyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydCB7IGRlZmF1bHRPZmZzZXQgfTtcbiIsImZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cblxuZXhwb3J0IHsgY29udmVydE9mZnNldFRvVGltZXMgfTtcbiIsImltcG9ydCB7IGVhc2VJbk91dCB9IGZyb20gJy4uLy4uL2Vhc2luZy9lYXNlLm1qcyc7XG5pbXBvcnQgeyBpc0Vhc2luZ0FycmF5IH0gZnJvbSAnLi4vLi4vZWFzaW5nL3V0aWxzL2lzLWVhc2luZy1hcnJheS5tanMnO1xuaW1wb3J0IHsgZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9lYXNpbmcvdXRpbHMvbWFwLm1qcyc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2ludGVycG9sYXRlLm1qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T2Zmc2V0IH0gZnJvbSAnLi4vLi4vdXRpbHMvb2Zmc2V0cy9kZWZhdWx0Lm1qcyc7XG5pbXBvcnQgeyBjb252ZXJ0T2Zmc2V0VG9UaW1lcyB9IGZyb20gJy4uLy4uL3V0aWxzL29mZnNldHMvdGltZS5tanMnO1xuXG5mdW5jdGlvbiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKCkgPT4gZWFzaW5nIHx8IGVhc2VJbk91dCkuc3BsaWNlKDAsIHZhbHVlcy5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGR1cmF0aW9uID0gMzAwLCBrZXlmcmFtZXM6IGtleWZyYW1lVmFsdWVzLCB0aW1lcywgZWFzZSA9IFwiZWFzZUluT3V0XCIsIH0pIHtcbiAgICAvKipcbiAgICAgKiBFYXNpbmcgZnVuY3Rpb25zIGNhbiBiZSBleHRlcm5hbGx5IGRlZmluZWQgYXMgc3RyaW5ncy4gSGVyZSB3ZSBjb252ZXJ0IHRoZW1cbiAgICAgKiBpbnRvIGFjdHVhbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY29uc3QgZWFzaW5nRnVuY3Rpb25zID0gaXNFYXNpbmdBcnJheShlYXNlKVxuICAgICAgICA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKVxuICAgICAgICA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIEl0ZXJhdG9yLXNwZWMgcmV0dXJuIHZhbHVlLiBXZSBlbnN1cmUgaXQncyBtdXRhYmxlIHJhdGhlciB0aGFuIHVzaW5nIGEgZ2VuZXJhdG9yXG4gICAgICogdG8gcmVkdWNlIEdDIGR1cmluZyBhbmltYXRpb24uXG4gICAgICovXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZToga2V5ZnJhbWVWYWx1ZXNbMF0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aW1lcyBhcnJheSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgMC0xIG9mZnNldHNcbiAgICAgKi9cbiAgICBjb25zdCBhYnNvbHV0ZVRpbWVzID0gY29udmVydE9mZnNldFRvVGltZXMoXG4gICAgLy8gT25seSB1c2UgdGhlIHByb3ZpZGVkIG9mZnNldHMgaWYgdGhleSdyZSB0aGUgY29ycmVjdCBsZW5ndGhcbiAgICAvLyBUT0RPIE1heWJlIHdlIHNob3VsZCB3YXJuIGhlcmUgaWYgdGhlcmUncyBhIGxlbmd0aCBtaXNtYXRjaFxuICAgIHRpbWVzICYmIHRpbWVzLmxlbmd0aCA9PT0ga2V5ZnJhbWVWYWx1ZXMubGVuZ3RoXG4gICAgICAgID8gdGltZXNcbiAgICAgICAgOiBkZWZhdWx0T2Zmc2V0KGtleWZyYW1lVmFsdWVzKSwgZHVyYXRpb24pO1xuICAgIGNvbnN0IG1hcFRpbWVUb0tleWZyYW1lID0gaW50ZXJwb2xhdGUoYWJzb2x1dGVUaW1lcywga2V5ZnJhbWVWYWx1ZXMsIHtcbiAgICAgICAgZWFzZTogQXJyYXkuaXNBcnJheShlYXNpbmdGdW5jdGlvbnMpXG4gICAgICAgICAgICA/IGVhc2luZ0Z1bmN0aW9uc1xuICAgICAgICAgICAgOiBkZWZhdWx0RWFzaW5nKGtleWZyYW1lVmFsdWVzLCBlYXNpbmdGdW5jdGlvbnMpLFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IG1hcFRpbWVUb0tleWZyYW1lKHQpO1xuICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgZGVmYXVsdEVhc2luZywga2V5ZnJhbWVzIH07XG4iLCJpbXBvcnQgeyB0aW1lIH0gZnJvbSAnLi4vLi4vLi4vZnJhbWVsb29wL3N5bmMtdGltZS5tanMnO1xuaW1wb3J0IHsgZnJhbWUsIGNhbmNlbEZyYW1lLCBmcmFtZURhdGEgfSBmcm9tICcuLi8uLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuY29uc3QgZnJhbWVsb29wRHJpdmVyID0gKHVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IHBhc3NUaW1lc3RhbXAgPSAoeyB0aW1lc3RhbXAgfSkgPT4gdXBkYXRlKHRpbWVzdGFtcCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6ICgpID0+IGZyYW1lLnVwZGF0ZShwYXNzVGltZXN0YW1wLCB0cnVlKSxcbiAgICAgICAgc3RvcDogKCkgPT4gY2FuY2VsRnJhbWUocGFzc1RpbWVzdGFtcCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBwcm9jZXNzaW5nIHRoaXMgZnJhbWUgd2UgY2FuIHVzZSB0aGVcbiAgICAgICAgICogZnJhbWVsb2NrZWQgdGltZXN0YW1wIHRvIGtlZXAgdGhpbmdzIGluIHN5bmMuXG4gICAgICAgICAqL1xuICAgICAgICBub3c6ICgpID0+IChmcmFtZURhdGEuaXNQcm9jZXNzaW5nID8gZnJhbWVEYXRhLnRpbWVzdGFtcCA6IHRpbWUubm93KCkpLFxuICAgIH07XG59O1xuXG5leHBvcnQgeyBmcmFtZWxvb3BEcml2ZXIgfTtcbiIsImltcG9ydCB7IGlzR2VuZXJhdG9yLCBjYWxjR2VuZXJhdG9yRHVyYXRpb24gfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IGludmFyaWFudCwgbWlsbGlzZWNvbmRzVG9TZWNvbmRzLCBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgS2V5ZnJhbWVSZXNvbHZlciB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9LZXlmcmFtZXNSZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi91dGlscy9jbGFtcC5tanMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi4vLi4vdXRpbHMvbWl4L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcGlwZS5tanMnO1xuaW1wb3J0IHsgaW5lcnRpYSB9IGZyb20gJy4uL2dlbmVyYXRvcnMvaW5lcnRpYS5tanMnO1xuaW1wb3J0IHsga2V5ZnJhbWVzIH0gZnJvbSAnLi4vZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzJztcbmltcG9ydCB7IHNwcmluZyB9IGZyb20gJy4uL2dlbmVyYXRvcnMvc3ByaW5nL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBCYXNlQW5pbWF0aW9uIH0gZnJvbSAnLi9CYXNlQW5pbWF0aW9uLm1qcyc7XG5pbXBvcnQgeyBmcmFtZWxvb3BEcml2ZXIgfSBmcm9tICcuL2RyaXZlcnMvZHJpdmVyLWZyYW1lbG9vcC5tanMnO1xuaW1wb3J0IHsgZ2V0RmluYWxLZXlmcmFtZSB9IGZyb20gJy4vd2FhcGkvdXRpbHMvZ2V0LWZpbmFsLWtleWZyYW1lLm1qcyc7XG5cbmNvbnN0IGdlbmVyYXRvcnMgPSB7XG4gICAgZGVjYXk6IGluZXJ0aWEsXG4gICAgaW5lcnRpYSxcbiAgICB0d2Vlbjoga2V5ZnJhbWVzLFxuICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLFxuICAgIHNwcmluZyxcbn07XG5jb25zdCBwZXJjZW50VG9Qcm9ncmVzcyA9IChwZXJjZW50KSA9PiBwZXJjZW50IC8gMTAwO1xuLyoqXG4gKiBBbmltYXRpb24gdGhhdCBydW5zIG9uIHRoZSBtYWluIHRocmVhZC4gRGVzaWduZWQgdG8gYmUgV0FBUEktc3BlYyBpbiB0aGUgc3Vic2V0IG9mXG4gKiBmZWF0dXJlcyB3ZSBleHBvc2UgcHVibGljYWxseS4gTW9zdGx5IHRoZSBjb21wYXRpYmlsaXR5IGlzIHRvIGVuc3VyZSB2aXN1YWwgaWRlbnRpdHlcbiAqIGJldHdlZW4gYm90aCBXQUFQSSBhbmQgbWFpbiB0aHJlYWQgYW5pbWF0aW9ucy5cbiAqL1xuY2xhc3MgTWFpblRocmVhZEFuaW1hdGlvbiBleHRlbmRzIEJhc2VBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBhdCB3aGljaCB0aGUgYW5pbWF0aW9uIHdhcyBwYXVzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvbGRUaW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gd2FzIGNhbmNlbGxlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuY2VsVGltZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCB0aW1lIG9mIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYXliYWNrIHNwZWVkIGFzIGEgZmFjdG9yLiAwIHdvdWxkIGJlIHN0b3BwZWQsIC0xIHJldmVyc2UgYW5kIDIgZG91YmxlIHNwZWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGF5YmFja1NwZWVkID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHRvIGFwcGx5IHdoZW4gdGhlIGFuaW1hdGlvbiBpcyByZXNvbHZlZC4gVGhpc1xuICAgICAgICAgKiBhbGxvd3MgY2FsbHMgdG8gdGhlIHB1YmxpYyBBUEkgdG8gY29udHJvbCB0aGUgYW5pbWF0aW9uIGJlZm9yZSBpdCBpcyByZXNvbHZlZCxcbiAgICAgICAgICogd2l0aG91dCB1cyBoYXZpbmcgdG8gcmVzb2x2ZSBpdCBmaXJzdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9IFwicnVubmluZ1wiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGFuaW1hdGlvbiB3YXMgc3RhcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaWRsZVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgaXMgYm91bmQgdG8gdGhlIGluc3RhbmNlIHRvIGZpeCBhIHBhdHRlcm4gd2hlcmVcbiAgICAgICAgICogYW5pbWF0aW9uLnN0b3AgaXMgcmV0dXJuZWQgYXMgYSByZWZlcmVuY2UgZnJvbSBhIHVzZUVmZmVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJpZGxlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy50ZWFyZG93bigpO1xuICAgICAgICAgICAgY29uc3QgeyBvblN0b3AgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIG9uU3RvcCAmJiBvblN0b3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwga2V5ZnJhbWVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IEtleWZyYW1lUmVzb2x2ZXIkMSA9IChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQuS2V5ZnJhbWVSZXNvbHZlcikgfHwgS2V5ZnJhbWVSZXNvbHZlcjtcbiAgICAgICAgY29uc3Qgb25SZXNvbHZlZCA9IChyZXNvbHZlZEtleWZyYW1lcywgZmluYWxLZXlmcmFtZSkgPT4gdGhpcy5vbktleWZyYW1lc1Jlc29sdmVkKHJlc29sdmVkS2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlciA9IG5ldyBLZXlmcmFtZVJlc29sdmVyJDEoa2V5ZnJhbWVzLCBvblJlc29sdmVkLCBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZXIuc2NoZWR1bGVSZXNvbHZlKCk7XG4gICAgfVxuICAgIGZsYXR0ZW4oKSB7XG4gICAgICAgIHN1cGVyLmZsYXR0ZW4oKTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSByZXNvbHZlZCB0aGUgYW5pbWF0aW9uLCByZS1pbml0aWFsaXNlIGl0XG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9yZXNvbHZlZCwgdGhpcy5pbml0UGxheWJhY2sodGhpcy5fcmVzb2x2ZWQua2V5ZnJhbWVzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdFBsYXliYWNrKGtleWZyYW1lcyQxKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSA9IFwia2V5ZnJhbWVzXCIsIHJlcGVhdCA9IDAsIHJlcGVhdERlbGF5ID0gMCwgcmVwZWF0VHlwZSwgdmVsb2NpdHkgPSAwLCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBnZW5lcmF0b3JGYWN0b3J5ID0gaXNHZW5lcmF0b3IodHlwZSlcbiAgICAgICAgICAgID8gdHlwZVxuICAgICAgICAgICAgOiBnZW5lcmF0b3JzW3R5cGVdIHx8IGtleWZyYW1lcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG91ciBnZW5lcmF0b3IgZG9lc24ndCBzdXBwb3J0IG1peGluZyBudW1iZXJzLCB3ZSBuZWVkIHRvIHJlcGxhY2Uga2V5ZnJhbWVzIHdpdGhcbiAgICAgICAgICogWzAsIDEwMF0gYW5kIHRoZW4gbWFrZSBhIGZ1bmN0aW9uIHRoYXQgbWFwcyB0aGF0IHRvIHRoZSBhY3R1YWwga2V5ZnJhbWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAxMDAgaXMgY2hvc2VuIGluc3RlYWQgb2YgMSBhcyBpdCB3b3JrcyBuaWNlciB3aXRoIHNwcmluZyBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG1hcFBlcmNlbnRUb0tleWZyYW1lcztcbiAgICAgICAgbGV0IG1pcnJvcmVkR2VuZXJhdG9yO1xuICAgICAgICBpZiAoZ2VuZXJhdG9yRmFjdG9yeSAhPT0ga2V5ZnJhbWVzICYmXG4gICAgICAgICAgICB0eXBlb2Yga2V5ZnJhbWVzJDFbMF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnQoa2V5ZnJhbWVzJDEubGVuZ3RoID09PSAyLCBgT25seSB0d28ga2V5ZnJhbWVzIGN1cnJlbnRseSBzdXBwb3J0ZWQgd2l0aCBzcHJpbmcgYW5kIGluZXJ0aWEgYW5pbWF0aW9ucy4gVHJ5aW5nIHRvIGFuaW1hdGUgJHtrZXlmcmFtZXMkMX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFBlcmNlbnRUb0tleWZyYW1lcyA9IHBpcGUocGVyY2VudFRvUHJvZ3Jlc3MsIG1peChrZXlmcmFtZXMkMVswXSwga2V5ZnJhbWVzJDFbMV0pKTtcbiAgICAgICAgICAgIGtleWZyYW1lcyQxID0gWzAsIDEwMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yRmFjdG9yeSh7IC4uLnRoaXMub3B0aW9ucywga2V5ZnJhbWVzOiBrZXlmcmFtZXMkMSB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlIGhhdmUgYSBtaXJyb3IgcmVwZWF0IHR5cGUgd2UgbmVlZCB0byBjcmVhdGUgYSBzZWNvbmQgZ2VuZXJhdG9yIHRoYXQgb3V0cHV0cyB0aGVcbiAgICAgICAgICogbWlycm9yZWQgKG5vdCByZXZlcnNlZCkgYW5pbWF0aW9uIGFuZCBsYXRlciBwaW5nIHBvbmcgYmV0d2VlbiB0aGUgdHdvIGdlbmVyYXRvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIikge1xuICAgICAgICAgICAgbWlycm9yZWRHZW5lcmF0b3IgPSBnZW5lcmF0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzOiBbLi4ua2V5ZnJhbWVzJDFdLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eTogLXZlbG9jaXR5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGR1cmF0aW9uIGlzIHVuZGVmaW5lZCBhbmQgd2UgaGF2ZSByZXBlYXQgb3B0aW9ucyxcbiAgICAgICAgICogd2UgbmVlZCB0byBjYWxjdWxhdGUgYSBkdXJhdGlvbiBmcm9tIHRoZSBnZW5lcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIHNldCBpdCB0byB0aGUgZ2VuZXJhdG9yIGl0c2VsZiB0byBjYWNoZSB0aGUgZHVyYXRpb24uXG4gICAgICAgICAqIEFueSB0aW1lbGluZSByZXNvbHZlciB3aWxsIG5lZWQgdG8gaGF2ZSBhbHJlYWR5IHByZWNhbGN1bGF0ZWRcbiAgICAgICAgICogdGhlIGR1cmF0aW9uIGJ5IHRoaXMgc3RlcC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZW5lcmF0b3IuY2FsY3VsYXRlZER1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICBnZW5lcmF0b3IuY2FsY3VsYXRlZER1cmF0aW9uID0gY2FsY0dlbmVyYXRvckR1cmF0aW9uKGdlbmVyYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjYWxjdWxhdGVkRHVyYXRpb24gfSA9IGdlbmVyYXRvcjtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWREdXJhdGlvbiA9IGNhbGN1bGF0ZWREdXJhdGlvbiArIHJlcGVhdERlbGF5O1xuICAgICAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gcmVzb2x2ZWREdXJhdGlvbiAqIChyZXBlYXQgKyAxKSAtIHJlcGVhdERlbGF5O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2VuZXJhdG9yLFxuICAgICAgICAgICAgbWlycm9yZWRHZW5lcmF0b3IsXG4gICAgICAgICAgICBtYXBQZXJjZW50VG9LZXlmcmFtZXMsXG4gICAgICAgICAgICBjYWxjdWxhdGVkRHVyYXRpb24sXG4gICAgICAgICAgICByZXNvbHZlZER1cmF0aW9uLFxuICAgICAgICAgICAgdG90YWxEdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb25Qb3N0UmVzb2x2ZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgYXV0b3BsYXkgPSB0cnVlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nUGxheVN0YXRlID09PSBcInBhdXNlZFwiIHx8ICFhdXRvcGxheSkge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucGVuZGluZ1BsYXlTdGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aWNrKHRpbWVzdGFtcCwgc2FtcGxlID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgLy8gSWYgdGhlIGFuaW1hdGlvbnMgaGFzIGZhaWxlZCB0byByZXNvbHZlLCByZXR1cm4gdGhlIGZpbmFsIGtleWZyYW1lLlxuICAgICAgICBpZiAoIXJlc29sdmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleWZyYW1lcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IGtleWZyYW1lc1trZXlmcmFtZXMubGVuZ3RoIC0gMV0gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGZpbmFsS2V5ZnJhbWUsIGdlbmVyYXRvciwgbWlycm9yZWRHZW5lcmF0b3IsIG1hcFBlcmNlbnRUb0tleWZyYW1lcywga2V5ZnJhbWVzLCBjYWxjdWxhdGVkRHVyYXRpb24sIHRvdGFsRHVyYXRpb24sIHJlc29sdmVkRHVyYXRpb24sIH0gPSByZXNvbHZlZDtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRvci5uZXh0KDApO1xuICAgICAgICBjb25zdCB7IGRlbGF5LCByZXBlYXQsIHJlcGVhdFR5cGUsIHJlcGVhdERlbGF5LCBvblVwZGF0ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAvKipcbiAgICAgICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRpbWVzdGFtcHMgY2FuIGNvbWUgdGhyb3VnaCBhcyBsb3dlciB0aGFuXG4gICAgICAgICAqIHRoZSBzdGFydFRpbWUgYXMgc2V0IGJ5IHBlcmZvcm1hbmNlLm5vdygpLiBIZXJlIHdlIHByZXZlbnQgdGhpcyxcbiAgICAgICAgICogdGhvdWdoIGluIHRoZSBmdXR1cmUgaXQgY291bGQgYmUgcG9zc2libGUgdG8gbWFrZSBzZXR0aW5nIHN0YXJ0VGltZVxuICAgICAgICAgKiBhIHBlbmRpbmcgb3BlcmF0aW9uIHRoYXQgZ2V0cyByZXNvbHZlZCBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IE1hdGgubWluKHRoaXMuc3RhcnRUaW1lLCB0aW1lc3RhbXApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3BlZWQgPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IE1hdGgubWluKHRpbWVzdGFtcCAtIHRvdGFsRHVyYXRpb24gLyB0aGlzLnNwZWVkLCB0aGlzLnN0YXJ0VGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGN1cnJlbnRUaW1lXG4gICAgICAgIGlmIChzYW1wbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ob2xkVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuaG9sZFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSb3VuZGluZyB0aGUgdGltZSBiZWNhdXNlIGZsb2F0aW5nIHBvaW50IGFyaXRobWV0aWMgaXMgbm90IGFsd2F5cyBhY2N1cmF0ZSwgZS5nLiAzMDAwLjM2NyAtIDEwMDAuMzY3ID1cbiAgICAgICAgICAgIC8vIDIwMDAuMDAwMDAwMDAwMDAwMi4gVGhpcyBpcyBhIHByb2JsZW0gd2hlbiB3ZSBhcmUgY29tcGFyaW5nIHRoZSBjdXJyZW50VGltZSB3aXRoIHRoZSBkdXJhdGlvbiwgZm9yXG4gICAgICAgICAgICAvLyBleGFtcGxlLlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9XG4gICAgICAgICAgICAgICAgTWF0aC5yb3VuZCh0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0VGltZSkgKiB0aGlzLnNwZWVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlYmFzZSBvbiBkZWxheVxuICAgICAgICBjb25zdCB0aW1lV2l0aG91dERlbGF5ID0gdGhpcy5jdXJyZW50VGltZSAtIGRlbGF5ICogKHRoaXMuc3BlZWQgPj0gMCA/IDEgOiAtMSk7XG4gICAgICAgIGNvbnN0IGlzSW5EZWxheVBoYXNlID0gdGhpcy5zcGVlZCA+PSAwXG4gICAgICAgICAgICA/IHRpbWVXaXRob3V0RGVsYXkgPCAwXG4gICAgICAgICAgICA6IHRpbWVXaXRob3V0RGVsYXkgPiB0b3RhbER1cmF0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gTWF0aC5tYXgodGltZVdpdGhvdXREZWxheSwgMCk7XG4gICAgICAgIC8vIElmIHRoaXMgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZCwgc2V0IHRoZSBjdXJyZW50IHRpbWUgIHRvIHRoZSB0b3RhbCBkdXJhdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmluaXNoZWRcIiAmJiB0aGlzLmhvbGRUaW1lID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdG90YWxEdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWxhcHNlZCA9IHRoaXMuY3VycmVudFRpbWU7XG4gICAgICAgIGxldCBmcmFtZUdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgaWYgKHJlcGVhdCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcHJvZ3Jlc3MgKDAtMSkgb2YgdGhlIGFuaW1hdGlvbi4gSWYgdCBpcyA+XG4gICAgICAgICAgICAgKiB0aGFuIGR1cmF0aW9uIHdlJ2xsIGdldCB2YWx1ZXMgbGlrZSAyLjUgKG1pZHdheSB0aHJvdWdoIHRoZVxuICAgICAgICAgICAgICogdGhpcmQgaXRlcmF0aW9uKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKHRoaXMuY3VycmVudFRpbWUsIHRvdGFsRHVyYXRpb24pIC8gcmVzb2x2ZWREdXJhdGlvbjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IGl0ZXJhdGlvbiAoMCBpbmRleGVkKS4gRm9yIGluc3RhbmNlIHRoZSBmbG9vciBvZlxuICAgICAgICAgICAgICogMi41IGlzIDIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCBjdXJyZW50SXRlcmF0aW9uID0gTWF0aC5mbG9vcihwcm9ncmVzcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgY3VycmVudCBwcm9ncmVzcyBvZiB0aGUgaXRlcmF0aW9uIGJ5IHRha2luZyB0aGUgcmVtYWluZGVyXG4gICAgICAgICAgICAgKiBzbyAyLjUgaXMgMC41IHRocm91Z2ggaXRlcmF0aW9uIDJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGl0ZXJhdGlvblByb2dyZXNzID0gcHJvZ3Jlc3MgJSAxLjA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIGl0ZXJhdGlvbiBwcm9ncmVzcyBpcyAxIHdlIGNvdW50IHRoYXQgYXMgdGhlIGVuZFxuICAgICAgICAgICAgICogb2YgdGhlIHByZXZpb3VzIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCFpdGVyYXRpb25Qcm9ncmVzcyAmJiBwcm9ncmVzcyA+PSAxKSB7XG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uUHJvZ3Jlc3MgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlcmF0aW9uUHJvZ3Jlc3MgPT09IDEgJiYgY3VycmVudEl0ZXJhdGlvbi0tO1xuICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbiA9IE1hdGgubWluKGN1cnJlbnRJdGVyYXRpb24sIHJlcGVhdCArIDEpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXZlcnNlIHByb2dyZXNzIGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluIFwibm9ybWFsXCIgZGlyZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGlzT2RkSXRlcmF0aW9uID0gQm9vbGVhbihjdXJyZW50SXRlcmF0aW9uICUgMik7XG4gICAgICAgICAgICBpZiAoaXNPZGRJdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9uUHJvZ3Jlc3MgPSAxIC0gaXRlcmF0aW9uUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBlYXREZWxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9uUHJvZ3Jlc3MgLT0gcmVwZWF0RGVsYXkgLyByZXNvbHZlZER1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGVhdFR5cGUgPT09IFwibWlycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWVHZW5lcmF0b3IgPSBtaXJyb3JlZEdlbmVyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGFwc2VkID0gY2xhbXAoMCwgMSwgaXRlcmF0aW9uUHJvZ3Jlc3MpICogcmVzb2x2ZWREdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgaW4gbmVnYXRpdmUgdGltZSwgc2V0IHN0YXRlIGFzIHRoZSBpbml0aWFsIGtleWZyYW1lLlxuICAgICAgICAgKiBUaGlzIHByZXZlbnRzIGRlbGF5OiB4LCBkdXJhdGlvbjogMCBhbmltYXRpb25zIGZyb20gZmluaXNoaW5nXG4gICAgICAgICAqIGluc3RhbnRseS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHN0YXRlID0gaXNJbkRlbGF5UGhhc2VcbiAgICAgICAgICAgID8geyBkb25lOiBmYWxzZSwgdmFsdWU6IGtleWZyYW1lc1swXSB9XG4gICAgICAgICAgICA6IGZyYW1lR2VuZXJhdG9yLm5leHQoZWxhcHNlZCk7XG4gICAgICAgIGlmIChtYXBQZXJjZW50VG9LZXlmcmFtZXMpIHtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gbWFwUGVyY2VudFRvS2V5ZnJhbWVzKHN0YXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBkb25lIH0gPSBzdGF0ZTtcbiAgICAgICAgaWYgKCFpc0luRGVsYXlQaGFzZSAmJiBjYWxjdWxhdGVkRHVyYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRvbmUgPVxuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPj0gMFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMuY3VycmVudFRpbWUgPj0gdG90YWxEdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY3VycmVudFRpbWUgPD0gMDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0FuaW1hdGlvbkZpbmlzaGVkID0gdGhpcy5ob2xkVGltZSA9PT0gbnVsbCAmJlxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IFwiZmluaXNoZWRcIiB8fCAodGhpcy5zdGF0ZSA9PT0gXCJydW5uaW5nXCIgJiYgZG9uZSkpO1xuICAgICAgICBpZiAoaXNBbmltYXRpb25GaW5pc2hlZCAmJiBmaW5hbEtleWZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gZ2V0RmluYWxLZXlmcmFtZShrZXlmcmFtZXMsIHRoaXMub3B0aW9ucywgZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgICAgICBvblVwZGF0ZShzdGF0ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZXNvbHZlZCA/IG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhyZXNvbHZlZC5jYWxjdWxhdGVkRHVyYXRpb24pIDogMDtcbiAgICB9XG4gICAgZ2V0IHRpbWUoKSB7XG4gICAgICAgIHJldHVybiBtaWxsaXNlY29uZHNUb1NlY29uZHModGhpcy5jdXJyZW50VGltZSk7XG4gICAgfVxuICAgIHNldCB0aW1lKG5ld1RpbWUpIHtcbiAgICAgICAgbmV3VGltZSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhuZXdUaW1lKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IG5ld1RpbWU7XG4gICAgICAgIGlmICh0aGlzLmhvbGRUaW1lICE9PSBudWxsIHx8IHRoaXMuc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuaG9sZFRpbWUgPSBuZXdUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZHJpdmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuZHJpdmVyLm5vdygpIC0gbmV3VGltZSAvIHRoaXMuc3BlZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNwZWVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wbGF5YmFja1NwZWVkO1xuICAgIH1cbiAgICBzZXQgc3BlZWQobmV3U3BlZWQpIHtcbiAgICAgICAgY29uc3QgaGFzQ2hhbmdlZCA9IHRoaXMucGxheWJhY2tTcGVlZCAhPT0gbmV3U3BlZWQ7XG4gICAgICAgIHRoaXMucGxheWJhY2tTcGVlZCA9IG5ld1NwZWVkO1xuICAgICAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy50aW1lID0gbWlsbGlzZWNvbmRzVG9TZWNvbmRzKHRoaXMuY3VycmVudFRpbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlci5pc1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlci5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQbGF5U3RhdGUgPSBcInJ1bm5pbmdcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgZHJpdmVyID0gZnJhbWVsb29wRHJpdmVyLCBvblBsYXksIHN0YXJ0VGltZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMuZHJpdmVyKSB7XG4gICAgICAgICAgICB0aGlzLmRyaXZlciA9IGRyaXZlcigodGltZXN0YW1wKSA9PiB0aGlzLnRpY2sodGltZXN0YW1wKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25QbGF5ICYmIG9uUGxheSgpO1xuICAgICAgICBjb25zdCBub3cgPSB0aGlzLmRyaXZlci5ub3coKTtcbiAgICAgICAgaWYgKHRoaXMuaG9sZFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gbm93IC0gdGhpcy5ob2xkVGltZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zdGFydFRpbWUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lICE9PSBudWxsICYmIHN0YXJ0VGltZSAhPT0gdm9pZCAwID8gc3RhcnRUaW1lIDogdGhpcy5jYWxjU3RhcnRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5vdztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuY2VsVGltZSA9IHRoaXMuc3RhcnRUaW1lO1xuICAgICAgICB0aGlzLmhvbGRUaW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCBwbGF5U3RhdGUgdG8gcnVubmluZyBvbmx5IGFmdGVyIHdlJ3ZlIHVzZWQgaXQgaW5cbiAgICAgICAgICogdGhlIHByZXZpb3VzIGxvZ2ljLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwicnVubmluZ1wiO1xuICAgICAgICB0aGlzLmRyaXZlci5zdGFydCgpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdQbGF5U3RhdGUgPSBcInBhdXNlZFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcInBhdXNlZFwiO1xuICAgICAgICB0aGlzLmhvbGRUaW1lID0gKF9hID0gdGhpcy5jdXJyZW50VGltZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBcInJ1bm5pbmdcIikge1xuICAgICAgICAgICAgdGhpcy5wbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nUGxheVN0YXRlID0gdGhpcy5zdGF0ZSA9IFwiZmluaXNoZWRcIjtcbiAgICAgICAgdGhpcy5ob2xkVGltZSA9IG51bGw7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy50ZWFyZG93bigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJmaW5pc2hlZFwiO1xuICAgICAgICBjb25zdCB7IG9uQ29tcGxldGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsVGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aWNrKHRoaXMuY2FuY2VsVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZWFyZG93bigpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgIH1cbiAgICB0ZWFyZG93bigpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiaWRsZVwiO1xuICAgICAgICB0aGlzLnN0b3BEcml2ZXIoKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gdGhpcy5jYW5jZWxUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5jYW5jZWwoKTtcbiAgICB9XG4gICAgc3RvcERyaXZlcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRyaXZlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5kcml2ZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLmRyaXZlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2FtcGxlKHRpbWUpIHtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy50aWNrKHRpbWUsIHRydWUpO1xuICAgIH1cbn1cbi8vIExlZ2FjeSBpbnRlcmZhY2VcbmZ1bmN0aW9uIGFuaW1hdGVWYWx1ZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBNYWluVGhyZWFkQW5pbWF0aW9uLCBhbmltYXRlVmFsdWUgfTtcbiIsIi8qKlxuICogQSBsaXN0IG9mIHZhbHVlcyB0aGF0IGNhbiBiZSBoYXJkd2FyZS1hY2NlbGVyYXRlZC5cbiAqL1xuY29uc3QgYWNjZWxlcmF0ZWRWYWx1ZXMgPSBuZXcgU2V0KFtcbiAgICBcIm9wYWNpdHlcIixcbiAgICBcImNsaXBQYXRoXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcInRyYW5zZm9ybVwiLFxuICAgIC8vIFRPRE86IENhbiBiZSBhY2NlbGVyYXRlZCBidXQgY3VycmVudGx5IGRpc2FibGVkIHVudGlsIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDE0OTEwOTggaXMgcmVzb2x2ZWRcbiAgICAvLyBvciB1bnRpbCB3ZSBpbXBsZW1lbnQgc3VwcG9ydCBmb3IgbGluZWFyKCkgZWFzaW5nLlxuICAgIC8vIFwiYmFja2dyb3VuZC1jb2xvclwiXG5dKTtcblxuZXhwb3J0IHsgYWNjZWxlcmF0ZWRWYWx1ZXMgfTtcbiIsImltcG9ydCB7IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5cbmZ1bmN0aW9uIHN0YXJ0V2FhcGlBbmltYXRpb24oZWxlbWVudCwgdmFsdWVOYW1lLCBrZXlmcmFtZXMsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgcmVwZWF0ID0gMCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiLCBlYXNlID0gXCJlYXNlSW5PdXRcIiwgdGltZXMsIH0gPSB7fSkge1xuICAgIGNvbnN0IGtleWZyYW1lT3B0aW9ucyA9IHsgW3ZhbHVlTmFtZV06IGtleWZyYW1lcyB9O1xuICAgIGlmICh0aW1lcylcbiAgICAgICAga2V5ZnJhbWVPcHRpb25zLm9mZnNldCA9IHRpbWVzO1xuICAgIGNvbnN0IGVhc2luZyA9IG1hcEVhc2luZ1RvTmF0aXZlRWFzaW5nKGVhc2UsIGR1cmF0aW9uKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIGlzIGFuIGVhc2luZyBhcnJheSwgYXBwbHkgdG8ga2V5ZnJhbWVzLCBub3QgYW5pbWF0aW9uIGFzIGEgd2hvbGVcbiAgICAgKi9cbiAgICBpZiAoQXJyYXkuaXNBcnJheShlYXNpbmcpKVxuICAgICAgICBrZXlmcmFtZU9wdGlvbnMuZWFzaW5nID0gZWFzaW5nO1xuICAgIHJldHVybiBlbGVtZW50LmFuaW1hdGUoa2V5ZnJhbWVPcHRpb25zLCB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiAhQXJyYXkuaXNBcnJheShlYXNpbmcpID8gZWFzaW5nIDogXCJsaW5lYXJcIixcbiAgICAgICAgZmlsbDogXCJib3RoXCIsXG4gICAgICAgIGl0ZXJhdGlvbnM6IHJlcGVhdCArIDEsXG4gICAgICAgIGRpcmVjdGlvbjogcmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIgPyBcImFsdGVybmF0ZVwiIDogXCJub3JtYWxcIixcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgc3RhcnRXYWFwaUFuaW1hdGlvbiB9O1xuIiwiaW1wb3J0IHsgbWVtbyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5cbmNvbnN0IHN1cHBvcnRzV2FhcGkgPSAvKkBfX1BVUkVfXyovIG1lbW8oKCkgPT4gT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoRWxlbWVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiKSk7XG5cbmV4cG9ydCB7IHN1cHBvcnRzV2FhcGkgfTtcbiIsImltcG9ydCB7IHN1cHBvcnRzTGluZWFyRWFzaW5nLCBhdHRhY2hUaW1lbGluZSwgaXNHZW5lcmF0b3IsIGlzV2FhcGlTdXBwb3J0ZWRFYXNpbmcgfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IG1pbGxpc2Vjb25kc1RvU2Vjb25kcywgc2Vjb25kc1RvTWlsbGlzZWNvbmRzLCBub29wIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGFudGljaXBhdGUgfSBmcm9tICcuLi8uLi9lYXNpbmcvYW50aWNpcGF0ZS5tanMnO1xuaW1wb3J0IHsgYmFja0luT3V0IH0gZnJvbSAnLi4vLi4vZWFzaW5nL2JhY2subWpzJztcbmltcG9ydCB7IGNpcmNJbk91dCB9IGZyb20gJy4uLy4uL2Vhc2luZy9jaXJjLm1qcyc7XG5pbXBvcnQgeyBET01LZXlmcmFtZXNSZXNvbHZlciB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vRE9NS2V5ZnJhbWVzUmVzb2x2ZXIubWpzJztcbmltcG9ydCB7IEJhc2VBbmltYXRpb24gfSBmcm9tICcuL0Jhc2VBbmltYXRpb24ubWpzJztcbmltcG9ydCB7IE1haW5UaHJlYWRBbmltYXRpb24gfSBmcm9tICcuL01haW5UaHJlYWRBbmltYXRpb24ubWpzJztcbmltcG9ydCB7IGFjY2VsZXJhdGVkVmFsdWVzIH0gZnJvbSAnLi91dGlscy9hY2NlbGVyYXRlZC12YWx1ZXMubWpzJztcbmltcG9ydCB7IHN0YXJ0V2FhcGlBbmltYXRpb24gfSBmcm9tICcuL3dhYXBpL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBnZXRGaW5hbEtleWZyYW1lIH0gZnJvbSAnLi93YWFwaS91dGlscy9nZXQtZmluYWwta2V5ZnJhbWUubWpzJztcbmltcG9ydCB7IHN1cHBvcnRzV2FhcGkgfSBmcm9tICcuL3dhYXBpL3V0aWxzL3N1cHBvcnRzLXdhYXBpLm1qcyc7XG5cbi8qKlxuICogMTBtcyBpcyBjaG9zZW4gaGVyZSBhcyBpdCBzdHJpa2VzIGEgYmFsYW5jZSBiZXR3ZWVuIHNtb290aFxuICogcmVzdWx0cyAobW9yZSB0aGFuIG9uZSBrZXlmcmFtZSBwZXIgZnJhbWUgYXQgNjBmcHMpIGFuZFxuICoga2V5ZnJhbWUgcXVhbnRpdHkuXG4gKi9cbmNvbnN0IHNhbXBsZURlbHRhID0gMTA7IC8vbXNcbi8qKlxuICogSW1wbGVtZW50IGEgcHJhY3RpY2FsIG1heCBkdXJhdGlvbiBmb3Iga2V5ZnJhbWUgZ2VuZXJhdGlvblxuICogdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICovXG5jb25zdCBtYXhEdXJhdGlvbiA9IDIwMDAwO1xuLyoqXG4gKiBDaGVjayBpZiBhbiBhbmltYXRpb24gY2FuIHJ1biBuYXRpdmVseSB2aWEgV0FBUEkgb3IgcmVxdWlyZXMgcHJlZ2VuZXJhdGVkIGtleWZyYW1lcy5cbiAqIFdBQVBJIGRvZXNuJ3Qgc3VwcG9ydCBzcHJpbmcgb3IgZnVuY3Rpb24gZWFzaW5ncyBzbyB3ZSBydW4gdGhlc2UgYXMgSlMgYW5pbWF0aW9uIGJlZm9yZVxuICogaGFuZGluZyBvZmYuXG4gKi9cbmZ1bmN0aW9uIHJlcXVpcmVzUHJlZ2VuZXJhdGVkS2V5ZnJhbWVzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gKGlzR2VuZXJhdG9yKG9wdGlvbnMudHlwZSkgfHxcbiAgICAgICAgb3B0aW9ucy50eXBlID09PSBcInNwcmluZ1wiIHx8XG4gICAgICAgICFpc1dhYXBpU3VwcG9ydGVkRWFzaW5nKG9wdGlvbnMuZWFzZSkpO1xufVxuZnVuY3Rpb24gcHJlZ2VuZXJhdGVLZXlmcmFtZXMoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFpbi10aHJlYWQgYW5pbWF0aW9uIHRvIHByZWdlbmVyYXRlIGtleWZyYW1lcy5cbiAgICAgKiBXZSBzYW1wbGUgdGhpcyBhdCByZWd1bGFyIGludGVydmFscyB0byBnZW5lcmF0ZSBrZXlmcmFtZXMgdGhhdCB3ZSB0aGVuXG4gICAgICogbGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2Vlbi5cbiAgICAgKi9cbiAgICBjb25zdCBzYW1wbGVBbmltYXRpb24gPSBuZXcgTWFpblRocmVhZEFuaW1hdGlvbih7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgaXNHZW5lcmF0b3I6IHRydWUsXG4gICAgfSk7XG4gICAgbGV0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGtleWZyYW1lc1swXSB9O1xuICAgIGNvbnN0IHByZWdlbmVyYXRlZEtleWZyYW1lcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEJhaWwgYWZ0ZXIgMjAgc2Vjb25kcyBvZiBwcmUtZ2VuZXJhdGVkIGtleWZyYW1lcyBhcyBpdCdzIGxpa2VseVxuICAgICAqIHdlJ3JlIGhlYWRpbmcgZm9yIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICovXG4gICAgbGV0IHQgPSAwO1xuICAgIHdoaWxlICghc3RhdGUuZG9uZSAmJiB0IDwgbWF4RHVyYXRpb24pIHtcbiAgICAgICAgc3RhdGUgPSBzYW1wbGVBbmltYXRpb24uc2FtcGxlKHQpO1xuICAgICAgICBwcmVnZW5lcmF0ZWRLZXlmcmFtZXMucHVzaChzdGF0ZS52YWx1ZSk7XG4gICAgICAgIHQgKz0gc2FtcGxlRGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzOiB1bmRlZmluZWQsXG4gICAgICAgIGtleWZyYW1lczogcHJlZ2VuZXJhdGVkS2V5ZnJhbWVzLFxuICAgICAgICBkdXJhdGlvbjogdCAtIHNhbXBsZURlbHRhLFxuICAgICAgICBlYXNlOiBcImxpbmVhclwiLFxuICAgIH07XG59XG5jb25zdCB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgICBhbnRpY2lwYXRlLFxuICAgIGJhY2tJbk91dCxcbiAgICBjaXJjSW5PdXQsXG59O1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEVhc2Uoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9ucztcbn1cbmNsYXNzIEFjY2VsZXJhdGVkQW5pbWF0aW9uIGV4dGVuZHMgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwga2V5ZnJhbWVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVzb2x2ZXIgPSBuZXcgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIoa2V5ZnJhbWVzLCAocmVzb2x2ZWRLZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpID0+IHRoaXMub25LZXlmcmFtZXNSZXNvbHZlZChyZXNvbHZlZEtleWZyYW1lcywgZmluYWxLZXlmcmFtZSksIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5zY2hlZHVsZVJlc29sdmUoKTtcbiAgICB9XG4gICAgaW5pdFBsYXliYWNrKGtleWZyYW1lcywgZmluYWxLZXlmcmFtZSkge1xuICAgICAgICBsZXQgeyBkdXJhdGlvbiA9IDMwMCwgdGltZXMsIGVhc2UsIHR5cGUsIG1vdGlvblZhbHVlLCBuYW1lLCBzdGFydFRpbWUsIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbGVtZW50IGhhcyBzaW5jZSBiZWVuIHVubW91bnRlZCwgcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlXG4gICAgICAgICAqIHRoZSBhbmltYXRpb24gZmFpbGVkIHRvIGluaXRpYWxpc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFtb3Rpb25WYWx1ZS5vd25lciB8fCAhbW90aW9uVmFsdWUub3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdXNlciBoYXMgcHJvdmlkZWQgYW4gZWFzaW5nIGZ1bmN0aW9uIG5hbWUgdGhhdCBpc24ndCBzdXBwb3J0ZWRcbiAgICAgICAgICogYnkgV0FBUEkgKGxpa2UgXCJhbnRpY2lwYXRlXCIpLCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGNvcnJlc3Nwb25kaW5nXG4gICAgICAgICAqIGZ1bmN0aW9uLiBUaGlzIHdpbGwgbGF0ZXIgZ2V0IGNvbnZlcnRlZCB0byBhIGxpbmVhcigpIGVhc2luZyBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0eXBlb2YgZWFzZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgc3VwcG9ydHNMaW5lYXJFYXNpbmcoKSAmJlxuICAgICAgICAgICAgaXNVbnN1cHBvcnRlZEVhc2UoZWFzZSkpIHtcbiAgICAgICAgICAgIGVhc2UgPSB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9uc1tlYXNlXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBhbmltYXRpb24gbmVlZHMgcHJlLWdlbmVyYXRlZCBrZXlmcmFtZXMgdGhlbiBnZW5lcmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZXF1aXJlc1ByZWdlbmVyYXRlZEtleWZyYW1lcyh0aGlzLm9wdGlvbnMpKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9uQ29tcGxldGUsIG9uVXBkYXRlLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwgLi4ub3B0aW9ucyB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgcHJlZ2VuZXJhdGVkQW5pbWF0aW9uID0gcHJlZ2VuZXJhdGVLZXlmcmFtZXMoa2V5ZnJhbWVzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGtleWZyYW1lcyA9IHByZWdlbmVyYXRlZEFuaW1hdGlvbi5rZXlmcmFtZXM7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdmVyeSBzaG9ydCBhbmltYXRpb24sIGVuc3VyZSB3ZSBoYXZlXG4gICAgICAgICAgICAvLyBhdCBsZWFzdCB0d28ga2V5ZnJhbWVzIHRvIGFuaW1hdGUgYmV0d2VlbiBhcyBvbGRlciBicm93c2Vyc1xuICAgICAgICAgICAgLy8gY2FuJ3QgYW5pbWF0ZSBiZXR3ZWVuIGEgc2luZ2xlIGtleWZyYW1lLlxuICAgICAgICAgICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXNbMV0gPSBrZXlmcmFtZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHByZWdlbmVyYXRlZEFuaW1hdGlvbi5kdXJhdGlvbjtcbiAgICAgICAgICAgIHRpbWVzID0gcHJlZ2VuZXJhdGVkQW5pbWF0aW9uLnRpbWVzO1xuICAgICAgICAgICAgZWFzZSA9IHByZWdlbmVyYXRlZEFuaW1hdGlvbi5lYXNlO1xuICAgICAgICAgICAgdHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gc3RhcnRXYWFwaUFuaW1hdGlvbihtb3Rpb25WYWx1ZS5vd25lci5jdXJyZW50LCBuYW1lLCBrZXlmcmFtZXMsIHsgLi4udGhpcy5vcHRpb25zLCBkdXJhdGlvbiwgdGltZXMsIGVhc2UgfSk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBicm93c2VyIGNhbGN1bGF0ZWQgc3RhcnRUaW1lIHdpdGggb25lIHN5bmNocm9uaXNlZCB0byBvdGhlciBKU1xuICAgICAgICAvLyBhbmQgV0FBUEkgYW5pbWF0aW9ucyBzdGFydGluZyB0aGlzIGV2ZW50IGxvb3AuXG4gICAgICAgIGFuaW1hdGlvbi5zdGFydFRpbWUgPSBzdGFydFRpbWUgIT09IG51bGwgJiYgc3RhcnRUaW1lICE9PSB2b2lkIDAgPyBzdGFydFRpbWUgOiB0aGlzLmNhbGNTdGFydFRpbWUoKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1RpbWVsaW5lKSB7XG4gICAgICAgICAgICBhdHRhY2hUaW1lbGluZShhbmltYXRpb24sIHRoaXMucGVuZGluZ1RpbWVsaW5lKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVsaW5lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcmVmZXIgdGhlIGBvbmZpbmlzaGAgcHJvcCBhcyBpdCdzIG1vcmUgd2lkZWx5IHN1cHBvcnRlZCB0aGFuXG4gICAgICAgICAgICAgKiB0aGUgYGZpbmlzaGVkYCBwcm9taXNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEhlcmUsIHdlIHN5bmNocm9ub3VzbHkgc2V0IHRoZSBwcm92aWRlZCBNb3Rpb25WYWx1ZSB0byB0aGUgZW5kXG4gICAgICAgICAgICAgKiBrZXlmcmFtZS4gSWYgd2UgZGlkbid0LCB3aGVuIHRoZSBXQUFQSSBhbmltYXRpb24gaXMgZmluaXNoZWQgaXQgd291bGRcbiAgICAgICAgICAgICAqIGJlIHJlbW92ZWQgZnJvbSB0aGUgZWxlbWVudCB3aGljaCB3b3VsZCB0aGVuIHJldmVydCB0byBpdHMgb2xkIHN0eWxlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYW5pbWF0aW9uLm9uZmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgb25Db21wbGV0ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLnNldChnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgdGhpcy5vcHRpb25zLCBmaW5hbEtleWZyYW1lKSk7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICAgICAgdGltZXMsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZWFzZSxcbiAgICAgICAgICAgIGtleWZyYW1lczoga2V5ZnJhbWVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgeyBkdXJhdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIHJldHVybiBtaWxsaXNlY29uZHNUb1NlY29uZHMoZHVyYXRpb24pO1xuICAgIH1cbiAgICBnZXQgdGltZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIHJldHVybiBtaWxsaXNlY29uZHNUb1NlY29uZHMoYW5pbWF0aW9uLmN1cnJlbnRUaW1lIHx8IDApO1xuICAgIH1cbiAgICBzZXQgdGltZShuZXdUaW1lKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgYW5pbWF0aW9uLmN1cnJlbnRUaW1lID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG5ld1RpbWUpO1xuICAgIH1cbiAgICBnZXQgc3BlZWQoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnBsYXliYWNrUmF0ZTtcbiAgICB9XG4gICAgc2V0IHNwZWVkKG5ld1NwZWVkKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgYW5pbWF0aW9uLnBsYXliYWNrUmF0ZSA9IG5ld1NwZWVkO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm4gXCJpZGxlXCI7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5wbGF5U3RhdGU7XG4gICAgfVxuICAgIGdldCBzdGFydFRpbWUoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICAvLyBDb2VyY2UgdG8gbnVtYmVyIGFzIFR5cGVTY3JpcHQgaW5jb3JyZWN0bHkgdHlwZXMgdGhpc1xuICAgICAgICAvLyBhcyBDU1NOdW1iZXJpc2hcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5zdGFydFRpbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgdGhlIGRlZmF1bHQgRG9jdW1lbnRUaW1lbGluZSB3aXRoIGFub3RoZXIgQW5pbWF0aW9uVGltZWxpbmUuXG4gICAgICogQ3VycmVudGx5IHVzZWQgZm9yIHNjcm9sbCBhbmltYXRpb25zLlxuICAgICAqL1xuICAgIGF0dGFjaFRpbWVsaW5lKHRpbWVsaW5lKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RpbWVsaW5lID0gdGltZWxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGF0dGFjaFRpbWVsaW5lKGFuaW1hdGlvbiwgdGltZWxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub29wO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5wbGF5U3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJpZGxlXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgdHlwZSwgZWFzZSwgdGltZXMgfSA9IHJlc29sdmVkO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJpZGxlXCIgfHxcbiAgICAgICAgICAgIGFuaW1hdGlvbi5wbGF5U3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXQUFQSSBkb2Vzbid0IG5hdGl2ZWx5IGhhdmUgYW55IGludGVycnVwdGlvbiBjYXBhYmlsaXRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJhdGhlciB0aGFuIHJlYWQgY29tbWl0ZWQgc3R5bGVzIGJhY2sgb3V0IG9mIHRoZSBET00sIHdlIGNhblxuICAgICAgICAgKiBjcmVhdGUgYSByZW5kZXJsZXNzIEpTIGFuaW1hdGlvbiBhbmQgc2FtcGxlIGl0IHR3aWNlIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgKiBpdHMgY3VycmVudCB2YWx1ZSwgXCJwcmV2aW91c1wiIHZhbHVlLCBhbmQgdGhlcmVmb3JlIGFsbG93XG4gICAgICAgICAqIE1vdGlvbiB0byBjYWxjdWxhdGUgdmVsb2NpdHkgZm9yIGFueSBzdWJzZXF1ZW50IGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW90aW9uVmFsdWUsIG9uVXBkYXRlLCBvbkNvbXBsZXRlLCBlbGVtZW50LCAuLi5vcHRpb25zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVBbmltYXRpb24gPSBuZXcgTWFpblRocmVhZEFuaW1hdGlvbih7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBlYXNlLFxuICAgICAgICAgICAgICAgIHRpbWVzLFxuICAgICAgICAgICAgICAgIGlzR2VuZXJhdG9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVUaW1lID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRoaXMudGltZSk7XG4gICAgICAgICAgICBtb3Rpb25WYWx1ZS5zZXRXaXRoVmVsb2NpdHkoc2FtcGxlQW5pbWF0aW9uLnNhbXBsZShzYW1wbGVUaW1lIC0gc2FtcGxlRGVsdGEpLnZhbHVlLCBzYW1wbGVBbmltYXRpb24uc2FtcGxlKHNhbXBsZVRpbWUpLnZhbHVlLCBzYW1wbGVEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvblN0b3AgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgb25TdG9wICYmIG9uU3RvcCgpO1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQuYW5pbWF0aW9uLmZpbmlzaCgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlc29sdmVkLmFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBtb3Rpb25WYWx1ZSwgbmFtZSwgcmVwZWF0RGVsYXksIHJlcGVhdFR5cGUsIGRhbXBpbmcsIHR5cGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghbW90aW9uVmFsdWUgfHxcbiAgICAgICAgICAgICFtb3Rpb25WYWx1ZS5vd25lciB8fFxuICAgICAgICAgICAgIShtb3Rpb25WYWx1ZS5vd25lci5jdXJyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvblVwZGF0ZSwgdHJhbnNmb3JtVGVtcGxhdGUgfSA9IG1vdGlvblZhbHVlLm93bmVyLmdldFByb3BzKCk7XG4gICAgICAgIHJldHVybiAoc3VwcG9ydHNXYWFwaSgpICYmXG4gICAgICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICBhY2NlbGVyYXRlZFZhbHVlcy5oYXMobmFtZSkgJiZcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgb3V0cHV0dGluZyB2YWx1ZXMgdG8gb25VcGRhdGUgdGhlbiB3ZSBjYW4ndCB1c2UgV0FBUEkgYXMgdGhlcmUnc1xuICAgICAgICAgICAgICogbm8gd2F5IHRvIHJlYWQgdGhlIHZhbHVlIGZyb20gV0FBUEkgZXZlcnkgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICFvblVwZGF0ZSAmJlxuICAgICAgICAgICAgIXRyYW5zZm9ybVRlbXBsYXRlICYmXG4gICAgICAgICAgICAhcmVwZWF0RGVsYXkgJiZcbiAgICAgICAgICAgIHJlcGVhdFR5cGUgIT09IFwibWlycm9yXCIgJiZcbiAgICAgICAgICAgIGRhbXBpbmcgIT09IDAgJiZcbiAgICAgICAgICAgIHR5cGUgIT09IFwiaW5lcnRpYVwiKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFjY2VsZXJhdGVkQW5pbWF0aW9uIH07XG4iLCJpbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4uLy4uL3JlbmRlci9odG1sL3V0aWxzL2tleXMtdHJhbnNmb3JtLm1qcyc7XG5cbmNvbnN0IHVuZGVyRGFtcGVkU3ByaW5nID0ge1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1MDAsXG4gICAgZGFtcGluZzogMjUsXG4gICAgcmVzdFNwZWVkOiAxMCxcbn07XG5jb25zdCBjcml0aWNhbGx5RGFtcGVkU3ByaW5nID0gKHRhcmdldCkgPT4gKHtcbiAgICB0eXBlOiBcInNwcmluZ1wiLFxuICAgIHN0aWZmbmVzczogNTUwLFxuICAgIGRhbXBpbmc6IHRhcmdldCA9PT0gMCA/IDIgKiBNYXRoLnNxcnQoNTUwKSA6IDMwLFxuICAgIHJlc3RTcGVlZDogMTAsXG59KTtcbmNvbnN0IGtleWZyYW1lc1RyYW5zaXRpb24gPSB7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBkdXJhdGlvbjogMC44LFxufTtcbi8qKlxuICogRGVmYXVsdCBlYXNpbmcgY3VydmUgaXMgYSBzbGlnaHRseSBzaGFsbG93ZXIgdmVyc2lvbiBvZlxuICogdGhlIGRlZmF1bHQgYnJvd3NlciBlYXNpbmcgY3VydmUuXG4gKi9cbmNvbnN0IGVhc2UgPSB7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBlYXNlOiBbMC4yNSwgMC4xLCAwLjM1LCAxXSxcbiAgICBkdXJhdGlvbjogMC4zLFxufTtcbmNvbnN0IGdldERlZmF1bHRUcmFuc2l0aW9uID0gKHZhbHVlS2V5LCB7IGtleWZyYW1lcyB9KSA9PiB7XG4gICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNUcmFuc2l0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXModmFsdWVLZXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUtleS5zdGFydHNXaXRoKFwic2NhbGVcIilcbiAgICAgICAgICAgID8gY3JpdGljYWxseURhbXBlZFNwcmluZyhrZXlmcmFtZXNbMV0pXG4gICAgICAgICAgICA6IHVuZGVyRGFtcGVkU3ByaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZTtcbn07XG5cbmV4cG9ydCB7IGdldERlZmF1bHRUcmFuc2l0aW9uIH07XG4iLCIvKipcbiAqIERlY2lkZSB3aGV0aGVyIGEgdHJhbnNpdGlvbiBpcyBkZWZpbmVkIG9uIGEgZ2l2ZW4gVHJhbnNpdGlvbi5cbiAqIFRoaXMgZmlsdGVycyBvdXQgb3JjaGVzdHJhdGlvbiBvcHRpb25zIGFuZCByZXR1cm5zIHRydWVcbiAqIGlmIGFueSBvcHRpb25zIGFyZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBpc1RyYW5zaXRpb25EZWZpbmVkKHsgd2hlbiwgZGVsYXk6IF9kZWxheSwgZGVsYXlDaGlsZHJlbiwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCByZXBlYXQsIHJlcGVhdFR5cGUsIHJlcGVhdERlbGF5LCBmcm9tLCBlbGFwc2VkLCAuLi50cmFuc2l0aW9uIH0pIHtcbiAgICByZXR1cm4gISFPYmplY3Qua2V5cyh0cmFuc2l0aW9uKS5sZW5ndGg7XG59XG5cbmV4cG9ydCB7IGlzVHJhbnNpdGlvbkRlZmluZWQgfTtcbiIsImltcG9ydCB7IGdldFZhbHVlVHJhbnNpdGlvbiwgR3JvdXBQbGF5YmFja0NvbnRyb2xzIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgZnJhbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcbmltcG9ydCB7IE1vdGlvbkdsb2JhbENvbmZpZyB9IGZyb20gJy4uLy4uL3V0aWxzL0dsb2JhbENvbmZpZy5tanMnO1xuaW1wb3J0IHsgaW5zdGFudEFuaW1hdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWluc3RhbnQtdHJhbnNpdGlvbi1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgQWNjZWxlcmF0ZWRBbmltYXRpb24gfSBmcm9tICcuLi9hbmltYXRvcnMvQWNjZWxlcmF0ZWRBbmltYXRpb24ubWpzJztcbmltcG9ydCB7IE1haW5UaHJlYWRBbmltYXRpb24gfSBmcm9tICcuLi9hbmltYXRvcnMvTWFpblRocmVhZEFuaW1hdGlvbi5tanMnO1xuaW1wb3J0IHsgZ2V0RmluYWxLZXlmcmFtZSB9IGZyb20gJy4uL2FuaW1hdG9ycy93YWFwaS91dGlscy9nZXQtZmluYWwta2V5ZnJhbWUubWpzJztcbmltcG9ydCB7IGdldERlZmF1bHRUcmFuc2l0aW9uIH0gZnJvbSAnLi4vdXRpbHMvZGVmYXVsdC10cmFuc2l0aW9ucy5tanMnO1xuaW1wb3J0IHsgaXNUcmFuc2l0aW9uRGVmaW5lZCB9IGZyb20gJy4uL3V0aWxzL2lzLXRyYW5zaXRpb24tZGVmaW5lZC5tanMnO1xuXG5jb25zdCBhbmltYXRlTW90aW9uVmFsdWUgPSAobmFtZSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiA9IHt9LCBlbGVtZW50LCBpc0hhbmRvZmYpID0+IChvbkNvbXBsZXRlKSA9PiB7XG4gICAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIG5hbWUpIHx8IHt9O1xuICAgIC8qKlxuICAgICAqIE1vc3QgdHJhbnNpdGlvbiB2YWx1ZXMgYXJlIGN1cnJlbnRseSBjb21wbGV0ZWx5IG92ZXJ3cml0dGVuIGJ5IHZhbHVlLXNwZWNpZmljXG4gICAgICogdHJhbnNpdGlvbnMuIEluIHRoZSBmdXR1cmUgaXQnZCBiZSBuaWNlciB0byBibGVuZCB0aGVzZSB0cmFuc2l0aW9ucy4gQnV0IGZvciBub3dcbiAgICAgKiBkZWxheSBhY3R1YWxseSBkb2VzIGluaGVyaXQgZnJvbSB0aGUgcm9vdCB0cmFuc2l0aW9uIGlmIG5vdCB2YWx1ZS1zcGVjaWZpYy5cbiAgICAgKi9cbiAgICBjb25zdCBkZWxheSA9IHZhbHVlVHJhbnNpdGlvbi5kZWxheSB8fCB0cmFuc2l0aW9uLmRlbGF5IHx8IDA7XG4gICAgLyoqXG4gICAgICogRWxhcHNlZCBpc24ndCBhIHB1YmxpYyB0cmFuc2l0aW9uIG9wdGlvbiBidXQgY2FuIGJlIHBhc3NlZCB0aHJvdWdoIGZyb21cbiAgICAgKiBvcHRpbWl6ZWQgYXBwZWFyIGVmZmVjdHMgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIGxldCB7IGVsYXBzZWQgPSAwIH0gPSB0cmFuc2l0aW9uO1xuICAgIGVsYXBzZWQgPSBlbGFwc2VkIC0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGRlbGF5KTtcbiAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAga2V5ZnJhbWVzOiBBcnJheS5pc0FycmF5KHRhcmdldCkgPyB0YXJnZXQgOiBbbnVsbCwgdGFyZ2V0XSxcbiAgICAgICAgZWFzZTogXCJlYXNlT3V0XCIsXG4gICAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgICAuLi52YWx1ZVRyYW5zaXRpb24sXG4gICAgICAgIGRlbGF5OiAtZWxhcHNlZCxcbiAgICAgICAgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgICAgICB2YWx1ZS5zZXQodik7XG4gICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUgJiYgdmFsdWVUcmFuc2l0aW9uLm9uVXBkYXRlKHYpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICBuYW1lLFxuICAgICAgICBtb3Rpb25WYWx1ZTogdmFsdWUsXG4gICAgICAgIGVsZW1lbnQ6IGlzSGFuZG9mZiA/IHVuZGVmaW5lZCA6IGVsZW1lbnQsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIG5vIHRyYW5zaXRpb24gZGVmaW5lZCBmb3IgdGhpcyB2YWx1ZSwgd2UgY2FuIGdlbmVyYXRlXG4gICAgICogdW5xaXVlIHRyYW5zaXRpb24gc2V0dGluZ3MgZm9yIHRoaXMgdmFsdWUuXG4gICAgICovXG4gICAgaWYgKCFpc1RyYW5zaXRpb25EZWZpbmVkKHZhbHVlVHJhbnNpdGlvbikpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5nZXREZWZhdWx0VHJhbnNpdGlvbihuYW1lLCBvcHRpb25zKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQm90aCBXQUFQSSBhbmQgb3VyIGludGVybmFsIGFuaW1hdGlvbiBmdW5jdGlvbnMgdXNlIGR1cmF0aW9uc1xuICAgICAqIGFzIGRlZmluZWQgYnkgbWlsbGlzZWNvbmRzLCB3aGlsZSBvdXIgZXh0ZXJuYWwgQVBJIGRlZmluZXMgdGhlbVxuICAgICAqIGFzIHNlY29uZHMuXG4gICAgICovXG4gICAgaWYgKG9wdGlvbnMuZHVyYXRpb24pIHtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhvcHRpb25zLmR1cmF0aW9uKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVwZWF0RGVsYXkpIHtcbiAgICAgICAgb3B0aW9ucy5yZXBlYXREZWxheSA9IHNlY29uZHNUb01pbGxpc2Vjb25kcyhvcHRpb25zLnJlcGVhdERlbGF5KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZnJvbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMua2V5ZnJhbWVzWzBdID0gb3B0aW9ucy5mcm9tO1xuICAgIH1cbiAgICBsZXQgc2hvdWxkU2tpcCA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLnR5cGUgPT09IGZhbHNlIHx8XG4gICAgICAgIChvcHRpb25zLmR1cmF0aW9uID09PSAwICYmICFvcHRpb25zLnJlcGVhdERlbGF5KSkge1xuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gMDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIHNob3VsZFNraXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCB8fFxuICAgICAgICBNb3Rpb25HbG9iYWxDb25maWcuc2tpcEFuaW1hdGlvbnMpIHtcbiAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSAwO1xuICAgICAgICBvcHRpb25zLmRlbGF5ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UgY2FuIG9yIG11c3Qgc2tpcCBjcmVhdGluZyB0aGUgYW5pbWF0aW9uLCBhbmQgYXBwbHkgb25seVxuICAgICAqIHRoZSBmaW5hbCBrZXlmcmFtZSwgZG8gc28uIFdlIGFsc28gY2hlY2sgb25jZSBrZXlmcmFtZXMgYXJlIHJlc29sdmVkIGJ1dFxuICAgICAqIHRoaXMgZWFybHkgY2hlY2sgcHJldmVudHMgdGhlIG5lZWQgdG8gY3JlYXRlIGFuIGFuaW1hdGlvbiBhdCBhbGwuXG4gICAgICovXG4gICAgaWYgKHNob3VsZFNraXAgJiYgIWlzSGFuZG9mZiAmJiB2YWx1ZS5nZXQoKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsS2V5ZnJhbWUgPSBnZXRGaW5hbEtleWZyYW1lKG9wdGlvbnMua2V5ZnJhbWVzLCB2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICBpZiAoZmluYWxLZXlmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25VcGRhdGUoZmluYWxLZXlmcmFtZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFdlIHN0aWxsIHdhbnQgdG8gcmV0dXJuIHNvbWUgYW5pbWF0aW9uIGNvbnRyb2xzIGhlcmUgcmF0aGVyXG4gICAgICAgICAgICAvLyB0aGFuIHJldHVybmluZyB1bmRlZmluZWRcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3JvdXBQbGF5YmFja0NvbnRyb2xzKFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIHZpYSBXQUFQSSBpZiBwb3NzaWJsZS4gSWYgdGhpcyBpcyBhIGhhbmRvZmYgYW5pbWF0aW9uLCB0aGUgb3B0aW1pc2VkIGFuaW1hdGlvbiB3aWxsIGJlIHJ1bm5pbmcgdmlhXG4gICAgICogV0FBUEkuIFRoZXJlZm9yZSwgdGhpcyBhbmltYXRpb24gbXVzdCBiZSBKUyB0byBlbnN1cmUgaXQgcnVucyBcInVuZGVyXCIgdGhlXG4gICAgICogb3B0aW1pc2VkIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBpZiAoIWlzSGFuZG9mZiAmJiBBY2NlbGVyYXRlZEFuaW1hdGlvbi5zdXBwb3J0cyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFjY2VsZXJhdGVkQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGFuaW1hdGVNb3Rpb25WYWx1ZSB9O1xuIiwiaW1wb3J0IHsgZ2V0VmFsdWVUcmFuc2l0aW9uIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBwb3NpdGlvbmFsS2V5cyB9IGZyb20gJy4uLy4uL3JlbmRlci9odG1sL3V0aWxzL2tleXMtcG9zaXRpb24ubWpzJztcbmltcG9ydCB7IHNldFRhcmdldCB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qcyc7XG5pbXBvcnQgeyBhZGRWYWx1ZVRvV2lsbENoYW5nZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3VzZS13aWxsLWNoYW5nZS9hZGQtd2lsbC1jaGFuZ2UubWpzJztcbmltcG9ydCB7IGdldE9wdGltaXNlZEFwcGVhcklkIH0gZnJvbSAnLi4vb3B0aW1pemVkLWFwcGVhci9nZXQtYXBwZWFyLWlkLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlTW90aW9uVmFsdWUgfSBmcm9tICcuL21vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgZnJhbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuLyoqXG4gKiBEZWNpZGUgd2hldGhlciB3ZSBzaG91bGQgYmxvY2sgdGhpcyBhbmltYXRpb24uIFByZXZpb3VzbHksIHdlIGFjaGlldmVkIHRoaXNcbiAqIGp1c3QgYnkgY2hlY2tpbmcgd2hldGhlciB0aGUga2V5IHdhcyBsaXN0ZWQgaW4gcHJvdGVjdGVkS2V5cywgYnV0IHRoaXNcbiAqIHBvc2VkIHByb2JsZW1zIGlmIGFuIGFuaW1hdGlvbiB3YXMgdHJpZ2dlcmVkIGJ5IGFmdGVyQ2hpbGRyZW4gYW5kIHByb3RlY3RlZEtleXNcbiAqIGhhZCBiZWVuIHNldCB0byB0cnVlIGluIHRoZSBtZWFudGltZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQmxvY2tBbmltYXRpb24oeyBwcm90ZWN0ZWRLZXlzLCBuZWVkc0FuaW1hdGluZyB9LCBrZXkpIHtcbiAgICBjb25zdCBzaG91bGRCbG9jayA9IHByb3RlY3RlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBuZWVkc0FuaW1hdGluZ1trZXldICE9PSB0cnVlO1xuICAgIG5lZWRzQW5pbWF0aW5nW2tleV0gPSBmYWxzZTtcbiAgICByZXR1cm4gc2hvdWxkQmxvY2s7XG59XG5mdW5jdGlvbiBhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRhcmdldEFuZFRyYW5zaXRpb24sIHsgZGVsYXkgPSAwLCB0cmFuc2l0aW9uT3ZlcnJpZGUsIHR5cGUgfSA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IHRyYW5zaXRpb24gPSB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCksIHRyYW5zaXRpb25FbmQsIC4uLnRhcmdldCB9ID0gdGFyZ2V0QW5kVHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbk92ZXJyaWRlKVxuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBhbmltYXRpb25UeXBlU3RhdGUgPSB0eXBlICYmXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUgJiZcbiAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5nZXRTdGF0ZSgpW3R5cGVdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5LCAoX2EgPSB2aXN1YWxFbGVtZW50LmxhdGVzdFZhbHVlc1trZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKTtcbiAgICAgICAgY29uc3QgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChhbmltYXRpb25UeXBlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRCbG9ja0FuaW1hdGlvbihhbmltYXRpb25UeXBlU3RhdGUsIGtleSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIC4uLmdldFZhbHVlVHJhbnNpdGlvbih0cmFuc2l0aW9uIHx8IHt9LCBrZXkpLFxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSBhIHZhbHVlIGlzIGJlaW5nIGFuaW1hdGVkLCBjaGVja1xuICAgICAgICAgKiB0byBzZWUgaWYgd2UncmUgaGFuZGxpbmcgb2ZmIGZyb20gYW4gZXhpc3RpbmcgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGlzSGFuZG9mZiA9IGZhbHNlO1xuICAgICAgICBpZiAod2luZG93Lk1vdGlvbkhhbmRvZmZBbmltYXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGFwcGVhcklkID0gZ2V0T3B0aW1pc2VkQXBwZWFySWQodmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoYXBwZWFySWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFRpbWUgPSB3aW5kb3cuTW90aW9uSGFuZG9mZkFuaW1hdGlvbihhcHBlYXJJZCwga2V5LCBmcmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0VGltZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZVRyYW5zaXRpb24uc3RhcnRUaW1lID0gc3RhcnRUaW1lO1xuICAgICAgICAgICAgICAgICAgICBpc0hhbmRvZmYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRWYWx1ZVRvV2lsbENoYW5nZSh2aXN1YWxFbGVtZW50LCBrZXkpO1xuICAgICAgICB2YWx1ZS5zdGFydChhbmltYXRlTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSwgdmFsdWVUYXJnZXQsIHZpc3VhbEVsZW1lbnQuc2hvdWxkUmVkdWNlTW90aW9uICYmIHBvc2l0aW9uYWxLZXlzLmhhcyhrZXkpXG4gICAgICAgICAgICA/IHsgdHlwZTogZmFsc2UgfVxuICAgICAgICAgICAgOiB2YWx1ZVRyYW5zaXRpb24sIHZpc3VhbEVsZW1lbnQsIGlzSGFuZG9mZikpO1xuICAgICAgICBjb25zdCBhbmltYXRpb24gPSB2YWx1ZS5hbmltYXRpb247XG4gICAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2l0aW9uRW5kKSB7XG4gICAgICAgIFByb21pc2UuYWxsKGFuaW1hdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZnJhbWUudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kICYmIHNldFRhcmdldCh2aXN1YWxFbGVtZW50LCB0cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG59XG5cbmV4cG9ydCB7IGFuaW1hdGVUYXJnZXQgfTtcbiIsImltcG9ydCB7IHJlc29sdmVWYXJpYW50IH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL3Jlc29sdmUtZHluYW1pYy12YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgYW5pbWF0ZVRhcmdldCB9IGZyb20gJy4vdmlzdWFsLWVsZW1lbnQtdGFyZ2V0Lm1qcyc7XG5cbmZ1bmN0aW9uIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMgPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMudHlwZSA9PT0gXCJleGl0XCJcbiAgICAgICAgPyAoX2EgPSB2aXN1YWxFbGVtZW50LnByZXNlbmNlQ29udGV4dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmN1c3RvbVxuICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgbGV0IHsgdHJhbnNpdGlvbiA9IHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB8fCB7fSB9ID0gcmVzb2x2ZWQgfHwge307XG4gICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSBvcHRpb25zLnRyYW5zaXRpb25PdmVycmlkZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSBhIHZhcmlhbnQsIGNyZWF0ZSBhIGNhbGxiYWNrIHRoYXQgcnVucyBpdCBhcyBhbiBhbmltYXRpb24uXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIGNvbnN0IGdldEFuaW1hdGlvbiA9IHJlc29sdmVkXG4gICAgICAgID8gKCkgPT4gUHJvbWlzZS5hbGwoYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZCwgb3B0aW9ucykpXG4gICAgICAgIDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSBjaGlsZHJlbiwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGFsbCB0aGVpciBhbmltYXRpb25zLlxuICAgICAqIE90aGVyd2lzZSwgd2UgcmVzb2x2ZSBhIFByb21pc2UgaW1tZWRpYXRlbHkgZm9yIGEgY29tcG9zYWJsZSBuby1vcC5cbiAgICAgKi9cbiAgICBjb25zdCBnZXRDaGlsZEFuaW1hdGlvbnMgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbiAmJiB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbi5zaXplXG4gICAgICAgID8gKGZvcndhcmREZWxheSA9IDApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGVsYXlDaGlsZHJlbiA9IDAsIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgfSA9IHRyYW5zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0ZUNoaWxkcmVuKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIGRlbGF5Q2hpbGRyZW4gKyBmb3J3YXJkRGVsYXksIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiBleHBsaWNpdGx5IGRlZmluZXMgYSBcIndoZW5cIiBvcHRpb24sIHdlIG5lZWQgdG8gcmVzb2x2ZSBlaXRoZXJcbiAgICAgKiB0aGlzIGFuaW1hdGlvbiBvciBhbGwgY2hpbGRyZW4gYW5pbWF0aW9ucyBiZWZvcmUgcGxheWluZyB0aGUgb3RoZXIuXG4gICAgICovXG4gICAgY29uc3QgeyB3aGVuIH0gPSB0cmFuc2l0aW9uO1xuICAgIGlmICh3aGVuKSB7XG4gICAgICAgIGNvbnN0IFtmaXJzdCwgbGFzdF0gPSB3aGVuID09PSBcImJlZm9yZUNoaWxkcmVuXCJcbiAgICAgICAgICAgID8gW2dldEFuaW1hdGlvbiwgZ2V0Q2hpbGRBbmltYXRpb25zXVxuICAgICAgICAgICAgOiBbZ2V0Q2hpbGRBbmltYXRpb25zLCBnZXRBbmltYXRpb25dO1xuICAgICAgICByZXR1cm4gZmlyc3QoKS50aGVuKCgpID0+IGxhc3QoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2dldEFuaW1hdGlvbigpLCBnZXRDaGlsZEFuaW1hdGlvbnMob3B0aW9ucy5kZWxheSldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiA9IDAsIHN0YWdnZXJDaGlsZHJlbiA9IDAsIHN0YWdnZXJEaXJlY3Rpb24gPSAxLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IG1heFN0YWdnZXJEdXJhdGlvbiA9ICh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbi5zaXplIC0gMSkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgY29uc3QgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24gPSBzdGFnZ2VyRGlyZWN0aW9uID09PSAxXG4gICAgICAgID8gKGkgPSAwKSA9PiBpICogc3RhZ2dlckNoaWxkcmVuXG4gICAgICAgIDogKGkgPSAwKSA9PiBtYXhTdGFnZ2VyRHVyYXRpb24gLSBpICogc3RhZ2dlckNoaWxkcmVuO1xuICAgIEFycmF5LmZyb20odmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pXG4gICAgICAgIC5zb3J0KHNvcnRCeVRyZWVPcmRlcilcbiAgICAgICAgLmZvckVhY2goKGNoaWxkLCBpKSA9PiB7XG4gICAgICAgIGNoaWxkLm5vdGlmeShcIkFuaW1hdGlvblN0YXJ0XCIsIHZhcmlhbnQpO1xuICAgICAgICBhbmltYXRpb25zLnB1c2goYW5pbWF0ZVZhcmlhbnQoY2hpbGQsIHZhcmlhbnQsIHtcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICBkZWxheTogZGVsYXlDaGlsZHJlbiArIGdlbmVyYXRlU3RhZ2dlckR1cmF0aW9uKGkpLFxuICAgICAgICB9KS50aGVuKCgpID0+IGNoaWxkLm5vdGlmeShcIkFuaW1hdGlvbkNvbXBsZXRlXCIsIHZhcmlhbnQpKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xufVxuZnVuY3Rpb24gc29ydEJ5VHJlZU9yZGVyKGEsIGIpIHtcbiAgICByZXR1cm4gYS5zb3J0Tm9kZVBvc2l0aW9uKGIpO1xufVxuXG5leHBvcnQgeyBhbmltYXRlVmFyaWFudCwgc29ydEJ5VHJlZU9yZGVyIH07XG4iLCJpbXBvcnQgeyByZXNvbHZlVmFyaWFudCB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9yZXNvbHZlLWR5bmFtaWMtdmFyaWFudHMubWpzJztcbmltcG9ydCB7IGFuaW1hdGVUYXJnZXQgfSBmcm9tICcuL3Zpc3VhbC1lbGVtZW50LXRhcmdldC5tanMnO1xuaW1wb3J0IHsgYW5pbWF0ZVZhcmlhbnQgfSBmcm9tICcuL3Zpc3VhbC1lbGVtZW50LXZhcmlhbnQubWpzJztcblxuZnVuY3Rpb24gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJBbmltYXRpb25TdGFydFwiLCBkZWZpbml0aW9uKTtcbiAgICBsZXQgYW5pbWF0aW9uO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBkZWZpbml0aW9uLm1hcCgodmFyaWFudCkgPT4gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucykpO1xuICAgICAgICBhbmltYXRpb24gPSBQcm9taXNlLmFsbChhbmltYXRpb25zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYW5pbWF0aW9uID0gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByZXNvbHZlZERlZmluaXRpb24gPSB0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMuY3VzdG9tKVxuICAgICAgICAgICAgOiBkZWZpbml0aW9uO1xuICAgICAgICBhbmltYXRpb24gPSBQcm9taXNlLmFsbChhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkRGVmaW5pdGlvbiwgb3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uLnRoZW4oKCkgPT4ge1xuICAgICAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkFuaW1hdGlvbkNvbXBsZXRlXCIsIGRlZmluaXRpb24pO1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBhbmltYXRlVmlzdWFsRWxlbWVudCB9O1xuIiwiaW1wb3J0IHsgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuL2lzLXZhcmlhbnQtbGFiZWwubWpzJztcbmltcG9ydCB7IHZhcmlhbnRQcm9wcyB9IGZyb20gJy4vdmFyaWFudC1wcm9wcy5tanMnO1xuXG5jb25zdCBudW1WYXJpYW50UHJvcHMgPSB2YXJpYW50UHJvcHMubGVuZ3RoO1xuZnVuY3Rpb24gZ2V0VmFyaWFudENvbnRleHQodmlzdWFsRWxlbWVudCkge1xuICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQuaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB2aXN1YWxFbGVtZW50LnBhcmVudFxuICAgICAgICAgICAgPyBnZXRWYXJpYW50Q29udGV4dCh2aXN1YWxFbGVtZW50LnBhcmVudCkgfHwge31cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnByb3BzLmluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGV4dC5pbml0aWFsID0gdmlzdWFsRWxlbWVudC5wcm9wcy5pbml0aWFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiAgICBjb25zdCBjb250ZXh0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYXJpYW50UHJvcHM7IGkrKykge1xuICAgICAgICBjb25zdCBuYW1lID0gdmFyaWFudFByb3BzW2ldO1xuICAgICAgICBjb25zdCBwcm9wID0gdmlzdWFsRWxlbWVudC5wcm9wc1tuYW1lXTtcbiAgICAgICAgaWYgKGlzVmFyaWFudExhYmVsKHByb3ApIHx8IHByb3AgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250ZXh0W25hbWVdID0gcHJvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IHsgZ2V0VmFyaWFudENvbnRleHQgfTtcbiIsImltcG9ydCB7IGlzQW5pbWF0aW9uQ29udHJvbHMgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvaXMtYW5pbWF0aW9uLWNvbnRyb2xzLm1qcyc7XG5pbXBvcnQgeyBpc0tleWZyYW1lc1RhcmdldCB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1rZXlmcmFtZXMtdGFyZ2V0Lm1qcyc7XG5pbXBvcnQgeyBzaGFsbG93Q29tcGFyZSB9IGZyb20gJy4uLy4uL3V0aWxzL3NoYWxsb3ctY29tcGFyZS5tanMnO1xuaW1wb3J0IHsgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuL2lzLXZhcmlhbnQtbGFiZWwubWpzJztcbmltcG9ydCB7IHJlc29sdmVWYXJpYW50IH0gZnJvbSAnLi9yZXNvbHZlLWR5bmFtaWMtdmFyaWFudHMubWpzJztcbmltcG9ydCB7IHZhcmlhbnRQcmlvcml0eU9yZGVyIH0gZnJvbSAnLi92YXJpYW50LXByb3BzLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi9pbnRlcmZhY2VzL3Zpc3VhbC1lbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBnZXRWYXJpYW50Q29udGV4dCB9IGZyb20gJy4vZ2V0LXZhcmlhbnQtY29udGV4dC5tanMnO1xuXG5jb25zdCByZXZlcnNlUHJpb3JpdHlPcmRlciA9IFsuLi52YXJpYW50UHJpb3JpdHlPcmRlcl0ucmV2ZXJzZSgpO1xuY29uc3QgbnVtQW5pbWF0aW9uVHlwZXMgPSB2YXJpYW50UHJpb3JpdHlPcmRlci5sZW5ndGg7XG5mdW5jdGlvbiBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KSB7XG4gICAgcmV0dXJuIChhbmltYXRpb25zKSA9PiBQcm9taXNlLmFsbChhbmltYXRpb25zLm1hcCgoeyBhbmltYXRpb24sIG9wdGlvbnMgfSkgPT4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgYW5pbWF0aW9uLCBvcHRpb25zKSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uU3RhdGUodmlzdWFsRWxlbWVudCkge1xuICAgIGxldCBhbmltYXRlID0gYW5pbWF0ZUxpc3QodmlzdWFsRWxlbWVudCk7XG4gICAgbGV0IHN0YXRlID0gY3JlYXRlU3RhdGUoKTtcbiAgICBsZXQgaXNJbml0aWFsUmVuZGVyID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0byByZWR1Y2UgdGhlIGFuaW1hdGlvbiBkZWZpbml0aW9ucyBmb3JcbiAgICAgKiBlYWNoIGFjdGl2ZSBhbmltYXRpb24gdHlwZSBpbnRvIGFuIG9iamVjdCBvZiByZXNvbHZlZCB2YWx1ZXMgZm9yIGl0LlxuICAgICAqL1xuICAgIGNvbnN0IGJ1aWxkUmVzb2x2ZWRUeXBlVmFsdWVzID0gKHR5cGUpID0+IChhY2MsIGRlZmluaXRpb24pID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIHR5cGUgPT09IFwiZXhpdFwiXG4gICAgICAgICAgICA/IChfYSA9IHZpc3VhbEVsZW1lbnQucHJlc2VuY2VDb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VzdG9tXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2l0aW9uLCB0cmFuc2l0aW9uRW5kLCAuLi50YXJnZXQgfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgYWNjID0geyAuLi5hY2MsIC4uLnRhcmdldCwgLi4udHJhbnNpdGlvbkVuZCB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGp1c3QgYWxsb3dzIHVzIHRvIGluamVjdCBtb2NrZWQgYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEFuaW1hdGVGdW5jdGlvbihtYWtlQW5pbWF0b3IpIHtcbiAgICAgICAgYW5pbWF0ZSA9IG1ha2VBbmltYXRvcih2aXN1YWxFbGVtZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hlbiB3ZSByZWNlaXZlIG5ldyBwcm9wcywgd2UgbmVlZCB0bzpcbiAgICAgKiAxLiBDcmVhdGUgYSBsaXN0IG9mIHByb3RlY3RlZCBrZXlzIGZvciBlYWNoIHR5cGUuIFRoaXMgaXMgYSBkaXJlY3Rvcnkgb2ZcbiAgICAgKiAgICB2YWx1ZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBcImhhbmRsZWRcIiBieSB0eXBlcyBvZiBhIGhpZ2hlciBwcmlvcml0eVxuICAgICAqICAgIHNvIHRoYXQgd2hlbmV2ZXIgYW4gYW5pbWF0aW9uIGlzIHBsYXllZCBvZiBhIGdpdmVuIHR5cGUsIHRoZXNlIHZhbHVlcyBhcmVcbiAgICAgKiAgICBwcm90ZWN0ZWQgZnJvbSBiZWluZyBhbmltYXRlZC5cbiAgICAgKiAyLiBEZXRlcm1pbmUgaWYgYW4gYW5pbWF0aW9uIHR5cGUgbmVlZHMgYW5pbWF0aW5nLlxuICAgICAqIDMuIERldGVybWluZSBpZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gYSB0eXBlIGFuZCBmaWd1cmUgb3V0XG4gICAgICogICAgd2hhdCB0byBhbmltYXRlIHRob3NlIHRvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFuaW1hdGVDaGFuZ2VzKGNoYW5nZWRBY3RpdmVUeXBlKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvcHMgfSA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBnZXRWYXJpYW50Q29udGV4dCh2aXN1YWxFbGVtZW50LnBhcmVudCkgfHwge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgYW5pbWF0aW9ucyB0aGF0IHdlJ2xsIGJ1aWxkIGludG8gYXMgd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogdHlwZXMuIFRoaXMgd2lsbCBnZXQgZXhlY3V0ZWQgYXQgdGhlIGVuZCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwIHRyYWNrIG9mIHdoaWNoIHZhbHVlcyBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhlbiwgYXMgd2UgaGl0IGxvd2VyIHByaW9yaXR5XG4gICAgICAgICAqIGFuaW1hdGlvbiB0eXBlcywgd2UgY2FuIGNoZWNrIGlmIHRoZXkgY29udGFpbiByZW1vdmVkIHZhbHVlcyBhbmQgYW5pbWF0ZSB0byB0aGF0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgcmVtb3ZlZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGRpY3Rpb25hcnkgb2YgYWxsIGVuY291bnRlcmVkIGtleXMuIFRoaXMgaXMgYW4gb2JqZWN0IHRvIGxldCB1cyBidWlsZCBpbnRvIGFuZFxuICAgICAgICAgKiBjb3B5IGl0IHdpdGhvdXQgaXRlcmF0aW9uLiBFYWNoIHRpbWUgd2UgaGl0IGFuIGFuaW1hdGlvbiB0eXBlIHdlIHNldCBpdHMgcHJvdGVjdGVkXG4gICAgICAgICAqIGtleXMgLSB0aGUga2V5cyBpdHMgbm90IGFsbG93ZWQgdG8gYW5pbWF0ZSAtIHRvIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGlzIG9iamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBlbmNvdW50ZXJlZEtleXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgdmFyaWFudCBoYXMgYmVlbiByZW1vdmVkIGF0IGEgZ2l2ZW4gaW5kZXgsIGFuZCB0aGlzIGNvbXBvbmVudCBpcyBjb250cm9sbGluZ1xuICAgICAgICAgKiB2YXJpYW50IGFuaW1hdGlvbnMsIHdlIHdhbnQgdG8gZW5zdXJlIGxvd2VyLXByaW9yaXR5IHZhcmlhbnRzIGFyZSBmb3JjZWQgdG8gYW5pbWF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCByZW1vdmVkVmFyaWFudEluZGV4ID0gSW5maW5pdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGFuaW1hdGlvbiB0eXBlcyBpbiByZXZlcnNlIHByaW9yaXR5IG9yZGVyLiBGb3IgZWFjaCwgd2Ugd2FudCB0b1xuICAgICAgICAgKiBkZXRlY3Qgd2hpY2ggdmFsdWVzIGl0J3MgaGFuZGxpbmcgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkndmUgY2hhbmdlZCAoYW5kIHRoZXJlZm9yZVxuICAgICAgICAgKiBuZWVkIHRvIGJlIGFuaW1hdGVkKS4gSWYgYW55IHZhbHVlcyBoYXZlIGJlZW4gcmVtb3ZlZCwgd2Ugd2FudCB0byBkZXRlY3QgdGhvc2UgaW5cbiAgICAgICAgICogbG93ZXIgcHJpb3JpdHkgcHJvcHMgYW5kIGZsYWcgZm9yIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQW5pbWF0aW9uVHlwZXM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHJldmVyc2VQcmlvcml0eU9yZGVyW2ldO1xuICAgICAgICAgICAgY29uc3QgdHlwZVN0YXRlID0gc3RhdGVbdHlwZV07XG4gICAgICAgICAgICBjb25zdCBwcm9wID0gcHJvcHNbdHlwZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gcHJvcHNbdHlwZV1cbiAgICAgICAgICAgICAgICA6IGNvbnRleHRbdHlwZV07XG4gICAgICAgICAgICBjb25zdCBwcm9wSXNWYXJpYW50ID0gaXNWYXJpYW50TGFiZWwocHJvcCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgdHlwZSBoYXMgKmp1c3QqIGNoYW5nZWQgaXNBY3RpdmUgc3RhdHVzLCBzZXQgYWN0aXZlRGVsdGFcbiAgICAgICAgICAgICAqIHRvIHRoYXQgc3RhdHVzLiBPdGhlcndpc2Ugc2V0IHRvIG51bGwuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZURlbHRhID0gdHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgPyB0eXBlU3RhdGUuaXNBY3RpdmUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZW1vdmVkVmFyaWFudEluZGV4ID0gaTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBwcm9wIGlzIGFuIGluaGVyaXRlZCB2YXJpYW50LCByYXRoZXIgdGhhbiBiZWVuIHNldCBkaXJlY3RseSBvbiB0aGVcbiAgICAgICAgICAgICAqIGNvbXBvbmVudCBpdHNlbGYsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGFsbG93IHRoZSBwYXJlbnQgdG8gdHJpZ2dlciBhbmltYXRpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IENhbiBwcm9iYWJseSBjaGFuZ2UgdGhpcyB0byBhICFpc0NvbnRyb2xsaW5nVmFyaWFudHMgY2hlY2tcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGlzSW5oZXJpdGVkID0gcHJvcCA9PT0gY29udGV4dFt0eXBlXSAmJlxuICAgICAgICAgICAgICAgIHByb3AgIT09IHByb3BzW3R5cGVdICYmXG4gICAgICAgICAgICAgICAgcHJvcElzVmFyaWFudDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzSW5oZXJpdGVkICYmXG4gICAgICAgICAgICAgICAgaXNJbml0aWFsUmVuZGVyICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICAgICAgICAgICAgaXNJbmhlcml0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IGFsbCBlbmNvdW50ZXJlZCBrZXlzIHNvIGZhciBhcyB0aGUgcHJvdGVjdGVkIGtleXMgZm9yIHRoaXMgdHlwZS4gVGhpcyB3aWxsXG4gICAgICAgICAgICAgKiBiZSBhbnkga2V5IHRoYXQgaGFzIGJlZW4gYW5pbWF0ZWQgb3Igb3RoZXJ3aXNlIGhhbmRsZWQgYnkgYWN0aXZlLCBoaWdoZXItcHJpb3J0aXkgdHlwZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzID0geyAuLi5lbmNvdW50ZXJlZEtleXMgfTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBza2lwIGFuYWx5c2luZyB0aGlzIHByb3AgZWFybHlcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIElmIGl0IGlzbid0IGFjdGl2ZSBhbmQgaGFzbid0ICpqdXN0KiBiZWVuIHNldCBhcyBpbmFjdGl2ZVxuICAgICAgICAgICAgKCF0eXBlU3RhdGUuaXNBY3RpdmUgJiYgYWN0aXZlRGVsdGEgPT09IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGFuZCBkb24ndCBoYXZlIGFueSBkZWZpbmVkIHByb3AgZm9yIHRoaXMgYW5pbWF0aW9uIHR5cGVcbiAgICAgICAgICAgICAgICAoIXByb3AgJiYgIXR5cGVTdGF0ZS5wcmV2UHJvcCkgfHxcbiAgICAgICAgICAgICAgICAvLyBPciBpZiB0aGUgcHJvcCBkb2Vzbid0IGRlZmluZSBhbiBhbmltYXRpb25cbiAgICAgICAgICAgICAgICBpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3ApIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIHByb3AgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzIHdlIGdvIGxvb2sgdGhyb3VnaCB0aGUgdmFsdWVzIGRlZmluZWQgb24gdGhpcyB0eXBlLCBpZiB3ZSBkZXRlY3RcbiAgICAgICAgICAgICAqIGEgY2hhbmdlZCB2YWx1ZSBvciBhIHZhbHVlIHRoYXQgd2FzIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHksIHdlIHNldFxuICAgICAgICAgICAgICogdGhpcyB0byB0cnVlIGFuZCBhZGQgdGhpcyBwcm9wIHRvIHRoZSBhbmltYXRpb24gbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudERpZENoYW5nZSA9IGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UodHlwZVN0YXRlLnByZXZQcm9wLCBwcm9wKTtcbiAgICAgICAgICAgIGxldCBzaG91bGRBbmltYXRlVHlwZSA9IHZhcmlhbnREaWRDaGFuZ2UgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBtYWtpbmcgdGhpcyB2YXJpYW50IGFjdGl2ZSwgd2Ugd2FudCB0byBhbHdheXMgbWFrZSBpdCBhY3RpdmVcbiAgICAgICAgICAgICAgICAodHlwZSA9PT0gY2hhbmdlZEFjdGl2ZVR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLmlzQWN0aXZlICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0luaGVyaXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICBwcm9wSXNWYXJpYW50KSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlbW92ZWQgYSBoaWdoZXItcHJpb3JpdHkgdmFyaWFudCAoaSBpcyBpbiByZXZlcnNlIG9yZGVyKVxuICAgICAgICAgICAgICAgIChpID4gcmVtb3ZlZFZhcmlhbnRJbmRleCAmJiBwcm9wSXNWYXJpYW50KTtcbiAgICAgICAgICAgIGxldCBoYW5kbGVkUmVtb3ZlZFZhbHVlcyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcyBhbmltYXRpb25zIGNhbiBiZSBzZXQgYXMgdmFyaWFudCBsaXN0cywgdmFyaWFudHMgb3IgdGFyZ2V0IG9iamVjdHMsIHdlXG4gICAgICAgICAgICAgKiBjb2VyY2UgZXZlcnl0aGluZyB0byBhbiBhcnJheSBpZiBpdCBpc24ndCBvbmUgYWxyZWFkeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uTGlzdCA9IEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCdWlsZCBhbiBvYmplY3Qgb2YgYWxsIHRoZSByZXNvbHZlZCB2YWx1ZXMuIFdlJ2xsIHVzZSB0aGlzIGluIHRoZSBzdWJzZXF1ZW50XG4gICAgICAgICAgICAgKiBhbmltYXRlQ2hhbmdlcyBjYWxscyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgcmVzb2x2ZWRWYWx1ZXMgPSBkZWZpbml0aW9uTGlzdC5yZWR1Y2UoYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXModHlwZSksIHt9KTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVEZWx0YSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm93IHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGFsbCB0aGUga2V5cyBpbiB0aGUgcHJldiBwcm9wIGFuZCB0aGlzIHByb3AsXG4gICAgICAgICAgICAgKiBhbmQgZGVjaWRlOlxuICAgICAgICAgICAgICogMS4gSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBhbmQgbmVlZHMgYW5pbWF0aW5nXG4gICAgICAgICAgICAgKiAyLiBJZiBpdCBoYXMgYmVlbiByZW1vdmVkLCBhbmQgbmVlZHMgYWRkaW5nIHRvIHRoZSByZW1vdmVkS2V5cyBzZXRcbiAgICAgICAgICAgICAqIDMuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgdHlwZSBhbmQgbmVlZHMgYW5pbWF0aW5nXG4gICAgICAgICAgICAgKiA0LiBJZiBpdCBoYXNuJ3QgYmVlbiByZW1vdmVkIGluIGEgaGlnaGVyIHByaW9yaXR5IGJ1dCBoYXNuJ3QgY2hhbmdlZCwgYW5kXG4gICAgICAgICAgICAgKiAgICBuZWVkcyBhZGRpbmcgdG8gdGhlIHR5cGUncyBwcm90ZWN0ZWRLZXlzIGxpc3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHsgcHJldlJlc29sdmVkVmFsdWVzID0ge30gfSA9IHR5cGVTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEtleXMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucHJldlJlc29sdmVkVmFsdWVzLFxuICAgICAgICAgICAgICAgIC4uLnJlc29sdmVkVmFsdWVzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG1hcmtUb0FuaW1hdGUgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVkUmVtb3ZlZFZhbHVlcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eXBlU3RhdGUubmVlZHNBbmltYXRpbmdba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgbW90aW9uVmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBtb3Rpb25WYWx1ZS5saXZlU3R5bGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IHByZXZSZXNvbHZlZFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGlzIHdlIGNhbiBqdXN0IHNraXAgYWhlYWRcbiAgICAgICAgICAgICAgICBpZiAoZW5jb3VudGVyZWRLZXlzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwgd2UgcHJvYmFibHkgd2FudCB0byBhbmltYXRlIGl0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZUhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQobmV4dCkgJiYgaXNLZXlmcmFtZXNUYXJnZXQocHJldikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNDaGFuZ2VkID0gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNDaGFuZ2VkID0gbmV4dCAhPT0gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIG5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5leHQgaXMgZGVmaW5lZCBhbmQgZG9lc24ndCBlcXVhbCBwcmV2LCBpdCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgdW5kZWZpbmVkLCBpdCdzIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiByZW1vdmVkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgbmV4dCBoYXNuJ3QgY2hhbmdlZCBhbmQgaXQgaXNuJ3QgdW5kZWZpbmVkLCB3ZSB3YW50IHRvIGNoZWNrIGlmIGl0J3NcbiAgICAgICAgICAgICAgICAgICAgICogYmVlbiByZW1vdmVkIGJ5IGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgaXQgaGFzbid0IGNoYW5nZWQsIHdlIGFkZCBpdCB0byB0aGUgbGlzdCBvZiBwcm90ZWN0ZWQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIGVuc3VyZSBpdCBkb2Vzbid0IGdldCBhbmltYXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSB0eXBlU3RhdGUgc28gbmV4dCB0aW1lIGFuaW1hdGVDaGFuZ2VzIGlzIGNhbGxlZCB3ZSBjYW4gY29tcGFyZSB0aGVcbiAgICAgICAgICAgICAqIGxhdGVzdCBwcm9wIGFuZCByZXNvbHZlZFZhbHVlcyB0byB0aGVzZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByZXZQcm9wID0gcHJvcDtcbiAgICAgICAgICAgIHR5cGVTdGF0ZS5wcmV2UmVzb2x2ZWRWYWx1ZXMgPSByZXNvbHZlZFZhbHVlcztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHR5cGVTdGF0ZS5pc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGVuY291bnRlcmVkS2V5cyA9IHsgLi4uZW5jb3VudGVyZWRLZXlzLCAuLi5yZXNvbHZlZFZhbHVlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlbmRlciAmJiB2aXN1YWxFbGVtZW50LmJsb2NrSW5pdGlhbEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHNob3VsZEFuaW1hdGVUeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gaW5oZXJpdGVkIHByb3Agd2Ugd2FudCB0byBza2lwIHRoaXMgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiB1bmxlc3MgdGhlIGluaGVyaXRlZCB2YXJpYW50cyBoYXZlbid0IGNoYW5nZWQgb24gdGhpcyByZW5kZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHdpbGxBbmltYXRlVmlhUGFyZW50ID0gaXNJbmhlcml0ZWQgJiYgdmFyaWFudERpZENoYW5nZTtcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzQW5pbWF0aW5nID0gIXdpbGxBbmltYXRlVmlhUGFyZW50IHx8IGhhbmRsZWRSZW1vdmVkVmFsdWVzO1xuICAgICAgICAgICAgaWYgKHNob3VsZEFuaW1hdGVUeXBlICYmIG5lZWRzQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKC4uLmRlZmluaXRpb25MaXN0Lm1hcCgoYW5pbWF0aW9uKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogeyB0eXBlIH0sXG4gICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlcmUgYXJlIHNvbWUgcmVtb3ZlZCB2YWx1ZSB0aGF0IGhhdmVuJ3QgYmVlbiBkZWFsdCB3aXRoLFxuICAgICAgICAgKiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBhbmltYXRpb24gdGhhdCBmYWxscyBiYWNrIGVpdGhlciB0byB0aGUgdmFsdWVcbiAgICAgICAgICogZGVmaW5lZCBpbiB0aGUgc3R5bGUgcHJvcCwgb3IgdGhlIGxhc3QgcmVhZCB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChyZW1vdmVkS2V5cy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBmYWxsYmFja0FuaW1hdGlvbiA9IHt9O1xuICAgICAgICAgICAgcmVtb3ZlZEtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmFsbGJhY2tUYXJnZXQgPSB2aXN1YWxFbGVtZW50LmdldEJhc2VUYXJnZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLmxpdmVTdHlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIEBtYXR0Z3BlcnJ5IHRvIGZpZ3VyZSBpZiB3ZSBzaG91bGQgZG8gc29tZXRoaW5nIGhlcmVcbiAgICAgICAgICAgICAgICBmYWxsYmFja0FuaW1hdGlvbltrZXldID0gZmFsbGJhY2tUYXJnZXQgIT09IG51bGwgJiYgZmFsbGJhY2tUYXJnZXQgIT09IHZvaWQgMCA/IGZhbGxiYWNrVGFyZ2V0IDogbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKHsgYW5pbWF0aW9uOiBmYWxsYmFja0FuaW1hdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2hvdWxkQW5pbWF0ZSA9IEJvb2xlYW4oYW5pbWF0aW9ucy5sZW5ndGgpO1xuICAgICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmXG4gICAgICAgICAgICAocHJvcHMuaW5pdGlhbCA9PT0gZmFsc2UgfHwgcHJvcHMuaW5pdGlhbCA9PT0gcHJvcHMuYW5pbWF0ZSkgJiZcbiAgICAgICAgICAgICF2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgIHNob3VsZEFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpc0luaXRpYWxSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNob3VsZEFuaW1hdGUgPyBhbmltYXRlKGFuaW1hdGlvbnMpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB3aGV0aGVyIGEgY2VydGFpbiBhbmltYXRpb24gdHlwZSBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gSWYgdGhlIGFjdGl2ZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZCwgd2UgY2FuIHNhZmVseSBkbyBub3RoaW5nIGhlcmVcbiAgICAgICAgaWYgKHN0YXRlW3R5cGVdLmlzQWN0aXZlID09PSBpc0FjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIGFjdGl2ZSBjaGFuZ2UgdG8gY2hpbGRyZW5cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChjaGlsZCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBjaGlsZC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSk7IH0pO1xuICAgICAgICBzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9IGlzQWN0aXZlO1xuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gYW5pbWF0ZUNoYW5nZXModHlwZSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZVtrZXldLnByb3RlY3RlZEtleXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW5pbWF0ZUNoYW5nZXMsXG4gICAgICAgIHNldEFjdGl2ZSxcbiAgICAgICAgc2V0QW5pbWF0ZUZ1bmN0aW9uLFxuICAgICAgICBnZXRTdGF0ZTogKCkgPT4gc3RhdGUsXG4gICAgICAgIHJlc2V0OiAoKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZSA9IGNyZWF0ZVN0YXRlKCk7XG4gICAgICAgICAgICBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICAgICAgICB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlKHByZXYsIG5leHQpIHtcbiAgICBpZiAodHlwZW9mIG5leHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5leHQgIT09IHByZXY7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVN0YXRlKGlzQWN0aXZlID0gZmFsc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpc0FjdGl2ZSxcbiAgICAgICAgcHJvdGVjdGVkS2V5czoge30sXG4gICAgICAgIG5lZWRzQW5pbWF0aW5nOiB7fSxcbiAgICAgICAgcHJldlJlc29sdmVkVmFsdWVzOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYW5pbWF0ZTogY3JlYXRlVHlwZVN0YXRlKHRydWUpLFxuICAgICAgICB3aGlsZUluVmlldzogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIHdoaWxlSG92ZXI6IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICB3aGlsZVRhcDogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIHdoaWxlRHJhZzogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIHdoaWxlRm9jdXM6IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBleGl0OiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlLCBjcmVhdGVBbmltYXRpb25TdGF0ZSB9O1xuIiwiY2xhc3MgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICB0aGlzLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7IH1cbn1cblxuZXhwb3J0IHsgRmVhdHVyZSB9O1xuIiwiaW1wb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4uLy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUFuaW1hdGlvblN0YXRlIH0gZnJvbSAnLi4vLi4vLi4vcmVuZGVyL3V0aWxzL2FuaW1hdGlvbi1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gJy4uL0ZlYXR1cmUubWpzJztcblxuY2xhc3MgQW5pbWF0aW9uRmVhdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIC8qKlxuICAgICAqIFdlIGR5bmFtaWNhbGx5IGdlbmVyYXRlIHRoZSBBbmltYXRpb25TdGF0ZSBtYW5hZ2VyIGFzIGl0IGNvbnRhaW5zIGEgcmVmZXJlbmNlXG4gICAgICogdG8gdGhlIHVuZGVybHlpbmcgYW5pbWF0aW9uIGxpYnJhcnkuIFdlIG9ubHkgd2FudCB0byBsb2FkIHRoYXQgaWYgd2UgbG9hZCB0aGlzLFxuICAgICAqIHNvIHBlb3BsZSBjYW4gb3B0aW9uYWxseSBjb2RlIHNwbGl0IGl0IG91dCB1c2luZyB0aGUgYG1gIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgICAgIHN1cGVyKG5vZGUpO1xuICAgICAgICBub2RlLmFuaW1hdGlvblN0YXRlIHx8IChub2RlLmFuaW1hdGlvblN0YXRlID0gY3JlYXRlQW5pbWF0aW9uU3RhdGUobm9kZSkpO1xuICAgIH1cbiAgICB1cGRhdGVBbmltYXRpb25Db250cm9sc1N1YnNjcmlwdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyBhbmltYXRlIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VudENvbnRyb2xzID0gYW5pbWF0ZS5zdWJzY3JpYmUodGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgYW55IHByb3ZpZGVkIEFuaW1hdGlvbkNvbnRyb2xzIHRvIHRoZSBjb21wb25lbnQncyBWaXN1YWxFbGVtZW50XG4gICAgICovXG4gICAgbW91bnQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uQ29udHJvbHNTdWJzY3JpcHRpb24oKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGFuaW1hdGUgfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGU6IHByZXZBbmltYXRlIH0gPSB0aGlzLm5vZGUucHJldlByb3BzIHx8IHt9O1xuICAgICAgICBpZiAoYW5pbWF0ZSAhPT0gcHJldkFuaW1hdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5pbWF0aW9uQ29udHJvbHNTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5yZXNldCgpO1xuICAgICAgICAoX2EgPSB0aGlzLnVubW91bnRDb250cm9scykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBbmltYXRpb25GZWF0dXJlIH07XG4iLCJpbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vRmVhdHVyZS5tanMnO1xuXG5sZXQgaWQgPSAwO1xuY2xhc3MgRXhpdEFuaW1hdGlvbkZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkKys7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUucHJlc2VuY2VDb250ZXh0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUgfSA9IHRoaXMubm9kZS5wcmVzZW5jZUNvbnRleHQ7XG4gICAgICAgIGNvbnN0IHsgaXNQcmVzZW50OiBwcmV2SXNQcmVzZW50IH0gPSB0aGlzLm5vZGUucHJldlByZXNlbmNlQ29udGV4dCB8fCB7fTtcbiAgICAgICAgaWYgKCF0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUgfHwgaXNQcmVzZW50ID09PSBwcmV2SXNQcmVzZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpdEFuaW1hdGlvbiA9IHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJleGl0XCIsICFpc1ByZXNlbnQpO1xuICAgICAgICBpZiAob25FeGl0Q29tcGxldGUgJiYgIWlzUHJlc2VudCkge1xuICAgICAgICAgICAgZXhpdEFuaW1hdGlvbi50aGVuKCgpID0+IG9uRXhpdENvbXBsZXRlKHRoaXMuaWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyByZWdpc3RlciB9ID0gdGhpcy5ub2RlLnByZXNlbmNlQ29udGV4dCB8fCB7fTtcbiAgICAgICAgaWYgKHJlZ2lzdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnVubW91bnQgPSByZWdpc3Rlcih0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbmV4cG9ydCB7IEV4aXRBbmltYXRpb25GZWF0dXJlIH07XG4iLCJpbXBvcnQgeyBBbmltYXRpb25GZWF0dXJlIH0gZnJvbSAnLi9hbmltYXRpb24vaW5kZXgubWpzJztcbmltcG9ydCB7IEV4aXRBbmltYXRpb25GZWF0dXJlIH0gZnJvbSAnLi9hbmltYXRpb24vZXhpdC5tanMnO1xuXG5jb25zdCBhbmltYXRpb25zID0ge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBGZWF0dXJlOiBBbmltYXRpb25GZWF0dXJlLFxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgICBGZWF0dXJlOiBFeGl0QW5pbWF0aW9uRmVhdHVyZSxcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgYW5pbWF0aW9ucyB9O1xuIiwiZnVuY3Rpb24gYWRkRG9tRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7IHBhc3NpdmU6IHRydWUgfSkge1xuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG59XG5cbmV4cG9ydCB7IGFkZERvbUV2ZW50IH07XG4iLCJpbXBvcnQgeyBpc1ByaW1hcnlQb2ludGVyIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludDoge1xuICAgICAgICAgICAgeDogZXZlbnQucGFnZVgsXG4gICAgICAgICAgICB5OiBldmVudC5wYWdlWSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuY29uc3QgYWRkUG9pbnRlckluZm8gPSAoaGFuZGxlcikgPT4ge1xuICAgIHJldHVybiAoZXZlbnQpID0+IGlzUHJpbWFyeVBvaW50ZXIoZXZlbnQpICYmIGhhbmRsZXIoZXZlbnQsIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpKTtcbn07XG5cbmV4cG9ydCB7IGFkZFBvaW50ZXJJbmZvLCBleHRyYWN0RXZlbnRJbmZvIH07XG4iLCJpbXBvcnQgeyBhZGREb21FdmVudCB9IGZyb20gJy4vYWRkLWRvbS1ldmVudC5tanMnO1xuaW1wb3J0IHsgYWRkUG9pbnRlckluZm8gfSBmcm9tICcuL2V2ZW50LWluZm8ubWpzJztcblxuZnVuY3Rpb24gYWRkUG9pbnRlckV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBhZGRQb2ludGVySW5mbyhoYW5kbGVyKSwgb3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IGFkZFBvaW50ZXJFdmVudCB9O1xuIiwiY29uc3QgZGlzdGFuY2UgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpO1xuZnVuY3Rpb24gZGlzdGFuY2UyRChhLCBiKSB7XG4gICAgLy8gTXVsdGktZGltZW5zaW9uYWxcbiAgICBjb25zdCB4RGVsdGEgPSBkaXN0YW5jZShhLngsIGIueCk7XG4gICAgY29uc3QgeURlbHRhID0gZGlzdGFuY2UoYS55LCBiLnkpO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeERlbHRhICoqIDIgKyB5RGVsdGEgKiogMik7XG59XG5cbmV4cG9ydCB7IGRpc3RhbmNlLCBkaXN0YW5jZTJEIH07XG4iLCJpbXBvcnQgeyBpc1ByaW1hcnlQb2ludGVyIH0gZnJvbSAnbW90aW9uLWRvbSc7XG5pbXBvcnQgeyBzZWNvbmRzVG9NaWxsaXNlY29uZHMsIG1pbGxpc2Vjb25kc1RvU2Vjb25kcyB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBhZGRQb2ludGVyRXZlbnQgfSBmcm9tICcuLi8uLi9ldmVudHMvYWRkLXBvaW50ZXItZXZlbnQubWpzJztcbmltcG9ydCB7IGV4dHJhY3RFdmVudEluZm8gfSBmcm9tICcuLi8uLi9ldmVudHMvZXZlbnQtaW5mby5tanMnO1xuaW1wb3J0IHsgZGlzdGFuY2UyRCB9IGZyb20gJy4uLy4uL3V0aWxzL2Rpc3RhbmNlLm1qcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcGlwZS5tanMnO1xuaW1wb3J0IHsgZnJhbWUsIGNhbmNlbEZyYW1lLCBmcmFtZURhdGEgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUGFuU2Vzc2lvbiB7XG4gICAgY29uc3RydWN0b3IoZXZlbnQsIGhhbmRsZXJzLCB7IHRyYW5zZm9ybVBhZ2VQb2ludCwgY29udGV4dFdpbmRvdywgZHJhZ1NuYXBUb09yaWdpbiA9IGZhbHNlLCB9ID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydEV2ZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0V2luZG93ID0gd2luZG93O1xuICAgICAgICB0aGlzLnVwZGF0ZVBvaW50ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5sYXN0TW92ZUV2ZW50ICYmIHRoaXMubGFzdE1vdmVFdmVudEluZm8pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRQYW5JbmZvKHRoaXMubGFzdE1vdmVFdmVudEluZm8sIHRoaXMuaGlzdG9yeSk7XG4gICAgICAgICAgICBjb25zdCBpc1BhblN0YXJ0ZWQgPSB0aGlzLnN0YXJ0RXZlbnQgIT09IG51bGw7XG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IHBhbm5pbmcgaWYgdGhlIG9mZnNldCBpcyBsYXJnZXIgdGhhbiAzIHBpeGVscy4gSWYgd2UgbWFrZSBpdFxuICAgICAgICAgICAgLy8gYW55IGxhcmdlciB0aGFuIHRoaXMgd2UnbGwgd2FudCB0byByZXNldCB0aGUgcG9pbnRlciBoaXN0b3J5XG4gICAgICAgICAgICAvLyBvbiB0aGUgZmlyc3QgdXBkYXRlIHRvIGF2b2lkIHZpc3VhbCBzbmFwcGluZyB0byB0aGUgY3Vyc29lLlxuICAgICAgICAgICAgY29uc3QgaXNEaXN0YW5jZVBhc3RUaHJlc2hvbGQgPSBkaXN0YW5jZTJEKGluZm8ub2Zmc2V0LCB7IHg6IDAsIHk6IDAgfSkgPj0gMztcbiAgICAgICAgICAgIGlmICghaXNQYW5TdGFydGVkICYmICFpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IHBvaW50IH0gPSBpbmZvO1xuICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXAgfSA9IGZyYW1lRGF0YTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHsgLi4ucG9pbnQsIHRpbWVzdGFtcCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgb25TdGFydCwgb25Nb3ZlIH0gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQodGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSB0aGlzLmxhc3RNb3ZlRXZlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbk1vdmUgJiYgb25Nb3ZlKHRoaXMubGFzdE1vdmVFdmVudCwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgIHRoaXMubGFzdE1vdmVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgICAgIC8vIFRocm90dGxlIG1vdXNlIG1vdmUgZXZlbnQgdG8gb25jZSBwZXIgZnJhbWVcbiAgICAgICAgICAgIGZyYW1lLnVwZGF0ZSh0aGlzLnVwZGF0ZVBvaW50LCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyVXAgPSAoZXZlbnQsIGluZm8pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgICAgICBjb25zdCB7IG9uRW5kLCBvblNlc3Npb25FbmQsIHJlc3VtZUFuaW1hdGlvbiB9ID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdTbmFwVG9PcmlnaW4pXG4gICAgICAgICAgICAgICAgcmVzdW1lQW5pbWF0aW9uICYmIHJlc3VtZUFuaW1hdGlvbigpO1xuICAgICAgICAgICAgaWYgKCEodGhpcy5sYXN0TW92ZUV2ZW50ICYmIHRoaXMubGFzdE1vdmVFdmVudEluZm8pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHBhbkluZm8gPSBnZXRQYW5JbmZvKGV2ZW50LnR5cGUgPT09IFwicG9pbnRlcmNhbmNlbFwiXG4gICAgICAgICAgICAgICAgPyB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvXG4gICAgICAgICAgICAgICAgOiB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCksIHRoaXMuaGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydEV2ZW50ICYmIG9uRW5kKSB7XG4gICAgICAgICAgICAgICAgb25FbmQoZXZlbnQsIHBhbkluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25TZXNzaW9uRW5kICYmIG9uU2Vzc2lvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSB0b3VjaCwgZG9uJ3Qgc3RhcnQgZGV0ZWN0aW5nIHRoaXMgZ2VzdHVyZVxuICAgICAgICBpZiAoIWlzUHJpbWFyeVBvaW50ZXIoZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRyYWdTbmFwVG9PcmlnaW4gPSBkcmFnU25hcFRvT3JpZ2luO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICB0aGlzLmNvbnRleHRXaW5kb3cgPSBjb250ZXh0V2luZG93IHx8IHdpbmRvdztcbiAgICAgICAgY29uc3QgaW5mbyA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpO1xuICAgICAgICBjb25zdCBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgY29uc3QgeyBwb2ludCB9ID0gaW5pdGlhbEluZm87XG4gICAgICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSBmcmFtZURhdGE7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFt7IC4uLnBvaW50LCB0aW1lc3RhbXAgfV07XG4gICAgICAgIGNvbnN0IHsgb25TZXNzaW9uU3RhcnQgfSA9IGhhbmRsZXJzO1xuICAgICAgICBvblNlc3Npb25TdGFydCAmJlxuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQoZXZlbnQsIGdldFBhbkluZm8oaW5pdGlhbEluZm8sIHRoaXMuaGlzdG9yeSkpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBpcGUoYWRkUG9pbnRlckV2ZW50KHRoaXMuY29udGV4dFdpbmRvdywgXCJwb2ludGVybW92ZVwiLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKSwgYWRkUG9pbnRlckV2ZW50KHRoaXMuY29udGV4dFdpbmRvdywgXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApLCBhZGRQb2ludGVyRXZlbnQodGhpcy5jb250ZXh0V2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApKTtcbiAgICB9XG4gICAgdXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzICYmIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIGNhbmNlbEZyYW1lKHRoaXMudXBkYXRlUG9pbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYWdlUG9pbnQgPyB7IHBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQoaW5mby5wb2ludCkgfSA6IGluZm87XG59XG5mdW5jdGlvbiBzdWJ0cmFjdFBvaW50KGEsIGIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyh7IHBvaW50IH0sIGhpc3RvcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludCxcbiAgICAgICAgZGVsdGE6IHN1YnRyYWN0UG9pbnQocG9pbnQsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIG9mZnNldDogc3VidHJhY3RQb2ludChwb2ludCwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eShoaXN0b3J5LCAwLjEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gaGlzdG9yeVswXTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICBsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICBsZXQgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gbGFzdERldmljZVBvaW50KGhpc3RvcnkpO1xuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgdGltZXN0YW1wZWRQb2ludCA9IGhpc3RvcnlbaV07XG4gICAgICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPlxuICAgICAgICAgICAgc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRpbWVEZWx0YSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApO1xuICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0ge1xuICAgICAgICB4OiAobGFzdFBvaW50LnggLSB0aW1lc3RhbXBlZFBvaW50LngpIC8gdGltZSxcbiAgICAgICAgeTogKGxhc3RQb2ludC55IC0gdGltZXN0YW1wZWRQb2ludC55KSAvIHRpbWUsXG4gICAgfTtcbiAgICBpZiAoY3VycmVudFZlbG9jaXR5LnggPT09IEluZmluaXR5KSB7XG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS54ID0gMDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjdXJyZW50VmVsb2NpdHkueSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmVsb2NpdHk7XG59XG5cbmV4cG9ydCB7IFBhblNlc3Npb24gfTtcbiIsImZ1bmN0aW9uIGlzUmVmT2JqZWN0KHJlZikge1xuICAgIHJldHVybiAocmVmICYmXG4gICAgICAgIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpKTtcbn1cblxuZXhwb3J0IHsgaXNSZWZPYmplY3QgfTtcbiIsImltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcblxuY29uc3QgU0NBTEVfUFJFQ0lTSU9OID0gMC4wMDAxO1xuY29uc3QgU0NBTEVfTUlOID0gMSAtIFNDQUxFX1BSRUNJU0lPTjtcbmNvbnN0IFNDQUxFX01BWCA9IDEgKyBTQ0FMRV9QUkVDSVNJT047XG5jb25zdCBUUkFOU0xBVEVfUFJFQ0lTSU9OID0gMC4wMTtcbmNvbnN0IFRSQU5TTEFURV9NSU4gPSAwIC0gVFJBTlNMQVRFX1BSRUNJU0lPTjtcbmNvbnN0IFRSQU5TTEFURV9NQVggPSAwICsgVFJBTlNMQVRFX1BSRUNJU0lPTjtcbmZ1bmN0aW9uIGNhbGNMZW5ndGgoYXhpcykge1xuICAgIHJldHVybiBheGlzLm1heCAtIGF4aXMubWluO1xufVxuZnVuY3Rpb24gaXNOZWFyKHZhbHVlLCB0YXJnZXQsIG1heERpc3RhbmNlKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHZhbHVlIC0gdGFyZ2V0KSA8PSBtYXhEaXN0YW5jZTtcbn1cbmZ1bmN0aW9uIGNhbGNBeGlzRGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4gPSAwLjUpIHtcbiAgICBkZWx0YS5vcmlnaW4gPSBvcmlnaW47XG4gICAgZGVsdGEub3JpZ2luUG9pbnQgPSBtaXhOdW1iZXIoc291cmNlLm1pbiwgc291cmNlLm1heCwgZGVsdGEub3JpZ2luKTtcbiAgICBkZWx0YS5zY2FsZSA9IGNhbGNMZW5ndGgodGFyZ2V0KSAvIGNhbGNMZW5ndGgoc291cmNlKTtcbiAgICBkZWx0YS50cmFuc2xhdGUgPVxuICAgICAgICBtaXhOdW1iZXIodGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCwgZGVsdGEub3JpZ2luKSAtIGRlbHRhLm9yaWdpblBvaW50O1xuICAgIGlmICgoZGVsdGEuc2NhbGUgPj0gU0NBTEVfTUlOICYmIGRlbHRhLnNjYWxlIDw9IFNDQUxFX01BWCkgfHxcbiAgICAgICAgaXNOYU4oZGVsdGEuc2NhbGUpKSB7XG4gICAgICAgIGRlbHRhLnNjYWxlID0gMS4wO1xuICAgIH1cbiAgICBpZiAoKGRlbHRhLnRyYW5zbGF0ZSA+PSBUUkFOU0xBVEVfTUlOICYmXG4gICAgICAgIGRlbHRhLnRyYW5zbGF0ZSA8PSBUUkFOU0xBVEVfTUFYKSB8fFxuICAgICAgICBpc05hTihkZWx0YS50cmFuc2xhdGUpKSB7XG4gICAgICAgIGRlbHRhLnRyYW5zbGF0ZSA9IDAuMDtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjQm94RGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICBjYWxjQXhpc0RlbHRhKGRlbHRhLngsIHNvdXJjZS54LCB0YXJnZXQueCwgb3JpZ2luID8gb3JpZ2luLm9yaWdpblggOiB1bmRlZmluZWQpO1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueSwgc291cmNlLnksIHRhcmdldC55LCBvcmlnaW4gPyBvcmlnaW4ub3JpZ2luWSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICAgIHRhcmdldC5taW4gPSBwYXJlbnQubWluICsgcmVsYXRpdmUubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChyZWxhdGl2ZSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVCb3godGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueCwgcmVsYXRpdmUueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LnksIHJlbGF0aXZlLnksIHBhcmVudC55KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IGxheW91dC5taW4gLSBwYXJlbnQubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChsYXlvdXQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueCwgbGF5b3V0LngsIHBhcmVudC54KTtcbiAgICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LnksIGxheW91dC55LCBwYXJlbnQueSk7XG59XG5cbmV4cG9ydCB7IGNhbGNBeGlzRGVsdGEsIGNhbGNCb3hEZWx0YSwgY2FsY0xlbmd0aCwgY2FsY1JlbGF0aXZlQXhpcywgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uLCBjYWxjUmVsYXRpdmVCb3gsIGNhbGNSZWxhdGl2ZVBvc2l0aW9uLCBpc05lYXIgfTtcbiIsImltcG9ydCB7IHByb2dyZXNzIH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGNhbGNMZW5ndGggfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvY2xhbXAubWpzJztcbmltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcblxuLyoqXG4gKiBBcHBseSBjb25zdHJhaW50cyB0byBhIHBvaW50LiBUaGVzZSBjb25zdHJhaW50cyBhcmUgYm90aCBwaHlzaWNhbCBhbG9uZyBhblxuICogYXhpcywgYW5kIGFuIGVsYXN0aWMgZmFjdG9yIHRoYXQgZGV0ZXJtaW5lcyBob3cgbXVjaCB0byBjb25zdHJhaW4gdGhlIHBvaW50XG4gKiBieSBpZiBpdCBkb2VzIGxpZSBvdXRzaWRlIHRoZSBkZWZpbmVkIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMocG9pbnQsIHsgbWluLCBtYXggfSwgZWxhc3RpYykge1xuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBwb2ludCA8IG1pbikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWluIHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpY1xuICAgICAgICAgICAgPyBtaXhOdW1iZXIobWluLCBwb2ludCwgZWxhc3RpYy5taW4pXG4gICAgICAgICAgICA6IE1hdGgubWF4KHBvaW50LCBtaW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBwb2ludCA+IG1heCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF4IHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpY1xuICAgICAgICAgICAgPyBtaXhOdW1iZXIobWF4LCBwb2ludCwgZWxhc3RpYy5tYXgpXG4gICAgICAgICAgICA6IE1hdGgubWluKHBvaW50LCBtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBjb25zdHJhaW50cyBpbiB0ZXJtcyBvZiB0aGUgdmlld3BvcnQgd2hlbiBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gdGhlXG4gKiBtZWFzdXJlZCBheGlzLiBUaGlzIGlzIG1lYXN1cmVkIGZyb20gdGhlIG5lYXJlc3QgZWRnZSwgc28gYSBtYXggY29uc3RyYWludCBvZiAyMDBcbiAqIG9uIGFuIGF4aXMgd2l0aCBhIG1heCB2YWx1ZSBvZiAzMDAgd291bGQgcmV0dXJuIGEgY29uc3RyYWludCBvZiA1MDAgLSBheGlzIGxlbmd0aFxuICovXG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMoYXhpcywgbWluLCBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IG1pbiAhPT0gdW5kZWZpbmVkID8gYXhpcy5taW4gKyBtaW4gOiB1bmRlZmluZWQsXG4gICAgICAgIG1heDogbWF4ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXhpcy5tYXggKyBtYXggLSAoYXhpcy5tYXggLSBheGlzLm1pbilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSBjb25zdHJhaW50cyBpbiB0ZXJtcyBvZiB0aGUgdmlld3BvcnQgd2hlblxuICogZGVmaW5lZCByZWxhdGl2ZWx5IHRvIHRoZSBtZWFzdXJlZCBib3VuZGluZyBib3guXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dEJveCwgeyB0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgbGVmdCwgcmlnaHQpLFxuICAgICAgICB5OiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LnksIHRvcCwgYm90dG9tKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdmlld3BvcnQgY29uc3RyYWludHMgd2hlbiBkZWZpbmVkIGFzIGFub3RoZXIgdmlld3BvcnQtcmVsYXRpdmUgYXhpc1xuICovXG5mdW5jdGlvbiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0QXhpcywgY29uc3RyYWludHNBeGlzKSB7XG4gICAgbGV0IG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgICBsZXQgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICAgIC8vIElmIHRoZSBjb25zdHJhaW50cyBheGlzIGlzIGFjdHVhbGx5IHNtYWxsZXIgdGhhbiB0aGUgbGF5b3V0IGF4aXMgdGhlbiB3ZSBjYW5cbiAgICAvLyBmbGlwIHRoZSBjb25zdHJhaW50c1xuICAgIGlmIChjb25zdHJhaW50c0F4aXMubWF4IC0gY29uc3RyYWludHNBeGlzLm1pbiA8XG4gICAgICAgIGxheW91dEF4aXMubWF4IC0gbGF5b3V0QXhpcy5taW4pIHtcbiAgICAgICAgW21pbiwgbWF4XSA9IFttYXgsIG1pbl07XG4gICAgfVxuICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgICAgIHk6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgY29uc3RyYWludHNCb3gueSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgc291cmNlIGF4aXMsIGJldHdlZW4gMC0xLCB0aGF0IHJlc3VsdHNcbiAqIGluIGFuIGFzdGhldGljYWxseSBwbGVhc2luZyBzY2FsZS90cmFuc2Zvcm0gbmVlZGVkIHRvIHByb2plY3QgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBjYWxjT3JpZ2luKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgbGV0IG9yaWdpbiA9IDAuNTtcbiAgICBjb25zdCBzb3VyY2VMZW5ndGggPSBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gICAgY29uc3QgdGFyZ2V0TGVuZ3RoID0gY2FsY0xlbmd0aCh0YXJnZXQpO1xuICAgIGlmICh0YXJnZXRMZW5ndGggPiBzb3VyY2VMZW5ndGgpIHtcbiAgICAgICAgb3JpZ2luID0gcHJvZ3Jlc3ModGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCAtIHNvdXJjZUxlbmd0aCwgc291cmNlLm1pbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNvdXJjZUxlbmd0aCA+IHRhcmdldExlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwcm9ncmVzcyhzb3VyY2UubWluLCBzb3VyY2UubWF4IC0gdGFyZ2V0TGVuZ3RoLCB0YXJnZXQubWluKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYW1wKDAsIDEsIG9yaWdpbik7XG59XG4vKipcbiAqIFJlYmFzZSB0aGUgY2FsY3VsYXRlZCB2aWV3cG9ydCBjb25zdHJhaW50cyByZWxhdGl2ZSB0byB0aGUgbGF5b3V0Lm1pbiBwb2ludC5cbiAqL1xuZnVuY3Rpb24gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dCwgY29uc3RyYWludHMpIHtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnN0cmFpbnRzID0ge307XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWluID0gY29uc3RyYWludHMubWluIC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWF4ID0gY29uc3RyYWludHMubWF4IC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG5jb25zdCBkZWZhdWx0RWxhc3RpYyA9IDAuMzU7XG4vKipcbiAqIEFjY2VwdHMgYSBkcmFnRWxhc3RpYyBwcm9wIGFuZCByZXR1cm5zIHJlc29sdmVkIGVsYXN0aWMgdmFsdWVzIGZvciBlYWNoIGF4aXMuXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVEcmFnRWxhc3RpYyhkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljKSB7XG4gICAgaWYgKGRyYWdFbGFzdGljID09PSBmYWxzZSkge1xuICAgICAgICBkcmFnRWxhc3RpYyA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWdFbGFzdGljID09PSB0cnVlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJsZWZ0XCIsIFwicmlnaHRcIiksXG4gICAgICAgIHk6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJ0b3BcIiwgXCJib3R0b21cIiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwsIG1heExhYmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCksXG4gICAgICAgIG1heDogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWF4TGFiZWwpLFxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBsYWJlbCkge1xuICAgIHJldHVybiB0eXBlb2YgZHJhZ0VsYXN0aWMgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyBkcmFnRWxhc3RpY1xuICAgICAgICA6IGRyYWdFbGFzdGljW2xhYmVsXSB8fCAwO1xufVxuXG5leHBvcnQgeyBhcHBseUNvbnN0cmFpbnRzLCBjYWxjT3JpZ2luLCBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMsIGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzLCBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMsIGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzLCBkZWZhdWx0RWxhc3RpYywgcmViYXNlQXhpc0NvbnN0cmFpbnRzLCByZXNvbHZlQXhpc0VsYXN0aWMsIHJlc29sdmVEcmFnRWxhc3RpYywgcmVzb2x2ZVBvaW50RWxhc3RpYyB9O1xuIiwiY29uc3QgY3JlYXRlQXhpc0RlbHRhID0gKCkgPT4gKHtcbiAgICB0cmFuc2xhdGU6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgb3JpZ2luOiAwLFxuICAgIG9yaWdpblBvaW50OiAwLFxufSk7XG5jb25zdCBjcmVhdGVEZWx0YSA9ICgpID0+ICh7XG4gICAgeDogY3JlYXRlQXhpc0RlbHRhKCksXG4gICAgeTogY3JlYXRlQXhpc0RlbHRhKCksXG59KTtcbmNvbnN0IGNyZWF0ZUF4aXMgPSAoKSA9PiAoeyBtaW46IDAsIG1heDogMCB9KTtcbmNvbnN0IGNyZWF0ZUJveCA9ICgpID0+ICh7XG4gICAgeDogY3JlYXRlQXhpcygpLFxuICAgIHk6IGNyZWF0ZUF4aXMoKSxcbn0pO1xuXG5leHBvcnQgeyBjcmVhdGVBeGlzLCBjcmVhdGVBeGlzRGVsdGEsIGNyZWF0ZUJveCwgY3JlYXRlRGVsdGEgfTtcbiIsImZ1bmN0aW9uIGVhY2hBeGlzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFtjYWxsYmFjayhcInhcIiksIGNhbGxiYWNrKFwieVwiKV07XG59XG5cbmV4cG9ydCB7IGVhY2hBeGlzIH07XG4iLCIvKipcbiAqIEJvdW5kaW5nIGJveGVzIHRlbmQgdG8gYmUgZGVmaW5lZCBhcyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20uIEZvciB2YXJpb3VzIG9wZXJhdGlvbnNcbiAqIGl0J3MgZWFzaWVyIHRvIGNvbnNpZGVyIGVhY2ggYXhpcyBpbmRpdmlkdWFsbHkuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGJvdW5kaW5nIGJveFxuICogYXMgYSBtYXAgb2Ygc2luZ2xlLWF4aXMgbWluL21heCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogeyBtaW46IGxlZnQsIG1heDogcmlnaHQgfSxcbiAgICAgICAgeTogeyBtaW46IHRvcCwgbWF4OiBib3R0b20gfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29udmVydEJveFRvQm91bmRpbmdCb3goeyB4LCB5IH0pIHtcbiAgICByZXR1cm4geyB0b3A6IHkubWluLCByaWdodDogeC5tYXgsIGJvdHRvbTogeS5tYXgsIGxlZnQ6IHgubWluIH07XG59XG4vKipcbiAqIEFwcGxpZXMgYSBUcmFuc2Zvcm1Qb2ludCBmdW5jdGlvbiB0byBhIGJvdW5kaW5nIGJveC4gVHJhbnNmb3JtUG9pbnQgaXMgdXN1YWxseSBhIGZ1bmN0aW9uXG4gKiBwcm92aWRlZCBieSBGcmFtZXIgdG8gYWxsb3cgbWVhc3VyZWQgcG9pbnRzIHRvIGJlIGNvcnJlY3RlZCBmb3IgZGV2aWNlIHNjYWxpbmcuIFRoaXMgaXMgdXNlZFxuICogd2hlbiBtZWFzdXJpbmcgRE9NIGVsZW1lbnRzIGFuZCBET00gZXZlbnQgcG9pbnRzLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3hQb2ludHMocG9pbnQsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgaWYgKCF0cmFuc2Zvcm1Qb2ludClcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIGNvbnN0IHRvcExlZnQgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHBvaW50LmxlZnQsIHk6IHBvaW50LnRvcCB9KTtcbiAgICBjb25zdCBib3R0b21SaWdodCA9IHRyYW5zZm9ybVBvaW50KHsgeDogcG9pbnQucmlnaHQsIHk6IHBvaW50LmJvdHRvbSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcExlZnQueSxcbiAgICAgICAgbGVmdDogdG9wTGVmdC54LFxuICAgICAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgICAgIHJpZ2h0OiBib3R0b21SaWdodC54LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNvbnZlcnRCb3VuZGluZ0JveFRvQm94LCBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCwgdHJhbnNmb3JtQm94UG9pbnRzIH07XG4iLCJmdW5jdGlvbiBpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgPT09IHVuZGVmaW5lZCB8fCBzY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGhhc1NjYWxlKHsgc2NhbGUsIHNjYWxlWCwgc2NhbGVZIH0pIHtcbiAgICByZXR1cm4gKCFpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVYKSB8fFxuICAgICAgICAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWSkpO1xufVxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKHZhbHVlcykge1xuICAgIHJldHVybiAoaGFzU2NhbGUodmFsdWVzKSB8fFxuICAgICAgICBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHx8XG4gICAgICAgIHZhbHVlcy56IHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGUgfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZVggfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZVkgfHxcbiAgICAgICAgdmFsdWVzLnNrZXdYIHx8XG4gICAgICAgIHZhbHVlcy5za2V3WSk7XG59XG5mdW5jdGlvbiBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueCkgfHwgaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueSk7XG59XG5mdW5jdGlvbiBpczJEVHJhbnNsYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlICE9PSBcIjAlXCI7XG59XG5cbmV4cG9ydCB7IGhhczJEVHJhbnNsYXRlLCBoYXNTY2FsZSwgaGFzVHJhbnNmb3JtIH07XG4iLCJpbXBvcnQgeyBtaXhOdW1iZXIgfSBmcm9tICcuLi8uLi91dGlscy9taXgvbnVtYmVyLm1qcyc7XG5pbXBvcnQgeyBoYXNUcmFuc2Zvcm0gfSBmcm9tICcuLi91dGlscy9oYXMtdHJhbnNmb3JtLm1qcyc7XG5cbi8qKlxuICogU2NhbGVzIGEgcG9pbnQgYmFzZWQgb24gYSBmYWN0b3IgYW5kIGFuIG9yaWdpblBvaW50XG4gKi9cbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlLCBvcmlnaW5Qb2ludCkge1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50IC0gb3JpZ2luUG9pbnQ7XG4gICAgY29uc3Qgc2NhbGVkID0gc2NhbGUgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gICAgcmV0dXJuIG9yaWdpblBvaW50ICsgc2NhbGVkO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgcG9pbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGFuIGF4aXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAxLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhIGJveFxuICovXG5mdW5jdGlvbiBhcHBseUJveERlbHRhKGJveCwgeyB4LCB5IH0pIHtcbiAgICBhcHBseUF4aXNEZWx0YShib3gueCwgeC50cmFuc2xhdGUsIHguc2NhbGUsIHgub3JpZ2luUG9pbnQpO1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC55LCB5LnRyYW5zbGF0ZSwgeS5zY2FsZSwgeS5vcmlnaW5Qb2ludCk7XG59XG5jb25zdCBUUkVFX1NDQUxFX1NOQVBfTUlOID0gMC45OTk5OTk5OTk5OTk7XG5jb25zdCBUUkVFX1NDQUxFX1NOQVBfTUFYID0gMS4wMDAwMDAwMDAwMDAxO1xuLyoqXG4gKiBBcHBseSBhIHRyZWUgb2YgZGVsdGFzIHRvIGEgYm94LiBXZSBkbyB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWZmZWN0IG9mIGFsbCB0aGUgdHJhbnNmb3Jtc1xuICogaW4gYSB0cmVlIHVwb24gb3VyIGJveCBiZWZvcmUgdGhlbiBjYWxjdWxhdGluZyBob3cgdG8gcHJvamVjdCBpdCBpbnRvIG91ciBkZXNpcmVkIHZpZXdwb3J0LXJlbGF0aXZlIGJveFxuICpcbiAqIFRoaXMgaXMgdGhlIGZpbmFsIG5lc3RlZCBsb29wIHdpdGhpbiB1cGRhdGVMYXlvdXREZWx0YSBmb3IgZnV0dXJlIHJlZmFjdG9yaW5nXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJlZURlbHRhcyhib3gsIHRyZWVTY2FsZSwgdHJlZVBhdGgsIGlzU2hhcmVkVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgdHJlZUxlbmd0aCA9IHRyZWVQYXRoLmxlbmd0aDtcbiAgICBpZiAoIXRyZWVMZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBSZXNldCB0aGUgdHJlZVNjYWxlXG4gICAgdHJlZVNjYWxlLnggPSB0cmVlU2NhbGUueSA9IDE7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGRlbHRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSB0cmVlUGF0aFtpXTtcbiAgICAgICAgZGVsdGEgPSBub2RlLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFByZWZlciB0byByZW1vdmUgdGhpcywgYnV0IGN1cnJlbnRseSB3ZSBoYXZlIG1vdGlvbiBjb21wb25lbnRzIHdpdGhcbiAgICAgICAgICogZGlzcGxheTogY29udGVudHMgaW4gRnJhbWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnByb3BzLnN0eWxlICYmXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnByb3BzLnN0eWxlLmRpc3BsYXkgPT09IFwiY29udGVudHNcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwge1xuICAgICAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwub2Zmc2V0LnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIEluY29wb3JhdGUgZWFjaCBhbmNlc3RvcidzIHNjYWxlIGludG8gYSBjdWxtdWxhdGl2ZSB0cmVlU2NhbGUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICB0cmVlU2NhbGUueCAqPSBkZWx0YS54LnNjYWxlO1xuICAgICAgICAgICAgdHJlZVNjYWxlLnkgKj0gZGVsdGEueS5zY2FsZTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVhY2ggYW5jZXN0b3IncyBjYWxjdWxhdGVkIGRlbHRhIGludG8gdGhpcyBjb21wb25lbnQncyByZWNvcmRlZCBsYXlvdXQgYm94XG4gICAgICAgICAgICBhcHBseUJveERlbHRhKGJveCwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiYgaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNuYXAgdHJlZSBzY2FsZSBiYWNrIHRvIDEgaWYgaXQncyB3aXRoaW4gYSBub24tcGVyY2VpdmFibGUgdGhyZXNob2xkLlxuICAgICAqIFRoaXMgd2lsbCBoZWxwIHJlZHVjZSB1c2VsZXNzIHNjYWxlcyBnZXR0aW5nIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGlmICh0cmVlU2NhbGUueCA8IFRSRUVfU0NBTEVfU05BUF9NQVggJiZcbiAgICAgICAgdHJlZVNjYWxlLnggPiBUUkVFX1NDQUxFX1NOQVBfTUlOKSB7XG4gICAgICAgIHRyZWVTY2FsZS54ID0gMS4wO1xuICAgIH1cbiAgICBpZiAodHJlZVNjYWxlLnkgPCBUUkVFX1NDQUxFX1NOQVBfTUFYICYmXG4gICAgICAgIHRyZWVTY2FsZS55ID4gVFJFRV9TQ0FMRV9TTkFQX01JTikge1xuICAgICAgICB0cmVlU2NhbGUueSA9IDEuMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVBeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG4gICAgYXhpcy5taW4gPSBheGlzLm1pbiArIGRpc3RhbmNlO1xuICAgIGF4aXMubWF4ID0gYXhpcy5tYXggKyBkaXN0YW5jZTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYW4gYXhpcyBmcm9tIHRoZSBsYXRlc3QgcmVzb2x2ZWQgbW90aW9uIHZhbHVlcy5cbiAqIFRoaXMgZnVuY3Rpb24gYmFzaWNhbGx5IGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBhIGZsYXQgbW90aW9uIHZhbHVlIG1hcFxuICogYW5kIGFwcGx5QXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUF4aXMoYXhpcywgYXhpc1RyYW5zbGF0ZSwgYXhpc1NjYWxlLCBib3hTY2FsZSwgYXhpc09yaWdpbiA9IDAuNSkge1xuICAgIGNvbnN0IG9yaWdpblBvaW50ID0gbWl4TnVtYmVyKGF4aXMubWluLCBheGlzLm1heCwgYXhpc09yaWdpbik7XG4gICAgLy8gQXBwbHkgdGhlIGF4aXMgZGVsdGEgdG8gdGhlIGZpbmFsIGF4aXNcbiAgICBhcHBseUF4aXNEZWx0YShheGlzLCBheGlzVHJhbnNsYXRlLCBheGlzU2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG4vKipcbiAqIEFwcGx5IGEgdHJhbnNmb3JtIHRvIGEgYm94IGZyb20gdGhlIGxhdGVzdCByZXNvbHZlZCBtb3Rpb24gdmFsdWVzLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1Cb3goYm94LCB0cmFuc2Zvcm0pIHtcbiAgICB0cmFuc2Zvcm1BeGlzKGJveC54LCB0cmFuc2Zvcm0ueCwgdHJhbnNmb3JtLnNjYWxlWCwgdHJhbnNmb3JtLnNjYWxlLCB0cmFuc2Zvcm0ub3JpZ2luWCk7XG4gICAgdHJhbnNmb3JtQXhpcyhib3gueSwgdHJhbnNmb3JtLnksIHRyYW5zZm9ybS5zY2FsZVksIHRyYW5zZm9ybS5zY2FsZSwgdHJhbnNmb3JtLm9yaWdpblkpO1xufVxuXG5leHBvcnQgeyBhcHBseUF4aXNEZWx0YSwgYXBwbHlCb3hEZWx0YSwgYXBwbHlQb2ludERlbHRhLCBhcHBseVRyZWVEZWx0YXMsIHNjYWxlUG9pbnQsIHRyYW5zZm9ybUF4aXMsIHRyYW5zZm9ybUJveCwgdHJhbnNsYXRlQXhpcyB9O1xuIiwiaW1wb3J0IHsgY29udmVydEJvdW5kaW5nQm94VG9Cb3gsIHRyYW5zZm9ybUJveFBvaW50cyB9IGZyb20gJy4uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IHRyYW5zbGF0ZUF4aXMgfSBmcm9tICcuLi9nZW9tZXRyeS9kZWx0YS1hcHBseS5tanMnO1xuXG5mdW5jdGlvbiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHRyYW5zZm9ybUJveFBvaW50cyhpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJhbnNmb3JtUG9pbnQpKTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVQYWdlQm94KGVsZW1lbnQsIHJvb3RQcm9qZWN0aW9uTm9kZSwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gICAgY29uc3Qgdmlld3BvcnRCb3ggPSBtZWFzdXJlVmlld3BvcnRCb3goZWxlbWVudCwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICBjb25zdCB7IHNjcm9sbCB9ID0gcm9vdFByb2plY3Rpb25Ob2RlO1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC54LCBzY3JvbGwub2Zmc2V0LngpO1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LnksIHNjcm9sbC5vZmZzZXQueSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydEJveDtcbn1cblxuZXhwb3J0IHsgbWVhc3VyZVBhZ2VCb3gsIG1lYXN1cmVWaWV3cG9ydEJveCB9O1xuIiwiLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21vdGlvbmRpdmlzaW9uL21vdGlvbi9pc3N1ZXMvMjI3MFxuY29uc3QgZ2V0Q29udGV4dFdpbmRvdyA9ICh7IGN1cnJlbnQgfSkgPT4ge1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogbnVsbDtcbn07XG5cbmV4cG9ydCB7IGdldENvbnRleHRXaW5kb3cgfTtcbiIsImltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBzZXREcmFnTG9jayB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgUGFuU2Vzc2lvbiB9IGZyb20gJy4uL3Bhbi9QYW5TZXNzaW9uLm1qcyc7XG5pbXBvcnQgeyBpc1JlZk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzJztcbmltcG9ydCB7IGFkZFBvaW50ZXJFdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50cy9hZGQtcG9pbnRlci1ldmVudC5tanMnO1xuaW1wb3J0IHsgYXBwbHlDb25zdHJhaW50cywgY2FsY1JlbGF0aXZlQ29uc3RyYWludHMsIHJlc29sdmVEcmFnRWxhc3RpYywgcmViYXNlQXhpc0NvbnN0cmFpbnRzLCBjYWxjVmlld3BvcnRDb25zdHJhaW50cywgY2FsY09yaWdpbiwgZGVmYXVsdEVsYXN0aWMgfSBmcm9tICcuL3V0aWxzL2NvbnN0cmFpbnRzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVCb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L21vZGVscy5tanMnO1xuaW1wb3J0IHsgZWFjaEF4aXMgfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL3V0aWxzL2VhY2gtYXhpcy5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZVBhZ2VCb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL3V0aWxzL21lYXN1cmUubWpzJztcbmltcG9ydCB7IGV4dHJhY3RFdmVudEluZm8gfSBmcm9tICcuLi8uLi9ldmVudHMvZXZlbnQtaW5mby5tanMnO1xuaW1wb3J0IHsgY29udmVydEJveFRvQm91bmRpbmdCb3gsIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94IH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9nZW9tZXRyeS9jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBhZGREb21FdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50cy9hZGQtZG9tLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBjYWxjTGVuZ3RoIH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1jYWxjLm1qcyc7XG5pbXBvcnQgeyBtaXhOdW1iZXIgfSBmcm9tICcuLi8uLi91dGlscy9taXgvbnVtYmVyLm1qcyc7XG5pbXBvcnQgeyBwZXJjZW50IH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuaW1wb3J0IHsgYW5pbWF0ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL2ludGVyZmFjZXMvbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBnZXRDb250ZXh0V2luZG93IH0gZnJvbSAnLi4vLi4vdXRpbHMvZ2V0LWNvbnRleHQtd2luZG93Lm1qcyc7XG5pbXBvcnQgeyBhZGRWYWx1ZVRvV2lsbENoYW5nZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3VzZS13aWxsLWNoYW5nZS9hZGQtd2lsbC1jaGFuZ2UubWpzJztcbmltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5cbmNvbnN0IGVsZW1lbnREcmFnQ29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKlxuICovXG4vLyBsZXQgbGF0ZXN0UG9pbnRlckV2ZW50OiBQb2ludGVyRXZlbnRcbmNsYXNzIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMge1xuICAgIGNvbnN0cnVjdG9yKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcm1pdHRlZCBib3VuZGFyaWVzIG9mIHRyYXZlbCwgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlci1heGlzIHJlc29sdmVkIGVsYXN0aWMgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFzdGljID0gY3JlYXRlQm94KCk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgfVxuICAgIHN0YXJ0KG9yaWdpbkV2ZW50LCB7IHNuYXBUb0N1cnNvciA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9uJ3Qgc3RhcnQgZHJhZ2dpbmcgaWYgdGhpcyBjb21wb25lbnQgaXMgZXhpdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyBwcmVzZW5jZUNvbnRleHQgfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByZXNlbmNlQ29udGV4dCAmJiBwcmVzZW5jZUNvbnRleHQuaXNQcmVzZW50ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb25TZXNzaW9uU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ1NuYXBUb09yaWdpbiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgLy8gU3RvcCBvciBwYXVzZSBhbnkgYW5pbWF0aW9ucyBvbiBib3RoIGF4aXMgdmFsdWVzIGltbWVkaWF0ZWx5LiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byB0aHJvdyBhbmQgY2F0Y2hcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICBkcmFnU25hcFRvT3JpZ2luID8gdGhpcy5wYXVzZUFuaW1hdGlvbigpIDogdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc25hcFRvQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwVG9DdXJzb3IoZXh0cmFjdEV2ZW50SW5mbyhldmVudCkucG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblN0YXJ0ID0gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgdGhlIGdsb2JhbCBkcmFnIGdlc3R1cmUgbG9jayAtIG1heWJlIG1ha2UgdGhpcyBwYXJ0IG9mIFBhblNlc3Npb25cbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZywgZHJhZ1Byb3BhZ2F0aW9uLCBvbkRyYWdTdGFydCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgaWYgKGRyYWcgJiYgIWRyYWdQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5EcmFnTG9jaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jayA9IHNldERyYWdMb2NrKGRyYWcpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbiAndCBoYXZlIHRoZSBsb2NrLCBkb24ndCBzdGFydCBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcGVuRHJhZ0xvY2spXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24udGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWNvcmQgZ2VzdHVyZSBvcmlnaW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLmdldCgpIHx8IDA7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIE1vdGlvblZhbHVlIGlzIGEgcGVyY2VudGFnZSB2YWx1ZSBjb252ZXJ0IHRvIHB4XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQudGVzdChjdXJyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lYXN1cmVkQXhpcyA9IHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKG1lYXN1cmVkQXhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGxlbmd0aCAqIChwYXJzZUZsb2F0KGN1cnJlbnQpIC8gMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblBvaW50W2F4aXNdID0gY3VycmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRmlyZSBvbkRyYWdTdGFydCBldmVudFxuICAgICAgICAgICAgaWYgKG9uRHJhZ1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBvbkRyYWdTdGFydChldmVudCwgaW5mbykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkVmFsdWVUb1dpbGxDaGFuZ2UodGhpcy52aXN1YWxFbGVtZW50LCBcInRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uU3RhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGFuaW1hdGlvblN0YXRlICYmIGFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRHJhZ1wiLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Nb3ZlID0gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAvLyBsYXRlc3RQb2ludGVyRXZlbnQgPSBldmVudFxuICAgICAgICAgICAgY29uc3QgeyBkcmFnUHJvcGFnYXRpb24sIGRyYWdEaXJlY3Rpb25Mb2NrLCBvbkRpcmVjdGlvbkxvY2ssIG9uRHJhZywgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBzdWNjZXNzZnVsbHkgcmVjZWl2ZSB0aGUgZ2VzdHVyZSBsb2NrLCBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiAhdGhpcy5vcGVuRHJhZ0xvY2spXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyBvZmZzZXQgfSA9IGluZm87XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBkcmFnIGRpcmVjdGlvbiBpZiBkaXJlY3Rpb25Mb2NrIGlzIHRydWVcbiAgICAgICAgICAgIGlmIChkcmFnRGlyZWN0aW9uTG9jayAmJiB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREaXJlY3Rpb24gPSBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgc3VjY2Vzc2Z1bGx5IHNldCBhIGRpcmVjdGlvbiwgbm90aWZ5IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdGlvbkxvY2sgJiYgb25EaXJlY3Rpb25Mb2NrKHRoaXMuY3VycmVudERpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBlYWNoIHBvaW50IHdpdGggdGhlIGxhdGVzdCBwb3NpdGlvblxuICAgICAgICAgICAgdGhpcy51cGRhdGVBeGlzKFwieFwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVBeGlzKFwieVwiLCBpbmZvLnBvaW50LCBvZmZzZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZGVhbGx5IHdlIHdvdWxkIGxlYXZlIHRoZSByZW5kZXJlciB0byBmaXJlIG5hdHVyYWxseSBhdCB0aGUgZW5kIG9mXG4gICAgICAgICAgICAgKiB0aGlzIGZyYW1lIGJ1dCBpZiB0aGUgZWxlbWVudCBpcyBhYm91dCB0byBjaGFuZ2UgbGF5b3V0IGFzIHRoZSByZXN1bHRcbiAgICAgICAgICAgICAqIG9mIGEgcmUtcmVuZGVyIHdlIHdhbnQgdG8gZW5zdXJlIHRoZSBicm93c2VyIGNhbiByZWFkIHRoZSBsYXRlc3RcbiAgICAgICAgICAgICAqIGJvdW5kaW5nIGJveCB0byBlbnN1cmUgdGhlIHBvaW50ZXIgYW5kIGVsZW1lbnQgZG9uJ3QgZmFsbCBvdXQgb2Ygc3luYy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy52aXN1YWxFbGVtZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIG11c3QgZmlyZSBhZnRlciB0aGUgcmVuZGVyIGNhbGwgYXMgaXQgbWlnaHQgdHJpZ2dlciBhIHN0YXRlXG4gICAgICAgICAgICAgKiBjaGFuZ2Ugd2hpY2ggaXRzZWxmIG1pZ2h0IHRyaWdnZXIgYSBsYXlvdXQgdXBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkRyYWcgJiYgb25EcmFnKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25TZXNzaW9uRW5kID0gKGV2ZW50LCBpbmZvKSA9PiB0aGlzLnN0b3AoZXZlbnQsIGluZm8pO1xuICAgICAgICBjb25zdCByZXN1bWVBbmltYXRpb24gPSAoKSA9PiBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5pbWF0aW9uU3RhdGUoYXhpcykgPT09IFwicGF1c2VkXCIgJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxheSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZHJhZ1NuYXBUb09yaWdpbiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihvcmlnaW5FdmVudCwge1xuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQsXG4gICAgICAgICAgICBvblN0YXJ0LFxuICAgICAgICAgICAgb25Nb3ZlLFxuICAgICAgICAgICAgb25TZXNzaW9uRW5kLFxuICAgICAgICAgICAgcmVzdW1lQW5pbWF0aW9uLFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSxcbiAgICAgICAgICAgIGRyYWdTbmFwVG9PcmlnaW4sXG4gICAgICAgICAgICBjb250ZXh0V2luZG93OiBnZXRDb250ZXh0V2luZG93KHRoaXMudmlzdWFsRWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9wKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dpbmcgPSB0aGlzLmlzRHJhZ2dpbmc7XG4gICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIGlmICghaXNEcmFnZ2luZylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyB2ZWxvY2l0eSB9ID0gaW5mbztcbiAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbih2ZWxvY2l0eSk7XG4gICAgICAgIGNvbnN0IHsgb25EcmFnRW5kIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGlmIChvbkRyYWdFbmQpIHtcbiAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gb25EcmFnRW5kKGV2ZW50LCBpbmZvKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uLCBhbmltYXRpb25TdGF0ZSB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhblNlc3Npb24gJiYgdGhpcy5wYW5TZXNzaW9uLmVuZCgpO1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHsgZHJhZ1Byb3BhZ2F0aW9uIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmIHRoaXMub3BlbkRyYWdMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jaygpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdGlvblN0YXRlICYmIGFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRHJhZ1wiLCBmYWxzZSk7XG4gICAgfVxuICAgIHVwZGF0ZUF4aXMoYXhpcywgX3BvaW50LCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgaWYgKCFvZmZzZXQgfHwgIXNob3VsZERyYWcoYXhpcywgZHJhZywgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIGxldCBuZXh0ID0gdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArIG9mZnNldFtheGlzXTtcbiAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgaWYgKHRoaXMuY29uc3RyYWludHMgJiYgdGhpcy5jb25zdHJhaW50c1theGlzXSkge1xuICAgICAgICAgICAgbmV4dCA9IGFwcGx5Q29uc3RyYWludHMobmV4dCwgdGhpcy5jb25zdHJhaW50c1theGlzXSwgdGhpcy5lbGFzdGljW2F4aXNdKTtcbiAgICAgICAgfVxuICAgICAgICBheGlzVmFsdWUuc2V0KG5leHQpO1xuICAgIH1cbiAgICByZXNvbHZlQ29uc3RyYWludHMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHMsIGRyYWdFbGFzdGljIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IGxheW91dCA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uICYmXG4gICAgICAgICAgICAhdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24ubGF5b3V0XG4gICAgICAgICAgICA/IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLm1lYXN1cmUoZmFsc2UpXG4gICAgICAgICAgICA6IChfYSA9IHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0O1xuICAgICAgICBjb25zdCBwcmV2Q29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25zdHJhaW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBsYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0LmxheW91dEJveCwgZHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsYXN0aWMgPSByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgb3V0cHV0dGluZyB0byBleHRlcm5hbCBNb3Rpb25WYWx1ZXMsIHdlIHdhbnQgdG8gcmViYXNlIHRoZSBtZWFzdXJlZCBjb25zdHJhaW50c1xuICAgICAgICAgKiBmcm9tIHZpZXdwb3J0LXJlbGF0aXZlIHRvIGNvbXBvbmVudC1yZWxhdGl2ZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChwcmV2Q29uc3RyYWludHMgIT09IHRoaXMuY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgIGxheW91dCAmJlxuICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgIXRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzICE9PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdID0gcmViYXNlQXhpc0NvbnN0cmFpbnRzKGxheW91dC5sYXlvdXRCb3hbYXhpc10sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc29sdmVSZWZDb25zdHJhaW50cygpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnQ29uc3RyYWludHM6IGNvbnN0cmFpbnRzLCBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKCFjb25zdHJhaW50cyB8fCAhaXNSZWZPYmplY3QoY29uc3RyYWludHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBjb25zdHJhaW50c0VsZW1lbnQgPSBjb25zdHJhaW50cy5jdXJyZW50O1xuICAgICAgICBpbnZhcmlhbnQoY29uc3RyYWludHNFbGVtZW50ICE9PSBudWxsLCBcIklmIGBkcmFnQ29uc3RyYWludHNgIGlzIHNldCBhcyBhIFJlYWN0IHJlZiwgdGhhdCByZWYgbXVzdCBiZSBwYXNzZWQgdG8gYW5vdGhlciBjb21wb25lbnQncyBgcmVmYCBwcm9wLlwiKTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgaWYgKCFwcm9qZWN0aW9uIHx8ICFwcm9qZWN0aW9uLmxheW91dClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNCb3ggPSBtZWFzdXJlUGFnZUJveChjb25zdHJhaW50c0VsZW1lbnQsIHByb2plY3Rpb24ucm9vdCwgdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtcbiAgICAgICAgbGV0IG1lYXN1cmVkQ29uc3RyYWludHMgPSBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhwcm9qZWN0aW9uLmxheW91dC5sYXlvdXRCb3gsIGNvbnN0cmFpbnRzQm94KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZXJlJ3MgYW4gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIGxpc3RlbmVyIHdlIGNhbGwgaXQgYW5kXG4gICAgICAgICAqIGlmIGRpZmZlcmVudCBjb25zdHJhaW50cyBhcmUgcmV0dXJuZWQsIHNldCBjb25zdHJhaW50cyB0byB0aGF0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAob25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB1c2VyQ29uc3RyYWludHMgPSBvbk1lYXN1cmVEcmFnQ29uc3RyYWludHMoY29udmVydEJveFRvQm91bmRpbmdCb3gobWVhc3VyZWRDb25zdHJhaW50cykpO1xuICAgICAgICAgICAgdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMgPSAhIXVzZXJDb25zdHJhaW50cztcbiAgICAgICAgICAgIGlmICh1c2VyQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlZENvbnN0cmFpbnRzID0gY29udmVydEJvdW5kaW5nQm94VG9Cb3godXNlckNvbnN0cmFpbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVhc3VyZWRDb25zdHJhaW50cztcbiAgICB9XG4gICAgc3RhcnRBbmltYXRpb24odmVsb2NpdHkpIHtcbiAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljLCBkcmFnVHJhbnNpdGlvbiwgZHJhZ1NuYXBUb09yaWdpbiwgb25EcmFnVHJhbnNpdGlvbkVuZCwgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzIHx8IHt9O1xuICAgICAgICBjb25zdCBtb21lbnR1bUFuaW1hdGlvbnMgPSBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFzaG91bGREcmFnKGF4aXMsIGRyYWcsIHRoaXMuY3VycmVudERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdHJhbnNpdGlvbiA9IChjb25zdHJhaW50cyAmJiBjb25zdHJhaW50c1theGlzXSkgfHwge307XG4gICAgICAgICAgICBpZiAoZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uID0geyBtaW46IDAsIG1heDogMCB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyZGFtcCB0aGUgYm91bmRhcnkgc3ByaW5nIGlmIGBkcmFnRWxhc3RpY2AgaXMgZGlzYWJsZWQuIFRoZXJlJ3Mgc3RpbGwgYSBmcmFtZVxuICAgICAgICAgICAgICogb2Ygc3ByaW5nIGFuaW1hdGlvbnMgc28gd2Ugc2hvdWxkIGxvb2sgaW50byBhZGRpbmcgYSBkaXNhYmxlIHNwcmluZyBvcHRpb24gdG8gYGluZXJ0aWFgLlxuICAgICAgICAgICAgICogV2UgY291bGQgZG8gc29tZXRoaW5nIGhlcmUgd2hlcmUgd2UgYWZmZWN0IHRoZSBgYm91bmNlU3RpZmZuZXNzYCBhbmQgYGJvdW5jZURhbXBpbmdgXG4gICAgICAgICAgICAgKiB1c2luZyB0aGUgdmFsdWUgb2YgYGRyYWdFbGFzdGljYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYm91bmNlU3RpZmZuZXNzID0gZHJhZ0VsYXN0aWMgPyAyMDAgOiAxMDAwMDAwO1xuICAgICAgICAgICAgY29uc3QgYm91bmNlRGFtcGluZyA9IGRyYWdFbGFzdGljID8gNDAgOiAxMDAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGluZXJ0aWEgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbmVydGlhXCIsXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IGRyYWdNb21lbnR1bSA/IHZlbG9jaXR5W2F4aXNdIDogMCxcbiAgICAgICAgICAgICAgICBib3VuY2VTdGlmZm5lc3MsXG4gICAgICAgICAgICAgICAgYm91bmNlRGFtcGluZyxcbiAgICAgICAgICAgICAgICB0aW1lQ29uc3RhbnQ6IDc1MCxcbiAgICAgICAgICAgICAgICByZXN0RGVsdGE6IDEsXG4gICAgICAgICAgICAgICAgcmVzdFNwZWVkOiAxMCxcbiAgICAgICAgICAgICAgICAuLi5kcmFnVHJhbnNpdGlvbixcbiAgICAgICAgICAgICAgICAuLi50cmFuc2l0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBhbmltYXRpbmcgb24gYW4gZXh0ZXJuYWxseS1wcm92aWRlZCBgTW90aW9uVmFsdWVgIHdlIGNhbiB1c2UgdGhlXG4gICAgICAgICAgICAvLyBjb21wb25lbnQncyBhbmltYXRpb24gY29udHJvbHMgd2hpY2ggd2lsbCBoYW5kbGUgaW50ZXJhY3Rpb25zIHdpdGggd2hpbGVIb3ZlciAoZXRjKSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBqdXN0IGhhdmUgdG8gYW5pbWF0ZSB0aGUgYE1vdGlvblZhbHVlYCBpdHNlbGYuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCBpbmVydGlhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJ1biBhbGwgYW5pbWF0aW9ucyBhbmQgdGhlbiByZXNvbHZlIHRoZSBuZXcgZHJhZyBjb25zdHJhaW50cy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG1vbWVudHVtQW5pbWF0aW9ucykudGhlbihvbkRyYWdUcmFuc2l0aW9uRW5kKTtcbiAgICB9XG4gICAgc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgdHJhbnNpdGlvbikge1xuICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgYWRkVmFsdWVUb1dpbGxDaGFuZ2UodGhpcy52aXN1YWxFbGVtZW50LCBheGlzKTtcbiAgICAgICAgcmV0dXJuIGF4aXNWYWx1ZS5zdGFydChhbmltYXRlTW90aW9uVmFsdWUoYXhpcywgYXhpc1ZhbHVlLCAwLCB0cmFuc2l0aW9uLCB0aGlzLnZpc3VhbEVsZW1lbnQsIGZhbHNlKSk7XG4gICAgfVxuICAgIHN0b3BBbmltYXRpb24oKSB7XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5zdG9wKCkpO1xuICAgIH1cbiAgICBwYXVzZUFuaW1hdGlvbigpIHtcbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2UoKTsgfSk7XG4gICAgfVxuICAgIGdldEFuaW1hdGlvblN0YXRlKGF4aXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuYW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERyYWcgd29ya3MgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoaWNoIHByb3BzIGFyZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIC0gSWYgX2RyYWdYIGFuZCBfZHJhZ1kgYXJlIHByb3ZpZGVkLCB3ZSBvdXRwdXQgdGhlIGdlc3R1cmUgZGVsdGEgZGlyZWN0bHkgdG8gdGhvc2UgbW90aW9uIHZhbHVlcy5cbiAgICAgKiAtIE90aGVyd2lzZSwgd2UgYXBwbHkgdGhlIGRlbHRhIHRvIHRoZSB4L3kgbW90aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICBnZXRBeGlzTW90aW9uVmFsdWUoYXhpcykge1xuICAgICAgICBjb25zdCBkcmFnS2V5ID0gYF9kcmFnJHtheGlzLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWxNb3Rpb25WYWx1ZSA9IHByb3BzW2RyYWdLZXldO1xuICAgICAgICByZXR1cm4gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgPyBleHRlcm5hbE1vdGlvblZhbHVlXG4gICAgICAgICAgICA6IHRoaXMudmlzdWFsRWxlbWVudC5nZXRWYWx1ZShheGlzLCAocHJvcHMuaW5pdGlhbFxuICAgICAgICAgICAgICAgID8gcHJvcHMuaW5pdGlhbFtheGlzXVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKSB8fCAwKTtcbiAgICB9XG4gICAgc25hcFRvQ3Vyc29yKHBvaW50KSB7XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRyYWcgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICBpZiAocHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHByb2plY3Rpb24ubGF5b3V0LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICBheGlzVmFsdWUuc2V0KHBvaW50W2F4aXNdIC0gbWl4TnVtYmVyKG1pbiwgbWF4LCAwLjUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHZpZXdwb3J0IHJlc2l6ZXMgd2Ugd2FudCB0byBjaGVjayBpZiB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgKiBoYXZlIGNoYW5nZWQgYW5kLCBpZiBzbywgcmVwb3NpdGlvbiB0aGUgZWxlbWVudCB3aXRoaW4gdGhvc2UgbmV3IGNvbnN0cmFpbnRzXG4gICAgICogcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgcmVzaXplLlxuICAgICAqL1xuICAgIHNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGlmICghaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSB8fCAhcHJvamVjdGlvbiB8fCAhdGhpcy5jb25zdHJhaW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgY3VycmVudCBhbmltYXRpb25zIGFzIHRoZXJlIGNhbiBiZSB2aXN1YWwgZ2xpdGNoaW5nIGlmIHdlIHRyeSB0byBkb1xuICAgICAgICAgKiB0aGlzIG1pZC1hbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJhaW50cyBib3ggYW5kIHNhdmUgYXMgYSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGJveFByb2dyZXNzID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGlmIChheGlzVmFsdWUgJiYgdGhpcy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3QgPSBheGlzVmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYm94UHJvZ3Jlc3NbYXhpc10gPSBjYWxjT3JpZ2luKHsgbWluOiBsYXRlc3QsIG1heDogbGF0ZXN0IH0sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgbGF5b3V0IG9mIHRoaXMgZWxlbWVudCBhbmQgcmVzb2x2ZSB0aGUgbGF0ZXN0IGRyYWcgY29uc3RyYWludHNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtVGVtcGxhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgIHByb2plY3Rpb24ucm9vdCAmJiBwcm9qZWN0aW9uLnJvb3QudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBheGlzLCBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGxheW91dCBheGlzXG4gICAgICAgICAqIHdpdGhpbiB0aGUgbmV3IGNvbnN0cmFpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZSBhIG5ldyB0cmFuc2Zvcm0gYmFzZWQgb24gdGhlIHByZXZpb3VzIGJveCBwcm9ncmVzc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuY29uc3RyYWludHNbYXhpc107XG4gICAgICAgICAgICBheGlzVmFsdWUuc2V0KG1peE51bWJlcihtaW4sIG1heCwgYm94UHJvZ3Jlc3NbYXhpc10pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkZExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZWxlbWVudERyYWdDb250cm9scy5zZXQodGhpcy52aXN1YWxFbGVtZW50LCB0aGlzKTtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIGEgcG9pbnRlcmRvd24gZXZlbnQgbGlzdGVuZXIgb24gdGhpcyBET00gZWxlbWVudCB0byBpbml0aWF0ZSBkcmFnIHRyYWNraW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3RvcFBvaW50ZXJMaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudChlbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnTGlzdGVuZXIgPSB0cnVlIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBkcmFnICYmIGRyYWdMaXN0ZW5lciAmJiB0aGlzLnN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRyYWdDb25zdHJhaW50cyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgaWYgKGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykgJiYgZHJhZ0NvbnN0cmFpbnRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHN0b3BNZWFzdXJlTGF5b3V0TGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtZWFzdXJlXCIsIG1lYXN1cmVEcmFnQ29uc3RyYWludHMpO1xuICAgICAgICBpZiAocHJvamVjdGlvbiAmJiAhcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdCAmJiBwcm9qZWN0aW9uLnJvb3QudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnVwZGF0ZUxheW91dCgpO1xuICAgICAgICB9XG4gICAgICAgIGZyYW1lLnJlYWQobWVhc3VyZURyYWdDb25zdHJhaW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSB3aW5kb3cgcmVzaXplIGxpc3RlbmVyIHRvIHNjYWxlIHRoZSBkcmFnZ2FibGUgdGFyZ2V0IHdpdGhpbiBpdHMgZGVmaW5lZFxuICAgICAgICAgKiBjb25zdHJhaW50cyBhcyB0aGUgd2luZG93IHJlc2l6ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdG9wUmVzaXplTGlzdGVuZXIgPSBhZGREb21FdmVudCh3aW5kb3csIFwicmVzaXplXCIsICgpID0+IHRoaXMuc2NhbGVQb3NpdGlvbldpdGhpbkNvbnN0cmFpbnRzKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIGVsZW1lbnQncyBsYXlvdXQgY2hhbmdlcywgY2FsY3VsYXRlIHRoZSBkZWx0YSBhbmQgYXBwbHkgdGhhdCB0b1xuICAgICAgICAgKiB0aGUgZHJhZyBnZXN0dXJlJ3Mgb3JpZ2luIHBvaW50LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICgoeyBkZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nICYmIGhhc0xheW91dENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9yaWdpblBvaW50W2F4aXNdICs9IGRlbHRhW2F4aXNdLnRyYW5zbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KG1vdGlvblZhbHVlLmdldCgpICsgZGVsdGFbYXhpc10udHJhbnNsYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN0b3BSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcFBvaW50ZXJMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyICYmIHN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lcigpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRQcm9wcygpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyBkcmFnID0gZmFsc2UsIGRyYWdEaXJlY3Rpb25Mb2NrID0gZmFsc2UsIGRyYWdQcm9wYWdhdGlvbiA9IGZhbHNlLCBkcmFnQ29uc3RyYWludHMgPSBmYWxzZSwgZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYywgZHJhZ01vbWVudHVtID0gdHJ1ZSwgfSA9IHByb3BzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBkcmFnLFxuICAgICAgICAgICAgZHJhZ0RpcmVjdGlvbkxvY2ssXG4gICAgICAgICAgICBkcmFnUHJvcGFnYXRpb24sXG4gICAgICAgICAgICBkcmFnQ29uc3RyYWludHMsXG4gICAgICAgICAgICBkcmFnRWxhc3RpYyxcbiAgICAgICAgICAgIGRyYWdNb21lbnR1bSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaG91bGREcmFnKGRpcmVjdGlvbiwgZHJhZywgY3VycmVudERpcmVjdGlvbikge1xuICAgIHJldHVybiAoKGRyYWcgPT09IHRydWUgfHwgZHJhZyA9PT0gZGlyZWN0aW9uKSAmJlxuICAgICAgICAoY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RGlyZWN0aW9uID09PSBkaXJlY3Rpb24pKTtcbn1cbi8qKlxuICogQmFzZWQgb24gYW4geC95IG9mZnNldCBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgZHJhZyBkaXJlY3Rpb24uIElmIGJvdGggYXhpcycgb2Zmc2V0cyBhcmUgbG93ZXJcbiAqIHRoYW4gdGhlIHByb3ZpZGVkIHRocmVzaG9sZCwgcmV0dXJuIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIHgveSBvZmZzZXQgZnJvbSBvcmlnaW4uXG4gKiBAcGFyYW0gbG9ja1RocmVzaG9sZCAtIChPcHRpb25hbCkgLSB0aGUgbWluaW11bSBhYnNvbHV0ZSBvZmZzZXQgYmVmb3JlIHdlIGNhbiBkZXRlcm1pbmUgYSBkcmFnIGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQsIGxvY2tUaHJlc2hvbGQgPSAxMCkge1xuICAgIGxldCBkaXJlY3Rpb24gPSBudWxsO1xuICAgIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IFwieVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyhvZmZzZXQueCkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IFwieFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5leHBvcnQgeyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLCBlbGVtZW50RHJhZ0NvbnRyb2xzIH07XG4iLCJpbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL0ZlYXR1cmUubWpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyB9IGZyb20gJy4vVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5tanMnO1xuXG5jbGFzcyBEcmFnR2VzdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgc3VwZXIobm9kZSk7XG4gICAgICAgIHRoaXMucmVtb3ZlR3JvdXBDb250cm9scyA9IG5vb3A7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gbm9vcDtcbiAgICAgICAgdGhpcy5jb250cm9scyA9IG5ldyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzKG5vZGUpO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYmVlbiBwcm92aWRlZCBhIERyYWdDb250cm9scyBmb3IgbWFudWFsIGNvbnRyb2wgb3ZlciB0aGUgZHJhZyBnZXN0dXJlLFxuICAgICAgICAvLyBzdWJzY3JpYmUgdGhpcyBjb21wb25lbnQgdG8gaXQgb24gbW91bnQuXG4gICAgICAgIGNvbnN0IHsgZHJhZ0NvbnRyb2xzIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgaWYgKGRyYWdDb250cm9scykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzID0gZHJhZ0NvbnRyb2xzLnN1YnNjcmliZSh0aGlzLmNvbnRyb2xzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHRoaXMuY29udHJvbHMuYWRkTGlzdGVuZXJzKCkgfHwgbm9vcDtcbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBEcmFnR2VzdHVyZSB9O1xuIiwiaW1wb3J0IHsgUGFuU2Vzc2lvbiB9IGZyb20gJy4vUGFuU2Vzc2lvbi5tanMnO1xuaW1wb3J0IHsgYWRkUG9pbnRlckV2ZW50IH0gZnJvbSAnLi4vLi4vZXZlbnRzL2FkZC1wb2ludGVyLWV2ZW50Lm1qcyc7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL0ZlYXR1cmUubWpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgZ2V0Q29udGV4dFdpbmRvdyB9IGZyb20gJy4uLy4uL3V0aWxzL2dldC1jb250ZXh0LXdpbmRvdy5tanMnO1xuaW1wb3J0IHsgZnJhbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuY29uc3QgYXN5bmNIYW5kbGVyID0gKGhhbmRsZXIpID0+IChldmVudCwgaW5mbykgPT4ge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gaGFuZGxlcihldmVudCwgaW5mbykpO1xuICAgIH1cbn07XG5jbGFzcyBQYW5HZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9pbnRlckRvd25MaXN0ZW5lciA9IG5vb3A7XG4gICAgfVxuICAgIG9uUG9pbnRlckRvd24ocG9pbnRlckRvd25FdmVudCkge1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBuZXcgUGFuU2Vzc2lvbihwb2ludGVyRG93bkV2ZW50LCB0aGlzLmNyZWF0ZVBhbkhhbmRsZXJzKCksIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogdGhpcy5ub2RlLmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpLFxuICAgICAgICAgICAgY29udGV4dFdpbmRvdzogZ2V0Q29udGV4dFdpbmRvdyh0aGlzLm5vZGUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlUGFuSGFuZGxlcnMoKSB7XG4gICAgICAgIGNvbnN0IHsgb25QYW5TZXNzaW9uU3RhcnQsIG9uUGFuU3RhcnQsIG9uUGFuLCBvblBhbkVuZCB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblNlc3Npb25TdGFydDogYXN5bmNIYW5kbGVyKG9uUGFuU2Vzc2lvblN0YXJ0KSxcbiAgICAgICAgICAgIG9uU3RhcnQ6IGFzeW5jSGFuZGxlcihvblBhblN0YXJ0KSxcbiAgICAgICAgICAgIG9uTW92ZTogb25QYW4sXG4gICAgICAgICAgICBvbkVuZDogKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgICAgICAgICBpZiAob25QYW5FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBvblBhbkVuZChldmVudCwgaW5mbykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnJlbW92ZVBvaW50ZXJEb3duTGlzdGVuZXIgPSBhZGRQb2ludGVyRXZlbnQodGhpcy5ub2RlLmN1cnJlbnQsIFwicG9pbnRlcmRvd25cIiwgKGV2ZW50KSA9PiB0aGlzLm9uUG9pbnRlckRvd24oZXZlbnQpKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICB0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLnVwZGF0ZUhhbmRsZXJzKHRoaXMuY3JlYXRlUGFuSGFuZGxlcnMoKSk7XG4gICAgfVxuICAgIHVubW91bnQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUG9pbnRlckRvd25MaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLnNlc3Npb24gJiYgdGhpcy5zZXNzaW9uLmVuZCgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgUGFuR2VzdHVyZSB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgUHJlc2VuY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblxuZXhwb3J0IHsgUHJlc2VuY2VDb250ZXh0IH07XG4iLCJpbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VJZCwgdXNlRWZmZWN0LCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyB0aGUgY2hpbGQgb2YgYEFuaW1hdGVQcmVzZW5jZWAsIGl0IGNhbiB1c2UgYHVzZVByZXNlbmNlYFxuICogdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIgaXQncyBzdGlsbCBwcmVzZW50IGluIHRoZSBSZWFjdCB0cmVlLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgdXNlUHJlc2VuY2UgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBzZXRUaW1lb3V0KHNhZmVUb1JlbW92ZSwgMTAwMClcbiAqICAgfSwgW2lzUHJlc2VudF0pXG4gKlxuICogICByZXR1cm4gPGRpdiAvPlxuICogfVxuICogYGBgXG4gKlxuICogSWYgYGlzUHJlc2VudGAgaXMgYGZhbHNlYCwgaXQgbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBoYXMgYmVlbiByZW1vdmVkIHRoZSB0cmVlLCBidXRcbiAqIGBBbmltYXRlUHJlc2VuY2VgIHdvbid0IHJlYWxseSByZW1vdmUgaXQgdW50aWwgYHNhZmVUb1JlbW92ZWAgaGFzIGJlZW4gY2FsbGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlUHJlc2VuY2Uoc3Vic2NyaWJlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbdHJ1ZSwgbnVsbF07XG4gICAgY29uc3QgeyBpc1ByZXNlbnQsIG9uRXhpdENvbXBsZXRlLCByZWdpc3RlciB9ID0gY29udGV4dDtcbiAgICAvLyBJdCdzIHNhZmUgdG8gY2FsbCB0aGUgZm9sbG93aW5nIGhvb2tzIGNvbmRpdGlvbmFsbHkgKGFmdGVyIGFuIGVhcmx5IHJldHVybikgYmVjYXVzZSB0aGUgY29udGV4dCB3aWxsIGFsd2F5c1xuICAgIC8vIGVpdGhlciBiZSBudWxsIG9yIG5vbi1udWxsIGZvciB0aGUgbGlmZXNwYW4gb2YgdGhlIGNvbXBvbmVudC5cbiAgICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN1YnNjcmliZSlcbiAgICAgICAgICAgIHJlZ2lzdGVyKGlkKTtcbiAgICB9LCBbc3Vic2NyaWJlXSk7XG4gICAgY29uc3Qgc2FmZVRvUmVtb3ZlID0gdXNlQ2FsbGJhY2soKCkgPT4gc3Vic2NyaWJlICYmIG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKGlkKSwgW2lkLCBvbkV4aXRDb21wbGV0ZSwgc3Vic2NyaWJlXSk7XG4gICAgcmV0dXJuICFpc1ByZXNlbnQgJiYgb25FeGl0Q29tcGxldGUgPyBbZmFsc2UsIHNhZmVUb1JlbW92ZV0gOiBbdHJ1ZV07XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVByZXNlbmNlYCwgZXhjZXB0IGB1c2VJc1ByZXNlbnRgIHNpbXBseSByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgcHJlc2VudC5cbiAqIFRoZXJlIGlzIG5vIGBzYWZlVG9SZW1vdmVgIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgdXNlSXNQcmVzZW50IH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IGlzUHJlc2VudCA9IHVzZUlzUHJlc2VudCgpXG4gKlxuICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgICFpc1ByZXNlbnQgJiYgY29uc29sZS5sb2coXCJJJ3ZlIGJlZW4gcmVtb3ZlZCFcIilcbiAqICAgfSwgW2lzUHJlc2VudF0pXG4gKlxuICogICByZXR1cm4gPGRpdiAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VJc1ByZXNlbnQoKSB7XG4gICAgcmV0dXJuIGlzUHJlc2VudCh1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCkpO1xufVxuZnVuY3Rpb24gaXNQcmVzZW50KGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCA9PT0gbnVsbCA/IHRydWUgOiBjb250ZXh0LmlzUHJlc2VudDtcbn1cblxuZXhwb3J0IHsgaXNQcmVzZW50LCB1c2VJc1ByZXNlbnQsIHVzZVByZXNlbmNlIH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IExheW91dEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuXG5leHBvcnQgeyBMYXlvdXRHcm91cENvbnRleHQgfTtcbiIsIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBJbnRlcm5hbCwgZXhwb3J0ZWQgb25seSBmb3IgdXNhZ2UgaW4gRnJhbWVyXG4gKi9cbmNvbnN0IFN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuXG5leHBvcnQgeyBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgfTtcbiIsIi8qKlxuICogVGhpcyBzaG91bGQgb25seSBldmVyIGJlIG1vZGlmaWVkIG9uIHRoZSBjbGllbnQgb3RoZXJ3aXNlIGl0J2xsXG4gKiBwZXJzaXN0IHRocm91Z2ggc2VydmVyIHJlcXVlc3RzLiBJZiB3ZSBuZWVkIGluc3RhbmNlZCBzdGF0ZXMgd2VcbiAqIGNvdWxkIGxhenktaW5pdCB2aWEgcm9vdC5cbiAqL1xuY29uc3QgZ2xvYmFsUHJvamVjdGlvblN0YXRlID0ge1xuICAgIC8qKlxuICAgICAqIEdsb2JhbCBmbGFnIGFzIHRvIHdoZXRoZXIgdGhlIHRyZWUgaGFzIGFuaW1hdGVkIHNpbmNlIHRoZSBsYXN0IHRpbWVcbiAgICAgKiB3ZSByZXNpemVkIHRoZSB3aW5kb3dcbiAgICAgKi9cbiAgICBoYXNBbmltYXRlZFNpbmNlUmVzaXplOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFdlIHNldCB0aGlzIHRvIHRydWUgb25jZSwgb24gdGhlIGZpcnN0IHVwZGF0ZS4gQW55IG5vZGVzIGFkZGVkIHRvIHRoZSB0cmVlIGJleW9uZCB0aGF0XG4gICAgICogdXBkYXRlIHdpbGwgYmUgZ2l2ZW4gYSBgZGF0YS1wcm9qZWN0aW9uLWlkYCBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgaGFzRXZlclVwZGF0ZWQ6IGZhbHNlLFxufTtcblxuZXhwb3J0IHsgZ2xvYmFsUHJvamVjdGlvblN0YXRlIH07XG4iLCJpbXBvcnQgeyBweCB9IGZyb20gJy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcblxuZnVuY3Rpb24gcGl4ZWxzVG9QZXJjZW50KHBpeGVscywgYXhpcykge1xuICAgIGlmIChheGlzLm1heCA9PT0gYXhpcy5taW4pXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAocGl4ZWxzIC8gKGF4aXMubWF4IC0gYXhpcy5taW4pKSAqIDEwMDtcbn1cbi8qKlxuICogV2UgYWx3YXlzIGNvcnJlY3QgYm9yZGVyUmFkaXVzIGFzIGEgcGVyY2VudGFnZSByYXRoZXIgdGhhbiBwaXhlbHMgdG8gcmVkdWNlIHBhaW50cy5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgYXJlIHByb2plY3RpbmcgYSBib3ggdGhhdCBpcyAxMDBweCB3aWRlIHdpdGggYSAxMHB4IGJvcmRlclJhZGl1c1xuICogaW50byBhIGJveCB0aGF0IGlzIDIwMHB4IHdpZGUgd2l0aCBhIDIwcHggYm9yZGVyUmFkaXVzLCB0aGF0IGlzIGFjdHVhbGx5IGEgMTAlXG4gKiBib3JkZXJSYWRpdXMgaW4gYm90aCBzdGF0ZXMuIElmIHdlIGFuaW1hdGUgYmV0d2VlbiB0aGUgdHdvIGluIHBpeGVscyB0aGF0IHdpbGwgdHJpZ2dlclxuICogYSBwYWludCBlYWNoIHRpbWUuIElmIHdlIGFuaW1hdGUgYmV0d2VlbiB0aGUgdHdvIGluIHBlcmNlbnRhZ2Ugd2UnbGwgYXZvaWQgYSBwYWludC5cbiAqL1xuY29uc3QgY29ycmVjdEJvcmRlclJhZGl1cyA9IHtcbiAgICBjb3JyZWN0OiAobGF0ZXN0LCBub2RlKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS50YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGF0ZXN0IGlzIGEgc3RyaW5nLCBpZiBpdCdzIGEgcGVyY2VudGFnZSB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5IGFzIGl0J3NcbiAgICAgICAgICogZ29pbmcgdG8gYmUgc3RyZXRjaGVkIGFwcHJvcHJpYXRlbHkuIE90aGVyd2lzZSwgaWYgaXQncyBhIHBpeGVsLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBsYXRlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChweC50ZXN0KGxhdGVzdCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBudW1iZXIsIGl0J3MgYSBwaXhlbCB2YWx1ZS4gV2UgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0Qm94IHRvIGNhbGN1bGF0ZSB0aGF0XG4gICAgICAgICAqIHBpeGVsIHZhbHVlIGFzIGEgcGVyY2VudGFnZSBvZiBlYWNoIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHggPSBwaXhlbHNUb1BlcmNlbnQobGF0ZXN0LCBub2RlLnRhcmdldC54KTtcbiAgICAgICAgY29uc3QgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LnkpO1xuICAgICAgICByZXR1cm4gYCR7eH0lICR7eX0lYDtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgY29ycmVjdEJvcmRlclJhZGl1cywgcGl4ZWxzVG9QZXJjZW50IH07XG4iLCJpbXBvcnQgeyBtaXhOdW1iZXIgfSBmcm9tICcuLi8uLi91dGlscy9taXgvbnVtYmVyLm1qcyc7XG5pbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvY29tcGxleC9pbmRleC5tanMnO1xuXG5jb25zdCBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICAgIGNvcnJlY3Q6IChsYXRlc3QsIHsgdHJlZVNjYWxlLCBwcm9qZWN0aW9uRGVsdGEgfSkgPT4ge1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGxhdGVzdDtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gY29tcGxleC5wYXJzZShsYXRlc3QpO1xuICAgICAgICAvLyBUT0RPOiBEb2Vzbid0IHN1cHBvcnQgbXVsdGlwbGUgc2hhZG93c1xuICAgICAgICBpZiAoc2hhZG93Lmxlbmd0aCA+IDUpXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWw7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcihsYXRlc3QpO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2Ygc2hhZG93WzBdICE9PSBcIm51bWJlclwiID8gMSA6IDA7XG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgb3ZlcmFsbCBjb250ZXh0IHNjYWxlXG4gICAgICAgIGNvbnN0IHhTY2FsZSA9IHByb2plY3Rpb25EZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgICAgIGNvbnN0IHlTY2FsZSA9IHByb2plY3Rpb25EZWx0YS55LnNjYWxlICogdHJlZVNjYWxlLnk7XG4gICAgICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHdlJ2QgY29ycmVjdCB4IGFuZCB5IHNjYWxlcyBpbmRpdmlkdWFsbHksIGJ1dCBiZWNhdXNlIGJsdXIgYW5kXG4gICAgICAgICAqIHNwcmVhZCBhcHBseSB0byBib3RoIHdlIGhhdmUgdG8gdGFrZSBhIHNjYWxlIGF2ZXJhZ2UgYW5kIGFwcGx5IHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICogV2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSB0aGUgb3V0Y29tZSBvZiB0aGlzIGJ5IGluY29ycG9yYXRpbmcgdGhlIHJhdGlvIGJldHdlZW5cbiAgICAgICAgICogdGhlIHR3byBzY2FsZXMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBhdmVyYWdlU2NhbGUgPSBtaXhOdW1iZXIoeFNjYWxlLCB5U2NhbGUsIDAuNSk7XG4gICAgICAgIC8vIEJsdXJcbiAgICAgICAgaWYgKHR5cGVvZiBzaGFkb3dbMiArIG9mZnNldF0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBzaGFkb3dbMiArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICAgICAgICAvLyBTcHJlYWRcbiAgICAgICAgaWYgKHR5cGVvZiBzaGFkb3dbMyArIG9mZnNldF0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBzaGFkb3dbMyArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUoc2hhZG93KTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgY29ycmVjdEJveFNoYWRvdyB9O1xuIiwiaW1wb3J0IHsgaXNDU1NWYXJpYWJsZU5hbWUgfSBmcm9tICcuLi8uLi9yZW5kZXIvZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanMnO1xuXG5jb25zdCBzY2FsZUNvcnJlY3RvcnMgPSB7fTtcbmZ1bmN0aW9uIGFkZFNjYWxlQ29ycmVjdG9yKGNvcnJlY3RvcnMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjb3JyZWN0b3JzKSB7XG4gICAgICAgIHNjYWxlQ29ycmVjdG9yc1trZXldID0gY29ycmVjdG9yc1trZXldO1xuICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZU5hbWUoa2V5KSkge1xuICAgICAgICAgICAgc2NhbGVDb3JyZWN0b3JzW2tleV0uaXNDU1NWYXJpYWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGFkZFNjYWxlQ29ycmVjdG9yLCBzY2FsZUNvcnJlY3RvcnMgfTtcbiIsImltcG9ydCB7IGNyZWF0ZVJlbmRlckJhdGNoZXIgfSBmcm9tICcuL2JhdGNoZXIubWpzJztcblxuY29uc3QgeyBzY2hlZHVsZTogbWljcm90YXNrLCBjYW5jZWw6IGNhbmNlbE1pY3JvdGFzayB9ID0gY3JlYXRlUmVuZGVyQmF0Y2hlcihxdWV1ZU1pY3JvdGFzaywgZmFsc2UpO1xuXG5leHBvcnQgeyBjYW5jZWxNaWNyb3Rhc2ssIG1pY3JvdGFzayB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VQcmVzZW5jZSB9IGZyb20gJy4uLy4uLy4uL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL3VzZS1wcmVzZW5jZS5tanMnO1xuaW1wb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IFN3aXRjaExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4uLy4uLy4uL2NvbnRleHQvU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL25vZGUvc3RhdGUubWpzJztcbmltcG9ydCB7IGNvcnJlY3RCb3JkZXJSYWRpdXMgfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3JkZXItcmFkaXVzLm1qcyc7XG5pbXBvcnQgeyBjb3JyZWN0Qm94U2hhZG93IH0gZnJvbSAnLi4vLi4vLi4vcHJvamVjdGlvbi9zdHlsZXMvc2NhbGUtYm94LXNoYWRvdy5tanMnO1xuaW1wb3J0IHsgYWRkU2NhbGVDb3JyZWN0b3IgfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qcyc7XG5pbXBvcnQgeyBtaWNyb3Rhc2sgfSBmcm9tICcuLi8uLi8uLi9mcmFtZWxvb3AvbWljcm90YXNrLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uLy4uLy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5jbGFzcyBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQgZXh0ZW5kcyBDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIFRoaXMgb25seSBtb3VudHMgcHJvamVjdGlvbiBub2RlcyBmb3IgY29tcG9uZW50cyB0aGF0XG4gICAgICogbmVlZCBtZWFzdXJpbmcsIHdlIG1pZ2h0IHdhbnQgdG8gZG8gaXQgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgICogaW4gb3JkZXIgdG8gaW5jb3Jwb3JhdGUgdHJhbnNmb3Jtc1xuICAgICAqL1xuICAgIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cCwgbGF5b3V0SWQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgYWRkU2NhbGVDb3JyZWN0b3IoZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAuZ3JvdXApXG4gICAgICAgICAgICAgICAgbGF5b3V0R3JvdXAuZ3JvdXAuYWRkKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHN3aXRjaExheW91dEdyb3VwICYmIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyICYmIGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoTGF5b3V0R3JvdXAucmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25Db21wbGV0ZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAuLi5wcm9qZWN0aW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgb25FeGl0Q29tcGxldGU6ICgpID0+IHRoaXMuc2FmZVRvUmVtb3ZlKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzRXZlclVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBsYXlvdXREZXBlbmRlbmN5LCB2aXN1YWxFbGVtZW50LCBkcmFnLCBpc1ByZXNlbnQgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmICghcHJvamVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogV2UgdXNlIHRoaXMgZGF0YSBpbiByZWxlZ2F0ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0b1xuICAgICAgICAgKiBwcm9tb3RlIGEgcHJldmlvdXMgZWxlbWVudC4gVGhlcmUncyBubyBndWFyYW50ZWUgaXRzIHByZXNlbmNlIGRhdGFcbiAgICAgICAgICogd2lsbCBoYXZlIHVwZGF0ZWQgYnkgdGhpcyBwb2ludCAtIGlmIGEgYnVnIGxpa2UgdGhpcyBhcmlzZXMgaXQgd2lsbFxuICAgICAgICAgKiBoYXZlIHRvIGJlIHRoYXQgd2UgbWFya0ZvclJlbGVnYXRpb24gYW5kIHRoZW4gZmluZCBhIG5ldyBsZWFkIHNvbWUgb3RoZXIgd2F5LFxuICAgICAgICAgKiBwZXJoYXBzIGluIGRpZFVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdGlvbi5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgICAgIGlmIChkcmFnIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMubGF5b3V0RGVwZW5kZW5jeSAhPT0gbGF5b3V0RGVwZW5kZW5jeSB8fFxuICAgICAgICAgICAgbGF5b3V0RGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLndpbGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQcm9wcy5pc1ByZXNlbnQgIT09IGlzUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb24ucHJvbW90ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXByb2plY3Rpb24ucmVsZWdhdGUoKSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZXJlJ3MgYW5vdGhlciBzdGFjayBtZW1iZXIgdGFraW5nIG92ZXIgZnJvbSB0aGlzIG9uZSxcbiAgICAgICAgICAgICAgICAgKiBpdCdzIGluIGNoYXJnZSBvZiB0aGUgZXhpdCBhbmltYXRpb24gYW5kIHRoZXJlZm9yZSBzaG91bGRcbiAgICAgICAgICAgICAgICAgKiBiZSBpbiBjaGFyZ2Ugb2YgdGhlIHNhZmUgdG8gcmVtb3ZlLiBPdGhlcndpc2Ugd2UgY2FsbCBpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHByb2plY3Rpb24uZ2V0U3RhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGFjayB8fCAhc3RhY2subWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMucHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgIG1pY3JvdGFzay5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb2plY3Rpb24uY3VycmVudEFuaW1hdGlvbiAmJiBwcm9qZWN0aW9uLmlzTGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAsIHN3aXRjaExheW91dEdyb3VwOiBwcm9tb3RlQ29udGV4dCwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpO1xuICAgICAgICAgICAgaWYgKGxheW91dEdyb3VwICYmIGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLnJlbW92ZShwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9tb3RlQ29udGV4dCAmJiBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKVxuICAgICAgICAgICAgICAgIHByb21vdGVDb250ZXh0LmRlcmVnaXN0ZXIocHJvamVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2FmZVRvUmVtb3ZlKCkge1xuICAgICAgICBjb25zdCB7IHNhZmVUb1JlbW92ZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgc2FmZVRvUmVtb3ZlICYmIHNhZmVUb1JlbW92ZSgpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIE1lYXN1cmVMYXlvdXQocHJvcHMpIHtcbiAgICBjb25zdCBbaXNQcmVzZW50LCBzYWZlVG9SZW1vdmVdID0gdXNlUHJlc2VuY2UoKTtcbiAgICBjb25zdCBsYXlvdXRHcm91cCA9IHVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICByZXR1cm4gKGpzeChNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQsIHsgLi4ucHJvcHMsIGxheW91dEdyb3VwOiBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXA6IHVzZUNvbnRleHQoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KSwgaXNQcmVzZW50OiBpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZTogc2FmZVRvUmVtb3ZlIH0pKTtcbn1cbmNvbnN0IGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gICAgYm9yZGVyUmFkaXVzOiB7XG4gICAgICAgIC4uLmNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgICAgIGFwcGx5VG86IFtcbiAgICAgICAgICAgIFwiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm94U2hhZG93OiBjb3JyZWN0Qm94U2hhZG93LFxufTtcblxuZXhwb3J0IHsgTWVhc3VyZUxheW91dCB9O1xuIiwiaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgYW5pbWF0ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gYW5pbWF0ZVNpbmdsZVZhbHVlKHZhbHVlLCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb3Rpb25WYWx1ZSQxID0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZSA6IG1vdGlvblZhbHVlKHZhbHVlKTtcbiAgICBtb3Rpb25WYWx1ZSQxLnN0YXJ0KGFuaW1hdGVNb3Rpb25WYWx1ZShcIlwiLCBtb3Rpb25WYWx1ZSQxLCBrZXlmcmFtZXMsIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gbW90aW9uVmFsdWUkMS5hbmltYXRpb247XG59XG5cbmV4cG9ydCB7IGFuaW1hdGVTaW5nbGVWYWx1ZSB9O1xuIiwiZnVuY3Rpb24gaXNTVkdFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQgJiYgZWxlbWVudC50YWdOYW1lICE9PSBcInN2Z1wiO1xufVxuXG5leHBvcnQgeyBpc1NWR0VsZW1lbnQgfTtcbiIsImNvbnN0IGNvbXBhcmVCeURlcHRoID0gKGEsIGIpID0+IGEuZGVwdGggLSBiLmRlcHRoO1xuXG5leHBvcnQgeyBjb21wYXJlQnlEZXB0aCB9O1xuIiwiaW1wb3J0IHsgYWRkVW5pcXVlSXRlbSwgcmVtb3ZlSXRlbSB9IGZyb20gJy4uLy4uL3V0aWxzL2FycmF5Lm1qcyc7XG5pbXBvcnQgeyBjb21wYXJlQnlEZXB0aCB9IGZyb20gJy4vY29tcGFyZS1ieS1kZXB0aC5tanMnO1xuXG5jbGFzcyBGbGF0VHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZChjaGlsZCkge1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlKGNoaWxkKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSAmJiB0aGlzLmNoaWxkcmVuLnNvcnQoY29tcGFyZUJ5RGVwdGgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEZsYXRUcmVlIH07XG4iLCJpbXBvcnQgeyBzZWNvbmRzVG9NaWxsaXNlY29uZHMgfSBmcm9tICdtb3Rpb24tdXRpbHMnO1xuaW1wb3J0IHsgdGltZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9zeW5jLXRpbWUubWpzJztcbmltcG9ydCB7IGZyYW1lLCBjYW5jZWxGcmFtZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG4vKipcbiAqIFRpbWVvdXQgZGVmaW5lZCBpbiBtc1xuICovXG5mdW5jdGlvbiBkZWxheShjYWxsYmFjaywgdGltZW91dCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGltZS5ub3coKTtcbiAgICBjb25zdCBjaGVja0VsYXBzZWQgPSAoeyB0aW1lc3RhbXAgfSkgPT4ge1xuICAgICAgICBjb25zdCBlbGFwc2VkID0gdGltZXN0YW1wIC0gc3RhcnQ7XG4gICAgICAgIGlmIChlbGFwc2VkID49IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNhbmNlbEZyYW1lKGNoZWNrRWxhcHNlZCk7XG4gICAgICAgICAgICBjYWxsYmFjayhlbGFwc2VkIC0gdGltZW91dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZyYW1lLnJlYWQoY2hlY2tFbGFwc2VkLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4gY2FuY2VsRnJhbWUoY2hlY2tFbGFwc2VkKTtcbn1cbmZ1bmN0aW9uIGRlbGF5SW5TZWNvbmRzKGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgcmV0dXJuIGRlbGF5KGNhbGxiYWNrLCBzZWNvbmRzVG9NaWxsaXNlY29uZHModGltZW91dCkpO1xufVxuXG5leHBvcnQgeyBkZWxheSwgZGVsYXlJblNlY29uZHMgfTtcbiIsImltcG9ydCB7IGlzQ3VzdG9tVmFsdWUgfSBmcm9tICcuLi8uLi91dGlscy9yZXNvbHZlLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuLyoqXG4gKiBJZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBNb3Rpb25WYWx1ZSwgdGhpcyByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHRoZSB2YWx1ZSBpdHNlbGZcbiAqXG4gKiBUT0RPOiBSZW1vdmUgYW5kIG1vdmUgdG8gbGlicmFyeVxuICovXG5mdW5jdGlvbiByZXNvbHZlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB1bndyYXBwZWRWYWx1ZSA9IGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgICByZXR1cm4gaXNDdXN0b21WYWx1ZSh1bndyYXBwZWRWYWx1ZSlcbiAgICAgICAgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKClcbiAgICAgICAgOiB1bndyYXBwZWRWYWx1ZTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyBwcm9ncmVzcywgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBjaXJjT3V0IH0gZnJvbSAnLi4vLi4vZWFzaW5nL2NpcmMubWpzJztcbmltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcbmltcG9ydCB7IHBlcmNlbnQsIHB4IH0gZnJvbSAnLi4vLi4vdmFsdWUvdHlwZXMvbnVtYmVycy91bml0cy5tanMnO1xuXG5jb25zdCBib3JkZXJzID0gW1wiVG9wTGVmdFwiLCBcIlRvcFJpZ2h0XCIsIFwiQm90dG9tTGVmdFwiLCBcIkJvdHRvbVJpZ2h0XCJdO1xuY29uc3QgbnVtQm9yZGVycyA9IGJvcmRlcnMubGVuZ3RoO1xuY29uc3QgYXNOdW1iZXIgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRmxvYXQodmFsdWUpIDogdmFsdWU7XG5jb25zdCBpc1B4ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgcHgudGVzdCh2YWx1ZSk7XG5mdW5jdGlvbiBtaXhWYWx1ZXModGFyZ2V0LCBmb2xsb3csIGxlYWQsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpIHtcbiAgICBpZiAoc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSkge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IG1peE51bWJlcigwLCBcbiAgICAgICAgLy8gVE9ETyBSZWluc3RhdGUgdGhpcyBpZiBvbmx5IGNoaWxkXG4gICAgICAgIGxlYWQub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gbGVhZC5vcGFjaXR5IDogMSwgZWFzZUNyb3NzZmFkZUluKHByb2dyZXNzKSk7XG4gICAgICAgIHRhcmdldC5vcGFjaXR5RXhpdCA9IG1peE51bWJlcihmb2xsb3cub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gZm9sbG93Lm9wYWNpdHkgOiAxLCAwLCBlYXNlQ3Jvc3NmYWRlT3V0KHByb2dyZXNzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT25seU1lbWJlcikge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IG1peE51bWJlcihmb2xsb3cub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gZm9sbG93Lm9wYWNpdHkgOiAxLCBsZWFkLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IGxlYWQub3BhY2l0eSA6IDEsIHByb2dyZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IGJvcmRlciByYWRpdXNcbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJvcmRlcnM7IGkrKykge1xuICAgICAgICBjb25zdCBib3JkZXJMYWJlbCA9IGBib3JkZXIke2JvcmRlcnNbaV19UmFkaXVzYDtcbiAgICAgICAgbGV0IGZvbGxvd1JhZGl1cyA9IGdldFJhZGl1cyhmb2xsb3csIGJvcmRlckxhYmVsKTtcbiAgICAgICAgbGV0IGxlYWRSYWRpdXMgPSBnZXRSYWRpdXMobGVhZCwgYm9yZGVyTGFiZWwpO1xuICAgICAgICBpZiAoZm9sbG93UmFkaXVzID09PSB1bmRlZmluZWQgJiYgbGVhZFJhZGl1cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvbGxvd1JhZGl1cyB8fCAoZm9sbG93UmFkaXVzID0gMCk7XG4gICAgICAgIGxlYWRSYWRpdXMgfHwgKGxlYWRSYWRpdXMgPSAwKTtcbiAgICAgICAgY29uc3QgY2FuTWl4ID0gZm9sbG93UmFkaXVzID09PSAwIHx8XG4gICAgICAgICAgICBsZWFkUmFkaXVzID09PSAwIHx8XG4gICAgICAgICAgICBpc1B4KGZvbGxvd1JhZGl1cykgPT09IGlzUHgobGVhZFJhZGl1cyk7XG4gICAgICAgIGlmIChjYW5NaXgpIHtcbiAgICAgICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gPSBNYXRoLm1heChtaXhOdW1iZXIoYXNOdW1iZXIoZm9sbG93UmFkaXVzKSwgYXNOdW1iZXIobGVhZFJhZGl1cyksIHByb2dyZXNzKSwgMCk7XG4gICAgICAgICAgICBpZiAocGVyY2VudC50ZXN0KGxlYWRSYWRpdXMpIHx8IHBlcmNlbnQudGVzdChmb2xsb3dSYWRpdXMpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSArPSBcIiVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gPSBsZWFkUmFkaXVzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1peCByb3RhdGlvblxuICAgICAqL1xuICAgIGlmIChmb2xsb3cucm90YXRlIHx8IGxlYWQucm90YXRlKSB7XG4gICAgICAgIHRhcmdldC5yb3RhdGUgPSBtaXhOdW1iZXIoZm9sbG93LnJvdGF0ZSB8fCAwLCBsZWFkLnJvdGF0ZSB8fCAwLCBwcm9ncmVzcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmFkaXVzKHZhbHVlcywgcmFkaXVzTmFtZSkge1xuICAgIHJldHVybiB2YWx1ZXNbcmFkaXVzTmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHZhbHVlc1tyYWRpdXNOYW1lXVxuICAgICAgICA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG4vLyAvKipcbi8vICAqIFdlIG9ubHkgd2FudCB0byBtaXggdGhlIGJhY2tncm91bmQgY29sb3IgaWYgdGhlcmUncyBhIGZvbGxvdyBlbGVtZW50XG4vLyAgKiB0aGF0IHdlJ3JlIG5vdCBjcm9zc2ZhZGluZyBvcGFjaXR5IGJldHdlZW4uIEZvciBpbnN0YW5jZSB3aXRoIHN3aXRjaFxuLy8gICogQW5pbWF0ZVNoYXJlZExheW91dCBhbmltYXRpb25zLCB0aGlzIGhlbHBzIHRoZSBpbGx1c2lvbiBvZiBhIGNvbnRpbnVvdXNcbi8vICAqIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQgYnV0IGFsc28gY3V0cyBkb3duIG9uIHRoZSBudW1iZXIgb2YgcGFpbnRzIHRyaWdnZXJlZFxuLy8gICogZm9yIGVsZW1lbnRzIHdoZXJlIG9wYWNpdHkgaXMgZG9pbmcgdGhhdCB3b3JrIGZvciB1cy5cbi8vICAqL1xuLy8gaWYgKFxuLy8gICAgICFoYXNGb2xsb3dFbGVtZW50ICYmXG4vLyAgICAgbGF0ZXN0TGVhZFZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgJiZcbi8vICAgICBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yXG4vLyApIHtcbi8vICAgICAvKipcbi8vICAgICAgKiBUaGlzIGlzbid0IGlkZWFsIHBlcmZvcm1hbmNlLXdpc2UgYXMgbWl4Q29sb3IgaXMgY3JlYXRpbmcgYSBuZXcgZnVuY3Rpb24gZXZlcnkgZnJhbWUuXG4vLyAgICAgICogV2UgY291bGQgcHJvYmFibHkgY3JlYXRlIGEgbWl4ZXIgdGhhdCBydW5zIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIGJ1dFxuLy8gICAgICAqIHRoZSBpZGVhIGJlaGluZCB0aGUgY3Jvc3NmYWRlciBpcyB0aGF0IGl0IHJ1bnMgZHluYW1pY2FsbHkgYmV0d2VlbiB0d28gcG90ZW50aWFsbHlcbi8vICAgICAgKiBjaGFuZ2luZyB0YXJnZXRzIChpZSBvcGFjaXR5IG9yIGJvcmRlclJhZGl1cyBtYXkgYmUgYW5pbWF0aW5nIGluZGVwZW5kZW50bHkgdmlhIHZhcmlhbnRzKVxuLy8gICAgICAqL1xuLy8gICAgIGxlYWRTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBmb2xsb3dTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBtaXhDb2xvcihcbi8vICAgICAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmcsXG4vLyAgICAgICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yIGFzIHN0cmluZ1xuLy8gICAgICkocClcbi8vIH1cbmNvbnN0IGVhc2VDcm9zc2ZhZGVJbiA9IC8qQF9fUFVSRV9fKi8gY29tcHJlc3MoMCwgMC41LCBjaXJjT3V0KTtcbmNvbnN0IGVhc2VDcm9zc2ZhZGVPdXQgPSAvKkBfX1BVUkVfXyovIGNvbXByZXNzKDAuNSwgMC45NSwgbm9vcCk7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIChwKSA9PiB7XG4gICAgICAgIC8vIENvdWxkIHJlcGxhY2UgaWZzIHdpdGggY2xhbXBcbiAgICAgICAgaWYgKHAgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHAgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyhtaW4sIG1heCwgcCkpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG1peFZhbHVlcyB9O1xuIiwiLyoqXG4gKiBSZXNldCBhbiBheGlzIHRvIHRoZSBwcm92aWRlZCBvcmlnaW4gYm94LlxuICpcbiAqIFRoaXMgaXMgYSBtdXRhdGl2ZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvcHlBeGlzSW50byhheGlzLCBvcmlnaW5BeGlzKSB7XG4gICAgYXhpcy5taW4gPSBvcmlnaW5BeGlzLm1pbjtcbiAgICBheGlzLm1heCA9IG9yaWdpbkF4aXMubWF4O1xufVxuLyoqXG4gKiBSZXNldCBhIGJveCB0byB0aGUgcHJvdmlkZWQgb3JpZ2luIGJveC5cbiAqXG4gKiBUaGlzIGlzIGEgbXV0YXRpdmUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjb3B5Qm94SW50byhib3gsIG9yaWdpbkJveCkge1xuICAgIGNvcHlBeGlzSW50byhib3gueCwgb3JpZ2luQm94LngpO1xuICAgIGNvcHlBeGlzSW50byhib3gueSwgb3JpZ2luQm94LnkpO1xufVxuLyoqXG4gKiBSZXNldCBhIGRlbHRhIHRvIHRoZSBwcm92aWRlZCBvcmlnaW4gYm94LlxuICpcbiAqIFRoaXMgaXMgYSBtdXRhdGl2ZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvcHlBeGlzRGVsdGFJbnRvKGRlbHRhLCBvcmlnaW5EZWx0YSkge1xuICAgIGRlbHRhLnRyYW5zbGF0ZSA9IG9yaWdpbkRlbHRhLnRyYW5zbGF0ZTtcbiAgICBkZWx0YS5zY2FsZSA9IG9yaWdpbkRlbHRhLnNjYWxlO1xuICAgIGRlbHRhLm9yaWdpblBvaW50ID0gb3JpZ2luRGVsdGEub3JpZ2luUG9pbnQ7XG4gICAgZGVsdGEub3JpZ2luID0gb3JpZ2luRGVsdGEub3JpZ2luO1xufVxuXG5leHBvcnQgeyBjb3B5QXhpc0RlbHRhSW50bywgY29weUF4aXNJbnRvLCBjb3B5Qm94SW50byB9O1xuIiwiaW1wb3J0IHsgbWl4TnVtYmVyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbWl4L251bWJlci5tanMnO1xuaW1wb3J0IHsgcGVyY2VudCB9IGZyb20gJy4uLy4uL3ZhbHVlL3R5cGVzL251bWJlcnMvdW5pdHMubWpzJztcbmltcG9ydCB7IHNjYWxlUG9pbnQgfSBmcm9tICcuL2RlbHRhLWFwcGx5Lm1qcyc7XG5cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhIHBvaW50LiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseVBvaW50RGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBwb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCAxIC8gc2NhbGUsIG9yaWdpblBvaW50KTtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIFJlbW92ZSBhIGRlbHRhIGZyb20gYW4gYXhpcy4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzRGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAxLCBvcmlnaW4gPSAwLjUsIGJveFNjYWxlLCBvcmlnaW5BeGlzID0gYXhpcywgc291cmNlQXhpcyA9IGF4aXMpIHtcbiAgICBpZiAocGVyY2VudC50ZXN0KHRyYW5zbGF0ZSkpIHtcbiAgICAgICAgdHJhbnNsYXRlID0gcGFyc2VGbG9hdCh0cmFuc2xhdGUpO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVByb2dyZXNzID0gbWl4TnVtYmVyKHNvdXJjZUF4aXMubWluLCBzb3VyY2VBeGlzLm1heCwgdHJhbnNsYXRlIC8gMTAwKTtcbiAgICAgICAgdHJhbnNsYXRlID0gcmVsYXRpdmVQcm9ncmVzcyAtIHNvdXJjZUF4aXMubWluO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRyYW5zbGF0ZSAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBvcmlnaW5Qb2ludCA9IG1peE51bWJlcihvcmlnaW5BeGlzLm1pbiwgb3JpZ2luQXhpcy5tYXgsIG9yaWdpbik7XG4gICAgaWYgKGF4aXMgPT09IG9yaWdpbkF4aXMpXG4gICAgICAgIG9yaWdpblBvaW50IC09IHRyYW5zbGF0ZTtcbiAgICBheGlzLm1pbiA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG4gICAgYXhpcy5tYXggPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuLyoqXG4gKiBSZW1vdmUgYSB0cmFuc2Zvcm1zIGZyb20gYW4gYXhpcy4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzVHJhbnNmb3JtcyBpbiByZXZlcnNlXG4gKiBhbmQgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIG1vdGlvbiB2YWx1ZXMgYW5kIHJlbW92ZUF4aXNEZWx0YVxuICovXG5mdW5jdGlvbiByZW1vdmVBeGlzVHJhbnNmb3JtcyhheGlzLCB0cmFuc2Zvcm1zLCBba2V5LCBzY2FsZUtleSwgb3JpZ2luS2V5XSwgb3JpZ2luLCBzb3VyY2VBeGlzKSB7XG4gICAgcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIHRyYW5zZm9ybXNbb3JpZ2luS2V5XSwgdHJhbnNmb3Jtcy5zY2FsZSwgb3JpZ2luLCBzb3VyY2VBeGlzKTtcbn1cbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBtb3Rpb24gdmFsdWVzIHdlIHdhbnQgdG8gYXBwbHkgYXMgdHJhbnNsYXRpb24sIHNjYWxlIGFuZCBvcmlnaW4uXG4gKi9cbmNvbnN0IHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG5jb25zdCB5S2V5cyA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuLyoqXG4gKiBSZW1vdmUgYSB0cmFuc2Zvcm1zIGZyb20gYW4gYm94LiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNCb3ggaW4gcmV2ZXJzZVxuICogYW5kIGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBtb3Rpb24gdmFsdWVzIGFuZCByZW1vdmVBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3gsIHRyYW5zZm9ybXMsIG9yaWdpbkJveCwgc291cmNlQm94KSB7XG4gICAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LngsIHRyYW5zZm9ybXMsIHhLZXlzLCBvcmlnaW5Cb3ggPyBvcmlnaW5Cb3gueCA6IHVuZGVmaW5lZCwgc291cmNlQm94ID8gc291cmNlQm94LnggOiB1bmRlZmluZWQpO1xuICAgIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC55LCB0cmFuc2Zvcm1zLCB5S2V5cywgb3JpZ2luQm94ID8gb3JpZ2luQm94LnkgOiB1bmRlZmluZWQsIHNvdXJjZUJveCA/IHNvdXJjZUJveC55IDogdW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0IHsgcmVtb3ZlQXhpc0RlbHRhLCByZW1vdmVBeGlzVHJhbnNmb3JtcywgcmVtb3ZlQm94VHJhbnNmb3JtcywgcmVtb3ZlUG9pbnREZWx0YSB9O1xuIiwiaW1wb3J0IHsgY2FsY0xlbmd0aCB9IGZyb20gJy4vZGVsdGEtY2FsYy5tanMnO1xuXG5mdW5jdGlvbiBpc0F4aXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gZGVsdGEudHJhbnNsYXRlID09PSAwICYmIGRlbHRhLnNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gaXNBeGlzRGVsdGFaZXJvKGRlbHRhLngpICYmIGlzQXhpc0RlbHRhWmVybyhkZWx0YS55KTtcbn1cbmZ1bmN0aW9uIGF4aXNFcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBhLm1pbiA9PT0gYi5taW4gJiYgYS5tYXggPT09IGIubWF4O1xufVxuZnVuY3Rpb24gYm94RXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYXhpc0VxdWFscyhhLngsIGIueCkgJiYgYXhpc0VxdWFscyhhLnksIGIueSk7XG59XG5mdW5jdGlvbiBheGlzRXF1YWxzUm91bmRlZChhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLnJvdW5kKGEubWluKSA9PT0gTWF0aC5yb3VuZChiLm1pbikgJiZcbiAgICAgICAgTWF0aC5yb3VuZChhLm1heCkgPT09IE1hdGgucm91bmQoYi5tYXgpKTtcbn1cbmZ1bmN0aW9uIGJveEVxdWFsc1JvdW5kZWQoYSwgYikge1xuICAgIHJldHVybiBheGlzRXF1YWxzUm91bmRlZChhLngsIGIueCkgJiYgYXhpc0VxdWFsc1JvdW5kZWQoYS55LCBiLnkpO1xufVxuZnVuY3Rpb24gYXNwZWN0UmF0aW8oYm94KSB7XG4gICAgcmV0dXJuIGNhbGNMZW5ndGgoYm94LngpIC8gY2FsY0xlbmd0aChib3gueSk7XG59XG5mdW5jdGlvbiBheGlzRGVsdGFFcXVhbHMoYSwgYikge1xuICAgIHJldHVybiAoYS50cmFuc2xhdGUgPT09IGIudHJhbnNsYXRlICYmXG4gICAgICAgIGEuc2NhbGUgPT09IGIuc2NhbGUgJiZcbiAgICAgICAgYS5vcmlnaW5Qb2ludCA9PT0gYi5vcmlnaW5Qb2ludCk7XG59XG5cbmV4cG9ydCB7IGFzcGVjdFJhdGlvLCBheGlzRGVsdGFFcXVhbHMsIGF4aXNFcXVhbHMsIGF4aXNFcXVhbHNSb3VuZGVkLCBib3hFcXVhbHMsIGJveEVxdWFsc1JvdW5kZWQsIGlzRGVsdGFaZXJvIH07XG4iLCJpbXBvcnQgeyBhZGRVbmlxdWVJdGVtLCByZW1vdmVJdGVtIH0gZnJvbSAnLi4vLi4vdXRpbHMvYXJyYXkubWpzJztcblxuY2xhc3MgTm9kZVN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgfVxuICAgIGFkZChub2RlKSB7XG4gICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH1cbiAgICByZW1vdmUobm9kZSkge1xuICAgICAgICByZW1vdmVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLnByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZMZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmxlYWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5tZW1iZXJzW3RoaXMubWVtYmVycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVsZWdhdGUobm9kZSkge1xuICAgICAgICBjb25zdCBpbmRleE9mTm9kZSA9IHRoaXMubWVtYmVycy5maW5kSW5kZXgoKG1lbWJlcikgPT4gbm9kZSA9PT0gbWVtYmVyKTtcbiAgICAgICAgaWYgKGluZGV4T2ZOb2RlID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgbmV4dCBwcm9qZWN0aW9uIG5vZGUgdGhhdCBpcyBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgcHJldkxlYWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleE9mTm9kZTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1lbWJlciA9IHRoaXMubWVtYmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChtZW1iZXIuaXNQcmVzZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHByZXZMZWFkID0gbWVtYmVyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb21vdGUobm9kZSwgcHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgIGNvbnN0IHByZXZMZWFkID0gdGhpcy5sZWFkO1xuICAgICAgICBpZiAobm9kZSA9PT0gcHJldkxlYWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucHJldkxlYWQgPSBwcmV2TGVhZDtcbiAgICAgICAgdGhpcy5sZWFkID0gbm9kZTtcbiAgICAgICAgbm9kZS5zaG93KCk7XG4gICAgICAgIGlmIChwcmV2TGVhZCkge1xuICAgICAgICAgICAgcHJldkxlYWQuaW5zdGFuY2UgJiYgcHJldkxlYWQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIG5vZGUuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIG5vZGUucmVzdW1lRnJvbSA9IHByZXZMZWFkO1xuICAgICAgICAgICAgaWYgKHByZXNlcnZlRm9sbG93T3BhY2l0eSkge1xuICAgICAgICAgICAgICAgIG5vZGUucmVzdW1lRnJvbS5wcmVzZXJ2ZU9wYWNpdHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXZMZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdCA9IHByZXZMZWFkLnNuYXBzaG90O1xuICAgICAgICAgICAgICAgIG5vZGUuc25hcHNob3QubGF0ZXN0VmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgcHJldkxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IHByZXZMZWFkLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnJvb3QgJiYgbm9kZS5yb290LmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBub2RlLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBjcm9zc2ZhZGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChjcm9zc2ZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPOlxuICAgICAgICAgICAgICogICAtIFRlc3QgYm9yZGVyIHJhZGl1cyB3aGVuIHByZXZpb3VzIG5vZGUgd2FzIGRlbGV0ZWRcbiAgICAgICAgICAgICAqICAgLSBib3hTaGFkb3cgbWl4aW5nXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHNjcm9sbGVkIGNvbnRhaW5lciBhbmQgZWxlbWVudCBCIChzY3JvbGwgc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gdHJhbnNmb3JtZWQgY29udGFpbmVyIGFuZCBlbGVtZW50IEIgKHRyYW5zZm9ybSBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiBzY3JvbGxlZCBwYWdlIGFuZCBlbGVtZW50IEIgKHNjcm9sbCBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogLS0tXG4gICAgICAgICAgICAgKiAgIC0gQ3Jvc3NmYWRlIG9wYWNpdHkgb2Ygcm9vdCBub2Rlc1xuICAgICAgICAgICAgICogICAtIGxheW91dElkIGNoYW5nZXMgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiAgIC0gbGF5b3V0SWQgY2hhbmdlcyBtaWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0QW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMsIHJlc3VtaW5nRnJvbSB9ID0gbm9kZTtcbiAgICAgICAgICAgIG9wdGlvbnMub25FeGl0Q29tcGxldGUgJiYgb3B0aW9ucy5vbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgaWYgKHJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgIHJlc3VtaW5nRnJvbS5vcHRpb25zLm9uRXhpdENvbXBsZXRlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtaW5nRnJvbS5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGUuaW5zdGFuY2UgJiYgbm9kZS5zY2hlZHVsZVJlbmRlcihmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbnkgbGVhZHMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCB0aGlzIHJlbmRlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWluZ1xuICAgICAqIHVzZWQgaW4gZnV0dXJlIGFuaW1hdGlvbnMgYW5kIHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzXG4gICAgICovXG4gICAgcmVtb3ZlTGVhZFNuYXBzaG90KCkge1xuICAgICAgICBpZiAodGhpcy5sZWFkICYmIHRoaXMubGVhZC5zbmFwc2hvdCkge1xuICAgICAgICAgICAgdGhpcy5sZWFkLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBOb2RlU3RhY2sgfTtcbiIsImZ1bmN0aW9uIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybShkZWx0YSwgdHJlZVNjYWxlLCBsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNsYXRpb25zIHdlIHVzZSB0byBjYWxjdWxhdGUgYXJlIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgKiBCdXQgd2hlbiB3ZSBhcHBseSBzY2FsZXMsIHdlIGFsc28gc2NhbGUgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgYW4gZWxlbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIEZvciBpbnN0YW5jZSBpZiB3ZSBoYXZlIGEgdHJlZVNjYWxlICh0aGUgY3VsbWluYXRpb24gb2YgYWxsIHBhcmVudCBzY2FsZXMpIG9mIDAuNSBhbmQgd2UgbmVlZFxuICAgICAqIHRvIG1vdmUgYW4gZWxlbWVudCAxMDAgcGl4ZWxzLCB3ZSBhY3R1YWxseSBuZWVkIHRvIG1vdmUgaXQgMjAwIGluIHdpdGhpbiB0aGF0IHNjYWxlZCBzcGFjZS5cbiAgICAgKi9cbiAgICBjb25zdCB4VHJhbnNsYXRlID0gZGVsdGEueC50cmFuc2xhdGUgLyB0cmVlU2NhbGUueDtcbiAgICBjb25zdCB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgICBjb25zdCB6VHJhbnNsYXRlID0gKGxhdGVzdFRyYW5zZm9ybSA9PT0gbnVsbCB8fCBsYXRlc3RUcmFuc2Zvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdGVzdFRyYW5zZm9ybS56KSB8fCAwO1xuICAgIGlmICh4VHJhbnNsYXRlIHx8IHlUcmFuc2xhdGUgfHwgelRyYW5zbGF0ZSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4VHJhbnNsYXRlfXB4LCAke3lUcmFuc2xhdGV9cHgsICR7elRyYW5zbGF0ZX1weCkgYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvbiBmb3IgdGhlIHRyZWUgdHJhbnNmb3JtLlxuICAgICAqIFRoaXMgd2lsbCBhcHBseSBzY2FsZSB0byB0aGUgc2NyZWVuLW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICBpZiAodHJlZVNjYWxlLnggIT09IDEgfHwgdHJlZVNjYWxlLnkgIT09IDEpIHtcbiAgICAgICAgdHJhbnNmb3JtICs9IGBzY2FsZSgkezEgLyB0cmVlU2NhbGUueH0sICR7MSAvIHRyZWVTY2FsZS55fSkgYDtcbiAgICB9XG4gICAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybVBlcnNwZWN0aXZlLCByb3RhdGUsIHJvdGF0ZVgsIHJvdGF0ZVksIHNrZXdYLCBza2V3WSB9ID0gbGF0ZXN0VHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtUGVyc3BlY3RpdmUpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBgcGVyc3BlY3RpdmUoJHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZX1weCkgJHt0cmFuc2Zvcm19YDtcbiAgICAgICAgaWYgKHJvdGF0ZSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlKCR7cm90YXRlfWRlZykgYDtcbiAgICAgICAgaWYgKHJvdGF0ZVgpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgYDtcbiAgICAgICAgaWYgKHJvdGF0ZVkpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVkoJHtyb3RhdGVZfWRlZykgYDtcbiAgICAgICAgaWYgKHNrZXdYKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGBza2V3WCgke3NrZXdYfWRlZykgYDtcbiAgICAgICAgaWYgKHNrZXdZKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGBza2V3WSgke3NrZXdZfWRlZykgYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgdG8gbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgdG8gdGhlIHNpemUgd2Ugd2FudCBpdC5cbiAgICAgKiBUaGlzIHdpbGwgYXBwbHkgc2NhbGUgdG8gdGhlIGVsZW1lbnQtb3JpZW50YXRlZCBheGVzLlxuICAgICAqL1xuICAgIGNvbnN0IGVsZW1lbnRTY2FsZVggPSBkZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgY29uc3QgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICBpZiAoZWxlbWVudFNjYWxlWCAhPT0gMSB8fCBlbGVtZW50U2NhbGVZICE9PSAxKSB7XG4gICAgICAgIHRyYW5zZm9ybSArPSBgc2NhbGUoJHtlbGVtZW50U2NhbGVYfSwgJHtlbGVtZW50U2NhbGVZfSlgO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtIHx8IFwibm9uZVwiO1xufVxuXG5leHBvcnQgeyBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0gfTtcbiIsImltcG9ydCB7IGdldFZhbHVlVHJhbnNpdGlvbiB9IGZyb20gJ21vdGlvbi1kb20nO1xuaW1wb3J0IHsgbm9vcCB9IGZyb20gJ21vdGlvbi11dGlscyc7XG5pbXBvcnQgeyBhbmltYXRlU2luZ2xlVmFsdWUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vYW5pbWF0ZS9zaW5nbGUtdmFsdWUubWpzJztcbmltcG9ydCB7IGdldE9wdGltaXNlZEFwcGVhcklkIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL29wdGltaXplZC1hcHBlYXIvZ2V0LWFwcGVhci1pZC5tanMnO1xuaW1wb3J0IHsgY2FuY2VsRnJhbWUsIGZyYW1lRGF0YSwgZnJhbWVTdGVwcywgZnJhbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcbmltcG9ydCB7IG1pY3JvdGFzayB9IGZyb20gJy4uLy4uL2ZyYW1lbG9vcC9taWNyb3Rhc2subWpzJztcbmltcG9ydCB7IHRpbWUgfSBmcm9tICcuLi8uLi9mcmFtZWxvb3Avc3luYy10aW1lLm1qcyc7XG5pbXBvcnQgeyBpc1NWR0VsZW1lbnQgfSBmcm9tICcuLi8uLi9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1lbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBGbGF0VHJlZSB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi4vLi4vdXRpbHMvY2xhbXAubWpzJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAnLi4vLi4vdXRpbHMvZGVsYXkubWpzJztcbmltcG9ydCB7IG1peE51bWJlciB9IGZyb20gJy4uLy4uL3V0aWxzL21peC9udW1iZXIubWpzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbk1hbmFnZXIgfSBmcm9tICcuLi8uLi91dGlscy9zdWJzY3JpcHRpb24tbWFuYWdlci5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvcmVzb2x2ZS1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IG1peFZhbHVlcyB9IGZyb20gJy4uL2FuaW1hdGlvbi9taXgtdmFsdWVzLm1qcyc7XG5pbXBvcnQgeyBjb3B5Qm94SW50bywgY29weUF4aXNEZWx0YUludG8gfSBmcm9tICcuLi9nZW9tZXRyeS9jb3B5Lm1qcyc7XG5pbXBvcnQgeyB0cmFuc2xhdGVBeGlzLCB0cmFuc2Zvcm1Cb3gsIGFwcGx5Qm94RGVsdGEsIGFwcGx5VHJlZURlbHRhcyB9IGZyb20gJy4uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qcyc7XG5pbXBvcnQgeyBjYWxjTGVuZ3RoLCBjYWxjUmVsYXRpdmVQb3NpdGlvbiwgY2FsY1JlbGF0aXZlQm94LCBjYWxjQm94RGVsdGEsIGlzTmVhciB9IGZyb20gJy4uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcbmltcG9ydCB7IHJlbW92ZUJveFRyYW5zZm9ybXMgfSBmcm9tICcuLi9nZW9tZXRyeS9kZWx0YS1yZW1vdmUubWpzJztcbmltcG9ydCB7IGNyZWF0ZUJveCwgY3JlYXRlRGVsdGEgfSBmcm9tICcuLi9nZW9tZXRyeS9tb2RlbHMubWpzJztcbmltcG9ydCB7IGJveEVxdWFsc1JvdW5kZWQsIGlzRGVsdGFaZXJvLCBheGlzRGVsdGFFcXVhbHMsIGFzcGVjdFJhdGlvLCBib3hFcXVhbHMgfSBmcm9tICcuLi9nZW9tZXRyeS91dGlscy5tanMnO1xuaW1wb3J0IHsgTm9kZVN0YWNrIH0gZnJvbSAnLi4vc2hhcmVkL3N0YWNrLm1qcyc7XG5pbXBvcnQgeyBzY2FsZUNvcnJlY3RvcnMgfSBmcm9tICcuLi9zdHlsZXMvc2NhbGUtY29ycmVjdGlvbi5tanMnO1xuaW1wb3J0IHsgYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtIH0gZnJvbSAnLi4vc3R5bGVzL3RyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgZWFjaEF4aXMgfSBmcm9tICcuLi91dGlscy9lYWNoLWF4aXMubWpzJztcbmltcG9ydCB7IGhhc1RyYW5zZm9ybSwgaGFzU2NhbGUsIGhhczJEVHJhbnNsYXRlIH0gZnJvbSAnLi4vdXRpbHMvaGFzLXRyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgZ2xvYmFsUHJvamVjdGlvblN0YXRlIH0gZnJvbSAnLi9zdGF0ZS5tanMnO1xuXG5jb25zdCBtZXRyaWNzID0ge1xuICAgIHR5cGU6IFwicHJvamVjdGlvbkZyYW1lXCIsXG4gICAgdG90YWxOb2RlczogMCxcbiAgICByZXNvbHZlZFRhcmdldERlbHRhczogMCxcbiAgICByZWNhbGN1bGF0ZWRQcm9qZWN0aW9uOiAwLFxufTtcbmNvbnN0IGlzRGVidWcgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5Nb3Rpb25EZWJ1ZyAhPT0gdW5kZWZpbmVkO1xuY29uc3QgdHJhbnNmb3JtQXhlcyA9IFtcIlwiLCBcIlhcIiwgXCJZXCIsIFwiWlwiXTtcbmNvbnN0IGhpZGRlblZpc2liaWxpdHkgPSB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfTtcbi8qKlxuICogV2UgdXNlIDEwMDAgYXMgdGhlIGFuaW1hdGlvbiB0YXJnZXQgYXMgMC0xMDAwIG1hcHMgYmV0dGVyIHRvIHBpeGVscyB0aGFuIDAtMVxuICogd2hpY2ggaGFzIGEgbm90aWNlYWJsZSBkaWZmZXJlbmNlIGluIHNwcmluZyBhbmltYXRpb25zXG4gKi9cbmNvbnN0IGFuaW1hdGlvblRhcmdldCA9IDEwMDA7XG5sZXQgaWQgPSAwO1xuZnVuY3Rpb24gcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKGtleSwgdmlzdWFsRWxlbWVudCwgdmFsdWVzLCBzaGFyZWRBbmltYXRpb25WYWx1ZXMpIHtcbiAgICBjb25zdCB7IGxhdGVzdFZhbHVlcyB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAvLyBSZWNvcmQgdGhlIGRpc3RvcnRpbmcgdHJhbnNmb3JtIGFuZCB0aGVuIHRlbXBvcmFyaWx5IHNldCBpdCB0byAwXG4gICAgaWYgKGxhdGVzdFZhbHVlc1trZXldKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0U3RhdGljVmFsdWUoa2V5LCAwKTtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvblZhbHVlcykge1xuICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uVmFsdWVzW2tleV0gPSAwO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2FuY2VsVHJlZU9wdGltaXNlZFRyYW5zZm9ybUFuaW1hdGlvbnMocHJvamVjdGlvbk5vZGUpIHtcbiAgICBwcm9qZWN0aW9uTm9kZS5oYXNDaGVja2VkT3B0aW1pc2VkQXBwZWFyID0gdHJ1ZTtcbiAgICBpZiAocHJvamVjdGlvbk5vZGUucm9vdCA9PT0gcHJvamVjdGlvbk5vZGUpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHByb2plY3Rpb25Ob2RlLm9wdGlvbnM7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgYXBwZWFySWQgPSBnZXRPcHRpbWlzZWRBcHBlYXJJZCh2aXN1YWxFbGVtZW50KTtcbiAgICBpZiAod2luZG93Lk1vdGlvbkhhc09wdGltaXNlZEFuaW1hdGlvbihhcHBlYXJJZCwgXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICAgICAgY29uc3QgeyBsYXlvdXQsIGxheW91dElkIH0gPSBwcm9qZWN0aW9uTm9kZS5vcHRpb25zO1xuICAgICAgICB3aW5kb3cuTW90aW9uQ2FuY2VsT3B0aW1pc2VkQW5pbWF0aW9uKGFwcGVhcklkLCBcInRyYW5zZm9ybVwiLCBmcmFtZSwgIShsYXlvdXQgfHwgbGF5b3V0SWQpKTtcbiAgICB9XG4gICAgY29uc3QgeyBwYXJlbnQgfSA9IHByb2plY3Rpb25Ob2RlO1xuICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5oYXNDaGVja2VkT3B0aW1pc2VkQXBwZWFyKSB7XG4gICAgICAgIGNhbmNlbFRyZWVPcHRpbWlzZWRUcmFuc2Zvcm1BbmltYXRpb25zKHBhcmVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUoeyBhdHRhY2hSZXNpemVMaXN0ZW5lciwgZGVmYXVsdFBhcmVudCwgbWVhc3VyZVNjcm9sbCwgY2hlY2tJc1Njcm9sbFJvb3QsIHJlc2V0VHJhbnNmb3JtLCB9KSB7XG4gICAgcmV0dXJuIGNsYXNzIFByb2plY3Rpb25Ob2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IobGF0ZXN0VmFsdWVzID0ge30sIHBhcmVudCA9IGRlZmF1bHRQYXJlbnQgPT09IG51bGwgfHwgZGVmYXVsdFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFBhcmVudCgpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgdW5pcXVlIElEIGdlbmVyYXRlZCBmb3IgZXZlcnkgcHJvamVjdGlvbiBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlkID0gaWQrKztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gaWQgdGhhdCByZXByZXNlbnRzIGEgdW5pcXVlIHNlc3Npb24gaW5zdGlnYXRlZCBieSBzdGFydFVwZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JZCA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgU2V0IGNvbnRhaW5pbmcgYWxsIHRoaXMgY29tcG9uZW50J3MgY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCB0byBpdGVyYXRlXG4gICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBUaGlzIGNvdWxkIGJlIGZhc3RlciB0byBpdGVyYXRlIGFzIGEgZmxhdCBhcnJheSBzdG9yZWQgb24gdGhlIHJvb3Qgbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3B0aW9ucyBmb3IgdGhlIG5vZGUuIFdlIHVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB3aGF0IGtpbmQgb2YgbGF5b3V0IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBwZXJmb3JtIChpZiBhbnkpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgdXNlIHRoaXMgdG8gZGV0ZWN0IHdoZW4gaXRzIHNhZmUgdG8gc2h1dCBkb3duIHBhcnQgb2YgYSBwcm9qZWN0aW9uIHRyZWUuXG4gICAgICAgICAgICAgKiBXZSBoYXZlIHRvIGtlZXAgcHJvamVjdGluZyBjaGlsZHJlbiBmb3Igc2NhbGUgY29ycmVjdGlvbiBhbmQgcmVsYXRpdmUgcHJvamVjdGlvblxuICAgICAgICAgICAgICogdW50aWwgYWxsIHRoZWlyIHBhcmVudHMgc3RvcCBwZXJmb3JtaW5nIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHdlIHRoaW5rIHRoaXMgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQuIFdlIGNhbid0IGFsd2F5cyBrbm93IHRoaXMsXG4gICAgICAgICAgICAgKiBjdXJyZW50bHkgd2Ugc2V0IGl0IHRvIHRydWUgZXZlcnkgdGltZSBhIGNvbXBvbmVudCByZW5kZXJzLCBvciBpZiBpdCBoYXMgYSBsYXlvdXREZXBlbmRlbmN5XG4gICAgICAgICAgICAgKiBpZiB0aGF0IGhhcyBjaGFuZ2VkIGJldHdlZW4gcmVuZGVycy4gQWRkaXRpb25hbGx5LCBjb21wb25lbnRzIGNhbiBiZSBncm91cGVkIGJ5IExheW91dEdyb3VwXG4gICAgICAgICAgICAgKiBhbmQgaWYgb25lIG5vZGUgaXMgZGlydGllZCwgdGhleSBhbGwgYXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHdlIHRoaW5rIHRoZSBwcm9qZWN0aW9uIGNhbGN1bGF0aW9ucyBmb3IgdGhpcyBub2RlIG5lZWRzXG4gICAgICAgICAgICAgKiByZWNhbGN1bGF0aW5nIGFzIGEgcmVzdWx0IG9mIGFuIHVwZGF0ZWQgdHJhbnNmb3JtIG9yIGxheW91dCBhbmltYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHRoZSBsYXlvdXQgKm9yKiB0cmFuc2Zvcm0gaGFzIGNoYW5nZWQuIFRoaXMgdGhlbiBnZXRzIHByb3BhZ2F0ZWRcbiAgICAgICAgICAgICAqIHRocm91Z2hvdXQgdGhlIHByb2plY3Rpb24gdHJlZSwgZm9yY2luZyBhbnkgZWxlbWVudCBiZWxvdyB0byByZWNhbGN1bGF0ZSBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRyYW5zZm9ybSBkaXJ0eS4gVGhpcyBnZXRzIHByb3BhZ2F0ZWQgdGhyb3VnaG91dCB0aGUgd2hvbGUgdHJlZSBidXQgaXMgb25seVxuICAgICAgICAgICAgICogcmVzcGVjdGVkIGJ5IHNoYXJlZCBub2Rlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1RyYW5zZm9ybURpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJsb2NrIGxheW91dCB1cGRhdGVzIGZvciBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9ucyB0aHJvdWdob3V0IHRoZSB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRvIHRydWUgYmV0d2VlbiB0aGUgc3RhcnQgb2YgdGhlIGZpcnN0IGB3aWxsVXBkYXRlYCBjYWxsIGFuZCB0aGUgZW5kIG9mIHRoZSBgZGlkVXBkYXRlYFxuICAgICAgICAgICAgICogY2FsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYW4gU1ZHIGVsZW1lbnQgd2UgY3VycmVudGx5IGRpc2FibGUgcHJvamVjdGlvbiB0cmFuc2Zvcm1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIChkdXJpbmcgcHJvbW90aW9uKSBpZiBhIG5vZGUgZG9pbmcgYW4gaW5zdGFudCBsYXlvdXQgdHJhbnNpdGlvbiBuZWVkcyB0byByZXNldFxuICAgICAgICAgICAgICogaXRzIHByb2plY3Rpb24gc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZ3Mgd2hldGhlciB0aGlzIG5vZGUgc2hvdWxkIGhhdmUgaXRzIHRyYW5zZm9ybSByZXNldCBwcmlvciB0byBtZWFzdXJpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmUgd2hldGhlciB0aGlzIG5vZGUgaGFzIGJlZW4gY2hlY2tlZCBmb3Igb3B0aW1pc2VkIGFwcGVhciBhbmltYXRpb25zLiBBc1xuICAgICAgICAgICAgICogZWZmZWN0cyBmaXJlIGJvdHRvbS11cCwgYW5kIHdlIHdhbnQgdG8gbG9vayB1cCB0aGUgdHJlZSBmb3IgYXBwZWFyIGFuaW1hdGlvbnMsXG4gICAgICAgICAgICAgKiB0aGlzIG1ha2VzIHN1cmUgd2Ugb25seSBjaGVjayBlYWNoIHBhdGggb25jZSwgc3RvcHBpbmcgYXQgbm9kZXMgdGhhdFxuICAgICAgICAgICAgICogaGF2ZSBhbHJlYWR5IGJlZW4gY2hlY2tlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5oYXNDaGVja2VkT3B0aW1pc2VkQXBwZWFyID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGNhbGN1bGF0ZWQgY29udGV4dHVhbC9hY2N1bXVsYXRlZC90cmVlIHNjYWxlLlxuICAgICAgICAgICAgICogVGhpcyB3aWxsIGJlIHVzZWQgdG8gc2NhbGUgY2FsY3VsY2F0ZWQgcHJvamVjdGlvbiB0cmFuc2Zvcm1zLCBhcyB0aGVzZSBhcmVcbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZWQgaW4gc2NyZWVuLXNwYWNlIGJ1dCBuZWVkIHRvIGJlIHNjYWxlZCBmb3IgZWxlbWVudHMgdG8gbGF5b3V0bHlcbiAgICAgICAgICAgICAqIG1ha2UgaXQgdG8gdGhlaXIgY2FsY3VsYXRlZCBkZXN0aW5hdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogTGF6eS1pbml0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlID0geyB4OiAxLCB5OiAxIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaGFzVHJlZUFuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBOb3RlOiBDdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSAoKSA9PiB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNoZWNrVXBkYXRlRmFpbGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGEgbXVsdGktc3RlcCBwcm9jZXNzIGFzIHNoYXJlZCBub2RlcyBtaWdodCBiZSBvZiBkaWZmZXJlbnQgZGVwdGhzLiBOb2Rlc1xuICAgICAgICAgICAgICogYXJlIHNvcnRlZCBieSBkZXB0aCBvcmRlciwgc28gd2UgbmVlZCB0byByZXNvbHZlIHRoZSBlbnRpcmUgdHJlZSBiZWZvcmUgbW92aW5nIHRvXG4gICAgICAgICAgICAgKiB0aGUgbmV4dCBzdGVwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVzZXQgZGVidWcgY291bnRzLiBNYW51YWxseSByZXNldHRpbmcgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXdcbiAgICAgICAgICAgICAgICAgKiBvYmplY3QgZWFjaCBmcmFtZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnRvdGFsTm9kZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5yZXNvbHZlZFRhcmdldERlbHRhcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5yZWNhbGN1bGF0ZWRQcm9qZWN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHByb3BhZ2F0ZURpcnR5Tm9kZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNvbHZlVGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjYWxjUHJvamVjdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFuRGlydHlOb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lk1vdGlvbkRlYnVnLnJlY29yZChtZXRyaWNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGcmFtZSBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNoYXJlZCBsYXlvdXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVE9ETyBPbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBwYXJlbnQgPyBwYXJlbnQucm9vdCB8fCBwYXJlbnQgOiB0aGlzO1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGFyZW50ID8gWy4uLnBhcmVudC5wYXRoLCBwYXJlbnRdIDogW107XG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoW2ldLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBGbGF0VHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzLnNldChuYW1lLCBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuZ2V0KG5hbWUpLmFkZChoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnlMaXN0ZW5lcnMobmFtZSwgLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uTWFuYWdlciA9IHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25NYW5hZ2VyICYmIHN1YnNjcmlwdGlvbk1hbmFnZXIubm90aWZ5KC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0xpc3RlbmVycyhuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTGlmZWN5Y2xlc1xuICAgICAgICAgKi9cbiAgICAgICAgbW91bnQoaW5zdGFuY2UsIGlzTGF5b3V0RGlydHkgPSB0aGlzLnJvb3QuaGFzVHJlZUFuaW1hdGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzU1ZHID0gaXNTVkdFbGVtZW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQsIGxheW91dCwgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgIXZpc3VhbEVsZW1lbnQuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIGlmIChpc0xheW91dERpcnR5ICYmIChsYXlvdXQgfHwgbGF5b3V0SWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRhY2hSZXNpemVMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIGxldCBjYW5jZWxEZWxheTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNpemVVbmJsb2NrVXBkYXRlID0gKCkgPT4gKHRoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYXR0YWNoUmVzaXplTGlzdGVuZXIoaW5zdGFuY2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbERlbGF5ICYmIGNhbmNlbERlbGF5KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbERlbGF5ID0gZGVsYXkocmVzaXplVW5ibG9ja1VwZGF0ZSwgMjUwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGZpbmlzaEFuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZWdpc3RlclNoYXJlZE5vZGUobGF5b3V0SWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSByZWdpc3RlciB0aGUgaGFuZGxlciBpZiBpdCByZXF1aXJlcyBsYXlvdXQgYW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIChsYXlvdXRJZCB8fCBsYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKFwiZGlkVXBkYXRlXCIsICh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkLCBoYXNSZWxhdGl2ZUxheW91dENoYW5nZWQsIGxheW91dDogbmV3TGF5b3V0LCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGhlcmUgaWYgYW4gYW5pbWF0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXlvdXRUcmFuc2l0aW9uID0gdGhpcy5vcHRpb25zLnRyYW5zaXRpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExheW91dFRyYW5zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25MYXlvdXRBbmltYXRpb25TdGFydCwgb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSwgfSA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZSB0YXJnZXQgbGF5b3V0IG9mIHRoZSBlbGVtZW50IG1pZ2h0IHN0YXkgdGhlIHNhbWUsXG4gICAgICAgICAgICAgICAgICAgICAqIGJ1dCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBoYXMgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc1RhcmdldENoYW5nZWQgPSAhdGhpcy50YXJnZXRMYXlvdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFib3hFcXVhbHNSb3VuZGVkKHRoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpO1xuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBOb3RlOiBEaXNhYmxlZCB0byBmaXggcmVsYXRpdmUgYW5pbWF0aW9ucyBhbHdheXMgdHJpZ2dlcmluZyBuZXdcbiAgICAgICAgICAgICAgICAgICAgICogbGF5b3V0IGFuaW1hdGlvbnMuIElmIHRoaXMgY2F1c2VzIGZ1cnRoZXIgaXNzdWVzLCB3ZSBjYW4gdHJ5XG4gICAgICAgICAgICAgICAgICAgICAqIGEgZGlmZmVyZW50IGFwcHJvYWNoIHRvIGRldGVjdGluZyByZWxhdGl2ZSB0YXJnZXQgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIC8vIHx8IGhhc1JlbGF0aXZlTGF5b3V0Q2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIGxheW91dCBoYXNuJ3Qgc2VlbWVkIHRvIGhhdmUgY2hhbmdlZCwgaXQgbWlnaHQgYmUgdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogZWxlbWVudCBpcyB2aXN1YWxseSBpbiB0aGUgc2FtZSBwbGFjZSBpbiB0aGUgZG9jdW1lbnQgYnV0IGl0cyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgKiByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGhhcyBpbmRlZWQgY2hhbmdlZC4gU28gaGVyZSB3ZSBjaGVjayBmb3IgdGhhdC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSAhaGFzTGF5b3V0Q2hhbmdlZCAmJiBoYXNSZWxhdGl2ZUxheW91dENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWVGcm9tIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoaGFzTGF5b3V0Q2hhbmdlZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChoYXNUYXJnZXRDaGFuZ2VkIHx8ICF0aGlzLmN1cnJlbnRBbmltYXRpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdGhpcy5yZXN1bWVGcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnJlc3VtaW5nRnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QW5pbWF0aW9uT3JpZ2luKGRlbHRhLCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZ2V0VmFsdWVUcmFuc2l0aW9uKGxheW91dFRyYW5zaXRpb24sIFwibGF5b3V0XCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUGxheTogb25MYXlvdXRBbmltYXRpb25TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNvbXBsZXRlOiBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sYXlvdXRSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy5kZWxheSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uT3B0aW9ucy50eXBlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKGFuaW1hdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBjaGFuZ2VkIGFuZCB3ZSBoYXZlIGFuIGFuaW1hdGlvbiB0aGF0IGhhc24ndCBzdGFydGVkIHlldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGZpbmlzaCBpdCBpbW1lZGlhdGVseS4gT3RoZXJ3aXNlIGl0IHdpbGwgYmUgYW5pbWF0aW5nIGZyb20gYSBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhhdCB3YXMgcHJvYmFibHkgbmV2ZXIgY29tbWl0ZWQgdG8gc2NyZWVuIGFuZCBsb29rIGxpa2UgYSBqdW1weSBib3guXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaEFuaW1hdGlvbih0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGVhZCgpICYmIHRoaXMub3B0aW9ucy5vbkV4aXRDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0TGF5b3V0ID0gbmV3TGF5b3V0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVubW91bnQoKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubGF5b3V0SWQgJiYgdGhpcy53aWxsVXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBzdGFjayAmJiBzdGFjay5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jaGlsZHJlbi5kZWxldGUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUodGhpcy51cGRhdGVQcm9qZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IG9uIHRoZSByb290XG4gICAgICAgIGJsb2NrVXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYW51YWxseUJsb2NrZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHVuYmxvY2tVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlzVXBkYXRlQmxvY2tlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCB8fCB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpc1RyZWVBbmltYXRpb25CbG9ja2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCB8fFxuICAgICAgICAgICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHx8XG4gICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBvbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgIHN0YXJ0VXBkYXRlKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGVCbG9ja2VkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMgJiYgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc2V0U2tld0FuZFJvdGF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSWQrKztcbiAgICAgICAgfVxuICAgICAgICBnZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHdpbGxVcGRhdGUoc2hvdWxkTm90aWZ5TGlzdGVuZXJzID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5yb290Lmhhc1RyZWVBbmltYXRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5yb290LmlzVXBkYXRlQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlICYmIHRoaXMub3B0aW9ucy5vbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgcnVubmluZyBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnMgdGhlbiB0aGVzZSBtdXN0IGJlXG4gICAgICAgICAgICAgKiBjYW5jZWxsZWQgYmVmb3JlIG1lYXN1cmluZyB0aGUgRE9NLiBUaGlzIGlzIHNvIHdlIGNhbiBtZWFzdXJlXG4gICAgICAgICAgICAgKiB0aGUgdHJ1ZSBsYXlvdXQgb2YgdGhlIGVsZW1lbnQgcmF0aGVyIHRoYW4gdGhlIFdBQVBJIGFuaW1hdGlvblxuICAgICAgICAgICAgICogd2hpY2ggd2lsbCBiZSB1bmFmZmVjdGVkIGJ5IHRoZSByZXNldFNrZXdBbmRSb3RhdGUgc3RlcC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlOiBUaGlzIGlzIGEgRE9NIHdyaXRlLiBXb3JzdCBjYXNlIHNjZW5hcmlvIGlzIHRoaXMgaXMgc2FuZHdpY2hlZFxuICAgICAgICAgICAgICogYmV0d2VlbiBvdGhlciBzbmFwc2hvdCByZWFkcyB3aGljaCB3aWxsIGNhdXNlIHVubmVjZXNzYXJ5IHN0eWxlIHJlY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgICogVGhpcyBoYXMgdG8gaGFwcGVuIGhlcmUgdGhvdWdoLCBhcyB3ZSBkb24ndCB5ZXQga25vdyB3aGljaCBub2RlcyB3aWxsIG5lZWRcbiAgICAgICAgICAgICAqIHNuYXBzaG90cyBpbiBzdGFydFVwZGF0ZSgpLCBidXQgd2Ugb25seSB3YW50IHRvIGNhbmNlbCBvcHRpbWlzZWQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICogaWYgYSBsYXlvdXQgYW5pbWF0aW9uIG1lYXN1cmVtZW50IGlzIGFjdHVhbGx5IGdvaW5nIHRvIGJlIGFmZmVjdGVkIGJ5IHRoZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh3aW5kb3cuTW90aW9uQ2FuY2VsT3B0aW1pc2VkQW5pbWF0aW9uICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaGFzQ2hlY2tlZE9wdGltaXNlZEFwcGVhcikge1xuICAgICAgICAgICAgICAgIGNhbmNlbFRyZWVPcHRpbWlzZWRUcmFuc2Zvcm1BbmltYXRpb25zKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIXRoaXMucm9vdC5pc1VwZGF0aW5nICYmIHRoaXMucm9vdC5zdGFydFVwZGF0ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMYXlvdXREaXJ0eSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIG5vZGUuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUudXBkYXRlU2Nyb2xsKFwic25hcHNob3RcIik7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5sYXlvdXRSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUud2lsbFVwZGF0ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAobGF5b3V0SWQgPT09IHVuZGVmaW5lZCAmJiAhbGF5b3V0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm1UZW1wbGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5wcmV2VHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh0aGlzLmxhdGVzdFZhbHVlcywgXCJcIilcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgIHNob3VsZE5vdGlmeUxpc3RlbmVycyAmJiB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIndpbGxVcGRhdGVcIik7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlKCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZVdhc0Jsb2NrZWQgPSB0aGlzLmlzVXBkYXRlQmxvY2tlZCgpO1xuICAgICAgICAgICAgLy8gV2hlbiBkb2luZyBhbiBpbnN0YW50IHRyYW5zaXRpb24sIHdlIHNraXAgdGhlIGxheW91dCB1cGRhdGUsXG4gICAgICAgICAgICAvLyBidXQgc2hvdWxkIHN0aWxsIGNsZWFuIHVwIHRoZSBtZWFzdXJlbWVudHMgc28gdGhhdCB0aGUgbmV4dFxuICAgICAgICAgICAgLy8gc25hcHNob3QgY291bGQgYmUgdGFrZW4gY29ycmVjdGx5LlxuICAgICAgICAgICAgaWYgKHVwZGF0ZVdhc0Jsb2NrZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmxvY2tVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyTWVhc3VyZW1lbnRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChjbGVhcklzTGF5b3V0RGlydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdyaXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChyZXNldFRyYW5zZm9ybVN0eWxlKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVhZCA9PT09PT09PT09PT09PT09PT1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gVXBkYXRlIGxheW91dCBtZWFzdXJlbWVudHMgb2YgdXBkYXRlZCBjaGlsZHJlblxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHVwZGF0ZUxheW91dCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdyaXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIE5vdGlmeSBsaXN0ZW5lcnMgdGhhdCB0aGUgbGF5b3V0IGlzIHVwZGF0ZWRcbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaChub3RpZnlMYXlvdXRVcGRhdGUpO1xuICAgICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYW51YWxseSBmbHVzaCBhbnkgcGVuZGluZyB1cGRhdGVzLiBJZGVhbGx5XG4gICAgICAgICAgICAgKiB3ZSBjb3VsZCBsZWF2ZSB0aGlzIHRvIHRoZSBmb2xsb3dpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGJ1dCB0aGlzIHNlZW1zXG4gICAgICAgICAgICAgKiB0byBsZWF2ZSBhIGZsYXNoIG9mIGluY29ycmVjdGx5IHN0eWxlZCBjb250ZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBub3cgPSB0aW1lLm5vdygpO1xuICAgICAgICAgICAgZnJhbWVEYXRhLmRlbHRhID0gY2xhbXAoMCwgMTAwMCAvIDYwLCBub3cgLSBmcmFtZURhdGEudGltZXN0YW1wKTtcbiAgICAgICAgICAgIGZyYW1lRGF0YS50aW1lc3RhbXAgPSBub3c7XG4gICAgICAgICAgICBmcmFtZURhdGEuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGZyYW1lU3RlcHMudXBkYXRlLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIGZyYW1lU3RlcHMucHJlUmVuZGVyLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIGZyYW1lU3RlcHMucmVuZGVyLnByb2Nlc3MoZnJhbWVEYXRhKTtcbiAgICAgICAgICAgIGZyYW1lRGF0YS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkaWRVcGRhdGUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudXBkYXRlU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1pY3JvdGFzay5yZWFkKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsZWFyQWxsU25hcHNob3RzKCkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFyU25hcHNob3QpO1xuICAgICAgICAgICAgdGhpcy5zaGFyZWROb2Rlcy5mb3JFYWNoKHJlbW92ZUxlYWRTbmFwc2hvdHMpO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5wcmVSZW5kZXIodGhpcy51cGRhdGVQcm9qZWN0aW9uLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVDaGVja0FmdGVyVW5tb3VudCgpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHVubW91bnRpbmcgbm9kZSBpcyBpbiBhIGxheW91dEdyb3VwIGFuZCBkaWQgdHJpZ2dlciBhIHdpbGxVcGRhdGUsXG4gICAgICAgICAgICAgKiB3ZSBtYW51YWxseSBjYWxsIGRpZFVwZGF0ZSB0byBnaXZlIGEgY2hhbmNlIHRvIHRoZSBzaWJsaW5ncyB0byBhbmltYXRlLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlLCBjbGVhbnVwIGFsbCBzbmFwc2hvdHMgdG8gcHJldmVudHMgZnV0dXJlIG5vZGVzIGZyb20gcmV1c2luZyB0aGVtLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5jaGVja1VwZGF0ZUZhaWxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgbWVhc3VyZW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICB1cGRhdGVTbmFwc2hvdCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNuYXBzaG90IHx8ICF0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNuYXBzaG90ICYmXG4gICAgICAgICAgICAgICAgIWNhbGNMZW5ndGgodGhpcy5zbmFwc2hvdC5tZWFzdXJlZEJveC54KSAmJlxuICAgICAgICAgICAgICAgICFjYWxjTGVuZ3RoKHRoaXMuc25hcHNob3QubWVhc3VyZWRCb3gueSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBzaG90ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUxheW91dCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBUT0RPOiBJbmNvcnBvcmF0ZSBpbnRvIGEgZm9yd2FyZGVkIHNjcm9sbCBvZmZzZXRcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWx3YXlzTWVhc3VyZUxheW91dCAmJiB0aGlzLmlzTGVhZCgpKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBub2RlIGlzIG1vdW50ZWQsIGl0IHNpbXBseSByZXN1bWVzIGZyb20gdGhlIHByZXZMZWFkJ3NcbiAgICAgICAgICAgICAqIHNuYXBzaG90IGluc3RlYWQgb2YgdGFraW5nIGEgbmV3IG9uZSwgYnV0IHRoZSBhbmNlc3RvcnMgc2Nyb2xsXG4gICAgICAgICAgICAgKiBtaWdodCBoYXZlIHVwZGF0ZWQgd2hpbGUgdGhlIHByZXZMZWFkIGlzIHVubW91bnRlZC4gV2UgbmVlZCB0b1xuICAgICAgICAgICAgICogdXBkYXRlIHRoZSBzY3JvbGwgYWdhaW4gdG8gbWFrZSBzdXJlIHRoZSBsYXlvdXQgd2UgbWVhc3VyZSBpc1xuICAgICAgICAgICAgICogdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSAmJiAhdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2TGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICAgICAgICB0aGlzLmxheW91dCA9IHRoaXMubWVhc3VyZShmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmxheW91dENvcnJlY3RlZCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwibWVhc3VyZVwiLCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJMYXlvdXRNZWFzdXJlXCIsIHRoaXMubGF5b3V0LmxheW91dEJveCwgcHJldkxheW91dCA/IHByZXZMYXlvdXQubGF5b3V0Qm94IDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVTY3JvbGwocGhhc2UgPSBcIm1lYXN1cmVcIikge1xuICAgICAgICAgICAgbGV0IG5lZWRzTWVhc3VyZW1lbnQgPSBCb29sZWFuKHRoaXMub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgdGhpcy5pbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbC5hbmltYXRpb25JZCA9PT0gdGhpcy5yb290LmFuaW1hdGlvbklkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwucGhhc2UgPT09IHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgbmVlZHNNZWFzdXJlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzTWVhc3VyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Jvb3QgPSBjaGVja0lzU2Nyb2xsUm9vdCh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSWQ6IHRoaXMucm9vdC5hbmltYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtZWFzdXJlU2Nyb2xsKHRoaXMuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICB3YXNSb290OiB0aGlzLnNjcm9sbCA/IHRoaXMuc2Nyb2xsLmlzUm9vdCA6IGlzUm9vdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgICAgICAgICAgaWYgKCFyZXNldFRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpc1Jlc2V0UmVxdWVzdGVkID0gdGhpcy5pc0xheW91dERpcnR5IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgaGFzUHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbkRlbHRhICYmICFpc0RlbHRhWmVybyh0aGlzLnByb2plY3Rpb25EZWx0YSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQgPSB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlICE9PSB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUmVzZXRSZXF1ZXN0ZWQgJiZcbiAgICAgICAgICAgICAgICAoaGFzUHJvamVjdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICByZXNldFRyYW5zZm9ybSh0aGlzLmluc3RhbmNlLCB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmUocmVtb3ZlVHJhbnNmb3JtID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcGFnZUJveCA9IHRoaXMubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgICAgICAgIGxldCBsYXlvdXRCb3ggPSB0aGlzLnJlbW92ZUVsZW1lbnRTY3JvbGwocGFnZUJveCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1lYXN1cmVtZW50cyB0YWtlbiBkdXJpbmcgdGhlIHByZS1yZW5kZXIgc3RhZ2VcbiAgICAgICAgICAgICAqIHN0aWxsIGhhdmUgdHJhbnNmb3JtcyBhcHBsaWVkIHNvIHdlIHJlbW92ZSB0aGVtXG4gICAgICAgICAgICAgKiB2aWEgY2FsY3VsYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZW1vdmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRCb3ggPSB0aGlzLnJlbW92ZVRyYW5zZm9ybShsYXlvdXRCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91bmRCb3gobGF5b3V0Qm94KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uSWQ6IHRoaXMucm9vdC5hbmltYXRpb25JZCxcbiAgICAgICAgICAgICAgICBtZWFzdXJlZEJveDogcGFnZUJveCxcbiAgICAgICAgICAgICAgICBsYXlvdXRCb3gsXG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzOiB7fSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmVQYWdlQm94KCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29uc3QgYm94ID0gdmlzdWFsRWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgICAgICAgICAgIGNvbnN0IHdhc0luU2Nyb2xsUm9vdCA9ICgoX2EgPSB0aGlzLnNjcm9sbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndhc1Jvb3QpIHx8IHRoaXMucGF0aC5zb21lKGNoZWNrTm9kZVdhc1Njcm9sbFJvb3QpO1xuICAgICAgICAgICAgaWYgKCF3YXNJblNjcm9sbFJvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdmlld3BvcnQgc2Nyb2xsIHRvIGdpdmUgcGFnZS1yZWxhdGl2ZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsIH0gPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC54LCBzY3JvbGwub2Zmc2V0LngpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC55LCBzY3JvbGwub2Zmc2V0LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlRWxlbWVudFNjcm9sbChib3gpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGJveFdpdGhvdXRTY3JvbGwgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRTY3JvbGwsIGJveCk7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5zY3JvbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YXNSb290KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcmZvcm1hbmNlIFRPRE86IEtlZXAgYSBjdW11bGF0aXZlIHNjcm9sbCBvZmZzZXQgZG93biB0aGUgdHJlZVxuICAgICAgICAgICAgICogcmF0aGVyIHRoYW4gbG9vcCBiYWNrIHVwIHRoZSBwYXRoLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JvbGwsIG9wdGlvbnMgfSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMucm9vdCAmJiBzY3JvbGwgJiYgb3B0aW9ucy5sYXlvdXRTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBuZXcgc2Nyb2xsIHJvb3QsIHdlIHdhbnQgdG8gcmVtb3ZlIGFsbCBwcmV2aW91cyBzY3JvbGxzXG4gICAgICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIHZpZXdwb3J0IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGwud2FzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgc2Nyb2xsLm9mZnNldC54KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIHNjcm9sbC5vZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm0oYm94LCB0cmFuc2Zvcm1Pbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byh3aXRoVHJhbnNmb3JtcywgYm94KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zZm9ybU9ubHkgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLnNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlICE9PSBub2RlLnJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtbm9kZS5zY3JvbGwub2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwub2Zmc2V0LnksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoVHJhbnNmb3JtcztcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2Zvcm0oYm94KSB7XG4gICAgICAgICAgICBjb25zdCBib3hXaXRob3V0VHJhbnNmb3JtID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0VHJhbnNmb3JtLCBib3gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBoYXNTY2FsZShub2RlLmxhdGVzdFZhbHVlcykgJiYgbm9kZS51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUJveCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlLm1lYXN1cmVQYWdlQm94KCk7XG4gICAgICAgICAgICAgICAgY29weUJveEludG8oc291cmNlQm94LCBub2RlQm94KTtcbiAgICAgICAgICAgICAgICByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveFdpdGhvdXRUcmFuc2Zvcm0sIG5vZGUubGF0ZXN0VmFsdWVzLCBub2RlLnNuYXBzaG90ID8gbm9kZS5zbmFwc2hvdC5sYXlvdXRCb3ggOiB1bmRlZmluZWQsIHNvdXJjZUJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGFyZ2V0RGVsdGEoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNyb3NzZmFkZTogb3B0aW9ucy5jcm9zc2ZhZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NmYWRlIDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJNZWFzdXJlbWVudHMoKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlUGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHBhcmVudCB0YXJnZXQgaXNuJ3QgdXAtdG8tZGF0ZSwgZm9yY2UgaXQgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICogVGhpcyBpcyBhbiB1bmZvcnR1bmF0ZSBkZS1vcHRpbWlzYXRpb24gYXMgaXQgbWVhbnMgYW55IHVwZGF0aW5nIHJlbGF0aXZlXG4gICAgICAgICAgICAgKiBwcm9qZWN0aW9uIHdpbGwgY2F1c2UgYWxsIHRoZSByZWxhdGl2ZSBwYXJlbnRzIHRvIHJlY2FsY3VsYXRlIGJhY2tcbiAgICAgICAgICAgICAqIHVwIHRoZSB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVBhcmVudC5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQgIT09XG4gICAgICAgICAgICAgICAgZnJhbWVEYXRhLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQucmVzb2x2ZVRhcmdldERlbHRhKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVUYXJnZXREZWx0YShmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPbmNlIHRoZSBkaXJ0eSBzdGF0dXMgb2Ygbm9kZXMgaGFzIGJlZW4gc3ByZWFkIHRocm91Z2ggdGhlIHRyZWUsIHdlIGFsc29cbiAgICAgICAgICAgICAqIG5lZWQgdG8gY2hlY2sgaWYgd2UgaGF2ZSBhIHNoYXJlZCBub2RlIG9mIGEgZGlmZmVyZW50IGRlcHRoIHRoYXQgaGFzIGl0c2VsZlxuICAgICAgICAgICAgICogYmVlbiBkaXJ0aWVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmlzUHJvamVjdGlvbkRpcnR5IHx8ICh0aGlzLmlzUHJvamVjdGlvbkRpcnR5ID0gbGVhZC5pc1Byb2plY3Rpb25EaXJ0eSk7XG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNmb3JtRGlydHkgfHwgKHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eSA9IGxlYWQuaXNUcmFuc2Zvcm1EaXJ0eSk7XG4gICAgICAgICAgICB0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IHx8ICh0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID0gbGVhZC5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSk7XG4gICAgICAgICAgICBjb25zdCBpc1NoYXJlZCA9IEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIGRvbid0IHVzZSB0cmFuc2Zvcm0gZm9yIHRoaXMgc3RlcCBvZiBwcm9jZXNzaW5nIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAgKiBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgYW55IG5vZGVzIGhhdmUgY2hhbmdlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGNhblNraXAgPSAhKGZvcmNlUmVjYWxjdWxhdGlvbiB8fFxuICAgICAgICAgICAgICAgIChpc1NoYXJlZCAmJiB0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgfHxcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Byb2plY3Rpb25EaXJ0eSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCB8fFxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUpO1xuICAgICAgICAgICAgaWYgKGNhblNraXApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQsIGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gbGF5b3V0LCB3ZSBjYW4ndCBwZXJmb3JtIHByb2plY3Rpb24sIHNvIGVhcmx5IHJldHVyblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCA9IGZyYW1lRGF0YS50aW1lc3RhbXA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGRvbid0IGhhdmUgYSB0YXJnZXREZWx0YSBidXQgZG8gaGF2ZSBhIGxheW91dCwgd2UgY2FuIGF0dGVtcHQgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICogYSByZWxhdGl2ZVBhcmVudC4gVGhpcyB3aWxsIGFsbG93IGEgY29tcG9uZW50IHRvIHBlcmZvcm0gc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICogZXZlbiBpZiBubyBhbmltYXRpb24gaGFzIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXREZWx0YSAmJiAhdGhpcy5yZWxhdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhcmVudC5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCByZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gcmVsYXRpdmUgdGFyZ2V0IG9yIG5vIHRhcmdldCBkZWx0YSBvdXIgdGFyZ2V0IGlzbid0IHZhbGlkXG4gICAgICAgICAgICAgKiBmb3IgdGhpcyBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmICF0aGlzLnRhcmdldERlbHRhKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGF6eS1pbml0IHRhcmdldCBkYXRhIHN0cnVjdHVyZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGdvdCBhIHJlbGF0aXZlIGJveCBmb3IgdGhpcyBjb21wb25lbnQsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldCByZWxhdGl2ZSB0byB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVCb3godGhpcy50YXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSd2ZSBvbmx5IGdvdCBhIHRhcmdldERlbHRhLCByZXNvbHZlIGl0IGludG8gYSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0RGVsdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnRhcmdldCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHlCb3hEZWx0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXREZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBubyB0YXJnZXQsIHVzZSBvd24gbGF5b3V0IGFzIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSd2ZSBiZWVuIHRvbGQgdG8gYXR0ZW1wdCB0byByZXNvbHZlIGEgcmVsYXRpdmUgdGFyZ2V0LCBkbyBzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhcmVudCA9IHRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihyZWxhdGl2ZVBhcmVudC5yZXN1bWluZ0Zyb20pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbGF0aXZlUGFyZW50Lm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGFyZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLnRhcmdldCwgcmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluY3JlYXNlIGRlYnVnIGNvdW50ZXIgZm9yIHJlc29sdmVkIHRhcmdldCBkZWx0YXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzLnJlc29sdmVkVGFyZ2V0RGVsdGFzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8XG4gICAgICAgICAgICAgICAgaGFzU2NhbGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSB8fFxuICAgICAgICAgICAgICAgIGhhczJEVHJhbnNsYXRlKHRoaXMucGFyZW50LmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzUHJvamVjdGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNQcm9qZWN0aW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMucmVsYXRpdmVUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheW91dFJvb3QpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGNQcm9qZWN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgY29uc3QgaXNTaGFyZWQgPSBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSB8fCB0aGlzICE9PSBsZWFkO1xuICAgICAgICAgICAgbGV0IGNhblNraXAgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbm9ybWFsIGxheW91dCBhbmltYXRpb24gYW5kIG5laXRoZXIgdGhpcyBub2RlIG5vciBpdHMgbmVhcmVzdCBwcm9qZWN0aW5nXG4gICAgICAgICAgICAgKiBpcyBkaXJ0eSB0aGVuIHdlIGNhbid0IHNraXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJvamVjdGlvbkRpcnR5IHx8ICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUHJvamVjdGlvbkRpcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhblNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIHNoYXJlZCBsYXlvdXQgYW5pbWF0aW9uIGFuZCB0aGlzIG5vZGUncyBzaGFyZWQgcHJvamVjdGlvbiBpcyBkaXJ0eSB0aGVuXG4gICAgICAgICAgICAgKiB3ZSBjYW4ndCBza2lwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNTaGFyZWQgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSB8fCB0aGlzLmlzVHJhbnNmb3JtRGlydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FuU2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHJlc29sdmVkIHRoZSB0YXJnZXQgdGhpcyBmcmFtZSB3ZSBtdXN0IHJlY2FsY3VsYXRlIHRoZVxuICAgICAgICAgICAgICogcHJvamVjdGlvbiB0byBlbnN1cmUgaXQgdmlzdWFsbHkgcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQgPT09IGZyYW1lRGF0YS50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBjYW5Ta2lwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuU2tpcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBzZWN0aW9uIG9mIHRoZSB0cmVlIGlzbid0IGFuaW1hdGluZyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGRlbGV0ZSBvdXIgdGFyZ2V0IHNvdXJjZXMgZm9yIHRoZSBmb2xsb3dpbmcgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gQm9vbGVhbigodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNUcmVlQW5pbWF0aW5nKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiB8fFxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUcmVlQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IHRoaXMucmVsYXRpdmVUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc2V0IHRoZSBjb3JyZWN0ZWQgYm94IHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBib3gsIGFzIHdlJ3JlIHRoZW4gZ29pbmdcbiAgICAgICAgICAgICAqIHRvIHBlcmZvcm0gbXV0YXRpdmUgb3BlcmF0aW9ucyBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29weUJveEludG8odGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29yZCBwcmV2aW91cyB0cmVlIHNjYWxlcyBiZWZvcmUgdXBkYXRpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlU2NhbGVYID0gdGhpcy50cmVlU2NhbGUueDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlU2NhbGVZID0gdGhpcy50cmVlU2NhbGUueTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgYWxsIHRoZSBwYXJlbnQgZGVsdGFzIHRvIHRoaXMgYm94IHRvIHByb2R1Y2UgdGhlIGNvcnJlY3RlZCBib3guIFRoaXNcbiAgICAgICAgICAgICAqIGlzIHRoZSBsYXlvdXQgYm94LCBhcyBpdCB3aWxsIGFwcGVhciBvbiBzY3JlZW4gYXMgYSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybXMgb2YgaXRzIHBhcmVudHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFwcGx5VHJlZURlbHRhcyh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy50cmVlU2NhbGUsIHRoaXMucGF0aCwgaXNTaGFyZWQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGxheWVyIG5lZWRzIHRvIHBlcmZvcm0gc2NhbGUgY29ycmVjdGlvbiBidXQgZG9lc24ndCBoYXZlIGEgdGFyZ2V0LFxuICAgICAgICAgICAgICogdXNlIHRoZSBsYXlvdXQgYXMgdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGxlYWQubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgIWxlYWQudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgKHRoaXMudHJlZVNjYWxlLnggIT09IDEgfHwgdGhpcy50cmVlU2NhbGUueSAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgICBsZWFkLnRhcmdldCA9IGxlYWQubGF5b3V0LmxheW91dEJveDtcbiAgICAgICAgICAgICAgICBsZWFkLnRhcmdldFdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gbGVhZDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldCB0byBwcm9qZWN0IGludG8sIGJ1dCB3ZSB3ZXJlIHByZXZpb3VzbHlcbiAgICAgICAgICAgICAgICAgKiBwcm9qZWN0aW5nLCB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgc3RvcmVkIHRyYW5zZm9ybSBhbmQgc2NoZWR1bGVcbiAgICAgICAgICAgICAgICAgKiBhIHJlbmRlciB0byBlbnN1cmUgdGhlIGVsZW1lbnRzIHJlZmxlY3QgdGhlIHJlbW92ZWQgdHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aW9uRGVsdGFzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSB8fCAhdGhpcy5wcmV2UHJvamVjdGlvbkRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aW9uRGVsdGFzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5QXhpc0RlbHRhSW50byh0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEueCwgdGhpcy5wcm9qZWN0aW9uRGVsdGEueCk7XG4gICAgICAgICAgICAgICAgY29weUF4aXNEZWx0YUludG8odGhpcy5wcmV2UHJvamVjdGlvbkRlbHRhLnksIHRoaXMucHJvamVjdGlvbkRlbHRhLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGNvcnJlY3RlZCBib3ggYW5kIHRoZSB0YXJnZXQgYm94IGJlZm9yZSB1c2VyLXNldCB0cmFuc2Zvcm1zIHdlcmUgYXBwbGllZC5cbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3RlZCBib3JkZXJSYWRpdXMgYW5kIGJveFNoYWRvdyB0byBjb21wZW5zYXRlXG4gICAgICAgICAgICAgKiBmb3Igb3VyIGxheW91dCByZXByb2plY3Rpb24sIGJ1dCBzdGlsbCBhbGxvdyB0aGVtIHRvIGJlIHNjYWxlZCBjb3JyZWN0bHkgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgKiBJdCBtaWdodCBiZSB0aGF0IHRvIHNpbXBsaWZ5IHRoaXMgd2UgbWF5IHdhbnQgdG8gYWNjZXB0IHRoYXQgdXNlci1zZXQgc2NhbGUgaXMgYWxzbyBjb3JyZWN0ZWRcbiAgICAgICAgICAgICAqIGFuZCB3ZSB3b3VsZG4ndCBoYXZlIHRvIGtlZXAgYW5kIGNhbGMgYm90aCBkZWx0YXMsIE9SIHdlIGNvdWxkIHN1cHBvcnQgYSB1c2VyIHNldHRpbmdcbiAgICAgICAgICAgICAqIHRvIGFsbG93IHBlb3BsZSB0byBjaG9vc2Ugd2hldGhlciB0aGVzZSBzdHlsZXMgYXJlIGNvcnJlY3RlZCBiYXNlZCBvbiBqdXN0IHRoZVxuICAgICAgICAgICAgICogbGF5b3V0IHJlcHJvamVjdGlvbiBvciB0aGUgZmluYWwgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXQsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVTY2FsZS54ICE9PSBwcmV2VHJlZVNjYWxlWCB8fFxuICAgICAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlLnkgIT09IHByZXZUcmVlU2NhbGVZIHx8XG4gICAgICAgICAgICAgICAgIWF4aXNEZWx0YUVxdWFscyh0aGlzLnByb2plY3Rpb25EZWx0YS54LCB0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEueCkgfHxcbiAgICAgICAgICAgICAgICAhYXhpc0RlbHRhRXF1YWxzKHRoaXMucHJvamVjdGlvbkRlbHRhLnksIHRoaXMucHJldlByb2plY3Rpb25EZWx0YS55KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJwcm9qZWN0aW9uVXBkYXRlXCIsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluY3JlYXNlIGRlYnVnIGNvdW50ZXIgZm9yIHJlY2FsY3VsYXRlZCBwcm9qZWN0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MucmVjYWxjdWxhdGVkUHJvamVjdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogU2NoZWR1bGUgcmVuZGVyXG4gICAgICAgIH1cbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFNjaGVkdWxlIHJlbmRlclxuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlUmVuZGVyKG5vdGlmeUFsbCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIGlmIChub3RpZnlBbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgICAgICBzdGFjayAmJiBzdGFjay5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tICYmICF0aGlzLnJlc3VtaW5nRnJvbS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZVByb2plY3Rpb25EZWx0YXMoKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RMYXRlc3RWYWx1ZXMgPSBzbmFwc2hvdFxuICAgICAgICAgICAgICAgID8gc25hcHNob3QubGF0ZXN0VmFsdWVzXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IG1peGVkVmFsdWVzID0geyAuLi50aGlzLmxhdGVzdFZhbHVlcyB9O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlUGFyZW50IHx8XG4gICAgICAgICAgICAgICAgIXRoaXMucmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRSb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9ICFoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90U291cmNlID0gc25hcHNob3QgPyBzbmFwc2hvdC5zb3VyY2UgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRTb3VyY2UgPSB0aGlzLmxheW91dCA/IHRoaXMubGF5b3V0LnNvdXJjZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uID0gc25hcHNob3RTb3VyY2UgIT09IGxheW91dFNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgY29uc3QgaXNPbmx5TWVtYmVyID0gIXN0YWNrIHx8IHN0YWNrLm1lbWJlcnMubGVuZ3RoIDw9IDE7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5ID0gQm9vbGVhbihpc1NoYXJlZExheW91dEFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgICAgICFpc09ubHlNZW1iZXIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY3Jvc3NmYWRlID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucGF0aC5zb21lKGhhc09wYWNpdHlDcm9zc2ZhZGUpKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgbGV0IHByZXZSZWxhdGl2ZVRhcmdldDtcbiAgICAgICAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEgPSAobGF0ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBsYXRlc3QgLyAxMDAwO1xuICAgICAgICAgICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS54LCBkZWx0YS54LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLnksIGRlbHRhLnksIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRhcmdldERlbHRhKHRhcmdldERlbHRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIHRoaXMubGF5b3V0LmxheW91dEJveCwgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgbWl4Qm94KHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHJlbGF0aXZlTGF5b3V0LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGFuIHVuY2hhbmdlZCByZWxhdGl2ZSB0YXJnZXQgd2UgY2FuIGNvbnNpZGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBwcm9qZWN0aW9uIG5vdCBkaXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UmVsYXRpdmVUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveEVxdWFscyh0aGlzLnJlbGF0aXZlVGFyZ2V0LCBwcmV2UmVsYXRpdmVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJvamVjdGlvbkRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2UmVsYXRpdmVUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2UmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8ocHJldlJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzID0gbWl4ZWRWYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIG1peFZhbHVlcyhtaXhlZFZhbHVlcywgc25hcHNob3RMYXRlc3RWYWx1ZXMsIHRoaXMubGF0ZXN0VmFsdWVzLCBwcm9ncmVzcywgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSwgaXNPbmx5TWVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSh0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCA/IDEwMDAgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydEFuaW1hdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvblN0YXJ0XCIpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uICYmIHRoaXMuY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNhbmNlbEZyYW1lKHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uIGluIHRoZSBuZXh0IGZyYW1lIHRvIGhhdmUgYSBmcmFtZSB3aXRoIHByb2dyZXNzIDAsXG4gICAgICAgICAgICAgKiB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydGVkLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIGNvcnJlY3RseSBmb3IgaW5zdGFudCB0cmFuc2l0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gZnJhbWUudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZVNpbmdsZVZhbHVlKDAsIGFuaW1hdGlvblRhcmdldCwge1xuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZTogKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YShsYXRlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZSAmJiBvcHRpb25zLm9uVXBkYXRlKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVBbmltYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgc3RhY2sgJiYgc3RhY2suZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25Db21wbGV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hBbmltYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSAmJiB0aGlzLm1peFRhcmdldERlbHRhKGFuaW1hdGlvblRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIGxldCB7IHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQsIGxheW91dCwgbGF0ZXN0VmFsdWVzIH0gPSBsZWFkO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRXaXRoVHJhbnNmb3JtcyB8fCAhdGFyZ2V0IHx8ICFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBvbmx5IGFuaW1hdGluZyBwb3NpdGlvbiwgYW5kIHRoaXMgZWxlbWVudCBpc24ndCB0aGUgbGVhZCBlbGVtZW50LFxuICAgICAgICAgICAgICogdGhlbiBpbnN0ZWFkIG9mIHByb2plY3RpbmcgaW50byB0aGUgbGVhZCBib3ggd2UgaW5zdGVhZCB3YW50IHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICogYSBuZXcgdGFyZ2V0IHRoYXQgYWxpZ25zIHRoZSB0d28gYm94ZXMgYnV0IG1haW50YWlucyB0aGUgbGF5b3V0IHNoYXBlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcyAhPT0gbGVhZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgbGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uVHlwZSwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCBsYXlvdXQubGF5b3V0Qm94KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhMZW5ndGggPSBjYWxjTGVuZ3RoKHRoaXMubGF5b3V0LmxheW91dEJveC54KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueC5taW4gPSBsZWFkLnRhcmdldC54Lm1pbjtcbiAgICAgICAgICAgICAgICB0YXJnZXQueC5tYXggPSB0YXJnZXQueC5taW4gKyB4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlMZW5ndGggPSBjYWxjTGVuZ3RoKHRoaXMubGF5b3V0LmxheW91dEJveC55KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueS5taW4gPSBsZWFkLnRhcmdldC55Lm1pbjtcbiAgICAgICAgICAgICAgICB0YXJnZXQueS5tYXggPSB0YXJnZXQueS5taW4gKyB5TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weUJveEludG8odGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGx5IHRoZSBsYXRlc3QgdXNlci1zZXQgdHJhbnNmb3JtcyB0byB0aGUgdGFyZ2V0Qm94IHRvIHByb2R1Y2UgdGhlIHRhcmdldEJveEZpbmFsLlxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgZmluYWwgYm94IHRoYXQgd2Ugd2lsbCB0aGVuIHByb2plY3QgaW50byBieSBjYWxjdWxhdGluZyBhIHRyYW5zZm9ybSBkZWx0YSBhbmRcbiAgICAgICAgICAgICAqIGFwcGx5aW5nIGl0IHRvIHRoZSBjb3JyZWN0ZWQgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3godGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIGZpbmFsIHRhcmdldCBib3gsIGFmdGVyXG4gICAgICAgICAgICAgKiB1c2VyLXNldCB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGlzIHdpbGwgYmUgdXNlZCBieSB0aGUgcmVuZGVyZXIgdG9cbiAgICAgICAgICAgICAqIGNyZWF0ZSBhIHRyYW5zZm9ybSBzdHlsZSB0aGF0IHdpbGwgcmVwcm9qZWN0IHRoZSBlbGVtZW50IGZyb20gaXRzIGxheW91dCBsYXlvdXRcbiAgICAgICAgICAgICAqIGludG8gdGhlIGRlc2lyZWQgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXJTaGFyZWROb2RlKGxheW91dElkLCBub2RlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVkTm9kZXMuaGFzKGxheW91dElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMuc2V0KGxheW91dElkLCBuZXcgTm9kZVN0YWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgICAgICBzdGFjay5hZGQobm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBub2RlLm9wdGlvbnMuaW5pdGlhbFByb21vdGlvbkNvbmZpZztcbiAgICAgICAgICAgIG5vZGUucHJvbW90ZSh7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogY29uZmlnID8gY29uZmlnLnRyYW5zaXRpb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVGb2xsb3dPcGFjaXR5OiBjb25maWcgJiYgY29uZmlnLnNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICA/IGNvbmZpZy5zaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHkobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xlYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjayA/IHN0YWNrLmxlYWQgPT09IHRoaXMgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGdldExlYWQoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0SWQgPyAoKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVhZCkgfHwgdGhpcyA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UHJldkxlYWQoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0SWQgPyAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2TGVhZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTdGFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbW90ZSh7IG5lZWRzUmVzZXQsIHRyYW5zaXRpb24sIHByZXNlcnZlRm9sbG93T3BhY2l0eSwgfSA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIGlmIChzdGFjaylcbiAgICAgICAgICAgICAgICBzdGFjay5wcm9tb3RlKHRoaXMsIHByZXNlcnZlRm9sbG93T3BhY2l0eSk7XG4gICAgICAgICAgICBpZiAobmVlZHNSZXNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoeyB0cmFuc2l0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVnYXRlKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2sucmVsZWdhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRTa2V3QW5kUm90YXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGRldGVjdGVkIHNrZXcgb3Igcm90YXRpb24gdmFsdWVzLCB3ZSBjYW4gZWFybHkgcmV0dXJuIHdpdGhvdXQgYSBmb3JjZWQgcmVuZGVyLlxuICAgICAgICAgICAgbGV0IGhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gdW5yb2xsZWQgY2hlY2sgZm9yIHJvdGF0aW9uIHZhbHVlcy4gTW9zdCBlbGVtZW50cyBkb24ndCBoYXZlIGFueSByb3RhdGlvbiBhbmRcbiAgICAgICAgICAgICAqIHNraXBwaW5nIHRoZSBuZXN0ZWQgbG9vcCBhbmQgbmV3IG9iamVjdCBjcmVhdGlvbiBpcyA1MCUgZmFzdGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB7IGxhdGVzdFZhbHVlcyB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXMueiB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5yb3RhdGUgfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMucm90YXRlWCB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5yb3RhdGVZIHx8XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzLnJvdGF0ZVogfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMuc2tld1ggfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMuc2tld1kpIHtcbiAgICAgICAgICAgICAgICBoYXNEaXN0b3J0aW5nVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZGlzdG9ydGluZyB2YWx1ZXMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IG1vcmUuXG4gICAgICAgICAgICBpZiAoIWhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXMueikge1xuICAgICAgICAgICAgICAgIHJlc2V0RGlzdG9ydGluZ1RyYW5zZm9ybShcInpcIiwgdmlzdWFsRWxlbWVudCwgcmVzZXRWYWx1ZXMsIHRoaXMuYW5pbWF0aW9uVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBza2V3IGFuZCByb3RhdGUgdmFsdWUgb2YgYWxsIGF4ZXMgYW5kIHJlc2V0IHRvIDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc2V0RGlzdG9ydGluZ1RyYW5zZm9ybShgcm90YXRlJHt0cmFuc2Zvcm1BeGVzW2ldfWAsIHZpc3VhbEVsZW1lbnQsIHJlc2V0VmFsdWVzLCB0aGlzLmFuaW1hdGlvblZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKGBza2V3JHt0cmFuc2Zvcm1BeGVzW2ldfWAsIHZpc3VhbEVsZW1lbnQsIHJlc2V0VmFsdWVzLCB0aGlzLmFuaW1hdGlvblZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3JjZSBhIHJlbmRlciBvZiB0aGlzIGVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB3aXRoIGFsbCBza2V3cyBhbmQgcm90YXRpb25zXG4gICAgICAgICAgICAvLyBzZXQgdG8gMC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICAgICAgICAvLyBQdXQgYmFjayBhbGwgdGhlIHZhbHVlcyB3ZSByZXNldFxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgcmVzZXRWYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzW2tleV0gPSByZXNldFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbmV4dCBmcmFtZS4gVGhpcyBlbnN1cmVzIHdlIHdvbid0IHZpc3VhbGx5XG4gICAgICAgICAgICAvLyBzZWUgdGhlIGVsZW1lbnQgd2l0aCB0aGUgcmVzZXQgcm90YXRlIHZhbHVlIGFwcGxpZWQuXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3ApIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgdGhpcy5pc1NWRylcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRkZW5WaXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSB0aGlzLmdldFRyYW5zZm9ybVRlbXBsYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcCA9PT0gbnVsbCB8fCBzdHlsZVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLmxheW91dCB8fCAhbGVhZC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eVN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5U3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcCA9PT0gbnVsbCB8fCBzdHlsZVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNQcm9qZWN0ZWQgJiYgIWhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlTdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNUb1JlbmRlciA9IGxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IGxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpO1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMudHJlZVNjYWxlLCB2YWx1ZXNUb1JlbmRlcik7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUodmFsdWVzVG9SZW5kZXIsIHN0eWxlcy50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm1PcmlnaW4gPSBgJHt4Lm9yaWdpbiAqIDEwMH0lICR7eS5vcmlnaW4gKiAxMDB9JSAwYDtcbiAgICAgICAgICAgIGlmIChsZWFkLmFuaW1hdGlvblZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBsZWFkIGNvbXBvbmVudCBpcyBhbmltYXRpbmcsIGFzc2lnbiB0aGlzIGVpdGhlciB0aGUgZW50ZXJpbmcvbGVhdmluZ1xuICAgICAgICAgICAgICAgICAqIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9iID0gKF9hID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByZXNlcnZlT3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBPciB3ZSdyZSBub3QgYW5pbWF0aW5nIGF0IGFsbCwgc2V0IHRoZSBsZWFkIGNvbXBvbmVudCB0byBpdHMgbGF5b3V0XG4gICAgICAgICAgICAgICAgICogb3BhY2l0eSBhbmQgb3RoZXIgY29tcG9uZW50cyB0byBoaWRkZW4uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPVxuICAgICAgICAgICAgICAgICAgICBsZWFkID09PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2FsZUNvcnJlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzVG9SZW5kZXJba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvcnJlY3QsIGFwcGx5VG8sIGlzQ1NTVmFyaWFibGUgfSA9IHNjYWxlQ29ycmVjdG9yc1trZXldO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9ubHkgYXBwbHkgc2NhbGUgY29ycmVjdGlvbiB0byB0aGUgdmFsdWUgaWYgd2UgaGF2ZSBhblxuICAgICAgICAgICAgICAgICAqIGFjdGl2ZSBwcm9qZWN0aW9uIHRyYW5zZm9ybS4gT3RoZXJ3aXNlIHRoZXNlIHZhbHVlcyBiZWNvbWVcbiAgICAgICAgICAgICAgICAgKiB2dWxuZXJhYmxlIHRvIGRpc3RvcnRpb24gaWYgdGhlIGVsZW1lbnQgY2hhbmdlcyBzaXplIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgKiBhIGNvcnJlc3BvbmRpbmcgbGF5b3V0IGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWQgPSBzdHlsZXMudHJhbnNmb3JtID09PSBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlc1RvUmVuZGVyW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiBjb3JyZWN0KHZhbHVlc1RvUmVuZGVyW2tleV0sIGxlYWQpO1xuICAgICAgICAgICAgICAgIGlmIChhcHBseVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IGFwcGx5VG8ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbYXBwbHlUb1tpXV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBDU1MgdmFyaWFibGUsIHNldCBpdCBkaXJlY3RseSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2luZyB0aGlzIGZ1bmN0aW9uIGZyb20gY3JlYXRpbmcgc3R5bGVzIHRvIHNldHRpbmcgdGhlbVxuICAgICAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSBhIGdvb2QgcGxhY2UgdG8gcmVtb3ZlIHBlciBmcmFtZSBvYmplY3QgY3JlYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ1NTVmFyaWFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50LnJlbmRlclN0YXRlLnZhcnNba2V5XSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1trZXldID0gY29ycmVjdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNhYmxlIHBvaW50ZXIgZXZlbnRzIG9uIGZvbGxvdyBjb21wb25lbnRzLiBUaGlzIGlzIHRvIGVuc3VyZVxuICAgICAgICAgICAgICogdGhhdCBpZiBhIGZvbGxvdyBjb21wb25lbnQgY292ZXJzIGEgbGVhZCBjb21wb25lbnQgaXQgZG9lc24ndCBibG9ja1xuICAgICAgICAgICAgICogcG9pbnRlciBldmVudHMgb24gdGhlIGxlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMucG9pbnRlckV2ZW50cyA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcCA9PT0gbnVsbCB8fCBzdHlsZVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgfVxuICAgICAgICBjbGVhclNuYXBzaG90KCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVGcm9tID0gdGhpcy5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHJ1biBvbiByb290XG4gICAgICAgIHJlc2V0VHJlZSgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG5vZGUuY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1cGRhdGVMYXlvdXQobm9kZSkge1xuICAgIG5vZGUudXBkYXRlTGF5b3V0KCk7XG59XG5mdW5jdGlvbiBub3RpZnlMYXlvdXRVcGRhdGUobm9kZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzbmFwc2hvdCA9ICgoX2EgPSBub2RlLnJlc3VtZUZyb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbmFwc2hvdCkgfHwgbm9kZS5zbmFwc2hvdDtcbiAgICBpZiAobm9kZS5pc0xlYWQoKSAmJlxuICAgICAgICBub2RlLmxheW91dCAmJlxuICAgICAgICBzbmFwc2hvdCAmJlxuICAgICAgICBub2RlLmhhc0xpc3RlbmVycyhcImRpZFVwZGF0ZVwiKSkge1xuICAgICAgICBjb25zdCB7IGxheW91dEJveDogbGF5b3V0LCBtZWFzdXJlZEJveDogbWVhc3VyZWRMYXlvdXQgfSA9IG5vZGUubGF5b3V0O1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvblR5cGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNTaGFyZWQgPSBzbmFwc2hvdC5zb3VyY2UgIT09IG5vZGUubGF5b3V0LnNvdXJjZTtcbiAgICAgICAgLy8gVE9ETyBNYXliZSB3ZSB3YW50IHRvIGFsc28gcmVzaXplIHRoZSBsYXlvdXQgc25hcHNob3Qgc28gd2UgZG9uJ3QgdHJpZ2dlclxuICAgICAgICAvLyBhbmltYXRpb25zIGZvciBpbnN0YW5jZSBpZiBsYXlvdXQ9XCJzaXplXCIgYW5kIGFuIGVsZW1lbnQgaGFzIG9ubHkgY2hhbmdlZCBwb3NpdGlvblxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJzaXplXCIpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc1NuYXBzaG90ID0gaXNTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5tZWFzdXJlZEJveFtheGlzXVxuICAgICAgICAgICAgICAgICAgICA6IHNuYXBzaG90LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKGF4aXNTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1pbiA9IGxheW91dFtheGlzXS5taW47XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5KGFuaW1hdGlvblR5cGUsIHNuYXBzaG90LmxheW91dEJveCwgbGF5b3V0KSkge1xuICAgICAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBheGlzU25hcHNob3QgPSBpc1NoYXJlZFxuICAgICAgICAgICAgICAgICAgICA/IHNuYXBzaG90Lm1lYXN1cmVkQm94W2F4aXNdXG4gICAgICAgICAgICAgICAgICAgIDogc25hcHNob3QubGF5b3V0Qm94W2F4aXNdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGNhbGNMZW5ndGgobGF5b3V0W2F4aXNdKTtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbnN1cmUgcmVsYXRpdmUgdGFyZ2V0IGdldHMgcmVzaXplZCBhbmQgcmVyZW5kZXJlcmRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5yZWxhdGl2ZVRhcmdldCAmJiAhbm9kZS5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlVGFyZ2V0W2F4aXNdLm1heCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlVGFyZ2V0W2F4aXNdLm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXlvdXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIGNhbGNCb3hEZWx0YShsYXlvdXREZWx0YSwgbGF5b3V0LCBzbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgICAgICBjb25zdCB2aXN1YWxEZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIGlmIChpc1NoYXJlZCkge1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBub2RlLmFwcGx5VHJhbnNmb3JtKG1lYXN1cmVkTGF5b3V0LCB0cnVlKSwgc25hcHNob3QubWVhc3VyZWRCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBsYXlvdXQsIHNuYXBzaG90LmxheW91dEJveCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzTGF5b3V0Q2hhbmdlZCA9ICFpc0RlbHRhWmVybyhsYXlvdXREZWx0YSk7XG4gICAgICAgIGxldCBoYXNSZWxhdGl2ZUxheW91dENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFub2RlLnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gbm9kZS5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgcmVsYXRpdmVQYXJlbnQgaXMgaXRzZWxmIHJlc3VtaW5nIGZyb20gYSBkaWZmZXJlbnQgZWxlbWVudCB0aGVuXG4gICAgICAgICAgICAgKiB0aGUgcmVsYXRpdmUgc25hcHNob3QgaXMgbm90IHJlbGF2ZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJiAhcmVsYXRpdmVQYXJlbnQucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc25hcHNob3Q6IHBhcmVudFNuYXBzaG90LCBsYXlvdXQ6IHBhcmVudExheW91dCB9ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNuYXBzaG90ICYmIHBhcmVudExheW91dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVNuYXBzaG90ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlU25hcHNob3QsIHNuYXBzaG90LmxheW91dEJveCwgcGFyZW50U25hcHNob3QubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIGxheW91dCwgcGFyZW50TGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYm94RXF1YWxzUm91bmRlZChyZWxhdGl2ZVNuYXBzaG90LCByZWxhdGl2ZUxheW91dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlbGF0aXZlTGF5b3V0Q2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGFyZW50Lm9wdGlvbnMubGF5b3V0Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVRhcmdldCA9IHJlbGF0aXZlTGF5b3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IHJlbGF0aXZlU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5ub3RpZnlMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIiwge1xuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICBkZWx0YTogdmlzdWFsRGVsdGEsXG4gICAgICAgICAgICBsYXlvdXREZWx0YSxcbiAgICAgICAgICAgIGhhc0xheW91dENoYW5nZWQsXG4gICAgICAgICAgICBoYXNSZWxhdGl2ZUxheW91dENoYW5nZWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLmlzTGVhZCgpKSB7XG4gICAgICAgIGNvbnN0IHsgb25FeGl0Q29tcGxldGUgfSA9IG5vZGUub3B0aW9ucztcbiAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJpbmcgdHJhbnNpdGlvblxuICAgICAqIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIHRyYW5zaXRpb24gaXMgYmVpbmcgcGFzc2VkIGluIGFzIHt0eXBlOiBmYWxzZSB9IGZyb20gRnJhbWVyXG4gICAgICogYW5kIHdoeSB3ZSBuZWVkIGl0IGF0IGFsbFxuICAgICAqL1xuICAgIG5vZGUub3B0aW9ucy50cmFuc2l0aW9uID0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcHJvcGFnYXRlRGlydHlOb2Rlcyhub2RlKSB7XG4gICAgLyoqXG4gICAgICogSW5jcmVhc2UgZGVidWcgY291bnRlciBmb3Igbm9kZXMgZW5jb3VudGVyZWQgdGhpcyBmcmFtZVxuICAgICAqL1xuICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgIG1ldHJpY3MudG90YWxOb2RlcysrO1xuICAgIH1cbiAgICBpZiAoIW5vZGUucGFyZW50KVxuICAgICAgICByZXR1cm47XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBub2RlIGlzbid0IHByb2plY3RpbmcsIHByb3BhZ2F0ZSBpc1Byb2plY3Rpb25EaXJ0eS4gSXQgd2lsbCBoYXZlXG4gICAgICogbm8gcGVyZm9ybWFuY2UgaW1wYWN0IGJ1dCBpdCB3aWxsIGFsbG93IHRoZSBuZXh0IGNoaWxkIHRoYXQgKmlzKiBwcm9qZWN0aW5nXG4gICAgICogYnV0ICppc24ndCogZGlydHkgdG8ganVzdCBjaGVjayBpdHMgcGFyZW50IHRvIHNlZSBpZiAqYW55KiBhbmNlc3RvciBuZWVkc1xuICAgICAqIGNvcnJlY3RpbmcuXG4gICAgICovXG4gICAgaWYgKCFub2RlLmlzUHJvamVjdGluZygpKSB7XG4gICAgICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPSBub2RlLnBhcmVudC5pc1Byb2plY3Rpb25EaXJ0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvcGFnYXRlIGlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IGFuZCBpc1RyYW5zZm9ybURpcnR5XG4gICAgICogdGhyb3VnaG91dCB0aGUgd2hvbGUgdHJlZS4gQSBmdXR1cmUgcmV2aXNpb24gY2FuIHRha2UgYW5vdGhlciBsb29rIGF0XG4gICAgICogdGhpcyBidXQgZm9yIHNhZmV0eSB3ZSBzdGlsbCByZWNhbGN1YWx0ZSBzaGFyZWQgbm9kZXMuXG4gICAgICovXG4gICAgbm9kZS5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSB8fCAobm9kZS5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSA9IEJvb2xlYW4obm9kZS5pc1Byb2plY3Rpb25EaXJ0eSB8fFxuICAgICAgICBub2RlLnBhcmVudC5pc1Byb2plY3Rpb25EaXJ0eSB8fFxuICAgICAgICBub2RlLnBhcmVudC5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSkpO1xuICAgIG5vZGUuaXNUcmFuc2Zvcm1EaXJ0eSB8fCAobm9kZS5pc1RyYW5zZm9ybURpcnR5ID0gbm9kZS5wYXJlbnQuaXNUcmFuc2Zvcm1EaXJ0eSk7XG59XG5mdW5jdGlvbiBjbGVhbkRpcnR5Tm9kZXMobm9kZSkge1xuICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPVxuICAgICAgICBub2RlLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID1cbiAgICAgICAgICAgIG5vZGUuaXNUcmFuc2Zvcm1EaXJ0eSA9XG4gICAgICAgICAgICAgICAgZmFsc2U7XG59XG5mdW5jdGlvbiBjbGVhclNuYXBzaG90KG5vZGUpIHtcbiAgICBub2RlLmNsZWFyU25hcHNob3QoKTtcbn1cbmZ1bmN0aW9uIGNsZWFyTWVhc3VyZW1lbnRzKG5vZGUpIHtcbiAgICBub2RlLmNsZWFyTWVhc3VyZW1lbnRzKCk7XG59XG5mdW5jdGlvbiBjbGVhcklzTGF5b3V0RGlydHkobm9kZSkge1xuICAgIG5vZGUuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1TdHlsZShub2RlKSB7XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBub2RlLm9wdGlvbnM7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLm9uQmVmb3JlTGF5b3V0TWVhc3VyZSkge1xuICAgICAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeShcIkJlZm9yZUxheW91dE1lYXN1cmVcIik7XG4gICAgfVxuICAgIG5vZGUucmVzZXRUcmFuc2Zvcm0oKTtcbn1cbmZ1bmN0aW9uIGZpbmlzaEFuaW1hdGlvbihub2RlKSB7XG4gICAgbm9kZS5maW5pc2hBbmltYXRpb24oKTtcbiAgICBub2RlLnRhcmdldERlbHRhID0gbm9kZS5yZWxhdGl2ZVRhcmdldCA9IG5vZGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldERlbHRhKG5vZGUpIHtcbiAgICBub2RlLnJlc29sdmVUYXJnZXREZWx0YSgpO1xufVxuZnVuY3Rpb24gY2FsY1Byb2plY3Rpb24obm9kZSkge1xuICAgIG5vZGUuY2FsY1Byb2plY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIHJlc2V0U2tld0FuZFJvdGF0aW9uKG5vZGUpIHtcbiAgICBub2RlLnJlc2V0U2tld0FuZFJvdGF0aW9uKCk7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkU25hcHNob3RzKHN0YWNrKSB7XG4gICAgc3RhY2sucmVtb3ZlTGVhZFNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBtaXhBeGlzRGVsdGEob3V0cHV0LCBkZWx0YSwgcCkge1xuICAgIG91dHB1dC50cmFuc2xhdGUgPSBtaXhOdW1iZXIoZGVsdGEudHJhbnNsYXRlLCAwLCBwKTtcbiAgICBvdXRwdXQuc2NhbGUgPSBtaXhOdW1iZXIoZGVsdGEuc2NhbGUsIDEsIHApO1xuICAgIG91dHB1dC5vcmlnaW4gPSBkZWx0YS5vcmlnaW47XG4gICAgb3V0cHV0Lm9yaWdpblBvaW50ID0gZGVsdGEub3JpZ2luUG9pbnQ7XG59XG5mdW5jdGlvbiBtaXhBeGlzKG91dHB1dCwgZnJvbSwgdG8sIHApIHtcbiAgICBvdXRwdXQubWluID0gbWl4TnVtYmVyKGZyb20ubWluLCB0by5taW4sIHApO1xuICAgIG91dHB1dC5tYXggPSBtaXhOdW1iZXIoZnJvbS5tYXgsIHRvLm1heCwgcCk7XG59XG5mdW5jdGlvbiBtaXhCb3gob3V0cHV0LCBmcm9tLCB0bywgcCkge1xuICAgIG1peEF4aXMob3V0cHV0LngsIGZyb20ueCwgdG8ueCwgcCk7XG4gICAgbWl4QXhpcyhvdXRwdXQueSwgZnJvbS55LCB0by55LCBwKTtcbn1cbmZ1bmN0aW9uIGhhc09wYWNpdHlDcm9zc2ZhZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5hbmltYXRpb25WYWx1ZXMgJiYgbm9kZS5hbmltYXRpb25WYWx1ZXMub3BhY2l0eUV4aXQgIT09IHVuZGVmaW5lZCk7XG59XG5jb25zdCBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiA9IHtcbiAgICBkdXJhdGlvbjogMC40NSxcbiAgICBlYXNlOiBbMC40LCAwLCAwLjEsIDFdLFxufTtcbmNvbnN0IHVzZXJBZ2VudENvbnRhaW5zID0gKHN0cmluZykgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc3RyaW5nKTtcbi8qKlxuICogTWVhc3VyZWQgYm91bmRpbmcgYm94ZXMgbXVzdCBiZSByb3VuZGVkIGluIFNhZmFyaSBhbmRcbiAqIGxlZnQgdW50b3VjaGVkIGluIENocm9tZSwgb3RoZXJ3aXNlIG5vbi1pbnRlZ2VyIGxheW91dHMgd2l0aGluIHNjYWxlZC11cCBlbGVtZW50c1xuICogY2FuIGFwcGVhciB0byBqdW1wLlxuICovXG5jb25zdCByb3VuZFBvaW50ID0gdXNlckFnZW50Q29udGFpbnMoXCJhcHBsZXdlYmtpdC9cIikgJiYgIXVzZXJBZ2VudENvbnRhaW5zKFwiY2hyb21lL1wiKVxuICAgID8gTWF0aC5yb3VuZFxuICAgIDogbm9vcDtcbmZ1bmN0aW9uIHJvdW5kQXhpcyhheGlzKSB7XG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgLjUgcGl4ZWxzIHRvIHN1cHBvcnQgc3VicGl4ZWwgbGF5b3V0c1xuICAgIGF4aXMubWluID0gcm91bmRQb2ludChheGlzLm1pbik7XG4gICAgYXhpcy5tYXggPSByb3VuZFBvaW50KGF4aXMubWF4KTtcbn1cbmZ1bmN0aW9uIHJvdW5kQm94KGJveCkge1xuICAgIHJvdW5kQXhpcyhib3gueCk7XG4gICAgcm91bmRBeGlzKGJveC55KTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFuaW1hdGVQb3NpdGlvbk9ubHkoYW5pbWF0aW9uVHlwZSwgc25hcHNob3QsIGxheW91dCkge1xuICAgIHJldHVybiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJwb3NpdGlvblwiIHx8XG4gICAgICAgIChhbmltYXRpb25UeXBlID09PSBcInByZXNlcnZlLWFzcGVjdFwiICYmXG4gICAgICAgICAgICAhaXNOZWFyKGFzcGVjdFJhdGlvKHNuYXBzaG90KSwgYXNwZWN0UmF0aW8obGF5b3V0KSwgMC4yKSkpO1xufVxuZnVuY3Rpb24gY2hlY2tOb2RlV2FzU2Nyb2xsUm9vdChub2RlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBub2RlICE9PSBub2RlLnJvb3QgJiYgKChfYSA9IG5vZGUuc2Nyb2xsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FzUm9vdCk7XG59XG5cbmV4cG9ydCB7IGNsZWFuRGlydHlOb2RlcywgY3JlYXRlUHJvamVjdGlvbk5vZGUsIG1peEF4aXMsIG1peEF4aXNEZWx0YSwgbWl4Qm94LCBwcm9wYWdhdGVEaXJ0eU5vZGVzIH07XG4iLCJpbXBvcnQgeyBjcmVhdGVQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vY3JlYXRlLXByb2plY3Rpb24tbm9kZS5tanMnO1xuaW1wb3J0IHsgYWRkRG9tRXZlbnQgfSBmcm9tICcuLi8uLi9ldmVudHMvYWRkLWRvbS1ldmVudC5tanMnO1xuXG5jb25zdCBEb2N1bWVudFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICAgIGF0dGFjaFJlc2l6ZUxpc3RlbmVyOiAocmVmLCBub3RpZnkpID0+IGFkZERvbUV2ZW50KHJlZiwgXCJyZXNpemVcIiwgbm90aWZ5KSxcbiAgICBtZWFzdXJlU2Nyb2xsOiAoKSA9PiAoe1xuICAgICAgICB4OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQsXG4gICAgICAgIHk6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgfSksXG4gICAgY2hlY2tJc1Njcm9sbFJvb3Q6ICgpID0+IHRydWUsXG59KTtcblxuZXhwb3J0IHsgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlUHJvamVjdGlvbk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzJztcbmltcG9ydCB7IERvY3VtZW50UHJvamVjdGlvbk5vZGUgfSBmcm9tICcuL0RvY3VtZW50UHJvamVjdGlvbk5vZGUubWpzJztcblxuY29uc3Qgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG5jb25zdCBIVE1MUHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gICAgbWVhc3VyZVNjcm9sbDogKGluc3RhbmNlKSA9PiAoe1xuICAgICAgICB4OiBpbnN0YW5jZS5zY3JvbGxMZWZ0LFxuICAgICAgICB5OiBpbnN0YW5jZS5zY3JvbGxUb3AsXG4gICAgfSksXG4gICAgZGVmYXVsdFBhcmVudDogKCkgPT4ge1xuICAgICAgICBpZiAoIXJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudE5vZGUgPSBuZXcgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSh7fSk7XG4gICAgICAgICAgICBkb2N1bWVudE5vZGUubW91bnQod2luZG93KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5zZXRPcHRpb25zKHsgbGF5b3V0U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQgPSBkb2N1bWVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgIH0sXG4gICAgcmVzZXRUcmFuc2Zvcm06IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaW5zdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogXCJub25lXCI7XG4gICAgfSxcbiAgICBjaGVja0lzU2Nyb2xsUm9vdDogKGluc3RhbmNlKSA9PiBCb29sZWFuKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGluc3RhbmNlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSxcbn0pO1xuXG5leHBvcnQgeyBIVE1MUHJvamVjdGlvbk5vZGUsIHJvb3RQcm9qZWN0aW9uTm9kZSB9O1xuIiwiaW1wb3J0IHsgRHJhZ0dlc3R1cmUgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy9kcmFnL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBQYW5HZXN0dXJlIH0gZnJvbSAnLi4vLi4vZ2VzdHVyZXMvcGFuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBNZWFzdXJlTGF5b3V0IH0gZnJvbSAnLi9sYXlvdXQvTWVhc3VyZUxheW91dC5tanMnO1xuaW1wb3J0IHsgSFRNTFByb2plY3Rpb25Ob2RlIH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9ub2RlL0hUTUxQcm9qZWN0aW9uTm9kZS5tanMnO1xuXG5jb25zdCBkcmFnID0ge1xuICAgIHBhbjoge1xuICAgICAgICBGZWF0dXJlOiBQYW5HZXN0dXJlLFxuICAgIH0sXG4gICAgZHJhZzoge1xuICAgICAgICBGZWF0dXJlOiBEcmFnR2VzdHVyZSxcbiAgICAgICAgUHJvamVjdGlvbk5vZGU6IEhUTUxQcm9qZWN0aW9uTm9kZSxcbiAgICAgICAgTWVhc3VyZUxheW91dCxcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgZHJhZyB9O1xuIiwiaW1wb3J0IHsgaG92ZXIgfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IGV4dHJhY3RFdmVudEluZm8gfSBmcm9tICcuLi9ldmVudHMvZXZlbnQtaW5mby5tanMnO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gJy4uL21vdGlvbi9mZWF0dXJlcy9GZWF0dXJlLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5mdW5jdGlvbiBoYW5kbGVIb3ZlckV2ZW50KG5vZGUsIGV2ZW50LCBsaWZlY3ljbGUpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xuICAgIGlmIChub2RlLmFuaW1hdGlvblN0YXRlICYmIHByb3BzLndoaWxlSG92ZXIpIHtcbiAgICAgICAgbm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZUhvdmVyXCIsIGxpZmVjeWNsZSA9PT0gXCJTdGFydFwiKTtcbiAgICB9XG4gICAgY29uc3QgZXZlbnROYW1lID0gKFwib25Ib3ZlclwiICsgbGlmZWN5Y2xlKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHByb3BzW2V2ZW50TmFtZV07XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gY2FsbGJhY2soZXZlbnQsIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpKSk7XG4gICAgfVxufVxuY2xhc3MgSG92ZXJHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdGhpcy5ub2RlO1xuICAgICAgICBpZiAoIWN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudW5tb3VudCA9IGhvdmVyKGN1cnJlbnQsIChfZWxlbWVudCwgc3RhcnRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlSG92ZXJFdmVudCh0aGlzLm5vZGUsIHN0YXJ0RXZlbnQsIFwiU3RhcnRcIik7XG4gICAgICAgICAgICByZXR1cm4gKGVuZEV2ZW50KSA9PiBoYW5kbGVIb3ZlckV2ZW50KHRoaXMubm9kZSwgZW5kRXZlbnQsIFwiRW5kXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHsgfVxufVxuXG5leHBvcnQgeyBIb3Zlckdlc3R1cmUgfTtcbiIsImltcG9ydCB7IGFkZERvbUV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzL2FkZC1kb20tZXZlbnQubWpzJztcbmltcG9ydCB7IEZlYXR1cmUgfSBmcm9tICcuLi9tb3Rpb24vZmVhdHVyZXMvRmVhdHVyZS5tanMnO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJy4uL3V0aWxzL3BpcGUubWpzJztcblxuY2xhc3MgRm9jdXNHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgb25Gb2N1cygpIHtcbiAgICAgICAgbGV0IGlzRm9jdXNWaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgZG9lc24ndCBtYXRjaCBmb2N1cy12aXNpYmxlIHRoZW4gZG9uJ3RcbiAgICAgICAgICogYXBwbHkgd2hpbGVIb3Zlci4gQnV0LCBpZiBtYXRjaGVzIHRocm93cyB0aGF0IGZvY3VzLXZpc2libGVcbiAgICAgICAgICogaXMgbm90IGEgdmFsaWQgc2VsZWN0b3IgdGhlbiBpbiB0aGF0IGJyb3dzZXIgb3V0bGluZSBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkXG4gICAgICAgICAqIHRvIHRoZSBlbGVtZW50IGJ5IGRlZmF1bHQgYW5kIHdlIHdhbnQgdG8gbWF0Y2ggdGhhdCBiZWhhdmlvdXIgd2l0aCB3aGlsZUZvY3VzLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzRm9jdXNWaXNpYmxlID0gdGhpcy5ub2RlLmN1cnJlbnQubWF0Y2hlcyhcIjpmb2N1cy12aXNpYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpc0ZvY3VzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0ZvY3VzVmlzaWJsZSB8fCAhdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVGb2N1c1wiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgfVxuICAgIG9uQmx1cigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQWN0aXZlIHx8ICF0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZUZvY3VzXCIsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy51bm1vdW50ID0gcGlwZShhZGREb21FdmVudCh0aGlzLm5vZGUuY3VycmVudCwgXCJmb2N1c1wiLCAoKSA9PiB0aGlzLm9uRm9jdXMoKSksIGFkZERvbUV2ZW50KHRoaXMubm9kZS5jdXJyZW50LCBcImJsdXJcIiwgKCkgPT4gdGhpcy5vbkJsdXIoKSkpO1xuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbmV4cG9ydCB7IEZvY3VzR2VzdHVyZSB9O1xuIiwiaW1wb3J0IHsgcHJlc3MgfSBmcm9tICdtb3Rpb24tZG9tJztcbmltcG9ydCB7IGV4dHJhY3RFdmVudEluZm8gfSBmcm9tICcuLi9ldmVudHMvZXZlbnQtaW5mby5tanMnO1xuaW1wb3J0IHsgRmVhdHVyZSB9IGZyb20gJy4uL21vdGlvbi9mZWF0dXJlcy9GZWF0dXJlLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9mcmFtZS5tanMnO1xuXG5mdW5jdGlvbiBoYW5kbGVQcmVzc0V2ZW50KG5vZGUsIGV2ZW50LCBsaWZlY3ljbGUpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xuICAgIGlmIChub2RlLmFuaW1hdGlvblN0YXRlICYmIHByb3BzLndoaWxlVGFwKSB7XG4gICAgICAgIG5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVUYXBcIiwgbGlmZWN5Y2xlID09PSBcIlN0YXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBldmVudE5hbWUgPSAoXCJvblRhcFwiICsgKGxpZmVjeWNsZSA9PT0gXCJFbmRcIiA/IFwiXCIgOiBsaWZlY3ljbGUpKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHByb3BzW2V2ZW50TmFtZV07XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gY2FsbGJhY2soZXZlbnQsIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpKSk7XG4gICAgfVxufVxuY2xhc3MgUHJlc3NHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdGhpcy5ub2RlO1xuICAgICAgICBpZiAoIWN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudW5tb3VudCA9IHByZXNzKGN1cnJlbnQsIChfZWxlbWVudCwgc3RhcnRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlUHJlc3NFdmVudCh0aGlzLm5vZGUsIHN0YXJ0RXZlbnQsIFwiU3RhcnRcIik7XG4gICAgICAgICAgICByZXR1cm4gKGVuZEV2ZW50LCB7IHN1Y2Nlc3MgfSkgPT4gaGFuZGxlUHJlc3NFdmVudCh0aGlzLm5vZGUsIGVuZEV2ZW50LCBzdWNjZXNzID8gXCJFbmRcIiA6IFwiQ2FuY2VsXCIpO1xuICAgICAgICB9LCB7IHVzZUdsb2JhbFRhcmdldDogdGhpcy5ub2RlLnByb3BzLmdsb2JhbFRhcFRhcmdldCB9KTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHsgfVxufVxuXG5leHBvcnQgeyBQcmVzc0dlc3R1cmUgfTtcbiIsIi8qKlxuICogTWFwIGFuIEludGVyc2VjdGlvbkhhbmRsZXIgY2FsbGJhY2sgdG8gYW4gZWxlbWVudC4gV2Ugb25seSBldmVyIG1ha2Ugb25lIGhhbmRsZXIgZm9yIG9uZVxuICogZWxlbWVudCwgc28gZXZlbiB0aG91Z2ggdGhlc2UgaGFuZGxlcnMgbWlnaHQgYWxsIGJlIHRyaWdnZXJlZCBieSBkaWZmZXJlbnRcbiAqIG9ic2VydmVycywgd2UgY2FuIGtlZXAgdGhlbSBpbiB0aGUgc2FtZSBtYXAuXG4gKi9cbmNvbnN0IG9ic2VydmVyQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogTXVsdGlwbGUgb2JzZXJ2ZXJzIGNhbiBiZSBjcmVhdGVkIGZvciBtdWx0aXBsZSBlbGVtZW50L2RvY3VtZW50IHJvb3RzLiBFYWNoIHdpdGhcbiAqIGRpZmZlcmVudCBzZXR0aW5ncy4gU28gaGVyZSB3ZSBzdG9yZSBkaWN0aW9uYXJpZXMgb2Ygb2JzZXJ2ZXJzIHRvIGVhY2ggcm9vdCxcbiAqIHVzaW5nIHNlcmlhbGlzZWQgc2V0dGluZ3MgKHRocmVzaG9sZC9tYXJnaW4pIGFzIGxvb2t1cCBrZXlzLlxuICovXG5jb25zdCBvYnNlcnZlcnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgZmlyZU9ic2VydmVyQ2FsbGJhY2sgPSAoZW50cnkpID0+IHtcbiAgICBjb25zdCBjYWxsYmFjayA9IG9ic2VydmVyQ2FsbGJhY2tzLmdldChlbnRyeS50YXJnZXQpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVudHJ5KTtcbn07XG5jb25zdCBmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MgPSAoZW50cmllcykgPT4ge1xuICAgIGVudHJpZXMuZm9yRWFjaChmaXJlT2JzZXJ2ZXJDYWxsYmFjayk7XG59O1xuZnVuY3Rpb24gaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKHsgcm9vdCwgLi4ub3B0aW9ucyB9KSB7XG4gICAgY29uc3QgbG9va3VwUm9vdCA9IHJvb3QgfHwgZG9jdW1lbnQ7XG4gICAgLyoqXG4gICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhbiBvYnNlcnZlciBsb29rdXAgbWFwIGZvciB0aGlzIHJvb3QsIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFvYnNlcnZlcnMuaGFzKGxvb2t1cFJvb3QpKSB7XG4gICAgICAgIG9ic2VydmVycy5zZXQobG9va3VwUm9vdCwge30pO1xuICAgIH1cbiAgICBjb25zdCByb290T2JzZXJ2ZXJzID0gb2JzZXJ2ZXJzLmdldChsb29rdXBSb290KTtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGZvciB0aGlzIGNvbWJpbmF0aW9uIG9mIHJvb3QgYW5kIHNldHRpbmdzLFxuICAgICAqIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICAgICAgcm9vdE9ic2VydmVyc1trZXldID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcywgeyByb290LCAuLi5vcHRpb25zIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdE9ic2VydmVyc1trZXldO1xufVxuZnVuY3Rpb24gb2JzZXJ2ZUludGVyc2VjdGlvbihlbGVtZW50LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIgPSBpbml0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIob3B0aW9ucyk7XG4gICAgb2JzZXJ2ZXJDYWxsYmFja3Muc2V0KGVsZW1lbnQsIGNhbGxiYWNrKTtcbiAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgb2JzZXJ2ZXJDYWxsYmFja3MuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBvYnNlcnZlSW50ZXJzZWN0aW9uIH07XG4iLCJpbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi4vRmVhdHVyZS5tanMnO1xuaW1wb3J0IHsgb2JzZXJ2ZUludGVyc2VjdGlvbiB9IGZyb20gJy4vb2JzZXJ2ZXJzLm1qcyc7XG5cbmNvbnN0IHRocmVzaG9sZE5hbWVzID0ge1xuICAgIHNvbWU6IDAsXG4gICAgYWxsOiAxLFxufTtcbmNsYXNzIEluVmlld0ZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5oYXNFbnRlcmVkVmlldyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW5WaWV3ID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0T2JzZXJ2ZXIoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudCgpO1xuICAgICAgICBjb25zdCB7IHZpZXdwb3J0ID0ge30gfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCB7IHJvb3QsIG1hcmdpbjogcm9vdE1hcmdpbiwgYW1vdW50ID0gXCJzb21lXCIsIG9uY2UgfSA9IHZpZXdwb3J0O1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcm9vdDogcm9vdCA/IHJvb3QuY3VycmVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGROYW1lc1thbW91bnRdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkludGVyc2VjdGlvblVwZGF0ZSA9IChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpc0ludGVyc2VjdGluZyB9ID0gZW50cnk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlJ3MgYmVlbiBubyBjaGFuZ2UgaW4gdGhlIHZpZXdwb3J0IHN0YXRlLCBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5WaWV3ID09PSBpc0ludGVyc2VjdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzSW5WaWV3ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZSBoYXNFbnRlcmVkVmlldy4gSWYgdGhpcyBpcyBvbmx5IG1lYW50IHRvIHJ1biBvbmNlLCBhbmRcbiAgICAgICAgICAgICAqIGVsZW1lbnQgaXNuJ3QgdmlzaWJsZSwgZWFybHkgcmV0dXJuLiBPdGhlcndpc2Ugc2V0IGhhc0VudGVyZWRWaWV3IHRvIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvbmNlICYmICFpc0ludGVyc2VjdGluZyAmJiB0aGlzLmhhc0VudGVyZWRWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0VudGVyZWRWaWV3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVJblZpZXdcIiwgaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2UgdGhlIGxhdGVzdCBjb21taXR0ZWQgcHJvcHMgcmF0aGVyIHRoYW4gdGhlIG9uZXMgaW4gc2NvcGVcbiAgICAgICAgICAgICAqIHdoZW4gdGhpcyBvYnNlcnZlciBpcyBjcmVhdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydEVudGVyLCBvblZpZXdwb3J0TGVhdmUgfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBpc0ludGVyc2VjdGluZyA/IG9uVmlld3BvcnRFbnRlciA6IG9uVmlld3BvcnRMZWF2ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVudHJ5KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG9ic2VydmVJbnRlcnNlY3Rpb24odGhpcy5ub2RlLmN1cnJlbnQsIG9wdGlvbnMsIG9uSW50ZXJzZWN0aW9uVXBkYXRlKTtcbiAgICB9XG4gICAgbW91bnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRPYnNlcnZlcigpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgcHJvcHMsIHByZXZQcm9wcyB9ID0gdGhpcy5ub2RlO1xuICAgICAgICBjb25zdCBoYXNPcHRpb25zQ2hhbmdlZCA9IFtcImFtb3VudFwiLCBcIm1hcmdpblwiLCBcInJvb3RcIl0uc29tZShoYXNWaWV3cG9ydE9wdGlvbkNoYW5nZWQocHJvcHMsIHByZXZQcm9wcykpO1xuICAgICAgICBpZiAoaGFzT3B0aW9uc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRPYnNlcnZlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7IH1cbn1cbmZ1bmN0aW9uIGhhc1ZpZXdwb3J0T3B0aW9uQ2hhbmdlZCh7IHZpZXdwb3J0ID0ge30gfSwgeyB2aWV3cG9ydDogcHJldlZpZXdwb3J0ID0ge30gfSA9IHt9KSB7XG4gICAgcmV0dXJuIChuYW1lKSA9PiB2aWV3cG9ydFtuYW1lXSAhPT0gcHJldlZpZXdwb3J0W25hbWVdO1xufVxuXG5leHBvcnQgeyBJblZpZXdGZWF0dXJlIH07XG4iLCJpbXBvcnQgeyBIb3Zlckdlc3R1cmUgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy9ob3Zlci5tanMnO1xuaW1wb3J0IHsgRm9jdXNHZXN0dXJlIH0gZnJvbSAnLi4vLi4vZ2VzdHVyZXMvZm9jdXMubWpzJztcbmltcG9ydCB7IFByZXNzR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3ByZXNzLm1qcyc7XG5pbXBvcnQgeyBJblZpZXdGZWF0dXJlIH0gZnJvbSAnLi92aWV3cG9ydC9pbmRleC5tanMnO1xuXG5jb25zdCBnZXN0dXJlQW5pbWF0aW9ucyA9IHtcbiAgICBpblZpZXc6IHtcbiAgICAgICAgRmVhdHVyZTogSW5WaWV3RmVhdHVyZSxcbiAgICB9LFxuICAgIHRhcDoge1xuICAgICAgICBGZWF0dXJlOiBQcmVzc0dlc3R1cmUsXG4gICAgfSxcbiAgICBmb2N1czoge1xuICAgICAgICBGZWF0dXJlOiBGb2N1c0dlc3R1cmUsXG4gICAgfSxcbiAgICBob3Zlcjoge1xuICAgICAgICBGZWF0dXJlOiBIb3Zlckdlc3R1cmUsXG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGdlc3R1cmVBbmltYXRpb25zIH07XG4iLCJpbXBvcnQgeyBIVE1MUHJvamVjdGlvbk5vZGUgfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL25vZGUvSFRNTFByb2plY3Rpb25Ob2RlLm1qcyc7XG5pbXBvcnQgeyBNZWFzdXJlTGF5b3V0IH0gZnJvbSAnLi9sYXlvdXQvTWVhc3VyZUxheW91dC5tanMnO1xuXG5jb25zdCBsYXlvdXQgPSB7XG4gICAgbGF5b3V0OiB7XG4gICAgICAgIFByb2plY3Rpb25Ob2RlOiBIVE1MUHJvamVjdGlvbk5vZGUsXG4gICAgICAgIE1lYXN1cmVMYXlvdXQsXG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGxheW91dCB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG5jb25zdCBMYXp5Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQoeyBzdHJpY3Q6IGZhbHNlIH0pO1xuXG5leHBvcnQgeyBMYXp5Q29udGV4dCB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgTW90aW9uQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIHRyYW5zZm9ybVBhZ2VQb2ludDogKHApID0+IHAsXG4gICAgaXNTdGF0aWM6IGZhbHNlLFxuICAgIHJlZHVjZWRNb3Rpb246IFwibmV2ZXJcIixcbn0pO1xuXG5leHBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH07XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IE1vdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcblxuZXhwb3J0IHsgTW90aW9uQ29udGV4dCB9O1xuIiwiaW1wb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzJztcbmltcG9ydCB7IGlzVmFyaWFudExhYmVsIH0gZnJvbSAnLi9pcy12YXJpYW50LWxhYmVsLm1qcyc7XG5pbXBvcnQgeyB2YXJpYW50UHJvcHMgfSBmcm9tICcuL3ZhcmlhbnQtcHJvcHMubWpzJztcblxuZnVuY3Rpb24gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB7XG4gICAgcmV0dXJuIChpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3BzLmFuaW1hdGUpIHx8XG4gICAgICAgIHZhcmlhbnRQcm9wcy5zb21lKChuYW1lKSA9PiBpc1ZhcmlhbnRMYWJlbChwcm9wc1tuYW1lXSkpKTtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFudE5vZGUocHJvcHMpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHx8IHByb3BzLnZhcmlhbnRzKTtcbn1cblxuZXhwb3J0IHsgaXNDb250cm9sbGluZ1ZhcmlhbnRzLCBpc1ZhcmlhbnROb2RlIH07XG4iLCJpbXBvcnQgeyBpc1ZhcmlhbnRMYWJlbCB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9pcy12YXJpYW50LWxhYmVsLm1qcyc7XG5pbXBvcnQgeyBpc0NvbnRyb2xsaW5nVmFyaWFudHMgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvaXMtY29udHJvbGxpbmctdmFyaWFudHMubWpzJztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgY29udGV4dCkge1xuICAgIGlmIChpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbml0aWFsOiBpbml0aWFsID09PSBmYWxzZSB8fCBpc1ZhcmlhbnRMYWJlbChpbml0aWFsKVxuICAgICAgICAgICAgICAgID8gaW5pdGlhbFxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYW5pbWF0ZTogaXNWYXJpYW50TGFiZWwoYW5pbWF0ZSkgPyBhbmltYXRlIDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UgPyBjb250ZXh0IDoge307XG59XG5cbmV4cG9ydCB7IGdldEN1cnJlbnRUcmVlVmFyaWFudHMgfTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi9pbmRleC5tanMnO1xuaW1wb3J0IHsgZ2V0Q3VycmVudFRyZWVWYXJpYW50cyB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuZnVuY3Rpb24gdXNlQ3JlYXRlTW90aW9uQ29udGV4dChwcm9wcykge1xuICAgIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgaW5pdGlhbCwgYW5pbWF0ZSB9KSwgW3ZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3koaW5pdGlhbCksIHZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3koYW5pbWF0ZSldKTtcbn1cbmZ1bmN0aW9uIHZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3kocHJvcCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcC5qb2luKFwiIFwiKSA6IHByb3A7XG59XG5cbmV4cG9ydCB7IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQgfTtcbiIsImNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG5cbmV4cG9ydCB7IGlzQnJvd3NlciB9O1xuIiwiY29uc3QgZmVhdHVyZVByb3BzID0ge1xuICAgIGFuaW1hdGlvbjogW1xuICAgICAgICBcImFuaW1hdGVcIixcbiAgICAgICAgXCJ2YXJpYW50c1wiLFxuICAgICAgICBcIndoaWxlSG92ZXJcIixcbiAgICAgICAgXCJ3aGlsZVRhcFwiLFxuICAgICAgICBcImV4aXRcIixcbiAgICAgICAgXCJ3aGlsZUluVmlld1wiLFxuICAgICAgICBcIndoaWxlRm9jdXNcIixcbiAgICAgICAgXCJ3aGlsZURyYWdcIixcbiAgICBdLFxuICAgIGV4aXQ6IFtcImV4aXRcIl0sXG4gICAgZHJhZzogW1wiZHJhZ1wiLCBcImRyYWdDb250cm9sc1wiXSxcbiAgICBmb2N1czogW1wid2hpbGVGb2N1c1wiXSxcbiAgICBob3ZlcjogW1wid2hpbGVIb3ZlclwiLCBcIm9uSG92ZXJTdGFydFwiLCBcIm9uSG92ZXJFbmRcIl0sXG4gICAgdGFwOiBbXCJ3aGlsZVRhcFwiLCBcIm9uVGFwXCIsIFwib25UYXBTdGFydFwiLCBcIm9uVGFwQ2FuY2VsXCJdLFxuICAgIHBhbjogW1wib25QYW5cIiwgXCJvblBhblN0YXJ0XCIsIFwib25QYW5TZXNzaW9uU3RhcnRcIiwgXCJvblBhbkVuZFwiXSxcbiAgICBpblZpZXc6IFtcIndoaWxlSW5WaWV3XCIsIFwib25WaWV3cG9ydEVudGVyXCIsIFwib25WaWV3cG9ydExlYXZlXCJdLFxuICAgIGxheW91dDogW1wibGF5b3V0XCIsIFwibGF5b3V0SWRcIl0sXG59O1xuY29uc3QgZmVhdHVyZURlZmluaXRpb25zID0ge307XG5mb3IgKGNvbnN0IGtleSBpbiBmZWF0dXJlUHJvcHMpIHtcbiAgICBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XSA9IHtcbiAgICAgICAgaXNFbmFibGVkOiAocHJvcHMpID0+IGZlYXR1cmVQcm9wc1trZXldLnNvbWUoKG5hbWUpID0+ICEhcHJvcHNbbmFtZV0pLFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGZlYXR1cmVEZWZpbml0aW9ucyB9O1xuIiwiaW1wb3J0IHsgZmVhdHVyZURlZmluaXRpb25zIH0gZnJvbSAnLi9kZWZpbml0aW9ucy5tanMnO1xuXG5mdW5jdGlvbiBsb2FkRmVhdHVyZXMoZmVhdHVyZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmZWF0dXJlcykge1xuICAgICAgICBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XSA9IHtcbiAgICAgICAgICAgIC4uLmZlYXR1cmVEZWZpbml0aW9uc1trZXldLFxuICAgICAgICAgICAgLi4uZmVhdHVyZXNba2V5XSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGxvYWRGZWF0dXJlcyB9O1xuIiwiY29uc3QgbW90aW9uQ29tcG9uZW50U3ltYm9sID0gU3ltYm9sLmZvcihcIm1vdGlvbkNvbXBvbmVudFN5bWJvbFwiKTtcblxuZXhwb3J0IHsgbW90aW9uQ29tcG9uZW50U3ltYm9sIH07XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzUmVmT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtcmVmLW9iamVjdC5tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZWYgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGh5ZHJhdGVzIHRoZSBwcm92aWRlZFxuICogZXh0ZXJuYWwgcmVmIGFuZCBWaXN1YWxFbGVtZW50LlxuICovXG5mdW5jdGlvbiB1c2VNb3Rpb25SZWYodmlzdWFsU3RhdGUsIHZpc3VhbEVsZW1lbnQsIGV4dGVybmFsUmVmKSB7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChpbnN0YW5jZSkgPT4ge1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZpc3VhbFN0YXRlLm9uTW91bnQgJiYgdmlzdWFsU3RhdGUub25Nb3VudChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQubW91bnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC51bm1vdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZihpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvKipcbiAgICAgKiBPbmx5IHBhc3MgYSBuZXcgcmVmIGNhbGxiYWNrIHRvIFJlYWN0IGlmIHdlJ3ZlIHJlY2VpdmVkIGEgdmlzdWFsIGVsZW1lbnRcbiAgICAgKiBmYWN0b3J5LiBPdGhlcndpc2Ugd2UnbGwgYmUgbW91bnRpbmcvcmVtb3VudGluZyBldmVyeSB0aW1lIGV4dGVybmFsUmVmXG4gICAgICogb3Igb3RoZXIgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBbdmlzdWFsRWxlbWVudF0pO1xufVxuXG5leHBvcnQgeyB1c2VNb3Rpb25SZWYgfTtcbiIsImltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi9pcy1icm93c2VyLm1qcyc7XG5cbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBpc0Jyb3dzZXIgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbmV4cG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlSW5zZXJ0aW9uRWZmZWN0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcmVzZW5jZUNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L1ByZXNlbmNlQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgTW90aW9uQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvTW90aW9uQ29udGV4dC9pbmRleC5tanMnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanMnO1xuaW1wb3J0IHsgTGF6eUNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L0xhenlDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL29wdGltaXplZC1hcHBlYXIvZGF0YS1pZC5tanMnO1xuaW1wb3J0IHsgbWljcm90YXNrIH0gZnJvbSAnLi4vLi4vZnJhbWVsb29wL21pY3JvdGFzay5tanMnO1xuaW1wb3J0IHsgaXNSZWZPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcyc7XG5pbXBvcnQgeyBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanMnO1xuXG5mdW5jdGlvbiB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIHByb3BzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQ6IHBhcmVudCB9ID0gdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCBsYXp5Q29udGV4dCA9IHVzZUNvbnRleHQoTGF6eUNvbnRleHQpO1xuICAgIGNvbnN0IHByZXNlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KTtcbiAgICBjb25zdCByZWR1Y2VkTW90aW9uQ29uZmlnID0gdXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS5yZWR1Y2VkTW90aW9uO1xuICAgIGNvbnN0IHZpc3VhbEVsZW1lbnRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZW4ndCBwcmVsb2FkZWQgYSByZW5kZXJlciwgY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgb25lIGxhenktbG9hZGVkXG4gICAgICovXG4gICAgY3JlYXRlVmlzdWFsRWxlbWVudCA9IGNyZWF0ZVZpc3VhbEVsZW1lbnQgfHwgbGF6eUNvbnRleHQucmVuZGVyZXI7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgJiYgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQgPSBjcmVhdGVWaXN1YWxFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgICAgICAgdmlzdWFsU3RhdGUsXG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICAgIHByZXNlbmNlQ29udGV4dCxcbiAgICAgICAgICAgIGJsb2NrSW5pdGlhbEFuaW1hdGlvbjogcHJlc2VuY2VDb250ZXh0XG4gICAgICAgICAgICAgICAgPyBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCA9PT0gZmFsc2VcbiAgICAgICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgcmVkdWNlZE1vdGlvbkNvbmZpZyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgLyoqXG4gICAgICogTG9hZCBNb3Rpb24gZ2VzdHVyZSBhbmQgYW5pbWF0aW9uIGZlYXR1cmVzLiBUaGVzZSBhcmUgcmVuZGVyZWQgYXMgcmVuZGVybGVzc1xuICAgICAqIGNvbXBvbmVudHMgc28gZWFjaCBmZWF0dXJlIGNhbiBvcHRpb25hbGx5IG1ha2UgdXNlIG9mIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzLlxuICAgICAqL1xuICAgIGNvbnN0IGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyA9IHVzZUNvbnRleHQoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICBpZiAodmlzdWFsRWxlbWVudCAmJlxuICAgICAgICAhdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uICYmXG4gICAgICAgIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgJiZcbiAgICAgICAgKHZpc3VhbEVsZW1lbnQudHlwZSA9PT0gXCJodG1sXCIgfHwgdmlzdWFsRWxlbWVudC50eXBlID09PSBcInN2Z1wiKSkge1xuICAgICAgICBjcmVhdGVQcm9qZWN0aW9uTm9kZSh2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQsIHByb3BzLCBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCBpbml0aWFsTGF5b3V0R3JvdXBDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBpc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayB0aGUgY29tcG9uZW50IGhhcyBhbHJlYWR5IG1vdW50ZWQgYmVmb3JlIGNhbGxpbmdcbiAgICAgICAgICogYHVwZGF0ZWAgdW5uZWNlc3NhcmlseS4gVGhpcyBlbnN1cmVzIHdlIHNraXAgdGhlIGluaXRpYWwgdXBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQgJiYgaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQudXBkYXRlKHByb3BzLCBwcmVzZW5jZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQ2FjaGUgdGhpcyB2YWx1ZSBhcyB3ZSB3YW50IHRvIGtub3cgd2hldGhlciBIYW5kb2ZmQXBwZWFyQW5pbWF0aW9uc1xuICAgICAqIHdhcyBwcmVzZW50IG9uIGluaXRpYWwgcmVuZGVyIC0gaXQgd2lsbCBiZSBkZWxldGVkIGFmdGVyIHRoaXMuXG4gICAgICovXG4gICAgY29uc3Qgb3B0aW1pc2VkQXBwZWFySWQgPSBwcm9wc1tvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlXTtcbiAgICBjb25zdCB3YW50c0hhbmRvZmYgPSB1c2VSZWYoQm9vbGVhbihvcHRpbWlzZWRBcHBlYXJJZCkgJiZcbiAgICAgICAgISgoX2EgPSB3aW5kb3cuTW90aW9uSGFuZG9mZklzQ29tcGxldGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdpbmRvdywgb3B0aW1pc2VkQXBwZWFySWQpKSAmJlxuICAgICAgICAoKF9iID0gd2luZG93Lk1vdGlvbkhhc09wdGltaXNlZEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwod2luZG93LCBvcHRpbWlzZWRBcHBlYXJJZCkpKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5Nb3Rpb25Jc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICB2aXN1YWxFbGVtZW50LnVwZGF0ZUZlYXR1cmVzKCk7XG4gICAgICAgIG1pY3JvdGFzay5yZW5kZXIodmlzdWFsRWxlbWVudC5yZW5kZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlYWxseSB0aGlzIGZ1bmN0aW9uIHdvdWxkIGFsd2F5cyBydW4gaW4gYSB1c2VFZmZlY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEhvd2V2ZXIsIGlmIHdlIGhhdmUgb3B0aW1pc2VkIGFwcGVhciBhbmltYXRpb25zIHRvIGhhbmRvZmYgZnJvbSxcbiAgICAgICAgICogaXQgbmVlZHMgdG8gaGFwcGVuIHN5bmNocm9ub3VzbHkgdG8gZW5zdXJlIHRoZXJlJ3Mgbm8gZmxhc2ggb2ZcbiAgICAgICAgICogaW5jb3JyZWN0IHN0eWxlcyBpbiB0aGUgZXZlbnQgb2YgYSBoeWRyYXRpb24gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFNvIGlmIHdlIGRldGVjdCBhIHNpdHV0YXRpb24gd2hlcmUgb3B0aW1pc2VkIGFwcGVhciBhbmltYXRpb25zXG4gICAgICAgICAqIGFyZSBydW5uaW5nLCB3ZSB1c2UgdXNlTGF5b3V0RWZmZWN0IHRvIHRyaWdnZXIgYW5pbWF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh3YW50c0hhbmRvZmYuY3VycmVudCAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLmFuaW1hdGVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghd2FudHNIYW5kb2ZmLmN1cnJlbnQgJiYgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZS5hbmltYXRlQ2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3YW50c0hhbmRvZmYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIGFsbCBmdXR1cmUgY2FsbHMgdG8gYW5pbWF0ZUNoYW5nZXMoKSBpbiB0aGlzIGNvbXBvbmVudCB3aWxsIHJ1biBpbiB1c2VFZmZlY3RcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gd2luZG93Lk1vdGlvbkhhbmRvZmZNYXJrQXNDb21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBvcHRpbWlzZWRBcHBlYXJJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdhbnRzSGFuZG9mZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmlzdWFsRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3Rpb25Ob2RlKHZpc3VhbEVsZW1lbnQsIHByb3BzLCBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yLCBpbml0aWFsUHJvbW90aW9uQ29uZmlnKSB7XG4gICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0LCBkcmFnLCBkcmFnQ29uc3RyYWludHMsIGxheW91dFNjcm9sbCwgbGF5b3V0Um9vdCwgfSA9IHByb3BzO1xuICAgIHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiA9IG5ldyBQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yKHZpc3VhbEVsZW1lbnQubGF0ZXN0VmFsdWVzLCBwcm9wc1tcImRhdGEtZnJhbWVyLXBvcnRhbC1pZFwiXVxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IGdldENsb3Nlc3RQcm9qZWN0aW5nTm9kZSh2aXN1YWxFbGVtZW50LnBhcmVudCkpO1xuICAgIHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5zZXRPcHRpb25zKHtcbiAgICAgICAgbGF5b3V0SWQsXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgYWx3YXlzTWVhc3VyZUxheW91dDogQm9vbGVhbihkcmFnKSB8fCAoZHJhZ0NvbnN0cmFpbnRzICYmIGlzUmVmT2JqZWN0KGRyYWdDb25zdHJhaW50cykpLFxuICAgICAgICB2aXN1YWxFbGVtZW50LFxuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogVXBkYXRlIG9wdGlvbnMgaW4gYW4gZWZmZWN0LiBUaGlzIGNvdWxkIGJlIHRyaWNreSBhcyBpdCdsbCBiZSB0b28gbGF0ZVxuICAgICAgICAgKiB0byB1cGRhdGUgYnkgdGhlIHRpbWUgbGF5b3V0IGFuaW1hdGlvbnMgcnVuLlxuICAgICAgICAgKiBXZSBhbHNvIG5lZWQgdG8gZml4IHRoaXMgc2FmZVRvUmVtb3ZlIGJ5IGxpbmtpbmcgaXQgdXAgdG8gdGhlIG9uZSByZXR1cm5lZCBieSB1c2VQcmVzZW5jZSxcbiAgICAgICAgICogZW5zdXJpbmcgaXQgZ2V0cyBjYWxsZWQgaWYgdGhlcmUncyBubyBwb3RlbnRpYWwgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBhbmltYXRpb25UeXBlOiB0eXBlb2YgbGF5b3V0ID09PSBcInN0cmluZ1wiID8gbGF5b3V0IDogXCJib3RoXCIsXG4gICAgICAgIGluaXRpYWxQcm9tb3Rpb25Db25maWcsXG4gICAgICAgIGxheW91dFNjcm9sbCxcbiAgICAgICAgbGF5b3V0Um9vdCxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldENsb3Nlc3RQcm9qZWN0aW5nTm9kZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50KVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50Lm9wdGlvbnMuYWxsb3dQcm9qZWN0aW9uICE9PSBmYWxzZVxuICAgICAgICA/IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvblxuICAgICAgICA6IGdldENsb3Nlc3RQcm9qZWN0aW5nTm9kZSh2aXN1YWxFbGVtZW50LnBhcmVudCk7XG59XG5cbmV4cG9ydCB7IHVzZVZpc3VhbEVsZW1lbnQgfTtcbiIsIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IHsganN4cywganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgd2FybmluZywgaW52YXJpYW50IH0gZnJvbSAnbW90aW9uLXV0aWxzJztcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgTGF6eUNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L0xhenlDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1c2VDcmVhdGVNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2NyZWF0ZS5tanMnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi4vdXRpbHMvaXMtYnJvd3Nlci5tanMnO1xuaW1wb3J0IHsgZmVhdHVyZURlZmluaXRpb25zIH0gZnJvbSAnLi9mZWF0dXJlcy9kZWZpbml0aW9ucy5tanMnO1xuaW1wb3J0IHsgbG9hZEZlYXR1cmVzIH0gZnJvbSAnLi9mZWF0dXJlcy9sb2FkLWZlYXR1cmVzLm1qcyc7XG5pbXBvcnQgeyBtb3Rpb25Db21wb25lbnRTeW1ib2wgfSBmcm9tICcuL3V0aWxzL3N5bWJvbC5tanMnO1xuaW1wb3J0IHsgdXNlTW90aW9uUmVmIH0gZnJvbSAnLi91dGlscy91c2UtbW90aW9uLXJlZi5tanMnO1xuaW1wb3J0IHsgdXNlVmlzdWFsRWxlbWVudCB9IGZyb20gJy4vdXRpbHMvdXNlLXZpc3VhbC1lbGVtZW50Lm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlIGEgYG1vdGlvbmAgY29tcG9uZW50LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhIENvbXBvbmVudCBhcmd1bWVudCwgd2hpY2ggY2FuIGJlIGVpdGhlciBhIHN0cmluZyAoaWUgXCJkaXZcIlxuICogZm9yIGBtb3Rpb24uZGl2YCksIG9yIGFuIGFjdHVhbCBSZWFjdCBjb21wb25lbnQuXG4gKlxuICogQWxvbmdzaWRlIHRoaXMgaXMgYSBjb25maWcgb3B0aW9uIHdoaWNoIHByb3ZpZGVzIGEgd2F5IG9mIHJlbmRlcmluZyB0aGUgcHJvdmlkZWRcbiAqIGNvbXBvbmVudCBcIm9mZmxpbmVcIiwgb3Igb3V0c2lkZSB0aGUgUmVhY3QgcmVuZGVyIGN5Y2xlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCh7IHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50LCB1c2VSZW5kZXIsIHVzZVZpc3VhbFN0YXRlLCBDb21wb25lbnQsIH0pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHByZWxvYWRlZEZlYXR1cmVzICYmIGxvYWRGZWF0dXJlcyhwcmVsb2FkZWRGZWF0dXJlcyk7XG4gICAgZnVuY3Rpb24gTW90aW9uQ29tcG9uZW50KHByb3BzLCBleHRlcm5hbFJlZikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UgbmVlZCB0byBtZWFzdXJlIHRoZSBlbGVtZW50IHdlIGxvYWQgdGhpcyBmdW5jdGlvbmFsaXR5IGluIGFcbiAgICAgICAgICogc2VwYXJhdGUgY2xhc3MgY29tcG9uZW50IGluIG9yZGVyIHRvIGdhaW4gYWNjZXNzIHRvIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IE1lYXN1cmVMYXlvdXQ7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0FuZFByb3BzID0ge1xuICAgICAgICAgICAgLi4udXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KSxcbiAgICAgICAgICAgIC4uLnByb3BzLFxuICAgICAgICAgICAgbGF5b3V0SWQ6IHVzZUxheW91dElkKHByb3BzKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBpc1N0YXRpYyB9ID0gY29uZmlnQW5kUHJvcHM7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKTtcbiAgICAgICAgY29uc3QgdmlzdWFsU3RhdGUgPSB1c2VWaXN1YWxTdGF0ZShwcm9wcywgaXNTdGF0aWMpO1xuICAgICAgICBpZiAoIWlzU3RhdGljICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdXNlU3RyaWN0TW9kZShjb25maWdBbmRQcm9wcywgcHJlbG9hZGVkRmVhdHVyZXMpO1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0UHJvamVjdGlvbiA9IGdldFByb2plY3Rpb25GdW5jdGlvbmFsaXR5KGNvbmZpZ0FuZFByb3BzKTtcbiAgICAgICAgICAgIE1lYXN1cmVMYXlvdXQgPSBsYXlvdXRQcm9qZWN0aW9uLk1lYXN1cmVMYXlvdXQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENyZWF0ZSBhIFZpc3VhbEVsZW1lbnQgZm9yIHRoaXMgY29tcG9uZW50LiBBIFZpc3VhbEVsZW1lbnQgcHJvdmlkZXMgYSBjb21tb25cbiAgICAgICAgICAgICAqIGludGVyZmFjZSB0byByZW5kZXJlci1zcGVjaWZpYyBBUElzIChpZSBET00vVGhyZWUuanMgZXRjKSBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgKiBwcm92aWRpbmcgYSB3YXkgb2YgcmVuZGVyaW5nIHRvIHRoZXNlIEFQSXMgb3V0c2lkZSBvZiB0aGUgUmVhY3QgcmVuZGVyIGxvb3BcbiAgICAgICAgICAgICAqIGZvciBtb3JlIHBlcmZvcm1hbnQgYW5pbWF0aW9ucyBhbmQgaW50ZXJhY3Rpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnRleHQudmlzdWFsRWxlbWVudCA9IHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgY29uZmlnQW5kUHJvcHMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIGxheW91dFByb2plY3Rpb24uUHJvamVjdGlvbk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbW91bnQgb3JkZXIgYW5kIGhpZXJhcmNoeSBpcyBzcGVjaWZpYyB0byBlbnN1cmUgb3VyIGVsZW1lbnQgcmVmXG4gICAgICAgICAqIGlzIGh5ZHJhdGVkIGJ5IHRoZSB0aW1lIGZlYXR1cmVzIGZpcmUgdGhlaXIgZWZmZWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiAoanN4cyhNb3Rpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogW01lYXN1cmVMYXlvdXQgJiYgY29udGV4dC52aXN1YWxFbGVtZW50ID8gKGpzeChNZWFzdXJlTGF5b3V0LCB7IHZpc3VhbEVsZW1lbnQ6IGNvbnRleHQudmlzdWFsRWxlbWVudCwgLi4uY29uZmlnQW5kUHJvcHMgfSkpIDogbnVsbCwgdXNlUmVuZGVyKENvbXBvbmVudCwgcHJvcHMsIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgY29udGV4dC52aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZiksIHZpc3VhbFN0YXRlLCBpc1N0YXRpYywgY29udGV4dC52aXN1YWxFbGVtZW50KV0gfSkpO1xuICAgIH1cbiAgICBNb3Rpb25Db21wb25lbnQuZGlzcGxheU5hbWUgPSBgbW90aW9uLiR7dHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IENvbXBvbmVudFxuICAgICAgICA6IGBjcmVhdGUoJHsoX2IgPSAoX2EgPSBDb21wb25lbnQuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENvbXBvbmVudC5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwifSlgfWA7XG4gICAgY29uc3QgRm9yd2FyZFJlZk1vdGlvbkNvbXBvbmVudCA9IGZvcndhcmRSZWYoTW90aW9uQ29tcG9uZW50KTtcbiAgICBGb3J3YXJkUmVmTW90aW9uQ29tcG9uZW50W21vdGlvbkNvbXBvbmVudFN5bWJvbF0gPSBDb21wb25lbnQ7XG4gICAgcmV0dXJuIEZvcndhcmRSZWZNb3Rpb25Db21wb25lbnQ7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRJZCh7IGxheW91dElkIH0pIHtcbiAgICBjb25zdCBsYXlvdXRHcm91cElkID0gdXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpLmlkO1xuICAgIHJldHVybiBsYXlvdXRHcm91cElkICYmIGxheW91dElkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBsYXlvdXRHcm91cElkICsgXCItXCIgKyBsYXlvdXRJZFxuICAgICAgICA6IGxheW91dElkO1xufVxuZnVuY3Rpb24gdXNlU3RyaWN0TW9kZShjb25maWdBbmRQcm9wcywgcHJlbG9hZGVkRmVhdHVyZXMpIHtcbiAgICBjb25zdCBpc1N0cmljdCA9IHVzZUNvbnRleHQoTGF6eUNvbnRleHQpLnN0cmljdDtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCBtb2RlLCBjaGVjayB0byBtYWtlIHN1cmUgd2UncmUgbm90IHJlbmRlcmluZyBhIG1vdGlvbiBjb21wb25lbnRcbiAgICAgKiBhcyBhIGNoaWxkIG9mIExhenlNb3Rpb24sIGFzIHRoaXMgd2lsbCBicmVhayB0aGUgZmlsZS1zaXplIGJlbmVmaXRzIG9mIHVzaW5nIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiZcbiAgICAgICAgcHJlbG9hZGVkRmVhdHVyZXMgJiZcbiAgICAgICAgaXNTdHJpY3QpIHtcbiAgICAgICAgY29uc3Qgc3RyaWN0TWVzc2FnZSA9IFwiWW91IGhhdmUgcmVuZGVyZWQgYSBgbW90aW9uYCBjb21wb25lbnQgd2l0aGluIGEgYExhenlNb3Rpb25gIGNvbXBvbmVudC4gVGhpcyB3aWxsIGJyZWFrIHRyZWUgc2hha2luZy4gSW1wb3J0IGFuZCByZW5kZXIgYSBgbWAgY29tcG9uZW50IGluc3RlYWQuXCI7XG4gICAgICAgIGNvbmZpZ0FuZFByb3BzLmlnbm9yZVN0cmljdFxuICAgICAgICAgICAgPyB3YXJuaW5nKGZhbHNlLCBzdHJpY3RNZXNzYWdlKVxuICAgICAgICAgICAgOiBpbnZhcmlhbnQoZmFsc2UsIHN0cmljdE1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFByb2plY3Rpb25GdW5jdGlvbmFsaXR5KHByb3BzKSB7XG4gICAgY29uc3QgeyBkcmFnLCBsYXlvdXQgfSA9IGZlYXR1cmVEZWZpbml0aW9ucztcbiAgICBpZiAoIWRyYWcgJiYgIWxheW91dClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGNvbWJpbmVkID0geyAuLi5kcmFnLCAuLi5sYXlvdXQgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBNZWFzdXJlTGF5b3V0OiAoZHJhZyA9PT0gbnVsbCB8fCBkcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnLmlzRW5hYmxlZChwcm9wcykpIHx8IChsYXlvdXQgPT09IG51bGwgfHwgbGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXQuaXNFbmFibGVkKHByb3BzKSlcbiAgICAgICAgICAgID8gY29tYmluZWQuTWVhc3VyZUxheW91dFxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIFByb2plY3Rpb25Ob2RlOiBjb21iaW5lZC5Qcm9qZWN0aW9uTm9kZSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCB9O1xuIiwiLyoqXG4gKiBXZSBrZWVwIHRoZXNlIGxpc3RlZCBzZXBhcmF0ZWx5IGFzIHdlIHVzZSB0aGUgbG93ZXJjYXNlIHRhZyBuYW1lcyBhcyBwYXJ0XG4gKiBvZiB0aGUgcnVudGltZSBidW5kbGUgdG8gZGV0ZWN0IFNWRyBjb21wb25lbnRzXG4gKi9cbmNvbnN0IGxvd2VyY2FzZVNWR0VsZW1lbnRzID0gW1xuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwiY2lyY2xlXCIsXG4gICAgXCJkZWZzXCIsXG4gICAgXCJkZXNjXCIsXG4gICAgXCJlbGxpcHNlXCIsXG4gICAgXCJnXCIsXG4gICAgXCJpbWFnZVwiLFxuICAgIFwibGluZVwiLFxuICAgIFwiZmlsdGVyXCIsXG4gICAgXCJtYXJrZXJcIixcbiAgICBcIm1hc2tcIixcbiAgICBcIm1ldGFkYXRhXCIsXG4gICAgXCJwYXRoXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJwb2x5Z29uXCIsXG4gICAgXCJwb2x5bGluZVwiLFxuICAgIFwicmVjdFwiLFxuICAgIFwic3RvcFwiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcInN2Z1wiLFxuICAgIFwidGV4dFwiLFxuICAgIFwidHNwYW5cIixcbiAgICBcInVzZVwiLFxuICAgIFwidmlld1wiLFxuXTtcblxuZXhwb3J0IHsgbG93ZXJjYXNlU1ZHRWxlbWVudHMgfTtcbiIsImltcG9ydCB7IGxvd2VyY2FzZVNWR0VsZW1lbnRzIH0gZnJvbSAnLi4vLi4vc3ZnL2xvd2VyY2FzZS1lbGVtZW50cy5tanMnO1xuXG5mdW5jdGlvbiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICBpZiAoXG4gICAgLyoqXG4gICAgICogSWYgaXQncyBub3QgYSBzdHJpbmcsIGl0J3MgYSBjdXN0b20gUmVhY3QgY29tcG9uZW50LiBDdXJyZW50bHkgd2Ugb25seSBzdXBwb3J0XG4gICAgICogSFRNTCBjdXN0b20gUmVhY3QgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICB0eXBlb2YgQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBpdCBjb250YWlucyBhIGRhc2gsIHRoZSBlbGVtZW50IGlzIGEgY3VzdG9tIEhUTUwgd2ViY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50LmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8qKlxuICAgICAqIElmIGl0J3MgaW4gb3VyIGxpc3Qgb2YgbG93ZXJjYXNlIFNWRyB0YWdzLCBpdCdzIGFuIFNWRyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBsb3dlcmNhc2VTVkdFbGVtZW50cy5pbmRleE9mKENvbXBvbmVudCkgPiAtMSB8fFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaXQgY29udGFpbnMgYSBjYXBpdGFsIGxldHRlciwgaXQncyBhbiBTVkcgY29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICAvW0EtWl0vdS50ZXN0KENvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IHsgaXNTVkdDb21wb25lbnQgfTtcbiIsImltcG9ydCB7IHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uc3RhbnQgdmFsdWUgb3ZlciB0aGUgbGlmZWN5Y2xlIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEV2ZW4gaWYgYHVzZU1lbW9gIGlzIHByb3ZpZGVkIGFuIGVtcHR5IGFycmF5IGFzIGl0cyBmaW5hbCBhcmd1bWVudCwgaXQgZG9lc24ndCBvZmZlclxuICogYSBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCByZS1ydW4gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgbGF0ZXIgb24uIEJ5IHVzaW5nIGB1c2VDb25zdGFudGBcbiAqIHlvdSBjYW4gZW5zdXJlIHRoYXQgaW5pdGlhbGlzZXJzIGRvbid0IGV4ZWN1dGUgdHdpY2Ugb3IgbW9yZS5cbiAqL1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBpbml0KCk7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuZXhwb3J0IHsgdXNlQ29uc3RhbnQgfTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanMnO1xuaW1wb3J0IHsgTW90aW9uQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvTW90aW9uQ29udGV4dC9pbmRleC5tanMnO1xuaW1wb3J0IHsgUHJlc2VuY2VDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmltcG9ydCB7IGlzQ29udHJvbGxpbmdWYXJpYW50cywgaXNWYXJpYW50Tm9kZSB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9pcy1jb250cm9sbGluZy12YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvcmVzb2x2ZS12YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcbmltcG9ydCB7IHJlc29sdmVNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL3Jlc29sdmUtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZSh7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcywgY3JlYXRlUmVuZGVyU3RhdGUsIG9uVXBkYXRlLCB9LCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGxhdGVzdFZhbHVlczogbWFrZUxhdGVzdFZhbHVlcyhwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0LCBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMpLFxuICAgICAgICByZW5kZXJTdGF0ZTogY3JlYXRlUmVuZGVyU3RhdGUoKSxcbiAgICB9O1xuICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogb25Nb3VudCB3b3JrcyB3aXRob3V0IHRoZSBWaXN1YWxFbGVtZW50IGJlY2F1c2UgaXQgY291bGQgYmVcbiAgICAgICAgICogY2FsbGVkIGJlZm9yZSB0aGUgVmlzdWFsRWxlbWVudCBwYXlsb2FkIGhhcyBiZWVuIGh5ZHJhdGVkLlxuICAgICAgICAgKiAoZS5nLiBpZiBzb21lb25lIGlzIHVzaW5nIG0gY29tcG9uZW50cyA8bS5jaXJjbGUgLz4pXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0ZS5vbk1vdW50ID0gKGluc3RhbmNlKSA9PiBvblVwZGF0ZSh7IHByb3BzLCBjdXJyZW50OiBpbnN0YW5jZSwgLi4uc3RhdGUgfSk7XG4gICAgICAgIHN0YXRlLm9uVXBkYXRlID0gKHZpc3VhbEVsZW1lbnQpID0+IG9uVXBkYXRlKHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG59XG5jb25zdCBtYWtlVXNlVmlzdWFsU3RhdGUgPSAoY29uZmlnKSA9PiAocHJvcHMsIGlzU3RhdGljKSA9PiB7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoTW90aW9uQ29udGV4dCk7XG4gICAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gdXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIGNvbnN0IG1ha2UgPSAoKSA9PiBtYWtlU3RhdGUoY29uZmlnLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KTtcbiAgICByZXR1cm4gaXNTdGF0aWMgPyBtYWtlKCkgOiB1c2VDb25zdGFudChtYWtlKTtcbn07XG5mdW5jdGlvbiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlcykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHt9O1xuICAgIGNvbnN0IG1vdGlvblZhbHVlcyA9IHNjcmFwZU1vdGlvblZhbHVlcyhwcm9wcywge30pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG1vdGlvblZhbHVlcykge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHJlc29sdmVNb3Rpb25WYWx1ZShtb3Rpb25WYWx1ZXNba2V5XSk7XG4gICAgfVxuICAgIGxldCB7IGluaXRpYWwsIGFuaW1hdGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzQ29udHJvbGxpbmdWYXJpYW50cyQxID0gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICBjb25zdCBpc1ZhcmlhbnROb2RlJDEgPSBpc1ZhcmlhbnROb2RlKHByb3BzKTtcbiAgICBpZiAoY29udGV4dCAmJlxuICAgICAgICBpc1ZhcmlhbnROb2RlJDEgJiZcbiAgICAgICAgIWlzQ29udHJvbGxpbmdWYXJpYW50cyQxICYmXG4gICAgICAgIHByb3BzLmluaGVyaXQgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChpbml0aWFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBpbml0aWFsID0gY29udGV4dC5pbml0aWFsO1xuICAgICAgICBpZiAoYW5pbWF0ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYW5pbWF0ZSA9IGNvbnRleHQuYW5pbWF0ZTtcbiAgICB9XG4gICAgbGV0IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBwcmVzZW5jZUNvbnRleHRcbiAgICAgICAgPyBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCA9PT0gZmFsc2VcbiAgICAgICAgOiBmYWxzZTtcbiAgICBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkID0gaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCB8fCBpbml0aWFsID09PSBmYWxzZTtcbiAgICBjb25zdCB2YXJpYW50VG9TZXQgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkID8gYW5pbWF0ZSA6IGluaXRpYWw7XG4gICAgaWYgKHZhcmlhbnRUb1NldCAmJlxuICAgICAgICB0eXBlb2YgdmFyaWFudFRvU2V0ICE9PSBcImJvb2xlYW5cIiAmJlxuICAgICAgICAhaXNBbmltYXRpb25Db250cm9scyh2YXJpYW50VG9TZXQpKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRUb1NldCkgPyB2YXJpYW50VG9TZXQgOiBbdmFyaWFudFRvU2V0XTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBsaXN0W2ldKTtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbiwgLi4udGFyZ2V0IH0gPSByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUYWtlIGZpbmFsIGtleWZyYW1lIGlmIHRoZSBpbml0aWFsIGFuaW1hdGlvbiBpcyBibG9ja2VkIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlIHdhbnQgdG8gaW5pdGlhbGlzZSBhdCB0aGUgZW5kIG9mIHRoYXQgYmxvY2tlZCBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVUYXJnZXQubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlVGFyZ2V0ID0gdmFsdWVUYXJnZXRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB2YWx1ZVRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0cmFuc2l0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0gdHJhbnNpdGlvbkVuZFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuXG5leHBvcnQgeyBtYWtlVXNlVmlzdWFsU3RhdGUgfTtcbiIsIi8qKlxuICogUHJvdmlkZWQgYSB2YWx1ZSBhbmQgYSBWYWx1ZVR5cGUsIHJldHVybnMgdGhlIHZhbHVlIGFzIHRoYXQgdmFsdWUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0VmFsdWVBc1R5cGUgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbn07XG5cbmV4cG9ydCB7IGdldFZhbHVlQXNUeXBlIH07XG4iLCJpbXBvcnQgeyBnZXRWYWx1ZUFzVHlwZSB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanMnO1xuaW1wb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVByb3BPcmRlciB9IGZyb20gJy4va2V5cy10cmFuc2Zvcm0ubWpzJztcblxuY29uc3QgdHJhbnNsYXRlQWxpYXMgPSB7XG4gICAgeDogXCJ0cmFuc2xhdGVYXCIsXG4gICAgeTogXCJ0cmFuc2xhdGVZXCIsXG4gICAgejogXCJ0cmFuc2xhdGVaXCIsXG4gICAgdHJhbnNmb3JtUGVyc3BlY3RpdmU6IFwicGVyc3BlY3RpdmVcIixcbn07XG5jb25zdCBudW1UcmFuc2Zvcm1zID0gdHJhbnNmb3JtUHJvcE9yZGVyLmxlbmd0aDtcbi8qKlxuICogQnVpbGQgYSBDU1MgdHJhbnNmb3JtIHN0eWxlIGZyb20gaW5kaXZpZHVhbCB4L3kvc2NhbGUgZXRjIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBvdXRwdXRzIHdpdGggYSBkZWZhdWx0IG9yZGVyIG9mIHRyYW5zZm9ybXMvc2NhbGVzL3JvdGF0aW9ucywgdGhpcyBjYW4gYmUgY3VzdG9taXNlZCBieVxuICogcHJvdmlkaW5nIGEgdHJhbnNmb3JtVGVtcGxhdGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtKGxhdGVzdFZhbHVlcywgdHJhbnNmb3JtLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIC8vIFRoZSB0cmFuc2Zvcm0gc3RyaW5nIHdlJ3JlIGdvaW5nIHRvIGJ1aWxkIGludG8uXG4gICAgbGV0IHRyYW5zZm9ybVN0cmluZyA9IFwiXCI7XG4gICAgbGV0IHRyYW5zZm9ybUlzRGVmYXVsdCA9IHRydWU7XG4gICAgLyoqXG4gICAgICogTG9vcCBvdmVyIGFsbCBwb3NzaWJsZSB0cmFuc2Zvcm1zIGluIG9yZGVyLCBhZGRpbmcgdGhlIG9uZXMgdGhhdFxuICAgICAqIGFyZSBwcmVzZW50IHRvIHRoZSB0cmFuc2Zvcm0gc3RyaW5nLlxuICAgICAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVHJhbnNmb3JtczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRyYW5zZm9ybVByb3BPcmRlcltpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgbGV0IHZhbHVlSXNEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdmFsdWVJc0RlZmF1bHQgPSB2YWx1ZSA9PT0gKGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZUlzRGVmYXVsdCA9IHBhcnNlRmxvYXQodmFsdWUpID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsdWVJc0RlZmF1bHQgfHwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlQXNUeXBlID0gZ2V0VmFsdWVBc1R5cGUodmFsdWUsIG51bWJlclZhbHVlVHlwZXNba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXZhbHVlSXNEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSXNEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtTmFtZSA9IHRyYW5zbGF0ZUFsaWFzW2tleV0gfHwga2V5O1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVN0cmluZyArPSBgJHt0cmFuc2Zvcm1OYW1lfSgke3ZhbHVlQXNUeXBlfSkgYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtU3RyaW5nID0gdHJhbnNmb3JtU3RyaW5nLnRyaW0oKTtcbiAgICAvLyBJZiB3ZSBoYXZlIGEgY3VzdG9tIGB0cmFuc2Zvcm1gIHRlbXBsYXRlLCBwYXNzIG91ciB0cmFuc2Zvcm0gdmFsdWVzIGFuZFxuICAgIC8vIGdlbmVyYXRlZCB0cmFuc2Zvcm1TdHJpbmcgdG8gdGhhdCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVRlbXBsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtSXNEZWZhdWx0ID8gXCJcIiA6IHRyYW5zZm9ybVN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyYW5zZm9ybUlzRGVmYXVsdCkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZm9ybVN0cmluZztcbn1cblxuZXhwb3J0IHsgYnVpbGRUcmFuc2Zvcm0gfTtcbiIsImltcG9ydCB7IGlzQ1NTVmFyaWFibGVOYW1lIH0gZnJvbSAnLi4vLi4vZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanMnO1xuaW1wb3J0IHsgZ2V0VmFsdWVBc1R5cGUgfSBmcm9tICcuLi8uLi9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUubWpzJztcbmltcG9ydCB7IG51bWJlclZhbHVlVHlwZXMgfSBmcm9tICcuLi8uLi9kb20vdmFsdWUtdHlwZXMvbnVtYmVyLm1qcyc7XG5pbXBvcnQgeyBidWlsZFRyYW5zZm9ybSB9IGZyb20gJy4vYnVpbGQtdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4va2V5cy10cmFuc2Zvcm0ubWpzJztcblxuZnVuY3Rpb24gYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3RWYWx1ZXMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgY29uc3QgeyBzdHlsZSwgdmFycywgdHJhbnNmb3JtT3JpZ2luIH0gPSBzdGF0ZTtcbiAgICAvLyBUcmFjayB3aGV0aGVyIHdlIGVuY291bnRlciBhbnkgdHJhbnNmb3JtIG9yIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMuXG4gICAgbGV0IGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgIGxldCBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBMb29wIG92ZXIgYWxsIG91ciBsYXRlc3QgYW5pbWF0ZWQgdmFsdWVzIGFuZCBkZWNpZGUgd2hldGhlciB0byBoYW5kbGUgdGhlbVxuICAgICAqIGFzIGEgc3R5bGUgb3IgQ1NTIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVHJhbnNmb3JtcyBhbmQgdHJhbnNmb3JtIG9yaWdpbnMgYXJlIGtlcHQgc2VwYXJhdGVseSBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIGZvciAoY29uc3Qga2V5IGluIGxhdGVzdFZhbHVlcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGxhdGVzdFZhbHVlc1trZXldO1xuICAgICAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0cmFuc2Zvcm0sIGZsYWcgdG8gZW5hYmxlIGZ1cnRoZXIgdHJhbnNmb3JtIHByb2Nlc3NpbmdcbiAgICAgICAgICAgIGhhc1RyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0NTU1ZhcmlhYmxlTmFtZShrZXkpKSB7XG4gICAgICAgICAgICB2YXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gaXRzIGRlZmF1bHQgdmFsdWUgdHlwZSwgaWUgMCAtPiBcIjBweFwiXG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFzVHlwZSA9IGdldFZhbHVlQXNUeXBlKHZhbHVlLCBudW1iZXJWYWx1ZVR5cGVzW2tleV0pO1xuICAgICAgICAgICAgaWYgKGtleS5zdGFydHNXaXRoKFwib3JpZ2luXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRyYW5zZm9ybSBvcmlnaW4sIGZsYWcgYW5kIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybS1vcmlnaW4gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybU9yaWdpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtT3JpZ2luW2tleV0gPVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWxhdGVzdFZhbHVlcy50cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gYnVpbGRUcmFuc2Zvcm0obGF0ZXN0VmFsdWVzLCBzdGF0ZS50cmFuc2Zvcm0sIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBwcmV2aW91c2x5IGNyZWF0ZWQgYSB0cmFuc2Zvcm0gYnV0IGN1cnJlbnRseSBkb24ndCBoYXZlIGFueSxcbiAgICAgICAgICAgICAqIHJlc2V0IHRyYW5zZm9ybSBzdHlsZSB0byBub25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBcIm5vbmVcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHRyYW5zZm9ybU9yaWdpbiBzdHlsZS4gVXNlcyB0aGUgc2FtZSBkZWZhdWx0cyBhcyB0aGUgYnJvd3NlciBmb3JcbiAgICAgKiB1bmRlZmluZWQgb3JpZ2lucy5cbiAgICAgKi9cbiAgICBpZiAoaGFzVHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luWCA9IFwiNTAlXCIsIG9yaWdpblkgPSBcIjUwJVwiLCBvcmlnaW5aID0gMCwgfSA9IHRyYW5zZm9ybU9yaWdpbjtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYCR7b3JpZ2luWH0gJHtvcmlnaW5ZfSAke29yaWdpblp9YDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9O1xuIiwiaW1wb3J0IHsgcHggfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL3VuaXRzLm1qcyc7XG5cbmNvbnN0IGRhc2hLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICAgIGFycmF5OiBcInN0cm9rZS1kYXNoYXJyYXlcIixcbn07XG5jb25zdCBjYW1lbEtleXMgPSB7XG4gICAgb2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgICBhcnJheTogXCJzdHJva2VEYXNoYXJyYXlcIixcbn07XG4vKipcbiAqIEJ1aWxkIFNWRyBwYXRoIHByb3BlcnRpZXMuIFVzZXMgdGhlIHBhdGgncyBtZWFzdXJlZCBsZW5ndGggdG8gY29udmVydFxuICogb3VyIGN1c3RvbSBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZyBhbmQgcGF0aE9mZnNldCBpbnRvIHN0cm9rZS1kYXNob2Zmc2V0XG4gKiBhbmQgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbXV0YXRpdmUgdG8gcmVkdWNlIHBlci1mcmFtZSBHQy5cbiAqL1xuZnVuY3Rpb24gYnVpbGRTVkdQYXRoKGF0dHJzLCBsZW5ndGgsIHNwYWNpbmcgPSAxLCBvZmZzZXQgPSAwLCB1c2VEYXNoQ2FzZSA9IHRydWUpIHtcbiAgICAvLyBOb3JtYWxpc2UgcGF0aCBsZW5ndGggYnkgc2V0dGluZyBTVkcgYXR0cmlidXRlIHBhdGhMZW5ndGggdG8gMVxuICAgIGF0dHJzLnBhdGhMZW5ndGggPSAxO1xuICAgIC8vIFdlIHVzZSBkYXNoIGNhc2Ugd2hlbiBzZXR0aW5nIGF0dHJpYnV0ZXMgZGlyZWN0bHkgdG8gdGhlIERPTSBub2RlIGFuZCBjYW1lbCBjYXNlXG4gICAgLy8gd2hlbiBkZWZpbmluZyBwcm9wcyBvbiBhIFJlYWN0IGNvbXBvbmVudC5cbiAgICBjb25zdCBrZXlzID0gdXNlRGFzaENhc2UgPyBkYXNoS2V5cyA6IGNhbWVsS2V5cztcbiAgICAvLyBCdWlsZCB0aGUgZGFzaCBvZmZzZXRcbiAgICBhdHRyc1trZXlzLm9mZnNldF0gPSBweC50cmFuc2Zvcm0oLW9mZnNldCk7XG4gICAgLy8gQnVpbGQgdGhlIGRhc2ggYXJyYXlcbiAgICBjb25zdCBwYXRoTGVuZ3RoID0gcHgudHJhbnNmb3JtKGxlbmd0aCk7XG4gICAgY29uc3QgcGF0aFNwYWNpbmcgPSBweC50cmFuc2Zvcm0oc3BhY2luZyk7XG4gICAgYXR0cnNba2V5cy5hcnJheV0gPSBgJHtwYXRoTGVuZ3RofSAke3BhdGhTcGFjaW5nfWA7XG59XG5cbmV4cG9ydCB7IGJ1aWxkU1ZHUGF0aCB9O1xuIiwiaW1wb3J0IHsgcHggfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9udW1iZXJzL3VuaXRzLm1qcyc7XG5cbmZ1bmN0aW9uIGNhbGNPcmlnaW4ob3JpZ2luLCBvZmZzZXQsIHNpemUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IG9yaWdpblxuICAgICAgICA6IHB4LnRyYW5zZm9ybShvZmZzZXQgKyBzaXplICogb3JpZ2luKTtcbn1cbi8qKlxuICogVGhlIFNWRyB0cmFuc2Zvcm0gb3JpZ2luIGRlZmF1bHRzIGFyZSBkaWZmZXJlbnQgdG8gQ1NTIGFuZCBpcyBsZXNzIGludHVpdGl2ZSxcbiAqIHNvIHdlIHVzZSB0aGUgbWVhc3VyZWQgZGltZW5zaW9ucyBvZiB0aGUgU1ZHIHRvIHJlY29uY2lsZSB0aGVzZS5cbiAqL1xuZnVuY3Rpb24gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgY29uc3QgcHhPcmlnaW5YID0gY2FsY09yaWdpbihvcmlnaW5YLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMud2lkdGgpO1xuICAgIGNvbnN0IHB4T3JpZ2luWSA9IGNhbGNPcmlnaW4ob3JpZ2luWSwgZGltZW5zaW9ucy55LCBkaW1lbnNpb25zLmhlaWdodCk7XG4gICAgcmV0dXJuIGAke3B4T3JpZ2luWH0gJHtweE9yaWdpbll9YDtcbn1cblxuZXhwb3J0IHsgY2FsY1NWR1RyYW5zZm9ybU9yaWdpbiB9O1xuIiwiaW1wb3J0IHsgYnVpbGRIVE1MU3R5bGVzIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy9idWlsZC1zdHlsZXMubWpzJztcbmltcG9ydCB7IGJ1aWxkU1ZHUGF0aCB9IGZyb20gJy4vcGF0aC5tanMnO1xuaW1wb3J0IHsgY2FsY1NWR1RyYW5zZm9ybU9yaWdpbiB9IGZyb20gJy4vdHJhbnNmb3JtLW9yaWdpbi5tanMnO1xuXG4vKipcbiAqIEJ1aWxkIFNWRyB2aXN1YWwgYXR0cmJ1dGVzLCBsaWtlIGN4IGFuZCBzdHlsZS50cmFuc2Zvcm1cbiAqL1xuZnVuY3Rpb24gYnVpbGRTVkdBdHRycyhzdGF0ZSwgeyBhdHRyWCwgYXR0clksIGF0dHJTY2FsZSwgb3JpZ2luWCwgb3JpZ2luWSwgcGF0aExlbmd0aCwgcGF0aFNwYWNpbmcgPSAxLCBwYXRoT2Zmc2V0ID0gMCwgXG4vLyBUaGlzIGlzIG9iamVjdCBjcmVhdGlvbiwgd2hpY2ggd2UgdHJ5IHRvIGF2b2lkIHBlci1mcmFtZS5cbi4uLmxhdGVzdCB9LCBpc1NWR1RhZywgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIGxhdGVzdCwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIC8qKlxuICAgICAqIEZvciBzdmcgdGFncyB3ZSBqdXN0IHdhbnQgdG8gbWFrZSBzdXJlIHZpZXdCb3ggaXMgYW5pbWF0YWJsZSBhbmQgdHJlYXQgYWxsIHRoZSBzdHlsZXNcbiAgICAgKiBhcyBub3JtYWwgSFRNTCB0YWdzLlxuICAgICAqL1xuICAgIGlmIChpc1NWR1RhZykge1xuICAgICAgICBpZiAoc3RhdGUuc3R5bGUudmlld0JveCkge1xuICAgICAgICAgICAgc3RhdGUuYXR0cnMudmlld0JveCA9IHN0YXRlLnN0eWxlLnZpZXdCb3g7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdGF0ZS5hdHRycyA9IHN0YXRlLnN0eWxlO1xuICAgIHN0YXRlLnN0eWxlID0ge307XG4gICAgY29uc3QgeyBhdHRycywgc3R5bGUsIGRpbWVuc2lvbnMgfSA9IHN0YXRlO1xuICAgIC8qKlxuICAgICAqIEhvd2V2ZXIsIHdlIGFwcGx5IHRyYW5zZm9ybXMgYXMgQ1NTIHRyYW5zZm9ybXMuIFNvIGlmIHdlIGRldGVjdCBhIHRyYW5zZm9ybSB3ZSB0YWtlIGl0IGZyb20gYXR0cnNcbiAgICAgKiBhbmQgY29weSBpdCBpbnRvIHN0eWxlLlxuICAgICAqL1xuICAgIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMpXG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBhdHRycy50cmFuc2Zvcm07XG4gICAgICAgIGRlbGV0ZSBhdHRycy50cmFuc2Zvcm07XG4gICAgfVxuICAgIC8vIFBhcnNlIHRyYW5zZm9ybU9yaWdpblxuICAgIGlmIChkaW1lbnNpb25zICYmXG4gICAgICAgIChvcmlnaW5YICE9PSB1bmRlZmluZWQgfHwgb3JpZ2luWSAhPT0gdW5kZWZpbmVkIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YICE9PSB1bmRlZmluZWQgPyBvcmlnaW5YIDogMC41LCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgPyBvcmlnaW5ZIDogMC41KTtcbiAgICB9XG4gICAgLy8gUmVuZGVyIGF0dHJYL2F0dHJZL2F0dHJTY2FsZSBhcyBhdHRyaWJ1dGVzXG4gICAgaWYgKGF0dHJYICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgICBpZiAoYXR0clkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueSA9IGF0dHJZO1xuICAgIGlmIChhdHRyU2NhbGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMuc2NhbGUgPSBhdHRyU2NhbGU7XG4gICAgLy8gQnVpbGQgU1ZHIHBhdGggaWYgb25lIGhhcyBiZWVuIGRlZmluZWRcbiAgICBpZiAocGF0aExlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJ1aWxkU1ZHUGF0aChhdHRycywgcGF0aExlbmd0aCwgcGF0aFNwYWNpbmcsIHBhdGhPZmZzZXQsIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkU1ZHQXR0cnMgfTtcbiIsImNvbnN0IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9ICgpID0+ICh7XG4gICAgc3R5bGU6IHt9LFxuICAgIHRyYW5zZm9ybToge30sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB7fSxcbiAgICB2YXJzOiB7fSxcbn0pO1xuXG5leHBvcnQgeyBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuXG5jb25zdCBjcmVhdGVTdmdSZW5kZXJTdGF0ZSA9ICgpID0+ICh7XG4gICAgLi4uY3JlYXRlSHRtbFJlbmRlclN0YXRlKCksXG4gICAgYXR0cnM6IHt9LFxufSk7XG5cbmV4cG9ydCB7IGNyZWF0ZVN2Z1JlbmRlclN0YXRlIH07XG4iLCJjb25zdCBpc1NWR1RhZyA9ICh0YWcpID0+IHR5cGVvZiB0YWcgPT09IFwic3RyaW5nXCIgJiYgdGFnLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCI7XG5cbmV4cG9ydCB7IGlzU1ZHVGFnIH07XG4iLCJmdW5jdGlvbiByZW5kZXJIVE1MKGVsZW1lbnQsIHsgc3R5bGUsIHZhcnMgfSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSwgcHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmdldFByb2plY3Rpb25TdHlsZXMoc3R5bGVQcm9wKSk7XG4gICAgLy8gTG9vcCBvdmVyIGFueSBDU1MgdmFyaWFibGVzIGFuZCBhc3NpZ24gdGhvc2UuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFyc1trZXldKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHJlbmRlckhUTUwgfTtcbiIsIi8qKlxuICogQSBzZXQgb2YgYXR0cmlidXRlIG5hbWVzIHRoYXQgYXJlIGFsd2F5cyByZWFkL3dyaXR0ZW4gYXMgY2FtZWwgY2FzZS5cbiAqL1xuY29uc3QgY2FtZWxDYXNlQXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgIFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgIFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgXCJrZXJuZWxNYXRyaXhcIixcbiAgICBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgICBcImtleVNwbGluZXNcIixcbiAgICBcImtleVRpbWVzXCIsXG4gICAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgIFwibWFya2VySGVpZ2h0XCIsXG4gICAgXCJtYXJrZXJXaWR0aFwiLFxuICAgIFwibnVtT2N0YXZlc1wiLFxuICAgIFwidGFyZ2V0WFwiLFxuICAgIFwidGFyZ2V0WVwiLFxuICAgIFwic3VyZmFjZVNjYWxlXCIsXG4gICAgXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgXCJzdGREZXZpYXRpb25cIixcbiAgICBcInRhYmxlVmFsdWVzXCIsXG4gICAgXCJ2aWV3Qm94XCIsXG4gICAgXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICAgIFwicGF0aExlbmd0aFwiLFxuICAgIFwic3RhcnRPZmZzZXRcIixcbiAgICBcInRleHRMZW5ndGhcIixcbiAgICBcImxlbmd0aEFkanVzdFwiLFxuXSk7XG5cbmV4cG9ydCB7IGNhbWVsQ2FzZUF0dHJpYnV0ZXMgfTtcbiIsImltcG9ydCB7IGNhbWVsVG9EYXNoIH0gZnJvbSAnLi4vLi4vZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzJztcbmltcG9ydCB7IHJlbmRlckhUTUwgfSBmcm9tICcuLi8uLi9odG1sL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgY2FtZWxDYXNlQXR0cmlidXRlcyB9IGZyb20gJy4vY2FtZWwtY2FzZS1hdHRycy5tanMnO1xuXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUsIF9zdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICByZW5kZXJIVE1MKGVsZW1lbnQsIHJlbmRlclN0YXRlLCB1bmRlZmluZWQsIHByb2plY3Rpb24pO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHJlbmRlclN0YXRlLmF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCFjYW1lbENhc2VBdHRyaWJ1dGVzLmhhcyhrZXkpID8gY2FtZWxUb0Rhc2goa2V5KSA6IGtleSwgcmVuZGVyU3RhdGUuYXR0cnNba2V5XSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyByZW5kZXJTVkcgfTtcbiIsImltcG9ydCB7IHNjYWxlQ29ycmVjdG9ycyB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVByb3BzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcblxuZnVuY3Rpb24gaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHsgbGF5b3V0LCBsYXlvdXRJZCB9KSB7XG4gICAgcmV0dXJuICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSB8fFxuICAgICAgICAoKGxheW91dCB8fCBsYXlvdXRJZCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKCEhc2NhbGVDb3JyZWN0b3JzW2tleV0gfHwga2V5ID09PSBcIm9wYWNpdHlcIikpKTtcbn1cblxuZXhwb3J0IHsgaXNGb3JjZWRNb3Rpb25WYWx1ZSB9O1xuIiwiaW1wb3J0IHsgaXNGb3JjZWRNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uLy4uL21vdGlvbi91dGlscy9pcy1mb3JjZWQtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc3R5bGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHN0eWxlKSB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHN0eWxlW2tleV0pIHx8XG4gICAgICAgICAgICAocHJldlByb3BzLnN0eWxlICYmXG4gICAgICAgICAgICAgICAgaXNNb3Rpb25WYWx1ZShwcmV2UHJvcHMuc3R5bGVba2V5XSkpIHx8XG4gICAgICAgICAgICBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgcHJvcHMpIHx8XG4gICAgICAgICAgICAoKF9hID0gdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saXZlU3R5bGUpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1trZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG5leHBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfTtcbiIsImltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IHRyYW5zZm9ybVByb3BPcmRlciB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyBhcyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMSB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcblxuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMShwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShwcm9wc1trZXldKSB8fFxuICAgICAgICAgICAgaXNNb3Rpb25WYWx1ZShwcmV2UHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRyYW5zZm9ybVByb3BPcmRlci5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgICAgICAgICAgICAgPyBcImF0dHJcIiArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgICA6IGtleTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1t0YXJnZXRLZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG5leHBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfTtcbiIsImltcG9ydCB7IGZyYW1lIH0gZnJvbSAnLi4vLi4vZnJhbWVsb29wL2ZyYW1lLm1qcyc7XG5pbXBvcnQgeyBtYWtlVXNlVmlzdWFsU3RhdGUgfSBmcm9tICcuLi8uLi9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcHMgfSBmcm9tICcuLi9odG1sL3V0aWxzL2tleXMtdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBidWlsZFNWR0F0dHJzIH0gZnJvbSAnLi91dGlscy9idWlsZC1hdHRycy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlU3ZnUmVuZGVyU3RhdGUgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZS1yZW5kZXItc3RhdGUubWpzJztcbmltcG9ydCB7IGlzU1ZHVGFnIH0gZnJvbSAnLi91dGlscy9pcy1zdmctdGFnLm1qcyc7XG5pbXBvcnQgeyByZW5kZXJTVkcgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuXG5mdW5jdGlvbiB1cGRhdGVTVkdEaW1lbnNpb25zKGluc3RhbmNlLCByZW5kZXJTdGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPVxuICAgICAgICAgICAgdHlwZW9mIGluc3RhbmNlLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgID8gaW5zdGFuY2UuZ2V0QkJveCgpXG4gICAgICAgICAgICAgICAgOiBpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gTW9zdCBsaWtlbHkgdHJ5aW5nIHRvIG1lYXN1cmUgYW4gdW5yZW5kZXJlZCBlbGVtZW50IHVuZGVyIEZpcmVmb3hcbiAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3QgbGF5b3V0UHJvcHMgPSBbXCJ4XCIsIFwieVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCIsIFwiY3hcIiwgXCJjeVwiLCBcInJcIl07XG5jb25zdCBzdmdNb3Rpb25Db25maWcgPSB7XG4gICAgdXNlVmlzdWFsU3RhdGU6IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlU3ZnUmVuZGVyU3RhdGUsXG4gICAgICAgIG9uVXBkYXRlOiAoeyBwcm9wcywgcHJldlByb3BzLCBjdXJyZW50LCByZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IGhhc1RyYW5zZm9ybSA9ICEhcHJvcHMuZHJhZztcbiAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbGF0ZXN0VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IG5lZWRzTWVhc3VyZSA9ICFwcmV2UHJvcHM7XG4gICAgICAgICAgICBpZiAocHJldlByb3BzKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgdGhlIGxheW91dCBwcm9wcyBmb3IgY2hhbmdlcywgaWYgYW55IGFyZSBmb3VuZCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICogbWVhc3VyZSB0aGUgZWxlbWVudCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheW91dFByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGxheW91dFByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPT1cbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZQcm9wc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZWVkc01lYXN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZWVkc01lYXN1cmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZnJhbWUucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU1ZHRGltZW5zaW9ucyhjdXJyZW50LCByZW5kZXJTdGF0ZSk7XG4gICAgICAgICAgICAgICAgZnJhbWUucmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBpc1NWR1RhZyhjdXJyZW50LnRhZ05hbWUpLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlclNWRyhjdXJyZW50LCByZW5kZXJTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCB7IHN2Z01vdGlvbkNvbmZpZyB9O1xuIiwiaW1wb3J0IHsgbWFrZVVzZVZpc3VhbFN0YXRlIH0gZnJvbSAnLi4vLi4vbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtc3RhdGUubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuXG5jb25zdCBodG1sTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsXG4gICAgICAgIGNyZWF0ZVJlbmRlclN0YXRlOiBjcmVhdGVIdG1sUmVuZGVyU3RhdGUsXG4gICAgfSksXG59O1xuXG5leHBvcnQgeyBodG1sTW90aW9uQ29uZmlnIH07XG4iLCJpbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNGb3JjZWRNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL21vdGlvbi91dGlscy9pcy1mb3JjZWQtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBidWlsZEhUTUxTdHlsZXMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLXN0eWxlcy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlSHRtbFJlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbmZ1bmN0aW9uIGNvcHlSYXdWYWx1ZXNPbmx5KHRhcmdldCwgc291cmNlLCBwcm9wcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoIWlzTW90aW9uVmFsdWUoc291cmNlW2tleV0pICYmICFpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgcHJvcHMpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlSW5pdGlhbE1vdGlvblZhbHVlcyh7IHRyYW5zZm9ybVRlbXBsYXRlIH0sIHZpc3VhbFN0YXRlKSB7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIHZpc3VhbFN0YXRlLCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS52YXJzLCBzdGF0ZS5zdHlsZSk7XG4gICAgfSwgW3Zpc3VhbFN0YXRlXSk7XG59XG5mdW5jdGlvbiB1c2VTdHlsZShwcm9wcywgdmlzdWFsU3RhdGUpIHtcbiAgICBjb25zdCBzdHlsZVByb3AgPSBwcm9wcy5zdHlsZSB8fCB7fTtcbiAgICBjb25zdCBzdHlsZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIENvcHkgbm9uLU1vdGlvbiBWYWx1ZXMgc3RyYWlnaHQgaW50byBzdHlsZVxuICAgICAqL1xuICAgIGNvcHlSYXdWYWx1ZXNPbmx5KHN0eWxlLCBzdHlsZVByb3AsIHByb3BzKTtcbiAgICBPYmplY3QuYXNzaWduKHN0eWxlLCB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHByb3BzLCB2aXN1YWxTdGF0ZSkpO1xuICAgIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHVzZUhUTUxQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUpIHtcbiAgICAvLyBUaGUgYGFueWAgaXNuJ3QgaWRlYWwgYnV0IGl0IGlzIHRoZSB0eXBlIG9mIGNyZWF0ZUVsZW1lbnQgcHJvcHMgYXJndW1lbnRcbiAgICBjb25zdCBodG1sUHJvcHMgPSB7fTtcbiAgICBjb25zdCBzdHlsZSA9IHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSk7XG4gICAgaWYgKHByb3BzLmRyYWcgJiYgcHJvcHMuZHJhZ0xpc3RlbmVyICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBEaXNhYmxlIHRoZSBnaG9zdCBlbGVtZW50IHdoZW4gYSB1c2VyIGRyYWdzXG4gICAgICAgIGh0bWxQcm9wcy5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgLy8gRGlzYWJsZSB0ZXh0IHNlbGVjdGlvblxuICAgICAgICBzdHlsZS51c2VyU2VsZWN0ID1cbiAgICAgICAgICAgIHN0eWxlLldlYmtpdFVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgICAgIHN0eWxlLldlYmtpdFRvdWNoQ2FsbG91dCA9XG4gICAgICAgICAgICAgICAgICAgIFwibm9uZVwiO1xuICAgICAgICAvLyBEaXNhYmxlIHNjcm9sbGluZyBvbiB0aGUgZHJhZ2dhYmxlIGRpcmVjdGlvblxuICAgICAgICBzdHlsZS50b3VjaEFjdGlvbiA9XG4gICAgICAgICAgICBwcm9wcy5kcmFnID09PSB0cnVlXG4gICAgICAgICAgICAgICAgPyBcIm5vbmVcIlxuICAgICAgICAgICAgICAgIDogYHBhbi0ke3Byb3BzLmRyYWcgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIn1gO1xuICAgIH1cbiAgICBpZiAocHJvcHMudGFiSW5kZXggPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAocHJvcHMub25UYXAgfHwgcHJvcHMub25UYXBTdGFydCB8fCBwcm9wcy53aGlsZVRhcCkpIHtcbiAgICAgICAgaHRtbFByb3BzLnRhYkluZGV4ID0gMDtcbiAgICB9XG4gICAgaHRtbFByb3BzLnN0eWxlID0gc3R5bGU7XG4gICAgcmV0dXJuIGh0bWxQcm9wcztcbn1cblxuZXhwb3J0IHsgY29weVJhd1ZhbHVlc09ubHksIHVzZUhUTUxQcm9wcyB9O1xuIiwiLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIHZhbGlkIE1vdGlvblByb3BzLlxuICpcbiAqIEBwcml2YXRlUmVtYXJrc1xuICogVGhpcyBkb2Vzbid0IHRocm93IGlmIGEgYE1vdGlvblByb3BgIG5hbWUgaXMgbWlzc2luZyAtIGl0IHNob3VsZC5cbiAqL1xuY29uc3QgdmFsaWRNb3Rpb25Qcm9wcyA9IG5ldyBTZXQoW1xuICAgIFwiYW5pbWF0ZVwiLFxuICAgIFwiZXhpdFwiLFxuICAgIFwidmFyaWFudHNcIixcbiAgICBcImluaXRpYWxcIixcbiAgICBcInN0eWxlXCIsXG4gICAgXCJ2YWx1ZXNcIixcbiAgICBcInZhcmlhbnRzXCIsXG4gICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgXCJ0cmFuc2Zvcm1UZW1wbGF0ZVwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbmhlcml0XCIsXG4gICAgXCJvbkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgICBcIm9uQW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIm9uQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIm9uVXBkYXRlXCIsXG4gICAgXCJvbkRyYWdTdGFydFwiLFxuICAgIFwib25EcmFnXCIsXG4gICAgXCJvbkRyYWdFbmRcIixcbiAgICBcIm9uTWVhc3VyZURyYWdDb25zdHJhaW50c1wiLFxuICAgIFwib25EaXJlY3Rpb25Mb2NrXCIsXG4gICAgXCJvbkRyYWdUcmFuc2l0aW9uRW5kXCIsXG4gICAgXCJfZHJhZ1hcIixcbiAgICBcIl9kcmFnWVwiLFxuICAgIFwib25Ib3ZlclN0YXJ0XCIsXG4gICAgXCJvbkhvdmVyRW5kXCIsXG4gICAgXCJvblZpZXdwb3J0RW50ZXJcIixcbiAgICBcIm9uVmlld3BvcnRMZWF2ZVwiLFxuICAgIFwiZ2xvYmFsVGFwVGFyZ2V0XCIsXG4gICAgXCJpZ25vcmVTdHJpY3RcIixcbiAgICBcInZpZXdwb3J0XCIsXG5dKTtcbi8qKlxuICogQ2hlY2sgd2hldGhlciBhIHByb3AgbmFtZSBpcyBhIHZhbGlkIGBNb3Rpb25Qcm9wYCBrZXkuXG4gKlxuICogQHBhcmFtIGtleSAtIE5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIGNoZWNrXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaXMga2V5IGlzIGEgdmFsaWQgYE1vdGlvblByb3BgLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZE1vdGlvblByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIChrZXkuc3RhcnRzV2l0aChcIndoaWxlXCIpIHx8XG4gICAgICAgIChrZXkuc3RhcnRzV2l0aChcImRyYWdcIikgJiYga2V5ICE9PSBcImRyYWdnYWJsZVwiKSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcImxheW91dFwiKSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9uVGFwXCIpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwib25QYW5cIikgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJvbkxheW91dFwiKSB8fFxuICAgICAgICB2YWxpZE1vdGlvblByb3BzLmhhcyhrZXkpKTtcbn1cblxuZXhwb3J0IHsgaXNWYWxpZE1vdGlvblByb3AgfTtcbiIsImltcG9ydCB7IGlzVmFsaWRNb3Rpb25Qcm9wIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzJztcblxubGV0IHNob3VsZEZvcndhcmQgPSAoa2V5KSA9PiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KTtcbmZ1bmN0aW9uIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKGlzVmFsaWRQcm9wKSB7XG4gICAgaWYgKCFpc1ZhbGlkUHJvcClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEV4cGxpY2l0bHkgZmlsdGVyIG91ciBldmVudHNcbiAgICBzaG91bGRGb3J3YXJkID0gKGtleSkgPT4ga2V5LnN0YXJ0c1dpdGgoXCJvblwiKSA/ICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpIDogaXNWYWxpZFByb3Aoa2V5KTtcbn1cbi8qKlxuICogRW1vdGlvbiBhbmQgU3R5bGVkIENvbXBvbmVudHMgYm90aCBhbGxvdyB1c2VycyB0byBwYXNzIHRocm91Z2ggYXJiaXRyYXJ5IHByb3BzIHRvIHRoZWlyIGNvbXBvbmVudHNcbiAqIHRvIGR5bmFtaWNhbGx5IGdlbmVyYXRlIENTUy4gVGhleSBib3RoIHVzZSB0aGUgYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgIHBhY2thZ2UgdG8gZGV0ZXJtaW5lIHdoaWNoXG4gKiBvZiB0aGVzZSBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlLlxuICpcbiAqIEhvd2V2ZXIsIHdoZW4gc3R5bGluZyBhIE1vdGlvbiBjb21wb25lbnQgYHN0eWxlZChtb3Rpb24uZGl2KWAsIGJvdGggcGFja2FnZXMgcGFzcyB0aHJvdWdoICphbGwqIHByb3BzXG4gKiBhcyBpdCdzIHNlZW4gYXMgYW4gYXJiaXRyYXJ5IGNvbXBvbmVudCByYXRoZXIgdGhhbiBhIERPTSBub2RlLiBNb3Rpb24gb25seSBhbGxvd3MgYXJiaXRyYXJ5IHByb3BzXG4gKiBwYXNzZWQgdGhyb3VnaCB0aGUgYGN1c3RvbWAgcHJvcCBzbyBpdCBkb2Vzbid0ICpuZWVkKiB0aGUgcGF5bG9hZCBvciBjb21wdXRhdGlvbmFsIG92ZXJoZWFkIG9mXG4gKiBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAsIGhvd2V2ZXIgdG8gZml4IHRoaXMgcHJvYmxlbSB3ZSBuZWVkIHRvIHVzZSBpdC5cbiAqXG4gKiBCeSBtYWtpbmcgaXQgYW4gb3B0aW9uYWxEZXBlbmRlbmN5IHdlIGNhbiBvZmZlciB0aGlzIGZ1bmN0aW9uYWxpdHkgb25seSBpbiB0aGUgc2l0dWF0aW9ucyB3aGVyZSBpdCdzXG4gKiBhY3R1YWxseSByZXF1aXJlZC5cbiAqL1xudHJ5IHtcbiAgICAvKipcbiAgICAgKiBXZSBhdHRlbXB0IHRvIGltcG9ydCB0aGlzIHBhY2thZ2UgYnV0IHJlcXVpcmUgd29uJ3QgYmUgZGVmaW5lZCBpbiBlc20gZW52aXJvbm1lbnRzLCBpbiB0aGF0IGNhc2VcbiAgICAgKiBpc1Byb3BWYWxpZCB3aWxsIGhhdmUgdG8gYmUgcHJvdmlkZWQgdmlhIGBNb3Rpb25Db250ZXh0YC4gSW4gYSA2LjAuMCB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSByZW1vdmVkXG4gICAgICogaW4gZmF2b3VyIG9mIGV4cGxpY2l0IGluamVjdGlvbi5cbiAgICAgKi9cbiAgICBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChyZXF1aXJlKFwiQGVtb3Rpb24vaXMtcHJvcC12YWxpZFwiKS5kZWZhdWx0KTtcbn1cbmNhdGNoIChfYSkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gYWN0dWFsbHkgZG8gYW55dGhpbmcgaGVyZSAtIHRoZSBmYWxsYmFjayBpcyB0aGUgZXhpc3RpbmcgYGlzUHJvcFZhbGlkYC5cbn1cbmZ1bmN0aW9uIGZpbHRlclByb3BzKHByb3BzLCBpc0RvbSwgZm9yd2FyZE1vdGlvblByb3BzKSB7XG4gICAgY29uc3QgZmlsdGVyZWRQcm9wcyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2YWx1ZXMgaXMgY29uc2lkZXJlZCBhIHZhbGlkIHByb3AgYnkgRW1vdGlvbiwgc28gaWYgaXQncyBwcmVzZW50XG4gICAgICAgICAqIHRoaXMgd2lsbCBiZSByZW5kZXJlZCBvdXQgdG8gdGhlIERPTSB1bmxlc3MgZXhwbGljaXRseSBmaWx0ZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2UgY2hlY2sgdGhlIHR5cGUgYXMgaXQgY291bGQgYmUgdXNlZCB3aXRoIHRoZSBgZmVDb2xvck1hdHJpeGBcbiAgICAgICAgICogZWxlbWVudCwgd2hpY2ggd2Ugc3VwcG9ydC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChrZXkgPT09IFwidmFsdWVzXCIgJiYgdHlwZW9mIHByb3BzLnZhbHVlcyA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoc2hvdWxkRm9yd2FyZChrZXkpIHx8XG4gICAgICAgICAgICAoZm9yd2FyZE1vdGlvblByb3BzID09PSB0cnVlICYmIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkpIHx8XG4gICAgICAgICAgICAoIWlzRG9tICYmICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpKSB8fFxuICAgICAgICAgICAgLy8gSWYgdHJ5aW5nIHRvIHVzZSBuYXRpdmUgSFRNTCBkcmFnIGV2ZW50cywgZm9yd2FyZCBkcmFnIGxpc3RlbmVyc1xuICAgICAgICAgICAgKHByb3BzW1wiZHJhZ2dhYmxlXCJdICYmXG4gICAgICAgICAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJvbkRyYWdcIikpKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFByb3BzW2tleV0gPVxuICAgICAgICAgICAgICAgIHByb3BzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkUHJvcHM7XG59XG5cbmV4cG9ydCB7IGZpbHRlclByb3BzLCBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcCB9O1xuIiwiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGNvcHlSYXdWYWx1ZXNPbmx5IH0gZnJvbSAnLi4vaHRtbC91c2UtcHJvcHMubWpzJztcbmltcG9ydCB7IGJ1aWxkU1ZHQXR0cnMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLWF0dHJzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdmdSZW5kZXJTdGF0ZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgaXNTVkdUYWcgfSBmcm9tICcuL3V0aWxzL2lzLXN2Zy10YWcubWpzJztcblxuZnVuY3Rpb24gdXNlU1ZHUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlLCBfaXNTdGF0aWMsIENvbXBvbmVudCkge1xuICAgIGNvbnN0IHZpc3VhbFByb3BzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlU3ZnUmVuZGVyU3RhdGUoKTtcbiAgICAgICAgYnVpbGRTVkdBdHRycyhzdGF0ZSwgdmlzdWFsU3RhdGUsIGlzU1ZHVGFnKENvbXBvbmVudCksIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmF0dHJzLFxuICAgICAgICAgICAgc3R5bGU6IHsgLi4uc3RhdGUuc3R5bGUgfSxcbiAgICAgICAgfTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbiAgICBpZiAocHJvcHMuc3R5bGUpIHtcbiAgICAgICAgY29uc3QgcmF3U3R5bGVzID0ge307XG4gICAgICAgIGNvcHlSYXdWYWx1ZXNPbmx5KHJhd1N0eWxlcywgcHJvcHMuc3R5bGUsIHByb3BzKTtcbiAgICAgICAgdmlzdWFsUHJvcHMuc3R5bGUgPSB7IC4uLnJhd1N0eWxlcywgLi4udmlzdWFsUHJvcHMuc3R5bGUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc3VhbFByb3BzO1xufVxuXG5leHBvcnQgeyB1c2VTVkdQcm9wcyB9O1xuIiwiaW1wb3J0IHsgRnJhZ21lbnQsIHVzZU1lbW8sIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VIVE1MUHJvcHMgfSBmcm9tICcuLi9odG1sL3VzZS1wcm9wcy5tanMnO1xuaW1wb3J0IHsgZmlsdGVyUHJvcHMgfSBmcm9tICcuL3V0aWxzL2ZpbHRlci1wcm9wcy5tanMnO1xuaW1wb3J0IHsgaXNTVkdDb21wb25lbnQgfSBmcm9tICcuL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzJztcbmltcG9ydCB7IHVzZVNWR1Byb3BzIH0gZnJvbSAnLi4vc3ZnL3VzZS1wcm9wcy5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzID0gZmFsc2UpIHtcbiAgICBjb25zdCB1c2VSZW5kZXIgPSAoQ29tcG9uZW50LCBwcm9wcywgcmVmLCB7IGxhdGVzdFZhbHVlcyB9LCBpc1N0YXRpYykgPT4ge1xuICAgICAgICBjb25zdCB1c2VWaXN1YWxQcm9wcyA9IGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgICAgID8gdXNlU1ZHUHJvcHNcbiAgICAgICAgICAgIDogdXNlSFRNTFByb3BzO1xuICAgICAgICBjb25zdCB2aXN1YWxQcm9wcyA9IHVzZVZpc3VhbFByb3BzKHByb3BzLCBsYXRlc3RWYWx1ZXMsIGlzU3RhdGljLCBDb21wb25lbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZFByb3BzID0gZmlsdGVyUHJvcHMocHJvcHMsIHR5cGVvZiBDb21wb25lbnQgPT09IFwic3RyaW5nXCIsIGZvcndhcmRNb3Rpb25Qcm9wcyk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQcm9wcyA9IENvbXBvbmVudCAhPT0gRnJhZ21lbnRcbiAgICAgICAgICAgID8geyAuLi5maWx0ZXJlZFByb3BzLCAuLi52aXN1YWxQcm9wcywgcmVmIH1cbiAgICAgICAgICAgIDoge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjb21wb25lbnQgaGFzIGJlZW4gaGFuZGVkIGEgbW90aW9uIHZhbHVlIGFzIGl0cyBjaGlsZCxcbiAgICAgICAgICogbWVtb2lzZSBpdHMgaW5pdGlhbCB2YWx1ZSBhbmQgcmVuZGVyIHRoYXQuIFN1YnNlcXVlbnQgdXBkYXRlc1xuICAgICAgICAgKiB3aWxsIGJlIGhhbmRsZWQgYnkgdGhlIG9uQ2hhbmdlIGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHByb3BzO1xuICAgICAgICBjb25zdCByZW5kZXJlZENoaWxkcmVuID0gdXNlTWVtbygoKSA9PiAoaXNNb3Rpb25WYWx1ZShjaGlsZHJlbikgPyBjaGlsZHJlbi5nZXQoKSA6IGNoaWxkcmVuKSwgW2NoaWxkcmVuXSk7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KENvbXBvbmVudCwge1xuICAgICAgICAgICAgLi4uZWxlbWVudFByb3BzLFxuICAgICAgICAgICAgY2hpbGRyZW46IHJlbmRlcmVkQ2hpbGRyZW4sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIHVzZVJlbmRlcjtcbn1cblxuZXhwb3J0IHsgY3JlYXRlVXNlUmVuZGVyIH07XG4iLCJpbXBvcnQgeyBjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL21vdGlvbi9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNTVkdDb21wb25lbnQgfSBmcm9tICcuLi9kb20vdXRpbHMvaXMtc3ZnLWNvbXBvbmVudC5tanMnO1xuaW1wb3J0IHsgc3ZnTW90aW9uQ29uZmlnIH0gZnJvbSAnLi4vc3ZnL2NvbmZpZy1tb3Rpb24ubWpzJztcbmltcG9ydCB7IGh0bWxNb3Rpb25Db25maWcgfSBmcm9tICcuLi9odG1sL2NvbmZpZy1tb3Rpb24ubWpzJztcbmltcG9ydCB7IGNyZWF0ZVVzZVJlbmRlciB9IGZyb20gJy4uL2RvbS91c2UtcmVuZGVyLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvbkNvbXBvbmVudEZhY3RvcnkocHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlTW90aW9uQ29tcG9uZW50KENvbXBvbmVudCwgeyBmb3J3YXJkTW90aW9uUHJvcHMgfSA9IHsgZm9yd2FyZE1vdGlvblByb3BzOiBmYWxzZSB9KSB7XG4gICAgICAgIGNvbnN0IGJhc2VDb25maWcgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgICAgICA/IHN2Z01vdGlvbkNvbmZpZ1xuICAgICAgICAgICAgOiBodG1sTW90aW9uQ29uZmlnO1xuICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAuLi5iYXNlQ29uZmlnLFxuICAgICAgICAgICAgcHJlbG9hZGVkRmVhdHVyZXMsXG4gICAgICAgICAgICB1c2VSZW5kZXI6IGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMpLFxuICAgICAgICAgICAgY3JlYXRlVmlzdWFsRWxlbWVudCxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50KGNvbmZpZyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeSB9O1xuIiwiLy8gRG9lcyB0aGlzIGRldmljZSBwcmVmZXIgcmVkdWNlZCBtb3Rpb24/IFJldHVybnMgYG51bGxgIHNlcnZlci1zaWRlLlxuY29uc3QgcHJlZmVyc1JlZHVjZWRNb3Rpb24gPSB7IGN1cnJlbnQ6IG51bGwgfTtcbmNvbnN0IGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lciA9IHsgY3VycmVudDogZmFsc2UgfTtcblxuZXhwb3J0IHsgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLCBwcmVmZXJzUmVkdWNlZE1vdGlvbiB9O1xuIiwiaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi4vaXMtYnJvd3Nlci5tanMnO1xuaW1wb3J0IHsgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLCBwcmVmZXJzUmVkdWNlZE1vdGlvbiB9IGZyb20gJy4vc3RhdGUubWpzJztcblxuZnVuY3Rpb24gaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCkge1xuICAgIGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lci5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpZiAoIWlzQnJvd3NlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgICBjb25zdCBtb3Rpb25NZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgICAgIGNvbnN0IHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyA9ICgpID0+IChwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gbW90aW9uTWVkaWFRdWVyeS5tYXRjaGVzKTtcbiAgICAgICAgbW90aW9uTWVkaWFRdWVyeS5hZGRMaXN0ZW5lcihzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMpO1xuICAgICAgICBzZXRSZWR1Y2VkTW90aW9uUHJlZmVyZW5jZXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbiB9O1xuIiwiaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS90eXBlcy9jb2xvci9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29tcGxleCB9IGZyb20gJy4uLy4uLy4uL3ZhbHVlL3R5cGVzL2NvbXBsZXgvaW5kZXgubWpzJztcbmltcG9ydCB7IGRpbWVuc2lvblZhbHVlVHlwZXMgfSBmcm9tICcuL2RpbWVuc2lvbnMubWpzJztcbmltcG9ydCB7IHRlc3RWYWx1ZVR5cGUgfSBmcm9tICcuL3Rlc3QubWpzJztcblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIFZhbHVlVHlwZXNcbiAqL1xuY29uc3QgdmFsdWVUeXBlcyA9IFsuLi5kaW1lbnNpb25WYWx1ZVR5cGVzLCBjb2xvciwgY29tcGxleF07XG4vKipcbiAqIFRlc3RzIGEgdmFsdWUgYWdhaW5zdCB0aGUgbGlzdCBvZiBWYWx1ZVR5cGVzXG4gKi9cbmNvbnN0IGZpbmRWYWx1ZVR5cGUgPSAodikgPT4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xuXG5leHBvcnQgeyBmaW5kVmFsdWVUeXBlIH07XG4iLCJjb25zdCB2aXN1YWxFbGVtZW50U3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgeyB2aXN1YWxFbGVtZW50U3RvcmUgfTtcbiIsImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2Fybi1vbmNlLm1qcyc7XG5pbXBvcnQgeyBtb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBuZXh0LCBwcmV2KSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbmV4dCkge1xuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSBuZXh0W2tleV07XG4gICAgICAgIGNvbnN0IHByZXZWYWx1ZSA9IHByZXZba2V5XTtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbW90aW9uIHZhbHVlIGZvdW5kIGluIHByb3BzIG9yIHN0eWxlLCB3ZSB3YW50IHRvIGFkZCBpdFxuICAgICAgICAgICAgICogdG8gb3VyIHZpc3VhbCBlbGVtZW50J3MgbW90aW9uIHZhbHVlIG1hcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG5leHRWYWx1ZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIHRoZSB2ZXJzaW9uIG9mIHRoZSBpbmNvbWluZyBtb3Rpb24gdmFsdWUgd2l0aCB0aGlzIHZlcnNpb25cbiAgICAgICAgICAgICAqIGFuZCB3YXJuIGFnYWluc3QgbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZShuZXh0VmFsdWUudmVyc2lvbiA9PT0gXCIxMi4wLjZcIiwgYEF0dGVtcHRpbmcgdG8gbWl4IE1vdGlvbiB2ZXJzaW9ucyAke25leHRWYWx1ZS52ZXJzaW9ufSB3aXRoIDEyLjAuNiBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHN3YXBwaW5nIGZyb20gYSBtb3Rpb24gdmFsdWUgdG8gYSBzdGF0aWMgdmFsdWUsXG4gICAgICAgICAgICAgKiBjcmVhdGUgYSBuZXcgbW90aW9uIHZhbHVlIGZyb20gdGhhdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobmV4dFZhbHVlLCB7IG93bmVyOiBlbGVtZW50IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgZmxhdCB2YWx1ZSB0aGF0IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZVxuICAgICAgICAgICAgICogb3IgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBpZiB3ZSdyZVxuICAgICAgICAgICAgICogbm90IGhhbmRsaW5nIHRoZSB2YWx1ZSB3aXRoIG91ciBhbmltYXRpb24gc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1ZhbHVlLmxpdmVTdHlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlLmp1bXAobmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nVmFsdWUuaGFzQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZS5zZXQobmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IGVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobGF0ZXN0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGxhdGVzdFZhbHVlIDogbmV4dFZhbHVlLCB7IG93bmVyOiBlbGVtZW50IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVtb3ZlZCB2YWx1ZXNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgIGlmIChuZXh0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG59XG5cbmV4cG9ydCB7IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9O1xuIiwiaW1wb3J0IHsgdGltZSB9IGZyb20gJy4uL2ZyYW1lbG9vcC9zeW5jLXRpbWUubWpzJztcbmltcG9ydCB7IGZlYXR1cmVEZWZpbml0aW9ucyB9IGZyb20gJy4uL21vdGlvbi9mZWF0dXJlcy9kZWZpbml0aW9ucy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQm94IH0gZnJvbSAnLi4vcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzJztcbmltcG9ydCB7IGlzTnVtZXJpY2FsU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvaXMtbnVtZXJpY2FsLXN0cmluZy5tanMnO1xuaW1wb3J0IHsgaXNaZXJvVmFsdWVTdHJpbmcgfSBmcm9tICcuLi91dGlscy9pcy16ZXJvLXZhbHVlLXN0cmluZy5tanMnO1xuaW1wb3J0IHsgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uIH0gZnJvbSAnLi4vdXRpbHMvcmVkdWNlZC1tb3Rpb24vaW5kZXgubWpzJztcbmltcG9ydCB7IGhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lciwgcHJlZmVyc1JlZHVjZWRNb3Rpb24gfSBmcm9tICcuLi91dGlscy9yZWR1Y2VkLW1vdGlvbi9zdGF0ZS5tanMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9IGZyb20gJy4uL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uL3V0aWxzL3dhcm4tb25jZS5tanMnO1xuaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuLi92YWx1ZS9pbmRleC5tanMnO1xuaW1wb3J0IHsgY29tcGxleCB9IGZyb20gJy4uL3ZhbHVlL3R5cGVzL2NvbXBsZXgvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGdldEFuaW1hdGFibGVOb25lIH0gZnJvbSAnLi9kb20vdmFsdWUtdHlwZXMvYW5pbWF0YWJsZS1ub25lLm1qcyc7XG5pbXBvcnQgeyBmaW5kVmFsdWVUeXBlIH0gZnJvbSAnLi9kb20vdmFsdWUtdHlwZXMvZmluZC5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcHMgfSBmcm9tICcuL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHZpc3VhbEVsZW1lbnRTdG9yZSB9IGZyb20gJy4vc3RvcmUubWpzJztcbmltcG9ydCB7IGlzQ29udHJvbGxpbmdWYXJpYW50cywgaXNWYXJpYW50Tm9kZSB9IGZyb20gJy4vdXRpbHMvaXMtY29udHJvbGxpbmctdmFyaWFudHMubWpzJztcbmltcG9ydCB7IEtleWZyYW1lUmVzb2x2ZXIgfSBmcm9tICcuL3V0aWxzL0tleWZyYW1lc1Jlc29sdmVyLm1qcyc7XG5pbXBvcnQgeyB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfSBmcm9tICcuL3V0aWxzL21vdGlvbi12YWx1ZXMubWpzJztcbmltcG9ydCB7IHJlc29sdmVWYXJpYW50RnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9yZXNvbHZlLXZhcmlhbnRzLm1qcyc7XG5pbXBvcnQgeyBmcmFtZSwgY2FuY2VsRnJhbWUgfSBmcm9tICcuLi9mcmFtZWxvb3AvZnJhbWUubWpzJztcblxuY29uc3QgcHJvcEV2ZW50SGFuZGxlcnMgPSBbXG4gICAgXCJBbmltYXRpb25TdGFydFwiLFxuICAgIFwiQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIlVwZGF0ZVwiLFxuICAgIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiTGF5b3V0QW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIkxheW91dEFuaW1hdGlvbkNvbXBsZXRlXCIsXG5dO1xuLyoqXG4gKiBBIFZpc3VhbEVsZW1lbnQgaXMgYW4gaW1wZXJhdGl2ZSBhYnN0cmFjdGlvbiBhcm91bmQgVUkgZWxlbWVudHMgc3VjaCBhc1xuICogSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQsIFRocmVlLk9iamVjdDNEIGV0Yy5cbiAqL1xuY2xhc3MgVmlzdWFsRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdGFrZXMgUmVhY3QgcHJvcHMgYW5kIHJldHVybnMgZm91bmQgTW90aW9uVmFsdWVzLiBGb3IgZXhhbXBsZSwgSFRNTFxuICAgICAqIE1vdGlvblZhbHVlcyB3aWxsIGJlIGZvdW5kIHdpdGhpbiB0aGUgc3R5bGUgcHJvcCwgd2hlcmVhcyBmb3IgVGhyZWUuanMgd2l0aGluIGF0dHJpYnV0ZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzbid0IGFuIGFic3RyYWN0IG1ldGhvZCBhcyBpdCBuZWVkcyBjYWxsaW5nIGluIHRoZSBjb25zdHJ1Y3RvciwgYnV0IGl0IGlzXG4gICAgICogaW50ZW5kZWQgdG8gYmUgb25lLlxuICAgICAqL1xuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhfcHJvcHMsIF9wcmV2UHJvcHMsIF92aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBwYXJlbnQsIHByb3BzLCBwcmVzZW5jZUNvbnRleHQsIHJlZHVjZWRNb3Rpb25Db25maWcsIGJsb2NrSW5pdGlhbEFuaW1hdGlvbiwgdmlzdWFsU3RhdGUsIH0sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgdW5kZXJseWluZyBJbnN0YW5jZSwgZS5nLiBhIEhUTUxFbGVtZW50XG4gICAgICAgICAqIG9yIFRocmVlLk1lc2ggZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2V0IGNvbnRhaW5pbmcgcmVmZXJlbmNlcyB0byB0aGlzIFZpc3VhbEVsZW1lbnQncyBjaGlsZHJlbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBuZXcgU2V0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgd2hhdCByb2xlIHRoaXMgdmlzdWFsIGVsZW1lbnQgc2hvdWxkIHRha2UgaW4gdGhlIHZhcmlhbnQgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVjaWRlcyB3aGV0aGVyIHRoaXMgVmlzdWFsRWxlbWVudCBzaG91bGQgYW5pbWF0ZSBpbiByZWR1Y2VkIG1vdGlvblxuICAgICAgICAgKiBtb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSBzZXQgb24gZXZlcnkgaW5kaXZpZHVhbCBWaXN1YWxFbGVtZW50IGJ1dCBmZWVsc1xuICAgICAgICAgKiBsaWtlIGl0IGNvdWxkIGJlIHNldCBnbG9iYWxseS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIGFsbCBtb3Rpb24gdmFsdWVzIGF0dGFjaGVkIHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuIE1vdGlvblxuICAgICAgICAgKiB2YWx1ZXMgYXJlIHNvdXJjZSBvZiB0cnV0aCBmb3IgYW55IGdpdmVuIGFuaW1hdGVkIHZhbHVlLiBBIG1vdGlvblxuICAgICAgICAgKiB2YWx1ZSBtaWdodCBiZSBwcm92aWRlZCBleHRlcm5hbGx5IGJ5IHRoZSBjb21wb25lbnQgdmlhIHByb3BzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuS2V5ZnJhbWVSZXNvbHZlciA9IEtleWZyYW1lUmVzb2x2ZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbGVhbnVwIGZ1bmN0aW9ucyBmb3IgYWN0aXZlIGZlYXR1cmVzIChob3Zlci90YXAvZXhpdCBldGMpXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBldmVyeSBzdWJzY3JpcHRpb24gdGhhdCBiaW5kcyB0aGUgcHJvdmlkZWQgb3IgZ2VuZXJhdGVkXG4gICAgICAgICAqIG1vdGlvbiB2YWx1ZXMgb25DaGFuZ2UgbGlzdGVuZXJzIHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91c2x5LXByb3ZpZGVkIG1vdGlvbiB2YWx1ZXMgYXMgcmV0dXJuZWRcbiAgICAgICAgICogZnJvbSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMuIFdlIHVzZSB0aGUga2V5cyBpbiBoZXJlIHRvIGRldGVybWluZVxuICAgICAgICAgKiBpZiBhbnkgbW90aW9uIHZhbHVlcyBuZWVkIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXZNb3Rpb25WYWx1ZXMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGEgU3Vic2NyaXB0aW9uTWFuYWdlciBmb3IgZWFjaCBhY3RpdmUgZXZlbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24gZm9yIGVhY2ggcHJvcCBldmVudCBzdWJzY3JpcHRpb24uXG4gICAgICAgICAqIEZvciBleGFtcGxlLCBldmVyeSBcIlVwZGF0ZVwiIGV2ZW50IGNhbiBoYXZlIG11bHRpcGxlIHN1YnNjcmliZXJzIHZpYVxuICAgICAgICAgKiBWaXN1YWxFbGVtZW50Lm9uKCksIGJ1dCBvbmx5IG9uZSBvZiB0aG9zZSBjYW4gYmUgZGVmaW5lZCB2aWEgdGhlIG9uVXBkYXRlIHByb3AuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5ub3RpZnlVcGRhdGUgPSAoKSA9PiB0aGlzLm5vdGlmeShcIlVwZGF0ZVwiLCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyQnVpbGQoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVySW5zdGFuY2UodGhpcy5jdXJyZW50LCB0aGlzLnJlbmRlclN0YXRlLCB0aGlzLnByb3BzLnN0eWxlLCB0aGlzLnByb2plY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlclNjaGVkdWxlZEF0ID0gMC4wO1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gdGltZS5ub3coKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlclNjaGVkdWxlZEF0IDwgbm93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTY2hlZHVsZWRBdCA9IG5vdztcbiAgICAgICAgICAgICAgICBmcmFtZS5yZW5kZXIodGhpcy5yZW5kZXIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBsYXRlc3RWYWx1ZXMsIHJlbmRlclN0YXRlLCBvblVwZGF0ZSB9ID0gdmlzdWFsU3RhdGU7XG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBvblVwZGF0ZTtcbiAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXMgPSBsYXRlc3RWYWx1ZXM7XG4gICAgICAgIHRoaXMuYmFzZVRhcmdldCA9IHsgLi4ubGF0ZXN0VmFsdWVzIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlcyA9IHByb3BzLmluaXRpYWwgPyB7IC4uLmxhdGVzdFZhbHVlcyB9IDoge307XG4gICAgICAgIHRoaXMucmVuZGVyU3RhdGUgPSByZW5kZXJTdGF0ZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNvbnRleHQgPSBwcmVzZW5jZUNvbnRleHQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMDtcbiAgICAgICAgdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID0gcmVkdWNlZE1vdGlvbkNvbmZpZztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5ibG9ja0luaXRpYWxBbmltYXRpb24gPSBCb29sZWFuKGJsb2NrSW5pdGlhbEFuaW1hdGlvbik7XG4gICAgICAgIHRoaXMuaXNDb250cm9sbGluZ1ZhcmlhbnRzID0gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICAgICAgdGhpcy5pc1ZhcmlhbnROb2RlID0gaXNWYXJpYW50Tm9kZShwcm9wcyk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFyaWFudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFudENoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFudWFsbHlBbmltYXRlT25Nb3VudCA9IEJvb2xlYW4ocGFyZW50ICYmIHBhcmVudC5jdXJyZW50KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFueSBtb3Rpb24gdmFsdWVzIHRoYXQgYXJlIHByb3ZpZGVkIHRvIHRoZSBlbGVtZW50IHdoZW4gY3JlYXRlZFxuICAgICAgICAgKiBhcmVuJ3QgeWV0IGJvdW5kIHRvIHRoZSBlbGVtZW50LCBhcyB0aGlzIHdvdWxkIHRlY2huaWNhbGx5IGJlIGltcHVyZS5cbiAgICAgICAgICogSG93ZXZlciwgd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSBtb3Rpb24gdmFsdWVzIGFuZCBzZXQgdGhlbSB0byB0aGVcbiAgICAgICAgICogaW5pdGlhbCB2YWx1ZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUT0RPOiBUaGlzIGlzIGltcHVyZSBhbmQgd2Ugc2hvdWxkIGxvb2sgYXQgY2hhbmdpbmcgdGhpcyB0byBydW4gb24gbW91bnQuXG4gICAgICAgICAqIERvaW5nIHNvIHdpbGwgYnJlYWsgc29tZSB0ZXN0cyBidXQgdGhpcyBpc24ndCBuZWNlc3NhcmlseSBhIGJyZWFraW5nIGNoYW5nZSxcbiAgICAgICAgICogbW9yZSBhIHJlZmxlY3Rpb24gb2YgdGhlIHRlc3QuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB7IHdpbGxDaGFuZ2UsIC4uLmluaXRpYWxNb3Rpb25WYWx1ZXMgfSA9IHRoaXMuc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCB7fSwgdGhpcyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGluaXRpYWxNb3Rpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbE1vdGlvblZhbHVlc1trZXldO1xuICAgICAgICAgICAgaWYgKGxhdGVzdFZhbHVlc1trZXldICE9PSB1bmRlZmluZWQgJiYgaXNNb3Rpb25WYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5zZXQobGF0ZXN0VmFsdWVzW2tleV0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3VudChpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgdmlzdWFsRWxlbWVudFN0b3JlLnNldChpbnN0YW5jZSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnByb2plY3Rpb24gJiYgIXRoaXMucHJvamVjdGlvbi5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uLm1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5pc1ZhcmlhbnROb2RlICYmICF0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVGcm9tVmFyaWFudFRyZWUgPSB0aGlzLnBhcmVudC5hZGRWYXJpYW50Q2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKSk7XG4gICAgICAgIGlmICghaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uID1cbiAgICAgICAgICAgIHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9PT0gXCJuZXZlclwiXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy5yZWR1Y2VkTW90aW9uQ29uZmlnID09PSBcImFsd2F5c1wiXG4gICAgICAgICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICA6IHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQ7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKHRoaXMuc2hvdWxkUmVkdWNlTW90aW9uICE9PSB0cnVlLCBcIllvdSBoYXZlIFJlZHVjZWQgTW90aW9uIGVuYWJsZWQgb24geW91ciBkZXZpY2UuIEFuaW1hdGlvbnMgbWF5IG5vdCBhcHBlYXIgYXMgZXhwZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGUodGhpcy5wcm9wcywgdGhpcy5wcmVzZW5jZUNvbnRleHQpO1xuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgICB2aXN1YWxFbGVtZW50U3RvcmUuZGVsZXRlKHRoaXMuY3VycmVudCk7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbiAmJiB0aGlzLnByb2plY3Rpb24udW5tb3VudCgpO1xuICAgICAgICBjYW5jZWxGcmFtZSh0aGlzLm5vdGlmeVVwZGF0ZSk7XG4gICAgICAgIGNhbmNlbEZyYW1lKHRoaXMucmVuZGVyKTtcbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZm9yRWFjaCgocmVtb3ZlKSA9PiByZW1vdmUoKSk7XG4gICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmNsZWFyKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlICYmIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlKCk7XG4gICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2tleV0uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmZlYXR1cmVzKSB7XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5mZWF0dXJlc1trZXldO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnVubW91bnQoKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICAgIGJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5nZXQoa2V5KSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlSXNUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KTtcbiAgICAgICAgY29uc3QgcmVtb3ZlT25DaGFuZ2UgPSB2YWx1ZS5vbihcImNoYW5nZVwiLCAobGF0ZXN0VmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25VcGRhdGUgJiYgZnJhbWUucHJlUmVuZGVyKHRoaXMubm90aWZ5VXBkYXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZUlzVHJhbnNmb3JtICYmIHRoaXMucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbi5pc1RyYW5zZm9ybURpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uKFwicmVuZGVyUmVxdWVzdFwiLCB0aGlzLnNjaGVkdWxlUmVuZGVyKTtcbiAgICAgICAgbGV0IHJlbW92ZVN5bmNDaGVjaztcbiAgICAgICAgaWYgKHdpbmRvdy5Nb3Rpb25DaGVja0FwcGVhclN5bmMpIHtcbiAgICAgICAgICAgIHJlbW92ZVN5bmNDaGVjayA9IHdpbmRvdy5Nb3Rpb25DaGVja0FwcGVhclN5bmModGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuc2V0KGtleSwgKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3ZlT25DaGFuZ2UoKTtcbiAgICAgICAgICAgIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCgpO1xuICAgICAgICAgICAgaWYgKHJlbW92ZVN5bmNDaGVjaylcbiAgICAgICAgICAgICAgICByZW1vdmVTeW5jQ2hlY2soKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5vd25lcilcbiAgICAgICAgICAgICAgICB2YWx1ZS5zdG9wKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzb3J0Tm9kZVBvc2l0aW9uKG90aGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVzZSBub2RlcyBhcmVuJ3QgZXZlbiBvZiB0aGUgc2FtZSB0eXBlIHdlIGNhbid0IGNvbXBhcmUgdGhlaXIgZGVwdGguXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudCB8fFxuICAgICAgICAgICAgIXRoaXMuc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uIHx8XG4gICAgICAgICAgICB0aGlzLnR5cGUgIT09IG90aGVyLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbih0aGlzLmN1cnJlbnQsIG90aGVyLmN1cnJlbnQpO1xuICAgIH1cbiAgICB1cGRhdGVGZWF0dXJlcygpIHtcbiAgICAgICAgbGV0IGtleSA9IFwiYW5pbWF0aW9uXCI7XG4gICAgICAgIGZvciAoa2V5IGluIGZlYXR1cmVEZWZpbml0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZURlZmluaXRpb24gPSBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGlmICghZmVhdHVyZURlZmluaXRpb24pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCB7IGlzRW5hYmxlZCwgRmVhdHVyZTogRmVhdHVyZUNvbnN0cnVjdG9yIH0gPSBmZWF0dXJlRGVmaW5pdGlvbjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBmZWF0dXJlIGlzIGVuYWJsZWQgYnV0IG5vdCBhY3RpdmUsIG1ha2UgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlc1trZXldICYmXG4gICAgICAgICAgICAgICAgRmVhdHVyZUNvbnN0cnVjdG9yICYmXG4gICAgICAgICAgICAgICAgaXNFbmFibGVkKHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1trZXldID0gbmV3IEZlYXR1cmVDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBhIGZlYXR1cmUsIG1vdW50IG9yIHVwZGF0ZSBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmZlYXR1cmVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuaXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLm1vdW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuaXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJpZ2dlckJ1aWxkKCkge1xuICAgICAgICB0aGlzLmJ1aWxkKHRoaXMucmVuZGVyU3RhdGUsIHRoaXMubGF0ZXN0VmFsdWVzLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBib3ggd2l0aCBvciB3aXRob3V0IHRyYW5zZm9ybXMuXG4gICAgICogT25seSBtZWFzdXJlcyBheGlzLWFsaWduZWQgYm94ZXMsIHJvdGF0ZSBhbmQgc2tldyBtdXN0IGJlIG1hbnVhbGx5XG4gICAgICogcmVtb3ZlZCB3aXRoIGEgcmUtcmVuZGVyIHRvIHdvcmsuXG4gICAgICovXG4gICAgbWVhc3VyZVZpZXdwb3J0Qm94KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50XG4gICAgICAgICAgICA/IHRoaXMubWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3godGhpcy5jdXJyZW50LCB0aGlzLnByb3BzKVxuICAgICAgICAgICAgOiBjcmVhdGVCb3goKTtcbiAgICB9XG4gICAgZ2V0U3RhdGljVmFsdWUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhdGVzdFZhbHVlc1trZXldO1xuICAgIH1cbiAgICBzZXRTdGF0aWNWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBwcm92aWRlZCBwcm9wcy4gRW5zdXJlIGFueSBuZXdseS1hZGRlZCBtb3Rpb24gdmFsdWVzIGFyZVxuICAgICAqIGFkZGVkIHRvIG91ciBtYXAsIG9sZCBvbmVzIHJlbW92ZWQsIGFuZCBsaXN0ZW5lcnMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICB1cGRhdGUocHJvcHMsIHByZXNlbmNlQ29udGV4dCkge1xuICAgICAgICBpZiAocHJvcHMudHJhbnNmb3JtVGVtcGxhdGUgfHwgdGhpcy5wcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldlByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLnByZXZQcmVzZW5jZUNvbnRleHQgPSB0aGlzLnByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgdGhpcy5wcmVzZW5jZUNvbnRleHQgPSBwcmVzZW5jZUNvbnRleHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgcHJvcCBldmVudCBoYW5kbGVycyBpZSBvbkFuaW1hdGlvblN0YXJ0LCBvbkFuaW1hdGlvbkNvbXBsZXRlXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BFdmVudEhhbmRsZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwcm9wRXZlbnRIYW5kbGVyc1tpXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucHJvcEV2ZW50U3Vic2NyaXB0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJOYW1lID0gKFwib25cIiArIGtleSk7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHByb3BzW2xpc3RlbmVyTmFtZV07XG4gICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSA9IHRoaXMub24oa2V5LCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmV2TW90aW9uVmFsdWVzID0gdXBkYXRlTW90aW9uVmFsdWVzRnJvbVByb3BzKHRoaXMsIHRoaXMuc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCB0aGlzLnByZXZQcm9wcywgdGhpcyksIHRoaXMucHJldk1vdGlvblZhbHVlcyk7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZUNoaWxkTW90aW9uVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpbGRNb3Rpb25WYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25VcGRhdGUgJiYgdGhpcy5vblVwZGF0ZSh0aGlzKTtcbiAgICB9XG4gICAgZ2V0UHJvcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2YXJpYW50IGRlZmluaXRpb24gd2l0aCBhIGdpdmVuIG5hbWUuXG4gICAgICovXG4gICAgZ2V0VmFyaWFudChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnZhcmlhbnRzID8gdGhpcy5wcm9wcy52YXJpYW50c1tuYW1lXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVmaW5lZCBkZWZhdWx0IHRyYW5zaXRpb24gb24gdGhpcyBjb21wb25lbnQuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFRyYW5zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRyYW5zaXRpb247XG4gICAgfVxuICAgIGdldFRyYW5zZm9ybVBhZ2VQb2ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIH1cbiAgICBnZXRDbG9zZXN0VmFyaWFudE5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFyaWFudE5vZGVcbiAgICAgICAgICAgID8gdGhpc1xuICAgICAgICAgICAgOiB0aGlzLnBhcmVudFxuICAgICAgICAgICAgICAgID8gdGhpcy5wYXJlbnQuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKClcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgY2hpbGQgdmlzdWFsIGVsZW1lbnQgdG8gb3VyIHNldCBvZiBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBhZGRWYXJpYW50Q2hpbGQoY2hpbGQpIHtcbiAgICAgICAgY29uc3QgY2xvc2VzdFZhcmlhbnROb2RlID0gdGhpcy5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICAgICAgaWYgKGNsb3Nlc3RWYXJpYW50Tm9kZSkge1xuICAgICAgICAgICAgY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbiAmJlxuICAgICAgICAgICAgICAgIGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4uYWRkKGNoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmRlbGV0ZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbW90aW9uIHZhbHVlIGFuZCBiaW5kIGl0IHRvIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICovXG4gICAgYWRkVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgdmFsdWUgaWYgaXQgZXhpc3RzXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nVmFsdWUgPSB0aGlzLnZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBleGlzdGluZ1ZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdWYWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVZhbHVlKGtleSk7XG4gICAgICAgICAgICB0aGlzLmJpbmRUb01vdGlvblZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlLmdldCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIG1vdGlvbiB2YWx1ZSBhbmQgdW5iaW5kIGFueSBhY3RpdmUgc3Vic2NyaXB0aW9ucy5cbiAgICAgKi9cbiAgICByZW1vdmVWYWx1ZShrZXkpIHtcbiAgICAgICAgdGhpcy52YWx1ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmRlbGV0ZShrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmxhdGVzdFZhbHVlc1trZXldO1xuICAgICAgICB0aGlzLnJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgdGhpcy5yZW5kZXJTdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIG1vdGlvbiB2YWx1ZSBmb3IgdGhpcyBrZXlcbiAgICAgKi9cbiAgICBoYXNWYWx1ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzLmhhcyhrZXkpO1xuICAgIH1cbiAgICBnZXRWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy52YWx1ZXMgJiYgdGhpcy5wcm9wcy52YWx1ZXNba2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMudmFsdWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG1vdGlvblZhbHVlKGRlZmF1bHRWYWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IGRlZmF1bHRWYWx1ZSwgeyBvd25lcjogdGhpcyB9KTtcbiAgICAgICAgICAgIHRoaXMuYWRkVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSB0cnlpbmcgdG8gYW5pbWF0ZSB0byBhIHByZXZpb3VzbHkgdW5lbmNvdW50ZXJlZCB2YWx1ZSxcbiAgICAgKiB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdCBpbiBvdXIgc3RhdGUgYW5kIGFzIGEgbGFzdCByZXNvcnQgcmVhZCBpdFxuICAgICAqIGRpcmVjdGx5IGZyb20gdGhlIGluc3RhbmNlICh3aGljaCBtaWdodCBoYXZlIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucykuXG4gICAgICovXG4gICAgcmVhZFZhbHVlKGtleSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5sYXRlc3RWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkIHx8ICF0aGlzLmN1cnJlbnRcbiAgICAgICAgICAgID8gdGhpcy5sYXRlc3RWYWx1ZXNba2V5XVxuICAgICAgICAgICAgOiAoX2EgPSB0aGlzLmdldEJhc2VUYXJnZXRGcm9tUHJvcHModGhpcy5wcm9wcywga2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yZWFkVmFsdWVGcm9tSW5zdGFuY2UodGhpcy5jdXJyZW50LCBrZXksIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgKGlzTnVtZXJpY2FsU3RyaW5nKHZhbHVlKSB8fCBpc1plcm9WYWx1ZVN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG51bWJlciByZWFkIGFzIGEgc3RyaW5nLCBpZSBcIjBcIiBvciBcIjIwMFwiLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFmaW5kVmFsdWVUeXBlKHZhbHVlKSAmJiBjb21wbGV4LnRlc3QodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0QW5pbWF0YWJsZU5vbmUoa2V5LCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRCYXNlVGFyZ2V0KGtleSwgaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGJhc2UgdGFyZ2V0IHRvIGxhdGVyIGFuaW1hdGUgYmFjayB0by4gVGhpcyBpcyBjdXJyZW50bHlcbiAgICAgKiBvbmx5IGh5ZHJhdGVkIG9uIGNyZWF0aW9uIGFuZCB3aGVuIHdlIGZpcnN0IHJlYWQgYSB2YWx1ZS5cbiAgICAgKi9cbiAgICBzZXRCYXNlVGFyZ2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5iYXNlVGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgYmFzZSB0YXJnZXQgZm9yIGEgdmFsdWUgdGhhdHMgYmVlbiByZW1vdmVkIGZyb20gYWxsIGFuaW1hdGlvblxuICAgICAqIHByb3BzLlxuICAgICAqL1xuICAgIGdldEJhc2VUYXJnZXQoa2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBsZXQgdmFsdWVGcm9tSW5pdGlhbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbml0aWFsID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBpbml0aWFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBjb25zdCB2YXJpYW50ID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHModGhpcy5wcm9wcywgaW5pdGlhbCwgKF9hID0gdGhpcy5wcmVzZW5jZUNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b20pO1xuICAgICAgICAgICAgaWYgKHZhcmlhbnQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZUZyb21Jbml0aWFsID0gdmFyaWFudFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIHZhbHVlIHN0aWxsIGV4aXN0cyBpbiB0aGUgY3VycmVudCBpbml0aWFsIHZhcmlhbnQsIHJlYWQgdGhhdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpbml0aWFsICYmIHZhbHVlRnJvbUluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlRnJvbUluaXRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsdGVybmF0aXZlbHksIGlmIHRoaXMgVmlzdWFsRWxlbWVudCBjb25maWcgaGFzIGRlZmluZWQgYSBnZXRCYXNlVGFyZ2V0XG4gICAgICAgICAqIHNvIHdlIGNhbiByZWFkIHRoZSB2YWx1ZSBmcm9tIGFuIGFsdGVybmF0aXZlIHNvdXJjZSwgdHJ5IHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEJhc2VUYXJnZXRGcm9tUHJvcHModGhpcy5wcm9wcywga2V5KTtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmICFpc01vdGlvblZhbHVlKHRhcmdldCkpXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHZhbHVlIHdhcyBpbml0aWFsbHkgZGVmaW5lZCBvbiBpbml0aWFsLCBidXQgaXQgZG9lc24ndCBhbnkgbW9yZSxcbiAgICAgICAgICogcmV0dXJuIHVuZGVmaW5lZC4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdmFsdWUgYXMgaW5pdGlhbGx5IHJlYWQgZnJvbSB0aGUgRE9NLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlc1trZXldICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHZhbHVlRnJvbUluaXRpYWwgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogdGhpcy5iYXNlVGFyZ2V0W2tleV07XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5hZGQoY2FsbGJhY2spO1xuICAgIH1cbiAgICBub3RpZnkoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE5hbWVdLm5vdGlmeSguLi5hcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgVmlzdWFsRWxlbWVudCB9O1xuIiwiaW1wb3J0IHsgVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL1Zpc3VhbEVsZW1lbnQubWpzJztcbmltcG9ydCB7IERPTUtleWZyYW1lc1Jlc29sdmVyIH0gZnJvbSAnLi9ET01LZXlmcmFtZXNSZXNvbHZlci5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuXG5jbGFzcyBET01WaXN1YWxFbGVtZW50IGV4dGVuZHMgVmlzdWFsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuS2V5ZnJhbWVSZXNvbHZlciA9IERPTUtleWZyYW1lc1Jlc29sdmVyO1xuICAgIH1cbiAgICBzb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24oYSwgYikge1xuICAgICAgICAvKipcbiAgICAgICAgICogY29tcGFyZURvY3VtZW50UG9zaXRpb24gcmV0dXJucyBhIGJpdG1hc2ssIGJ5IHVzaW5nIHRoZSBiaXR3aXNlICZcbiAgICAgICAgICogd2UncmUgcmV0dXJuaW5nIHRydWUgaWYgMiBpbiB0aGF0IGJpdG1hc2sgaXMgc2V0IHRvIHRydWUuIDIgaXMgc2V0XG4gICAgICAgICAqIHRvIHRydWUgaWYgYiBwcmVjZWVkcyBhLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAyID8gMSA6IC0xO1xuICAgIH1cbiAgICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHByb3BzLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLnN0eWxlXG4gICAgICAgICAgICA/IHByb3BzLnN0eWxlW2tleV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHsgdmFycywgc3R5bGUgfSkge1xuICAgICAgICBkZWxldGUgdmFyc1trZXldO1xuICAgICAgICBkZWxldGUgc3R5bGVba2V5XTtcbiAgICB9XG4gICAgaGFuZGxlQ2hpbGRNb3Rpb25WYWx1ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNoaWxkU3Vic2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2hpbGRyZW4gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN1YnNjcmlwdGlvbiA9IGNoaWxkcmVuLm9uKFwiY2hhbmdlXCIsIChsYXRlc3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudC50ZXh0Q29udGVudCA9IGAke2xhdGVzdH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBET01WaXN1YWxFbGVtZW50IH07XG4iLCJpbXBvcnQgeyBtZWFzdXJlVmlld3BvcnRCb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL3V0aWxzL21lYXN1cmUubWpzJztcbmltcG9ydCB7IERPTVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi9kb20vRE9NVmlzdWFsRWxlbWVudC5tanMnO1xuaW1wb3J0IHsgaXNDU1NWYXJpYWJsZU5hbWUgfSBmcm9tICcuLi9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0VmFsdWVUeXBlIH0gZnJvbSAnLi4vZG9tL3ZhbHVlLXR5cGVzL2RlZmF1bHRzLm1qcyc7XG5pbXBvcnQgeyBidWlsZEhUTUxTdHlsZXMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLXN0eWxlcy5tanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtUHJvcHMgfSBmcm9tICcuL3V0aWxzL2tleXMtdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyByZW5kZXJIVE1MIH0gZnJvbSAnLi91dGlscy9yZW5kZXIubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuY2xhc3MgSFRNTFZpc3VhbEVsZW1lbnQgZXh0ZW5kcyBET01WaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJodG1sXCI7XG4gICAgICAgIHRoaXMucmVuZGVySW5zdGFuY2UgPSByZW5kZXJIVE1MO1xuICAgIH1cbiAgICByZWFkVmFsdWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UsIGtleSkge1xuICAgICAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlID8gZGVmYXVsdFR5cGUuZGVmYXVsdCB8fCAwIDogMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGluc3RhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGlzQ1NTVmFyaWFibGVOYW1lKGtleSlcbiAgICAgICAgICAgICAgICA/IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpXG4gICAgICAgICAgICAgICAgOiBjb21wdXRlZFN0eWxlW2tleV0pIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goaW5zdGFuY2UsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvcHMpIHtcbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEhUTUxWaXN1YWxFbGVtZW50LCBnZXRDb21wdXRlZFN0eWxlIH07XG4iLCJpbXBvcnQgeyBjcmVhdGVCb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L21vZGVscy5tanMnO1xuaW1wb3J0IHsgRE9NVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL2RvbS9ET01WaXN1YWxFbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBjYW1lbFRvRGFzaCB9IGZyb20gJy4uL2RvbS91dGlscy9jYW1lbC10by1kYXNoLm1qcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0VmFsdWVUeXBlIH0gZnJvbSAnLi4vZG9tL3ZhbHVlLXR5cGVzL2RlZmF1bHRzLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4uL2h0bWwvdXRpbHMva2V5cy10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGJ1aWxkU1ZHQXR0cnMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLWF0dHJzLm1qcyc7XG5pbXBvcnQgeyBjYW1lbENhc2VBdHRyaWJ1dGVzIH0gZnJvbSAnLi91dGlscy9jYW1lbC1jYXNlLWF0dHJzLm1qcyc7XG5pbXBvcnQgeyBpc1NWR1RhZyB9IGZyb20gJy4vdXRpbHMvaXMtc3ZnLXRhZy5tanMnO1xuaW1wb3J0IHsgcmVuZGVyU1ZHIH0gZnJvbSAnLi91dGlscy9yZW5kZXIubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcblxuY2xhc3MgU1ZHVmlzdWFsRWxlbWVudCBleHRlbmRzIERPTVZpc3VhbEVsZW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnR5cGUgPSBcInN2Z1wiO1xuICAgICAgICB0aGlzLmlzU1ZHVGFnID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3ggPSBjcmVhdGVCb3g7XG4gICAgfVxuICAgIGdldEJhc2VUYXJnZXRGcm9tUHJvcHMocHJvcHMsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJvcHNba2V5XTtcbiAgICB9XG4gICAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5O1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UuZ2V0QXR0cmlidXRlKGtleSk7XG4gICAgfVxuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMocHJvcHMsIHByZXZQcm9wcywgdmlzdWFsRWxlbWVudCk7XG4gICAgfVxuICAgIGJ1aWxkKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHByb3BzKSB7XG4gICAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgdGhpcy5pc1NWR1RhZywgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgIH1cbiAgICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgICAgICByZW5kZXJTVkcoaW5zdGFuY2UsIHJlbmRlclN0YXRlLCBzdHlsZVByb3AsIHByb2plY3Rpb24pO1xuICAgIH1cbiAgICBtb3VudChpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLmlzU1ZHVGFnID0gaXNTVkdUYWcoaW5zdGFuY2UudGFnTmFtZSk7XG4gICAgICAgIHN1cGVyLm1vdW50KGluc3RhbmNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFNWR1Zpc3VhbEVsZW1lbnQgfTtcbiIsImltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSFRNTFZpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi9odG1sL0hUTUxWaXN1YWxFbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBTVkdWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vc3ZnL1NWR1Zpc3VhbEVsZW1lbnQubWpzJztcbmltcG9ydCB7IGlzU1ZHQ29tcG9uZW50IH0gZnJvbSAnLi91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qcyc7XG5cbmNvbnN0IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgPSAoQ29tcG9uZW50LCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgPyBuZXcgU1ZHVmlzdWFsRWxlbWVudChvcHRpb25zKVxuICAgICAgICA6IG5ldyBIVE1MVmlzdWFsRWxlbWVudChvcHRpb25zLCB7XG4gICAgICAgICAgICBhbGxvd1Byb2plY3Rpb246IENvbXBvbmVudCAhPT0gRnJhZ21lbnQsXG4gICAgICAgIH0pO1xufTtcblxuZXhwb3J0IHsgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCB9O1xuIiwiaW1wb3J0IHsgYW5pbWF0aW9ucyB9IGZyb20gJy4uLy4uLy4uL21vdGlvbi9mZWF0dXJlcy9hbmltYXRpb25zLm1qcyc7XG5pbXBvcnQgeyBkcmFnIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2RyYWcubWpzJztcbmltcG9ydCB7IGdlc3R1cmVBbmltYXRpb25zIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2dlc3R1cmVzLm1qcyc7XG5pbXBvcnQgeyBsYXlvdXQgfSBmcm9tICcuLi8uLi8uLi9tb3Rpb24vZmVhdHVyZXMvbGF5b3V0Lm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVNb3Rpb25Db21wb25lbnRGYWN0b3J5IH0gZnJvbSAnLi4vY3JlYXRlLWZhY3RvcnkubWpzJztcbmltcG9ydCB7IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi8uLi9kb20vY3JlYXRlLXZpc3VhbC1lbGVtZW50Lm1qcyc7XG5cbmNvbnN0IGNyZWF0ZU1vdGlvbkNvbXBvbmVudCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeSh7XG4gICAgLi4uYW5pbWF0aW9ucyxcbiAgICAuLi5nZXN0dXJlQW5pbWF0aW9ucyxcbiAgICAuLi5kcmFnLFxuICAgIC4uLmxheW91dCxcbn0sIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQpO1xuXG5leHBvcnQgeyBjcmVhdGVNb3Rpb25Db21wb25lbnQgfTtcbiIsImltcG9ydCB7IGNyZWF0ZURPTU1vdGlvbkNvbXBvbmVudFByb3h5IH0gZnJvbSAnLi4vY3JlYXRlLXByb3h5Lm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVNb3Rpb25Db21wb25lbnQgfSBmcm9tICcuL2NyZWF0ZS5tanMnO1xuXG5jb25zdCBtb3Rpb24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZURPTU1vdGlvbkNvbXBvbmVudFByb3h5KGNyZWF0ZU1vdGlvbkNvbXBvbmVudCk7XG5cbmV4cG9ydCB7IG1vdGlvbiB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VJZCwgdXNlUmVmLCB1c2VDb250ZXh0LCB1c2VJbnNlcnRpb25FZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyc7XG5cbi8qKlxuICogTWVhc3VyZW1lbnQgZnVuY3Rpb25hbGl0eSBoYXMgdG8gYmUgd2l0aGluIGEgc2VwYXJhdGUgY29tcG9uZW50XG4gKiB0byBsZXZlcmFnZSBzbmFwc2hvdCBsaWZlY3ljbGUuXG4gKi9cbmNsYXNzIFBvcENoaWxkTWVhc3VyZSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnByb3BzLmNoaWxkUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChlbGVtZW50ICYmIHByZXZQcm9wcy5pc1ByZXNlbnQgJiYgIXRoaXMucHJvcHMuaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFdpZHRoID0gcGFyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBwYXJlbnQub2Zmc2V0V2lkdGggfHwgMCA6IDA7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gdGhpcy5wcm9wcy5zaXplUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBzaXplLmhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICBzaXplLndpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAwO1xuICAgICAgICAgICAgc2l6ZS50b3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIHNpemUubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIHNpemUucmlnaHQgPSBwYXJlbnRXaWR0aCAtIHNpemUud2lkdGggLSBzaXplLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVpcmVkIHdpdGggZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgdG8gc3RvcCBSZWFjdCBjb21wbGFpbmluZy5cbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7IH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIFBvcENoaWxkKHsgY2hpbGRyZW4sIGlzUHJlc2VudCwgYW5jaG9yWCB9KSB7XG4gICAgY29uc3QgaWQgPSB1c2VJZCgpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBzaXplID0gdXNlUmVmKHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICB9KTtcbiAgICBjb25zdCB7IG5vbmNlIH0gPSB1c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgIC8qKlxuICAgICAqIFdlIGNyZWF0ZSBhbmQgaW5qZWN0IGEgc3R5bGUgYmxvY2sgc28gd2UgY2FuIGFwcGx5IHRoaXMgZXhwbGljaXRcbiAgICAgKiBzaXppbmcgaW4gYSBub24tZGVzdHJ1Y3RpdmUgbWFubmVyIGJ5IGp1c3QgZGVsZXRpbmcgdGhlIHN0eWxlIGJsb2NrLlxuICAgICAqXG4gICAgICogV2UgY2FuJ3QgYXBwbHkgc2l6ZSB2aWEgcmVuZGVyIGFzIHRoZSBtZWFzdXJlbWVudCBoYXBwZW5zXG4gICAgICogaW4gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgKHBvc3QtcmVuZGVyKSwgbGlrZXdpc2UgaWYgd2UgYXBwbHkgdGhlXG4gICAgICogc3R5bGVzIGRpcmVjdGx5IG9uIHRoZSBET00gbm9kZSwgd2UgbWlnaHQgYmUgb3ZlcndyaXRpbmdcbiAgICAgKiBzdHlsZXMgc2V0IHZpYSB0aGUgc3R5bGUgcHJvcC5cbiAgICAgKi9cbiAgICB1c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCwgcmlnaHQgfSA9IHNpemUuY3VycmVudDtcbiAgICAgICAgaWYgKGlzUHJlc2VudCB8fCAhcmVmLmN1cnJlbnQgfHwgIXdpZHRoIHx8ICFoZWlnaHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHggPSBhbmNob3JYID09PSBcImxlZnRcIiA/IGBsZWZ0OiAke2xlZnR9YCA6IGByaWdodDogJHtyaWdodH1gO1xuICAgICAgICByZWYuY3VycmVudC5kYXRhc2V0Lm1vdGlvblBvcElkID0gaWQ7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgICBpZiAobm9uY2UpXG4gICAgICAgICAgICBzdHlsZS5ub25jZSA9IG5vbmNlO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICAgICAgaWYgKHN0eWxlLnNoZWV0KSB7XG4gICAgICAgICAgICBzdHlsZS5zaGVldC5pbnNlcnRSdWxlKGBcbiAgICAgICAgICBbZGF0YS1tb3Rpb24tcG9wLWlkPVwiJHtpZH1cIl0ge1xuICAgICAgICAgICAgcG9zaXRpb246IGFic29sdXRlICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB3aWR0aDogJHt3aWR0aH1weCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgaGVpZ2h0OiAke2hlaWdodH1weCAhaW1wb3J0YW50O1xuICAgICAgICAgICAgJHt4fXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgICB0b3A6ICR7dG9wfXB4ICFpbXBvcnRhbnQ7XG4gICAgICAgICAgfVxuICAgICAgICBgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICAgIH07XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIHJldHVybiAoanN4KFBvcENoaWxkTWVhc3VyZSwgeyBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgY2hpbGRSZWY6IHJlZiwgc2l6ZVJlZjogc2l6ZSwgY2hpbGRyZW46IFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwgeyByZWYgfSkgfSkpO1xufVxuXG5leHBvcnQgeyBQb3BDaGlsZCB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBqc3ggfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VJZCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBQcmVzZW5jZUNvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L1ByZXNlbmNlQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcbmltcG9ydCB7IFBvcENoaWxkIH0gZnJvbSAnLi9Qb3BDaGlsZC5tanMnO1xuXG5jb25zdCBQcmVzZW5jZUNoaWxkID0gKHsgY2hpbGRyZW4sIGluaXRpYWwsIGlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUsIGN1c3RvbSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0LCBtb2RlLCBhbmNob3JYLCB9KSA9PiB7XG4gICAgY29uc3QgcHJlc2VuY2VDaGlsZHJlbiA9IHVzZUNvbnN0YW50KG5ld0NoaWxkcmVuTWFwKTtcbiAgICBjb25zdCBpZCA9IHVzZUlkKCk7XG4gICAgY29uc3QgbWVtb2l6ZWRPbkV4aXRDb21wbGV0ZSA9IHVzZUNhbGxiYWNrKChjaGlsZElkKSA9PiB7XG4gICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uc2V0KGNoaWxkSWQsIHRydWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGlzQ29tcGxldGUgb2YgcHJlc2VuY2VDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgaWYgKCFpc0NvbXBsZXRlKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gY2FuIHN0b3Agc2VhcmNoaW5nIHdoZW4gYW55IGlzIGluY29tcGxldGVcbiAgICAgICAgfVxuICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgIH0sIFtwcmVzZW5jZUNoaWxkcmVuLCBvbkV4aXRDb21wbGV0ZV0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGlkLFxuICAgICAgICBpbml0aWFsLFxuICAgICAgICBpc1ByZXNlbnQsXG4gICAgICAgIGN1c3RvbSxcbiAgICAgICAgb25FeGl0Q29tcGxldGU6IG1lbW9pemVkT25FeGl0Q29tcGxldGUsXG4gICAgICAgIHJlZ2lzdGVyOiAoY2hpbGRJZCkgPT4ge1xuICAgICAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHByZXNlbmNlQ2hpbGRyZW4uZGVsZXRlKGNoaWxkSWQpO1xuICAgICAgICB9LFxuICAgIH0pLCBcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcHJlc2VuY2Ugb2YgYSBjaGlsZCBhZmZlY3RzIHRoZSBsYXlvdXQgb2YgdGhlIGNvbXBvbmVudHMgYXJvdW5kIGl0LFxuICAgICAqIHdlIHdhbnQgdG8gbWFrZSBhIG5ldyBjb250ZXh0IHZhbHVlIHRvIGVuc3VyZSB0aGV5IGdldCByZS1yZW5kZXJlZFxuICAgICAqIHNvIHRoZXkgY2FuIGRldGVjdCB0aGF0IGxheW91dCBjaGFuZ2UuXG4gICAgICovXG4gICAgcHJlc2VuY2VBZmZlY3RzTGF5b3V0XG4gICAgICAgID8gW01hdGgucmFuZG9tKCksIG1lbW9pemVkT25FeGl0Q29tcGxldGVdXG4gICAgICAgIDogW2lzUHJlc2VudCwgbWVtb2l6ZWRPbkV4aXRDb21wbGV0ZV0pO1xuICAgIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLmZvckVhY2goKF8sIGtleSkgPT4gcHJlc2VuY2VDaGlsZHJlbi5zZXQoa2V5LCBmYWxzZSkpO1xuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIG5vIGBtb3Rpb25gIGNvbXBvbmVudHMgdG8gZmlyZSBleGl0IGFuaW1hdGlvbnMsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoaXNcbiAgICAgKiBjb21wb25lbnQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWlzUHJlc2VudCAmJlxuICAgICAgICAgICAgIXByZXNlbmNlQ2hpbGRyZW4uc2l6ZSAmJlxuICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgJiZcbiAgICAgICAgICAgIG9uRXhpdENvbXBsZXRlKCk7XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIGlmIChtb2RlID09PSBcInBvcExheW91dFwiKSB7XG4gICAgICAgIGNoaWxkcmVuID0gKGpzeChQb3BDaGlsZCwgeyBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgYW5jaG9yWDogYW5jaG9yWCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goUHJlc2VuY2VDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbmZ1bmN0aW9uIG5ld0NoaWxkcmVuTWFwKCkge1xuICAgIHJldHVybiBuZXcgTWFwKCk7XG59XG5cbmV4cG9ydCB7IFByZXNlbmNlQ2hpbGQgfTtcbiIsImltcG9ydCB7IENoaWxkcmVuLCBpc1ZhbGlkRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgZ2V0Q2hpbGRLZXkgPSAoY2hpbGQpID0+IGNoaWxkLmtleSB8fCBcIlwiO1xuZnVuY3Rpb24gb25seUVsZW1lbnRzKGNoaWxkcmVuKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICAvLyBXZSB1c2UgZm9yRWFjaCBoZXJlIGluc3RlYWQgb2YgbWFwIGFzIG1hcCBtdXRhdGVzIHRoZSBjb21wb25lbnQga2V5IGJ5IHByZXByZW5kaW5nIGAuJGBcbiAgICBDaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSlcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goY2hpbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuZXhwb3J0IHsgZ2V0Q2hpbGRLZXksIG9ubHlFbGVtZW50cyB9O1xuIiwiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBqc3gsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvTGF5b3V0R3JvdXBDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgUHJlc2VuY2VDaGlsZCB9IGZyb20gJy4vUHJlc2VuY2VDaGlsZC5tanMnO1xuaW1wb3J0IHsgdXNlUHJlc2VuY2UgfSBmcm9tICcuL3VzZS1wcmVzZW5jZS5tanMnO1xuaW1wb3J0IHsgb25seUVsZW1lbnRzLCBnZXRDaGlsZEtleSB9IGZyb20gJy4vdXRpbHMubWpzJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzJztcblxuLyoqXG4gKiBgQW5pbWF0ZVByZXNlbmNlYCBlbmFibGVzIHRoZSBhbmltYXRpb24gb2YgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyZWUuXG4gKlxuICogV2hlbiBhZGRpbmcvcmVtb3ZpbmcgbW9yZSB0aGFuIGEgc2luZ2xlIGNoaWxkLCBldmVyeSBjaGlsZCAqKm11c3QqKiBiZSBnaXZlbiBhIHVuaXF1ZSBga2V5YCBwcm9wLlxuICpcbiAqIEFueSBgbW90aW9uYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXG4gKiB0aGUgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgY29uc3QgSXRlbXMgPSAoeyBpdGVtcyB9KSA9PiAoXG4gKiAgIDxBbmltYXRlUHJlc2VuY2U+XG4gKiAgICAge2l0ZW1zLm1hcChpdGVtID0+IChcbiAqICAgICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICAgIGtleT17aXRlbS5pZH1cbiAqICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gKiAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICogICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgIC8+XG4gKiAgICAgKSl9XG4gKiAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICogKVxuICogYGBgXG4gKlxuICogWW91IGNhbiBzZXF1ZW5jZSBleGl0IGFuaW1hdGlvbnMgdGhyb3VnaG91dCBhIHRyZWUgdXNpbmcgdmFyaWFudHMuXG4gKlxuICogSWYgYSBjaGlsZCBjb250YWlucyBtdWx0aXBsZSBgbW90aW9uYCBjb21wb25lbnRzIHdpdGggYGV4aXRgIHByb3BzLCBpdCB3aWxsIG9ubHkgdW5tb3VudCB0aGUgY2hpbGRcbiAqIG9uY2UgYWxsIGBtb3Rpb25gIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LiBMaWtld2lzZSwgYW55IGNvbXBvbmVudHMgdXNpbmdcbiAqIGB1c2VQcmVzZW5jZWAgYWxsIG5lZWQgdG8gY2FsbCBgc2FmZVRvUmVtb3ZlYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEFuaW1hdGVQcmVzZW5jZSA9ICh7IGNoaWxkcmVuLCBjdXN0b20sIGluaXRpYWwgPSB0cnVlLCBvbkV4aXRDb21wbGV0ZSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0ID0gdHJ1ZSwgbW9kZSA9IFwic3luY1wiLCBwcm9wYWdhdGUgPSBmYWxzZSwgYW5jaG9yWCA9IFwibGVmdFwiLCB9KSA9PiB7XG4gICAgY29uc3QgW2lzUGFyZW50UHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKHByb3BhZ2F0ZSk7XG4gICAgLyoqXG4gICAgICogRmlsdGVyIGFueSBjaGlsZHJlbiB0aGF0IGFyZW4ndCBSZWFjdEVsZW1lbnRzLiBXZSBjYW4gb25seSB0cmFjayBjb21wb25lbnRzXG4gICAgICogYmV0d2VlbiByZW5kZXJzIHdpdGggYSBwcm9wcy5rZXkuXG4gICAgICovXG4gICAgY29uc3QgcHJlc2VudENoaWxkcmVuID0gdXNlTWVtbygoKSA9PiBvbmx5RWxlbWVudHMoY2hpbGRyZW4pLCBbY2hpbGRyZW5dKTtcbiAgICAvKipcbiAgICAgKiBUcmFjayB0aGUga2V5cyBvZiB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGNoaWxkcmVuLiBUaGlzIGlzIHVzZWQgdG9cbiAgICAgKiBkZXRlcm1pbmUgd2hpY2ggY2hpbGRyZW4gYXJlIGV4aXRpbmcuXG4gICAgICovXG4gICAgY29uc3QgcHJlc2VudEtleXMgPSBwcm9wYWdhdGUgJiYgIWlzUGFyZW50UHJlc2VudCA/IFtdIDogcHJlc2VudENoaWxkcmVuLm1hcChnZXRDaGlsZEtleSk7XG4gICAgLyoqXG4gICAgICogSWYgYGluaXRpYWw9e2ZhbHNlfWAgd2Ugb25seSB3YW50IHRvIHBhc3MgdGhpcyB0byBjb21wb25lbnRzIGluIHRoZSBmaXJzdCByZW5kZXIuXG4gICAgICovXG4gICAgY29uc3QgaXNJbml0aWFsUmVuZGVyID0gdXNlUmVmKHRydWUpO1xuICAgIC8qKlxuICAgICAqIEEgcmVmIGNvbnRhaW5pbmcgdGhlIGN1cnJlbnRseSBwcmVzZW50IGNoaWxkcmVuLiBXaGVuIGFsbCBleGl0IGFuaW1hdGlvbnNcbiAgICAgKiBhcmUgY29tcGxldGUsIHdlIHVzZSB0aGlzIHRvIHJlLXJlbmRlciB0aGUgY29tcG9uZW50IHdpdGggdGhlIGxhdGVzdCBjaGlsZHJlblxuICAgICAqICpjb21taXR0ZWQqIHJhdGhlciB0aGFuIHRoZSBsYXRlc3QgY2hpbGRyZW4gKnJlbmRlcmVkKi5cbiAgICAgKi9cbiAgICBjb25zdCBwZW5kaW5nUHJlc2VudENoaWxkcmVuID0gdXNlUmVmKHByZXNlbnRDaGlsZHJlbik7XG4gICAgLyoqXG4gICAgICogVHJhY2sgd2hpY2ggZXhpdGluZyBjaGlsZHJlbiBoYXZlIGZpbmlzaGVkIGFuaW1hdGluZyBvdXQuXG4gICAgICovXG4gICAgY29uc3QgZXhpdENvbXBsZXRlID0gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IE1hcCgpKTtcbiAgICAvKipcbiAgICAgKiBTYXZlIGNoaWxkcmVuIHRvIHJlbmRlciBhcyBSZWFjdCBzdGF0ZS4gVG8gZW5zdXJlIHRoaXMgY29tcG9uZW50IGlzIGNvbmN1cnJlbnQtc2FmZSxcbiAgICAgKiB3ZSBjaGVjayBmb3IgZXhpdGluZyBjaGlsZHJlbiB2aWEgYW4gZWZmZWN0LlxuICAgICAqL1xuICAgIGNvbnN0IFtkaWZmZWRDaGlsZHJlbiwgc2V0RGlmZmVkQ2hpbGRyZW5dID0gdXNlU3RhdGUocHJlc2VudENoaWxkcmVuKTtcbiAgICBjb25zdCBbcmVuZGVyZWRDaGlsZHJlbiwgc2V0UmVuZGVyZWRDaGlsZHJlbl0gPSB1c2VTdGF0ZShwcmVzZW50Q2hpbGRyZW4pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpc0luaXRpYWxSZW5kZXIuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBwZW5kaW5nUHJlc2VudENoaWxkcmVuLmN1cnJlbnQgPSBwcmVzZW50Q2hpbGRyZW47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgY29tcGxldGUgc3RhdHVzIG9mIGV4aXRpbmcgY2hpbGRyZW4uXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldENoaWxkS2V5KHJlbmRlcmVkQ2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgaWYgKCFwcmVzZW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXRDb21wbGV0ZS5nZXQoa2V5KSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBleGl0Q29tcGxldGUuc2V0KGtleSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtyZW5kZXJlZENoaWxkcmVuLCBwcmVzZW50S2V5cy5sZW5ndGgsIHByZXNlbnRLZXlzLmpvaW4oXCItXCIpXSk7XG4gICAgY29uc3QgZXhpdGluZ0NoaWxkcmVuID0gW107XG4gICAgaWYgKHByZXNlbnRDaGlsZHJlbiAhPT0gZGlmZmVkQ2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IG5leHRDaGlsZHJlbiA9IFsuLi5wcmVzZW50Q2hpbGRyZW5dO1xuICAgICAgICAvKipcbiAgICAgICAgICogTG9vcCB0aHJvdWdoIGFsbCB0aGUgY3VycmVudGx5IHJlbmRlcmVkIGNvbXBvbmVudHMgYW5kIGRlY2lkZSB3aGljaFxuICAgICAgICAgKiBhcmUgZXhpdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVuZGVyZWRDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQgPSByZW5kZXJlZENoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0Q2hpbGRLZXkoY2hpbGQpO1xuICAgICAgICAgICAgaWYgKCFwcmVzZW50S2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV4dENoaWxkcmVuLnNwbGljZShpLCAwLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgZXhpdGluZ0NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBpbiBcIndhaXRcIiBtb2RlLCBhbmQgd2UgaGF2ZSBleGl0aW5nIGNoaWxkcmVuLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIG9ubHkgcmVuZGVyIHRoZXNlIHVudGlsIHRoZXkndmUgYWxsIGV4aXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChtb2RlID09PSBcIndhaXRcIiAmJiBleGl0aW5nQ2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBuZXh0Q2hpbGRyZW4gPSBleGl0aW5nQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UmVuZGVyZWRDaGlsZHJlbihvbmx5RWxlbWVudHMobmV4dENoaWxkcmVuKSk7XG4gICAgICAgIHNldERpZmZlZENoaWxkcmVuKHByZXNlbnRDaGlsZHJlbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFYXJseSByZXR1cm4gdG8gZW5zdXJlIG9uY2Ugd2UndmUgc2V0IHN0YXRlIHdpdGggdGhlIGxhdGVzdCBkaWZmZWRcbiAgICAgICAgICogY2hpbGRyZW4sIHdlIGNhbiBpbW1lZGlhdGVseSByZS1yZW5kZXIuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiZcbiAgICAgICAgbW9kZSA9PT0gXCJ3YWl0XCIgJiZcbiAgICAgICAgcmVuZGVyZWRDaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgWW91J3JlIGF0dGVtcHRpbmcgdG8gYW5pbWF0ZSBtdWx0aXBsZSBjaGlsZHJlbiB3aXRoaW4gQW5pbWF0ZVByZXNlbmNlLCBidXQgaXRzIG1vZGUgaXMgc2V0IHRvIFwid2FpdFwiLiBUaGlzIHdpbGwgbGVhZCB0byBvZGQgdmlzdWFsIGJlaGF2aW91ci5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UndmUgYmVlbiBwcm92aWRlZCBhIGZvcmNlUmVuZGVyIGZ1bmN0aW9uIGJ5IHRoZSBMYXlvdXRHcm91cENvbnRleHQsXG4gICAgICogd2UgY2FuIHVzZSBpdCB0byBmb3JjZSBhIHJlLXJlbmRlciBhbW9uZ3N0IGFsbCBzdXJyb3VuZGluZyBjb21wb25lbnRzIG9uY2VcbiAgICAgKiBhbGwgY29tcG9uZW50cyBoYXZlIGZpbmlzaGVkIGFuaW1hdGluZyBvdXQuXG4gICAgICovXG4gICAgY29uc3QgeyBmb3JjZVJlbmRlciB9ID0gdXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIHJldHVybiAoanN4KEZyYWdtZW50LCB7IGNoaWxkcmVuOiByZW5kZXJlZENoaWxkcmVuLm1hcCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldENoaWxkS2V5KGNoaWxkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUHJlc2VudCA9IHByb3BhZ2F0ZSAmJiAhaXNQYXJlbnRQcmVzZW50XG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogcHJlc2VudENoaWxkcmVuID09PSByZW5kZXJlZENoaWxkcmVuIHx8XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbnRLZXlzLmluY2x1ZGVzKGtleSk7XG4gICAgICAgICAgICBjb25zdCBvbkV4aXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXRDb21wbGV0ZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleGl0Q29tcGxldGUuc2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBpc0V2ZXJ5RXhpdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBleGl0Q29tcGxldGUuZm9yRWFjaCgoaXNFeGl0Q29tcGxldGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0V4aXRDb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlcnlFeGl0Q29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFdmVyeUV4aXRDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZVJlbmRlciA9PT0gbnVsbCB8fCBmb3JjZVJlbmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVuZGVyZWRDaGlsZHJlbihwZW5kaW5nUHJlc2VudENoaWxkcmVuLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wYWdhdGUgJiYgKHNhZmVUb1JlbW92ZSA9PT0gbnVsbCB8fCBzYWZlVG9SZW1vdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNhZmVUb1JlbW92ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgJiYgb25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIChqc3goUHJlc2VuY2VDaGlsZCwgeyBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgaW5pdGlhbDogIWlzSW5pdGlhbFJlbmRlci5jdXJyZW50IHx8IGluaXRpYWxcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiBmYWxzZSwgY3VzdG9tOiBpc1ByZXNlbnQgPyB1bmRlZmluZWQgOiBjdXN0b20sIHByZXNlbmNlQWZmZWN0c0xheW91dDogcHJlc2VuY2VBZmZlY3RzTGF5b3V0LCBtb2RlOiBtb2RlLCBvbkV4aXRDb21wbGV0ZTogaXNQcmVzZW50ID8gdW5kZWZpbmVkIDogb25FeGl0LCBhbmNob3JYOiBhbmNob3JYLCBjaGlsZHJlbjogY2hpbGQgfSwga2V5KSk7XG4gICAgICAgIH0pIH0pKTtcbn07XG5cbmV4cG9ydCB7IEFuaW1hdGVQcmVzZW5jZSB9O1xuIiwiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgRmlsZVdpdGhQcmV2aWV3IGV4dGVuZHMgRmlsZSB7XG4gIHByZXZpZXc/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBGaWxlVXBsb2FkQ29udGV4dFR5cGUge1xuICBmaWxlOiBGaWxlV2l0aFByZXZpZXcgfCBudWxsO1xuICBlcnJvcjogc3RyaW5nIHwgbnVsbDtcbiAgYWRkRmlsZTogKG5ld0ZpbGU6IEZpbGVMaXN0IHwgRmlsZVtdKSA9PiB2b2lkO1xuICByZW1vdmVGaWxlOiAoKSA9PiB2b2lkO1xuICBjbGVhckZpbGU6ICgpID0+IHZvaWQ7XG59XG5cbmNvbnN0IEZpbGVVcGxvYWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxGaWxlVXBsb2FkQ29udGV4dFR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGaWxlVXBsb2FkKCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChGaWxlVXBsb2FkQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VGaWxlVXBsb2FkIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBGaWxlVXBsb2FkUHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmludGVyZmFjZSBGaWxlVXBsb2FkUHJvdmlkZXJQcm9wcyB7XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGU7XG4gIG1heFNpemU/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGaWxlVXBsb2FkUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbiAgbWF4U2l6ZSA9IDQ1ICogMTAyNCwgLy8gNDVLQiBkZWZhdWx0XG59OiBGaWxlVXBsb2FkUHJvdmlkZXJQcm9wcykge1xuICBjb25zdCBbZmlsZSwgc2V0RmlsZV0gPSB1c2VTdGF0ZTxGaWxlV2l0aFByZXZpZXcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCB2YWxpZGF0ZUZpbGUgPSB1c2VDYWxsYmFjayhcbiAgICAoZmlsZTogRmlsZSk6IGJvb2xlYW4gPT4ge1xuICAgICAgY29uc3QgdmFsaWRUeXBlcyA9IFtcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9wZGdcIiwgXCJ2aWRlby9tcDRcIl07XG4gICAgICBpZiAoIXZhbGlkVHlwZXMuaW5jbHVkZXMoZmlsZS50eXBlKSkge1xuICAgICAgICBzZXRFcnJvcihcIkZpbGUgdHlwZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZmlsZS5zaXplID4gbWF4U2l6ZSkge1xuICAgICAgICBzZXRFcnJvcihcIkZpbGUgc2l6ZSBleGNlZWRzIDQ1S0IgbGltaXRcIik7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgW21heFNpemVdXG4gICk7XG5cbiAgY29uc3QgYWRkRmlsZSA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXdGaWxlczogRmlsZUxpc3QgfCBGaWxlW10pID0+IHtcbiAgICAgIHNldEVycm9yKG51bGwpO1xuICAgICAgLy8gU2UgdG9tYSBzb2xvIGVsIHByaW1lciBhcmNoaXZvXG4gICAgICBjb25zdCBmaWxlVG9BZGQgPSBBcnJheS5mcm9tKG5ld0ZpbGVzKVswXTtcbiAgICAgIGlmICghdmFsaWRhdGVGaWxlKGZpbGVUb0FkZCkpIHJldHVybjtcblxuICAgICAgbGV0IGZpbGVXaXRoUHJldmlldzogRmlsZVdpdGhQcmV2aWV3ID0gZmlsZVRvQWRkO1xuICAgICAgaWYgKGZpbGVUb0FkZC50eXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICAgICAgZmlsZVdpdGhQcmV2aWV3ID0gT2JqZWN0LmFzc2lnbihmaWxlVG9BZGQsIHtcbiAgICAgICAgICBwcmV2aWV3OiBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGVUb0FkZCksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgLy8gU2kgeWEgZXhpc3RlIHVuIGFyY2hpdm8sIHNlIHJldm9jYSBzdSBVUkwgZGUgcHJldmlld1xuICAgICAgaWYgKGZpbGUgJiYgZmlsZS5wcmV2aWV3KSB7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZS5wcmV2aWV3KTtcbiAgICAgIH1cbiAgICAgIHNldEZpbGUoZmlsZVdpdGhQcmV2aWV3KTtcbiAgICB9LFxuICAgIFt2YWxpZGF0ZUZpbGUsIGZpbGVdXG4gICk7XG5cbiAgY29uc3QgcmVtb3ZlRmlsZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoZmlsZSAmJiBmaWxlLnByZXZpZXcpIHtcbiAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoZmlsZS5wcmV2aWV3KTtcbiAgICB9XG4gICAgc2V0RmlsZShudWxsKTtcbiAgfSwgW2ZpbGVdKTtcblxuICBjb25zdCBjbGVhckZpbGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGZpbGUgJiYgZmlsZS5wcmV2aWV3KSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGZpbGUucHJldmlldyk7XG4gICAgfVxuICAgIHNldEZpbGUobnVsbCk7XG4gIH0sIFtmaWxlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8RmlsZVVwbG9hZENvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGZpbGUsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBhZGRGaWxlLFxuICAgICAgICByZW1vdmVGaWxlLFxuICAgICAgICBjbGVhckZpbGUsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0ZpbGVVcGxvYWRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgVXBsb2FkSWNvblByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgVXBsb2FkSWNvbjogUmVhY3QuRkM8VXBsb2FkSWNvblByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgd2lkdGg9XCI0NlwiXG4gICAgICBoZWlnaHQ9XCI0N1wiXG4gICAgICB2aWV3Qm94PVwiMCAwIDQ2IDQ3XCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xNC4yOTkxIDM3LjU2ODVIMTAuNjE5QzQuOTg0IDM3LjE2NiAyLjQ1NDEgMzIuODM0MyAyLjQ1NDEgMjguOTgxOEMyLjQ1NDEgMjUuMTI5MyA0Ljk4NDAzIDIwLjc3ODUgMTAuNTIzMiAyMC4zOTUxQzExLjMwOSAyMC4zMTg1IDExLjk5OSAyMC45MzE4IDEyLjA1NjUgMjEuNzM2OEMxMi4xMTQgMjIuNTIyNiAxMS41MTk5IDIzLjIxMjYgMTAuNzE0OSAyMy4yNzAxQzYuOTk2NiAyMy41Mzg1IDUuMzI5MSAyNi4zMzY4IDUuMzI5MSAyOS4wMDFDNS4zMjkxIDMxLjY2NTEgNi45OTY2IDM0LjQ2MzUgMTAuNzE0OSAzNC43MzE4SDE0LjI5OTFDMTUuMDg0OSAzNC43MzE4IDE1LjczNjYgMzUuMzgzNSAxNS43MzY2IDM2LjE2OTNDMTUuNzM2NiAzNi45NTUxIDE1LjA4NDkgMzcuNTY4NSAxNC4yOTkxIDM3LjU2ODVaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0zMS45NTA3IDM3LjU2ODJDMzEuOTEyNCAzNy41NjgyIDMxLjg5MzIgMzcuNTY4MiAzMS44NTQ5IDM3LjU2ODJDMzEuMDY5MSAzNy41NjgyIDMwLjM0MDggMzYuOTE2NiAzMC4zNDA4IDM2LjEzMDdDMzAuMzQwOCAzNS4zMDY2IDMwLjk1NDEgMzQuNjkzMiAzMS43NTkxIDM0LjY5MzJDMzQuMTE2NiAzNC42OTMyIDM2LjIyNDkgMzMuODY5MSAzNy44NzMzIDMyLjM5MzNDNDAuODYzMyAyOS43ODY2IDQxLjA1NDkgMjYuMDI5OSA0MC4yNDk5IDIzLjM4NDlDMzkuNDQ0OSAyMC43NTkxIDM3LjIwMjQgMTcuNzQ5OSAzMy4yOTI0IDE3LjI3MDhDMzIuNjU5OSAxNy4xOTQxIDMyLjE2MTUgMTYuNzE0OSAzMi4wNDY1IDE2LjA4MjRDMzEuMjc5OSAxMS40ODI0IDI4LjgwNzQgOC4zMDA3NiAyNS4wNTA4IDcuMTUwNzZDMjEuMTc5MSA1Ljk0MzI2IDE2LjY1NTcgNy4xMzE1OSAxMy44MzgyIDEwLjA4MzNDMTEuMDk3NCAxMi45MzkxIDEwLjQ2NDkgMTYuOTQ0OSAxMi4wNTU3IDIxLjM1MzNDMTIuMzI0IDIyLjEwMDggMTEuOTQwOCAyMi45MjQ5IDExLjE5MzMgMjMuMTkzMkMxMC40NDU4IDIzLjQ2MTYgOS42MjE1OSAyMy4wNzgzIDkuMzUzMjYgMjIuMzMwOEM3LjQxNzQzIDE2LjkyNTggOC4yOTkxMSAxMS43NTA4IDExLjc2ODMgOC4xMDkwOUMxNS4zMTQxIDQuMzkwNzYgMjEuMDA2NiAyLjkxNDkxIDI1Ljg5NDEgNC40MDk5MUMzMC4zNzkxIDUuNzg5OTEgMzMuNTQxNSA5LjQ4OTA4IDM0LjY5MTUgMTQuNjI1N0MzOC42MDE1IDE1LjUwNzQgNDEuNzQ0OSAxOC40NzgzIDQyLjk5MDcgMjIuNTc5OUM0NC4zNTE2IDI3LjA0NTggNDMuMTI0OSAzMS42NDU4IDM5Ljc3MDcgMzQuNTU5MUMzNy42NDMyIDM2LjQ3NTggMzQuODY0IDM3LjU2ODIgMzEuOTUwNyAzNy41NjgyWlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMjIuOTk5OCA0My4yMDMzQzE5LjE0NzMgNDMuMjAzMyAxNS41NDQgNDEuMTUyNCAxMy41Njk5IDM3LjgzNjZDMTMuMzU5IDM3LjUxMDggMTMuMTQ4MiAzNy4xMjc1IDEyLjk3NTcgMzYuNzA1OEMxMi4zMjQgMzUuMzQ1IDExLjk3OSAzMy43OTI1IDExLjk3OSAzMi4xODI1QzExLjk3OSAyNi4xMDY2IDE2LjkyNCAyMS4xNjE2IDIyLjk5OTggMjEuMTYxNkMyOS4wNzU3IDIxLjE2MTYgMzQuMDIwNyAyNi4xMDY2IDM0LjAyMDcgMzIuMTgyNUMzNC4wMjA3IDMzLjgxMTYgMzMuNjc1NyAzNS4zNDUgMzIuOTg1NyAzNi43NjMzQzMyLjgzMjQgMzcuMTI3NSAzMi42MjE2IDM3LjUxMDggMzIuMzkxNiAzNy44NzVDMzAuNDU1NyA0MS4xNTI1IDI2Ljg1MjMgNDMuMjAzMyAyMi45OTk4IDQzLjIwMzNaTTIyLjk5OTggMjQuMDM2NkMxOC41MTQ4IDI0LjAzNjYgMTQuODU0IDI3LjY5NzUgMTQuODU0IDMyLjE4MjVDMTQuODU0IDMzLjM3MDggMTUuMTAzMiAzNC40ODI0IDE1LjU4MjMgMzUuNDk4M0MxNS43MzU3IDM1LjgyNDEgMTUuODY5OCAzNi4wOTI1IDE2LjAyMzEgMzYuMzQxNkMxNy40Nzk4IDM4LjgxNDEgMjAuMTQ0IDQwLjMyODMgMjIuOTgwNyA0MC4zMjgzQzI1LjgxNzMgNDAuMzI4MyAyOC40ODE1IDM4LjgxNDEgMjkuOTE5IDM2LjM4QzMwLjA5MTUgMzYuMDkyNSAzMC4yNDQ5IDM1LjgyNDEgMzAuMzU5OSAzNS41NTU4QzMwLjg3NzQgMzQuNTAxNiAzMS4xMjY1IDMzLjM4OTkgMzEuMTI2NSAzMi4yMDE2QzMxLjE0NTcgMjcuNjk3NCAyNy40ODQ4IDI0LjAzNjYgMjIuOTk5OCAyNC4wMzY2WlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMjEuOTA3NCAzNS41MTc1QzIxLjU0MzIgMzUuNTE3NSAyMS4xNzkxIDM1LjM4MzQgMjAuODkxNiAzNS4wOTU5TDE4Ljk5NCAzMy4xOTg0QzE4LjQzODIgMzIuNjQyNSAxOC40MzgyIDMxLjcyMjUgMTguOTk0IDMxLjE2NjdDMTkuNTQ5OSAzMC42MTA5IDIwLjQ2OTkgMzAuNjEwOSAyMS4wMjU3IDMxLjE2NjdMMjEuOTQ1OCAzMi4wODY3TDI1LjAxMjQgMjkuMjVDMjUuNjA2NiAyOC43MTM0IDI2LjUwNzQgMjguNzUxNyAyNy4wNDQgMjkuMzI2N0MyNy41ODA3IDI5LjkwMTcgMjcuNTQyNCAzMC44MjE3IDI2Ljk2NzQgMzEuMzU4NEwyMi44ODQ5IDM1LjEzNDJDMjIuNTk3NCAzNS4zODM0IDIyLjI1MjQgMzUuNTE3NSAyMS45MDc0IDM1LjUxNzVaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgIDwvc3ZnPlxuICApO1xufTtcbiIsIi8vIFR4U3RhdHVzQ29udGV4dC50c3hcblwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VDYWxsYmFjayB9IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgVHhTdGF0dXMge1xuICBpc1Byb2Nlc3Npbmc6IGJvb2xlYW47XG4gIGN1cnJlbnRTdGVwOiBzdHJpbmc7XG4gIG5leHRTdGVwOiBzdHJpbmcgfCBudWxsO1xufVxuXG5pbnRlcmZhY2UgVHhTdGF0dXNDb250ZXh0VHlwZSB7XG4gIHByZXBhcmF0aW9uOiBUeFN0YXR1cztcbiAgaW5zY3JpcHRpb246IFR4U3RhdHVzO1xuICBzZXRQcmVwYXJhdGlvblN0YXR1czogKHN0YXR1czogUGFydGlhbDxUeFN0YXR1cz4pID0+IHZvaWQ7XG4gIHNldEluc2NyaXB0aW9uU3RhdHVzOiAoc3RhdHVzOiBQYXJ0aWFsPFR4U3RhdHVzPikgPT4gdm9pZDtcbiAgbW92ZVRvTmV4dFN0ZXA6IChmbG93OiBcInByZXBhcmF0aW9uXCIgfCBcImluc2NyaXB0aW9uXCIgfCBcImVuZFwiKSA9PiB2b2lkO1xuICByZXNldFN0YXR1czogKGZsb3c6IFwicHJlcGFyYXRpb25cIiB8IFwiaW5zY3JpcHRpb25cIikgPT4gdm9pZDtcbn1cblxuY29uc3QgVHhTdGF0dXNDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxUeFN0YXR1c0NvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgY29uc3QgVHhTdGF0dXNQcm92aWRlciA9ICh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSA9PiB7XG4gIGNvbnN0IFtwcmVwYXJhdGlvbiwgc2V0UHJlcGFyYXRpb25dID0gdXNlU3RhdGU8VHhTdGF0dXM+KHtcbiAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIGN1cnJlbnRTdGVwOiBcInByZXBhcmUvY29uc3RydWN0XCIsXG4gICAgbmV4dFN0ZXA6IFwicHJlcGFyZS9yZXRyaWV2ZVwiLFxuICB9KTtcblxuICBjb25zdCBbaW5zY3JpcHRpb24sIHNldEluc2NyaXB0aW9uXSA9IHVzZVN0YXRlPFR4U3RhdHVzPih7XG4gICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICBjdXJyZW50U3RlcDogXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIixcbiAgICBuZXh0U3RlcDogXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiLFxuICB9KTtcblxuICBjb25zdCBzZXRQcmVwYXJhdGlvblN0YXR1cyA9IHVzZUNhbGxiYWNrKChzdGF0dXM6IFBhcnRpYWw8VHhTdGF0dXM+KSA9PiB7XG4gICAgc2V0UHJlcGFyYXRpb24oKHByZXYpID0+ICh7IC4uLnByZXYsIC4uLnN0YXR1cyB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZXRJbnNjcmlwdGlvblN0YXR1cyA9IHVzZUNhbGxiYWNrKChzdGF0dXM6IFBhcnRpYWw8VHhTdGF0dXM+KSA9PiB7XG4gICAgc2V0SW5zY3JpcHRpb24oKHByZXYpID0+ICh7IC4uLnByZXYsIC4uLnN0YXR1cyB9KSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBtb3ZlVG9OZXh0U3RlcCA9IChmbG93OiBcInByZXBhcmF0aW9uXCIgfCBcImluc2NyaXB0aW9uXCIgfCBcImVuZFwiKSA9PiB7XG4gICAgaWYgKGZsb3cgPT09IFwicHJlcGFyYXRpb25cIiAmJiBwcmVwYXJhdGlvbi5uZXh0U3RlcCkge1xuICAgICAgY29uc3QgbmV4dFN0ZXBNYXA6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIHwgbnVsbCB9ID0ge1xuICAgICAgICBcInByZXBhcmUvY29uc3RydWN0XCI6IFwicHJlcGFyZS9yZXRyaWV2ZVwiLFxuICAgICAgICBcInByZXBhcmUvcmV0cmlldmVcIjogXCJwcmVwYXJlL3N1Ym1pdFwiLFxuICAgICAgICBcInByZXBhcmUvc3VibWl0XCI6IFwicHJlcGFyZS9yZXRyaWV2ZS1zdWJtaXNzaW9uXCIsXG4gICAgICAgIFwicHJlcGFyZS9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6IG51bGwsXG4gICAgICB9O1xuICAgICAgY29uc3QgY3VycmVudFN0ZXAgPSBwcmVwYXJhdGlvbi5uZXh0U3RlcDtcbiAgICAgIGNvbnN0IG5leHRTdGVwID0gbmV4dFN0ZXBNYXBbY3VycmVudFN0ZXBdO1xuICAgICAgc2V0UHJlcGFyYXRpb25TdGF0dXMoeyBjdXJyZW50U3RlcCwgbmV4dFN0ZXAgfSk7XG4gICAgfSBlbHNlIGlmIChmbG93ID09PSBcImluc2NyaXB0aW9uXCIgJiYgaW5zY3JpcHRpb24ubmV4dFN0ZXApIHtcbiAgICAgIGNvbnN0IG5leHRTdGVwTWFwOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB8IG51bGwgfSA9IHtcbiAgICAgICAgXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIjogXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiLFxuICAgICAgICBcImluc2NyaXB0aW9uL3JldHJpZXZlXCI6IFwiaW5zY3JpcHRpb24vc3VibWl0XCIsXG4gICAgICAgIFwiaW5zY3JpcHRpb24vc3VibWl0XCI6IFwiaW5zY3JpcHRpb24vcmV0cmlldmUtc3VibWlzc2lvblwiLFxuICAgICAgICBcImluc2NyaXB0aW9uL3JldHJpZXZlLXN1Ym1pc3Npb25cIjogbnVsbCxcbiAgICAgIH07XG4gICAgICBjb25zdCBjdXJyZW50U3RlcCA9IGluc2NyaXB0aW9uLm5leHRTdGVwO1xuICAgICAgY29uc3QgbmV4dFN0ZXAgPSBuZXh0U3RlcE1hcFtjdXJyZW50U3RlcF07XG4gICAgICBzZXRJbnNjcmlwdGlvblN0YXR1cyh7IGN1cnJlbnRTdGVwLCBuZXh0U3RlcCB9KTtcbiAgICB9IGVsc2UgaWYgKGZsb3cgPT09IFwiZW5kXCIpIHtcbiAgICAgIC8vIEFsIGxsZWdhciBhbCBmaW5hbCwgcmVpbmljaWFtb3MgbG9zIGVzdGFkb3NcbiAgICAgIHNldFByZXBhcmF0aW9uKHtcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFN0ZXA6IFwicHJlcGFyZS9jb25zdHJ1Y3RcIixcbiAgICAgICAgbmV4dFN0ZXA6IFwicHJlcGFyZS9yZXRyaWV2ZVwiLFxuICAgICAgfSk7XG4gICAgICBzZXRJbnNjcmlwdGlvbih7XG4gICAgICAgIGlzUHJvY2Vzc2luZzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRTdGVwOiBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiLFxuICAgICAgICBuZXh0U3RlcDogXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiLFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHJlc2V0U3RhdHVzID0gKGZsb3c6IFwicHJlcGFyYXRpb25cIiB8IFwiaW5zY3JpcHRpb25cIikgPT4ge1xuICAgIGlmIChmbG93ID09PSBcInByZXBhcmF0aW9uXCIpIHtcbiAgICAgIHNldFByZXBhcmF0aW9uKHtcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFN0ZXA6IFwicHJlcGFyZS9jb25zdHJ1Y3RcIixcbiAgICAgICAgbmV4dFN0ZXA6IFwicHJlcGFyZS9yZXRyaWV2ZVwiLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEluc2NyaXB0aW9uKHtcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICAgICAgY3VycmVudFN0ZXA6IFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCIsXG4gICAgICAgIG5leHRTdGVwOiBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIsXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8VHhTdGF0dXNDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBwcmVwYXJhdGlvbixcbiAgICAgICAgaW5zY3JpcHRpb24sXG4gICAgICAgIHNldFByZXBhcmF0aW9uU3RhdHVzLFxuICAgICAgICBzZXRJbnNjcmlwdGlvblN0YXR1cyxcbiAgICAgICAgbW92ZVRvTmV4dFN0ZXAsXG4gICAgICAgIHJlc2V0U3RhdHVzLFxuICAgICAgfX1cbiAgICA+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9UeFN0YXR1c0NvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgdXNlVHhTdGF0dXMgPSAoKSA9PiB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFR4U3RhdHVzQ29udGV4dCk7XG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVR4U3RhdHVzIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBUeFN0YXR1c1Byb3ZpZGVyXCIpO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTsiLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uLCBBbmltYXRlUHJlc2VuY2UgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiO1xuaW1wb3J0IHsgdXNlRmlsZVVwbG9hZCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L0ZpbGVVcGxvYWRDb250ZXh0XCI7XG5pbXBvcnQgeyBVcGxvYWRJY29uIH0gZnJvbSBcIi4uLy4uL2ljb25zL1VwbG9hZEljb25cIjtcbmltcG9ydCB7IHVzZVR4U3RhdHVzIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhTdGF0dXNDb250ZXh0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBVcGxvYWRCb3goKSB7XG4gIGNvbnN0IHsgYWRkRmlsZSwgZXJyb3IgfSA9IHVzZUZpbGVVcGxvYWQoKTtcbiAgY29uc3QgW2lzRHJhZ2dpbmcsIHNldElzRHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbZHJhZ0NvdW50ZXIsIHNldERyYWdDb3VudGVyXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCB7IHByZXBhcmF0aW9uIH0gPSB1c2VUeFN0YXR1cygpO1xuXG4gIGNvbnN0IGhhbmRsZURyYWdFbnRlciA9IHVzZUNhbGxiYWNrKChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzZXREcmFnQ291bnRlcigocHJldikgPT4gcHJldiArIDEpO1xuICAgIHNldElzRHJhZ2dpbmcodHJ1ZSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBoYW5kbGVEcmFnTGVhdmUgPSB1c2VDYWxsYmFjayhcbiAgICAoZTogUmVhY3QuRHJhZ0V2ZW50KSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgc2V0RHJhZ0NvdW50ZXIoKHByZXYpID0+IHByZXYgLSAxKTtcbiAgICAgIGlmIChkcmFnQ291bnRlciA9PT0gMCkge1xuICAgICAgICBzZXRJc0RyYWdnaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtkcmFnQ291bnRlcl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IHVzZUNhbGxiYWNrKChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZURyb3AgPSB1c2VDYWxsYmFjayhcbiAgICAoZTogUmVhY3QuRHJhZ0V2ZW50KSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgc2V0SXNEcmFnZ2luZyhmYWxzZSk7XG4gICAgICBzZXREcmFnQ291bnRlcigwKTtcblxuICAgICAgY29uc3QgeyBmaWxlcyB9ID0gZS5kYXRhVHJhbnNmZXI7XG4gICAgICBpZiAoZmlsZXMgJiYgZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaWxlID0gZmlsZXNbMF07XG4gICAgICAgIGlmIChmaWxlLnNpemUgPiA0NSAqIDEwMjQpIHtcbiAgICAgICAgICAvLyA0NUtCIGluIGJ5dGVzXG4gICAgICAgICAgYWxlcnQoXCJGaWxlIHRvbyBiaWdcIik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFkZEZpbGUoZmlsZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2FkZEZpbGVdXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8bW90aW9uLmRpdlxuICAgICAgY2xhc3NOYW1lPXtgcmVsYXRpdmUgYm9yZGVyLTIgYm9yZGVyLWRhc2hlZCBib3JkZXItd2hpdGUgcm91bmRlZC0zeGwgcC0xMiB0ZXh0LWNlbnRlciB0cmFuc2l0aW9uLWFsbCAke1xuICAgICAgICBpc0RyYWdnaW5nID8gXCJiZy13aGl0ZS8yMFwiIDogXCJcIlxuICAgICAgfWB9XG4gICAgICBvbkRyYWdFbnRlcj17aGFuZGxlRHJhZ0VudGVyfVxuICAgICAgb25EcmFnTGVhdmU9e2hhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJhZ092ZXI9e2hhbmRsZURyYWdPdmVyfVxuICAgICAgb25Ecm9wPXtoYW5kbGVEcm9wfVxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB5OiAyMCB9fVxuICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxLCB5OiAwIH19XG4gICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjUgfX1cbiAgICA+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cImZpbGVcIlxuICAgICAgICBpZD1cImZpbGUtdXBsb2FkXCJcbiAgICAgICAgY2xhc3NOYW1lPXtgYWJzb2x1dGUgaW5zZXQtMCB3LWZ1bGwgaC1mdWxsIG9wYWNpdHktMCAke1xuICAgICAgICAgIHByZXBhcmF0aW9uLmN1cnJlbnRTdGVwID09IFwicHJlcGFyZS9jb25zdHJ1Y3RcIlxuICAgICAgICAgICAgPyBcImN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgIDogXCJjdXJzb3Itbm90LWFsbG93ZWRcIlxuICAgICAgICB9IGB9XG4gICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgIGlmIChlLnRhcmdldC5maWxlcykge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IGUudGFyZ2V0LmZpbGVzWzBdO1xuICAgICAgICAgICAgaWYgKGZpbGUgJiYgZmlsZS5zaXplID4gNDUgKiAxMDI0KSB7XG4gICAgICAgICAgICAgIC8vIDQ1S0IgaW4gYnl0ZXNcblxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRGaWxlKGUudGFyZ2V0LmZpbGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICAgIGFjY2VwdD1cIi5qcGcsLmpwZWcsLnBuZywucGRnLC5tcDRcIlxuICAgICAgICBkaXNhYmxlZD17cHJlcGFyYXRpb24uY3VycmVudFN0ZXAgIT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwifVxuICAgICAgLz5cblxuICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLTZcIlxuICAgICAgICB3aGlsZUhvdmVyPXt7IHNjYWxlOiAxLjA1IH19XG4gICAgICAgIHRyYW5zaXRpb249e3sgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiAzMDAgfX1cbiAgICAgID5cbiAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJ3LVsyLjg3NXJlbV0gaC1bMi44NzVyZW1dIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiXG4gICAgICAgICAgd2hpbGVIb3Zlcj17eyByb3RhdGU6IDM2MCB9fVxuICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuNSB9fVxuICAgICAgICA+XG4gICAgICAgICAgPFVwbG9hZEljb24gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCB0ZXh0LXdoaXRlXCIgLz5cbiAgICAgICAgPC9tb3Rpb24uZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtNFwiPlxuICAgICAgICAgIDxBbmltYXRlUHJlc2VuY2UgbW9kZT1cIndhaXRcIj5cbiAgICAgICAgICAgIHtpc0RyYWdnaW5nID8gKFxuICAgICAgICAgICAgICA8bW90aW9uLnBcbiAgICAgICAgICAgICAgICBrZXk9XCJkcmFnZ2luZ1wiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC0yeGwgZm9udC1tZWRpdW0gIXRleHQtd2hpdGVcIlxuICAgICAgICAgICAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCwgeTogMTAgfX1cbiAgICAgICAgICAgICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEsIHk6IDAgfX1cbiAgICAgICAgICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAsIHk6IC0xMCB9fVxuICAgICAgICAgICAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuMiB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgRHJvcCBoZXJlIHlvdXIgZmlsZVxuICAgICAgICAgICAgICA8L21vdGlvbi5wPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPG1vdGlvbi5wXG4gICAgICAgICAgICAgICAga2V5PVwibm90LWRyYWdnaW5nXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCAhdGV4dC13aGl0ZSBmb250LW1lZGl1bVwiXG4gICAgICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB5OiAxMCB9fVxuICAgICAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeTogMCB9fVxuICAgICAgICAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCwgeTogLTEwIH19XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4yIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICBDaG9vc2UgYSBmaWxlIG9yIGRyYWcgJiBkcm9wIGl0IGhlcmVcbiAgICAgICAgICAgICAgPC9tb3Rpb24ucD5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9BbmltYXRlUHJlc2VuY2U+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1iYXNlIHRleHQtbGlnaHRcIj5cbiAgICAgICAgICAgIEpQRUcsIFBORywgUERHLCBhbmQgTVA0IGZvcm1hdHMsIHVwIHRvIDQ1S0JcbiAgICAgICAgICA8L3A+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIHtlcnJvciAmJiAoXG4gICAgICAgICAgPG1vdGlvbi5wXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXJlZC01MDAgdGV4dC1zbVwiXG4gICAgICAgICAgICBpbml0aWFsPXt7IG9wYWNpdHk6IDAgfX1cbiAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICAgICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4zIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAge2Vycm9yfVxuICAgICAgICAgIDwvbW90aW9uLnA+XG4gICAgICAgICl9XG4gICAgICA8L21vdGlvbi5kaXY+XG4gICAgPC9tb3Rpb24uZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgY3JlYXRlQ29udGV4dCxcbiAgdXNlQ29udGV4dCxcbiAgdXNlU3RhdGUsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QsXG59IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBDb25uZWN0ZWRXYWxsZXQsXG4gIEFsbFN1cHBvcnRlZFdhbGxldHMsXG4gIFRXYWxsZXRBUEksXG59IGZyb20gXCIuLi90eXBlcy9jYXJkYW5vXCI7XG5cbmNvbnN0IGFsbFN1cHBvcnRlZFdhbGxldHM6IEFsbFN1cHBvcnRlZFdhbGxldHMgPSB7XG4gIC8qICAgeW9yb2k6IHtcbiAgICBuYW1lOiBcIllvcm9pXCIsXG4gICAgaWNvbjogXCJodHRwczovL3VwbG9hZHMtc3NsLndlYmZsb3cuY29tLzY2YzNiNzc5Njc0OTE1YzI4OGNhOTk5OC82NmM5NWVmYmVkOWFiZGY5Y2Y3ZTAxZDRfWW9yb2lXYWxsZXQucG5nXCIsXG4gICAgdXJsOiBcImh0dHBzOi8veW9yb2ktd2FsbGV0LmNvbS9cIixcbiAgfSwgKi9cbi8qICAgZmxpbnQ6IHtcbiAgICBuYW1lOiBcIkZsaW50XCIsXG4gICAgaWNvbjogXCJodHRwczovL3VwbG9hZHMtc3NsLndlYmZsb3cuY29tLzY2YzNiNzc5Njc0OTE1YzI4OGNhOTk5OC82NmM5NWQ3YzVmYjAzZjJkNGIzMmIzZWRfRmxpbnRXYWxsZXQuc3ZnXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZmxpbnQtd2FsbGV0LmNvbS9cIixcbiAgfSxcblxuICBldGVybmw6IHtcbiAgICBuYW1lOiBcIkV0ZXJubFwiLFxuICAgIGljb246IFwiaHR0cHM6Ly91cGxvYWRzLXNzbC53ZWJmbG93LmNvbS82NmMzYjc3OTY3NDkxNWMyODhjYTk5OTgvNjZjOTVlZmNhMGViZWNmZWRmY2E4NTk5X0V0ZXJubFdhbGxldC5wbmdcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9ldGVybmwuaW8vXCIsXG4gIH0sICovXG4gIGdlcm86IHtcbiAgICBuYW1lOiBcIkdlcm9cIixcbiAgICBpY29uOiBcImh0dHBzOi8vdXBsb2Fkcy1zc2wud2ViZmxvdy5jb20vNjZjM2I3Nzk2NzQ5MTVjMjg4Y2E5OTk4LzY2Yzk1ZWZiOTFkNTQyZTY0M2JmNWVkNF9HZXJvV2FsbGV0LnBuZ1wiLFxuICAgIHVybDogXCJodHRwczovL2dlcm93YWxsZXQuaW8vXCIsXG4gIH0sXG4gIG51Zmk6IHtcbiAgICBuYW1lOiBcIk51ZmlcIixcbiAgICBpY29uOiBcImh0dHBzOi8vdXBsb2Fkcy1zc2wud2ViZmxvdy5jb20vNjZjM2I3Nzk2NzQ5MTVjMjg4Y2E5OTk4LzY2Yzk1ZWZiYmVlMWFiYzEwYWVhMjZhZF9OdWZpV2FsbGV0LnBuZ1wiLFxuICAgIHVybDogXCJodHRwczovL251LmZpL1wiLFxuICB9LFxuICBiZWdpbjoge1xuICAgIG5hbWU6IFwiQmVnaW5cIixcbiAgICBpY29uOiBcImh0dHBzOi8vdXBsb2Fkcy1zc2wud2ViZmxvdy5jb20vNjZjM2I3Nzk2NzQ5MTVjMjg4Y2E5OTk4LzY2Yzk1ZWZiMDhiNmExMjVhNGFmNDc5Yl9CZWdpbldhbGxldC5wbmdcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9iZWdpbi5pcy9cIixcbiAgfSxcbiAgbGFjZToge1xuICAgIG5hbWU6IFwiTGFjZVwiLFxuICAgIGljb246IFwiaHR0cHM6Ly91cGxvYWRzLXNzbC53ZWJmbG93LmNvbS82NmMzYjc3OTY3NDkxNWMyODhjYTk5OTgvNjZjOTVlZmJmMjVlZjE2NjMzY2RkNTI4X0xhY2VXYWxsZXQucG5nXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vd3d3LmxhY2UuaW8vXCIsXG4gIH0sXG59O1xuXG5pbnRlcmZhY2UgV2FsbGV0Q29udGV4dFR5cGUge1xuICBpc01lbnVPcGVuOiBib29sZWFuO1xuICBvcGVuTWVudTogKCkgPT4gdm9pZDtcbiAgY2xvc2VNZW51OiAoKSA9PiB2b2lkO1xuICB3YWxsZXRzOiBBbGxTdXBwb3J0ZWRXYWxsZXRzO1xuICBjb25uZWN0ZWRXYWxsZXRzOiBDb25uZWN0ZWRXYWxsZXRbXTtcbiAgZGVmYXVsdFdhbGxldDogc3RyaW5nIHwgbnVsbDtcbiAgY29ubmVjdFdhbGxldDogKHdhbGxldE5hbWU6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZGlzY29ubmVjdFdhbGxldDogKHdhbGxldE5hbWU6IHN0cmluZykgPT4gdm9pZDtcbiAgc2V0RGVmYXVsdFdhbGxldDogKHdhbGxldE5hbWU6IHN0cmluZykgPT4gdm9pZDtcbiAgaW5zdGFsbGVkV2FsbGV0czogc3RyaW5nW107XG4gIGdldFdhbGxldEFwaTogKHdhbGxldE5hbWU6IHN0cmluZykgPT4gVFdhbGxldEFQSSB8IG51bGw7XG59XG5cbmNvbnN0IFdhbGxldENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFdhbGxldENvbnRleHRUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlV2FsbGV0KCkge1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dChXYWxsZXRDb250ZXh0KTtcbiAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVdhbGxldCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgV2FsbGV0UHJvdmlkZXJcIik7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXYWxsZXRQcm92aWRlcih7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9KSB7XG4gIGNvbnN0IFtpc01lbnVPcGVuLCBzZXRJc01lbnVPcGVuXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Nvbm5lY3RlZFdhbGxldHMsIHNldENvbm5lY3RlZFdhbGxldHNdID0gdXNlU3RhdGU8Q29ubmVjdGVkV2FsbGV0W10+KFxuICAgIFtdXG4gICk7XG4gIGNvbnN0IFtkZWZhdWx0V2FsbGV0LCBzZXREZWZhdWx0V2FsbGV0XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KFxuICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiZGVmYXVsdFdhbGxldFwiKVxuICApO1xuICBjb25zdCBbaW5zdGFsbGVkV2FsbGV0cywgc2V0SW5zdGFsbGVkV2FsbGV0c10gPSB1c2VTdGF0ZTxzdHJpbmdbXT4oW10pO1xuXG4gIGNvbnN0IGRldGVjdENvbm5lY3RlZFdhbGxldHMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgY2FyZGFubyA9IHdpbmRvdy5jYXJkYW5vO1xuICAgIGlmICghY2FyZGFubykgcmV0dXJuO1xuXG4gICAgY29uc3QgY29ubmVjdGVkOiBDb25uZWN0ZWRXYWxsZXRbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB3YWxsZXRdIG9mIE9iamVjdC5lbnRyaWVzKGFsbFN1cHBvcnRlZFdhbGxldHMpKSB7XG4gICAgICBpZiAoY2FyZGFub1trZXldKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgaXNFbmFibGVkID0gYXdhaXQgY2FyZGFub1trZXldLmlzRW5hYmxlZCgpO1xuICAgICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwaSA9IGF3YWl0IGNhcmRhbm9ba2V5XS5lbmFibGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3RlZC5wdXNoKHsgbmFtZTogd2FsbGV0Lm5hbWUsIGFwaSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZGV0ZWN0aW5nICR7d2FsbGV0Lm5hbWV9IGNvbm5lY3Rpb246YCwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0Q29ubmVjdGVkV2FsbGV0cyhjb25uZWN0ZWQpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY29ubmVjdFdhbGxldCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jICh3YWxsZXROYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGNhcmRhbm8gPSB3aW5kb3cuY2FyZGFubztcbiAgICAgIGlmICghY2FyZGFubykgcmV0dXJuO1xuXG4gICAgICBjb25zdCB3YWxsZXQgPSBjYXJkYW5vW3dhbGxldE5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIXdhbGxldCkgcmV0dXJuO1xuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhcGkgPSBhd2FpdCB3YWxsZXQuZW5hYmxlKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQ29ubmVjdGVkIHdhbGxldDpcIiwgd2FsbGV0TmFtZSwgYXBpKTtcbiAgICAgICAgc2V0Q29ubmVjdGVkV2FsbGV0cygocHJldikgPT4gWy4uLnByZXYsIHsgbmFtZTogd2FsbGV0TmFtZSwgYXBpIH1dKTtcblxuICAgICAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHtcbiAgICAgICAgICBzZXREZWZhdWx0V2FsbGV0KHdhbGxldE5hbWUpO1xuXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJkZWZhdWx0V2FsbGV0XCIsIHdhbGxldE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY29ubmVjdGluZyB3YWxsZXQ6XCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtkZWZhdWx0V2FsbGV0XVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFkZWZhdWx0V2FsbGV0ICYmIGNvbm5lY3RlZFdhbGxldHMubGVuZ3RoID4gMCkge1xuICAgICAgc2V0RGVmYXVsdFdhbGxldChjb25uZWN0ZWRXYWxsZXRzWzBdLm5hbWUpO1xuICAgIH1cbiAgfSwgW2RlZmF1bHRXYWxsZXQsIGNvbm5lY3RlZFdhbGxldHNdKTtcblxuICBjb25zdCBkaXNjb25uZWN0V2FsbGV0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHdhbGxldE5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgc2V0Q29ubmVjdGVkV2FsbGV0cygocHJldikgPT5cbiAgICAgICAgcHJldi5maWx0ZXIoKHdhbGxldCkgPT4gd2FsbGV0Lm5hbWUgIT09IHdhbGxldE5hbWUpXG4gICAgICApO1xuXG4gICAgICBpZiAoZGVmYXVsdFdhbGxldCA9PT0gd2FsbGV0TmFtZSkge1xuICAgICAgICBzZXREZWZhdWx0V2FsbGV0KG51bGwpO1xuICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImRlZmF1bHRXYWxsZXRcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZGVmYXVsdFdhbGxldF1cbiAgKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zb2xlLmxvZyhcImRlZmF1bHRXYWxsZXRcIiwgZGVmYXVsdFdhbGxldCk7XG4gIH0sIFtkZWZhdWx0V2FsbGV0XSk7XG5cbiAgY29uc3QgaGFuZGxlU2V0RGVmYXVsdFdhbGxldCA9IHVzZUNhbGxiYWNrKCh3YWxsZXROYW1lOiBzdHJpbmcpID0+IHtcbiAgICBzZXREZWZhdWx0V2FsbGV0KHdhbGxldE5hbWUpO1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFwiZGVmYXVsdFdhbGxldFwiLCB3YWxsZXROYW1lKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IG9wZW5NZW51ID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0SXNNZW51T3Blbih0cnVlKSwgW10pO1xuICBjb25zdCBjbG9zZU1lbnUgPSB1c2VDYWxsYmFjaygoKSA9PiBzZXRJc01lbnVPcGVuKGZhbHNlKSwgW10pO1xuXG4gIGNvbnN0IGRldGVjdEluc3RhbGxlZFdhbGxldHMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29uc3QgaW5zdGFsbGVkID0gT2JqZWN0LmtleXMoYWxsU3VwcG9ydGVkV2FsbGV0cykuZmlsdGVyKFxuICAgICAgKGtleSkgPT4gd2luZG93LmNhcmRhbm8gJiYgd2luZG93LmNhcmRhbm9ba2V5XVxuICAgICk7XG4gICAgc2V0SW5zdGFsbGVkV2FsbGV0cyhpbnN0YWxsZWQpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgZ2V0V2FsbGV0QXBpID0gdXNlQ2FsbGJhY2soXG4gICAgKHdhbGxldE5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3Qgd2FsbGV0ID0gY29ubmVjdGVkV2FsbGV0cy5maW5kKFxuICAgICAgICAodykgPT4gdy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IHdhbGxldE5hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgKTtcbiAgICAgIHJldHVybiB3YWxsZXQgPyB3YWxsZXQuYXBpIDogbnVsbDtcbiAgICB9LFxuICAgIFtjb25uZWN0ZWRXYWxsZXRzXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZGV0ZWN0SW5zdGFsbGVkV2FsbGV0cygpO1xuICAgIGRldGVjdENvbm5lY3RlZFdhbGxldHMoKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNhcmRhbm9cIiwgZGV0ZWN0SW5zdGFsbGVkV2FsbGV0cyk7XG4gICAgcmV0dXJuICgpID0+IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2FyZGFub1wiLCBkZXRlY3RJbnN0YWxsZWRXYWxsZXRzKTtcbiAgfSwgW2RldGVjdEluc3RhbGxlZFdhbGxldHMsIGRldGVjdENvbm5lY3RlZFdhbGxldHNdKTtcblxuICByZXR1cm4gKFxuICAgIDxXYWxsZXRDb250ZXh0LlByb3ZpZGVyXG4gICAgICB2YWx1ZT17e1xuICAgICAgICBpc01lbnVPcGVuLFxuICAgICAgICBvcGVuTWVudSxcbiAgICAgICAgY2xvc2VNZW51LFxuICAgICAgICB3YWxsZXRzOiBhbGxTdXBwb3J0ZWRXYWxsZXRzLFxuICAgICAgICBjb25uZWN0ZWRXYWxsZXRzLFxuICAgICAgICBkZWZhdWx0V2FsbGV0LFxuICAgICAgICBjb25uZWN0V2FsbGV0LFxuICAgICAgICBkaXNjb25uZWN0V2FsbGV0LFxuICAgICAgICBzZXREZWZhdWx0V2FsbGV0OiBoYW5kbGVTZXREZWZhdWx0V2FsbGV0LFxuICAgICAgICBpbnN0YWxsZWRXYWxsZXRzLFxuICAgICAgICBnZXRXYWxsZXRBcGksXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1dhbGxldENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG4iLCIvKipcbiAqIEBhdXRob3I6IEVyaWNrIEhlcm7DoW5kZXogU2lsdmEgKGVyaWNrQHl1bmdsZS5jb20ubXgpXG4gKiBAY3JlYXRlZDogMDEvMDEvMjAyNVxuICogQHVwZGF0ZWQ6IDAxLzAxLzIwMjUgICAgICAgXG4gKiBAZmlsZSBmaWxlVXBsb2FkLnRzXG4gKi9cblxuLy8gTWFpbiBwYXRoIGZvciB0aGUgQVBJXG5leHBvcnQgY29uc3QgQVBJX1BBVEg6IHN0cmluZyA9XG4gIFwiaHR0cHM6Ly8xcm96cDY0aWFqLmV4ZWN1dGUtYXBpLnVzLWVhc3QtMS5hbWF6b25hd3MuY29tL3ByZXByb2R1Y3Rpb25cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQXBpVXJsKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtBUElfUEFUSH0ke3BhdGh9YDtcbn1cblxuZXhwb3J0IGNvbnN0IEFQSV9LRVk6IHN0cmluZyA9IFwiWmZRN0JZN3Bid0FRR0dxNUZBT042QXhMV2Z3TWw3MjlRcDNXNUZxNlwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdG9IZXgoaW5wdXQ6IHN0cmluZyB8IHN0cmluZ1tdKTogc3RyaW5nIHwgc3RyaW5nW10ge1xuICBjb25zb2xlLmxvZyhpbnB1dCk7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZW5jb2RlVG9IZXggPSAoc3RyOiBzdHJpbmcpID0+IFxuICAgIEFycmF5LmZyb20oZW5jb2Rlci5lbmNvZGUoc3RyKSlcbiAgICAgIC5tYXAoYnl0ZSA9PiBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKVxuICAgICAgLmpvaW4oJycpO1xuXG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGVuY29kZVRvSGV4KGlucHV0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKGVuY29kZVRvSGV4KTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9IZXgoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCByYXcgPSBhdG9iKHN0cik7XG4gIGxldCByZXN1bHQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBoZXggPSByYXcuY2hhckNvZGVBdChpKS50b1N0cmluZygxNik7XG4gICAgcmVzdWx0ICs9IChoZXgubGVuZ3RoID09PSAyID8gaGV4IDogJzAnICsgaGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnRvVXBwZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVDogJ3ByZXByb2R1Y3Rpb24nIHwgJ3Byb2R1Y3Rpb24nID0gcHJvY2Vzcy5lbnYuRU5WSVJPTk1FTlQgYXMgJ3ByZXByb2R1Y3Rpb24nIHwgJ3Byb2R1Y3Rpb24nIHx8ICdwcmVwcm9kdWN0aW9uJzsiLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNvbnRleHQsXG4gIHVzZVN0YXRlLFxuICB1c2VDYWxsYmFjayxcbiAgdXNlRWZmZWN0LFxufSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFRXYWxsZXRBUEkgfSBmcm9tIFwiLi4vdHlwZXMvY2FyZGFub1wiO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIi4vV2FsbGV0Q29udGV4dFwiO1xuaW1wb3J0IHtcbiAgRmlsZVByb2dyZXNzLFxuICBDb25zdHJ1Y3RUeFJlcXVlc3QsXG4gIENvbnN0cnVjdFR4UmVzcG9uc2UsXG4gIFJldHJpZXZlVW5zaWduZWRUeFJlc3BvbnNlLFxuICBQcmVwYXJlZFVUWE9zLFxuICBUU3VibWlzc2lvblN0YXR1cyxcbiAgVERhdGFUeXBlcyxcbn0gZnJvbSBcIi4uL3R5cGVzL3RyYW5zYWN0aW9uXCI7XG5pbXBvcnQgeyBBUElfS0VZLCBiYXNlNjRUb0hleCwgYnVpbGRBcGlVcmwgfSBmcm9tIFwiLi4vdXRpbHMvYXBpQ29uc3VtcHRpb25cIjtcbmltcG9ydCB7IHVzZVR4U3RhdHVzIH0gZnJvbSBcIi4vVHhTdGF0dXNDb250ZXh0XCI7XG5cbmV4cG9ydCB0eXBlIFR4UHJlcGFyYXRpb25TdGVwID1cbiAgfCBcInByZXBhcmUvY29uc3RydWN0XCJcbiAgfCBcInByZXBhcmUvcmV0cmlldmVcIlxuICB8IFwicHJlcGFyZS9zdWJtaXRcIlxuICB8IFwicHJlcGFyZS9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI7XG5cbmludGVyZmFjZSBUeFByZXBhcmF0aW9uQ29udGV4dFR5cGUge1xuICBmaWxlUHJvZ3Jlc3M6IEZpbGVQcm9ncmVzc1tdO1xuICBwcmVwYXJlRmlsZXM6IChmaWxlczogRmlsZVtdKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBwcmVwYXJlVGV4dDogKHRleHQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgc2lnbkFuZFN1Ym1pdDogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgaXNQcm9jZXNzaW5nOiBib29sZWFuO1xuICBjdXJyZW50U3RlcDogVHhQcmVwYXJhdGlvblN0ZXA7XG4gIG5leHRTdGVwOiBUeFByZXBhcmF0aW9uU3RlcCB8IG51bGw7XG4gIGVycm9yOiBzdHJpbmcgfCBudWxsO1xuICBjbGVhckVycm9yOiAoKSA9PiB2b2lkO1xuICByZXNldDogKCkgPT4gdm9pZDtcbiAgc3VibWlzc2lvblN0YXR1cz86IFRTdWJtaXNzaW9uU3RhdHVzO1xuICBzZXRTdWJtaXNzaW9uU3RhdHVzOiAoc3RhdHVzOiBUU3VibWlzc2lvblN0YXR1cykgPT4gdm9pZDtcbiAgdW5zaWduZWRUeElkOiBzdHJpbmcgfCBudWxsO1xuICBzZXRVbnNpZ25lZFR4SWQ6ICh0eElkOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkO1xufVxuXG5jb25zdCBUeFByZXBhcmF0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8XG4gIFR4UHJlcGFyYXRpb25Db250ZXh0VHlwZSB8IHVuZGVmaW5lZFxuPih1bmRlZmluZWQpO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlVHhQcmVwYXJhdGlvbigpIHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoVHhQcmVwYXJhdGlvbkNvbnRleHQpO1xuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcInVzZVR4UHJlcGFyYXRpb24gbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFR4UHJlcGFyYXRpb25Qcm92aWRlclwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIFR4UHJlcGFyYXRpb25Qcm92aWRlcih7XG4gIGNoaWxkcmVuLFxufToge1xuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlO1xufSkge1xuICBjb25zdCBbZmlsZVByb2dyZXNzLCBzZXRGaWxlUHJvZ3Jlc3NdID0gdXNlU3RhdGU8RmlsZVByb2dyZXNzW10+KFtdKTtcbiAgY29uc3QgW2lzUHJvY2Vzc2luZywgc2V0SXNQcm9jZXNzaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgY29uc3QgeyBnZXRXYWxsZXRBcGksIGRlZmF1bHRXYWxsZXQgfSA9IHVzZVdhbGxldCgpO1xuICBjb25zdCB7IHByZXBhcmF0aW9uLCBtb3ZlVG9OZXh0U3RlcCB9ID0gdXNlVHhTdGF0dXMoKTtcbiAgY29uc3QgW3N1Ym1pc3Npb25TdGF0dXMsIHNldFN1Ym1pc3Npb25TdGF0dXNdID0gdXNlU3RhdGU8VFN1Ym1pc3Npb25TdGF0dXM+KCk7XG4gIGNvbnN0IFt1bnNpZ25lZFR4SWQsIHNldFVuc2lnbmVkVHhJZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcblxuICBjb25zdCB1cGRhdGVGaWxlUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjayhcbiAgICAoaW5kZXg6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxGaWxlUHJvZ3Jlc3M+KSA9PiB7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChpdGVtLCBpKSA9PiAoaSA9PT0gaW5kZXggPyB7IC4uLml0ZW0sIC4uLnVwZGF0ZXMgfSA6IGl0ZW0pKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3QgY2xlYXJFcnJvciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGNvbnN0cnVjdFR4ID0gYXN5bmMgKFxuICAgIGFwaTogVFdhbGxldEFQSSxcbiAgICBkYXRhOiBzdHJpbmcsXG4gICAgZGF0YVR5cGU6IFREYXRhVHlwZXNcbiAgKTogUHJvbWlzZTxDb25zdHJ1Y3RUeFJlc3BvbnNlPiA9PiB7XG4gICAgLy8gU2UgYXN1bWUgcXVlIGVsIGVzdGFkbyBpbmljaWFsIChcInByZXBhcmUvY29uc3RydWN0XCIgeSBcInByZXBhcmUvcmV0cmlldmVcIilcbiAgICAvLyB5YSBzZSBkZWZpbmnDsyBlbiBUeFN0YXR1c0NvbnRleHQgcGFyYSBsYSBwcmVwYXJhY2nDs24uXG4gICAgY29uc3QgcmV3YXJkQWRkcmVzc2VzID0gKGF3YWl0IGFwaS5nZXRSZXdhcmRBZGRyZXNzZXMoKSkgYXMgc3RyaW5nW107XG4gICAgY29uc3QgdXR4b3MgPSAoYXdhaXQgYXBpLmdldFV0eG9zKCkpIHx8IFtdO1xuICAgIGNvbnNvbGUubG9nKFwiVVRYT3M6XCIsIHV0eG9zKTtcbiAgICBjb25zdCB0YXJnZXRBZGRyZXNzID0gKGF3YWl0IGFwaS5nZXRVc2VkQWRkcmVzc2VzKCkpWzBdO1xuICAgIGlmICghdXR4b3MgfHwgdXR4b3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBzZXRFcnJvcihcIk5vIGhheSBVVFhPcyBkaXNwb25pYmxlc1wiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIFVUWE9zIGF2YWlsYWJsZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBib2R5OiBDb25zdHJ1Y3RUeFJlcXVlc3QgPSB7XG4gICAgICBkYXRhLFxuICAgICAgZGF0YVR5cGUsXG4gICAgICByZXdhcmRBZGRyZXNzZXMsXG4gICAgICB0YXJnZXRBZGRyZXNzLFxuICAgICAgdXR4b3MsXG4gICAgfTtcbiAgICBjb25zb2xlLmxvZyhcIkJvZHk6XCIsIGJvZHkpO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChidWlsZEFwaVVybChcIi9wcmVwYXJlLXV0eG9zL2NvbnN0cnVjdC10eFwiKSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIFwieC1hcGkta2V5XCI6IEFQSV9LRVkgfHwgXCJcIixcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB9KTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3JSZXNwb25zZS5qc29uKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICBlbmRwb2ludDogXCIvcHJlcGFyZS11dHhvcy9jb25zdHJ1Y3QtdHhcIixcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFNlIGF2YW56YSBhbCBzaWd1aWVudGUgcGFzbyBlbiBlbCBmbHVqbyBkZSBwcmVwYXJhY2nDs25cbiAgICBtb3ZlVG9OZXh0U3RlcChcInByZXBhcmF0aW9uXCIpO1xuICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIH07XG5cbiAgY29uc3QgcHJlcGFyZUZpbGVzID0gYXN5bmMgKGZpbGVzOiBGaWxlW10pID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBjb25uZWN0ZWRcIik7XG4gICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoXG4gICAgICAgIGZpbGVzLm1hcCgoZmlsZSkgPT4gKHtcbiAgICAgICAgICBmaWxlLFxuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIH0pKVxuICAgICAgKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoaSwgeyBzdGF0dXM6IFwiY29uc3RydWN0aW5nXCIsIHByb2dyZXNzOiAyNSB9KTtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgY29uc3QgZmlsZUFzQmFzZTY0ID0gYXdhaXQgbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCBhcyBzdHJpbmcpO1xuICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGVzW2ldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJhc2U2NENvbnRlbnQgPSBmaWxlQXNCYXNlNjQuc3BsaXQoXCIsXCIpWzFdO1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RlZFR4ID0gYXdhaXQgY29uc3RydWN0VHgoXG4gICAgICAgICAgYXBpLFxuICAgICAgICAgIGJhc2U2NENvbnRlbnQsXG4gICAgICAgICAgZmlsZXNbaV0udHlwZSBhcyBURGF0YVR5cGVzXG4gICAgICAgICk7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcygwLCB7XG4gICAgICAgICAgc3RhdHVzOiBcInVuc2lnbmVkXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDUwLFxuICAgICAgICAgIHR4SW5mbzogeyBjb25zdHJ1Y3RlZFR4IH0sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJwcmVwYXJhdGlvblwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHByZXBhcmluZyBmaWxlczpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwcmVwYXJlVGV4dCA9IGFzeW5jICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBjb25uZWN0ZWRcIik7XG4gICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZXh0RmlsZSA9IG5ldyBGaWxlKFt0ZXh0XSwgXCJkZWxlZ2F0ZS50eHRcIiwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KTtcbiAgICAgIHNldEZpbGVQcm9ncmVzcyhbXG4gICAgICAgIHtcbiAgICAgICAgICBmaWxlOiB0ZXh0RmlsZSxcbiAgICAgICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgICAgIHByb2dyZXNzOiAwLFxuICAgICAgICB9LFxuICAgICAgXSk7XG5cbiAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcygwLCB7IHN0YXR1czogXCJjb25zdHJ1Y3RpbmdcIiwgcHJvZ3Jlc3M6IDI1IH0pO1xuICAgICAgY29uc29sZS5sb2coXCJ0ZXh0XCIsIHRleHQpO1xuICAgICAgY29uc3QgYmFzZTY0Q29udGVudCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpKSk7XG4gICAgICBjb25zb2xlLmxvZyhcImJhc2U2NENvbnRlbnRcIiwgYmFzZTY0Q29udGVudCk7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFR4ID0gYXdhaXQgY29uc3RydWN0VHgoXG4gICAgICAgIGFwaSxcbiAgICAgICAgYmFzZTY0Q29udGVudCxcbiAgICAgICAgXCJ0ZXh0L3BsYWluXCIgYXMgVERhdGFUeXBlc1xuICAgICAgKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiY29uc3RydWN0ZWRUeFwiLCBjb25zdHJ1Y3RlZFR4KTtcbiAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcygwLCB7XG4gICAgICAgIHN0YXR1czogXCJ1bnNpZ25lZFwiLFxuICAgICAgICBwcm9ncmVzczogNTAsXG4gICAgICAgIHR4SW5mbzogeyBjb25zdHJ1Y3RlZFR4IH0sXG4gICAgICB9KTtcbiAgICAgIG1vdmVUb05leHRTdGVwKFwicHJlcGFyYXRpb25cIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBwcmVwYXJpbmcgdGV4dDpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBwb2xsRm9yQ29uZmlybWF0aW9uID0gYXN5bmMgKFxuICAgIHByZXBhcmVkVHg6IFByZXBhcmVkVVRYT3NcbiAgKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gICAgY29uc3QgcmV0cnlJbnRlcnZhbCA9IDkwMDA7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgYnVpbGRBcGlVcmwoXCIvcHJlcGFyZS11dHhvcy9yZXRyaWV2ZS1zdWJtaXNzaW9uLXN0YXR1c1wiKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSB8fCBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHByZXBhcmVkVHguZXhlY3V0aW9uQXJuKSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gcmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IGVycm9yUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL3ByZXBhcmUtdXR4b3MvcmV0cmlldmUtc3VibWlzc2lvbi1zdGF0dXNcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXM6IGFueSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgaWYgKHN0YXR1cy5zdWNjZXNzICYmIHN0YXR1cy5zdWNjZXNzLm9uY2hhaW4gPT09IFwib24tY2hhaW5cIikge1xuICAgICAgICAgIHNldFN1Ym1pc3Npb25TdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgICAgIG1vdmVUb05leHRTdGVwKFwicHJlcGFyYXRpb25cIik7XG4gICAgICAgICAgY2xlYXJFcnJvcigpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlIGNvbnRpbsO6YSBoYWNpZW5kbyBwb2xsaW5nIG1pZW50cmFzIGxhIHRyYW5zYWNjacOzbiBubyBlc3TDqSBvbi1jaGFpblxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgcmV0cnlJbnRlcnZhbCkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlBvbGxpbmcgYXR0ZW1wdCBmYWlsZWQ6XCIsIGVycm9yKTtcbiAgICAgICAgc2V0RXJyb3IoXG4gICAgICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgICAgKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciA9IChlcnJvcjogYW55KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNpZ24gYW5kIHN1Ym1pdDpcIiwgZXJyb3IpO1xuXG4gICAgLy8gRm9ybWF0IHRoZSBlcnJvciBtZXNzYWdlIGJhc2VkIG9uIHRoZSBlcnJvciB0eXBlXG4gICAgbGV0IGVycm9yTWVzc2FnZTogc3RyaW5nO1xuXG4gICAgLy8gSGFuZGxlIFR4U2lnbkVycm9yIGZyb20gd2FsbGV0XG4gICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiVHhTaWduRXJyb3JcIikge1xuICAgICAgZXJyb3JNZXNzYWdlID0gYFdhbGxldCBzaWduaW5nIGVycm9yOiAke1xuICAgICAgICBlcnJvci5pbmZvIHx8IGVycm9yLm1lc3NhZ2UgfHwgXCJGYWlsZWQgdG8gc2lnbiB0cmFuc2FjdGlvblwiXG4gICAgICB9YDtcbiAgICB9XG4gICAgLy8gSGFuZGxlIEVycm9yIG9iamVjdHNcbiAgICBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gcGFyc2UgdGhlIGVycm9yIG1lc3NhZ2UgYXMgSlNPTlxuICAgICAgICBjb25zdCBwYXJzZWRFcnJvciA9IEpTT04ucGFyc2UoZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgcGFyc2VkRXJyb3IuZXJyb3I/Lm1lc3NhZ2UgfHwgcGFyc2VkRXJyb3IubWVzc2FnZSB8fCBlcnJvci5tZXNzYWdlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiBwYXJzaW5nIGZhaWxzLCB1c2UgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZSB8fCBcIlVua25vd24gZXJyb3Igb2NjdXJyZWRcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIG90aGVyIGVycm9yIHR5cGVzXG4gICAgZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShlcnJvcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgc2V0RmlsZVByb2dyZXNzKChwcmV2KSA9PlxuICAgICAgcHJldi5tYXAoKGZpbGUpID0+ICh7IC4uLmZpbGUsIHN0YXR1czogXCJmYWlsZWRcIiwgcHJvZ3Jlc3M6IDAgfSkpXG4gICAgKTtcbiAgICAvLyBEb24ndCByZXNldCB0aGUgc3RlcCB0byB0aGUgYmVnaW5uaW5nIGZvciB3YWxsZXQgc2lnbmluZyBlcnJvcnNcbiAgICAvLyBUaGlzIGFsbG93cyB1c2VycyB0byByZXRyeSBmcm9tIHRoZSBjdXJyZW50IHN0ZXBcbiAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJUeFNpZ25FcnJvclwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldhbGxldCBzaWduaW5nIGVycm9yIGRldGVjdGVkLCBrZWVwaW5nIGN1cnJlbnQgc3RlcFwiKTtcbiAgICAgIC8vIEp1c3Qgc2V0IHByb2Nlc3NpbmcgdG8gZmFsc2UgYnV0IGRvbid0IGNoYW5nZSB0aGUgc3RlcFxuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIG90aGVyIGVycm9ycywgd2UgY2FuIHJlc2V0IHByb2Nlc3Npbmcgc3RhdGVcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNpZ25BbmRTdWJtaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFkZWZhdWx0V2FsbGV0KSB0aHJvdyBuZXcgRXJyb3IoXCJObyB3YWxsZXQgY29ubmVjdGVkXCIpO1xuICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcbiAgICB0cnkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlUHJvZ3Jlc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGZpbGVQcm9ncmVzc1tpXTtcbiAgICAgICAgY29uc29sZS5sb2coXCJmaWxlXCIsIGZpbGUpO1xuICAgICAgICBpZiAoIWZpbGUudHhJbmZvPy5jb25zdHJ1Y3RlZFR4KSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgeyBleGVjdXRpb25Bcm4gfSA9IGZpbGUudHhJbmZvLmNvbnN0cnVjdGVkVHg7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY3V0aW9uQXJuXCIsIGV4ZWN1dGlvbkFybik7XG5cbiAgICAgICAgY29uc3QgdW5zaWduZWRUeFJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXG4gICAgICAgICAgYnVpbGRBcGlVcmwoXCIvcHJlcGFyZS11dHhvcy9yZXRyaWV2ZS11bnNpZ25lZC10eFwiKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSB8fCBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGV4ZWN1dGlvbkFybiksXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXVuc2lnbmVkVHhSZXNwb25zZS5vaykge1xuICAgICAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSB1bnNpZ25lZFR4UmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IGVycm9yUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHVuc2lnbmVkVHhSZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiB1bnNpZ25lZFR4UmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB1bnNpZ25lZFR4UmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL3ByZXBhcmUtdXR4b3MvcmV0cmlldmUtdW5zaWduZWQtdHhcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdW5zaWduZWRUeDogUmV0cmlldmVVbnNpZ25lZFR4UmVzcG9uc2UgPVxuICAgICAgICAgIGF3YWl0IHVuc2lnbmVkVHhSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5zaWduZWQgVFg6XCIsIHVuc2lnbmVkVHgpO1xuXG4gICAgICAgIC8vIEd1YXJkYXIgZWwgdHhpZCBjdWFuZG8gZXN0w6EgZGlzcG9uaWJsZVxuICAgICAgICBpZiAodW5zaWduZWRUeC5zdWNjZXNzICYmIHVuc2lnbmVkVHguc3VjY2Vzcy50eGlkKSB7XG4gICAgICAgICAgc2V0VW5zaWduZWRUeElkKHVuc2lnbmVkVHguc3VjY2Vzcy50eGlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh1bnNpZ25lZFR4LmluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICB3aGlsZSAodW5zaWduZWRUeC5pblByb2dyZXNzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuc2lnbmVkIHRyYW5zYWN0aW9uIHN0aWxsIGluIHByb2dyZXNzLi4uXCIpO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIDUwMDApKTtcbiAgICAgICAgICAgIGNvbnN0IHJldHJ5UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICAgICAgYnVpbGRBcGlVcmwoXCIvcHJlcGFyZS11dHhvcy9yZXRyaWV2ZS11bnNpZ25lZC10eFwiKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShleGVjdXRpb25Bcm4pLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFyZXRyeVJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHJldHJ5UmVzcG9uc2UuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBlcnJvclJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IHJldHJ5UmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IHJldHJ5UmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgc3RhdHVzVGV4dDogcmV0cnlSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yRGF0YSxcbiAgICAgICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9wcmVwYXJlLXV0eG9zL3JldHJpZXZlLXVuc2lnbmVkLXR4XCIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVuc2lnbmVkVHggPSBhd2FpdCByZXRyeVJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmV0cnkgVW5zaWduZWQgVFg6XCIsIHVuc2lnbmVkVHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgcHJvZ3Jlc3M6IDc1LFxuICAgICAgICAgIHR4SW5mbzogeyAuLi5maWxlLnR4SW5mbywgdW5zaWduZWRUeCB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBoZXhUeCA9IGJhc2U2NFRvSGV4KHVuc2lnbmVkVHguc3VjY2Vzcy50eCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGV4IFRYOlwiLCBoZXhUeCk7XG5cbiAgICAgICAgbGV0IHNpZ25lZFR4O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENsZWFyIGFueSBwcmV2aW91cyBlcnJvciBzdGF0ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byBzaWduIGFnYWluXG4gICAgICAgICAgY2xlYXJFcnJvcigpO1xuXG4gICAgICAgICAgLy8gR2V0IGEgZnJlc2ggd2FsbGV0IEFQSSBpbnN0YW5jZSB0byBlbnN1cmUgdGhlIHBvcHVwIGFwcGVhcnMgYWdhaW5cbiAgICAgICAgICBjb25zdCBhcGkgPSBnZXRXYWxsZXRBcGkoZGVmYXVsdFdhbGxldCkgYXMgVFdhbGxldEFQSTtcblxuICAgICAgICAgIHNpZ25lZFR4ID0gYXdhaXQgYXBpLnNpZ25UeChoZXhUeCk7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJTaWduZWQgVFg6XCIsIHNpZ25lZFR4KTtcblxuICAgICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgICBzdGF0dXM6IFwic2lnbmVkXCIsXG4gICAgICAgICAgICBwcm9ncmVzczogODUsXG4gICAgICAgICAgICB0eEluZm86IHsgLi4uZmlsZS50eEluZm8sIHVuc2lnbmVkVHgsIHNpZ25lZFR4IH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdGVwIG9ubHkgYWZ0ZXIgc3VjY2Vzc2Z1bCBzaWduaW5nXG4gICAgICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJwcmVwYXJhdGlvblwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzaWduaW5nIHRyYW5zYWN0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICAgLy8gRG9uJ3QgbW92ZSB0byB0aGUgbmV4dCBzdGVwIGlmIHRoZXJlJ3MgYSBzaWduaW5nIGVycm9yXG4gICAgICAgICAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gcmV0cnkgc2lnbmluZyBmcm9tIHRoZSBzYW1lIHN0ZXBcbiAgICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gXCJUeFNpZ25FcnJvclwiKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gTGV0IHRoZSBoYW5kbGVTaWduQW5kU3VibWl0RXJyb3IgZnVuY3Rpb24gaGFuZGxlIHRoaXMgc3BlY2lmaWMgZXJyb3JcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb246ICR7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSB8fCBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3VibWl0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICBidWlsZEFwaVVybChcIi9wcmVwYXJlLXV0eG9zL3N1Ym1pdFwiKSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSB8fCBcIlwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgdHg6IHVuc2lnbmVkVHguc3VjY2Vzcy50eCxcbiAgICAgICAgICAgICAgdWxpZDogdW5zaWduZWRUeC5zdWNjZXNzLnVsaWQsXG4gICAgICAgICAgICAgIHdpdG5lc3NTZXQ6IHNpZ25lZFR4LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICBpZiAoIXN1Ym1pdFJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHN1Ym1pdFJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBlcnJvclJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBzdWJtaXRSZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiBzdWJtaXRSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHN1Ym1pdFJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGEsXG4gICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9wcmVwYXJlLXV0eG9zL3N1Ym1pdFwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Ym1pdHRlZFR4OiBQcmVwYXJlZFVUWE9zID0gYXdhaXQgc3VibWl0UmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCBUWDpcIiwgc3VibWl0dGVkVHgpO1xuICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0ZXAgYWZ0ZXIgc3VjY2Vzc2Z1bCBzdWJtaXNzaW9uXG4gICAgICAgIG1vdmVUb05leHRTdGVwKFwicHJlcGFyYXRpb25cIik7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgc3RhdHVzOiBcInN1Ym1pdHRlZFwiLFxuICAgICAgICAgIHByb2dyZXNzOiA5NSxcbiAgICAgICAgICB0eEluZm86IHsgLi4uZmlsZS50eEluZm8sIHVuc2lnbmVkVHgsIHNpZ25lZFR4LCBzdWJtaXR0ZWRUeCB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb25maXJtZWQgPSBhd2FpdCBwb2xsRm9yQ29uZmlybWF0aW9uKHN1Ym1pdHRlZFR4KTtcbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICBzdGF0dXM6IGNvbmZpcm1lZCA/IFwiY29uZmlybWVkXCIgOiBcImZhaWxlZFwiLFxuICAgICAgICAgIHByb2dyZXNzOiBjb25maXJtZWQgPyAxMDAgOiAwLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaGFuZGxlU2lnbkFuZFN1Ym1pdEVycm9yKGVycm9yKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVzZXQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgc2V0RmlsZVByb2dyZXNzKFtdKTtcbiAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIHNldFN1Ym1pc3Npb25TdGF0dXModW5kZWZpbmVkKTtcbiAgICBzZXRVbnNpZ25lZFR4SWQobnVsbCk7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gIH0sIFtdKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJFcnJvciBkZXRlY3RlZCBpbiBUeFByZXBhcmF0aW9uQ29udGV4dDpcIiwgZXJyb3IpO1xuXG4gICAgICAvLyBVcGRhdGUgYWxsIGZpbGUgcHJvZ3Jlc3MgdG8gZmFpbGVkIHN0YXR1cyB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICAgICAgc2V0RmlsZVByb2dyZXNzKChwcmV2KSA9PlxuICAgICAgICBwcmV2Lm1hcCgoZmlsZSkgPT4gKHsgLi4uZmlsZSwgc3RhdHVzOiBcImZhaWxlZFwiLCBwcm9ncmVzczogMCB9KSlcbiAgICAgICk7XG5cbiAgICAgIC8vIEVuc3VyZSBwcm9jZXNzaW5nIHN0YXRlIGlzIHJlc2V0XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSwgW2Vycm9yXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8VHhQcmVwYXJhdGlvbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGZpbGVQcm9ncmVzcyxcbiAgICAgICAgcHJlcGFyZUZpbGVzLFxuICAgICAgICBwcmVwYXJlVGV4dCxcbiAgICAgICAgc2lnbkFuZFN1Ym1pdCxcbiAgICAgICAgaXNQcm9jZXNzaW5nLFxuICAgICAgICBjdXJyZW50U3RlcDogcHJlcGFyYXRpb24uY3VycmVudFN0ZXAgYXMgVHhQcmVwYXJhdGlvblN0ZXAsXG4gICAgICAgIG5leHRTdGVwOiBwcmVwYXJhdGlvbi5uZXh0U3RlcCBhcyBUeFByZXBhcmF0aW9uU3RlcCB8IG51bGwsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBjbGVhckVycm9yLFxuICAgICAgICByZXNldCxcbiAgICAgICAgc3VibWlzc2lvblN0YXR1cyxcbiAgICAgICAgc2V0U3VibWlzc2lvblN0YXR1cyxcbiAgICAgICAgdW5zaWduZWRUeElkLFxuICAgICAgICBzZXRVbnNpZ25lZFR4SWQsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1R4UHJlcGFyYXRpb25Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgQ2xvc2VJY29uUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBDbG9zZUljb246IFJlYWN0LkZDPENsb3NlSWNvblByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB3aWR0aD1cIjMwXCJcbiAgICAgIGhlaWdodD1cIjMwXCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMzAgMzBcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xNSAyOC40Mzc1QzcuNTg3NSAyOC40Mzc1IDEuNTYyNSAyMi40MTI1IDEuNTYyNSAxNUMxLjU2MjUgNy41ODc1IDcuNTg3NSAxLjU2MjUgMTUgMS41NjI1QzIyLjQxMjUgMS41NjI1IDI4LjQzNzUgNy41ODc1IDI4LjQzNzUgMTVDMjguNDM3NSAyMi40MTI1IDIyLjQxMjUgMjguNDM3NSAxNSAyOC40Mzc1Wk0xNSAzLjQzNzVDOC42MjUgMy40Mzc1IDMuNDM3NSA4LjYyNSAzLjQzNzUgMTVDMy40Mzc1IDIxLjM3NSA4LjYyNSAyNi41NjI1IDE1IDI2LjU2MjVDMjEuMzc1IDI2LjU2MjUgMjYuNTYyNSAyMS4zNzUgMjYuNTYyNSAxNUMyNi41NjI1IDguNjI1IDIxLjM3NSAzLjQzNzUgMTUgMy40Mzc1WlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMTEuNDYyNyAxOS40NzVDMTEuMjI1MiAxOS40NzUgMTAuOTg3NyAxOS4zODc1IDEwLjgwMDIgMTkuMkMxMC40Mzc3IDE4LjgzNzUgMTAuNDM3NyAxOC4yMzc1IDEwLjgwMDIgMTcuODc1TDE3Ljg3NTIgMTAuOEMxOC4yMzc3IDEwLjQzNzUgMTguODM3NyAxMC40Mzc1IDE5LjIwMDIgMTAuOEMxOS41NjI3IDExLjE2MjUgMTkuNTYyNyAxMS43NjI1IDE5LjIwMDIgMTIuMTI1TDEyLjEyNTIgMTkuMkMxMS45NTAyIDE5LjM4NzUgMTEuNzAwMiAxOS40NzUgMTEuNDYyNyAxOS40NzVaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xOC41Mzc3IDE5LjQ3NUMxOC4zMDAyIDE5LjQ3NSAxOC4wNjI3IDE5LjM4NzUgMTcuODc1MiAxOS4yTDEwLjgwMDIgMTIuMTI1QzEwLjQzNzcgMTEuNzYyNSAxMC40Mzc3IDExLjE2MjUgMTAuODAwMiAxMC44QzExLjE2MjcgMTAuNDM3NSAxMS43NjI3IDEwLjQzNzUgMTIuMTI1MiAxMC44TDE5LjIwMDIgMTcuODc1QzE5LjU2MjcgMTguMjM3NSAxOS41NjI3IDE4LjgzNzUgMTkuMjAwMiAxOS4yQzE5LjAxMjcgMTkuMzg3NSAxOC43NzUyIDE5LjQ3NSAxOC41Mzc3IDE5LjQ3NVpcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1vdGlvbiwgTW90aW9uVmFsdWUgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiO1xuXG5pbnRlcmZhY2UgQnV0dG9uUHJvcHMgZXh0ZW5kcyBSZWFjdC5CdXR0b25IVE1MQXR0cmlidXRlczxIVE1MQnV0dG9uRWxlbWVudD4ge1xuICB2YXJpYW50PzogXCJwcmltYXJ5XCIgfCBcInNlY29uZGFyeVwiIHwgXCJnaG9zdFwiIHwgXCJpY29uXCI7XG4gIGxvYWRpbmdUZXh0Pzogc3RyaW5nO1xuICBzdWNjZXNzVGV4dD86IHN0cmluZztcbiAgaWNvbkJlZm9yZT86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgaWNvbkFmdGVyPzogUmVhY3QuUmVhY3ROb2RlO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgYW5pbWF0ZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjb25zdCBCdXR0b246IFJlYWN0LkZDPEJ1dHRvblByb3BzPiA9ICh7XG4gIGNoaWxkcmVuLFxuICB2YXJpYW50ID0gXCJwcmltYXJ5XCIsXG4gIGxvYWRpbmdUZXh0LFxuICBzdWNjZXNzVGV4dCxcbiAgaWNvbkJlZm9yZSxcbiAgaWNvbkFmdGVyLFxuICBvbkNsaWNrLFxuICBhbmltYXRlID0gdHJ1ZSxcbiAgY2xhc3NOYW1lID0gXCJcIixcbiAgLi4ucHJvcHNcbn0pID0+IHtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2lzU3VjY2Vzcywgc2V0SXNTdWNjZXNzXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBoYW5kbGVDbGljayA9IGFzeW5jIChldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IHtcbiAgICBpZiAob25DbGljaykge1xuICAgICAgc2V0SXNMb2FkaW5nKGFuaW1hdGUpO1xuICAgICAgYXdhaXQgb25DbGljayhldmVudCk7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgc2V0SXNTdWNjZXNzKGFuaW1hdGUpO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRJc1N1Y2Nlc3MoZmFsc2UpLCAyMDAwKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgYmFzZUNsYXNzZXMgPVxuICAgIFwiIWZsZXggIWp1c3RpZnktY2VudGVyICFpdGVtcy1jZW50ZXIgIWdhcC0yICFyb3VuZGVkLWZ1bGwgIXRyYW5zaXRpb24tY29sb3JzICFkdXJhdGlvbi0zMDAgIWZvY3VzOm91dGxpbmUtbm9uZSAhZm9udC1ib2xkIGN1cnNvci1wb2ludGVyXCI7XG4gIGNvbnN0IHZhcmlhbnRDbGFzc2VzID0ge1xuICAgIHByaW1hcnk6XG4gICAgICBcIiFib3JkZXIgIWJvcmRlci13aGl0ZSAhYmctd2hpdGUgIXRleHQtcHJpbWFyeS10dyBob3ZlcjohYmctdHJhbnNwYXJlbnQgaG92ZXI6IXRleHQtd2hpdGVcIixcbiAgICBzZWNvbmRhcnk6XG4gICAgICBcIiFib3JkZXIgIWJvcmRlci13aGl0ZSAhYmctdHJhbnNwYXJlbnQgIXRleHQtd2hpdGUgaG92ZXI6IXRleHQtd2hpdGVcIixcbiAgICBnaG9zdDogXCIhYmctdHJhbnNwYXJlbnQgIXRleHQtd2hpdGUgaG92ZXI6IWJnLXdoaXRlLzEwXCIsXG4gICAgaWNvbjogXCIhcm91bmRlZC1mdWxsICF3LTEwICFoLTEwICFwLTJcIixcbiAgfTtcbiAgY29uc3QgZGlzYWJsZWRDbGFzc2VzID0gXCIhb3BhY2l0eS01MCAhY3Vyc29yLW5vdC1hbGxvd2VkXCI7XG4gIGNvbnN0IHNpemVDbGFzc2VzID0gdmFyaWFudCA9PT0gXCJpY29uXCIgPyBcIlwiIDogXCJweC01IHB5LTJcIjtcblxuICBjb25zdCBidXR0b25DbGFzc2VzID0gYCR7YmFzZUNsYXNzZXN9ICR7dmFyaWFudENsYXNzZXNbdmFyaWFudF19ICR7c2l6ZUNsYXNzZXN9ICR7Y2xhc3NOYW1lfSAke3Byb3BzLmRpc2FibGVkID8gZGlzYWJsZWRDbGFzc2VzIDogXCJcIn1gO1xuXG4gIHJldHVybiAoXG4gICAgPG1vdGlvbi5idXR0b25cbiAgICAgIGNsYXNzTmFtZT17YnV0dG9uQ2xhc3Nlc31cbiAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsaWNrfVxuICAgICAgd2hpbGVUYXA9e3sgc2NhbGU6IDAuOTUgfX1cbiAgICAgIHsuLi4ocHJvcHMgYXMgYW55KX1cbiAgICA+XG4gICAgICB7aXNMb2FkaW5nID8gKFxuICAgICAgICA8PlxuICAgICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01IGJvcmRlci10LTIgYm9yZGVyLWItMiBib3JkZXItY3VycmVudCByb3VuZGVkLWZ1bGxcIlxuICAgICAgICAgICAgYW5pbWF0ZT17eyByb3RhdGU6IDM2MCB9fVxuICAgICAgICAgICAgdHJhbnNpdGlvbj17e1xuICAgICAgICAgICAgICBkdXJhdGlvbjogMSxcbiAgICAgICAgICAgICAgcmVwZWF0OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICAgIGVhc2U6IFwibGluZWFyXCIsXG4gICAgICAgICAgICB9fVxuICAgICAgICAgIC8+XG4gICAgICAgICAge2xvYWRpbmdUZXh0fVxuICAgICAgICA8Lz5cbiAgICAgICkgOiBpc1N1Y2Nlc3MgPyAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgIGluaXRpYWw9e3sgc2NhbGU6IDAgfX1cbiAgICAgICAgICAgIGFuaW1hdGU9e3sgc2NhbGU6IDEgfX1cbiAgICAgICAgICAgIHRyYW5zaXRpb249e3sgdHlwZTogXCJzcHJpbmdcIiwgc3RpZmZuZXNzOiA1MDAsIGRhbXBpbmc6IDMwIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAg4pyTXG4gICAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgICAgIHtzdWNjZXNzVGV4dH1cbiAgICAgICAgPC8+XG4gICAgICApIDogKFxuICAgICAgICA8PlxuICAgICAgICAgIHtpY29uQmVmb3JlfVxuICAgICAgICAgIHtBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IChcbiAgICAgICAgICAgIGNoaWxkcmVuLm1hcCgoY2hpbGQsIGluZGV4KSA9PlxuICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIE1vdGlvblZhbHVlID8gKFxuICAgICAgICAgICAgICAgIDxtb3Rpb24uc3BhbiBrZXk9e2luZGV4fT57Y2hpbGR9PC9tb3Rpb24uc3Bhbj5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICBjaGlsZFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSA6IGNoaWxkcmVuIGluc3RhbmNlb2YgTW90aW9uVmFsdWUgPyAoXG4gICAgICAgICAgICA8bW90aW9uLnNwYW4+e2NoaWxkcmVufTwvbW90aW9uLnNwYW4+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIGNoaWxkcmVuXG4gICAgICAgICAgKX1cbiAgICAgICAgICB7aWNvbkFmdGVyfVxuICAgICAgICA8Lz5cbiAgICAgICl9XG4gICAgPC9tb3Rpb24uYnV0dG9uPlxuICApO1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW50ZXJmYWNlIFBkZkljb25Qcm9wcyB7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IFBkZkljb246IFJlYWN0LkZDPFBkZkljb25Qcm9wcz4gPSAoeyBjbGFzc05hbWUgfSkgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzdmdcbiAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgd2lkdGg9XCI0OFwiXG4gICAgICBoZWlnaHQ9XCI0OFwiXG4gICAgICB2aWV3Qm94PVwiMCAwIDQ4IDQ4XCJcbiAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgID5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNNDIgMjguNUM0MiAyOC44OTc4IDQxLjg0MiAyOS4yNzk0IDQxLjU2MDcgMjkuNTYwN0M0MS4yNzk0IDI5Ljg0MiA0MC44OTc4IDMwIDQwLjUgMzBIMzZWMzNIMzlDMzkuMzk3OCAzMyAzOS43Nzk0IDMzLjE1OCA0MC4wNjA3IDMzLjQzOTNDNDAuMzQyIDMzLjcyMDYgNDAuNSAzNC4xMDIyIDQwLjUgMzQuNUM0MC41IDM0Ljg5NzggNDAuMzQyIDM1LjI3OTQgNDAuMDYwNyAzNS41NjA3QzM5Ljc3OTQgMzUuODQyIDM5LjM5NzggMzYgMzkgMzZIMzZWMzlDMzYgMzkuMzk3OCAzNS44NDIgMzkuNzc5NCAzNS41NjA3IDQwLjA2MDdDMzUuMjc5NCA0MC4zNDIgMzQuODk3OCA0MC41IDM0LjUgNDAuNUMzNC4xMDIyIDQwLjUgMzMuNzIwNiA0MC4zNDIgMzMuNDM5MyA0MC4wNjA3QzMzLjE1OCAzOS43Nzk0IDMzIDM5LjM5NzggMzMgMzlWMjguNUMzMyAyOC4xMDIyIDMzLjE1OCAyNy43MjA2IDMzLjQzOTMgMjcuNDM5M0MzMy43MjA2IDI3LjE1OCAzNC4xMDIyIDI3IDM0LjUgMjdINDAuNUM0MC44OTc4IDI3IDQxLjI3OTQgMjcuMTU4IDQxLjU2MDcgMjcuNDM5M0M0MS44NDIgMjcuNzIwNiA0MiAyOC4xMDIyIDQyIDI4LjVaTTE3LjI1IDMyLjI1QzE3LjI1IDMzLjY0MjQgMTYuNjk2OSAzNC45Nzc3IDE1LjcxMjMgMzUuOTYyM0MxNC43Mjc3IDM2Ljk0NjkgMTMuMzkyNCAzNy41IDEyIDM3LjVIMTAuNVYzOUMxMC41IDM5LjM5NzggMTAuMzQyIDM5Ljc3OTQgMTAuMDYwNyA0MC4wNjA3QzkuNzc5MzYgNDAuMzQyIDkuMzk3ODIgNDAuNSA5IDQwLjVDOC42MDIxOCA0MC41IDguMjIwNjQgNDAuMzQyIDcuOTM5MzQgNDAuMDYwN0M3LjY1ODA0IDM5Ljc3OTQgNy41IDM5LjM5NzggNy41IDM5VjI4LjVDNy41IDI4LjEwMjIgNy42NTgwNCAyNy43MjA2IDcuOTM5MzQgMjcuNDM5M0M4LjIyMDY0IDI3LjE1OCA4LjYwMjE4IDI3IDkgMjdIMTJDMTMuMzkyNCAyNyAxNC43Mjc3IDI3LjU1MzEgMTUuNzEyMyAyOC41Mzc3QzE2LjY5NjkgMjkuNTIyMyAxNy4yNSAzMC44NTc2IDE3LjI1IDMyLjI1Wk0xNC4yNSAzMi4yNUMxNC4yNSAzMS42NTMzIDE0LjAxMjkgMzEuMDgxIDEzLjU5MSAzMC42NTlDMTMuMTY5IDMwLjIzNzEgMTIuNTk2NyAzMCAxMiAzMEgxMC41VjM0LjVIMTJDMTIuNTk2NyAzNC41IDEzLjE2OSAzNC4yNjI5IDEzLjU5MSAzMy44NDFDMTQuMDEyOSAzMy40MTkgMTQuMjUgMzIuODQ2NyAxNC4yNSAzMi4yNVpNMzAuNzUgMzMuNzVDMzAuNzUgMzUuNTQwMiAzMC4wMzg4IDM3LjI1NzEgMjguNzczIDM4LjUyM0MyNy41MDcxIDM5Ljc4ODggMjUuNzkwMiA0MC41IDI0IDQwLjVIMjFDMjAuNjAyMiA0MC41IDIwLjIyMDYgNDAuMzQyIDE5LjkzOTMgNDAuMDYwN0MxOS42NTggMzkuNzc5NCAxOS41IDM5LjM5NzggMTkuNSAzOVYyOC41QzE5LjUgMjguMTAyMiAxOS42NTggMjcuNzIwNiAxOS45MzkzIDI3LjQzOTNDMjAuMjIwNiAyNy4xNTggMjAuNjAyMiAyNyAyMSAyN0gyNEMyNS43OTAyIDI3IDI3LjUwNzEgMjcuNzExMiAyOC43NzMgMjguOTc3QzMwLjAzODggMzAuMjQyOSAzMC43NSAzMS45NTk4IDMwLjc1IDMzLjc1Wk0yNy43NSAzMy43NUMyNy43NSAzMi43NTU0IDI3LjM1NDkgMzEuODAxNiAyNi42NTE2IDMxLjA5ODRDMjUuOTQ4NCAzMC4zOTUxIDI0Ljk5NDYgMzAgMjQgMzBIMjIuNVYzNy41SDI0QzI0Ljk5NDYgMzcuNSAyNS45NDg0IDM3LjEwNDkgMjYuNjUxNiAzNi40MDE2QzI3LjM1NDkgMzUuNjk4NCAyNy43NSAzNC43NDQ2IDI3Ljc1IDMzLjc1Wk03LjUgMjFWNy41QzcuNSA2LjcwNDM1IDcuODE2MDcgNS45NDEyOSA4LjM3ODY4IDUuMzc4NjhDOC45NDEyOSA0LjgxNjA3IDkuNzA0MzUgNC41IDEwLjUgNC41SDI4LjVDMjguNjk3IDQuNDk5ODUgMjguODkyMiA0LjUzODUxIDI5LjA3NDMgNC42MTM4QzI5LjI1NjQgNC42ODkwOCAyOS40MjE4IDQuNzk5NSAyOS41NjEzIDQuOTM4NzVMNDAuMDYxMiAxNS40Mzg4QzQwLjIwMDUgMTUuNTc4MiA0MC4zMTA5IDE1Ljc0MzYgNDAuMzg2MiAxNS45MjU3QzQwLjQ2MTUgMTYuMTA3OCA0MC41MDAyIDE2LjMwMyA0MC41IDE2LjVWMjFDNDAuNSAyMS4zOTc4IDQwLjM0MiAyMS43Nzk0IDQwLjA2MDcgMjIuMDYwN0MzOS43Nzk0IDIyLjM0MiAzOS4zOTc4IDIyLjUgMzkgMjIuNUMzOC42MDIyIDIyLjUgMzguMjIwNiAyMi4zNDIgMzcuOTM5MyAyMi4wNjA3QzM3LjY1OCAyMS43Nzk0IDM3LjUgMjEuMzk3OCAzNy41IDIxVjE4SDI4LjVDMjguMTAyMiAxOCAyNy43MjA2IDE3Ljg0MiAyNy40MzkzIDE3LjU2MDdDMjcuMTU4IDE3LjI3OTQgMjcgMTYuODk3OCAyNyAxNi41VjcuNUgxMC41VjIxQzEwLjUgMjEuMzk3OCAxMC4zNDIgMjEuNzc5NCAxMC4wNjA3IDIyLjA2MDdDOS43NzkzNiAyMi4zNDIgOS4zOTc4MiAyMi41IDkgMjIuNUM4LjYwMjE4IDIyLjUgOC4yMjA2NCAyMi4zNDIgNy45MzkzNCAyMi4wNjA3QzcuNjU4MDQgMjEuNzc5NCA3LjUgMjEuMzk3OCA3LjUgMjFaTTMwIDE1SDM1LjM3OTRMMzAgOS42MjA2M1YxNVpcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gICk7XG59O1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUG5nSWNvblByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgUG5nSWNvbjogUmVhY3QuRkM8UG5nSWNvblByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB3aWR0aD1cIjQ4XCJcbiAgICAgIGhlaWdodD1cIjQ4XCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgNDggNDhcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xMS4yNSAyN0g4LjI1QzcuODUyMTggMjcgNy40NzA2NCAyNy4xNTggNy4xODkzNCAyNy40MzkzQzYuOTA4MDQgMjcuNzIwNiA2Ljc1IDI4LjEwMjIgNi43NSAyOC41VjM5QzYuNzUgMzkuMzk3OCA2LjkwODA0IDM5Ljc3OTQgNy4xODkzNCA0MC4wNjA3QzcuNDcwNjQgNDAuMzQyIDcuODUyMTggNDAuNSA4LjI1IDQwLjVDOC42NDc4MiA0MC41IDkuMDI5MzYgNDAuMzQyIDkuMzEwNjYgNDAuMDYwN0M5LjU5MTk2IDM5Ljc3OTQgOS43NSAzOS4zOTc4IDkuNzUgMzlWMzcuNUgxMS4yNUMxMi42NDI0IDM3LjUgMTMuOTc3NyAzNi45NDY5IDE0Ljk2MjMgMzUuOTYyM0MxNS45NDY5IDM0Ljk3NzcgMTYuNSAzMy42NDI0IDE2LjUgMzIuMjVDMTYuNSAzMC44NTc2IDE1Ljk0NjkgMjkuNTIyMyAxNC45NjIzIDI4LjUzNzdDMTMuOTc3NyAyNy41NTMxIDEyLjY0MjQgMjcgMTEuMjUgMjdaTTExLjI1IDM0LjVIOS43NVYzMEgxMS4yNUMxMS44NDY3IDMwIDEyLjQxOSAzMC4yMzcxIDEyLjg0MSAzMC42NTlDMTMuMjYyOSAzMS4wODEgMTMuNSAzMS42NTMzIDEzLjUgMzIuMjVDMTMuNSAzMi44NDY3IDEzLjI2MjkgMzMuNDE5IDEyLjg0MSAzMy44NDFDMTIuNDE5IDM0LjI2MjkgMTEuODQ2NyAzNC41IDExLjI1IDM0LjVaTTQyIDM3LjY2MzFDNDIgMzguMDQ5NSA0MS44NTA4IDM4LjQyMDkgNDEuNTgzNyAzOC43QzQxLjA2MTUgMzkuMjYyMiA0MC40Mjk4IDM5LjcxMTkgMzkuNzI3NiA0MC4wMjE0QzM5LjAyNTQgNDAuMzMwOSAzOC4yNjc0IDQwLjQ5MzggMzcuNSA0MC41QzM0LjE5MDYgNDAuNSAzMS41IDM3LjQ3MTkgMzEuNSAzMy43NUMzMS41IDMwLjAyODEgMzQuMTkwNiAyNyAzNy41IDI3QzM4LjYwMjYgMjcuMDAzNyAzOS42Nzg4IDI3LjMzNzQgNDAuNTkgMjcuOTU4MUM0MC45MTk5IDI4LjE4MTkgNDEuMTQ3NSAyOC41Mjc2IDQxLjIyMjYgMjguOTE5MUM0MS4yOTc2IDI5LjMxMDcgNDEuMjE0MSAyOS43MTYgNDAuOTkwMyAzMC4wNDU5QzQwLjc2NjUgMzAuMzc1OSA0MC40MjA5IDMwLjYwMzQgNDAuMDI5MyAzMC42Nzg1QzM5LjYzNzggMzAuNzUzNiAzOS4yMzI0IDMwLjY3IDM4LjkwMjUgMzAuNDQ2M0MzOC40OTExIDMwLjE1ODcgMzguMDAxOSAzMC4wMDMxIDM3LjUgMzBDMzUuODQ2MyAzMCAzNC41IDMxLjY4NzUgMzQuNSAzMy43NUMzNC41IDM1LjgxMjUgMzUuODQ2MyAzNy41IDM3LjUgMzcuNUMzOC4wNDE1IDM3LjQ5NCAzOC41NjcgMzcuMzE1MyAzOSAzNi45OVYzNkMzOC42MDIyIDM2IDM4LjIyMDYgMzUuODQyIDM3LjkzOTMgMzUuNTYwN0MzNy42NTggMzUuMjc5NCAzNy41IDM0Ljg5NzggMzcuNSAzNC41QzM3LjUgMzQuMTAyMiAzNy42NTggMzMuNzIwNiAzNy45MzkzIDMzLjQzOTNDMzguMjIwNiAzMy4xNTggMzguNjAyMiAzMyAzOSAzM0g0MC41QzQwLjg5NzggMzMgNDEuMjc5NCAzMy4xNTggNDEuNTYwNyAzMy40MzkzQzQxLjg0MiAzMy43MjA2IDQyIDM0LjEwMjIgNDIgMzQuNVYzNy42NjMxWk0yOS4yNSAyOC41VjM5QzI5LjI1IDM5LjMxNzkgMjkuMTQ5MSAzOS42Mjc2IDI4Ljk2MTcgMzkuODg0NEMyOC43NzQ0IDQwLjE0MTIgMjguNTEwMiA0MC4zMzE4IDI4LjIwNzUgNDAuNDI4OEMyOC4wNTk3IDQwLjQ3NjMgMjcuOTA1MyA0MC41MDA0IDI3Ljc1IDQwLjVDMjcuNTExMiA0MC41IDI3LjI3NTkgNDAuNDQzIDI3LjA2MzYgNDAuMzMzOEMyNi44NTEzIDQwLjIyNDUgMjYuNjY4MiA0MC4wNjYyIDI2LjUyOTQgMzkuODcxOUwyMS43NSAzMy4xODc1VjM5QzIxLjc1IDM5LjM5NzggMjEuNTkyIDM5Ljc3OTQgMjEuMzEwNyA0MC4wNjA3QzIxLjAyOTQgNDAuMzQyIDIwLjY0NzggNDAuNSAyMC4yNSA0MC41QzE5Ljg1MjIgNDAuNSAxOS40NzA2IDQwLjM0MiAxOS4xODkzIDQwLjA2MDdDMTguOTA4IDM5Ljc3OTQgMTguNzUgMzkuMzk3OCAxOC43NSAzOVYyOC41QzE4Ljc1IDI4LjE4MjIgMTguODUwOSAyNy44NzI2IDE5LjAzODIgMjcuNjE1OEMxOS4yMjU2IDI3LjM1OTEgMTkuNDg5NiAyNy4xNjg1IDE5Ljc5MjIgMjcuMDcxNUMyMC4wOTQ5IDI2Ljk3NDUgMjAuNDIwNSAyNi45NzYyIDIwLjcyMjIgMjcuMDc2MkMyMS4wMjM4IDI3LjE3NjIgMjEuMjg1OSAyNy4zNjk1IDIxLjQ3MDYgMjcuNjI4MUwyNi4yNSAzNC4zMTI1VjI4LjVDMjYuMjUgMjguMTAyMiAyNi40MDggMjcuNzIwNiAyNi42ODkzIDI3LjQzOTNDMjYuOTcwNiAyNy4xNTggMjcuMzUyMiAyNyAyNy43NSAyN0MyOC4xNDc4IDI3IDI4LjUyOTQgMjcuMTU4IDI4LjgxMDcgMjcuNDM5M0MyOS4wOTIgMjcuNzIwNiAyOS4yNSAyOC4xMDIyIDI5LjI1IDI4LjVaTTkgMjIuNUM5LjM5NzgyIDIyLjUgOS43NzkzNiAyMi4zNDIgMTAuMDYwNyAyMi4wNjA3QzEwLjM0MiAyMS43Nzk0IDEwLjUgMjEuMzk3OCAxMC41IDIxVjcuNUgyN1YxNi41QzI3IDE2Ljg5NzggMjcuMTU4IDE3LjI3OTQgMjcuNDM5MyAxNy41NjA3QzI3LjcyMDYgMTcuODQyIDI4LjEwMjIgMTggMjguNSAxOEgzNy41VjIxQzM3LjUgMjEuMzk3OCAzNy42NTggMjEuNzc5NCAzNy45MzkzIDIyLjA2MDdDMzguMjIwNiAyMi4zNDIgMzguNjAyMiAyMi41IDM5IDIyLjVDMzkuMzk3OCAyMi41IDM5Ljc3OTQgMjIuMzQyIDQwLjA2MDcgMjIuMDYwN0M0MC4zNDIgMjEuNzc5NCA0MC41IDIxLjM5NzggNDAuNSAyMVYxNi41QzQwLjUwMDIgMTYuMzAzIDQwLjQ2MTUgMTYuMTA3OCA0MC4zODYyIDE1LjkyNTdDNDAuMzEwOSAxNS43NDM2IDQwLjIwMDUgMTUuNTc4MiA0MC4wNjEyIDE1LjQzODhMMjkuNTYxMyA0LjkzODc1QzI5LjQyMTggNC43OTk1IDI5LjI1NjQgNC42ODkwOCAyOS4wNzQzIDQuNjEzOEMyOC44OTIyIDQuNTM4NTEgMjguNjk3IDQuNDk5ODUgMjguNSA0LjVIMTAuNUM5LjcwNDM1IDQuNSA4Ljk0MTI5IDQuODE2MDcgOC4zNzg2OCA1LjM3ODY4QzcuODE2MDcgNS45NDEyOSA3LjUgNi43MDQzNSA3LjUgNy41VjIxQzcuNSAyMS4zOTc4IDcuNjU4MDQgMjEuNzc5NCA3LjkzOTM0IDIyLjA2MDdDOC4yMjA2NCAyMi4zNDIgOC42MDIxOCAyMi41IDkgMjIuNVpNMzAgOS42MjA2M0wzNS4zNzk0IDE1SDMwVjkuNjIwNjNaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgIDwvc3ZnPlxuICApO1xufTtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIlxuXG5pbnRlcmZhY2UgUGRnSWNvblByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBQZGdJY29uOiBSZWFjdC5GQzxQZGdJY29uUHJvcHM+ID0gKHsgY2xhc3NOYW1lIH0pID0+IHtcbiAgcmV0dXJuIChcbiAgICA8c3ZnXG4gICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgIHdpZHRoPVwiNDhcIlxuICAgICAgaGVpZ2h0PVwiNDhcIlxuICAgICAgdmlld0JveD1cIjAgMCA0OCA0OFwiXG4gICAgICBmaWxsPVwibm9uZVwiXG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICA+XG4gICAgICA8cGF0aFxuICAgICAgICBkPVwiTTExLjI1IDI3SDguMjVDNy44NTIxOCAyNyA3LjQ3MDY0IDI3LjE1OCA3LjE4OTM0IDI3LjQzOTNDNi45MDgwNCAyNy43MjA2IDYuNzUgMjguMTAyMiA2Ljc1IDI4LjVWMzlDNi43NSAzOS4zOTc4IDYuOTA4MDQgMzkuNzc5NCA3LjE4OTM0IDQwLjA2MDdDNy40NzA2NCA0MC4zNDIgNy44NTIxOCA0MC41IDguMjUgNDAuNUM4LjY0NzgyIDQwLjUgOS4wMjkzNiA0MC4zNDIgOS4zMTA2NiA0MC4wNjA3QzkuNTkxOTYgMzkuNzc5NCA5Ljc1IDM5LjM5NzggOS43NSAzOVYzNy41SDExLjI1QzEyLjY0MjQgMzcuNSAxMy45Nzc3IDM2Ljk0NjkgMTQuOTYyMyAzNS45NjIzQzE1Ljk0NjkgMzQuOTc3NyAxNi41IDMzLjY0MjQgMTYuNSAzMi4yNUMxNi41IDMwLjg1NzYgMTUuOTQ2OSAyOS41MjIzIDE0Ljk2MjMgMjguNTM3N0MxMy45Nzc3IDI3LjU1MzEgMTIuNjQyNCAyNyAxMS4yNSAyN1pNMTEuMjUgMzQuNUg5Ljc1VjMwSDExLjI1QzExLjg0NjcgMzAgMTIuNDE5IDMwLjIzNzEgMTIuODQxIDMwLjY1OUMxMy4yNjI5IDMxLjA4MSAxMy41IDMxLjY1MzMgMTMuNSAzMi4yNUMxMy41IDMyLjg0NjcgMTMuMjYyOSAzMy40MTkgMTIuODQxIDMzLjg0MUMxMi40MTkgMzQuMjYyOSAxMS44NDY3IDM0LjUgMTEuMjUgMzQuNVpNNDIgMzcuNjYzMUM0MiAzOC4wNDk1IDQxLjg1MDggMzguNDIwOSA0MS41ODM3IDM4LjdDNDEuMDYxNSAzOS4yNjIyIDQwLjQyOTggMzkuNzExOSAzOS43Mjc2IDQwLjAyMTRDMzkuMDI1NCA0MC4zMzA5IDM4LjI2NzQgNDAuNDkzOCAzNy41IDQwLjVDMzQuMTkwNiA0MC41IDMxLjUgMzcuNDcxOSAzMS41IDMzLjc1QzMxLjUgMzAuMDI4MSAzNC4xOTA2IDI3IDM3LjUgMjdDMzguNjAyNiAyNy4wMDM3IDM5LjY3ODggMjcuMzM3NCA0MC41OSAyNy45NTgxQzQwLjkxOTkgMjguMTgxOSA0MS4xNDc1IDI4LjUyNzYgNDEuMjIyNiAyOC45MTkxQzQxLjI5NzYgMjkuMzEwNyA0MS4yMTQxIDI5LjcxNiA0MC45OTAzIDMwLjA0NTlDNDAuNzY2NSAzMC4zNzU5IDQwLjQyMDkgMzAuNjAzNCA0MC4wMjkzIDMwLjY3ODVDMzkuNjM3OCAzMC43NTM2IDM5LjIzMjQgMzAuNjcgMzguOTAyNSAzMC40NDYzQzM4LjQ5MTEgMzAuMTU4NyAzOC4wMDE5IDMwLjAwMzEgMzcuNSAzMEMzNS44NDYzIDMwIDM0LjUgMzEuNjg3NSAzNC41IDMzLjc1QzM0LjUgMzUuODEyNSAzNS44NDYzIDM3LjUgMzcuNSAzNy41QzM4LjA0MTUgMzcuNDk0IDM4LjU2NyAzNy4zMTUzIDM5IDM2Ljk5VjM2QzM4LjYwMjIgMzYgMzguMjIwNiAzNS44NDIgMzcuOTM5MyAzNS41NjA3QzM3LjY1OCAzNS4yNzk0IDM3LjUgMzQuODk3OCAzNy41IDM0LjVDMzcuNSAzNC4xMDIyIDM3LjY1OCAzMy43MjA2IDM3LjkzOTMgMzMuNDM5M0MzOC4yMjA2IDMzLjE1OCAzOC42MDIyIDMzIDM5IDMzSDQwLjVDNDAuODk3OCAzMyA0MS4yNzk0IDMzLjE1OCA0MS41NjA3IDMzLjQzOTNDNDEuODQyIDMzLjcyMDYgNDIgMzQuMTAyMiA0MiAzNC41VjM3LjY2MzFaTTI5LjI1IDI4LjVWMzlDMjkuMjUgMzkuMzE3OSAyOS4xNDkxIDM5LjYyNzYgMjguOTYxNyAzOS44ODQ0QzI4Ljc3NDQgNDAuMTQxMiAyOC41MTAyIDQwLjMzMTggMjguMjA3NSA0MC40Mjg4QzI4LjA1OTcgNDAuNDc2MyAyNy45MDUzIDQwLjUwMDQgMjcuNzUgNDAuNUMyNy41MTEyIDQwLjUgMjcuMjc1OSA0MC40NDMgMjcuMDYzNiA0MC4zMzM4QzI2Ljg1MTMgNDAuMjI0NSAyNi42NjgyIDQwLjA2NjIgMjYuNTI5NCAzOS44NzE5TDIxLjc1IDMzLjE4NzVWMzlDMjEuNzUgMzkuMzk3OCAyMS41OTIgMzkuNzc5NCAyMS4zMTA3IDQwLjA2MDdDMjEuMDI5NCA0MC4zNDIgMjAuNjQ3OCA0MC41IDIwLjI1IDQwLjVDMTkuODUyMiA0MC41IDE5LjQ3MDYgNDAuMzQyIDE5LjE4OTMgNDAuMDYwN0MxOC45MDggMzkuNzc5NCAxOC43NSAzOS4zOTc4IDE4Ljc1IDM5VjI4LjVDMTguNzUgMjguMTgyMiAxOC44NTA5IDI3Ljg3MjYgMTkuMDM4MiAyNy42MTU4QzE5LjIyNTYgMjcuMzU5MSAxOS40ODk2IDI3LjE2ODUgMTkuNzkyMiAyNy4wNzE1QzIwLjA5NDkgMjYuOTc0NSAyMC40MjA1IDI2Ljk3NjIgMjAuNzIyMiAyNy4wNzYyQzIxLjAyMzggMjcuMTc2MiAyMS4yODU5IDI3LjM2OTUgMjEuNDcwNiAyNy42MjgxTDI2LjI1IDM0LjMxMjVWMjguNUMyNi4yNSAyOC4xMDIyIDI2LjQwOCAyNy43MjA2IDI2LjY4OTMgMjcuNDM5M0MyNi45NzA2IDI3LjE1OCAyNy4zNTIyIDI3IDI3Ljc1IDI3QzI4LjE0NzggMjcgMjguNTI5NCAyNy4xNTggMjguODEwNyAyNy40MzkzQzI5LjA5MiAyNy43MjA2IDI5LjI1IDI4LjEwMjIgMjkuMjUgMjguNVpNOSAyMi41QzkuMzk3ODIgMjIuNSA5Ljc3OTM2IDIyLjM0MiAxMC4wNjA3IDIyLjA2MDdDMTAuMzQyIDIxLjc3OTQgMTAuNSAyMS4zOTc4IDEwLjUgMjFWNy41SDI3VjE2LjVDMjcgMTYuODk3OCAyNy4xNTggMTcuMjc5NCAyNy40MzkzIDE3LjU2MDdDMjcuNzIwNiAxNy44NDIgMjguMTAyMiAxOCAyOC41IDE4SDM3LjVWMjFDMzcuNSAyMS4zOTc4IDM3LjY1OCAyMS43Nzk0IDM3LjkzOTMgMjIuMDYwN0MzOC4yMjA2IDIyLjM0MiAzOC42MDIyIDIyLjUgMzkgMjIuNUMzOS4zOTc4IDIyLjUgMzkuNzc5NCAyMi4zNDIgNDAuMDYwNyAyMi4wNjA3QzQwLjM0MiAyMS43Nzk0IDQwLjUgMjEuMzk3OCA0MC41IDIxVjE2LjVDNDAuNTAwMiAxNi4zMDMgNDAuNDYxNSAxNi4xMDc4IDQwLjM4NjIgMTUuOTI1N0M0MC4zMTA5IDE1Ljc0MzYgNDAuMjAwNSAxNS41NzgyIDQwLjA2MTIgMTUuNDM4OEwyOS41NjEzIDQuOTM4NzVDMjkuNDIxOCA0Ljc5OTUgMjkuMjU2NCA0LjY4OTA4IDI5LjA3NDMgNC42MTM4QzI4Ljg5MjIgNC41Mzg1MSAyOC42OTcgNC40OTk4NSAyOC41IDQuNUgxMC41QzkuNzA0MzUgNC41IDguOTQxMjkgNC44MTYwNyA4LjM3ODY4IDUuMzc4NjhDNy44MTYwNyA1Ljk0MTI5IDcuNSA2LjcwNDM1IDcuNSA3LjVWMjFDNy41IDIxLjM5NzggNy42NTgwNCAyMS43Nzk0IDcuOTM5MzQgMjIuMDYwN0M4LjIyMDY0IDIyLjM0MiA4LjYwMjE4IDIyLjUgOSAyMi41Wk0zMCA5LjYyMDYzTDM1LjM3OTQgMTVIMzBWOS42MjA2M1pcIlxuICAgICAgICBmaWxsPVwiY3VycmVudENvbG9yXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gIClcbn1cblxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgTXA0SWNvblByb3BzIHtcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgTXA0SWNvbjogUmVhY3QuRkM8TXA0SWNvblByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB3aWR0aD1cIjQ4XCJcbiAgICAgIGhlaWdodD1cIjQ4XCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgNDggNDhcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk00MiAyOC41QzQyIDI4Ljg5NzggNDEuODQyIDI5LjI3OTQgNDEuNTYwNyAyOS41NjA3QzQxLjI3OTQgMjkuODQyIDQwLjg5NzggMzAgNDAuNSAzMEgzNlYzM0gzOUMzOS4zOTc4IDMzIDM5Ljc3OTQgMzMuMTU4IDQwLjA2MDcgMzMuNDM5M0M0MC4zNDIgMzMuNzIwNiA0MC41IDM0LjEwMjIgNDAuNSAzNC41QzQwLjUgMzQuODk3OCA0MC4zNDIgMzUuMjc5NCA0MC4wNjA3IDM1LjU2MDdDMzkuNzc5NCAzNS44NDIgMzkuMzk3OCAzNiAzOSAzNkgzNlYzOUMzNiAzOS4zOTc4IDM1Ljg0MiAzOS43Nzk0IDM1LjU2MDcgNDAuMDYwN0MzNS4yNzk0IDQwLjM0MiAzNC44OTc4IDQwLjUgMzQuNSA0MC41QzM0LjEwMjIgNDAuNSAzMy43MjA2IDQwLjM0MiAzMy40MzkzIDQwLjA2MDdDMzMuMTU4IDM5Ljc3OTQgMzMgMzkuMzk3OCAzMyAzOVYyOC41QzMzIDI4LjEwMjIgMzMuMTU4IDI3LjcyMDYgMzMuNDM5MyAyNy40MzkzQzMzLjcyMDYgMjcuMTU4IDM0LjEwMjIgMjcgMzQuNSAyN0g0MC41QzQwLjg5NzggMjcgNDEuMjc5NCAyNy4xNTggNDEuNTYwNyAyNy40MzkzQzQxLjg0MiAyNy43MjA2IDQyIDI4LjEwMjIgNDIgMjguNVpNMTcuMjUgMzIuMjVDMTcuMjUgMzMuNjQyNCAxNi42OTY5IDM0Ljk3NzcgMTUuNzEyMyAzNS45NjIzQzE0LjcyNzcgMzYuOTQ2OSAxMy4zOTI0IDM3LjUgMTIgMzcuNUgxMC41VjM5QzEwLjUgMzkuMzk3OCAxMC4zNDIgMzkuNzc5NCAxMC4wNjA3IDQwLjA2MDdDOS43NzkzNiA0MC4zNDIgOS4zOTc4MiA0MC41IDkgNDAuNUM4LjYwMjE4IDQwLjUgOC4yMjA2NCA0MC4zNDIgNy45MzkzNCA0MC4wNjA3QzcuNjU4MDQgMzkuNzc5NCA3LjUgMzkuMzk3OCA3LjUgMzlWMjguNUM3LjUgMjguMTAyMiA3LjY1ODA0IDI3LjcyMDYgNy45MzkzNCAyNy40MzkzQzguMjIwNjQgMjcuMTU4IDguNjAyMTggMjcgOSAyN0gxMkMxMy4zOTI0IDI3IDE0LjcyNzcgMjcuNTUzMSAxNS43MTIzIDI4LjUzNzdDMTYuNjk2OSAyOS41MjIzIDE3LjI1IDMwLjg1NzYgMTcuMjUgMzIuMjVaTTE0LjI1IDMyLjI1QzE0LjI1IDMxLjY1MzMgMTQuMDEyOSAzMS4wODEgMTMuNTkxIDMwLjY1OUMxMy4xNjkgMzAuMjM3MSAxMi41OTY3IDMwIDEyIDMwSDEwLjVWMzQuNUgxMkMxMi41OTY3IDM0LjUgMTMuMTY5IDM0LjI2MjkgMTMuNTkxIDMzLjg0MUMxNC4wMTI5IDMzLjQxOSAxNC4yNSAzMi44NDY3IDE0LjI1IDMyLjI1Wk0zMC43NSAzMy43NUMzMC43NSAzNS41NDAyIDMwLjAzODggMzcuMjU3MSAyOC43NzMgMzguNTIzQzI3LjUwNzEgMzkuNzg4OCAyNS43OTAyIDQwLjUgMjQgNDAuNUgyMUMyMC42MDIyIDQwLjUgMjAuMjIwNiA0MC4zNDIgMTkuOTM5MyA0MC4wNjA3QzE5LjY1OCAzOS43Nzk0IDE5LjUgMzkuMzk3OCAxOS41IDM5VjI4LjVDMTkuNSAyOC4xMDIyIDE5LjY1OCAyNy43MjA2IDE5LjkzOTMgMjcuNDM5M0MyMC4yMjA2IDI3LjE1OCAyMC42MDIyIDI3IDIxIDI3SDI0QzI1Ljc5MDIgMjcgMjcuNTA3MSAyNy43MTEyIDI4Ljc3MyAyOC45NzdDMzAuMDM4OCAzMC4yNDI5IDMwLjc1IDMxLjk1OTggMzAuNzUgMzMuNzVaTTI3Ljc1IDMzLjc1QzI3Ljc1IDMyLjc1NTQgMjcuMzU0OSAzMS44MDE2IDI2LjY1MTYgMzEuMDk4NEMyNS45NDg0IDMwLjM5NTEgMjQuOTk0NiAzMCAyNCAzMEgyMi41VjM3LjVIMjRDMjQuOTk0NiAzNy41IDI1Ljk0ODQgMzcuMTA0OSAyNi42NTE2IDM2LjQwMTZDMjcuMzU0OSAzNS42OTg0IDI3Ljc1IDM0Ljc0NDYgMjcuNzUgMzMuNzVaTTcuNSAyMVY3LjVDNy41IDYuNzA0MzUgNy44MTYwNyA1Ljk0MTI5IDguMzc4NjggNS4zNzg2OEM4Ljk0MTI5IDQuODE2MDcgOS43MDQzNSA0LjUgMTAuNSA0LjVIMjguNUMyOC42OTcgNC40OTk4NSAyOC44OTIyIDQuNTM4NTEgMjkuMDc0MyA0LjYxMzhDMjkuMjU2NCA0LjY4OTA4IDI5LjQyMTggNC43OTk1IDI5LjU2MTMgNC45Mzg3NUw0MC4wNjEyIDE1LjQzODhDNDAuMjAwNSAxNS41NzgyIDQwLjMxMDkgMTUuNzQzNiA0MC4zODYyIDE1LjkyNTdDNDAuNDYxNSAxNi4xMDc4IDQwLjUwMDIgMTYuMzAzIDQwLjUgMTYuNVYyMUM0MC41IDIxLjM5NzggNDAuMzQyIDIxLjc3OTQgNDAuMDYwNyAyMi4wNjA3QzM5Ljc3OTQgMjIuMzQyIDM5LjM5NzggMjIuNSAzOSAyMi41QzM4LjYwMjIgMjIuNSAzOC4yMjA2IDIyLjM0MiAzNy45MzkzIDIyLjA2MDdDMzcuNjU4IDIxLjc3OTQgMzcuNSAyMS4zOTc4IDM3LjUgMjFWMThIMjguNUMyOC4xMDIyIDE4IDI3LjcyMDYgMTcuODQyIDI3LjQzOTMgMTcuNTYwN0MyNy4xNTggMTcuMjc5NCAyNyAxNi44OTc4IDI3IDE2LjVWNy41SDEwLjVWMjFDMTAuNSAyMS4zOTc4IDEwLjM0MiAyMS43Nzk0IDEwLjA2MDcgMjIuMDYwN0M5Ljc3OTM2IDIyLjM0MiA5LjM5NzgyIDIyLjUgOSAyMi41QzguNjAyMTggMjIuNSA4LjIyMDY0IDIyLjM0MiA3LjkzOTM0IDIyLjA2MDdDNy42NTgwNCAyMS43Nzk0IDcuNSAyMS4zOTc4IDcuNSAyMVpNMzAgMTVIMzUuMzc5NEwzMCA5LjYyMDYzVjE1WlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJcInVzZSBjbGllbnRcIlxuXG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCJcbmltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuaW1wb3J0IHsgdXNlRmlsZVVwbG9hZCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L0ZpbGVVcGxvYWRDb250ZXh0XCJcbmltcG9ydCB7IHVzZVR4UHJlcGFyYXRpb24gfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeFByZXBhcmF0aW9uQ29udGV4dFwiXG5pbXBvcnQgeyBDbG9zZUljb24gfSBmcm9tIFwiLi4vLi4vaWNvbnMvQ2xvc2VJY29uXCJcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCIuLi91aS9CdXR0b25cIlxuaW1wb3J0IHsgUGRmSWNvbiB9IGZyb20gXCIuLi8uLi9pY29ucy9QZGZJY29uXCJcbmltcG9ydCB7IFBuZ0ljb24gfSBmcm9tIFwiLi4vLi4vaWNvbnMvUG5nSWNvblwiXG5pbXBvcnQgeyBQZGdJY29uIH0gZnJvbSBcIi4uLy4uL2ljb25zL1BkZ0ljb25cIlxuaW1wb3J0IHsgTXA0SWNvbiB9IGZyb20gXCIuLi8uLi9pY29ucy9NcDRJY29uXCJcbmltcG9ydCB7IHVzZVR4U3RhdHVzIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhTdGF0dXNDb250ZXh0XCJcblxuZXhwb3J0IGZ1bmN0aW9uIEZpbGVMaXN0KCk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBjb25zdCB7IGZpbGUsIHJlbW92ZUZpbGUgfSA9IHVzZUZpbGVVcGxvYWQoKVxuICBjb25zdCB7IGZpbGVQcm9ncmVzcywgaXNQcm9jZXNzaW5nLCBjdXJyZW50U3RlcCB9ID0gdXNlVHhQcmVwYXJhdGlvbigpXG4gIGNvbnN0IHtwcmVwYXJhdGlvbn0gPSB1c2VUeFN0YXR1cygpXG5cbiAgaWYgKCFmaWxlKSByZXR1cm4gbnVsbFxuXG4gIC8vIENvbW8gc29sbyBzZSBhZG1pdGUgdW4gYXJjaGl2bywgc2UgdXNhIGVsIHByaW1lciBlbGVtZW50byBkZSBmaWxlUHJvZ3Jlc3MgKHNpIGV4aXN0ZSlcbiAgY29uc3QgcHJvZ3Jlc3MgPSBmaWxlUHJvZ3Jlc3NbMF1cblxuICByZXR1cm4gKFxuICAgIDxtb3Rpb24uZGl2XG4gICAgICBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00XCJcbiAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCB9fVxuICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxIH19XG4gICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjUgfX1cbiAgICA+XG4gICAgICA8QW5pbWF0ZVByZXNlbmNlPlxuICAgICAgICA8bW90aW9uLmRpdlxuICAgICAgICAgIGtleT17ZmlsZS5uYW1lfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgcC00IGJnLXdoaXRlLzUgcm91bmRlZC1sZ1wiXG4gICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB5OiAyMCB9fVxuICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeTogMCB9fVxuICAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCwgeDogLTIwIH19XG4gICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC4zIH19XG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtNFwiPlxuICAgICAgICAgICAgICB7ZmlsZS5wcmV2aWV3ID8gKFxuICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgIHNyYz17ZmlsZS5wcmV2aWV3fVxuICAgICAgICAgICAgICAgICAgYWx0PVwiUHJldmlld1wiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTEwIGgtMTAgcm91bmRlZCBvYmplY3QtY292ZXJcIlxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTEwIGgtMTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgIHtmaWxlLnR5cGUgPT09IFwiYXBwbGljYXRpb24vcGRmXCIgPyAoXG4gICAgICAgICAgICAgICAgICAgIDxQZGZJY29uIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgdGV4dC13aGl0ZVwiIC8+XG4gICAgICAgICAgICAgICAgICApIDogZmlsZS50eXBlID09PSBcImltYWdlL3BuZ1wiID8gKFxuICAgICAgICAgICAgICAgICAgICA8UG5nSWNvbiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIHRleHQtd2hpdGVcIiAvPlxuICAgICAgICAgICAgICAgICAgKSA6IGZpbGUudHlwZSA9PT0gXCJpbWFnZS9wZGdcIiA/IChcbiAgICAgICAgICAgICAgICAgICAgPFBkZ0ljb24gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCB0ZXh0LXdoaXRlXCIgLz5cbiAgICAgICAgICAgICAgICAgICkgOiBmaWxlLnR5cGUgPT09IFwidmlkZW8vbXA0XCIgPyAoXG4gICAgICAgICAgICAgICAgICAgIDxNcDRJY29uIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgdGV4dC13aGl0ZVwiIC8+XG4gICAgICAgICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtd2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICB7ZmlsZS50eXBlLnNwbGl0KFwiL1wiKVsxXS50b1VwcGVyQ2FzZSgpfVxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cImZvbnQtbWVkaXVtICF0ZXh0LXdoaXRlXCI+e2ZpbGUubmFtZX08L3A+XG4gICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSAhdGV4dC13aGl0ZS84MFwiPlxuICAgICAgICAgICAgICAgICAgeyhmaWxlLnNpemUgLyAxMDI0IC8gMTAyNCkudG9GaXhlZCgyKX0gTUJcbiAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIHZhcmlhbnQ9XCJpY29uXCJcbiAgICAgICAgICAgICAgb25DbGljaz17cmVtb3ZlRmlsZX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSBob3ZlcjpiZy13aGl0ZS8xMFwiXG4gICAgICAgICAgICAgIGRpc2FibGVkPXtwcmVwYXJhdGlvbi5jdXJyZW50U3RlcCAhPSBcInByZXBhcmUvY29uc3RydWN0XCJ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxDbG9zZUljb24gY2xhc3NOYW1lPVwidy02IGgtNlwiIC8+XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgIHsvKiBCYXJyYSBkZSBwcm9ncmVzbyB2aXNpYmxlIGR1cmFudGUgbGEgZXRhcGEgXCJwcmVwYXJlL2NvbnN0cnVjdFwiICovfVxuICAgICAgICAgIHtpc1Byb2Nlc3NpbmcgJiYgY3VycmVudFN0ZXAgPT09IFwicHJlcGFyZS9jb25zdHJ1Y3RcIiAmJiBwcm9ncmVzcyAmJiAoXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMVwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImgtMSBiZy13aGl0ZS8xMCByb3VuZGVkLWZ1bGwgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImgtZnVsbCBiZy1wcmltYXJ5LXR3XCJcbiAgICAgICAgICAgICAgICAgIGluaXRpYWw9e3sgd2lkdGg6IDAgfX1cbiAgICAgICAgICAgICAgICAgIGFuaW1hdGU9e3sgd2lkdGg6IGAke3Byb2dyZXNzLnByb2dyZXNzfSVgIH19XG4gICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjUgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXhzIHRleHQtd2hpdGUvNjBcIj5cbiAgICAgICAgICAgICAgICB7cHJvZ3Jlc3Muc3RhdHVzID09PSBcImNvbnN0cnVjdGluZ1wiXG4gICAgICAgICAgICAgICAgICA/IFwiQ29uc3RydWN0aW5nIHRyYW5zYWN0aW9uLi4uXCJcbiAgICAgICAgICAgICAgICAgIDogcHJvZ3Jlc3Muc3RhdHVzID09PSBcInVuc2lnbmVkXCJcbiAgICAgICAgICAgICAgICAgID8gXCJSZXRyaWV2aW5nIHVuc2lnbmVkIHRyYW5zYWN0aW9uLi4uXCJcbiAgICAgICAgICAgICAgICAgIDogXCJQcm9jZXNzaW5nLi4uXCJ9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9tb3Rpb24uZGl2PlxuICAgICAgPC9BbmltYXRlUHJlc2VuY2U+XG4gICAgPC9tb3Rpb24uZGl2PlxuICApXG59XG4iLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIjtcbmltcG9ydCB7IHVzZVR4U3RhdHVzIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhTdGF0dXNDb250ZXh0XCI7XG5cbmludGVyZmFjZSBEZWxlZ2F0ZVZpZXdQcm9wcyB7XG4gIHRleHQ6IHN0cmluZztcbiAgc2V0VGV4dDogKHRleHQ6IHN0cmluZykgPT4gdm9pZDtcbiAgaXNQcm9jZXNzaW5nOiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRGVsZWdhdGVWaWV3KHtcbiAgdGV4dCxcbiAgc2V0VGV4dCxcbiAgaXNQcm9jZXNzaW5nLFxufTogRGVsZWdhdGVWaWV3UHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBjb25zdCB7IHByZXBhcmF0aW9uIH0gPSB1c2VUeFN0YXR1cygpO1xuICByZXR1cm4gKFxuICAgIDxtb3Rpb24uZGl2XG4gICAgICBjbGFzc05hbWU9XCJzcGFjZS15LTRcIlxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgIHRyYW5zaXRpb249e3sgZHVyYXRpb246IDAuMyB9fVxuICAgID5cbiAgICAgIDx0ZXh0YXJlYVxuICAgICAgICB2YWx1ZT17dGV4dH1cbiAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRUZXh0KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB5b3VyIHRleHQgaGVyZS4uLlwiXG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLTQ4IHAtNCBiZy13aGl0ZS81IHJvdW5kZWQteGwgdGV4dC13aGl0ZSBwbGFjZWhvbGRlcjp0ZXh0LXdoaXRlLzQwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTIgZm9jdXM6cmluZy1bIzQ0N0JGNF1cIlxuICAgICAgICBkaXNhYmxlZD17cHJlcGFyYXRpb24uY3VycmVudFN0ZXAgIT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwifVxuICAgICAgLz5cbiAgICA8L21vdGlvbi5kaXY+XG4gICk7XG59XG4iLCJcInVzZSBjbGllbnRcIjtcbmltcG9ydCBSZWFjdCwge1xuICBjcmVhdGVDb250ZXh0LFxuICB1c2VDb250ZXh0LFxuICB1c2VTdGF0ZSxcbiAgdXNlQ2FsbGJhY2ssXG4gIHVzZUVmZmVjdCxcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBUV2FsbGV0QVBJIH0gZnJvbSBcIi4uL3R5cGVzL2NhcmRhbm9cIjtcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCIuL1dhbGxldENvbnRleHRcIjtcbmltcG9ydCB7XG4gIEZpbGVQcm9ncmVzcyxcbiAgQ29uc3RydWN0VHhSZXNwb25zZSxcbiAgUmV0cmlldmVVbnNpZ25lZEluc2NyaXB0aW9uVHhSZXNwb25zZSxcbiAgUHJlcGFyZWRVVFhPcyxcbiAgVERhdGFUeXBlcyxcbiAgQ29uc3RydWN0VHhJbnNjcmliZVJlcXVlc3QsXG4gIFRJbnNjcmlwdGlvblN1Ym1pc3Npb25TdGF0dXMsXG59IGZyb20gXCIuLi90eXBlcy90cmFuc2FjdGlvblwiO1xuaW1wb3J0IHsgQVBJX0tFWSwgYmFzZTY0VG9IZXgsIGJ1aWxkQXBpVXJsIH0gZnJvbSBcIi4uL3V0aWxzL2FwaUNvbnN1bXB0aW9uXCI7XG5pbXBvcnQgeyB1c2VUeFN0YXR1cyB9IGZyb20gXCIuL1R4U3RhdHVzQ29udGV4dFwiO1xuXG5leHBvcnQgdHlwZSBUeEluc2NyaXB0aW9uU3RlcCA9XG4gIHwgXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIlxuICB8IFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIlxuICB8IFwiaW5zY3JpcHRpb24vc3VibWl0XCJcbiAgfCBcImluc2NyaXB0aW9uL3JldHJpZXZlLXN1Ym1pc3Npb25cIlxuICB8IFwiZW5kXCI7XG5cbmludGVyZmFjZSBUeEluc2NyaXB0aW9uQ29udGV4dFR5cGUge1xuICBmaWxlUHJvZ3Jlc3M6IEZpbGVQcm9ncmVzc1tdO1xuICBpbnNjcmliZUZpbGVzOiAoZmlsZXM6IEZpbGVbXSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgaW5zY3JpYmVUZXh0OiAodGV4dDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzaWduQW5kU3VibWl0OiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBpc1Byb2Nlc3Npbmc6IGJvb2xlYW47XG4gIGN1cnJlbnRTdGVwOiBUeEluc2NyaXB0aW9uU3RlcDtcbiAgbmV4dFN0ZXA6IFR4SW5zY3JpcHRpb25TdGVwIHwgbnVsbDtcbiAgZXJyb3I6IHN0cmluZyB8IG51bGw7XG4gIGNsZWFyRXJyb3I6ICgpID0+IHZvaWQ7XG4gIHJlc2V0OiAoKSA9PiB2b2lkO1xuICBzdWJtaXNzaW9uU3RhdHVzPzogVEluc2NyaXB0aW9uU3VibWlzc2lvblN0YXR1cztcbiAgdW5zaWduZWRUeD86IFJldHJpZXZlVW5zaWduZWRJbnNjcmlwdGlvblR4UmVzcG9uc2U7XG4gIHNldFVuc2lnbmVkVHg6IChcbiAgICB0eDogUmV0cmlldmVVbnNpZ25lZEluc2NyaXB0aW9uVHhSZXNwb25zZSB8IHVuZGVmaW5lZFxuICApID0+IHZvaWQ7XG59XG5cbmNvbnN0IFR4SW5zY3JpcHRpb25Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxUeEluc2NyaXB0aW9uQ29udGV4dFR5cGU+KHtcbiAgZmlsZVByb2dyZXNzOiBbXSxcbiAgaW5zY3JpYmVGaWxlczogYXN5bmMgKCkgPT4ge30sXG4gIGluc2NyaWJlVGV4dDogYXN5bmMgKCkgPT4ge30sXG4gIHNpZ25BbmRTdWJtaXQ6IGFzeW5jICgpID0+IHt9LFxuICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICBjdXJyZW50U3RlcDogXCJpbnNjcmlwdGlvbi9jb25zdHJ1Y3RcIixcbiAgbmV4dFN0ZXA6IG51bGwsXG4gIGVycm9yOiBudWxsLFxuICBjbGVhckVycm9yOiAoKSA9PiB7fSxcbiAgcmVzZXQ6ICgpID0+IHt9LFxuICBzdWJtaXNzaW9uU3RhdHVzOiB1bmRlZmluZWQsXG4gIHVuc2lnbmVkVHg6IHVuZGVmaW5lZCxcbiAgc2V0VW5zaWduZWRUeDogKCkgPT4ge30sXG59KTtcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVR4SW5zY3JpcHRpb24oKSB7XG4gIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFR4SW5zY3JpcHRpb25Db250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJ1c2VUeEluc2NyaXB0aW9uIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBUeEluc2NyaXB0aW9uUHJvdmlkZXJcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBUeEluc2NyaXB0aW9uUHJvdmlkZXIoe1xuICBjaGlsZHJlbixcbn06IHtcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcbn0pIHtcbiAgY29uc3QgW2ZpbGVQcm9ncmVzcywgc2V0RmlsZVByb2dyZXNzXSA9IHVzZVN0YXRlPEZpbGVQcm9ncmVzc1tdPihbXSk7XG4gIGNvbnN0IFtpc1Byb2Nlc3NpbmcsIHNldElzUHJvY2Vzc2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzdWJtaXNzaW9uU3RhdHVzLCBzZXRTdWJtaXNzaW9uU3RhdHVzXSA9IHVzZVN0YXRlPFxuICAgIFRJbnNjcmlwdGlvblN1Ym1pc3Npb25TdGF0dXMgfCB1bmRlZmluZWRcbiAgPigpO1xuICBjb25zdCBbdW5zaWduZWRUeCwgc2V0VW5zaWduZWRUeF0gPSB1c2VTdGF0ZTxcbiAgICBSZXRyaWV2ZVVuc2lnbmVkSW5zY3JpcHRpb25UeFJlc3BvbnNlIHwgdW5kZWZpbmVkXG4gID4oKTtcbiAgY29uc3QgeyBnZXRXYWxsZXRBcGksIGRlZmF1bHRXYWxsZXQgfSA9IHVzZVdhbGxldCgpO1xuICBjb25zdCB7IGluc2NyaXB0aW9uLCBtb3ZlVG9OZXh0U3RlcCB9ID0gdXNlVHhTdGF0dXMoKTtcblxuICBjb25zdCB1cGRhdGVGaWxlUHJvZ3Jlc3MgPSB1c2VDYWxsYmFjayhcbiAgICAoaW5kZXg6IG51bWJlciwgdXBkYXRlczogUGFydGlhbDxGaWxlUHJvZ3Jlc3M+KSA9PiB7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChpdGVtLCBpKSA9PiAoaSA9PT0gaW5kZXggPyB7IC4uLml0ZW0sIC4uLnVwZGF0ZXMgfSA6IGl0ZW0pKVxuICAgICAgKTtcbiAgICB9LFxuICAgIFtdXG4gICk7XG5cbiAgY29uc3QgY2xlYXJFcnJvciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXRFcnJvcihudWxsKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHJlc2V0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldEZpbGVQcm9ncmVzcyhbXSk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICBzZXRTdWJtaXNzaW9uU3RhdHVzKHVuZGVmaW5lZCk7XG4gICAgc2V0VW5zaWduZWRUeCh1bmRlZmluZWQpO1xuICAgIHNldEVycm9yKG51bGwpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY29uc3RydWN0SW5zY3JpcHRpb25UeCA9IGFzeW5jIChcbiAgICBhcGk6IFRXYWxsZXRBUEksXG4gICAgZGF0YTogc3RyaW5nLFxuICAgIGRhdGFUeXBlOiBURGF0YVR5cGVzXG4gICk6IFByb21pc2U8Q29uc3RydWN0VHhSZXNwb25zZT4gPT4ge1xuICAgIGNvbnN0IHJld2FyZEFkZHJlc3NlcyA9IChhd2FpdCBhcGkuZ2V0UmV3YXJkQWRkcmVzc2VzKCkpIGFzIHN0cmluZ1tdO1xuICAgIGNvbnN0IHV0eG9zID0gKGF3YWl0IGFwaS5nZXRVdHhvcygpKSB8fCBbXTtcbiAgICBjb25zb2xlLmxvZyhcIlVUWE9zOlwiLCB1dHhvcyk7XG4gICAgY29uc3QgdGFyZ2V0QWRkcmVzcyA9IChhd2FpdCBhcGkuZ2V0VXNlZEFkZHJlc3NlcygpKVswXTtcbiAgICBpZiAoIXV0eG9zIHx8IHV0eG9zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgc2V0RXJyb3IoXCJObyBoYXkgVVRYT3MgZGlzcG9uaWJsZXNcIik7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBVVFhPcyBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgY29uc3QgYm9keTogQ29uc3RydWN0VHhJbnNjcmliZVJlcXVlc3QgPSB7XG4gICAgICBwYXlsb2FkOiBkYXRhLFxuICAgICAgcGF5bG9hZFR5cGU6IGRhdGFUeXBlLFxuICAgICAgcmV3YXJkQWRkcmVzc2VzLFxuICAgICAgY2hhbmdlQWRkcmVzczogdGFyZ2V0QWRkcmVzcyxcbiAgICAgIHV0eG9zLFxuICAgICAgbWludFRva2VuRm9yUGF5bG9hZDogXCJOb01pbnRpbmdcIixcbiAgICB9O1xuICAgIGNvbnNvbGUubG9nKFwiQm9keTpcIiwgYm9keSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGJ1aWxkQXBpVXJsKFwiL2luc2NyaXB0aW9ucy9jb25zdHJ1Y3QtdHhcIiksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgfSk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBsZXQgZXJyb3JEYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgIGVycm9yRGF0YSA9IGF3YWl0IGVycm9yUmVzcG9uc2UuanNvbigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgIGVycm9yOiBlcnJvckRhdGEsXG4gICAgICAgICAgZW5kcG9pbnQ6IFwiL2luc2NyaXB0aW9ucy9jb25zdHJ1Y3QtdHhcIixcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIEF2YW56YW1vcyBlbiBlbCBmbHVqbyBkZSBpbnNjcmlwY2nDs25cbiAgICBtb3ZlVG9OZXh0U3RlcChcImluc2NyaXB0aW9uXCIpO1xuICAgIGNvbnN0IGNvbnN0cnVjdGVkVHggPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgY29uc29sZS5sb2coXCJDb25zdHJ1Y3RlZCBUWDpcIiwgY29uc3RydWN0ZWRUeCk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICByZXR1cm4gY29uc3RydWN0ZWRUeDtcbiAgfTtcblxuICBjb25zdCBpbnNjcmliZUZpbGVzID0gYXN5bmMgKGZpbGVzOiBGaWxlW10pID0+IHtcbiAgICBpZiAoIWRlZmF1bHRXYWxsZXQpIHRocm93IG5ldyBFcnJvcihcIk5vIHdhbGxldCBjb25uZWN0ZWRcIik7XG4gICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG4gICAgc2V0SXNQcm9jZXNzaW5nKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEZpbGVQcm9ncmVzcyhcbiAgICAgICAgZmlsZXMubWFwKChmaWxlKSA9PiAoe1xuICAgICAgICAgIGZpbGUsXG4gICAgICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgICAgICBwcm9ncmVzczogMCxcbiAgICAgICAgfSkpXG4gICAgICApO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7IHN0YXR1czogXCJjb25zdHJ1Y3RpbmdcIiwgcHJvZ3Jlc3M6IDI1IH0pO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICBjb25zdCBmaWxlQXNCYXNlNjQgPSBhd2FpdCBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0IGFzIHN0cmluZyk7XG4gICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZXNbaV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYmFzZTY0Q29udGVudCA9IGZpbGVBc0Jhc2U2NC5zcGxpdChcIixcIilbMV07XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdGVkVHggPSBhd2FpdCBjb25zdHJ1Y3RJbnNjcmlwdGlvblR4KFxuICAgICAgICAgIGFwaSxcbiAgICAgICAgICBiYXNlNjRDb250ZW50LFxuICAgICAgICAgIGZpbGVzW2ldLnR5cGUgYXMgVERhdGFUeXBlc1xuICAgICAgICApO1xuICAgICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoaSwge1xuICAgICAgICAgIHN0YXR1czogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgIHByb2dyZXNzOiA1MCxcbiAgICAgICAgICB0eEluZm86IHsgY29uc3RydWN0ZWRUeCB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbnNjcmliaW5nIGZpbGVzOlwiLCBlcnJvcik7XG4gICAgICBzZXRFcnJvcihlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGVycm9yKSk7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBpbnNjcmliZVRleHQgPSBhc3luYyAodGV4dDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFkZWZhdWx0V2FsbGV0KSB0aHJvdyBuZXcgRXJyb3IoXCJObyB3YWxsZXQgY29ubmVjdGVkXCIpO1xuICAgIGNvbnN0IGFwaSA9IGdldFdhbGxldEFwaShkZWZhdWx0V2FsbGV0KSBhcyBUV2FsbGV0QVBJO1xuICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ZXh0RmlsZSA9IG5ldyBGaWxlKFt0ZXh0XSwgXCJpbnNjcmlwdGlvbi50eHRcIiwge1xuICAgICAgICB0eXBlOiBcInRleHQvcGxhaW5cIixcbiAgICAgIH0pO1xuICAgICAgc2V0RmlsZVByb2dyZXNzKFtcbiAgICAgICAge1xuICAgICAgICAgIGZpbGU6IHRleHRGaWxlLFxuICAgICAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICAgIH0sXG4gICAgICBdKTtcblxuICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKDAsIHsgc3RhdHVzOiBcImNvbnN0cnVjdGluZ1wiLCBwcm9ncmVzczogMjUgfSk7XG4gICAgICBjb25zb2xlLmxvZyhcInRleHRcIiwgdGV4dCk7XG4gICAgICBjb25zdCBiYXNlNjRDb250ZW50ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodGV4dCkpKTtcbiAgICAgIGNvbnNvbGUubG9nKFwiYmFzZTY0Q29udGVudFwiLCBiYXNlNjRDb250ZW50KTtcbiAgICAgIGNvbnN0IGNvbnN0cnVjdGVkVHggPSBhd2FpdCBjb25zdHJ1Y3RJbnNjcmlwdGlvblR4KFxuICAgICAgICBhcGksXG4gICAgICAgIGJhc2U2NENvbnRlbnQsXG4gICAgICAgIFwidGV4dC9wbGFpblwiIGFzIFREYXRhVHlwZXNcbiAgICAgICk7XG4gICAgICBjb25zb2xlLmxvZyhcImNvbnN0cnVjdGVkVHhcIiwgY29uc3RydWN0ZWRUeCk7XG5cbiAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcygwLCB7XG4gICAgICAgIHN0YXR1czogXCJ1bnNpZ25lZFwiLFxuICAgICAgICBwcm9ncmVzczogNTAsXG4gICAgICAgIHR4SW5mbzogeyBjb25zdHJ1Y3RlZFR4IH0sXG4gICAgICB9KTtcblxuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJpbnNjcmlwdGlvblwiKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluc2NyaWJpbmcgdGV4dDpcIiwgZXJyb3IpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShlcnJvcikpO1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0SXNQcm9jZXNzaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcG9sbEZvckNvbmZpcm1hdGlvbiA9IGFzeW5jIChcbiAgICBwcmVwYXJlZFR4OiBQcmVwYXJlZFVUWE9zXG4gICk6IFByb21pc2U8Ym9vbGVhbj4gPT4ge1xuICAgIGNvbnN0IHJldHJ5SW50ZXJ2YWwgPSA5MDAwO1xuICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICBidWlsZEFwaVVybChcIi9pbnNjcmlwdGlvbnMvcmV0cmlldmUtc3VibWlzc2lvbi1zdGF0dXNcIiksXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgIFwieC1hcGkta2V5XCI6IEFQSV9LRVkgfHwgXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShwcmVwYXJlZFR4LmV4ZWN1dGlvbkFybiksXG4gICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFNpIGVsIHNlcnZpZG9yIHJlc3BvbmRlIGNvbiB1biBlcnJvciA1MDAsIHNlIGludGVycnVtcGUgZWwgbG9vcFxuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZXNwb25zZSA9IHJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCBlcnJvclJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGEsXG4gICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9pbnNjcmlwdGlvbnMvcmV0cmlldmUtc3VibWlzc2lvbi1zdGF0dXNcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIHRoZSByZXNwb25zZSBjYXJlZnVsbHkgdG8gaGFuZGxlIHBvdGVudGlhbCBKU09OIGRlY29kaW5nIGVycm9yc1xuICAgICAgICBsZXQgc3RhdHVzOiBUSW5zY3JpcHRpb25TdWJtaXNzaW9uU3RhdHVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByZXNwb25zZSBjb250YWlucyBTdGF0ZXMuVGltZW91dCBlcnJvclxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHJlc3BvbnNlVGV4dC5pbmNsdWRlcyhcIlN0YXRlcy5UaW1lb3V0XCIpIHx8XG4gICAgICAgICAgICByZXNwb25zZVRleHQuaW5jbHVkZXMoXCJKc29uRGVjb2RlRXJyb3JcIilcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiVGltZW91dCBvciBKU09OIGRlY29kZSBlcnJvciBkZXRlY3RlZDpcIixcbiAgICAgICAgICAgICAgcmVzcG9uc2VUZXh0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICAgICAgXCJUcmFuc2FjdGlvbiBwcm9jZXNzaW5nIHRpbWVkIG91dCBvciBlbmNvdW50ZXJlZCBhIGRlY29kaW5nIGVycm9yLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlwiO1xuICAgICAgICAgICAgc2V0RXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhdHVzID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpO1xuICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgcmVzcG9uc2U6XCIsIHBhcnNlRXJyb3IpO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcGFyc2Ugc3VibWlzc2lvbiBzdGF0dXMgcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgZXJyb3I6XG4gICAgICAgICAgICAgICAgcGFyc2VFcnJvciBpbnN0YW5jZW9mIEVycm9yXG4gICAgICAgICAgICAgICAgICA/IHBhcnNlRXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgICAgOiBTdHJpbmcocGFyc2VFcnJvciksXG4gICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9pbnNjcmlwdGlvbnMvcmV0cmlldmUtc3VibWlzc2lvbi1zdGF0dXNcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlIGVzcGVyYSBxdWUgZWwgZW5kcG9pbnQgcmV0b3JuZSB7IGluUHJvZ3Jlc3M6IFwic3RyaW5nXCIgfSBtaWVudHJhcyBubyBlc3TDqSBvbi1jaGFpblxuICAgICAgICAvLyB5IGVuIGNhc28gZGUgw6l4aXRvIHJldG9ybmUgeyBzdWNjZXNzOiB7IG9uY2hhaW46IFwib24tY2hhaW5cIiwgLi4uIH0gfVxuICAgICAgICBpZiAoc3RhdHVzLnN1Y2Nlc3MgJiYgc3RhdHVzLnN1Y2Nlc3Mub25jaGFpbikge1xuICAgICAgICAgIHNldFN1Ym1pc3Npb25TdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2FjdGlvbiByZXRyaWV2ZWQ6XCIsIHN0YXR1cyk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cy5pblByb2dyZXNzKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJUcmFuc2FjdGlvbiBzdGlsbCBpbiBwcm9ncmVzcy4uLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBzdWJtaXNzaW9uIHN0YXR1cyByZXNwb25zZVwiLFxuICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICAgIGVuZHBvaW50OiBcIi9pbnNjcmlwdGlvbnMvcmV0cmlldmUtc3VibWlzc2lvbi1zdGF0dXNcIixcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgcmV0cnlJbnRlcnZhbCkpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlBvbGxpbmcgYXR0ZW1wdCBmYWlsZWQ6XCIsIGVycm9yKTtcblxuICAgICAgICAvLyBGb3JtYXQgdGhlIGVycm9yIG1lc3NhZ2UgZm9yIGJldHRlciByZWFkYWJpbGl0eVxuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlOiBzdHJpbmc7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgZXJyb3IgbWVzc2FnZSBhcyBKU09OIGZvciBiZXR0ZXIgZm9ybWF0dGluZ1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRXJyb3IgPSBKU09OLnBhcnNlKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgaWYgKHBhcnNlZEVycm9yLmVycm9yICYmIHR5cGVvZiBwYXJzZWRFcnJvci5lcnJvciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAvLyBIYW5kbGUgdGhlIHNwZWNpZmljIEpzb25EZWNvZGVFcnJvciBjYXNlXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBwYXJzZWRFcnJvci5lcnJvci5tZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgcGFyc2VkRXJyb3IuZXJyb3IubWVzc2FnZS5pbmNsdWRlcygna2V5IFwib25jaGFpblwiIG5vdCBmb3VuZCcpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICBcIlRyYW5zYWN0aW9uIHByb2Nlc3NpbmcgZXJyb3I6IFRoZSB0cmFuc2FjdGlvbiBkYXRhIGlzIGluY29tcGxldGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYEVycm9yOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgcGFyc2VkRXJyb3IuZXJyb3IsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICl9YDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiBwYXJzaW5nIGZhaWxzLCB1c2UgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIGZpbGUgcHJvZ3Jlc3MgdG8gZmFpbGVkXG4gICAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgICBwcmV2Lm1hcCgoZmlsZSkgPT4gKHsgLi4uZmlsZSwgc3RhdHVzOiBcImZhaWxlZFwiLCBwcm9ncmVzczogMCB9KSlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciA9IChlcnJvcjogYW55KSA9PiB7XG4gICAgY29uc29sZS5lcnJvcihcIkVycm9yIGluIHNpZ24gYW5kIHN1Ym1pdCBmb3IgaW5zY3JpcHRpb246XCIsIGVycm9yKTtcblxuICAgIC8vIEZvcm1hdCB0aGUgZXJyb3IgbWVzc2FnZSBiYXNlZCBvbiB0aGUgZXJyb3IgdHlwZVxuICAgIGxldCBlcnJvck1lc3NhZ2U6IHN0cmluZztcblxuICAgIC8vIEhhbmRsZSBUeFNpZ25FcnJvciBmcm9tIHdhbGxldFxuICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIlR4U2lnbkVycm9yXCIpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IGBXYWxsZXQgc2lnbmluZyBlcnJvcjogJHtcbiAgICAgICAgZXJyb3IuaW5mbyB8fCBlcnJvci5tZXNzYWdlIHx8IFwiRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb25cIlxuICAgICAgfWA7XG4gICAgICAvLyBObyBhY3R1YWxpemFtb3MgZWwgZXN0YWRvIGRlIGxvcyBhcmNoaXZvcyBhcXXDrSB5YSBxdWUgbG8gaGFjZW1vcyBlbiBlbCBjYXRjaCBkZWwgc2lnblxuICAgICAgLy8gU29sbyBsaW1waWFtb3MgZWwgZXJyb3IgeSBwZXJtaXRpbW9zIHJlaW50ZW50YXJcbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIFwiV2FsbGV0IHNpZ25pbmcgZXJyb3IgZGV0ZWN0ZWQsIGtlZXBpbmcgY3VycmVudCBzdGVwIGZvciByZXRyeVwiXG4gICAgICApO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgRXJyb3Igb2JqZWN0c1xuICAgIGVsc2UgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRyeSB0byBwYXJzZSB0aGUgZXJyb3IgbWVzc2FnZSBhcyBKU09OXG4gICAgICAgIGNvbnN0IHBhcnNlZEVycm9yID0gSlNPTi5wYXJzZShlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgZXJyb3JNZXNzYWdlID1cbiAgICAgICAgICBwYXJzZWRFcnJvci5lcnJvcj8ubWVzc2FnZSB8fCBwYXJzZWRFcnJvci5tZXNzYWdlIHx8IGVycm9yLm1lc3NhZ2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHBhcnNpbmcgZmFpbHMsIHVzZSB0aGUgb3JpZ2luYWwgZXJyb3IgbWVzc2FnZVxuICAgICAgICBlcnJvck1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlIHx8IFwiVW5rbm93biBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgfVxuXG4gICAgICBzZXRFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgc2V0RmlsZVByb2dyZXNzKChwcmV2KSA9PlxuICAgICAgICBwcmV2Lm1hcCgoZmlsZSkgPT4gKHsgLi4uZmlsZSwgc3RhdHVzOiBcImZhaWxlZFwiLCBwcm9ncmVzczogMCB9KSlcbiAgICAgICk7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgICAgLy8gRm9yIG90aGVyIGVycm9ycywgcmVzZXQgdG8gdGhlIGJlZ2lubmluZ1xuICAgICAgY29uc29sZS5sb2coXCJPdGhlciBlcnJvciBkZXRlY3RlZCwgbW92aW5nIHRvIGVuZDogXCIsIGVycm9yKTtcbiAgICAgIG1vdmVUb05leHRTdGVwKFwiZW5kXCIpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgb3RoZXIgZXJyb3IgdHlwZXNcbiAgICBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICB9XG5cbiAgICAgIHNldEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChmaWxlKSA9PiAoeyAuLi5maWxlLCBzdGF0dXM6IFwiZmFpbGVkXCIsIHByb2dyZXNzOiAwIH0pKVxuICAgICAgKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAvLyBGb3Igb3RoZXIgZXJyb3JzLCByZXNldCB0byB0aGUgYmVnaW5uaW5nXG4gICAgICBjb25zb2xlLmxvZyhcIk90aGVyIGVycm9yIGRldGVjdGVkLCBtb3ZpbmcgdG8gZW5kOiBcIiwgZXJyb3IpO1xuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJlbmRcIik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHNpZ25BbmRTdWJtaXQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFkZWZhdWx0V2FsbGV0KSB0aHJvdyBuZXcgRXJyb3IoXCJObyB3YWxsZXQgY29ubmVjdGVkXCIpO1xuICAgIGNvbnN0IGFwaSA9IGdldFdhbGxldEFwaShkZWZhdWx0V2FsbGV0KSBhcyBUV2FsbGV0QVBJO1xuICAgIHNldElzUHJvY2Vzc2luZyh0cnVlKTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVQcm9ncmVzcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBmaWxlID0gZmlsZVByb2dyZXNzW2ldO1xuICAgICAgICBpZiAoIWZpbGUudHhJbmZvPy5jb25zdHJ1Y3RlZFR4KSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgeyBleGVjdXRpb25Bcm4gfSA9IGZpbGUudHhJbmZvLmNvbnN0cnVjdGVkVHg7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZXhlY3V0aW9uQXJuXCIsIGV4ZWN1dGlvbkFybik7XG5cbiAgICAgICAgLy8gU29sbyBvYnRlbmVyIHVuc2lnbmVkVHggc2kgbm8gbG8gdGVuZW1vcyB5YVxuICAgICAgICBsZXQgdW5zaWduZWRUeCA9IGZpbGUudHhJbmZvXG4gICAgICAgICAgLnVuc2lnbmVkVHggYXMgUmV0cmlldmVVbnNpZ25lZEluc2NyaXB0aW9uVHhSZXNwb25zZTtcbiAgICAgICAgaWYgKCF1bnNpZ25lZFR4KSB7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkVHhSZXNwb25zZSA9IGF3YWl0IGZldGNoKFxuICAgICAgICAgICAgICBidWlsZEFwaVVybChcIi9pbnNjcmlwdGlvbnMvcmV0cmlldmUtdW5zaWduZWQtdHhcIiksXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZXhlY3V0aW9uQXJuKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCF1bnNpZ25lZFR4UmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgbGV0IGVycm9yRGF0YTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclJlc3BvbnNlID0gdW5zaWduZWRUeFJlc3BvbnNlLmNsb25lKCk7XG4gICAgICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3JSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnJvckRhdGEgPSBhd2FpdCB1bnNpZ25lZFR4UmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICBzdGF0dXM6IHVuc2lnbmVkVHhSZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICBzdGF0dXNUZXh0OiB1bnNpZ25lZFR4UmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvckRhdGEsXG4gICAgICAgICAgICAgICAgICBlbmRwb2ludDogXCIvaW5zY3JpcHRpb25zL3JldHJpZXZlLXVuc2lnbmVkLXR4XCIsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdW5zaWduZWRUeCA9IGF3YWl0IHVuc2lnbmVkVHhSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuc2lnbmVkIFRYOlwiLCB1bnNpZ25lZFR4KTtcblxuICAgICAgICAgICAgaWYgKHVuc2lnbmVkVHguc3VjY2VzcyAmJiB1bnNpZ25lZFR4LnN1Y2Nlc3MuaW5kZXhpbmdUeCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVuc2lnbmVkIHRyYW5zYWN0aW9uIHJldHJpZXZlZDpcIiwgdW5zaWduZWRUeCk7XG4gICAgICAgICAgICAgIHNldFVuc2lnbmVkVHgodW5zaWduZWRUeCk7XG4gICAgICAgICAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgICAgICAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodW5zaWduZWRUeC5pblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVW5zaWduZWQgdHJhbnNhY3Rpb24gc3RpbGwgaW4gcHJvZ3Jlc3MuLi5cIik7XG4gICAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCA1MDAwKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgICAgICAgXCJVbmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHJldHJpZXZpbmcgdW5zaWduZWQgdHJhbnNhY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB1bnNpZ25lZFR4LFxuICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IFwiL2luc2NyaXB0aW9ucy9yZXRyaWV2ZS11bnNpZ25lZC10eFwiLFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICBwcm9ncmVzczogNzUsXG4gICAgICAgICAgdHhJbmZvOiB7IC4uLmZpbGUudHhJbmZvLCB1bnNpZ25lZFR4IH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBzaWduZWRUeDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBDbGVhciBhbnkgcHJldmlvdXMgZXJyb3Igc3RhdGUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gc2lnbiBhZ2FpblxuICAgICAgICAgIGNsZWFyRXJyb3IoKTtcblxuICAgICAgICAgIC8vIEdldCBhIGZyZXNoIHdhbGxldCBBUEkgaW5zdGFuY2UgdG8gZW5zdXJlIHRoZSBwb3B1cCBhcHBlYXJzIGFnYWluXG4gICAgICAgICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpIGFzIFRXYWxsZXRBUEk7XG5cbiAgICAgICAgICBzaWduZWRUeCA9IGF3YWl0IGFwaS5zaWduVHgoXG4gICAgICAgICAgICBiYXNlNjRUb0hleCh1bnNpZ25lZFR4LnN1Y2Nlc3MuaW5kZXhpbmdUeClcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2lnbmVkIFRYOlwiLCBzaWduZWRUeCk7XG4gICAgICAgICAgdXBkYXRlRmlsZVByb2dyZXNzKGksIHtcbiAgICAgICAgICAgIHN0YXR1czogXCJzaWduZWRcIixcbiAgICAgICAgICAgIHByb2dyZXNzOiA4NSxcbiAgICAgICAgICAgIHR4SW5mbzogeyAuLi5maWxlLnR4SW5mbywgdW5zaWduZWRUeCwgc2lnbmVkVHggfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtb3ZlVG9OZXh0U3RlcChcImluc2NyaXB0aW9uXCIpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNpZ25pbmcgdHJhbnNhY3Rpb246XCIsIGVycm9yKTtcbiAgICAgICAgICAvLyBEb24ndCBtb3ZlIHRvIHRoZSBuZXh0IHN0ZXAgaWYgdGhlcmUncyBhIHNpZ25pbmcgZXJyb3JcbiAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byByZXRyeSBzaWduaW5nIGZyb20gdGhlIHNhbWUgc3RlcFxuICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5uYW1lID09PSBcIlR4U2lnbkVycm9yXCIpIHtcbiAgICAgICAgICAgIC8vIE1hbnRlbmVyIGVsIGVzdGFkbyBhY3R1YWwgeSBwZXJtaXRpciByZWludGVudGFyXG4gICAgICAgICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgICAgICAgIHByZXYubWFwKChpdGVtLCBpZHgpID0+XG4gICAgICAgICAgICAgICAgaWR4ID09PSBpXG4gICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJ1bnNpZ25lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiA3NSxcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOiBpdGVtXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjsgLy8gTGV0IHRoZSBoYW5kbGVTaWduQW5kU3VibWl0RXJyb3IgZnVuY3Rpb24gaGFuZGxlIHRoaXMgc3BlY2lmaWMgZXJyb3JcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIHNpZ24gdHJhbnNhY3Rpb246ICR7XG4gICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSB8fCBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2lnbmVkU2hhcmRUeHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICB1bnNpZ25lZFR4LnN1Y2Nlc3Muc2hhcmRUeHMubWFwKGFzeW5jIChzaGFyZFR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoZXhTaGFyZFR4ID0gYmFzZTY0VG9IZXgoc2hhcmRUeCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkhleCBTaGFyZCBUWDpcIiwgaGV4U2hhcmRUeCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAvLyBHZXQgYSBmcmVzaCB3YWxsZXQgQVBJIGluc3RhbmNlIGZvciBlYWNoIHNoYXJkIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgIGNvbnN0IGFwaSA9IGdldFdhbGxldEFwaShkZWZhdWx0V2FsbGV0KSBhcyBUV2FsbGV0QVBJO1xuICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgYXBpLnNpZ25UeChoZXhTaGFyZFR4KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNpZ25pbmcgc2hhcmQgdHJhbnNhY3Rpb246XCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgLy8gTWFudGVuZXIgZWwgZXN0YWRvIGFjdHVhbCB5IHBlcm1pdGlyIHJlaW50ZW50YXJcbiAgICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm5hbWUgPT09IFwiVHhTaWduRXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHNldEZpbGVQcm9ncmVzcygocHJldikgPT5cbiAgICAgICAgICAgICAgICAgIHByZXYubWFwKChpdGVtLCBpZHgpID0+XG4gICAgICAgICAgICAgICAgICAgIGlkeCA9PT0gaVxuICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5pdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidW5zaWduZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6IDc1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW1cbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yOyAvLyBMZXQgdGhlIGhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciBmdW5jdGlvbiBoYW5kbGUgdGhpcyBzcGVjaWZpYyBlcnJvclxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gc2lnbiBzaGFyZCB0cmFuc2FjdGlvbjogJHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSB8fCBKU09OLnN0cmluZ2lmeShlcnJvcilcbiAgICAgICAgICAgICAgICAgIH1gXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiU2lnbmVkIFNoYXJkIFRYczpcIiwgc2lnbmVkU2hhcmRUeHMpO1xuICAgICAgICB1cGRhdGVGaWxlUHJvZ3Jlc3MoaSwge1xuICAgICAgICAgIHN0YXR1czogXCJzaWduZWRcIixcbiAgICAgICAgICBwcm9ncmVzczogOTAsXG4gICAgICAgICAgdHhJbmZvOiB7XG4gICAgICAgICAgICAuLi5maWxlLnR4SW5mbyxcbiAgICAgICAgICAgIHVuc2lnbmVkVHgsXG4gICAgICAgICAgICBzaWduZWRUeCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBzdGVwIGFmdGVyIHN1Y2Nlc3NmdWwgc2lnbmluZyBvZiBhbGwgdHJhbnNhY3Rpb25zXG4gICAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG5cbiAgICAgICAgY29uc3QgaW5zY3JpYmVTdWJtaXRCb2R5ID0ge1xuICAgICAgICAgIGluZGV4aW5nVHhUb1N1Ym1pdDogW3Vuc2lnbmVkVHguc3VjY2Vzcy5pbmRleGluZ1R4LCBzaWduZWRUeF0sXG4gICAgICAgICAgdHhzVG9TdWJtaXQ6IHVuc2lnbmVkVHguc3VjY2Vzcy5zaGFyZFR4cy5tYXAoKHNoYXJkVHgsIGluZGV4KSA9PiBbXG4gICAgICAgICAgICBzaGFyZFR4LFxuICAgICAgICAgICAgc2lnbmVkU2hhcmRUeHNbaW5kZXhdLFxuICAgICAgICAgIF0pLFxuICAgICAgICAgIHVsaWRPZk9iamVjdDogdW5zaWduZWRUeC5zdWNjZXNzLm9iamVjdFVsaWQsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW5zY3JpYmUgc3VibWl0IGJvZHk6XCIsIGluc2NyaWJlU3VibWl0Qm9keSk7XG5cbiAgICAgICAgY29uc3Qgc3VibWl0UmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICBidWlsZEFwaVVybChcIi9pbnNjcmlwdGlvbnMvc3VibWl0XCIpLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZIHx8IFwiXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoaW5zY3JpYmVTdWJtaXRCb2R5KSxcbiAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFzdWJtaXRSZXNwb25zZS5vaykge1xuICAgICAgICAgIGxldCBlcnJvckRhdGE7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVzcG9uc2UgPSBzdWJtaXRSZXNwb25zZS5jbG9uZSgpO1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgZXJyb3JSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JEYXRhID0gYXdhaXQgc3VibWl0UmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgIHN0YXR1czogc3VibWl0UmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICBzdGF0dXNUZXh0OiBzdWJtaXRSZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICBlcnJvcjogZXJyb3JEYXRhLFxuICAgICAgICAgICAgICBlbmRwb2ludDogXCIvaW5zY3JpcHRpb25zL3N1Ym1pdFwiLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN1Ym1pdHRlZFR4OiBQcmVwYXJlZFVUWE9zID0gYXdhaXQgc3VibWl0UmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlN1Ym1pdHRlZCBUWDpcIiwgc3VibWl0dGVkVHgpO1xuICAgICAgICAvLyBNb3ZlIHRvIHRoZSBuZXh0IHN0ZXAgYWZ0ZXIgc3VjY2Vzc2Z1bCBzdWJtaXNzaW9uXG4gICAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgc3RhdHVzOiBcInN1Ym1pdHRlZFwiLFxuICAgICAgICAgIHByb2dyZXNzOiA5NSxcbiAgICAgICAgICB0eEluZm86IHtcbiAgICAgICAgICAgIC4uLmZpbGUudHhJbmZvLFxuICAgICAgICAgICAgdW5zaWduZWRUeCxcbiAgICAgICAgICAgIHNpZ25lZFR4LFxuICAgICAgICAgICAgc3VibWl0dGVkVHgsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgcG9sbEZvckNvbmZpcm1hdGlvbihzdWJtaXR0ZWRUeCk7XG4gICAgICAgIHVwZGF0ZUZpbGVQcm9ncmVzcyhpLCB7XG4gICAgICAgICAgc3RhdHVzOiBjb25maXJtZWQgPyBcImNvbmZpcm1lZFwiIDogXCJmYWlsZWRcIixcbiAgICAgICAgICBwcm9ncmVzczogY29uZmlybWVkID8gMTAwIDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIG1vdmVUb05leHRTdGVwKFwiaW5zY3JpcHRpb25cIik7XG4gICAgICB9XG4gICAgICAvLyBBbCBmaW5hbGl6YXIsIHNlIGVzdGFibGVjZSBlbCBlc3RhZG8gZmluYWwgXCJlbmRcIlxuICAgICAgbW92ZVRvTmV4dFN0ZXAoXCJlbmRcIik7XG4gICAgICBzZXRJc1Byb2Nlc3NpbmcoZmFsc2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBoYW5kbGVTaWduQW5kU3VibWl0RXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIG9jY3VycmVkOlwiLCBlcnJvcik7XG4gICAgICBzZXRGaWxlUHJvZ3Jlc3MoKHByZXYpID0+XG4gICAgICAgIHByZXYubWFwKChmaWxlKSA9PiAoeyAuLi5maWxlLCBzdGF0dXM6IFwiZmFpbGVkXCIsIHByb2dyZXNzOiAwIH0pKVxuICAgICAgKTtcbiAgICAgIHNldElzUHJvY2Vzc2luZyhmYWxzZSk7XG4gICAgfVxuICB9LCBbZXJyb3JdKTtcblxuICByZXR1cm4gKFxuICAgIDxUeEluc2NyaXB0aW9uQ29udGV4dC5Qcm92aWRlclxuICAgICAgdmFsdWU9e3tcbiAgICAgICAgZmlsZVByb2dyZXNzLFxuICAgICAgICBpbnNjcmliZUZpbGVzLFxuICAgICAgICBpbnNjcmliZVRleHQsXG4gICAgICAgIHNpZ25BbmRTdWJtaXQsXG4gICAgICAgIGlzUHJvY2Vzc2luZyxcbiAgICAgICAgY3VycmVudFN0ZXA6IGluc2NyaXB0aW9uLmN1cnJlbnRTdGVwIGFzIFR4SW5zY3JpcHRpb25TdGVwLFxuICAgICAgICBuZXh0U3RlcDogaW5zY3JpcHRpb24ubmV4dFN0ZXAgYXMgVHhJbnNjcmlwdGlvblN0ZXAgfCBudWxsLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgY2xlYXJFcnJvcixcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIHN1Ym1pc3Npb25TdGF0dXMsXG4gICAgICAgIHVuc2lnbmVkVHgsXG4gICAgICAgIHNldFVuc2lnbmVkVHgsXG4gICAgICB9fVxuICAgID5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L1R4SW5zY3JpcHRpb25Db250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5cbmludGVyZmFjZSBMb2FkaW5nU2NyZWVuUHJvcHMge1xuICB0ZXh0Pzogc3RyaW5nO1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBMb2FkaW5nU2NyZWVuKHtcbiAgdGV4dCA9IFwiTG9hZGluZy4uLlwiLFxuICBjbGFzc05hbWUgPSBcIlwiLFxufTogTG9hZGluZ1NjcmVlblByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgcmV0dXJuIChcbiAgICA8bW90aW9uLmRpdlxuICAgICAgY2xhc3NOYW1lPXtgdy1mdWxsIGgtZnVsbCAgei01MCBmbGV4IGZsZXgtY29sIGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciByb3VuZGVkLTR4bCAhdGV4dC13aGl0ZSAke2NsYXNzTmFtZX0gcHktOCBgfVxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCB9fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIgZ2FwLTZcIj5cbiAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJ3LTIwIGgtMjBcIlxuICAgICAgICAgIGFuaW1hdGU9e3tcbiAgICAgICAgICAgIHJvdGF0ZVk6IDM2MCxcbiAgICAgICAgICB9fVxuICAgICAgICAgIHRyYW5zaXRpb249e3tcbiAgICAgICAgICAgIGR1cmF0aW9uOiAyLjUsXG4gICAgICAgICAgICByZXBlYXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgIGVhc2U6IFwibGluZWFyXCIvL1wiZWFzZUluT3V0XCIsXG4gICAgICAgICAgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgIHNyYz1cImh0dHBzOi8vY2RuLnByb2Qud2Vic2l0ZS1maWxlcy5jb20vNjZjM2I3Nzk2NzQ5MTVjMjg4Y2E5OTk4LzY2YzYzZmE2MzA3MzMyZTIzOTEwNjA0NF9Mb2dvJTIwKDExKS5wbmdcIlxuICAgICAgICAgICAgYWx0PVwiTG9hZGluZyBzcGlubmVyXCJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgICAgPG1vdGlvbi5wXG4gICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB4OiAtMTAgfX1cbiAgICAgICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEsIHg6IDAgfX1cbiAgICAgICAgICB0cmFuc2l0aW9uPXt7IGRlbGF5OiAwLjIgfX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LVsxLjI1cmVtXSBmb250LW1lZGl1bSAhdGV4dC13aGl0ZVwiXG4gICAgICAgID5cbiAgICAgICAgICB7dGV4dH1cbiAgICAgICAgPC9tb3Rpb24ucD5cbiAgICAgICAgPG1vdGlvbi5wXG4gICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB4OiAtMTAgfX1cbiAgICAgICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEsIHg6IDAgfX1cbiAgICAgICAgICB0cmFuc2l0aW9uPXt7IGRlbGF5OiAwLjIgfX1cbiAgICAgICAgICBjbGFzc05hbWU9XCIgdGV4dC1bMC44NzVyZW1dICF0ZXh0LXdoaXRlXCJcbiAgICAgICAgPlxuICAgICAgICAgIMK/SGF2ZSBxdWVzdGlvbnM/IFNlZSBvdXJ7XCIgXCJ9XG4gICAgICAgICAgPGEgY2xhc3NOYW1lPVwidW5kZXJsaW5lICF0ZXh0LXdoaXRlXCIgaHJlZj1cIi9mYXFcIj5cbiAgICAgICAgICAgIEZBUXNcbiAgICAgICAgICA8L2E+XG4gICAgICAgICAgLlxuICAgICAgICA8L21vdGlvbi5wPlxuICAgICAgPC9kaXY+XG4gICAgPC9tb3Rpb24uZGl2PlxuICApO1xufVxuIiwiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi9CdXR0b25cIjtcbmltcG9ydCB7IHVzZUZpbGVVcGxvYWQgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9GaWxlVXBsb2FkQ29udGV4dFwiO1xuaW1wb3J0IHsgdXNlVHhTdGF0dXMgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeFN0YXR1c0NvbnRleHRcIjtcbmltcG9ydCB7IHVzZVR4SW5zY3JpcHRpb24gfSBmcm9tIFwiLi4vLi4vY29udGV4dC9UeEluc2NyaXB0aW9uQ29udGV4dFwiO1xuaW1wb3J0IHsgdXNlVHhQcmVwYXJhdGlvbiB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1R4UHJlcGFyYXRpb25Db250ZXh0XCI7XG5pbXBvcnQgeyBUSW5zY3JpcHRpb25TdWJtaXNzaW9uU3RhdHVzIH0gZnJvbSBcIi4uLy4uL3R5cGVzL3RyYW5zYWN0aW9uXCI7XG5cbmludGVyZmFjZSBGaW5pc2hTY3JlZW5Qcm9wcyB7XG4gIHRleHQ/OiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgc2V0SXNQcmVwYXJlZDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Ym9vbGVhbj4+O1xuICBzZXRJc0luc2NyaWJlZDogUmVhY3QuRGlzcGF0Y2g8UmVhY3QuU2V0U3RhdGVBY3Rpb248Ym9vbGVhbj4+O1xuICBzZXREZWxlZ2F0ZVRleHQ6IFJlYWN0LkRpc3BhdGNoPFJlYWN0LlNldFN0YXRlQWN0aW9uPHN0cmluZz4+O1xuICBzdWJtaXNzaW9uU3RhdHVzPzogVEluc2NyaXB0aW9uU3VibWlzc2lvblN0YXR1cztcbiAgcHJlcGFyYXRpb25UeElkPzogc3RyaW5nO1xuICB1bnNpZ25lZFR4SWQ/OiBzdHJpbmc7XG4gIGluZGV4aW5nVHhJZD86IHN0cmluZztcbiAgc2hhcmRUeElkcz86IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgY29uc3QgRXhwbG9yZXJMaW5rID0gKHsgdHhJZCB9OiB7IHR4SWQ6IHN0cmluZyB9KSA9PiAoXG4gIDxhXG4gICAgaHJlZj17YGh0dHBzOi8vcHJlcHJvZC5jYXJkYW5vc2Nhbi5pby90cmFuc2FjdGlvbi8ke3R4SWR9YH1cbiAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgIGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwICBob3ZlcjpvcGFjaXR5LTgwIHRyYW5zaXRpb24tY29sb3JzIGZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHctZnVsbFwiXG4gID5cbiAgICA8c3ZnXG4gICAgICBjbGFzc05hbWU9XCJ3LTQgaC00XCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk05IDVIN0M1Ljg5NTQzIDUgNSA1Ljg5NTQzIDUgN1YxOUM1IDIwLjEwNDYgNS44OTU0MyAyMSA3IDIxSDE3QzE4LjEwNDYgMjEgMTkgMjAuMTA0NiAxOSAxOVY3QzE5IDUuODk1NDMgMTguMTA0NiA1IDE3IDVIMTVcIlxuICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICBzdHJva2VXaWR0aD1cIjJcIlxuICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgLz5cbiAgICAgIDxwYXRoXG4gICAgICAgIGQ9XCJNMTIgMTJWM00xMiAzTDkgNk0xMiAzTDE1IDZcIlxuICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICBzdHJva2VXaWR0aD1cIjJcIlxuICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgIC8+XG4gICAgPC9zdmc+XG4gICAge3R4SWR9XG4gIDwvYT5cbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBGaW5pc2hTY3JlZW4oe1xuICB0ZXh0ID0gXCJZb3VyIHN1Ym1pc3Npb25zIGFyZSBub3cgaW5zY3JpYmVkIE9uY2hhaW4uXCIsXG4gIGNsYXNzTmFtZSA9IFwiXCIsXG4gIHNldElzUHJlcGFyZWQsXG4gIHNldElzSW5zY3JpYmVkLFxuICBzZXREZWxlZ2F0ZVRleHQsXG4gIHN1Ym1pc3Npb25TdGF0dXMsXG4gIHByZXBhcmF0aW9uVHhJZCxcbiAgdW5zaWduZWRUeElkLFxuICBpbmRleGluZ1R4SWQsXG4gIHNoYXJkVHhJZHMsXG59OiBGaW5pc2hTY3JlZW5Qcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIGNvbnN0IHsgcmVzZXRTdGF0dXMsIHNldEluc2NyaXB0aW9uU3RhdHVzLCBzZXRQcmVwYXJhdGlvblN0YXR1cyB9ID1cbiAgICB1c2VUeFN0YXR1cygpO1xuICBjb25zdCB7IGNsZWFyRmlsZSB9ID0gdXNlRmlsZVVwbG9hZCgpO1xuICBjb25zdCB7IHJlc2V0IH0gPSB1c2VUeEluc2NyaXB0aW9uKCk7XG4gIGNvbnN0IHsgcmVzZXQ6IHJlc2V0UHJlcGFyYXRpb24gfSA9IHVzZVR4UHJlcGFyYXRpb24oKTtcblxuICByZXR1cm4gKFxuICAgIDxtb3Rpb24uZGl2XG4gICAgICBjbGFzc05hbWU9e2B3LWZ1bGwgaC1mdWxsIHotNTAgZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZC00eGwgIXRleHQtd2hpdGUgJHtjbGFzc05hbWV9YH1cbiAgICAgIGluaXRpYWw9e3sgb3BhY2l0eTogMCB9fVxuICAgICAgYW5pbWF0ZT17eyBvcGFjaXR5OiAxIH19XG4gICAgICBleGl0PXt7IG9wYWNpdHk6IDAgfX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyIGdhcC02XCI+XG4gICAgICAgIDxtb3Rpb24uZGl2IGNsYXNzTmFtZT1cInctWzEuNDU0NTZyZW1dIGgtWzFyZW1dXCI+XG4gICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgICB3aWR0aD1cIjEwMCVcIlxuICAgICAgICAgICAgaGVpZ2h0PVwiMTAwJVwiXG4gICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI4IDIwXCJcbiAgICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICBkPVwiTTI1LjYzNjQgMkw5LjYzNjM3IDE4TDIuMzYzNjUgMTAuNzI3M1wiXG4gICAgICAgICAgICAgIHN0cm9rZT1cIiMyQjgwRkZcIlxuICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cIjIuOTA5MDlcIlxuICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgPC9zdmc+XG4gICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgdGV4dC1bMS4yNXJlbV1cIj57dGV4dH08L3A+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IGl0ZW1zLWNlbnRlciB0ZXh0LXNtIHctZnVsbCBtdC00XCI+XG4gICAgICAgICAgey8qIFByZXBhcmF0aW9uIFRyYW5zYWN0aW9uIFNlY3Rpb24gKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yIHctZnVsbFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBmb250LXNlbWlib2xkXCI+UHJlcGFyYXRpb24gUGhhc2U8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9yZGVyLXQgYm9yZGVyLXdoaXRlLzIwIG15LTFcIj48L2Rpdj5cblxuICAgICAgICAgICAge3ByZXBhcmF0aW9uVHhJZCAmJiAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBtdC0yXCI+XG4gICAgICAgICAgICAgICAgICBQcmVwYXJhdGlvbiBUcmFuc2FjdGlvbjpcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8RXhwbG9yZXJMaW5rIHR4SWQ9e3ByZXBhcmF0aW9uVHhJZH0gLz5cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgey8qIEluc2NyaXB0aW9uIFRyYW5zYWN0aW9uIFNlY3Rpb24gKi99XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yIHctZnVsbCBtdC00XCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGZvbnQtc2VtaWJvbGRcIj5JbnNjcmlwdGlvbiBQaGFzZTwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXItdCBib3JkZXItd2hpdGUvMjAgbXktMVwiPjwvZGl2PlxuXG4gICAgICAgICAgICB7aW5kZXhpbmdUeElkICYmIChcbiAgICAgICAgICAgICAgPD5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIG10LTJcIj5JbmRleGluZyBUcmFuc2FjdGlvbjo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8RXhwbG9yZXJMaW5rIHR4SWQ9e2luZGV4aW5nVHhJZH0gLz5cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApfVxuXG4gICAgICAgICAgICB7LyogU2hhcmQgVHJhbnNhY3Rpb25zIFNlY3Rpb24gKi99XG4gICAgICAgICAgICB7c2hhcmRUeElkcyAmJiBzaGFyZFR4SWRzLmxlbmd0aCA+IDAgJiYgKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdy1mdWxsIG10LTJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwXCI+U2hhcmQgVHJhbnNhY3Rpb25zOjwvZGl2PlxuICAgICAgICAgICAgICAgIHtzaGFyZFR4SWRzLm1hcCgoc2hhcmRUeElkLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgICAgPEV4cGxvcmVyTGluayBrZXk9e2luZGV4fSB0eElkPXtzaGFyZFR4SWR9IC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgey8qIEZhbGxiYWNrIHRvIHN1Ym1pc3Npb25TdGF0dXMgaWYgcHJvcHMgbm90IHByb3ZpZGVkICovfVxuICAgICAgICAgICAge3N1Ym1pc3Npb25TdGF0dXM/LnN1Y2Nlc3MgJiYgIWluZGV4aW5nVHhJZCAmJiAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBtdC0yXCI+SW5kZXhpbmcgVHJhbnNhY3Rpb246PC9kaXY+XG4gICAgICAgICAgICAgICAgPEV4cGxvcmVyTGluayB0eElkPXtzdWJtaXNzaW9uU3RhdHVzLnN1Y2Nlc3MuaW5kZXhpbmdUeElkfSAvPlxuICAgICAgICAgICAgICA8Lz5cbiAgICAgICAgICAgICl9XG5cbiAgICAgICAgICAgIHtzdWJtaXNzaW9uU3RhdHVzPy5zdWNjZXNzICYmXG4gICAgICAgICAgICAgIHN1Ym1pc3Npb25TdGF0dXMuc3VjY2Vzcy5hbGxTaGFyZFN1Ym1pc3Npb25zLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgIXNoYXJkVHhJZHMgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMiB3LWZ1bGwgbXQtMlwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MFwiPlNoYXJkIFRyYW5zYWN0aW9uczo8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIHtzdWJtaXNzaW9uU3RhdHVzLnN1Y2Nlc3MuYWxsU2hhcmRTdWJtaXNzaW9ucy5tYXAoXG4gICAgICAgICAgICAgICAgICAgIChzaGFyZCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICA8RXhwbG9yZXJMaW5rXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgdHhJZD17c2hhcmQuc2hhcmRTdWJtaXR0ZWRUeGlkfVxuICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxCdXR0b25cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICByZXNldFN0YXR1cyhcInByZXBhcmF0aW9uXCIpO1xuICAgICAgICAgICAgcmVzZXRTdGF0dXMoXCJpbnNjcmlwdGlvblwiKTtcbiAgICAgICAgICAgIHNldEluc2NyaXB0aW9uU3RhdHVzKHt9KTtcbiAgICAgICAgICAgIHNldFByZXBhcmF0aW9uU3RhdHVzKHt9KTtcbiAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICByZXNldFByZXBhcmF0aW9uKCk7XG4gICAgICAgICAgICBjbGVhckZpbGUoKTtcbiAgICAgICAgICAgIHNldElzUHJlcGFyZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0SXNJbnNjcmliZWQoZmFsc2UpO1xuICAgICAgICAgICAgc2V0RGVsZWdhdGVUZXh0KFwiXCIpO1xuICAgICAgICAgIH19XG4gICAgICAgICAgY2xhc3NOYW1lPVwibXQtNFwiXG4gICAgICAgID5cbiAgICAgICAgICBJbnNjcmliZSBtb3JlXG4gICAgICAgIDwvQnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9tb3Rpb24uZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgUHJvZ3Jlc3NCYXJQcm9wcyB7XG4gIGN1cnJlbnRTdGVwOiBudW1iZXI7XG4gIHRvdGFsU3RlcHM6IG51bWJlcjtcbiAgc3RlcFRleHQ6IHN0cmluZztcbiAgcGhhc2U6IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IFByb2dyZXNzQmFyOiBSZWFjdC5GQzxQcm9ncmVzc0JhclByb3BzPiA9ICh7XG4gIGN1cnJlbnRTdGVwLFxuICB0b3RhbFN0ZXBzLFxuICBzdGVwVGV4dCxcbiAgcGhhc2UsXG59KSA9PiB7XG4gIGNvbnN0IHByb2dyZXNzID0gKGN1cnJlbnRTdGVwIC8gdG90YWxTdGVwcykgKiAxMDA7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbFwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXIgbWItMlwiPlxuICAgICAgICA8c3BhblxuICAgICAgICAgIGNsYXNzTmFtZT17YHRleHQtc20gdGV4dC13aGl0ZS84MCBmb250LWJvbGRgfVxuICAgICAgICA+XG4gICAgICAgICAgU3RlcCB7Y3VycmVudFN0ZXB9IG9mIHt0b3RhbFN0ZXBzfToge3N0ZXBUZXh0fVxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC13aGl0ZS84MFwiPntwaGFzZX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtMiBiZy13aGl0ZS8yMCByb3VuZGVkLWZ1bGwgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICBjbGFzc05hbWU9XCJoLWZ1bGwgYmctYmx1ZS01MDAgcm91bmRlZC1mdWxsIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dFwiXG4gICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IGAke3Byb2dyZXNzfSVgIH19XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG4iLCJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IG1vdGlvbiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5pbXBvcnQgeyBVcGxvYWRCb3ggfSBmcm9tIFwiLi91cGxvYWQtYm94XCI7XG5pbXBvcnQgeyBGaWxlTGlzdCB9IGZyb20gXCIuL2ZpbGUtbGlzdFwiO1xuaW1wb3J0IHsgRGVsZWdhdGVWaWV3IH0gZnJvbSBcIi4vZGVsZWdhdGUtdmlld1wiO1xuaW1wb3J0IHsgdXNlVHhQcmVwYXJhdGlvbiB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1R4UHJlcGFyYXRpb25Db250ZXh0XCI7XG5pbXBvcnQgeyB1c2VUeEluc2NyaXB0aW9uIH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvVHhJbnNjcmlwdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IExvYWRpbmdTY3JlZW4gfSBmcm9tIFwiLi4vdWkvTG9hZGluZ1NjcmVlblwiO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIi4uL3VpL0J1dHRvblwiO1xuaW1wb3J0IHsgdXNlRmlsZVVwbG9hZCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L0ZpbGVVcGxvYWRDb250ZXh0XCI7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9XYWxsZXRDb250ZXh0XCI7XG5pbXBvcnQgeyBGaW5pc2hTY3JlZW4gfSBmcm9tIFwiLi4vdWkvRmluaXNoU2NyZWVuXCI7XG5pbXBvcnQgeyB1c2VUeFN0YXR1cyB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1R4U3RhdHVzQ29udGV4dFwiO1xuaW1wb3J0IHsgUHJvZ3Jlc3NCYXIgfSBmcm9tIFwiLi4vdWkvUHJvZ3Jlc3NCYXJcIjtcblxudHlwZSBWaWV3ID0gXCJmaWxlc1wiIHwgXCJkZWxlZ2F0ZVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYWluVXBsb2FkZXIoKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgY29uc3QgW2FjdGl2ZVZpZXcsIHNldEFjdGl2ZVZpZXddID0gdXNlU3RhdGU8Vmlldz4oXCJmaWxlc1wiKTtcbiAgLy8gU2UgdXNhIGVsIG51ZXZvIGNvbnRleHRvIHF1ZSBtYW5lamEgdW4gc29sbyBhcmNoaXZvXG4gIGNvbnN0IHsgZmlsZSwgY2xlYXJGaWxlIH0gPSB1c2VGaWxlVXBsb2FkKCk7XG4gIGNvbnN0IHsgZGVmYXVsdFdhbGxldCB9ID0gdXNlV2FsbGV0KCk7XG5cbiAgY29uc3Qge1xuICAgIGlzUHJvY2Vzc2luZzogaXNQcmVwYXJpbmcsXG4gICAgY3VycmVudFN0ZXA6IHByZXBhcmVTdGVwLFxuICAgIG5leHRTdGVwOiBwcmVwYXJlTmV4dFN0ZXAsXG4gICAgZXJyb3I6IHByZXBhcmVFcnJvcixcbiAgICBjbGVhckVycm9yOiBjbGVhclByZXBhcmVFcnJvcixcbiAgICBwcmVwYXJlRmlsZXMsXG4gICAgcHJlcGFyZVRleHQsXG4gICAgc2lnbkFuZFN1Ym1pdDogc2lnbkFuZFN1Ym1pdFByZXBhcmF0aW9uLFxuICAgIHJlc2V0OiByZXNldFByZXBhcmF0aW9uLFxuICAgIHN1Ym1pc3Npb25TdGF0dXM6IHByZXBhcmF0aW9uU3VibWlzc2lvblN0YXR1cyxcbiAgICB1bnNpZ25lZFR4SWQsXG4gIH0gPSB1c2VUeFByZXBhcmF0aW9uKCk7XG5cbiAgY29uc3Qge1xuICAgIGlzUHJvY2Vzc2luZzogaXNJbnNjcmliZVByZXBhcmluZyxcbiAgICBjdXJyZW50U3RlcDogaW5zY3JpYmVTdGVwLFxuICAgIG5leHRTdGVwOiBpbnNjcmliZU5leHRTdGVwLFxuICAgIGVycm9yOiBpbnNjcmliZUVycm9yLFxuICAgIGNsZWFyRXJyb3I6IGNsZWFySW5zY3JpYmVFcnJvcixcbiAgICBpbnNjcmliZUZpbGVzLFxuICAgIHNpZ25BbmRTdWJtaXQ6IHNpZ25BbmRTdWJtaXRJbnNjcmlwdGlvbixcbiAgICByZXNldDogcmVzZXRJbnNjcmlwdGlvbixcbiAgICBzdWJtaXNzaW9uU3RhdHVzLFxuICAgIHVuc2lnbmVkVHgsXG4gIH0gPSB1c2VUeEluc2NyaXB0aW9uKCk7XG5cbiAgY29uc3QgW2lzUHJlcGFyZWQsIHNldElzUHJlcGFyZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbaXNJbnNjcmliZWQsIHNldElzSW5zY3JpYmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2RlbGVnYXRlVGV4dCwgc2V0RGVsZWdhdGVUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCB7IHJlc2V0U3RhdHVzIH0gPSB1c2VUeFN0YXR1cygpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc29sZS5sb2coXCJwcmVwYXJlRXJyb3JcIiwgcHJlcGFyZUVycm9yKTtcbiAgICBjb25zb2xlLmxvZyhcImluc2NyaWJlRXJyb3JcIiwgaW5zY3JpYmVFcnJvcik7XG4gIH0sIFtwcmVwYXJlRXJyb3IsIGluc2NyaWJlRXJyb3IsIGNsZWFyUHJlcGFyZUVycm9yLCBjbGVhckluc2NyaWJlRXJyb3JdKTtcblxuICAvLyBDb25zb2xpZGF0ZWQgc3RhdGUgbWFuYWdlbWVudCBsb2dpY1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVwYXJlRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiUmVzZXR0aW5nIGlzUHJlcGFyZWQgZHVlIHRvIGVycm9yOlwiLCBwcmVwYXJlRXJyb3IpO1xuICAgICAgc2V0SXNQcmVwYXJlZChmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChwcmVwYXJlU3RlcCA9PT0gXCJwcmVwYXJlL3JldHJpZXZlLXN1Ym1pc3Npb25cIiB8fCBwcmVwYXJhdGlvblN1Ym1pc3Npb25TdGF0dXM/LnN1Y2Nlc3M/Lm9uY2hhaW4gPT09IFwib24tY2hhaW5cIikge1xuICAgICAgY29uc29sZS5sb2coXCJGaW5hbCBwcmVwYXJhdGlvbiBzdGVwIHJlYWNoZWQgd2l0aCBubyBlcnJvcnMgb3IgdHJhbnNhY3Rpb24gaXMgb24tY2hhaW4sIHNldHRpbmcgaXNQcmVwYXJlZCB0byB0cnVlXCIpO1xuICAgICAgc2V0SXNQcmVwYXJlZCh0cnVlKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zY3JpYmVFcnJvcikge1xuICAgICAgY29uc29sZS5sb2coXCJSZXNldHRpbmcgaXNJbnNjcmliZWQgZHVlIHRvIGVycm9yOlwiLCBpbnNjcmliZUVycm9yKTtcbiAgICAgIHNldElzSW5zY3JpYmVkKGZhbHNlKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcInByZXBhcmVTdGVwXCIsIHByZXBhcmVTdGVwKTtcbiAgICBjb25zb2xlLmxvZyhcImluc2NyaWJlU3RlcFwiLCBpbnNjcmliZVN0ZXApO1xuICAgIGNvbnNvbGUubG9nKFwiaXNQcmVwYXJlZFwiLCBpc1ByZXBhcmVkKTtcbiAgICBjb25zb2xlLmxvZyhcImlzSW5zY3JpYmVkXCIsIGlzSW5zY3JpYmVkKTtcbiAgfSwgW3ByZXBhcmVFcnJvciwgcHJlcGFyZVN0ZXAsIHByZXBhcmF0aW9uU3VibWlzc2lvblN0YXR1cywgaW5zY3JpYmVFcnJvcl0pO1xuXG4gIGNvbnN0IGdldExvYWRpbmdUZXh0ID0gKCkgPT4ge1xuICAgIGlmICghaXNQcmVwYXJlZCkge1xuICAgICAgc3dpdGNoIChwcmVwYXJlU3RlcCkge1xuICAgICAgICBjYXNlIFwicHJlcGFyZS9jb25zdHJ1Y3RcIjpcbiAgICAgICAgICByZXR1cm4gXCJQcmVwYXJpbmcgYW5kIGNvbnN0cnVjdGluZyB0cmFuc2FjdGlvbi4uLlwiO1xuICAgICAgICBjYXNlIFwicHJlcGFyZS9yZXRyaWV2ZVwiOlxuICAgICAgICAgIHJldHVybiBcIlJldHJpZXZpbmcgdXR4byBwcmVwYXJhdGlvbiB0cmFuc2FjdGlvbiBmb3Igc2lnbmluZy4uLlwiO1xuICAgICAgICBjYXNlIFwicHJlcGFyZS9zdWJtaXRcIjpcbiAgICAgICAgICByZXR1cm4gXCJTdWJtaXR0aW5nIHNpZ25lZCB0cmFuc2FjdGlvbi4uLlwiO1xuICAgICAgICBjYXNlIFwicHJlcGFyZS9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwiUmV0cmlldmluZyBwcmVwYXJhdGlvbiBzdWJtaXNzaW9uIHN0YXR1cy4uLlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlByb2Nlc3NpbmcuLi5cIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChpbnNjcmliZVN0ZXApIHtcbiAgICAgICAgY2FzZSBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiOlxuICAgICAgICAgIHJldHVybiBcIkNvbnN0cnVjdGluZyBpbnNjcmlwdGlvbiB0cmFuc2FjdGlvbi4uLlwiO1xuICAgICAgICBjYXNlIFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIjpcbiAgICAgICAgICByZXR1cm4gXCJSZXRyaWV2aW5nIHV0eG8gaW5zY3JpcHRpb24gdHJhbnNhY3Rpb24gZm9yIHNpZ25pbmcuLi5cIjtcbiAgICAgICAgY2FzZSBcImluc2NyaXB0aW9uL3N1Ym1pdFwiOlxuICAgICAgICAgIHJldHVybiBcIlN1Ym1pdHRpbmcgc2lnbmVkIHRyYW5zYWN0aW9uLi4uXCI7XG4gICAgICAgIGNhc2UgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwiUmV0cmlldmluZyBpbnNjcmlwdGlvbiBzdWJtaXNzaW9uIHN0YXR1cy4uLlwiO1xuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIFwiVHJhbnNhY3Rpb24gc3VibWl0dGVkIVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlByb2Nlc3NpbmcuLi5cIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0UHJvZ3Jlc3NUZXh0ID0gKCkgPT4ge1xuICAgIGlmIChpc0luc2NyaWJlZCkge1xuICAgICAgcmV0dXJuIFwiSW5zY3JpcHRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseSFcIjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUHJlcGFyZWQpIHtcbiAgICAgIHN3aXRjaCAocHJlcGFyZVN0ZXApIHtcbiAgICAgICAgY2FzZSBcInByZXBhcmUvY29uc3RydWN0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiU2VsZWN0IGNvbnRlbnQgdG8gdXBsb2FkXCI7XG4gICAgICAgIGNhc2UgXCJwcmVwYXJlL3JldHJpZXZlXCI6XG4gICAgICAgICAgcmV0dXJuIFwiU2lnbiB5b3VyIHRyYW5zYWN0aW9uKHMpXCI7XG4gICAgICAgIGNhc2UgXCJwcmVwYXJlL3N1Ym1pdFwiOlxuICAgICAgICAgIHJldHVybiBcIlN1Ym1pdHRpbmcgeW91ciBzaWduZWQgdHJhbnNhY3Rpb24ocykuLi5cIjtcbiAgICAgICAgY2FzZSBcInByZXBhcmUvcmV0cmlldmUtc3VibWlzc2lvblwiOlxuICAgICAgICAgIHJldHVybiBcIlZhbGlkYXRpbmcgeW91ciB0cmFuc2FjdGlvbihzKSBvbiBjaGFpbi4uLlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlByb2Nlc3NpbmcuLi5cIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoIChpbnNjcmliZVN0ZXApIHtcbiAgICAgICAgY2FzZSBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiOlxuICAgICAgICAgIHJldHVybiBcIkNvbmZpcm0geW91ciBpbnNjcmlwdGlvbiBjb250ZW50XCI7XG4gICAgICAgIGNhc2UgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiOlxuICAgICAgICAgIHJldHVybiBcIlNpZ24geW91ciB0cmFuc2FjdGlvbihzKVwiO1xuICAgICAgICBjYXNlIFwiaW5zY3JpcHRpb24vc3VibWl0XCI6XG4gICAgICAgICAgcmV0dXJuIFwiU3VibWl0dGluZyB5b3VyIHNpZ25lZCB0cmFuc2FjdGlvbihzKS4uLlwiO1xuICAgICAgICBjYXNlIFwiaW5zY3JpcHRpb24vcmV0cmlldmUtc3VibWlzc2lvblwiOlxuICAgICAgICAgIHJldHVybiBcIlZhbGlkYXRpbmcgeW91ciB0cmFuc2FjdGlvbihzKSBvbiBjaGFpbi4uLlwiO1xuICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgcmV0dXJuIFwiVHJhbnNhY3Rpb24gc3VibWl0dGVkIVwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBcIlByb2Nlc3NpbmcuLi5cIjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0QnV0dG9uVGV4dCA9ICgpID0+IHtcbiAgICAvLyBJZiB0aGVyZSdzIGEgd2FsbGV0IHNpZ25pbmcgZXJyb3IsIHNob3cgXCJSZXRyeSBTaWduaW5nXCIgYnV0dG9uXG4gICAgaWYgKGluc2NyaWJlRXJyb3IgJiYgaW5zY3JpYmVFcnJvci5pbmNsdWRlcyhcIldhbGxldCBzaWduaW5nIGVycm9yXCIpKSB7XG4gICAgICByZXR1cm4gXCJSZXRyeSBTaWduaW5nXCI7XG4gICAgfVxuICAgIGlmIChwcmVwYXJlRXJyb3IgJiYgcHJlcGFyZUVycm9yLmluY2x1ZGVzKFwiV2FsbGV0IHNpZ25pbmcgZXJyb3JcIikpIHtcbiAgICAgIHJldHVybiBcIlJldHJ5IFNpZ25pbmdcIjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUHJlcGFyZWQpIHtcbiAgICAgIGlmIChwcmVwYXJlU3RlcCA9PT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwiKSB7XG4gICAgICAgIHJldHVybiBcIlByZXBhcmUgVVR4T3MgZm9yIGluc2NyaXB0aW9uXCI7XG4gICAgICB9IGVsc2UgaWYgKHByZXBhcmVTdGVwID09PSBcInByZXBhcmUvcmV0cmlldmVcIikge1xuICAgICAgICByZXR1cm4gXCJTaWduIGFuZCBzdWJtaXQgdXR4byBwcmVwYXJhdGlvbiB0cmFuc2FjdGlvblwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNQcmVwYXJlZCAmJiAhaXNJbnNjcmliZWQpIHtcbiAgICAgIGlmIChpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiSW5zY3JpYmUgT25jaGFpblwiO1xuICAgICAgfSBlbHNlIGlmIChpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIikge1xuICAgICAgICByZXR1cm4gXCJTaWduIGFuZCBJbnNjcmliZVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJQcm9jZXNzaW5nLi4uXCI7XG4gIH07XG5cbiAgY29uc3QgaXNJbkZpbmFsU3RlcCA9ICgpID0+IHtcbiAgICByZXR1cm4gKFxuICAgICAgaW5zY3JpYmVTdGVwID09PSBcImluc2NyaXB0aW9uL3JldHJpZXZlLXN1Ym1pc3Npb25cIiB8fCBpc0luc2NyaWJlUHJlcGFyaW5nXG4gICAgKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVQcmVwYXJlID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChhY3RpdmVWaWV3ID09PSBcImZpbGVzXCIpIHtcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuO1xuICAgICAgYXdhaXQgcHJlcGFyZUZpbGVzKFtmaWxlXSk7IC8vIHNlIHBhc2EgZWwgYXJjaGl2byBjb21vIGFycmF5IGRlIHVuIHNvbG8gZWxlbWVudG9cbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgcHJlcGFyZVRleHQoZGVsZWdhdGVUZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlSW5zY3JpYmUgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZVZpZXcgPT09IFwiZmlsZXNcIikge1xuICAgICAgaWYgKCFmaWxlKSByZXR1cm47XG4gICAgICBhd2FpdCBpbnNjcmliZUZpbGVzKFtmaWxlXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGluc2NyaWJlRmlsZXMoW1xuICAgICAgICBuZXcgRmlsZShbZGVsZWdhdGVUZXh0XSwgXCJpbnNjcmlwdGlvbi50eHRcIiwgeyB0eXBlOiBcInRleHQvcGxhaW5cIiB9KSxcbiAgICAgIF0pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTaWduQW5kU3VibWl0UHJlcGFyYXRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHNldElzUHJlcGFyZWQoZmFsc2UpOyAvLyBSZXNldCB0aGUgc3RhdGUgYmVmb3JlIHN0YXJ0aW5nXG4gICAgICBhd2FpdCBzaWduQW5kU3VibWl0UHJlcGFyYXRpb24oKTtcbiAgICAgIC8vIFdlJ2xsIGxldCB0aGUgdXNlRWZmZWN0IGhhbmRsZSBzZXR0aW5nIGlzUHJlcGFyZWQgYmFzZWQgb24gdGhlIHN0ZXAgYW5kIGVycm9yIHN0YXRlXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBkdXJpbmcgcHJlcGFyYXRpb246XCIsIGVycm9yKTtcbiAgICAgIC8vIE1ha2Ugc3VyZSBpc1ByZXBhcmVkIGlzIGZhbHNlIGluIGNhc2Ugb2YgZXJyb3JcbiAgICAgIHNldElzUHJlcGFyZWQoZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVTaWduQW5kU3VibWl0SW5zY3JpcHRpb24gPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHNpZ25BbmRTdWJtaXRJbnNjcmlwdGlvbigpO1xuICAgICAgLy8gT25seSBzZXQgaXNJbnNjcmliZWQgdG8gdHJ1ZSBpZiB0aGVyZSB3YXMgbm8gZXJyb3JcbiAgICAgIGlmICghaW5zY3JpYmVFcnJvcikge1xuICAgICAgICBzZXRJc0luc2NyaWJlZCh0cnVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyBpbnNjcmlwdGlvbjpcIiwgZXJyb3IpO1xuICAgICAgLy8gTWFrZSBzdXJlIGlzSW5zY3JpYmVkIGlzIGZhbHNlIGluIGNhc2Ugb2YgZXJyb3JcbiAgICAgIHNldElzSW5zY3JpYmVkKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQmFjayA9ICgpID0+IHtcbiAgICByZXNldFByZXBhcmF0aW9uKCk7XG4gICAgc2V0SXNQcmVwYXJlZChmYWxzZSk7XG4gICAgLy8gU29sbyByZWluaWNpYW1vcyBlbCBlc3RhZG8gZGUgcHJlcGFyYWNpw7NuXG4gICAgcmVzZXRTdGF0dXMoXCJwcmVwYXJhdGlvblwiKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVDYW5jZWwgPSAoKSA9PiB7XG4gICAgcmVzZXRQcmVwYXJhdGlvbigpO1xuICAgIHJlc2V0SW5zY3JpcHRpb24oKTtcbiAgICBzZXRJc1ByZXBhcmVkKGZhbHNlKTtcbiAgICBzZXRJc0luc2NyaWJlZChmYWxzZSk7XG4gICAgY2xlYXJGaWxlKCk7XG4gICAgc2V0RGVsZWdhdGVUZXh0KFwiXCIpO1xuICAgIHJlc2V0U3RhdHVzKFwicHJlcGFyYXRpb25cIik7XG4gICAgcmVzZXRTdGF0dXMoXCJpbnNjcmlwdGlvblwiKTtcbiAgICBzZXREZWxlZ2F0ZVRleHQoXCJcIik7XG4gICAgXG4gIH07XG5cbiAgY29uc3Qgc2hvd0xvYWRlciA9IGlzUHJlcGFyaW5nIHx8IGlzSW5GaW5hbFN0ZXAoKTtcblxuICBjb25zdCBoYW5kbGVNYWluQnV0dG9uQ2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgLy8gSWYgdGhlcmUncyBhIHdhbGxldCBzaWduaW5nIGVycm9yLCByZXRyeSB0aGUgYXBwcm9wcmlhdGUgc2lnbmluZyBwcm9jZXNzXG4gICAgaWYgKHByZXBhcmVFcnJvciAmJiBwcmVwYXJlRXJyb3IuaW5jbHVkZXMoXCJXYWxsZXQgc2lnbmluZyBlcnJvclwiKSkge1xuICAgICAgYXdhaXQgaGFuZGxlU2lnbkFuZFN1Ym1pdFByZXBhcmF0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGlmIChpbnNjcmliZUVycm9yICYmIGluc2NyaWJlRXJyb3IuaW5jbHVkZXMoXCJXYWxsZXQgc2lnbmluZyBlcnJvclwiKSkge1xuICAgICAgYXdhaXQgaGFuZGxlU2lnbkFuZFN1Ym1pdEluc2NyaXB0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFpc1ByZXBhcmVkKSB7XG4gICAgICBpZiAocHJlcGFyZVN0ZXAgPT09IFwicHJlcGFyZS9jb25zdHJ1Y3RcIikge1xuICAgICAgICBhd2FpdCBoYW5kbGVQcmVwYXJlKCk7XG4gICAgICB9IGVsc2UgaWYgKHByZXBhcmVTdGVwID09PSBcInByZXBhcmUvcmV0cmlldmVcIikge1xuICAgICAgICBhd2FpdCBoYW5kbGVTaWduQW5kU3VibWl0UHJlcGFyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJlcGFyZWQgJiYgIWlzSW5zY3JpYmVkKSB7XG4gICAgICBpZiAoaW5zY3JpYmVTdGVwID09PSBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUluc2NyaWJlKCk7XG4gICAgICB9IGVsc2UgaWYgKGluc2NyaWJlU3RlcCA9PT0gXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiKSB7XG4gICAgICAgIGF3YWl0IGhhbmRsZVNpZ25BbmRTdWJtaXRJbnNjcmlwdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBnZXRUb3RhbFN0ZXBzID0gKCkgPT4ge1xuICAgIHJldHVybiA4OyAvLyA0IHByZXBhcmUgc3RlcHMgKyA0IGluc2NyaXB0aW9uIHN0ZXBzXG4gIH07XG5cbiAgY29uc3QgZ2V0Q3VycmVudFN0ZXAgPSAoKSA9PiB7XG4gICAgaWYgKGlzSW5zY3JpYmVkKSB7XG4gICAgICByZXR1cm4gODsgLy8gU3RheSBhdCBmaW5hbCBzdGVwIHdoZW4gaW5zY3JpcHRpb24gaXMgY29tcGxldGVcbiAgICB9XG5cbiAgICBjb25zdCBwcmVwYXJlU3RlcHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICBcInByZXBhcmUvY29uc3RydWN0XCI6IDEsXG4gICAgICBcInByZXBhcmUvcmV0cmlldmVcIjogMixcbiAgICAgIFwicHJlcGFyZS9zdWJtaXRcIjogMyxcbiAgICAgIFwicHJlcGFyZS9yZXRyaWV2ZS1zdWJtaXNzaW9uXCI6IDQsXG4gICAgfTtcblxuICAgIGNvbnN0IGluc2NyaWJlU3RlcHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7XG4gICAgICBcImluc2NyaXB0aW9uL2NvbnN0cnVjdFwiOiA1LFxuICAgICAgXCJpbnNjcmlwdGlvbi9yZXRyaWV2ZVwiOiA2LFxuICAgICAgXCJpbnNjcmlwdGlvbi9zdWJtaXRcIjogNyxcbiAgICAgIFwiaW5zY3JpcHRpb24vcmV0cmlldmUtc3VibWlzc2lvblwiOiA4LFxuICAgICAgZW5kOiA4LFxuICAgIH07XG5cbiAgICBpZiAoIWlzUHJlcGFyZWQpIHtcbiAgICAgIHJldHVybiBwcmVwYXJlU3RlcHNbcHJlcGFyZVN0ZXBdIHx8IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbnNjcmliZVN0ZXBzW2luc2NyaWJlU3RlcF0gfHwgNTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgZ2V0U3RlcFBoYXNlID0gKCkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRTdGVwID0gZ2V0Q3VycmVudFN0ZXAoKTtcbiAgICByZXR1cm4gY3VycmVudFN0ZXAgPD0gNCA/IFwiUHJlcGFyYXRpb25cIiA6IFwiSW5zY3JpcHRpb25cIjtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxtb3Rpb24uZGl2XG4gICAgICBjbGFzc05hbWU9XCJiZy13aGl0ZS8xMCByb3VuZGVkLTR4bCBiYWNrZHJvcC1ibHVyLVsxMHB4XSBwLTggbWF4LXctNXhsIHctZnVsbCBteC1hdXRvIHRleHQtd2hpdGVcIlxuICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCBzY2FsZTogMC45IH19XG4gICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEsIHNjYWxlOiAxIH19XG4gICAgICB0cmFuc2l0aW9uPXt7IGR1cmF0aW9uOiAwLjUgfX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1iLTZcIj5cbiAgICAgICAgPFByb2dyZXNzQmFyXG4gICAgICAgICAgY3VycmVudFN0ZXA9e2dldEN1cnJlbnRTdGVwKCl9XG4gICAgICAgICAgdG90YWxTdGVwcz17Z2V0VG90YWxTdGVwcygpfVxuICAgICAgICAgIHN0ZXBUZXh0PXtnZXRQcm9ncmVzc1RleHQoKX1cbiAgICAgICAgICBwaGFzZT17Z2V0U3RlcFBoYXNlKCl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIHshc2hvd0xvYWRlciAmJiAhaXNJbnNjcmliZWQgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktNlwiPlxuICAgICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW5cIlxuICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwLCB5OiAtMjAgfX1cbiAgICAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSwgeTogMCB9fVxuICAgICAgICAgICAgdHJhbnNpdGlvbj17eyBkdXJhdGlvbjogMC41LCBkZWxheTogMC4yIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LVsxLjI1cmVtXVwiPlxuICAgICAgICAgICAgICB7cHJlcGFyZVN0ZXAgPT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwiID8gKFxuICAgICAgICAgICAgICAgIFwiQWRkIEZpbGUgb3IgVGV4dCB0byBpbnNjcmliZVwiXG4gICAgICAgICAgICAgICkgOiBwcmVwYXJlU3RlcCA9PSBcInByZXBhcmUvcmV0cmlldmVcIiA/IChcbiAgICAgICAgICAgICAgICBcIlByZXBhcmluZyB5b3VyIFVUeE9zLlwiXG4gICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgPHN0cm9uZz5cbiAgICAgICAgICAgICAgICAgIFBsZWFzZSBkb3VibGUgY2hlY2sgdGhlIHRleHQgaXRlbXMgYmVsb3cgYmVmb3JlIGNvbnRpbnVpbmc6XG4gICAgICAgICAgICAgICAgPC9zdHJvbmc+XG4gICAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBcIj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTIgcHktWzAuMTI1cmVtXSAke1xuICAgICAgICAgICAgICAgICAgYWN0aXZlVmlldyA9PT0gXCJmaWxlc1wiXG4gICAgICAgICAgICAgICAgICAgID8gXCJiZy1bIzA1MTAyM10gdGV4dC13aGl0ZVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJiZy1bIzA1MTAyM10vMjAgdGV4dC13aGl0ZS82MFwiXG4gICAgICAgICAgICAgICAgfWB9XG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0QWN0aXZlVmlldyhcImZpbGVzXCIpfVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7IGJvcmRlclJhZGl1czogXCIwLjI1cmVtXCIgfX1cbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17cHJlcGFyZVN0ZXAgIT09IFwicHJlcGFyZS9jb25zdHJ1Y3RcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIEZpbGVzXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtgcHgtMiBweS1bMC4xMjVyZW1dICR7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVWaWV3ID09PSBcImRlbGVnYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgPyBcImJnLVsjMDUxMDIzXSB0ZXh0LXdoaXRlXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcImJnLVsjMDUxMDIzXS8yMCB0ZXh0LXdoaXRlLzYwXCJcbiAgICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRBY3RpdmVWaWV3KFwiZGVsZWdhdGVcIil9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgYm9yZGVyUmFkaXVzOiBcIjAuMjVyZW1cIiB9fVxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtwcmVwYXJlU3RlcCAhPT0gXCJwcmVwYXJlL2NvbnN0cnVjdFwifVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgVGV4dFxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTRcIj5cbiAgICAgICAgICAgIHsocHJlcGFyZUVycm9yIHx8IGluc2NyaWJlRXJyb3IpICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtcmVkLTYwMCBiZy13aGl0ZSBwLTQgcm91bmRlZC1tZCBvdmVyZmxvdy1hdXRvXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi0yIGZvbnQtc2VtaWJvbGRcIj5FcnJvciBvY2N1cnJlZDo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8cHJlIGNsYXNzTmFtZT1cIndoaXRlc3BhY2UtcHJlLXdyYXBcIj5cbiAgICAgICAgICAgICAgICAgIHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgeyBlcnJvcjogcHJlcGFyZUVycm9yIHx8IGluc2NyaWJlRXJyb3IgfSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtcbiAgICAgICAgICAgICAgICAgICAgcHJlcGFyZUVycm9yID8gY2xlYXJQcmVwYXJlRXJyb3IgOiBjbGVhckluc2NyaWJlRXJyb3JcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiFtdC00IHB4LTMgcHktMSBiZy1ibHVlLTYwMCAhdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWJsdWUtNzAwXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBDbGVhciBFcnJvclxuICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7aW5zY3JpYmVTdGVwID09PSBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIgfHxcbiAgICAgICAgICAgICAgaW5zY3JpYmVTdGVwID09PSBcImluc2NyaXB0aW9uL3N1Ym1pdFwiIHx8XG4gICAgICAgICAgICAgIChpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vY29uc3RydWN0XCIgJiYgaXNQcmVwYXJlZCAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yIHRleHQtWzEuMjVyZW1dXCI+XG4gICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICBXZSB0YWtlIG5vIHJlc3BvbnNpYmlsaXR5IGZvciB0eXBvcyBvciB3cm9uZyBwdW5jdHVhdGlvbi4gV2VcbiAgICAgICAgICAgICAgICAgICAgYXJlIGFsc28gbm90IGNoZWNraW5nIGZvciBhbnkgcHJldmlvdXMgaW5zY3JpcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5pbmcgdGhlIHNhbWUgdGV4dC5cbiAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIHthY3RpdmVWaWV3ID09PSBcImZpbGVzXCIgPyAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAge3ByZXBhcmVTdGVwID09PSBcInByZXBhcmUvY29uc3RydWN0XCIgJiYgPFVwbG9hZEJveCAvPn1cbiAgICAgICAgICAgICAgICB7ZmlsZSAmJiA8RmlsZUxpc3QgLz59XG4gICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgPERlbGVnYXRlVmlld1xuICAgICAgICAgICAgICAgIHRleHQ9e2RlbGVnYXRlVGV4dH1cbiAgICAgICAgICAgICAgICBzZXRUZXh0PXsodGV4dDogc3RyaW5nKSA9PiBzZXREZWxlZ2F0ZVRleHQodGV4dCl9XG4gICAgICAgICAgICAgICAgaXNQcm9jZXNzaW5nPXtpc1ByZXBhcmluZyB8fCBpc0luRmluYWxTdGVwKCl9XG4gICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtNFwiPlxuICAgICAgICAgICAgeyhwcmVwYXJlU3RlcCA9PT0gXCJwcmVwYXJlL3JldHJpZXZlXCIgfHxcbiAgICAgICAgICAgICAgaW5zY3JpYmVTdGVwID09PSBcImluc2NyaXB0aW9uL3JldHJpZXZlXCIpICYmIChcbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUJhY2t9XG4gICAgICAgICAgICAgICAgYW5pbWF0ZT17ZmFsc2V9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy0xLzRcIlxuICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJzZWNvbmRhcnlcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgQmFja1xuICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZU1haW5CdXR0b25DbGlja31cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsXCJcbiAgICAgICAgICAgICAgZGlzYWJsZWQ9e1xuICAgICAgICAgICAgICAgIChhY3RpdmVWaWV3ID09PSBcImZpbGVzXCIgJiYgIWZpbGUpIHx8XG4gICAgICAgICAgICAgICAgKGFjdGl2ZVZpZXcgPT09IFwiZGVsZWdhdGVcIiAmJiAhZGVsZWdhdGVUZXh0LnRyaW0oKSkgfHxcbiAgICAgICAgICAgICAgICAhZGVmYXVsdFdhbGxldCB8fFxuICAgICAgICAgICAgICAgIC8vIERvbid0IGRpc2FibGUgdGhlIGJ1dHRvbiB3aGVuIHRoZXJlJ3MgYSB3YWxsZXQgc2lnbmluZyBlcnJvclxuICAgICAgICAgICAgICAgIChpc1ByZXBhcmluZyAmJiBcbiAgICAgICAgICAgICAgICAgICEocHJlcGFyZUVycm9yICYmIHByZXBhcmVFcnJvci5pbmNsdWRlcyhcIldhbGxldCBzaWduaW5nIGVycm9yXCIpKSAmJiBcbiAgICAgICAgICAgICAgICAgICEoaW5zY3JpYmVFcnJvciAmJiBpbnNjcmliZUVycm9yLmluY2x1ZGVzKFwiV2FsbGV0IHNpZ25pbmcgZXJyb3JcIikpXG4gICAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIGlzSW5GaW5hbFN0ZXAoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtnZXRCdXR0b25UZXh0KCl9XG4gICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAge3Nob3dMb2FkZXIgJiYgPExvYWRpbmdTY3JlZW4gdGV4dD17Z2V0TG9hZGluZ1RleHQoKX0gLz59XG5cbiAgICAgIHt1bnNpZ25lZFR4SWQgJiYgIWlzSW5zY3JpYmVkICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IGl0ZW1zLWNlbnRlciB0ZXh0LXNtIHctZnVsbCBtdC04XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBmb250LXNlbWlib2xkIHNlbGYtc3RhcnRcIj5cbiAgICAgICAgICAgIFByZXBhcmF0aW9uIFBoYXNlXG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yIHctZnVsbFwiPlxuICAgICAgICAgICAge3Vuc2lnbmVkVHhJZCAmJiAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBcIj5QcmVwYXJhdGlvbiBUcmFuc2FjdGlvbjo8L2Rpdj5cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgaHJlZj17YGh0dHBzOi8vcHJlcHJvZC5jYXJkYW5vc2Nhbi5pby90cmFuc2FjdGlvbi8ke3Vuc2lnbmVkVHhJZH1gfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgaG92ZXI6b3BhY2l0eS04MCB0cmFuc2l0aW9uLWNvbG9ycyBmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMiB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy00IGgtNFwiXG4gICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgIGQ9XCJNOSA1SDdDNS44OTU0MyA1IDUgNS44OTU0MyA1IDdWMTlDNSAyMC4xMDQ2IDUuODk1NDMgMjEgNyAyMUgxN0MxOC4xMDQ2IDIxIDE5IDIwLjEwNDYgMTkgMTlWN0MxOSA1Ljg5NTQzIDE4LjEwNDYgNSAxNyA1SDE1XCJcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICBkPVwiTTEyIDEyVjNNMTIgM0w5IDZNMTIgM0wxNSA2XCJcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlTGluZWNhcD1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICAgICAge3Vuc2lnbmVkVHhJZH1cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIDwvPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIHsvKiA8YVxuICAgICAgICAgICAgICAgIGhyZWY9e2BodHRwczovL3ByZXByb2QuY2FyZGFub3NjYW4uaW8vdHJhbnNhY3Rpb24vJHtwcmVwYXJhdGlvblN1Ym1pc3Npb25TdGF0dXMuc3VjY2Vzcy50eGlkfWB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCIhdGV4dC13aGl0ZS84MCBob3ZlcjpvcGFjaXR5LTgwIHRyYW5zaXRpb24tY29sb3JzIGZsZXggaXRlbXMtY2VudGVyIGdhcC0yIHctZnVsbFwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTQgaC00XCJcbiAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICAgICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZD1cIk05IDVIN0M1Ljg5NTQzIDUgNSA1Ljg5NTQzIDUgN1YxOUM1IDIwLjEwNDYgNS44OTU0MyAyMSA3IDIxSDE3QzE4LjEwNDYgMjEgMTkgMjAuMTA0NiAxOSAxOVY3QzE5IDUuODk1NDMgMTguMTA0NiA1IDE3IDVIMTVcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cIjJcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgIGQ9XCJNMTIgMTJWM00xMiAzTDkgNk0xMiAzTDE1IDZcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2U9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aD1cIjJcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lY2FwPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICBzdHJva2VMaW5lam9pbj1cInJvdW5kXCJcbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAge3ByZXBhcmF0aW9uU3VibWlzc2lvblN0YXR1cy5zdWNjZXNzLnR4aWR9XG4gICAgICAgICAgICAgIDwvYT4gKi99XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cblxuICAgICAgeyhpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vcmV0cmlldmVcIiB8fFxuICAgICAgICBpbnNjcmliZVN0ZXAgPT09IFwiaW5zY3JpcHRpb24vc3VibWl0XCIpICYmXG4gICAgICAgIHVuc2lnbmVkVHg/LnN1Y2Nlc3MgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtNCBpdGVtcy1jZW50ZXIgdGV4dC1zbSB3LWZ1bGwgbXQtOFwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0yIHctZnVsbFwiPlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGZvbnQtc2VtaWJvbGRcIj5cbiAgICAgICAgICAgICAgICBJbnNjcmlwdGlvbiBQaGFzZVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJib3JkZXItdCBib3JkZXItd2hpdGUvMjAgbXktMVwiPjwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIG10LTJcIj5cbiAgICAgICAgICAgICAgICBJbnNjcmlwdGlvbiBJbmRleGluZyBUcmFuc2FjdGlvbjpcbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgaHJlZj17YGh0dHBzOi8vcHJlcHJvZC5jYXJkYW5vc2Nhbi5pby90cmFuc2FjdGlvbi8ke3Vuc2lnbmVkVHguc3VjY2Vzcy5pbmRleGluZ1R4SWR9YH1cbiAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGhvdmVyOm9wYWNpdHktODAgdHJhbnNpdGlvbi1jb2xvcnMgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgdy1mdWxsXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNCBoLTRcIlxuICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICBkPVwiTTkgNUg3QzUuODk1NDMgNSA1IDUuODk1NDMgNSA3VjE5QzUgMjAuMTA0NiA1Ljg5NTQzIDIxIDcgMjFIMTdDMTguMTA0NiAyMSAxOSAyMC4xMDQ2IDE5IDE5VjdDMTkgNS44OTU0MyAxOC4xMDQ2IDUgMTcgNUgxNVwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgZD1cIk0xMiAxMlYzTTEyIDNMOSA2TTEyIDNMMTUgNlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICB7dW5zaWduZWRUeC5zdWNjZXNzLmluZGV4aW5nVHhJZH1cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIHt1bnNpZ25lZFR4LnN1Y2Nlc3Muc2hhcmRUeElkcyAmJlxuICAgICAgICAgICAgICB1bnNpZ25lZFR4LnN1Y2Nlc3Muc2hhcmRUeElkcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIgdy1mdWxsIG10LTJcIj5cbiAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIXRleHQtd2hpdGUvODAgZm9udC1zZW1pYm9sZFwiPlxuICAgICAgICAgICAgICAgICAgICBTaGFyZCBUcmFuc2FjdGlvbnM6XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgIHt1bnNpZ25lZFR4LnN1Y2Nlc3Muc2hhcmRUeElkcy5tYXAoKHNoYXJkVHhJZCwgaW5kZXgpID0+IChcbiAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICBrZXk9e2luZGV4fVxuICAgICAgICAgICAgICAgICAgICAgIGhyZWY9e2BodHRwczovL3ByZXByb2QuY2FyZGFub3NjYW4uaW8vdHJhbnNhY3Rpb24vJHtzaGFyZFR4SWR9YH1cbiAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIiF0ZXh0LXdoaXRlLzgwIGhvdmVyOm9wYWNpdHktODAgdHJhbnNpdGlvbi1jb2xvcnMgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTIgdy1mdWxsXCJcbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNCBoLTRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkPVwiTTkgNUg3QzUuODk1NDMgNSA1IDUuODk1NDMgNSA3VjE5QzUgMjAuMTA0NiA1Ljg5NTQzIDIxIDcgMjFIMTdDMTguMTA0NiAyMSAxOSAyMC4xMDQ2IDE5IDE5VjdDMTkgNS44OTU0MyAxOC4xMDQ2IDUgMTcgNUgxNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk0xMiAxMlYzTTEyIDNMOSA2TTEyIDNMMTUgNlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoPVwiMlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgICAgICB7c2hhcmRUeElkfVxuICAgICAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgKX1cblxuICAgICAge2lzSW5zY3JpYmVkICYmIChcbiAgICAgICAgPEZpbmlzaFNjcmVlblxuICAgICAgICAgIHNldElzUHJlcGFyZWQ9e3NldElzUHJlcGFyZWR9XG4gICAgICAgICAgc2V0SXNJbnNjcmliZWQ9e3NldElzSW5zY3JpYmVkfVxuICAgICAgICAgIHNldERlbGVnYXRlVGV4dD17c2V0RGVsZWdhdGVUZXh0fVxuICAgICAgICAgIHN1Ym1pc3Npb25TdGF0dXM9e3N1Ym1pc3Npb25TdGF0dXN9XG4gICAgICAgICAgcHJlcGFyYXRpb25UeElkPXtwcmVwYXJhdGlvblN1Ym1pc3Npb25TdGF0dXM/LnN1Y2Nlc3M/LnR4aWR9XG4gICAgICAgICAgdW5zaWduZWRUeElkPXt1bnNpZ25lZFR4SWQgPz8gdW5kZWZpbmVkfVxuICAgICAgICAgIGluZGV4aW5nVHhJZD17dW5zaWduZWRUeD8uc3VjY2Vzcz8uaW5kZXhpbmdUeElkfVxuICAgICAgICAgIHNoYXJkVHhJZHM9e3Vuc2lnbmVkVHg/LnN1Y2Nlc3M/LnNoYXJkVHhJZHN9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAgey8qICB7KHByZXBhcmVOZXh0U3RlcCB8fCBpbnNjcmliZU5leHRTdGVwKSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXdoaXRlLzYwXCI+XG4gICAgICAgICAgTmV4dCBzdGVwOiB7cHJlcGFyZU5leHRTdGVwIHx8IGluc2NyaWJlTmV4dFN0ZXB9XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICAgIHsocHJlcGFyZVN0ZXAgfHwgaW5zY3JpYmVTdGVwKSAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXdoaXRlLzYwXCI+XG4gICAgICAgICAgQ3VycmVudCBzdGVwOiB7cHJlcGFyZVN0ZXAgfHwgaW5zY3JpYmVTdGVwfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9ICovfVxuICAgICAgey8qIHsocHJlcGFyZUVycm9yIHx8IGluc2NyaWJlRXJyb3IpICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtcmVkLTUwMFwiPlxuICAgICAgICAgIEVycm9yOiB7cHJlcGFyZUVycm9yIHx8IGluc2NyaWJlRXJyb3J9XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17cHJlcGFyZUVycm9yID8gY2xlYXJQcmVwYXJlRXJyb3IgOiBjbGVhckluc2NyaWJlRXJyb3J9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtbC0yIHRleHQtYmx1ZS01MDBcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIENsZWFyXG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX0gKi99XG4gICAgPC9tb3Rpb24uZGl2PlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSBcIi4uL3VpL0J1dHRvblwiO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvV2FsbGV0Q29udGV4dFwiO1xuaW1wb3J0IHsgV2FsbGV0TWVudSB9IGZyb20gXCIuL1dhbGxldE1lbnVcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29ubmVjdFdhbGxldCgpOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICBjb25zdCB7IG9wZW5NZW51LCBkZWZhdWx0V2FsbGV0IH0gPSB1c2VXYWxsZXQoKTtcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8QnV0dG9uIG9uQ2xpY2s9e29wZW5NZW51fSBhbmltYXRlPXtmYWxzZX0+XG4gICAgICAgIHtkZWZhdWx0V2FsbGV0ID8gYENvbm5lY3RlZCB0byAke2RlZmF1bHRXYWxsZXR9YCA6IFwiQ29ubmVjdCBXYWxsZXRcIn1cbiAgICAgIDwvQnV0dG9uPlxuICAgIDwvPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5pbnRlcmZhY2UgQ2xvc2VJY29uUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjb25zdCBDbG9zZUljb25TZWNvbmRhcnk6IFJlYWN0LkZDPENsb3NlSWNvblByb3BzPiA9ICh7IGNsYXNzTmFtZSB9KSA9PiB7XG4gIHJldHVybiAoXG4gICAgPHN2Z1xuICAgICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgICB3aWR0aD1cIjMwXCJcbiAgICAgIGhlaWdodD1cIjMwXCJcbiAgICAgIHZpZXdCb3g9XCIwIDAgMjAgMjBcIlxuICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWV9XG4gICAgPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0xOC4wNTUzIDAuMzMzODMxQzE4LjUwMDIgLTAuMTExMDQ3IDE5LjIyMTUgLTAuMTExMDQ3IDE5LjY2NjMgMC4zMzM4M0MyMC4xMTEyIDAuNzc4NzA4IDIwLjExMTIgMS41IDE5LjY2NjMgMS45NDQ4N0wxLjk0NDg2IDE5LjY2NjRDMS40OTk5OCAyMC4xMTEyIDAuNzc4Njk1IDIwLjExMTIgMC4zMzM4MTggMTkuNjY2NEMtMC4xMTEwNTkgMTkuMjIxNSAtMC4xMTEwNTkgMTguNTAwMiAwLjMzMzgxOCAxOC4wNTUzTDE4LjA1NTMgMC4zMzM4MzFaXCJcbiAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAvPlxuICAgICAgPHBhdGhcbiAgICAgICAgZD1cIk0wLjMzMzY1OCAxLjk0NDdDLTAuMTExMjE5IDEuNDk5ODIgLTAuMTExMjIgMC43Nzg1MzUgMC4zMzM2NTggMC4zMzM2NThDMC43Nzg1MzUgLTAuMTExMjE5IDEuNDk5ODIgLTAuMTExMjE5IDEuOTQ0NyAwLjMzMzY1OEwxOS42NjYyIDE4LjA1NTFDMjAuMTExMSAxOC41IDIwLjExMTEgMTkuMjIxMyAxOS42NjYyIDE5LjY2NjJDMTkuMjIxMyAyMC4xMTExIDE4LjUgMjAuMTExMSAxOC4wNTUxIDE5LjY2NjJMMC4zMzM2NTggMS45NDQ3WlwiXG4gICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgLz5cbiAgICA8L3N2Zz5cbiAgKTtcbn07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBtb3Rpb24sIEFuaW1hdGVQcmVzZW5jZSB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tIFwiLi4vLi4vY29udGV4dC9XYWxsZXRDb250ZXh0XCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiLi4vdWkvQnV0dG9uXCI7XG5pbXBvcnQgeyBDbG9zZUljb25TZWNvbmRhcnkgfSBmcm9tIFwiLi4vLi4vaWNvbnMvQ2xvc2VJY29uU2Vjb25kYXJ5XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBXYWxsZXRNZW51KCk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBjb25zdCB7XG4gICAgaXNNZW51T3BlbixcbiAgICBjbG9zZU1lbnUsXG4gICAgd2FsbGV0cyxcbiAgICBjb25uZWN0ZWRXYWxsZXRzLFxuICAgIGRlZmF1bHRXYWxsZXQsXG4gICAgY29ubmVjdFdhbGxldCxcbiAgICBkaXNjb25uZWN0V2FsbGV0LFxuICAgIHNldERlZmF1bHRXYWxsZXQsXG4gICAgaW5zdGFsbGVkV2FsbGV0cyxcbiAgfSA9IHVzZVdhbGxldCgpO1xuXG4gIGNvbnN0IGF2YWlsYWJsZVdhbGxldHMgPSBPYmplY3QuZW50cmllcyh3YWxsZXRzKS5maWx0ZXIoXG4gICAgKFtrZXksIF9dKSA9PlxuICAgICAgaW5zdGFsbGVkV2FsbGV0cy5pbmNsdWRlcyhrZXkpICYmXG4gICAgICAhY29ubmVjdGVkV2FsbGV0cy5zb21lKCh3KSA9PiB3Lm5hbWUudG9Mb3dlckNhc2UoKSA9PT0ga2V5KVxuICApO1xuXG4gIGNvbnN0IHdhbGxldHNUb0luc3RhbGwgPSBPYmplY3QuZW50cmllcyh3YWxsZXRzKS5maWx0ZXIoXG4gICAgKFtrZXksIF9dKSA9PiAhaW5zdGFsbGVkV2FsbGV0cy5pbmNsdWRlcyhrZXkpXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICA8QW5pbWF0ZVByZXNlbmNlPlxuICAgICAge2lzTWVudU9wZW4gJiYgKFxuICAgICAgICA8PlxuICAgICAgICAgIDxtb3Rpb24uZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJmaXhlZCBpbnNldC0wICBiYWNrZHJvcC1ibHVyLVsycHhdIHotNDBcIlxuICAgICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gICAgICAgICAgICBhbmltYXRlPXt7IG9wYWNpdHk6IDEgfX1cbiAgICAgICAgICAgIGV4aXQ9e3sgb3BhY2l0eTogMCB9fVxuICAgICAgICAgICAgb25DbGljaz17Y2xvc2VNZW51fVxuICAgICAgICAgIC8+XG4gICAgICAgICAgPG1vdGlvbi5kaXZcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cImZpeGVkIHRvcC0wIHJpZ2h0LTAgaC1mdWxsIHctZnVsbCBtYXgtdy1tZCBiZy13aGl0ZS8xMCBiYWNrZHJvcC1ibHVyLXhsIHAtNiB6LTUwIHRleHQtd2hpdGUgb3ZlcmZsb3cteS1hdXRvXCJcbiAgICAgICAgICAgIGluaXRpYWw9e3sgeDogXCIxMDAlXCIgfX1cbiAgICAgICAgICAgIGFuaW1hdGU9e3sgeDogMCB9fVxuICAgICAgICAgICAgZXhpdD17eyB4OiBcIjEwMCVcIiB9fVxuICAgICAgICAgICAgdHJhbnNpdGlvbj17eyB0eXBlOiBcInNwcmluZ1wiLCBkYW1waW5nOiAyMCwgc3RpZmZuZXNzOiAxMDAgfX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImgtZnVsbCBmbGV4IGZsZXgtY29sXCI+XG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIG1iLTJcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtWzJyZW1dIGZvbnQtbWVkaXVtXCI+Q29ubmVjdCB3YWxsZXQ8L2Rpdj5cbiAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICB2YXJpYW50PVwiZ2hvc3RcIlxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicC0xIGhvdmVyOmJnLXdoaXRlLzEwIHJvdW5kZWQtZnVsbFwiXG4gICAgICAgICAgICAgICAgICBvbkNsaWNrPXtjbG9zZU1lbnV9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPENsb3NlSWNvblNlY29uZGFyeSBjbGFzc05hbWU9XCJ3LTYgaC02XCIgLz5cbiAgICAgICAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwiIXRleHQtc20gIXRleHQtbGlnaHQgIW1iLTZcIj5cbiAgICAgICAgICAgICAgICBCeSBjb25uZWN0aW5nIHlvdXIgd2FsbGV0IHlvdSBhZ3JlZSB0byBvdXJ7XCIgXCJ9XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzc05hbWU9XCIhdGV4dC1saWdodCB1bmRlcmxpbmVcIj5cbiAgICAgICAgICAgICAgICAgIFRlcm1zXG4gICAgICAgICAgICAgICAgPC9hPntcIiBcIn1cbiAgICAgICAgICAgICAgICBhbmR7XCIgXCJ9XG4gICAgICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzc05hbWU9XCIhdGV4dC1saWdodCB1bmRlcmxpbmVcIj5cbiAgICAgICAgICAgICAgICAgIFByaXZhY3kgUG9saWN5XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIC5cbiAgICAgICAgICAgICAgPC9wPlxuXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwib3ZlcmZsb3cteS1hdXRvIGZsZXggZmxleC1jb2wgZ2FwLThcIj5cbiAgICAgICAgICAgICAgICB7LyogQ29ubmVjdGVkIFdhbGxldHMgU2VjdGlvbiAqL31cbiAgICAgICAgICAgICAgICB7Y29ubmVjdGVkV2FsbGV0cy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LW1lZGl1bSBtYi0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgQ29ubmVjdGVkIHdhbGxldHNcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAge2Nvbm5lY3RlZFdhbGxldHMubWFwKChjb25uZWN0ZWRXYWxsZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldHNbY29ubmVjdGVkV2FsbGV0Lm5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0RlZmF1bHQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0V2FsbGV0Py50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0ZWRXYWxsZXQubmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXtjb25uZWN0ZWRXYWxsZXQubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e2B3LWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHAtMyByb3VuZGVkLXhsIHRyYW5zaXRpb24tY29sb3JzICR7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0RlZmF1bHQgPyBcImJnLWJsdWUtNTAwLzIwXCIgOiBcImJnLXdoaXRlLzVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1gfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTggaC04IGJnLXdoaXRlLzEwIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXt3YWxsZXQuaWNvbiB8fCBcIi9wbGFjZWhvbGRlci5zdmdcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9e3dhbGxldC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctNSBoLTVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Bhbj57d2FsbGV0Lm5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHshaXNEZWZhdWx0ICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhbnQ9XCJnaG9zdFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC1zbSBob3ZlcjpiZy13aGl0ZS8xMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0RGVmYXVsdFdhbGxldCh3YWxsZXQubmFtZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYWtlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwiZ2hvc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtcmVkLTQwMCBob3ZlcjpiZy1yZWQtNTAwLzEwICFoaWRkZW5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBkaXNjb25uZWN0V2FsbGV0KHdhbGxldC5uYW1lKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRGlzY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuXG4gICAgICAgICAgICAgICAgey8qIEluc3RhbGxlZCBidXQgbm90IGNvbm5lY3RlZCBXYWxsZXRzIFNlY3Rpb24gKi99XG4gICAgICAgICAgICAgICAge2F2YWlsYWJsZVdhbGxldHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1tZWRpdW0gbWItM1wiPlxuICAgICAgICAgICAgICAgICAgICAgIEF2YWlsYWJsZSB3YWxsZXRzXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInNwYWNlLXktMlwiPlxuICAgICAgICAgICAgICAgICAgICAgIHthdmFpbGFibGVXYWxsZXRzLm1hcCgoW2tleSwgd2FsbGV0XSkgPT4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2tleX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwLTMgYmctd2hpdGUvNSBob3ZlcjpiZy13aGl0ZS8xMCByb3VuZGVkLXhsIHRyYW5zaXRpb24tY29sb3JzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy04IGgtOCBiZy13aGl0ZS8xMCByb3VuZGVkLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjPXt3YWxsZXQuaWNvbiB8fCBcIi9wbGFjZWhvbGRlci5zdmdcIn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PXt3YWxsZXQubmFtZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy01IGgtNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnt3YWxsZXQubmFtZX08L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyaWFudD1cImdob3N0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXNtIGhvdmVyOmJnLXdoaXRlLzEwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBjb25uZWN0V2FsbGV0KHdhbGxldC5uYW1lKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzVGV4dD1cIkNvbm5lY3RlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25uZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgKX1cblxuICAgICAgICAgICAgICAgIHsvKiBOb3QgSW5zdGFsbGVkIFdhbGxldHMgU2VjdGlvbiAqL31cbiAgICAgICAgICAgICAgICB7d2FsbGV0c1RvSW5zdGFsbC5sZW5ndGggPiAwICYmIChcbiAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14bCBmb250LW1lZGl1bSBtYi0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgU2VsZWN0IGEgd2FsbGV0IHRvIGluc3RhbGxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAge3dhbGxldHNUb0luc3RhbGwubWFwKChba2V5LCB3YWxsZXRdKSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGtleT17a2V5fVxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIHAtMyBiZy13aGl0ZS81IGhvdmVyOmJnLXdoaXRlLzEwIHJvdW5kZWQteGwgdHJhbnNpdGlvbi1jb2xvcnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIGdhcC0zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LTggaC04IGJnLXdoaXRlLzEwIHJvdW5kZWQtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGltZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3dhbGxldC5pY29uIHx8IFwiL3BsYWNlaG9sZGVyLnN2Z1wifVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ9e3dhbGxldC5uYW1lfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTUgaC01XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+e3dhbGxldC5uYW1lfTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJpYW50PVwiZ2hvc3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtc20gaG92ZXI6Ymctd2hpdGUvMTBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eyhlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9wZW4od2FsbGV0LnVybCwgXCJfYmxhbmtcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEluc3RhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvbW90aW9uLmRpdj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICApO1xufVxuIiwiLy8gc3JjL3V0aWxzL2RlY29kZXIudHNcbi8vIE5vIG5lZWQgZm9yIFdBU0kgaW1wb3J0cyBhbnltb3JlXG5cbi8qKlxuICogVHlwZSBkZWZpbml0aW9uIGZvciB0aGUgV0FTTSBpbnN0YW5jZSB3aXRoIGV4cG9ydGVkIGZ1bmN0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFdhc21EZWNvZGVySW5zdGFuY2Uge1xuICBleHBvcnRzOiB7XG4gICAgbWVtb3J5OiBXZWJBc3NlbWJseS5NZW1vcnk7XG4gICAgaHNfaW5pdDogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiB2b2lkO1xuICAgIGhzX2V4aXQ6ICgpID0+IHZvaWQ7XG4gICAgbWFsbG9jX2J5dGVzX2hzOiAoc2l6ZTogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgZnJlZV9oczogKHB0cjogbnVtYmVyKSA9PiB2b2lkO1xuICAgIHJlY29uc3RydWN0T3JpZ2luYWxCeXRlc0M6IChjb3VudDogbnVtYmVyLCBwdHJBcnJheTogbnVtYmVyKSA9PiBudW1iZXI7XG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgV0FTTSBkZWNvZGVyIGJ5IGZldGNoaW5nIGFuZCBpbnN0YW50aWF0aW5nIHRoZSBXQVNNIG1vZHVsZVxuICogQHBhcmFtIHdhc21Nb2R1bGVVcmwgT3B0aW9uYWwgVVJMIHRvIHRoZSBXQVNNIG1vZHVsZSwgZGVmYXVsdHMgdG8gdGhlIFMzIFVSTFxuICogQHJldHVybnMgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGluc3RhbnRpYXRlZCBXQVNNIG1vZHVsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZVdhc21EZWNvZGVyKHdhc21Nb2R1bGVVcmw/OiBzdHJpbmcpOiBQcm9taXNlPHsgd2FzbUluc3RhbmNlOiBXYXNtRGVjb2Rlckluc3RhbmNlIH0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB3YXNtVXJsID0gd2FzbU1vZHVsZVVybCB8fCAnaHR0cHM6Ly9tZXRhZGF0YS1kZWNvZGVyLXdhc20uczMudXMtZWFzdC0xLmFtYXpvbmF3cy5jb20vd2FzbS1kZWNvZGVyLndhc20nO1xuICAgIGNvbnNvbGUubG9nKFwiTG9hZGluZyBXQVNNIGZyb20gVVJMOlwiLCB3YXNtVXJsKTtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgdGhlIHN0cmVhbWluZyBhcHByb2FjaFxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHdhc21VcmwpO1xuICAgICAgY29uc29sZS5sb2coXCJSZXNwb25zZTpcIiwgcmVzcG9uc2UpO1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlc3BvbnNlIGlzIG9rXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gVHJ5IGNvbXBpbGVTdHJlYW1pbmcgZmlyc3QgKG1vcmUgZWZmaWNpZW50KVxuICAgICAgY29uc3QgY29tcGlsZWRXYXNtRGVjb2RlciA9IGF3YWl0IFdlYkFzc2VtYmx5LmNvbXBpbGVTdHJlYW1pbmcocmVzcG9uc2UpO1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgYSBkeW5hbWljIFdBU0kgaW1wb3J0IG9iamVjdCB3aXRoIGEgUHJveHlcbiAgICAgIC8vIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGhhbmRsZSBhbnkgV0FTSSBmdW5jdGlvbiB0aGF0IHRoZSBtb2R1bGUgcmVxdWlyZXNcbiAgICAgIGNvbnN0IHdhc2lIYW5kbGVyID0ge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKHRhcmdldDogYW55LCBwcm9wOiBzdHJpbmcpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgYWxyZWFkeSBleGlzdHMsIHJldHVybiBpdFxuICAgICAgICAgIGlmIChwcm9wIGluIHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBjcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgMCAoc3VjY2VzcyBpbiBXQVNJKVxuICAgICAgICAgIGNvbnNvbGUubG9nKGBBdXRvLWNyZWF0aW5nIFdBU0kgZnVuY3Rpb246ICR7cHJvcH1gKTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDYWxsZWQgYXV0by1jcmVhdGVkIFdBU0kgZnVuY3Rpb246ICR7cHJvcH0gd2l0aCAke2FyZ3MubGVuZ3RofSBhcmdzYCk7XG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gUmV0dXJuIHN1Y2Nlc3MgZm9yIGFueSBmdW5jdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIEJhc2UgV0FTSSBmdW5jdGlvbnMgd2l0aCBleHBsaWNpdCBpbXBsZW1lbnRhdGlvbnNcbiAgICAgIGNvbnN0IGJhc2VXYXNpID0ge1xuICAgICAgICBwcm9jX2V4aXQ6IChjb2RlOiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgcHJvY19leGl0IGNhbGxlZCB3aXRoIGNvZGU6ICR7Y29kZX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmRfd3JpdGU6IChmZDogbnVtYmVyLCBpb3ZzOiBudW1iZXIsIGlvdnNMZW46IG51bWJlciwgbndyaXR0ZW46IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBmZF93cml0ZSBjYWxsZWQ6IGZkPSR7ZmR9LCBpb3ZzPSR7aW92c30sIGlvdnNMZW49JHtpb3ZzTGVufSwgbndyaXR0ZW49JHtud3JpdHRlbn1gKTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRoZSBpbXBvcnQgb2JqZWN0IHdpdGggYSBQcm94eSBmb3Igd2FzaV9zbmFwc2hvdF9wcmV2aWV3MVxuICAgICAgY29uc3QgaW1wb3J0T2JqZWN0ID0ge1xuICAgICAgICB3YXNpX3NuYXBzaG90X3ByZXZpZXcxOiBuZXcgUHJveHkoYmFzZVdhc2ksIHdhc2lIYW5kbGVyKVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgY29uc3Qgd2FzbUluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoY29tcGlsZWRXYXNtRGVjb2RlciwgaW1wb3J0T2JqZWN0KTtcbiAgICAgIGNvbnNvbGUubG9nKFwiV0FTTSBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkgdmlhIHN0cmVhbWluZ1wiKTtcbiAgICAgIHJldHVybiB7IHdhc21JbnN0YW5jZTogd2FzbUluc3RhbmNlIGFzIHVua25vd24gYXMgV2FzbURlY29kZXJJbnN0YW5jZSB9O1xuICAgIH0gY2F0Y2ggKHN0cmVhbWluZ0Vycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJTdHJlYW1pbmcgY29tcGlsYXRpb24gZmFpbGVkLCBmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgYXBwcm9hY2g6XCIsIHN0cmVhbWluZ0Vycm9yKTtcbiAgICAgIFxuICAgICAgLy8gRmFsbGJhY2sgdG8gQXJyYXlCdWZmZXIgYXBwcm9hY2ggaWYgc3RyZWFtaW5nIGZhaWxzXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHdhc21VcmwpO1xuICAgICAgY29uc29sZS5sb2coXCJSZXNwb25zZTpcIiwgcmVzcG9uc2UpO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHdhc21CeXRlcyA9IGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICBjb25zdCB3YXNtTW9kdWxlID0gYXdhaXQgV2ViQXNzZW1ibHkuY29tcGlsZSh3YXNtQnl0ZXMpO1xuICAgICAgXG4gICAgICAvLyBSZXVzZSB0aGUgc2FtZSBkeW5hbWljIFdBU0kgaGFuZGxlciBhcHByb2FjaFxuICAgICAgY29uc3Qgd2FzaUhhbmRsZXIgPSB7XG4gICAgICAgIGdldDogZnVuY3Rpb24odGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZykge1xuICAgICAgICAgIC8vIElmIHRoZSBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0cywgcmV0dXJuIGl0XG4gICAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBPdGhlcndpc2UsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyAwIChzdWNjZXNzIGluIFdBU0kpXG4gICAgICAgICAgY29uc29sZS5sb2coYEF1dG8tY3JlYXRpbmcgV0FTSSBmdW5jdGlvbjogJHtwcm9wfWApO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiguLi5hcmdzOiBhbnlbXSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYENhbGxlZCBhdXRvLWNyZWF0ZWQgV0FTSSBmdW5jdGlvbjogJHtwcm9wfSB3aXRoICR7YXJncy5sZW5ndGh9IGFyZ3NgKTtcbiAgICAgICAgICAgIHJldHVybiAwOyAvLyBSZXR1cm4gc3VjY2VzcyBmb3IgYW55IGZ1bmN0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQmFzZSBXQVNJIGZ1bmN0aW9ucyB3aXRoIGV4cGxpY2l0IGltcGxlbWVudGF0aW9uc1xuICAgICAgY29uc3QgYmFzZVdhc2kgPSB7XG4gICAgICAgIHByb2NfZXhpdDogKGNvZGU6IG51bWJlcikgPT4ge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBwcm9jX2V4aXQgY2FsbGVkIHdpdGggY29kZTogJHtjb2RlfWApO1xuICAgICAgICB9LFxuICAgICAgICBmZF93cml0ZTogKGZkOiBudW1iZXIsIGlvdnM6IG51bWJlciwgaW92c0xlbjogbnVtYmVyLCBud3JpdHRlbjogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5sb2coYGZkX3dyaXRlIGNhbGxlZDogZmQ9JHtmZH0sIGlvdnM9JHtpb3ZzfSwgaW92c0xlbj0ke2lvdnNMZW59LCBud3JpdHRlbj0ke253cml0dGVufWApO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBDcmVhdGUgdGhlIGltcG9ydCBvYmplY3Qgd2l0aCBhIFByb3h5IGZvciB3YXNpX3NuYXBzaG90X3ByZXZpZXcxXG4gICAgICBjb25zdCBpbXBvcnRPYmplY3QgPSB7XG4gICAgICAgIHdhc2lfc25hcHNob3RfcHJldmlldzE6IG5ldyBQcm94eShiYXNlV2FzaSwgd2FzaUhhbmRsZXIpXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zdCB3YXNtSW5zdGFuY2UgPSBhd2FpdCBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZSh3YXNtTW9kdWxlLCBpbXBvcnRPYmplY3QpO1xuICAgICAgY29uc29sZS5sb2coXCJXQVNNIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseSB2aWEgQXJyYXlCdWZmZXJcIik7XG4gICAgICByZXR1cm4geyB3YXNtSW5zdGFuY2U6IHdhc21JbnN0YW5jZSBhcyB1bmtub3duIGFzIFdhc21EZWNvZGVySW5zdGFuY2UgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIldBU00gaW5pdGlhbGl6YXRpb24gZmFpbGVkOlwiLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoZXhhZGVjaW1hbCBzdHJpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRIZXhTdHJpbmcoaGV4OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRydWU7XG4gIHJldHVybiAvXlswLTlBLUZhLWZdKiQvLnRlc3QoaGV4KTtcbn1cblxuLyoqXG4gKiBQdXJlIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gZm9yIHJlY29uc3RydWN0aW5nIGJ5dGVzIGZyb20gaGV4IHN0cmluZ3NcbiAqIFRoaXMgaXMgdXNlZCBhcyBhIGZhbGxiYWNrIHdoZW4gV0FTTSBpbml0aWFsaXphdGlvbiBmYWlsc1xuICovXG5mdW5jdGlvbiBoZXhUb0J5dGVzKGhleDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIC8vIFJlbW92ZSBhbnkgbm9uLWhleCBjaGFyYWN0ZXJzIChsaWtlIHNwYWNlcyBvciBsaW5lIGJyZWFrcylcbiAgaGV4ID0gaGV4LnJlcGxhY2UoL1teMC05QS1GYS1mXS9nLCAnJyk7XG4gIFxuICAvLyBFbnN1cmUgd2UgaGF2ZSBhbiBldmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzXG4gIGlmIChoZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgIGhleCA9ICcwJyArIGhleDtcbiAgfVxuICBcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShoZXgubGVuZ3RoIC8gMik7XG4gIFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgIGJ5dGVzW2kgLyAyXSA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoaSwgaSArIDIpLCAxNik7XG4gIH1cbiAgXG4gIHJldHVybiBieXRlcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGJhc2U2NCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0Jhc2U2NChieXRlczogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGNvbnN0IGJpblN0cmluZyA9IEFycmF5LmZyb20oYnl0ZXMpXG4gICAgLm1hcChieXRlID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZSkpXG4gICAgLmpvaW4oJycpO1xuICBcbiAgcmV0dXJuIGJ0b2EoYmluU3RyaW5nKTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgdGhlIG9yaWdpbmFsIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgaGV4IHN0cmluZ3NcbiAqIEZpcnN0IHRyaWVzIHRvIHVzZSB0aGUgV0FTTSBpbXBsZW1lbnRhdGlvbiwgZmFsbHMgYmFjayB0byBwdXJlIEpTIGlmIHRoYXQgZmFpbHNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlY29uc3RydWN0T3JpZ2luYWxCeXRlcyhcbiAgd0luc3RhbmNlOiBXYXNtRGVjb2Rlckluc3RhbmNlIHwgbnVsbCxcbiAgaGV4U3RyaW5nQXJyYXk6IHN0cmluZ1tdXG4pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zb2xlLmxvZygnUmVjb25zdHJ1Y3RpbmcgYnl0ZXMgZnJvbSBoZXggc3RyaW5nczonLCBoZXhTdHJpbmdBcnJheSk7XG4gIFxuICB0cnkge1xuICAgIC8vIFZhbGlkYXRlIGhleCBzdHJpbmdzXG4gICAgY29uc3QgdmFsaWRIZXhTdHJpbmdzID0gaGV4U3RyaW5nQXJyYXkuZmlsdGVyKGhleCA9PiBpc1ZhbGlkSGV4U3RyaW5nKGhleCkpO1xuICAgIGlmICh2YWxpZEhleFN0cmluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbGlkIGhleCBzdHJpbmdzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIFxuICAgIGNvbnNvbGUubG9nKCdWYWxpZCBoZXggc3RyaW5nczonLCB2YWxpZEhleFN0cmluZ3MpO1xuICAgIFxuICAgIC8vIFRyeSBXQVNNIGltcGxlbWVudGF0aW9uIGZpcnN0IGlmIGF2YWlsYWJsZVxuICAgIGlmICh3SW5zdGFuY2UgJiYgd0luc3RhbmNlLmV4cG9ydHMgJiYgd0luc3RhbmNlLmV4cG9ydHMubWVtb3J5KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zb2xlLmxvZygnQXR0ZW1wdGluZyB0byB1c2UgV0FTTSBpbXBsZW1lbnRhdGlvbi4uLicpO1xuICAgICAgICBcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgSGFza2VsbCBydW50aW1lXG4gICAgICAgIHdJbnN0YW5jZS5leHBvcnRzLmhzX2luaXQoMCwgMCk7XG4gICAgICAgIFxuICAgICAgICBsZXQgaGV4U3RyaW5nUHRyczogbnVtYmVyW10gPSBbXTtcbiAgICAgICAgbGV0IGhleFN0cmluZ0FycmF5UHRyQWRkciA9IDA7XG4gICAgICAgIGxldCBiYXNlNjRQdHIgPSAwO1xuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBBbGxvY2F0ZSBhbmQgd3JpdGUgZWFjaCBoZXggc3RyaW5nIHRvIFdBU00gbWVtb3J5XG4gICAgICAgICAgaGV4U3RyaW5nUHRycyA9IHZhbGlkSGV4U3RyaW5ncy5tYXAoc3RyID0+IHdyaXRlQ1N0cmluZyhzdHIsIHdJbnN0YW5jZSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeSBmb3IgdGhlIGFycmF5IG9mIHBvaW50ZXJzXG4gICAgICAgICAgaGV4U3RyaW5nQXJyYXlQdHJBZGRyID0gd0luc3RhbmNlLmV4cG9ydHMubWFsbG9jX2J5dGVzX2hzKGhleFN0cmluZ1B0cnMubGVuZ3RoICogNCk7IC8vIDQgYnl0ZXMgcGVyIHBvaW50ZXJcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBXcml0ZSB0aGUgYXJyYXkgb2YgcG9pbnRlcnMgdG8gV0FTTSBtZW1vcnlcbiAgICAgICAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheSh3SW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyKTtcbiAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KHdJbnN0YW5jZS5leHBvcnRzLm1lbW9yeS5idWZmZXIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGV4U3RyaW5nUHRycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MzIoaGV4U3RyaW5nQXJyYXlQdHJBZGRyICsgaSAqIDQsIGhleFN0cmluZ1B0cnNbaV0sIHRydWUpOyAvLyB0cnVlIGZvciBsaXR0bGUtZW5kaWFuXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENhbGwgdGhlIFdBU00gZnVuY3Rpb24gdG8gcmVjb25zdHJ1Y3QgdGhlIGJ5dGVzXG4gICAgICAgICAgY29uc29sZS5sb2coYENhbGxpbmcgcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzQyB3aXRoIGNvdW50PSR7aGV4U3RyaW5nUHRycy5sZW5ndGh9LCBwdHJBcnJheT0ke2hleFN0cmluZ0FycmF5UHRyQWRkcn1gKTtcbiAgICAgICAgICBiYXNlNjRQdHIgPSB3SW5zdGFuY2UuZXhwb3J0cy5yZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXNDKGhleFN0cmluZ1B0cnMubGVuZ3RoLCBoZXhTdHJpbmdBcnJheVB0ckFkZHIpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmIChiYXNlNjRQdHIgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV0FTTSBmdW5jdGlvbiByZXR1cm5lZCBudWxsIHBvaW50ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gUmVhZCB0aGUgcmVzdWx0IGZyb20gV0FTTSBtZW1vcnlcbiAgICAgICAgICBjb25zdCBiYXNlNjQgPSByZWFkQ1N0cmluZyh3SW5zdGFuY2UuZXhwb3J0cy5tZW1vcnkuYnVmZmVyLCBiYXNlNjRQdHIpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgcmVjb25zdHJ1Y3RlZCBieXRlcywgYmFzZTY0IGxlbmd0aDogJHtiYXNlNjQubGVuZ3RofWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZyZWUgdGhlIGFsbG9jYXRlZCBtZW1vcnlcbiAgICAgICAgICB3SW5zdGFuY2UuZXhwb3J0cy5mcmVlX2hzKGJhc2U2NFB0cik7XG4gICAgICAgICAgd0luc3RhbmNlLmV4cG9ydHMuZnJlZV9ocyhoZXhTdHJpbmdBcnJheVB0ckFkZHIpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEZyZWUgaW5kaXZpZHVhbCBoZXggc3RyaW5nc1xuICAgICAgICAgIGhleFN0cmluZ1B0cnMuZm9yRWFjaChwdHIgPT4ge1xuICAgICAgICAgICAgaWYgKHB0ciAhPT0gMCkgd0luc3RhbmNlLmV4cG9ydHMuZnJlZV9ocyhwdHIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNodXQgZG93biB0aGUgSGFza2VsbCBydW50aW1lXG4gICAgICAgICAgd0luc3RhbmNlLmV4cG9ydHMuaHNfZXhpdCgpO1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyRXJyb3I6IGFueSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZHVyaW5nIFdBU00gZXhlY3V0aW9uOicsIGlubmVyRXJyb3IpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENsZWFuIHVwIGFueSBhbGxvY2F0ZWQgbWVtb3J5IGlmIHBvc3NpYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChiYXNlNjRQdHIgIT09IDApIHdJbnN0YW5jZS5leHBvcnRzLmZyZWVfaHMoYmFzZTY0UHRyKTtcbiAgICAgICAgICAgIGlmIChoZXhTdHJpbmdBcnJheVB0ckFkZHIgIT09IDApIHdJbnN0YW5jZS5leHBvcnRzLmZyZWVfaHMoaGV4U3RyaW5nQXJyYXlQdHJBZGRyKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gRnJlZSBpbmRpdmlkdWFsIGhleCBzdHJpbmdzXG4gICAgICAgICAgICBoZXhTdHJpbmdQdHJzLmZvckVhY2gocHRyID0+IHtcbiAgICAgICAgICAgICAgaWYgKHB0ciAhPT0gMCkgd0luc3RhbmNlLmV4cG9ydHMuZnJlZV9ocyhwdHIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNodXQgZG93biB0aGUgSGFza2VsbCBydW50aW1lXG4gICAgICAgICAgICB3SW5zdGFuY2UuZXhwb3J0cy5oc19leGl0KCk7XG4gICAgICAgICAgfSBjYXRjaCAoY2xlYW51cEVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGR1cmluZyBjbGVhbnVwOicsIGNsZWFudXBFcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHRocm93IGlubmVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHdhc21FcnJvcjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV0FTTSBpbXBsZW1lbnRhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUzonLCB3YXNtRXJyb3IpO1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gSlMgaW1wbGVtZW50YXRpb25cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gSmF2YVNjcmlwdCBmYWxsYmFjayBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnNvbGUubG9nKCdVc2luZyBKYXZhU2NyaXB0IGZhbGxiYWNrIGltcGxlbWVudGF0aW9uJyk7XG4gICAgXG4gICAgLy8gQ29uY2F0ZW5hdGUgYWxsIGhleCBzdHJpbmdzXG4gICAgY29uc3QgY29tYmluZWRIZXggPSB2YWxpZEhleFN0cmluZ3Muam9pbignJyk7XG4gICAgY29uc29sZS5sb2coJ0NvbWJpbmVkIGhleDonLCBjb21iaW5lZEhleCk7XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBieXRlc1xuICAgIGNvbnN0IGJ5dGVzID0gaGV4VG9CeXRlcyhjb21iaW5lZEhleCk7XG4gICAgY29uc29sZS5sb2coJ0NvbnZlcnRlZCB0byBieXRlcywgbGVuZ3RoOicsIGJ5dGVzLmxlbmd0aCk7XG4gICAgXG4gICAgLy8gQ29udmVydCB0byBiYXNlNjRcbiAgICBjb25zdCBiYXNlNjQgPSBieXRlc1RvQmFzZTY0KGJ5dGVzKTtcbiAgICBjb25zb2xlLmxvZygnQ29udmVydGVkIHRvIGJhc2U2NCwgbGVuZ3RoOicsIGJhc2U2NC5sZW5ndGgpO1xuICAgIFxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiByZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlY29uc3RydWN0IGJ5dGVzOiAke2Vycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlcjogUmVhZCBhIG51bGwtdGVybWluYXRlZCBDIHN0cmluZyBmcm9tIFdBU00gbWVtb3J5XG4gKi9cbmZ1bmN0aW9uIHJlYWRDU3RyaW5nKG1lbW9yeTogQXJyYXlCdWZmZXIsIHB0cjogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKCFtZW1vcnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01lbW9yeSBidWZmZXIgaXMgdW5kZWZpbmVkIGluIHJlYWRDU3RyaW5nJyk7XG4gIH1cbiAgXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coYFJlYWRpbmcgQyBzdHJpbmcgZnJvbSBtZW1vcnkgYXQgcG9pbnRlcjogJHtwdHJ9YCk7XG4gICAgY29uc29sZS5sb2coYE1lbW9yeSBidWZmZXIgc2l6ZTogJHttZW1vcnkuYnl0ZUxlbmd0aH1gKTtcbiAgICBcbiAgICBjb25zdCBtZW0gPSBuZXcgVWludDhBcnJheShtZW1vcnkpO1xuICAgIGxldCBlbmQgPSBwdHI7XG4gICAgY29uc3QgbWVtTGVuZ3RoID0gbWVtLmxlbmd0aDtcbiAgICBcbiAgICAvLyBDaGVjayBmb3Igb3V0LW9mLWJvdW5kcyBhY2Nlc3NcbiAgICBpZiAocHRyID49IG1lbUxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGByZWFkQ1N0cmluZzogUG9pbnRlciAke3B0cn0gaXMgb3V0c2lkZSBXQVNNIG1lbW9yeSBib3VuZHMuYCk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBudWxsIHRlcm1pbmF0b3IsIGJ1dCBzdG9wIGF0IG1lbW9yeSBib3VuZGFyeVxuICAgIHdoaWxlIChlbmQgPCBtZW1MZW5ndGggJiYgbWVtW2VuZF0gIT09IDApIHtcbiAgICAgIGVuZCsrO1xuICAgIH0gICAgXG4gICAgaWYgKGVuZCA+PSBtZW0ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyZWFkQ1N0cmluZzogVW50ZXJtaW5hdGVkIHN0cmluZyAobm8gbnVsbCBieXRlIGZvdW5kKS5cIik7XG4gICAgfVxuXG4gICAgLy8gRGVjb2RlIHRoZSBzdHJpbmdcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUobWVtLnN1YmFycmF5KHB0ciwgZW5kKSk7XG4gICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSByZWFkIHN0cmluZyBvZiBsZW5ndGggJHtlbmQgLSBwdHJ9YCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIHJlYWRDU3RyaW5nOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIHJlYWRDU3RyaW5nOiAke2Vycm9yLm1lc3NhZ2UgfHwgU3RyaW5nKGVycm9yKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlcjogV3JpdGUgYSBKUyBzdHJpbmcgdG8gV0FTTSBtZW1vcnkgKHJldHVybnMgcG9pbnRlcilcbiAqL1xuZnVuY3Rpb24gd3JpdGVDU3RyaW5nKHN0cjogc3RyaW5nLCB3SW5zdGFuY2U6IFdhc21EZWNvZGVySW5zdGFuY2UpOiBudW1iZXIge1xuICBpZiAoIXdJbnN0YW5jZSB8fCAhd0luc3RhbmNlLmV4cG9ydHMgfHwgIXdJbnN0YW5jZS5leHBvcnRzLm1lbW9yeSB8fCAhd0luc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1dBU00gaW5zdGFuY2Ugc3RydWN0dXJlOicsIHdJbnN0YW5jZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFdBU00gaW5zdGFuY2Ugc3RydWN0dXJlIGluIHdyaXRlQ1N0cmluZycpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIGNvbnN0IGxlbmd0aE5lZWRlZCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHB0ciA9IHdJbnN0YW5jZS5leHBvcnRzLm1hbGxvY19ieXRlc19ocyhzdHIubGVuZ3RoICsgMSk7ICAvLyArMSBmb3IgbnVsbCB0ZXJtaW5hdG9yXG4gICAgY29uc29sZS5sb2coYEFsbG9jYXRlZCBtZW1vcnkgYXQgcG9pbnRlcjogJHtwdHJ9IGZvciBzdHJpbmcgbGVuZ3RoOiAke3N0ci5sZW5ndGh9YCk7XG4gICAgXG4gICAgY29uc3QgbWVtID0gbmV3IFVpbnQ4QXJyYXkod0luc3RhbmNlLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcik7XG4gICAgY29uc29sZS5sb2coYE1lbW9yeSBidWZmZXIgc2l6ZTogJHttZW0ubGVuZ3RofWApO1xuXG4gICAgLy8gQ2hlY2sgaWYgcG9pbnRlciBpcyB2YWxpZCBhbmQgc3BhY2UgaXMgc3VmZmljaWVudFxuICAgIGlmIChwdHIgKyBsZW5ndGhOZWVkZWQgPj0gbWVtLmxlbmd0aCkge1xuICAgICAgd0luc3RhbmNlLmV4cG9ydHMuZnJlZV9ocyhwdHIpOyAgLy8gQXZvaWQgbGVha2luZyBtZW1vcnlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgd3JpdGVDU3RyaW5nOiBTdHJpbmcgJyR7c3RyfScgZXhjZWVkcyBhbGxvY2F0ZWQgV0FTTSBtZW1vcnkuYCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1lbVtwdHIgKyBpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICBtZW1bcHRyICsgc3RyLmxlbmd0aF0gPSAwOyAgLy8gTnVsbC10ZXJtaW5hdGVcbiAgICByZXR1cm4gcHRyO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gd3JpdGVDU3RyaW5nOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGluIHdyaXRlQ1N0cmluZzogJHtlcnJvci5tZXNzYWdlIHx8IFN0cmluZyhlcnJvcil9YCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXI6IENvbnZlcnQgYmFzZTY0IHN0cmluZyB0byBieXRlIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb0J5dGVzKGJhc2U2NDogc3RyaW5nKTogVWludDhBcnJheSB7XG4gIGNvbnN0IGJpblN0ciA9IGF0b2IoYmFzZTY0KTtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5TdHIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGJpblN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBieXRlcztcbn1cbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG4vLyBJbXBvcnQgZnJvbSBvdXIgbmV3IFR5cGVTY3JpcHQgaW1wbGVtZW50YXRpb25cbmltcG9ydCB7XG4gIGluaXRpYWxpemVXYXNtRGVjb2RlcixcbiAgcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzLFxuICBXYXNtRGVjb2Rlckluc3RhbmNlXG59IGZyb20gXCIuLi8uLi91dGlscy9kZWNvZGVyXCI7XG5cbmV4cG9ydCBjb25zdCBIZXhEZWNvZGVyOiBSZWFjdC5GQyA9ICgpID0+IHtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZShcIlwiKTtcbiAgY29uc3QgW2Zvcm1hdCwgc2V0Rm9ybWF0XSA9IHVzZVN0YXRlPFxuICAgIFwidXRmOFwiIHwgXCJiYXNlNjRcIiB8IFwicG5nXCIgfCBcImpwZWdcIiB8IFwicGRmXCJcbiAgPihcInV0ZjhcIik7XG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3Jlc3VsdCwgc2V0UmVzdWx0XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuXG4gIGNvbnN0IHdhc21JbnN0YW5jZSA9IHVzZVJlZjxXYXNtRGVjb2Rlckluc3RhbmNlIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGxhc3RIZXhJbnB1dCA9IHVzZVJlZjxzdHJpbmc+KFwiXCIpO1xuICBjb25zdCBsYXN0QmFzZTY0ID0gdXNlUmVmPHN0cmluZz4oXCJcIik7XG5cbiAgY29uc3QgaW5pdFdhc20gPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF3YXNtSW5zdGFuY2UuY3VycmVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gTm8gbmVlZCBmb3Igd2FzbVBhdGggcGFyYW1ldGVyIGFueW1vcmVcbiAgICAgICAgY29uc3QgeyB3YXNtSW5zdGFuY2U6IGluc3QgfSA9IGF3YWl0IGluaXRpYWxpemVXYXNtRGVjb2RlcigpO1xuICAgICAgICB3YXNtSW5zdGFuY2UuY3VycmVudCA9IGluc3Q7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0FTTSBkZWNvZGVyIGluaXRpYWxpemVkIHN1Y2Nlc3NmdWxseVwiKTtcbiAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkZhaWxlZCB0byBpbml0aWFsaXplIFdBU00gZGVjb2Rlciwgd2lsbCB1c2UgSlMgZmFsbGJhY2s6XCIsIGVycik7XG4gICAgICAgIC8vIFdlJ2xsIGNvbnRpbnVlIHdpdGhvdXQgYSBXQVNNIGluc3RhbmNlIGFuZCB1c2UgdGhlIEpTIGZhbGxiYWNrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3YXNtSW5zdGFuY2UuY3VycmVudDsgLy8gVGhpcyBtaWdodCBiZSBudWxsLCBidXQgb3VyIGltcGxlbWVudGF0aW9uIGNhbiBoYW5kbGUgaXRcbiAgfTtcblxuICBjb25zdCBkZWNvZGUgPSBhc3luYyAoKSA9PiB7XG4gICAgc2V0RXJyb3IobnVsbCk7XG4gICAgc2V0UmVzdWx0KG51bGwpO1xuICAgIGlmICghaW5wdXQudHJpbSgpKSB7XG4gICAgICBzZXRFcnJvcihcIlBsZWFzZSBwYXN0ZSBzb21lIGhleGFkZWNpbWFsIHN0cmluZ3MgZmlyc3QuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIFdBU00gKG1pZ2h0IHJldHVybiBudWxsIGlmIGluaXRpYWxpemF0aW9uIGZhaWxzKVxuICAgICAgY29uc3QgaW5zdCA9IGF3YWl0IGluaXRXYXNtKCk7XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIGxpbmVzIG9yIEpTT04gYXJyYXlcbiAgICAgIGxldCBoZXhzOiBzdHJpbmdbXTtcbiAgICAgIGNvbnN0IHR4dCA9IGlucHV0LnRyaW0oKTtcbiAgICAgIFxuICAgICAgaWYgKHR4dC5zdGFydHNXaXRoKFwiW1wiKSAmJiB0eHQuZW5kc1dpdGgoXCJdXCIpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgYXJyID0gSlNPTi5wYXJzZSh0eHQpO1xuICAgICAgICAgIGhleHMgPSBBcnJheS5pc0FycmF5KGFycikgPyBhcnIgOiBbU3RyaW5nKGFycildO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBoZXhzID0gdHh0LnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobCkgPT4gbC50cmltKCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZXhzID0gdHh0XG4gICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXG4gICAgICAgICAgLm1hcCgobCkgPT4gbC50cmltKCkpXG4gICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gT25seSBwcm9jZXNzIGlmIGlucHV0IGhhcyBjaGFuZ2VkXG4gICAgICBpZiAodHh0ICE9PSBsYXN0SGV4SW5wdXQuY3VycmVudCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlByb2Nlc3NpbmcgbmV3IGhleCBpbnB1dFwiKTtcbiAgICAgICAgLy8gT3VyIHJlY29uc3RydWN0T3JpZ2luYWxCeXRlcyBmdW5jdGlvbiBjYW4gbm93IGhhbmRsZSBhIG51bGwgV0FTTSBpbnN0YW5jZVxuICAgICAgICBsYXN0QmFzZTY0LmN1cnJlbnQgPSBhd2FpdCByZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXMoaW5zdCwgaGV4cyk7XG4gICAgICAgIGxhc3RIZXhJbnB1dC5jdXJyZW50ID0gdHh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJVc2luZyBjYWNoZWQgcmVzdWx0XCIpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBGb3JtYXQgdGhlIG91dHB1dCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgZm9ybWF0XG4gICAgICBsZXQgb3V0OiBzdHJpbmc7XG4gICAgICBpZiAoZm9ybWF0ID09PSBcInV0ZjhcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG91dCA9IGF0b2IobGFzdEJhc2U2NC5jdXJyZW50KTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkNvbnZlcnRlZCBiYXNlNjQgdG8gVVRGLTggdGV4dFwiKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIGRlY29kZSBiYXNlNjQgYXMgVVRGLTgsIHVzaW5nIHJhdyBiYXNlNjQ6XCIsIGVycik7XG4gICAgICAgICAgb3V0ID0gbGFzdEJhc2U2NC5jdXJyZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3IgYmluYXJ5IGZvcm1hdHMgd2Ugc3RpbGwgaG9sZCBiYXNlNjQ7IHVzZXIgY2FuIGRvd25sb2FkIG9yIHByZXZpZXcgZWxzZXdoZXJlXG4gICAgICAgIG91dCA9IGxhc3RCYXNlNjQuY3VycmVudDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc2V0UmVzdWx0KG91dCk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRGVjb2RpbmcgZXJyb3I6XCIsIGUpO1xuICAgICAgc2V0RXJyb3IoXCJEZWNvZGluZyBlcnJvcjogXCIgKyAoZS5tZXNzYWdlIHx8IGUudG9TdHJpbmcoKSkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgdGFiczogeyBrZXk6IHR5cGVvZiBmb3JtYXQ7IGxhYmVsOiBzdHJpbmcgfVtdID0gW1xuICAgIHsga2V5OiBcInV0ZjhcIiwgbGFiZWw6IFwiVGV4dCAoVVRG4oCROClcIiB9LFxuICAgIHsga2V5OiBcImJhc2U2NFwiLCBsYWJlbDogXCJCYXNlNjRcIiB9LFxuICAgIHsga2V5OiBcInBuZ1wiLCBsYWJlbDogXCJQTkdcIiB9LFxuICAgIHsga2V5OiBcImpwZWdcIiwgbGFiZWw6IFwiSlBFR1wiIH0sXG4gICAgeyBrZXk6IFwicGRmXCIsIGxhYmVsOiBcIlBERlwiIH0sXG4gIF07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImJnLXdoaXRlLzEwIHJvdW5kZWQtNHhsIGJhY2tkcm9wLWJsdXItWzEwcHhdIHAtOCBtYXgtdy01eGwgdy1mdWxsIG14LWF1dG8gdGV4dC13aGl0ZVwiPlxuICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCB0ZXh0LXdoaXRlIG1iLTRcIj5NZXRhZGF0YTo8L2gyPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm91bmRlZC0zeGwgYmctd2hpdGUvMTAgYmFja2Ryb3AtYmx1ci1bMTBweF0gZmxleCBmbGV4LWNvbCBnYXAtMiByZWxhdGl2ZVwiPlxuICAgICAgICAgIHtpbnB1dC50cmltKCkgPT09IFwiXCIgJiYgKFxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmb250LW1vbm8gdGV4dC1iYXNlIHRleHQtWyNDM0Q1RjddIG1iLTEgYWJzb2x1dGUgaW5zZXQtMCBwLTggZmxleCBmbGV4LWNvbCBwb2ludGVyLWV2ZW50cy1ub25lXCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJsb2NrIG1iLTFcIj5cbiAgICAgICAgICAgICAgICBQYXN0ZSB5b3VyIGhleCBzdHJpbmdzIGhlcmUsIG9uZSBwZXIgbGluZSBvciBhcyBhbiBhcnJheTpcbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpdGFsaWMgbXQtNlwiPkV4YW1wbGUgKGxpbmUgYnkgbGluZSk6PC9zcGFuPlxuICAgICAgICAgICAgICA8cHJlIGNsYXNzTmFtZT1cIm1iLTFcIj5cbiAgICAgICAgICAgICAgICA0ODY1NkM2QzZGMjA1NzZGNzI2QzY0e2BcXG5gfTRENzU2Qzc0Njk0QzY5NkU2NVxuICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaXRhbGljIG10LTZcIj5PciAoYXJyYXkgZm9ybWF0KTo8L3NwYW4+XG4gICAgICAgICAgICAgIDxwcmU+W1wiNDg2NTZDNkM2RlwiLCBcIjU3NkY3MjZDNjRcIl08L3ByZT5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICl9XG4gICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICB2YWx1ZT17aW5wdXR9XG4gICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldElucHV0KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBtaW4taC1bMjByZW1dIHAtOCBmb250LW1vbm8gdGV4dC1zbSB0ZXh0LWdyYXktMjAwIGJnLXRyYW5zcGFyZW50IHJvdW5kZWQtbGcgcmVzaXplLXkgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOmJvcmRlci1ibHVlLTQwMFwiXG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSBmb250LW1lZGl1bSBtYi0yXCI+T3V0cHV0OjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImlubGluZS1mbGV4IHJvdW5kZWQtbGcgcC0xIGdhcC0yXCI+XG4gICAgICAgICAge3RhYnMubWFwKCh0YWIpID0+IChcbiAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAga2V5PXt0YWIua2V5fVxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRGb3JtYXQodGFiLmtleSl9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17YHB4LTIgcHktMSB0ZXh0LXNtIGZvbnQtbWVkaXVtIHJvdW5kZWQtbGcgdHJhbnNpdGlvbiAke1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gdGFiLmtleVxuICAgICAgICAgICAgICAgICAgPyBcImJnLVsjMDUxMDIzXSBiZy1vcGFjaXR5LTUwIHRleHQtd2hpdGVcIlxuICAgICAgICAgICAgICAgICAgOiBcInRleHQtZ3JheS0yMDAgYmctd2hpdGUvMTBcIlxuICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RhYi5sYWJlbH1cbiAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8YnV0dG9uXG4gICAgICAgIG9uQ2xpY2s9e2RlY29kZX1cbiAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBweS0zIHJvdW5kZWQtZnVsbCBiZy1ibHVlLTYwMCBob3ZlcjpiZy1ibHVlLTcwMCB0ZXh0LXdoaXRlIGZvbnQtc2VtaWJvbGQgdHJhbnNpdGlvbiBkaXNhYmxlZDpvcGFjaXR5LTUwIGRpc2FibGVkOmN1cnNvci1ub3QtYWxsb3dlZFwiXG4gICAgICA+XG4gICAgICAgIHtsb2FkaW5nID8gXCJEZWNvZGluZ+KAplwiIDogXCJEZWNvZGVcIn1cbiAgICAgIDwvYnV0dG9uPlxuXG4gICAgICB7KHJlc3VsdCB8fCBlcnJvcikgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LThcIj5cbiAgICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC1sZyBmb250LXNlbWlib2xkIHRleHQtd2hpdGUgbWItMlwiPlxuICAgICAgICAgICAge2Vycm9yID8gXCJFcnJvclwiIDogXCJEZWNvZGVkIFJlc3VsdFwifVxuICAgICAgICAgIDwvaDM+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00IGJnLXdoaXRlLzEwIHJvdW5kZWQtNHhsIGJhY2tkcm9wLWJsdXItWzEwcHhdIGJvcmRlci1sLTQgYm9yZGVyLWJsdWUtNTAwIHAtNSBmb250LW1vbm8gdGV4dC1zbSB0ZXh0LWdyYXktMTAwIG1heC1oLTY0IG92ZXJmbG93LXktYXV0byB3aGl0ZXNwYWNlLXByZS13cmFwXCI+XG4gICAgICAgICAgICB7ZXJyb3IgPyAoXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApIDogZm9ybWF0ID09PSBcInBuZ1wiIHx8IGZvcm1hdCA9PT0gXCJqcGVnXCIgPyAoXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICA8aW1nIFxuICAgICAgICAgICAgICAgICAgc3JjPXtgZGF0YTppbWFnZS8ke2Zvcm1hdH07YmFzZTY0LCR7cmVzdWx0fWB9IFxuICAgICAgICAgICAgICAgICAgYWx0PVwiRGVjb2RlZCBpbWFnZVwiIFxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibWF4LXctZnVsbCBtYXgtaC01NiBvYmplY3QtY29udGFpblwiXG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8YSBcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2BkYXRhOmltYWdlLyR7Zm9ybWF0fTtiYXNlNjQsJHtyZXN1bHR9YH0gXG4gICAgICAgICAgICAgICAgICBkb3dubG9hZD17YGRlY29kZWQuJHtmb3JtYXR9YH1cbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTMgdGV4dC1ibHVlLTQwMCBob3Zlcjp0ZXh0LWJsdWUtMzAwIHVuZGVybGluZSB0ZXh0LXNtXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBEb3dubG9hZCBJbWFnZVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogZm9ybWF0ID09PSBcInBkZlwiID8gKFxuICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgPGlmcmFtZVxuICAgICAgICAgICAgICAgICAgc3JjPXtgZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LCR7cmVzdWx0fWB9XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGwgaC01NiBib3JkZXItMFwiXG4gICAgICAgICAgICAgICAgICB0aXRsZT1cIlBERiBWaWV3ZXJcIlxuICAgICAgICAgICAgICAgID48L2lmcmFtZT5cbiAgICAgICAgICAgICAgICA8YSBcbiAgICAgICAgICAgICAgICAgIGhyZWY9e2BkYXRhOmFwcGxpY2F0aW9uL3BkZjtiYXNlNjQsJHtyZXN1bHR9YH0gXG4gICAgICAgICAgICAgICAgICBkb3dubG9hZD1cImRlY29kZWQucGRmXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm10LTMgdGV4dC1ibHVlLTQwMCBob3Zlcjp0ZXh0LWJsdWUtMzAwIHVuZGVybGluZSB0ZXh0LXNtXCJcbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICBEb3dubG9hZCBQREZcbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICApfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZXhEZWNvZGVyO1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlV2FsbGV0IH0gZnJvbSBcIi4uLy4uL2NvbnRleHQvV2FsbGV0Q29udGV4dFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmV3YXJkQWNjb3VudHMoKSB7XG4gIGNvbnN0IFtyZXdhcmRBY2NvdW50cywgc2V0UmV3YXJkQWNjb3VudHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcbiAgY29uc3QgeyBkZWZhdWx0V2FsbGV0LCBnZXRXYWxsZXRBcGksIGNvbm5lY3RlZFdhbGxldHMgfSA9IHVzZVdhbGxldCgpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2hSZXdhcmRBY2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghY29ubmVjdGVkV2FsbGV0cy5sZW5ndGggfHwgIWRlZmF1bHRXYWxsZXQpIHJldHVybjtcbiAgICAgICAgY29uc3QgYXBpID0gZ2V0V2FsbGV0QXBpKGRlZmF1bHRXYWxsZXQpO1xuICAgICAgICBpZiAoIWFwaSkgdGhyb3cgbmV3IEVycm9yKFwiV2FsbGV0IEFQSSBub3QgZm91bmRcIik7XG4gICAgICAgIGNvbnN0IHJld2FyZEFkZHJlc3NlcyA9IGF3YWl0IGFwaS5nZXRSZXdhcmRBZGRyZXNzZXMoKTtcbiAgICAgICAgc2V0UmV3YXJkQWNjb3VudHMocmV3YXJkQWRkcmVzc2VzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgZmV0Y2hpbmcgcmV3YXJkIGFjY291bnRzOlwiLCBlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGNvbm5lY3RlZFdhbGxldHMubGVuZ3RoID4gMCkgZmV0Y2hSZXdhcmRBY2NvdW50cygpO1xuICB9LCBbZGVmYXVsdFdhbGxldCwgY29ubmVjdGVkV2FsbGV0cywgZ2V0V2FsbGV0QXBpXSk7XG5cbiAgcmV0dXJuIHJld2FyZEFjY291bnRzO1xufVxuIiwiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGJ1aWxkQXBpVXJsLCBBUElfS0VZIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2FwaUNvbnN1bXB0aW9uXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXBsb2FkIHtcbiAgaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkYXRlVXBsb2FkZWQ6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIHRodW1ibmFpbFVybD86IHN0cmluZztcbiAgZmlsZVR5cGU/OiBzdHJpbmc7XG4gIG9iamVjdERhdGE/OiBzdHJpbmc7XG4gIG9iamVjdFR5cGU/OiBzdHJpbmc7XG4gIGluZGV4aW5nVHhJZD86IHN0cmluZztcbiAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0Pzogc3RyaW5nO1xuICBzaGFyZFR4SWRzPzogc3RyaW5nW107XG4gIG9iamVjdFVsaWQ/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVXBsb2Fkc1Byb3BzIHtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHJld2FyZEFjY291bnRzOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVVwbG9hZHMoeyBsaW1pdCA9IDksIHJld2FyZEFjY291bnRzIH06IFVzZVVwbG9hZHNQcm9wcykge1xuICBjb25zdCBbYWxsVXBsb2Fkcywgc2V0QWxsVXBsb2Fkc10gPSB1c2VTdGF0ZTxVcGxvYWRbXT4oW10pO1xuICBjb25zdCBbZmlsdGVyZWRVcGxvYWRzLCBzZXRGaWx0ZXJlZFVwbG9hZHNdID0gdXNlU3RhdGU8VXBsb2FkW10+KFtdKTtcbiAgY29uc3QgW2Rpc3BsYXllZFVwbG9hZHMsIHNldERpc3BsYXllZFVwbG9hZHNdID0gdXNlU3RhdGU8VXBsb2FkW10+KFtdKTtcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtwYWdlc0RhdGEsIHNldFBhZ2VzRGF0YV0gPSB1c2VTdGF0ZTx7IFtwYWdlOiBudW1iZXJdOiBVcGxvYWRbXSB9Pih7fSk7XG4gIGNvbnN0IFtsYXN0T2JqZWN0VWxpZHMsIHNldExhc3RPYmplY3RVbGlkc10gPSB1c2VTdGF0ZTx7XG4gICAgW3BhZ2U6IG51bWJlcl06IHN0cmluZztcbiAgfT4oe30pO1xuICBjb25zdCBbY3VycmVudFBhZ2UsIHNldEN1cnJlbnRQYWdlXSA9IHVzZVN0YXRlKDEpO1xuICBjb25zdCBbaGFzTW9yZVBhZ2VzLCBzZXRIYXNNb3JlUGFnZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZmV0Y2hJbml0aWFsVXBsb2FkcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZXdhcmRBY2NvdW50cy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7IGxpbWl0LCByZXdhcmRBY2NvdW50cyB9O1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGJ1aWxkQXBpVXJsKFwiL2FjY291bnQtdXBsb2Fkc1wiKSwge1xuICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICBcIngtYXBpLWtleVwiOiBBUElfS0VZLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFVwbG9hZHM6IFVwbG9hZFtdID0gZGF0YS5vYmplY3RzO1xuICAgICAgICBzZXRBbGxVcGxvYWRzKGZvcm1hdHRlZFVwbG9hZHMpO1xuICAgICAgICBzZXRGaWx0ZXJlZFVwbG9hZHMoZm9ybWF0dGVkVXBsb2Fkcyk7XG4gICAgICAgIHNldERpc3BsYXllZFVwbG9hZHMoZm9ybWF0dGVkVXBsb2Fkcyk7XG4gICAgICAgIHNldFBhZ2VzRGF0YSh7IDE6IGZvcm1hdHRlZFVwbG9hZHMgfSk7XG4gICAgICAgIGNvbnN0IGxhc3RVbGlkID0gZGF0YS5tTGFzdE9iamVjdFVsaWQ7XG4gICAgICAgIHNldExhc3RPYmplY3RVbGlkcyh7IDE6IGxhc3RVbGlkIH0pO1xuICAgICAgICBzZXRIYXNNb3JlUGFnZXMobGFzdFVsaWQgIT09IG51bGwpO1xuICAgICAgICBzZXRDdXJyZW50UGFnZSgxKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRFcnJvcihcbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGluaXRpYWwgdXBsb2FkczpcIiwgZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgZmV0Y2hJbml0aWFsVXBsb2FkcygpO1xuICB9LCBbcmV3YXJkQWNjb3VudHMsIGxpbWl0XSk7XG5cbiAgY29uc3QgZmV0Y2hOZXh0UGFnZSA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChwYWdlTnVtYmVyOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChwYWdlc0RhdGFbcGFnZU51bWJlcl0pIHtcbiAgICAgICAgc2V0RGlzcGxheWVkVXBsb2FkcyhwYWdlc0RhdGFbcGFnZU51bWJlcl0pO1xuICAgICAgICBzZXRDdXJyZW50UGFnZShwYWdlTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFzdFVsaWQgPSBsYXN0T2JqZWN0VWxpZHNbcGFnZU51bWJlciAtIDFdO1xuICAgICAgaWYgKCFsYXN0VWxpZCkgcmV0dXJuO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICAgICAgY29uc3QgYm9keSA9IHsgbGFzdE9iamVjdFVsaWQ6IGxhc3RVbGlkLCBsaW1pdCwgcmV3YXJkQWNjb3VudHMgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChidWlsZEFwaVVybChcIi9hY2NvdW50LXVwbG9hZHNcIiksIHtcbiAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgXCJ4LWFwaS1rZXlcIjogQVBJX0tFWSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRVcGxvYWRzOiBVcGxvYWRbXSA9IGRhdGEub2JqZWN0cztcbiAgICAgICAgc2V0QWxsVXBsb2FkcygocHJldikgPT4gWy4uLnByZXYsIC4uLmZvcm1hdHRlZFVwbG9hZHNdKTtcbiAgICAgICAgc2V0UGFnZXNEYXRhKChwcmV2KSA9PiAoeyAuLi5wcmV2LCBbcGFnZU51bWJlcl06IGZvcm1hdHRlZFVwbG9hZHMgfSkpO1xuICAgICAgICBjb25zdCBuZXdMYXN0VWxpZCA9IGRhdGEubUxhc3RPYmplY3RVbGlkO1xuICAgICAgICBzZXRMYXN0T2JqZWN0VWxpZHMoKHByZXYpID0+ICh7IC4uLnByZXYsIFtwYWdlTnVtYmVyXTogbmV3TGFzdFVsaWQgfSkpO1xuICAgICAgICBzZXRIYXNNb3JlUGFnZXMobmV3TGFzdFVsaWQgIT09IG51bGwpO1xuICAgICAgICBzZXREaXNwbGF5ZWRVcGxvYWRzKGZvcm1hdHRlZFVwbG9hZHMpO1xuICAgICAgICBzZXRDdXJyZW50UGFnZShwYWdlTnVtYmVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXRFcnJvcihcbiAgICAgICAgICBlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogXCJBbiB1bmtub3duIGVycm9yIG9jY3VycmVkXCJcbiAgICAgICAgKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcGFnZSAke3BhZ2VOdW1iZXJ9OmAsIGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtwYWdlc0RhdGEsIGxhc3RPYmplY3RVbGlkcywgbGltaXQsIHJld2FyZEFjY291bnRzXVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgYWxsVXBsb2FkcyxcbiAgICBmaWx0ZXJlZFVwbG9hZHMsXG4gICAgZGlzcGxheWVkVXBsb2FkcyxcbiAgICBzZXRGaWx0ZXJlZFVwbG9hZHMsXG4gICAgc2V0RGlzcGxheWVkVXBsb2FkcyxcbiAgICBsb2FkaW5nLFxuICAgIGVycm9yLFxuICAgIHBhZ2VzRGF0YSxcbiAgICBsYXN0T2JqZWN0VWxpZHMsXG4gICAgY3VycmVudFBhZ2UsXG4gICAgc2V0Q3VycmVudFBhZ2UsXG4gICAgaGFzTW9yZVBhZ2VzLFxuICAgIHNldEFsbFVwbG9hZHMsXG4gICAgc2V0UGFnZXNEYXRhLFxuICAgIHNldExhc3RPYmplY3RVbGlkcyxcbiAgICBzZXRIYXNNb3JlUGFnZXMsXG4gICAgZmV0Y2hOZXh0UGFnZSxcbiAgfTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFVwbG9hZCB9IGZyb20gXCIuL3VzZVVwbG9hZHNcIjtcbmltcG9ydCB7IEV4cGxvcmVyTGluayB9IGZyb20gXCIuLi91aS9GaW5pc2hTY3JlZW5cIjtcblxuaW50ZXJmYWNlIFVwbG9hZENhcmRQcm9wcyB7XG4gIHVwbG9hZDogVXBsb2FkO1xuICBvbkNvcHlUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBnZXRJbWFnZVNyYyA9ICh1cGxvYWQ6IFVwbG9hZCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh1cGxvYWQudGh1bWJuYWlsVXJsKSByZXR1cm4gdXBsb2FkLnRodW1ibmFpbFVybDtcbiAgaWYgKHVwbG9hZC5vYmplY3REYXRhICYmIHVwbG9hZC5vYmplY3RUeXBlICYmIHVwbG9hZC5vYmplY3RUeXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICByZXR1cm4gYGRhdGE6JHt1cGxvYWQub2JqZWN0VHlwZX07YmFzZTY0LCR7dXBsb2FkLm9iamVjdERhdGF9YDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgZm9ybWF0RGF0ZSA9IChkYXRlU3RyaW5nPzogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICBpZiAoIWRhdGVTdHJpbmcpIHJldHVybiBcIlVuY29tcGxldGVkXCI7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkgcmV0dXJuIFwiVW5jb21wbGV0ZWRcIjtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG59O1xuXG5jb25zdCBVcGxvYWRDYXJkOiBSZWFjdC5GQzxVcGxvYWRDYXJkUHJvcHM+ID0gKHsgdXBsb2FkLCBvbkNvcHlUZXh0IH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJiZy1jYXJkLWdyYWRpZW50IHJvdW5kZWQtbGcgcC00IGZsZXggZmxleC1jb2wgaC1mdWxsIGJvcmRlciBib3JkZXItYm9yZGVyLWxpZ2h0IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBob3Zlcjp0cmFuc2Zvcm0gaG92ZXI6LXRyYW5zbGF0ZS15LTEuNSBob3ZlcjpzaGFkb3ctbGdcIj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQteHMgdGV4dC10ZXh0LW11dGVkIG1iLTEuNVwiPntmb3JtYXREYXRlKHVwbG9hZC5pbmRleGluZ1R4U3VibWl0dGVkQXQgfHwgXCJcIil9PC9kaXY+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZCBtYi0yLjVcIj57dXBsb2FkLm5hbWV9PC9kaXY+XG4gICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXRleHQtc2Vjb25kYXJ5IG1iLTQgZmxleC1ncm93IG92ZXJmbG93LWhpZGRlbiB0ZXh0LWVsbGlwc2lzIGxpbmUtY2xhbXAtM1wiPnt1cGxvYWQuZGVzY3JpcHRpb259PC9wPlxuICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtWzE1MHB4XSBiZy1wcmltYXJ5LTgwMCByb3VuZGVkLW1kIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIG1iLTQgb3ZlcmZsb3ctaGlkZGVuXCI+XG4gICAgICB7dXBsb2FkLm9iamVjdFR5cGUgPT09IFwidGV4dC9wbGFpblwiICYmIHVwbG9hZC5vYmplY3REYXRhID8gKFxuICAgICAgICA8cHJlIGNsYXNzTmFtZT1cIndoaXRlc3BhY2UtcHJlLXdyYXAgYnJlYWstYWxsIGJnLVsjZjZmNmY2XSBwLTMgcm91bmRlZC1tZCBtYXgtaC1bMzAwcHhdIG92ZXJmbG93LWF1dG8gdy1mdWxsIGgtZnVsbFwiPnthdG9iKHVwbG9hZC5vYmplY3REYXRhKX08L3ByZT5cbiAgICAgICkgOiB1cGxvYWQuZmlsZVR5cGUgJiYgdXBsb2FkLmZpbGVUeXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJwZGZcIikgJiYgdXBsb2FkLm9iamVjdERhdGEgPyAoXG4gICAgICAgIDxpZnJhbWUgc3JjPXtgZGF0YTphcHBsaWNhdGlvbi9wZGY7YmFzZTY0LCR7dXBsb2FkLm9iamVjdERhdGF9YH0gdGl0bGU9e3VwbG9hZC5uYW1lfSBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIG9iamVjdC1jb3ZlclwiIC8+XG4gICAgICApIDogZ2V0SW1hZ2VTcmModXBsb2FkKSA/IChcbiAgICAgICAgPGltZyBzcmM9e2dldEltYWdlU3JjKHVwbG9hZCl9IGFsdD17dXBsb2FkLm5hbWV9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgb2JqZWN0LWNvdmVyXCIgLz5cbiAgICAgICkgOiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1wcmltYXJ5LTgwMFwiPjxzcGFuIGNsYXNzTmFtZT1cInRleHQtM3hsIHRleHQtdGV4dC1tdXRlZFwiPvCflrzvuI88L3NwYW4+PC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICAgIHt1cGxvYWQuZmlsZVR5cGUgJiYgdXBsb2FkLmZpbGVUeXBlLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoXCJ0ZXh0XCIpICYmIChcbiAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYmctdHJhbnNwYXJlbnQgYm9yZGVyIGJvcmRlci1ib3JkZXItbGlnaHQgdGV4dC10ZXh0LXByaW1hcnkgcHktMiBweC0zIHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOmJnLWJvcmRlci1saWdodC81MCB0ZXh0LXNtXCIgb25DbGljaz17KCkgPT4gb25Db3B5VGV4dCh1cGxvYWQuZGVzY3JpcHRpb24gfHwgXCJcIil9PkNvcHkgdGV4dDwvYnV0dG9uPlxuICAgICl9XG4gICAge3VwbG9hZC5pbmRleGluZ1R4SWQgJiYgPEV4cGxvcmVyTGluayB0eElkPXt1cGxvYWQuaW5kZXhpbmdUeElkfSAvPn1cbiAgICB7dXBsb2FkLnNoYXJkVHhJZHMgJiYgdXBsb2FkLnNoYXJkVHhJZHMubGVuZ3RoID4gMCAmJiB1cGxvYWQuc2hhcmRUeElkcy5tYXAoKHR4SWQsIGluZGV4KSA9PiAoXG4gICAgICA8RXhwbG9yZXJMaW5rIHR4SWQ9e3R4SWR9IGtleT17aW5kZXh9IC8+XG4gICAgKSl9XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkQ2FyZDtcbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IFVwbG9hZCB9IGZyb20gXCIuL3VzZVVwbG9hZHNcIjtcbmltcG9ydCBVcGxvYWRDYXJkIGZyb20gXCIuL1VwbG9hZENhcmRcIjtcblxuXG5pbnRlcmZhY2UgVXBsb2Fkc0dyaWRQcm9wcyB7XG4gIHVwbG9hZHM6IFVwbG9hZFtdO1xuICBvbkNvcHlUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBVcGxvYWRzR3JpZDogUmVhY3QuRkM8VXBsb2Fkc0dyaWRQcm9wcz4gPSAoeyB1cGxvYWRzLCBvbkNvcHlUZXh0IH0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0zIGdhcC01IG1iLTggbWQ6Z3JpZC1jb2xzLTIgc206Z3JpZC1jb2xzLTFcIj5cbiAgICB7dXBsb2Fkcy5tYXAoKHVwbG9hZCkgPT4gKFxuICAgICAgPFVwbG9hZENhcmQga2V5PXt1cGxvYWQuaWR9IHVwbG9hZD17dXBsb2FkfSBvbkNvcHlUZXh0PXtvbkNvcHlUZXh0fSAvPlxuICAgICkpfVxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZHNHcmlkO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgVXBsb2FkIH0gZnJvbSBcIi4vdXNlVXBsb2Fkc1wiO1xuaW1wb3J0IHsgRXhwbG9yZXJMaW5rIH0gZnJvbSBcIi4uL3VpL0ZpbmlzaFNjcmVlblwiO1xuXG5pbnRlcmZhY2UgVXBsb2FkTGlzdEl0ZW1Qcm9wcyB7XG4gIHVwbG9hZDogVXBsb2FkO1xuICBvbkNvcHlUZXh0OiAodGV4dDogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5jb25zdCBnZXRJbWFnZVNyYyA9ICh1cGxvYWQ6IFVwbG9hZCk6IHN0cmluZyB8IHVuZGVmaW5lZCA9PiB7XG4gIGlmICh1cGxvYWQudGh1bWJuYWlsVXJsKSByZXR1cm4gdXBsb2FkLnRodW1ibmFpbFVybDtcbiAgaWYgKHVwbG9hZC5vYmplY3REYXRhICYmIHVwbG9hZC5vYmplY3RUeXBlICYmIHVwbG9hZC5vYmplY3RUeXBlLnN0YXJ0c1dpdGgoXCJpbWFnZS9cIikpIHtcbiAgICByZXR1cm4gYGRhdGE6JHt1cGxvYWQub2JqZWN0VHlwZX07YmFzZTY0LCR7dXBsb2FkLm9iamVjdERhdGF9YDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgZm9ybWF0RGF0ZSA9IChkYXRlU3RyaW5nPzogc3RyaW5nIHwgbnVsbCkgPT4ge1xuICBpZiAoIWRhdGVTdHJpbmcpIHJldHVybiBcIlVuY29tcGxldGVkXCI7XG4gIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbiAgaWYgKGlzTmFOKGRhdGUuZ2V0VGltZSgpKSkgcmV0dXJuIFwiVW5jb21wbGV0ZWRcIjtcbiAgcmV0dXJuIGRhdGUudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XG59O1xuXG5jb25zdCBVcGxvYWRMaXN0SXRlbTogUmVhY3QuRkM8VXBsb2FkTGlzdEl0ZW1Qcm9wcz4gPSAoeyB1cGxvYWQsIG9uQ29weVRleHQgfSkgPT4gKFxuICA8ZGl2IGNsYXNzTmFtZT1cImJnLWxpc3QtZ3JhZGllbnQgcm91bmRlZC1sZyBwLTQgZ3JpZCBncmlkLWNvbHMtWzFmcl8yZnJfMTAwcHhdIGdhcC00IGJvcmRlciBib3JkZXItYm9yZGVyLWxpZ2h0IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBob3Zlcjp0cmFuc2Zvcm0gaG92ZXI6LXRyYW5zbGF0ZS15LTAuNSBob3ZlcjpzaGFkb3ctbGcgaXRlbXMtY2VudGVyIG1kOmdyaWQtY29scy0xIG1kOmdyaWQtcm93cy1bYXV0b19hdXRvX2F1dG9dXCI+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0xLjVcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC14cyB0ZXh0LXRleHQtbXV0ZWRcIj57Zm9ybWF0RGF0ZSh1cGxvYWQuaW5kZXhpbmdUeFN1Ym1pdHRlZEF0IHx8IFwiXCIpfTwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWxnIGZvbnQtYm9sZFwiPnt1cGxvYWQubmFtZX08L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgZ2FwLTIuNVwiPlxuICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXRleHQtc2Vjb25kYXJ5IG92ZXJmbG93LWhpZGRlbiB0ZXh0LWVsbGlwc2lzIGxpbmUtY2xhbXAtMlwiPnt1cGxvYWQuZGVzY3JpcHRpb259PC9wPlxuICAgICAge3VwbG9hZC5maWxlVHlwZSAmJiB1cGxvYWQuZmlsZVR5cGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInRleHRcIikgJiYgKFxuICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJnLXRyYW5zcGFyZW50IGJvcmRlciBib3JkZXItYm9yZGVyLWxpZ2h0IHRleHQtdGV4dC1wcmltYXJ5IHB5LTIgcHgtMyByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBob3ZlcjpiZy1ib3JkZXItbGlnaHQvNTAgdGV4dC1zbVwiIG9uQ2xpY2s9eygpID0+IG9uQ29weVRleHQodXBsb2FkLmRlc2NyaXB0aW9uIHx8IFwiXCIpfT5Db3B5IHRleHQ8L2J1dHRvbj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LVsxMDBweF0gaC1bMTAwcHhdIGJnLXByaW1hcnktODAwIHJvdW5kZWQtbWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgb3ZlcmZsb3ctaGlkZGVuIG1kOnctZnVsbCBtZDpoLVsxNTBweF0gbWQ6b3JkZXItZmlyc3RcIj5cbiAgICAgIHt1cGxvYWQub2JqZWN0VHlwZSA9PT0gXCJ0ZXh0L3BsYWluXCIgJiYgdXBsb2FkLm9iamVjdERhdGEgPyAoXG4gICAgICAgIDxwcmUgY2xhc3NOYW1lPVwid2hpdGVzcGFjZS1wcmUtd3JhcCBicmVhay1hbGwgYmctWyNmNmY2ZjZdIHAtMyByb3VuZGVkLW1kIG1heC1oLVszMDBweF0gb3ZlcmZsb3ctYXV0byB3LWZ1bGwgaC1mdWxsXCI+e2F0b2IodXBsb2FkLm9iamVjdERhdGEpfTwvcHJlPlxuICAgICAgKSA6IHVwbG9hZC5maWxlVHlwZSAmJiB1cGxvYWQuZmlsZVR5cGUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInBkZlwiKSAmJiB1cGxvYWQub2JqZWN0RGF0YSA/IChcbiAgICAgICAgPGlmcmFtZSBzcmM9e2BkYXRhOmFwcGxpY2F0aW9uL3BkZjtiYXNlNjQsJHt1cGxvYWQub2JqZWN0RGF0YX1gfSB0aXRsZT17dXBsb2FkLm5hbWV9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgb2JqZWN0LWNvdmVyXCIgLz5cbiAgICAgICkgOiBnZXRJbWFnZVNyYyh1cGxvYWQpID8gKFxuICAgICAgICA8aW1nIHNyYz17Z2V0SW1hZ2VTcmModXBsb2FkKX0gYWx0PXt1cGxvYWQubmFtZX0gY2xhc3NOYW1lPVwidy1mdWxsIGgtZnVsbCBvYmplY3QtY292ZXJcIiAvPlxuICAgICAgKSA6IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgaC1mdWxsIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLVsjMWExYTJhXVwiPjxzcGFuIGNsYXNzTmFtZT1cInRleHQtM3hsIHRleHQtZ3JheS01MDBcIj7wn5a877iPPC9zcGFuPjwvZGl2PlxuICAgICAgKX1cbiAgICAgIHt1cGxvYWQuaW5kZXhpbmdUeElkICYmIDxFeHBsb3JlckxpbmsgdHhJZD17dXBsb2FkLmluZGV4aW5nVHhJZH0gLz59XG4gICAgICB7dXBsb2FkLnNoYXJkVHhJZHMgJiYgdXBsb2FkLnNoYXJkVHhJZHMubGVuZ3RoID4gMCAmJiB1cGxvYWQuc2hhcmRUeElkcy5tYXAoKHR4SWQsIGlkeCkgPT4gKFxuICAgICAgICA8RXhwbG9yZXJMaW5rIHR4SWQ9e3R4SWR9IGtleT17aWR4fSAvPlxuICAgICAgKSl9XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2FkTGlzdEl0ZW07XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBVcGxvYWQgfSBmcm9tIFwiLi91c2VVcGxvYWRzXCI7XG5pbXBvcnQgVXBsb2FkTGlzdEl0ZW0gZnJvbSBcIi4vVXBsb2FkTGlzdEl0ZW1cIjtcblxuaW50ZXJmYWNlIFVwbG9hZHNMaXN0UHJvcHMge1xuICB1cGxvYWRzOiBVcGxvYWRbXTtcbiAgb25Db3B5VGV4dDogKHRleHQ6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuY29uc3QgVXBsb2Fkc0xpc3Q6IFJlYWN0LkZDPFVwbG9hZHNMaXN0UHJvcHM+ID0gKHsgdXBsb2Fkcywgb25Db3B5VGV4dCB9KSA9PiAoXG4gIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtNCBtYi04XCI+XG4gICAge3VwbG9hZHMubWFwKCh1cGxvYWQsIGlkeCkgPT4gKFxuICAgICAgPFVwbG9hZExpc3RJdGVtIGtleT17dXBsb2FkLmlkIHx8IGlkeH0gdXBsb2FkPXt1cGxvYWR9IG9uQ29weVRleHQ9e29uQ29weVRleHR9IC8+XG4gICAgKSl9XG4gIDwvZGl2PlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgVXBsb2Fkc0xpc3Q7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBGaWx0ZXJPcHRpb24ge1xuICBpZDogc3RyaW5nO1xuICBsYWJlbDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgVXBsb2Fkc0ZpbHRlcnNQcm9wcyB7XG4gIGRhdGVGaWx0ZXI6IHN0cmluZztcbiAgc2V0RGF0ZUZpbHRlcjogKHY6IHN0cmluZykgPT4gdm9pZDtcbiAgdHlwZUZpbHRlcjogc3RyaW5nO1xuICBzZXRUeXBlRmlsdGVyOiAodjogc3RyaW5nKSA9PiB2b2lkO1xuICBzZWFyY2hRdWVyeTogc3RyaW5nO1xuICBzZXRTZWFyY2hRdWVyeTogKHY6IHN0cmluZykgPT4gdm9pZDtcbiAgb25TZWFyY2g6IChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHZvaWQ7XG4gIGRhdGVGaWx0ZXJPcHRpb25zOiBGaWx0ZXJPcHRpb25bXTtcbiAgdHlwZUZpbHRlck9wdGlvbnM6IEZpbHRlck9wdGlvbltdO1xuICB2aWV3TW9kZTogXCJncmlkXCIgfCBcImxpc3RcIjtcbiAgc2V0Vmlld01vZGU6ICh2OiBcImdyaWRcIiB8IFwibGlzdFwiKSA9PiB2b2lkO1xufVxuXG5jb25zdCBVcGxvYWRzRmlsdGVyczogUmVhY3QuRkM8VXBsb2Fkc0ZpbHRlcnNQcm9wcz4gPSAoe1xuICBkYXRlRmlsdGVyLFxuICBzZXREYXRlRmlsdGVyLFxuICB0eXBlRmlsdGVyLFxuICBzZXRUeXBlRmlsdGVyLFxuICBzZWFyY2hRdWVyeSxcbiAgc2V0U2VhcmNoUXVlcnksXG4gIG9uU2VhcmNoLFxuICBkYXRlRmlsdGVyT3B0aW9ucyxcbiAgdHlwZUZpbHRlck9wdGlvbnMsXG4gIHZpZXdNb2RlLFxuICBzZXRWaWV3TW9kZSxcbn0pID0+IChcbiAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC00IHctZnVsbCBtYXgtdy1bODAwcHhdXCI+XG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWItMi41XCI+XG4gICAgICA8Zm9ybSBvblN1Ym1pdD17b25TZWFyY2h9IGNsYXNzTmFtZT1cImZsZXggdy1mdWxsXCI+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBwbGFjZWhvbGRlcj1cIlNlYXJjaFwiXG4gICAgICAgICAgdmFsdWU9e3NlYXJjaFF1ZXJ5fVxuICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0U2VhcmNoUXVlcnkoZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgIGNsYXNzTmFtZT1cImZsZXgtZ3JvdyBweS0yLjUgcHgtNCByb3VuZGVkLWwtbWQgYmctcHJpbWFyeS04MDAgdGV4dC10ZXh0LXByaW1hcnkgYm9yZGVyIGJvcmRlci1ib3JkZXIgYm9yZGVyLXItMFwiXG4gICAgICAgIC8+XG4gICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiIGNsYXNzTmFtZT1cInB5LTIuNSBweC00IHJvdW5kZWQtci1tZCBiZy1wcmltYXJ5LTcwMCB0ZXh0LXRleHQtcHJpbWFyeSBib3JkZXIgYm9yZGVyLWJvcmRlciBjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgaG92ZXI6YmctcHJpbWFyeS02MDBcIj5cbiAgICAgICAgICA8c3BhbiByb2xlPVwiaW1nXCIgYXJpYS1sYWJlbD1cInNlYXJjaFwiPvCflI08L3NwYW4+XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9mb3JtPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBnYXAtNCBpdGVtcy1jZW50ZXIgZmxleC13cmFwIGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGZsZXgtY29sIGdhcC0xLjVcIj5cbiAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC10ZXh0LW11dGVkXCI+RmlsdGVyIGJ5IERhdGU8L2xhYmVsPlxuICAgICAgICA8c2VsZWN0XG4gICAgICAgICAgdmFsdWU9e2RhdGVGaWx0ZXJ9XG4gICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXREYXRlRmlsdGVyKGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICBjbGFzc05hbWU9XCJweS0yIHB4LTMgcm91bmRlZC1tZCBiZy1wcmltYXJ5LTgwMCB0ZXh0LXRleHQtcHJpbWFyeSBib3JkZXIgYm9yZGVyLWJvcmRlciBtaW4tdy1bMTIwcHhdXCJcbiAgICAgICAgPlxuICAgICAgICAgIHtkYXRlRmlsdGVyT3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gKFxuICAgICAgICAgICAgPG9wdGlvbiBrZXk9e29wdGlvbi5pZH0gdmFsdWU9e29wdGlvbi5pZH0+e29wdGlvbi5sYWJlbH08L29wdGlvbj5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC9zZWxlY3Q+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBnYXAtMS41XCI+XG4gICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtdGV4dC1tdXRlZFwiPkZpbHRlciBieSBUeXBlPC9sYWJlbD5cbiAgICAgICAgPHNlbGVjdFxuICAgICAgICAgIHZhbHVlPXt0eXBlRmlsdGVyfVxuICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0VHlwZUZpbHRlcihlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgY2xhc3NOYW1lPVwicHktMiBweC0zIHJvdW5kZWQtbWQgYmctcHJpbWFyeS04MDAgdGV4dC10ZXh0LXByaW1hcnkgYm9yZGVyIGJvcmRlci1ib3JkZXIgbWluLXctWzEyMHB4XVwiXG4gICAgICAgID5cbiAgICAgICAgICB7dHlwZUZpbHRlck9wdGlvbnMubWFwKChvcHRpb24pID0+IChcbiAgICAgICAgICAgIDxvcHRpb24ga2V5PXtvcHRpb24uaWR9IHZhbHVlPXtvcHRpb24uaWR9PntvcHRpb24ubGFiZWx9PC9vcHRpb24+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvc2VsZWN0PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZ2FwLTEuNVwiPlxuICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgY2xhc3NOYW1lPXtgdy0xMCBoLTEwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLXByaW1hcnktODAwIGJvcmRlciBib3JkZXItYm9yZGVyIHRleHQtdGV4dC1wcmltYXJ5IHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOmJnLXByaW1hcnktNzAwICR7XG4gICAgICAgICAgICB2aWV3TW9kZSA9PT0gXCJncmlkXCIgPyBcImJnLXByaW1hcnktNjAwIGJvcmRlci1ib3JkZXItYWN0aXZlXCIgOiBcIlwiXG4gICAgICAgICAgfWB9XG4gICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0Vmlld01vZGUoXCJncmlkXCIpfVxuICAgICAgICAgIGFyaWEtbGFiZWw9XCJHcmlkIHZpZXdcIlxuICAgICAgICA+XG4gICAgICAgICAgPHNwYW4gcm9sZT1cImltZ1wiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPuKKnjwvc3Bhbj5cbiAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBjbGFzc05hbWU9e2B3LTEwIGgtMTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctcHJpbWFyeS04MDAgYm9yZGVyIGJvcmRlci1ib3JkZXIgdGV4dC10ZXh0LXByaW1hcnkgcm91bmRlZC1tZCBjdXJzb3ItcG9pbnRlciB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgaG92ZXI6YmctcHJpbWFyeS03MDAgJHtcbiAgICAgICAgICAgIHZpZXdNb2RlID09PSBcImxpc3RcIiA/IFwiYmctcHJpbWFyeS02MDAgYm9yZGVyLWJvcmRlci1hY3RpdmVcIiA6IFwiXCJcbiAgICAgICAgICB9YH1cbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRWaWV3TW9kZShcImxpc3RcIil9XG4gICAgICAgICAgYXJpYS1sYWJlbD1cIkxpc3Qgdmlld1wiXG4gICAgICAgID5cbiAgICAgICAgICA8c3BhbiByb2xlPVwiaW1nXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+4piwPC9zcGFuPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbik7XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZHNGaWx0ZXJzO1xuIiwiaW1wb3J0IHsgVXBsb2FkIH0gZnJvbSBcIi4vdXNlVXBsb2Fkc1wiO1xuXG5leHBvcnQgY29uc3QgbW9ja1VwbG9hZHM6IFVwbG9hZFtdID0gW1xuICB7XG4gICAgaWQ6IFwiMVwiLFxuICAgIG5hbWU6IFwiQ2hhcnQgSW1hZ2VcIixcbiAgICBkYXRlVXBsb2FkZWQ6IFwiMjAyNS0wMy0xNVQxMDozMDowMFpcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBIGNoYXJ0IHNob3dpbmcgZGF0YSB2aXN1YWxpemF0aW9uXCIsXG4gICAgZmlsZVR5cGU6IFwicG5nXCIsXG4gICAgaW5kZXhpbmdUeElkOiB1bmRlZmluZWQsXG4gICAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0OiB1bmRlZmluZWQsXG4gICAgb2JqZWN0RGF0YTpcbiAgICAgIFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQStrQUFBSWpDQVlBQUFCL09Wb1pBQUFBT25SRldIUlRiMlowZDJGeVpRQk5ZWFJ3Ykc5MGJHbGlJSFpsY25OcGIyNHpMakV3TGpFc0lHaDBkSEJ6T2k4dmJXRjBjR3h2ZEd4cFlpNXZjbWN2YzIvKzVRQUFBQWx3U0ZsekFBQVBZUUFBRDJFQnFEK25hUUFBV21sSlJFRlVlSnp0M1FtYzNQUDlQL0JQN2tNU0VZbUVDQ0h1K3lhb293MVJTdW1GSGtKYldrVzFqcEsyUkxSRlZkRkQwUU85SGIraS81YXFpSnU0cWF1b002NGNqb2pJdGNuTy8vSCtybG16bTgzS3NidnpuWm5uOC9HWTdNNTN2anZ6bWZsK1pqS3Y3K2ZxVkNnVUNna0FBQUFvdTg3bExnQUFBQURRUUVnSEFBQ0FuQkRTQVFBQUlDZUVkQUFBQU1nSklSMEFBQUJ5UWtnSEFBQ0FuQkRTQVFBQUlDZUVkQUFBQU1nSklSMEFBQUJ5UWtnSGFHT2RPblZLcDUxMldwdmU1MldYWFpiZDc0c3Z2cGp5N0NjLytVbGFlKzIxVTVjdVhkSVdXMnhSN3VKQUUvSCtpZmRSdkorcXhhMjMzcG85cC9pNXBQdiszLy85WHlxSFN2a2M2K2pQZDREbWhIU2dLaFcvREM3dWNzODk5NlE4T3VPTU05SzExMTZiS3RHTk45Nll2dk9kNzZTZGR0b3BYWHJwcGRseldaeEREejEwc2NmbWhodHVTTFhrOWRkZlR5ZWZmSExhZmZmZFU5KytmVDgwY04xOTk5MXA1NTEzVHIxNzkwNURoZ3hKMy96bU45T3NXYk02dE14NTk1ZS8vQ1dkZi83NXFWYlY4dk4vN2JYWHNoRDl5Q09QTFBOOVhILzk5WUk0VUZaZHkvdndBTzNyOU5OUFQydXR0ZFlpMjlkWlo1MlVSeEZzUC9PWno2VDk5OSsveWZZdmZlbEw2YUNERGtvOWV2UkllWFh6elRlbnpwMDdwOS85N25lcGUvZnVIN3AvUEpmZi92YTNpMnpmZlBQTlV5MTUrdW1uMDQ5Ly9PTzA3cnJycGswMzNUUk5talJwc2Z0RzhQall4ejZXTnR4d3czVHV1ZWVtVjE1NUpaMXp6am5wZi8vN1gvclh2LzdWb2VYT2UwaDkvUEhIMDdlKzlhMG0yOWRjYzgwMFo4NmMxSzFidDFRdGR0bGxsK3c1bGI3bkZ2ZjhheVdrang4L1BnMGZQbnlaZS9ORVNML2dnZ3RhRE9yeFduZnQ2dXN6MEw1OHlnQlY3ZU1mLzNqYVpwdHRVcVdMN3VOeHliTnAwNmFsWHIxNkxWRkFEL0ZGOTR0Zi9HS3FaTys5OTE1YVlZVVZsdXMrdHQ1NjYvVG1tMittQVFNR1pOMlFQL3Zaenk1MjMrOSs5N3RwcFpWV3lscmErL1hybDIyTE1ITDQ0WWRuUFJuMjNIUFBWSTFtejU2ZDlSeFlYdEZMb1dmUG5xbWF4SW14YW50T2VlYTFCanFDN3U1QXphcXJxOHVDMFdHSEhiYkliVE5uenN5K2pKMXd3Z2xOUXVoWHZ2S1ZOSGp3NE95MmFQSDkvZTkvLzZHUEUxMjdJMGcxRjYwMEVScUs0dmNJZlhHZnhhN2Y4YmV0amVYODFhOStsVGJlZU9Pc1ZYcTExVlpMUngxMVZKb3hZMGFUZlhiYmJiZTB5U2FicENlZmZETHJVaDFoWitqUW9lbnNzODllb3RkcHdZSUY2UWMvK0VFYU1XSkU5amp4WENJc3pwczNyMG5abzR0N2xMOVk5dlljOS91blAvMHBDN2R4VWlDT1lmUXllUG5sbHh0dlAvcm9vMU9mUG4yeWNOZmN3UWNmbkhVVFg3aHdZZU8yYUlYK3lFYytrZ1h1NkhLK3p6NzdwQ2VlZUtMSjM4V3hpUHQ4N3JubjB0NTc3NTN0OTRVdmZDR05HemN1YTVtZFBuMzZJbzkxeEJGSHBQNzkrNmU1YytjdTlybkUvY1J6K0RCUkp5ZE1tSkNkMkNnRzlIRElJWWRrNWJyeXlpcy85RDVlZXVtbHROOSsrMlhQYzVWVlZrbmYvdmEzMDcvLy9lOFd1OWpmZSsrOWFhKzk5a29ycnJoaVZtZDIzWFhYZE5kZGQ3VlloNTk5OXRuczlZbm5HdnZIZTZxbDEvN0RqbHRwZlgzd3dRZXpWdUo0N0todjRlOS8vM3QyYktLdVIxMk1PaGwxcy9SWXh0OWZkOTExMlhNdDFzWGkrMjl4WTlLakYwangrTWR6K09RblA1bisrOS8vTHZOemplTVVReEppbnpnMjY2Ky9mdU56V0p4UGZlcFRhYXV0dG1xeWJkOTk5ODBlOC8vOXYvL1g1TGpFdG1MUGllWmowbHQ3L2tYMTlmWHBSei82VVZwOTlkV3p6N0xvblJIUDY4UEVmWDdqRzkvSW5rOGN3NVZYWGprN3FkVFNHUE40LzN6MG94L045b3ZIK2VFUGY1Zzlibk5MY2t5YjE0c2RkOXd4dTkvb0pYWFJSUmMxN2hPdndiYmJicHY5SHNlbCtXZlJIWGZja1pWM2pUWFd5QjVyMkxCaDJYc2dXc2VMNHRoR0szb29IWWJUMnBqMGh4OStPRHNoSE8vTE9ON3hlallmVWxYOERJLzMwSEhISFpjR0RScVUxYmNERGppZ3hjOE9vTFpwU1FlcTJqdnZ2SlBlZU9PTkp0dmlpMUo4dVl4Z0ZWK1Fycjc2Nm5UeHhSYzNhUUdPY2VFUlFpTkVoUGdTRjE4UzQ0dHNCTUQ0Y25qVlZWZGxYK2dpRkI5NzdMSExYZFkvL3ZHUDZhdGYvV3JhYnJ2dHNuQVg0Z3ZyNHNRWHhlaldPV3JVcUhUa2tVZG0zYVl2dlBEQ2RQLzk5MmRmQkV1NzlMNzk5dHRaNElvZzhMblBmUzVyc1QzcHBKT3k3dFh4NWJJMVVhWTRjUkRkOEk4Ly92Z3NKSng1NXBsWmlMbm1tbXNheS83clgvODYzWGZmZlkxZDJPT0w5SWRwZm15aXpCRjhXaFBoNHBSVFRzbWVSNVF0dnVEKzRoZS95QUpkZkZtT1lIVGdnUWRtWDdRanJKUzJURWVZK3NjLy9wRWR0MkxQaENqN21ERmowdWpSbzdOdTU3RlB2STRSc3VMK1NnTk9uTENJL2VLMjZHWWVBWExreUpIWnNJb3JycmdpcXh0RjgrZlB6MTduVDMvNjAyM1MrdmJZWTQ5bGo5KzhaMGpVMitqV0cyVnRUWnhBaWRBVVkrQ2p2c2FKaXVnV2Zjc3R0eXl5YjRUV3FCY1JxT01rUkxUV3hrbVkrUHNJT2xGSFM4V3hpUGRFMUl1SEhub29xd054RWlCZXo2VTVia1hSc3lBZVA5NS9jVklpVG93VmcwNkVvQWc1OFRQS2VlcXBwMlluTUdMU3d2Qzk3MzB2ZTkvSFVJRHp6anN2MnhiN0xzNU5OOTJVUFZaTWVCanZxWGl2UjdsaWJvVjRMczBEN29jOTF3aW5uL2pFSjlKbW0yMlcxWXNJZy9HNTBmd0VSM054a2lBQ2F6eVhDSHVGUWlIN20zanQ0eldQa3lzaGZvOXRVYjZXTE1uelArdXNzN0w3aUpPUXNXK2NzSXNUVHZIZWJrMTh0c1NjQ0hGY0luaEhPSS8zU253MnhrbkFZbStIS1ZPbVpDY0VvNzdHZkFzUlJ1UHpJWUoxYzB0eVRFcy94K0lFV1J5RE9Oa1dKNmJpc3kvZUExLys4cGV6WVNEeG1zZmZ4MmRvdkthbG4wWHhtUjN2Ny9pYitEOGdQcS9pV01kckZiZUZyMzN0YTFtWCtUalJFcDhOSHlhT2R6eE9ITE9Za3lNK3crTC9rM2hOYnJ2dHRyVDk5dHMzMmYrWVk0N0plc1BFK3lwZXY1ZzdJRDQzNHZNRG9GRUJvQXBkZXVtbGhmaUlhK25TbzBlUHh2MysvZTkvWjl2KzhZOS9OUG43dmZmZXU3RDIybXMzWGovLy9QT3ovZjcwcHo4MWJwcy9mMzVoNU1pUmhUNTkraFJtenB6WnVEMzJHemR1WE9QMU1XUEdGTlpjYzgxRnloajdOUDhZWG1HRkZiTDlGL2Q4WG5qaGhlejZ0R25UQ3QyN2R5L3N1ZWVlaFlVTEZ6YnU5OHRmL2pMYjc1SkxMbW5jdHV1dXUyYmIvdkNIUHpSdW16ZHZYbUhJa0NHRlQzLzYwNjIram84ODhrajJ0MS85NmxlYmJEL2hoQk95N1RmZmZIT1Q1eG5sWHhLeGIwdkhKc3JhbWhkZmZMSFFwVXVYd285KzlLTW0yeDk3N0xGQzE2NWRHN2ZYMTljWGhnNGR1c2p6dS9MS0s3UEh1ZjMyMjdQcjc3NzdicUYvLy82Rnd3OC92TWwrVTZaTUtheTQ0b3BOdGhmTGZQTEpKeTlTcnFnSDIyKy9mWk50VjE5OWRiYi9MYmZjVWxoU1YxMTExV0wvcG5oYnNleWxQdnZaejJiSHN6VS8vZWxQczcrLzl0cHJHN2ZObVRPbnNNRUdHelI1ekhqdDFsMTMzY0xvMGFPejM0dG16NTVkV0d1dHRRcDc3TEhISW5YNHkxLytjcFBIT3VDQUF3b3JyN3p5VWgrMzB2cDYwVVVYTGZJY29nek5mZTFyWHl2MDd0MjdNSGZ1M01adCsreXpUNHZ2dVhqL3hIM0grNmxvaXkyMktLeXl5aXFGTjk5OHMzSGJmLzd6bjBMbnpwMExoeHh5eUZJLzEvUE9PeS9iYi9yMDZZV2xjZi85OTJkL2QvMzExMmZYSDMzMDBleDZITnZTdXJYZmZ2c1Z0dHh5eThicmNkeWExNW5GUGYvaXZodHV1R0gyR1ZEMHM1LzlMTnNleDZNMUxiMytreVpOV3VUejVWdmYrbGEyN2Q1NzcyM2NGcDlaOFo0cS9SeGJtbU5hckJkUmo0dmlPUlNQWDN3ZWw3Nk9wY2U0dGNjNjg4d3pDNTA2ZFNxODlOSkxqZHVPT3Vxb1JUNmJGL2Y1dnYvKysyZWZ4Yzg5OTF6anR0ZGVlNjNRdDIvZndpNjc3TExJWi9pb1VhT2F2SysrL2UxdlorK05HVE5tdFBoNFFHM1MzUjJvYXRHYUdpMGlwWmZTQ2JhaVpYRGd3SUZOV2pHaXRTYjJpOWJZMG9tRW91VXhXbStLb3NXa09MTjJ0SmgwcEdqOWk1YmFtQmdxV3NTS1lteHl0T2hFQzNLcGFLRXFIZjhkTFUvUkd2cjg4OCszK2pqeHZFTzBjcFdLRnZYUS9IR1dSclF1Tno4MlAvM3BUMXY5bStqMUVGMW1veVV0V3VHTGx6ZzJNZkZhc1ZVNGVrdEVDM3FVdjNUbTh6ak8wZFUvV3NKRFBHYjBoSWpqV25wLzBjb2VMV0F0dFRKSEsxeHowZVU4V2lHakszelJuLy84NTZ3N2JYUVRid3ZGTHJrdFRSNFlyMlZwbDkyV3hLejU4ZHlMTGJMRnY0czYwM3h5dXBpSTd2T2YvM3pXb2wxOFRhSWxQcnJ4M243NzdZdDBXLzc2MTcvZTVIcTBMTWJmUm12bzBoeTNvbmlPTFExREtXMkpmZmZkZDdQN2lNZUsxdEdubm5vcUxhM29WUkRQTjNwV2xBNDVpRmJ3UGZiWW83SCtMODF6TGZZSWlGYnhscnAzTDg2V1cyNlp2VS9qOVMyMm1FZHJkZFN0YUxHUDV4Z1o4YzQ3NzJ4c0lWNVc4ZHFXOWh3cTN0K0hmUjZVdnY0eFhDaWVkMHpDR2M4NXlsZ1VyOXNPTyt6UXBNZEZkTytPMXZybE9hWXhqMFcwZEJmRmM0anJNUlFwdXNGL21OTEhpdm9janhXdDdQRzZmbGhQbEpaRWwveVlDeUltK295ZUdFV3JycnBxOXY2SlkxV3NGMFhSd2wvYWZUNmVhOXhQRENVQUtOTGRIYWhxOFNXeHRZbmo0a3RmZEVlT2JyL1J2VDNDUVFTSytBSmFHdExqQzFTRWlkSkFIS0o3WmZIMmpsUjh2QmdiV2lxK3RNYVh4ZWJsaVMvN3BWOE1RM1M1ZlBUUlJ6LzBjZUk1TjU4TlA4SlZmREZmbnVjZFFUaTY2aStOQ0kveGhUcU9SVXRLdS9qSDhZdXVwREdlTjc0d1IxaVA4QkJmNm91dlJkeGY4V1JOUzBySGZoZnJTN3lXemNWanhRbVRDT2JSMVRhNkVQL3puLy9NeHJzMmY5MlhWVEZnbE00RlVCUmozbHZxU2x3cWpsVU1uMmhlbnViSHR2aWF4QkNBeFlubkYvV25LTWI0bGlyZUZpZTg0alZjbXVNVzRtUkNTeE1RUnRmaTczLy8rMW1YNk9iaEo4clVWdStqNG5zN3h1czNueHp3dzU1cjFJWG9BaDlkK3FPcmQ1ellpR0VtTVZ5aytlZEg4L2REREoySWNCN2lad1M0T0tFVUlTN0dPRWUzLzdmZWVtdTVRM3ByejZFMWNTSW91dm5IMElkWFgzMDFPNll0dmY3eHVqYnY1cjI0MTNscGptbU1XMjgrVWVONjY2MlgvWXl1NDNGaW9EV1RKMC9PM3AveG1kRDh1UzVML1lraEczRXlZWEgxSjA3U3hKd0xNVy9JOHI3MlFHMFIwb0dhRitNcll3eGh0TEJIaTBpTWM5eGdndzNhYkNtd3hZVzA1aE1qdGFmRnpReGYraVc3TlcwVk5KZFhmT2t0VHByVjBuTXFIWHNiWDloalBIRWN6d2pwTVJZOVFrYnB5WmRpUzJlTVBZMFREODAxWDJvcFR1SzBGTFRpaTNhTVF5Nkc5QmlMSG1HNkxXZXZqOWE1WXV0dmM3RXRBa3hiS0w0bU1SNTRjVXRZTlIvai9HSDFhMm1PVzJqcGhFUDBlSWhlQ1JHRVk5eHhuSENJbmdEUmdodnpLeXhOcS9YeStMRG5HbVdQMXZEb0hSQTlUYUlIUS9UZ2lCTkIwZXJhMmlvTkVjaGo3SDZjZEltUUh1UEw0MlJZVEpnVzE0dGo4NWMzcEMvcjUwR01wNDZBSGllazRvUkN6QjhSeHpVK1E1Zmw5ZS9JWXhxZnQ5RTdJazV5eEgzSFozd0UvampaRUQwcDhsSi9BSUtRRHRTOG1MZ3FBbEI4a1k0dnlkR2lFMStPbTYrdkhLM084VVd1TktRVnUyUEc3WXNUQWE3NWpPdWhwVmJvSlEzRHhjZUx5ZUpLdTFsR0YvZ1hYbmhocVZ1b1czdWNlTTdSRWxyc05SQ21UcDJhUGFmV25uZDdpQy94OFdVMkp1NHF0cUMxSnJwWC8reG5QOHRhNk9MNFJtZ3ZiVzByVHN3WEUzOHQ3MnNXM1pKalZ2Q1lYQ3ZDZW5SZkxtMUJXMTRSMU9La3dRTVBQSkE5cjlKakhsMjJTN2UxSkk1VlRPNFZyMTlwUFdzK3EzZnhOWW5nMUZiMWFHbVBXMHRpNXU3b1hoMDlYZUk5V3hUMXZTM2VSODNGZXp1R3dpekxFbnZ4R1JFdDZIR0o5ZXpQT09PTTdETWxnbnRycjJtRTd6aWVmLzNyWDdQd1dBemo4WHlMSVQxZXYySlk3K2lUYW5IeUtYcFlsQTVMaVJNS3pUL2Y0blV0OXNnbzFmeDFYcHBqR21KQ3QrWTlHNTU1NXBuc1ozR0N2OFU5OTVoNE1mYU5TVERqdlZvVVExNlc5ZldMTHZ3eFdkN2k2ay9VZ3hqeUFyQzBqRWtIYWw1OGtZcXVxTkhTR2kycU1TTnhhV3RyaUJtRlk4Ymkwckhyc1YvTURCeXRnSzJOTzQ2QUVsMHBTN3VXUjh0bmNXYjBVdkhsczZWQTMxeDgwWS91d0QvLytjK2J0TUQ4N25lL3l4NHJsalJxQy9HOFEzUWJMeFhCSTdUVjR5eXA2RFljTFZFeHEzM3pscWU0SGwvNFM4VnhqQmJ0K0dJZUxack5nMnpNMUI1aE5FSlVESEZvYm1tV1Jvb1p3aVBVeFN6Zk1VZEJXNjhCSDYyV2NkeGpHYk1ZdTFzVWRUYTY4cmUydm5yeHVVYndLMTNPS3dMV2IzN3pteWI3eFl6dVVXZGo5dnJTOGZ4Rnk3SmMxTklldDlaYUlFdi9QZ0p0TEVQWTB2dG9TYm92eDhtNTZDMFE5YVAwZmZmNDQ0OW5yZDdGK3I4MG9xVzJ1V0tQaEphR0twU0tMdUxSOVQvcVVJeVJMNTdraWJBZTNkMmpYaTFKSy9xU1B2K2xGY2VnK2ZHTHo4RG12WUxpZFl2eXh1enBwZlVtVGw0MXY3OGxQYWJGejl6bzlWUzZiMXlQc0J6MU5oUURmUFBQMFpZZUszNlBrM2pOTGU0K21vdjczSFBQUGJQNUIwcVhvWXVUbURHRUtrNzZOaDh5QTdBa3RLUURWUzI2MTdZMG9WUk1GbFRhQWgxaExyNXN4ckk0c1N4WmFhdHhjYktmK0RJWTNTSmpncUpvdFlsV3BWZ2lLUUpzckhXOU9ORVZOTHBYeG5Kdk1kRmNjWW12YUJFcm5Xd3B4QmZObUJRdVFuQjBYNDZXeDViR2RzYVgwckZqeDJhaEo1WldpOG5Bb2pVbnZ0ekdPc0Z0RlJDankzKzBuTVh5U2NXdXFmSEZPMEpOREEySVpaWTZVb1RIV0c4NW5udDhLWTR5eEdzZkxXOXgwaU9PVStuYTlySHVkSXk1amxiTUNFak5UNzdFRitnNEZsLzYwcGV5ZmVOWXhXc2JZMWVqcTNJc2MvWExYLzV5aWNvVzRTcitQdmFQTCsrbGt3eCttSGhPb2JnMmV3VHZtSFFxeEhqZG91Z0tIWFUzamtNODExZzZLbG8xSXloRVBXaE5qTVdQc2tXNVlnbTJDS2dSbW9yTHd4VmJEK09rVll5cGpwTU9FUkpqa3JFWUl4NEJQMXFDNHpXTEUxcnRlZHhhRXM4N2VxVkVmWXozVVpRM1hxZVd1Z25IK3loT3FNV0VoL0YraUJOcHNlWjRTNkpiZnp6WDZMNzlsYTk4cFhFSnRqZ3Awbnc5N0NVUjNiYWp1M3Vjd0lvVzVaalVMTjZYTVpkQmNjTEN4WWxXMlNoN0JOemlHdWtoV3BtakJUa3VTeExTbCtiNUw0MFkwaEd2ZWJ3MkcyMjBVWm8wYVZMMmVSWExtWldLcGNoaXY2aVRVZGVLUzdBVmV5UXR5ekVOOFprWUp6Q2lEc1huWnp6SDZFVVM5MTJjMXlEcVdnd1JpUFhUbzQ3Rlk4ZG5hSFJ2ajl1aW5rVmRqbnI4dDcvOXJjV3g0TVhBSDJXS2sxdnhmaTR1eDlsYzFPdG9qWTlqRzJ2SVIyK1grTDhpUG05aWFUdUFaVkx1NmVVQk9ub0p0cGFXNTRrbGNZWU5HNWJkOXNNZi9yREYrNXc2ZFdyaHNNTU9Ld3djT0RCYmNtZlRUVGR0Y1ptZjVrdjBoQnR2dkxHd3lTYWJaSCszL3ZyclowdTV0YlFFMjFOUFBaVXQyOU9yVjYvc3R1SnliTTJYWUN0ZGNpMlcwT3JXclZ0aDhPREJoU09QUExMdzl0dHZOOWtubGk3YWVPT05GeW5uNHBhR2E2NnVycTR3ZnZ6NGJQbXRlSng0bmNhT0hkdGtlYVJsV1lKdFNmZHR5ZC8rOXJmQ3pqdnZuTjFIWE9JMWlHV1Rubjc2NlVYMi9kNzN2cGU5ZHV1c3M4NWk3eStXcG9vbHgyS0pxSjQ5ZXhaR2pCaFJPUFRRUXdzUFBQREFVcFg1dnZ2dXl4NHJsc1piR3EzVjFlYnV1T09Pd280NzdwaVZjOUNnUWRuekxsMENzRFhQUC85OHRqeFgxSy80MitPUFB6NTdMZU54N3Jubm5pYjdQdnp3dzRWUGZlcFQyZkppc1d4aDFKWFBmZTV6aFlrVEp6YnVVNnpEelpjYlcxeDlYWkxqdHJqNkd1NjY2NjdDRGp2c2tKVi90ZFZXSzN6bk85OXBYRWF4ZEFteVdiTm1GVDcvK2M5bnkrdkZiY1Y2M3RJU2JPR21tMjRxN0xUVFR0bjk5dXZYcjdEdnZ2c1dubnp5eVNiN0xPbHpqZGZuazUvOFpGYStlTC9IejRNUFByand6RFBQRkpiRWlTZWVtTjNmajMvODR5YmJvLzdHOXRLbHZoYTNCTnZpbm45eDMxak9yOVRpWHBmbTRyT2wrQmtZUzAvR2V5WStzK0wrbXk4ZEdVdkl4YkdNZWhyTElmN2dCejhvL081M3YxdWtYaXpwTVMzV2kzaFB4cEtIY2IveHVQRVoyTnpmLy83M3drWWJiWlF0NzFmNnZPS1l4aEpvVWZaNERySEVZaXkzMS95NUwxaXdvSERNTWNkazc1RllucTMwZmRqUzUvdEREejJVdlJaeHY3RjAzTzY3NzE2NCsrNjdXNnduc1VUY2h4MC9nRTd4ejdMRmV3Q2cxSC8rODUrc2EvTWYvdkNIckhXK0VrUlBrSmlGUGxybG84VWM4bWkzM1hiTGxreUxvUWdBMWM2WWRBQm9JekcrTzdvV3h4anNQR3ErbG5xTVNZK3V1YkUwbW9BT0FQbGdURG9BTEtjWW94MHpwOGZZMktPUFBucVpaZ1R2Q0hIeUlOWnBqdGIrbUZnc0pxR0xPUnVhVCtnRkFKU1BrQTRBeXluV2o0NFpuV05XNjVqTUw2OWlFcXlZRkM1Q2VjeklIWk4vWFg3NTVZdE1xQWNBbEk4eDZRQUFBSkFUeHFRREFBQkFUZ2pwQUFBQWtCTTFOeWE5dnI0K3ZmYmFhNmx2Mzc2cFU2ZE81UzRPQUFBQVZhNVFLS1IzMzMwM3JiYmFhcWx6NTliYnltc3VwRWRBSHpac1dMbUxBUUFBUUkxNStlV1gwK3Fycjk3cVBqVVgwcU1GdmZqaTlPdlhMK1ZWWFYxZHV2SEdHOU9lZSs2WnVuWHJWdTdpd0NMVVVTcUJla3JlcWFQa25UcEszdFZWU0IyZE9YTm0xbGhjektPdHFibVFYdXppSGdFOTd5RzlkKy9lV1JuelhObW9YZW9vbFVBOUplL1VVZkpPSFNYdjZpcXNqaTdKa0dzVHh3RUFBRUJPQ09rQUFBQ1FFMEk2QUFBQTVFVE5qVWtIQUFDb0Znc1hMc3pHWmRlcXVycTYxTFZyMXpSMzd0enN0U2luR0JQZnBVdVg1YjRmSVIwQUFLQUN6Wm8xSzczeXlpdlpHdHkxcWxBb3BDRkRobVNyZHkzSnBHenRLUjQvbGxmcjA2ZlBjdDJQa0E0QUFGQmhvdFU0QW5yTWJENW8wS0N5QjlSeXFhK3Z6MDVXUkREdTNMbHpXVThXVEo4K1BUc202NjY3N25LMXFBdnBBQUFBRmRqTk80SmhCUFJldlhxbFdsVmZYNS9tejUrZmV2YnNXZGFRSHVKWXZQamlpOW14V1o2UWJ1STRBQUNBQ2xXckxlalZmQ3lFZEFBQUFNZ0pJUjBBQUFCeVFrZ0hBQUNBbkJEU0FRQUE2QkNISG5wb05uYTcrZVhaWjU4dGQ5Rnl3K3p1QUFBQWRKaTk5dG9yWFhycHBZdk1qRTRETGVrQUFBQjBtQjQ5ZXFRaFE0WTB1U3h1eWJMTExyc3M5ZS9mUC8zem4vOU02NisvZnJZdS9HYys4NWswZS9iczlQdmYvejZ0dmZiYWFmanc0ZW5ZWTQvTjFvNHZtamR2WGpyaGhCUFMwS0ZEMHdvcnJKQzIzMzc3ZE91dHR6YmUvdWFiYjZhRER6NDR1ejN1YzlOTk4wMS8vZXRmbXp6MmJydnRscjc1elcrbTczem5PMm5BZ0FGWk9VODc3YlJVRXkzcEYxeHdRZnJKVDM2U3BreVpramJmZlBQMGkxLzhJbTIzM1hhTFBVaUhIWGJZSWdkNTd0eTVIVlJhQUFDQS9ObG1tMjJ5VE5YUklydys4TUFEN1hiL3MyZlBUai8vK2MvVDVaZGZudDU5OTkzMHFVOTlLaDF3d0FHTjRmM3h4eDlQWThhTVNUdnZ2SE02OE1BRHM3ODUrdWlqMDVOUFBwbjl6V3FyclphdXVlYWFyQVgvc2NjZVMrdXV1MjZXSDdmZWV1dDAwa2tucFg3OStxWHJycnN1ZmVsTFgwb2pSb3hva2tYalJNQnh4eDJYN3IzMzNqUnAwcVNzdS81T08rMlU5dGhqaitvTjZWZGNjVVgycEMrNjZLTHM3TWI1NTUrZlJvOGVuWjUrK3VtMHlpcXJ0UGczOFNMRzdVWFdCZ1FBQUdwZEJQUlhYMzAxNVYwRTZ6NTkralJlLy9qSFA1NnV1dXFxeGU1ZlYxZVhMcnp3d2l4QWgyaEovK01mLzVpbVRwMmF0WUt2dnZycVdhdjNMYmZja29YMHlaTW5aOTNwNDJjRTlCQ3Q2amZjY0VPMi9Zd3p6c2hhMEdOYjBUSEhISlArL2U5L3B5dXZ2TEpKU045c3M4M1N1SEhqc3Q4ajNQL3lsNzlNRXlkT3JPNlFmdTY1NTZiRER6KzhzWFU4d25xY3hiamtra3ZTeVNlZjNPTGZSQ2lQc3pWVmJkYXMxT090dDFKNi9mV1V1blZMS2JwL0RCeVlVbWNqRkFBQWdFV1ZLeU10N2VQdXZ2dnVXZWd1aXU3b3JlbmR1M2RqUUErREJ3L091cmhIMEsrdnIyL2NObTNhdE96M2FDMlBydS9ycmJkZWsvdUpMdkFycjd4eTludmNIbUU5UW5tYzJKZy9mMzUyZXp4V3FRanBwVlpkZGRYR3g2bktrQjR2eElNUFBwakdqaDNidUsxejU4NXAxS2hSV1ZlQ3haazFhMVphYzgwMXN3T3kxVlpiWlMvdXhodHYzT0srOFVMSHBXam16Sm1OWjJQaWtsY0xKazlPL1o5OU50WDM3WnNXdkQ4K294QVZjOE1OeTEwMHlCVGZQM2wrSDRGNlN0NnBvK1NkT3BwZmNVd0toVUtXaVlwQjliNzc3aXRiZVlwbCtEQlI1Z2pDTVpaOFNmNit2cjQrZGV2V2JaSGJpOXZpL29vTnVSRzhZMXRrdmhqamZ2Lzk5eTh5MXIwWTdNOCsrK3owczUvOUxHczBqdkhvY2FMZzI5LytkcFlkU3grcmE5ZXVpengyOFhGYUttdVVKNDVOODhkZG12ZFFXVVA2RzIrOGtUM0JPT3RSS3E0LzlkUlRMZjVOVEJZUXJleHhSdU9kZDk1SjU1eHpUdHB4eHgzVEUwODhrWFZ6YU83TU04OU00OGVQWDJUN2pUZmV1TWhaa2p6cE9YMTY2dDIzYjdydjJXZFQ1L256VTVkNTg5TGNGMTVJNzd6d1FybUxCazFNbURDaDNFV0FENldla25mcUtIbW5qdVpQaE1kb3dZNEd6R2o4ckJRUlZoY3NXTkRZZVBwaDVzNmRtd1hmMHYwalNFZU9MTjFXZXIvUkxUMXVmK0dGRjdLczJGenNjOXR0dDJYZDdQZmJiNy9HZ0IxRHFpTnZGdTgzN2k5ZTI5TEhpVzN4V0MyVlAvYWRNMmRPdXYzMjI3UDltbytycjVqdTdrdHI1TWlSMmFVb1h2UU5OOXd3WFh6eHhla0hQL2pCSXZ0SEszMk1lUytLRjNQWXNHRnB6ejMzek1hMjUxVWMrUGd3akxFTzNWNStPWFY2OHNsVUdEbzBwUzIzTEhmUllORTZHa015SUlmVVUvSk9IU1h2MU5IOGl2RDY4c3N2WnkzRFBYdjJUSlVpNmxHY1lGalNMTmF6Wjgrc2xieDAvNWc0UEZxcVkxc0UrSmhNcnZSK283ZjE1ei8vK1hUVVVVZGxFNVJ2dWVXV2FmcjA2ZW5tbTIvT1dzMzMyV2VmTEVQKzdXOS95eWFkVzJtbGxkSjU1NTJYN1JNOXRJdVBGZmZYdlh2M0pvOGQyK0t4V2lwL0hKTmV2WHFsWFhiWlpaRmpzcVFuSmJMSFNHVTBjT0RBN01XTkFmK2w0dnFTam11SUZ5aGU5R2VmZmJiRjIrTUF4cVdsdjZ1RUQ1ckdjbmJ0Mm5DcGdESlRXeXJsdlVSdFUwL0pPM1dVdkZOSDh5ZGFpaU84eG5EaHVGU0tLSE94M0V1aTgvdjdsZTVmbkRnOHRwVjJPeSs5MzFnVjdJYy8vR0U2OGNRVHN6SG5rVDEzMkdHSHRPKysrMmI3bkhMS0tWbExlN1NtUncvckk0NDRJdTIvLy81WmIrM21qOVg4K3VMS0g5dml0cGJlTDB2ei9pbHJTSSt6RWpIdGZjeU9GeTlJaUJjNXJzZVUrVXRhT1dOaWdMMzMzcnVkU3dzQUFNRHlpUEM4TkE0OTlORHNVaXJXS20rK1hubk0ybDRhbkNNVXg3RG5sb1kraDFqMy9OcHJyMjMxc1V2WFZTLzZzTDlwQzJYdjdoNWQwV05OdTFqVEw2YTZqeVhZM252dnZjYlozZzg1NUpCc2V2d1lXeDVPUC8zMDdBeklPdXVzazJiTW1KRjFYM2pwcFpmU1Y3LzYxVlMxaWt2TXZUOHBBZ0FBQU5XcDdDRTkxckdMdnYrbm5ucHF0cTdmRmx0c2thMWZWNXhNTHRhMkt6MGo4dmJiYjJkTHRzVytNWFlnV3VMdnZ2dnV0TkZHRzVYeFdRQUFBRUFWaFBRUVhkc1gxNzI5ZVJlREdOQWZsNXFpSlIwQUFLQW1WTTRNQXdBQUFGRGxoSFFBQUlBS0ZVdVFVVjNIUWtpdkJMcTdBd0FBSldJcDZ6Qi8vdnh5RjRYM0ZZOUY4ZGhVOUpoMEFBQUFsbHpYcmwyejliMWpFdTVZYnF5UzFrcHZTL1gxOVZrNG5qdDNibGxmZ3loSEhJczRKbkZzbG9lUURnQUFVR0U2ZGVxVVZsMTExZlRDQ3k5a1MxTFhjaGZ6T1hQbXBGNjllbVd2U1RuRlNZSTExbGhqdWNzaHBGZUNNbGMyQUFBZ2Y3cDM3NTdXWFhmZG11N3lYbGRYbDI2Ly9mYTB5eTY3WkQwS3luMDgycUkxWDBpdkpNYWtBd0FBSlNJVTl1elpNOVdxTGwyNnBBVUxGbVN2UWJsRGVsdXB6WUVMQUFBQWtFTkNlaVV3dXpzQUFFQk5FTklCQUFBZ0o0UjBBQUFBeUFraHZSTG83ZzRBQUZBVGhIUUFBQURJQ1NFZEFBQUFja0pJcndTNnV3TUFBTlFFSVIwQUFBQnlRa2dIQUFDQW5CRFNLNEh1N2dBQUFEVkJTQWNBQUlDY0VOSUJBQUFnSjRUMFNxQzdPd0FBUUUwUTBnRUFBQ0FuaFBSS2Fra0hBQUNncWducGxVUjNkd0FBZ0tvbXBBTUFBRUJPQ09rQUFBQ1FFMEo2SlRDN093QUFRRTBRMGdFQUFDQW5oUFJLb2lVZEFBQ2dxZ25wbGNBU2JBQUFBRFZCU0FjQUFJQ2NFTklyZ1luakFBQUFhb0tRRGdBQUFEa2hwQU1BQUVCT0NPa0FBQUNRRTBKNkpUQW1IUUFBb0NZSTZRQUFBSkFUUW5vbDBKSU9BQUJRRTRSMEFBQUF5QWtoSFFBQUFISkNTSzhFdXJzREFBRFVCQ0VkQUFBQWNrSklCd0FBZ0p3UTBpdUo3dTRBQUFCVlRVaXZwREhwQUFBQVZEVWhIUUFBQUhKQ1NLOEVabmNIQUFDb0NVSTZBQUFBNUlTUURnQUFBRGtocEZjQzNkMEJBQUJxZ3BBT0FBQUFPU0drVndKTHNBRUFBTlFFSWIyUzZPNE9BQUJRMVlSMEFBQUF5QWtoSFFBQUFISkNTSzhFWm5jSEFBQ29DVUk2QUFBQTVJU1FEZ0FBQURraHBGY0MzZDBCQUFCcWdwQU9BQUFBT1NHa1YxSkxPZ0FBQUZWTlNLOGt1cnNEQUFCVU5TRWRBQUFBY2tKSUJ3QUFnSndRMGl1QjJkMEJBQUJxZ3BBT0FBQUFPU0drVndJdDZRQUFBRFZCU0FjQUFJQ2M2RnJ1QXJBVW9pWDkyV2NiZmg4d29PRUNBQUJBMVJEU0swR1hMaCtFOVAvK3QrSDNybDFUMm11dkQ3ckNBd0FBVVBHRTlFclF2WHRLbTI2YTBvd1pLZFhYcC9UcXF5a3RXTkFRMm9WMEFBQ0FxaUdrVjRyaHd4dCtSamlQa0E0QUFFRFZNWEZjSlRQYk93QUFRRlhKUlVpLzRJSUwwdkRodzFQUG5qM1Q5dHR2bis2Nzc3NGwrcnZMTDc4OGRlclVLZTIvLy82cFp1amVEZ0FBVUxYS0h0S3Z1T0tLZE54eHg2Vng0OGFsaHg1NktHMisrZVpwOU9qUmFkcTBhYTMrM1lzdnZwaE9PT0dFOUpHUGZDVFZMQzNwQUFBQVZhWHNJZjNjYzg5Tmh4OStlRHJzc01QU1JodHRsQzY2NktMVXUzZnZkTWtsbHl6MmJ4WXVYSmkrOElVdnBQSGp4NmUxMTE0NzFSUXQ2UUFBQUZXcnJCUEh6WjgvUHozNDRJTnA3Tml4amRzNmQrNmNSbzBhbFNaTm1yVFl2enY5OU5QVEtxdXNrcjd5bGEra08rNjRvOVhIbURkdlhuWXBtamx6WnZhenJxNHV1K1JWc1d5TGxMRytQbldLeWVPaUlYMytmSzNwNUsrT1FvNm9wK1NkT2tyZXFhUGtYVjJGMU5HbEtWOVpRL29iYjd5UnRZb1BIank0eWZhNC90UlRUN1g0TjNmZWVXZjYzZTkrbHg1NTVKRWxlb3d6enp3emEzRnY3c1liYjh4YTdQTnV3b1FKVFRmVTE2ZkJEenlRL1RxdHZqNFZZcjEweUZNZGhSeFNUOGs3ZFpTOFUwZkp1d2s1cjZPelo4OWU0bjByS3VHOSsrNjc2VXRmK2xMNnpXOStrd1lPSExoRWZ4T3Q5REhtdmJRbGZkaXdZV25QUGZkTS9mcjFTM2srMHhJVmJZODk5a2pkdW5YNzRJWkNJUlU3dkJkR2owNnA5RGJJUXgyRkhGRlB5VHQxbEx4VFI4bTd1Z3FwbzhVZTNia1A2UkcwdTNUcGtxWk9uZHBrZTF3Zk1tVElJdnMvOTl4ejJZUngrKzY3YitPMit2cjY3R2ZYcmwzVDAwOC9uVWFNR05Ia2IzcjA2SkZkbW9zRG1PZUR1Tmh5UnZmMll1dDUvS3lBNTBCMXE1VDNFclZOUFNYdjFGSHlUaDBsNzdybHZJNHVUZG5LT25GYzkrN2QwOVpiYjUwbVRwellKSFRIOVpFalJ5Nnkvd1liYkpBZWUreXhyS3Q3OGJMZmZ2dWwzWGZmUGZzOVdzaXJub25qQUFBQXFsYlp1N3RIVi9ReFk4YWtiYmJaSm0yMzNYYnAvUFBQVCsrOTkxNDIyM3M0NUpCRDB0Q2hRN094NWJHTytpYWJiTkxrNy92Mzc1LzliTDY5SnBnMERnQUFvS3FVUGFRZmVPQ0JhZnIwNmVuVVUwOU5VNlpNU1Z0c3NVVzY0WVliR2llVG16eDVjamJqT3dBQUFGUzdzb2YwY1BUUlIyZVhsdHg2NjYydC91MWxsMTJXYWs1MGVZOVdkQzNwQUFBQVZVVVROUUFBQU9TRWtGNkpUQjRIQUFCUWxZVDBTcWE3T3dBQVFGVVIwZ0VBQUNBbmhQUks3dTZ1SlIwQUFLQ3FDT2tBQUFDUUUwSjZKZEtTRGdBQVVKV0VkQUFBQU1nSklSMEFBQUJ5UWtpdlJMcTdBd0FBVkNVaEhRQUFBSEpDU0FjQUFJQ2NFTklya2U3dUFBQUFWVWxJQndBQWdKd1EwaXVSbG5RQUFJQ3FKS1FEQUFCQVRnanBsZHlTRGdBQVFGVVIwaXVaN3U0QUFBQlZSVWdIQUFDQW5CRFNLNUdKNHdBQUFLcVNrQTRBQUFBNUlhUlhJaTNwQUFBQVZVbElCd0FBZ0p3UTBpdVJsblFBQUlDcUpLUURBQUJBVGdqcEFBQUFrQk5DZWlYUzNSMEFBS0FxQ2VrQUFBQ1FFMEo2SmRLU0RnQUFVSldFZEFBQUFNZ0pJYjBTYVVrSEFBQ29Ta0k2QUFBQTVJU1FEZ0FBQURraHBGY2kzZDBCQUFDcWtwQU9BQUFBT1NHa1Z6SXQ2UUFBQUZWRlNLL2s3dTRBQUFCVUZTRWRBQUFBY2tKSXIwUW1qZ01BQUtoS1Fqb0FBQURraEpCZWlZeEpCd0FBcUVwQ2VpWFQzUjBBQUtDcUNPa0FBQUNRRTBKNkpUSnhIQUFBUUZVUzBnRUFBQ0FuaFBSS3BDVWRBQUNnS2ducEFBQUFrQk5keTEwQWxxTWwvZm5uVTVveUphWHUzVlBhWUlPVXVuVXJkOGtBQUFCWURrSjZKWXBRSG1iTWFMaUUvdjFUR2phc3JNVUNBQUJnK1FqcGxXampqVk5hZWVXR01la3Z2WlRTekprcExWeFk3bElCQUFDd25JVDBTdFNqUjBwcnJ0bncrNXR2Tm9SMEFBQUFLcDZKNDZxRm1kNEJBQUFxbnBCZTZTekhCZ0FBVURXRWRBQUFBTWdKSWIxYVd0SUJBQUNvZUVKNnRkRGRIUUFBb09JSjZaVk9Tem9BQUVEVkVOS3JoWlowQUFDQWlpZWtWenF6dXdNQUFGUU5JUjBBQUFCeVFraXZkTWFrQXdBQVZBMGh2VnJvN2c0QUFGRHhoUFJLWjB3NkFBQkExUkRTQVFBQUlDZUU5RXFuSlIwQUFLQnFDT21WenNSeEFBQUFWVU5JQndBQWdKd1EwcXVGN3U0QUFBQVZUMGl2ZE1ha0F3QUFWQTBoSFFBQUFISkNTSzkwV3RJQkFBQ3FocEJlNmN6dURnQUFVRFdFZEFBQUFNaUpYSVQwQ3k2NElBMGZQanoxN05remJiLzk5dW0rKys1YjdMNVhYMzExMm1hYmJWTC8vdjNUQ2l1c2tMYllZb3YweHovK3NVUExtMHU2dXdNQUFGUzhzb2YwSzY2NEloMTMzSEZwM0xoeDZhR0hIa3FiYjc1NUdqMTZkSm8yYlZxTCt3OFlNQ0I5NzN2ZlM1TW1UVXFQUHZwb091eXd3N0xMdi8vOTcxU1RqRWtIQUFDb0dtVVA2ZWVlZTI0Ni9QRERzNkM5MFVZYnBZc3V1aWoxN3QwN1hYTEpKUzN1djl0dXU2VUREamdnYmJqaGhtbkVpQkhwMkdPUFRadHR0bG02ODg0N083enNBQUFBMEphNnBqS2FQMzkrZXZEQkI5UFlzV01idDNYdTNEbU5HalVxYXluL01JVkNJZDE4ODgzcDZhZWZUai8rOFk5YjNHZmV2SG5acFdqbXpKblp6N3E2dXV5U1Y4V3lmV2daRnl4SW5SWXNTSVg1ODJQbmppa2NMRTBkaFRKU1Q4azdkWlM4VTBmSnU3b0txYU5MVTc2eWh2UTMzbmdqTFZ5NE1BMGVQTGpKOXJqKzFGTlBMZmJ2M25ubm5UUjA2TkFzZkhmcDBpWDk2bGUvU252c3NVZUwrNTU1NXBscC9QanhpMnkvOGNZYnN4Yjd2SnN3WVVLcnQ2L3cybXVwenl1dnBEbVRKNmVacjd6U1llV0NKYTJqa0FmcUtYbW5qcEozNmloNU55SG5kWFQyN05tVkVkS1hWZCsrZmRNamp6eVNaczJhbFNaT25KaU5hVjk3N2JXenJ2RE5SU3Q5M0Y3YWtqNXMyTEMwNTU1N3BuNzkrcVU4bjJtSmloWW5IN3AxNjdiNEhmLzN2OVRwNmFkVFlkaXdsRGJmdkNPTFNJMWI0am9LWmFTZWtuZnFLSG1uanBKM2RSVlNSNHM5dW5NZjBnY09ISmkxaEUrZE9yWEo5cmcrWk1pUXhmNWRkSWxmWjUxMXN0OWpkdmYvL3ZlL1dZdDVTeUc5UjQ4ZTJhVzVPSUI1UG9oTFhNNjRyV3ZYaHA4VjhIeW9QcFh5WHFLMnFhZmtuVHBLM3FtajVGMjNuTmZScFNsYldTZU82OTY5ZTlwNjY2MnoxdkNpK3ZyNjdQcklrU09YK0g3aWIwckhuZGNVczdzREFBQlVqYkozZDQrdTZHUEdqTW5XUHQ5dXUrM1MrZWVmbjk1Nzc3MXN0dmR3eUNHSFpPUFBvNlU4eE0vWU4yWjJqMkIrL2ZYWFordWtYM2poaGFtbVF6b0FBQUFWcit3aC9jQUREMHpUcDA5UHA1NTZhcG95WlVyV2ZmMkdHMjVvbkV4dTh1VEpXZmYyb2dqdzMvakdOOUlycjd5U2V2WHFsVGJZWUlQMHB6LzlLYnVmbXFZbEhRQUFvT0tWUGFTSG80OCtPcnUwNU5aYmIyMXkvWWMvL0dGMjRYMWEwZ0VBQUtwR1djZWswNGEwcEFNQUFGUThJUjBBQUFCeVFraXZkR1ozQndBQXFCcENlcVV6SmgwQUFLQnFDT25WUWtzNkFBQkF4UlBTSzUyV2RBQUFnS29ocEZjTExla0FBQUFWVDBpdmRGclNBUUFBcW9hUVhpMjBwQU1BQUZROEliM1NhVWtIQUFDb0drSjZ0ZENTRGdBQVVQR0U5RXFuSlIwQUFLQzJRL3B6enoyWHZ2Lzk3NmVERHo0NFRaczJMZHYycjMvOUt6M3h4Qk50WFQ2V2xKWjBBQUNBMmd2cHQ5MTJXOXAwMDAzVHZmZmVtNjYrK3VvMGE5YXNiUHQvL3ZPZk5HN2N1UFlvSTYzUmtnNEFBRkM3SWYza2swOU9QL3poRDlPRUNSTlM5KzdkRzdkLzlLTWZUZmZjYzA5Ymw0OGxOWGR1U3ErOGt0S3JyNlkwZjM2NVN3TUFBTUF5NkxxMGYvRFlZNCtsdi96bEw0dHNYMldWVmRJYmI3eXhMR1ZnZVhSKy96ekx1KyttOVBERERiOFBIcHpTZHR1VnRWZ0FBQUIwUUV0Ni8vNzkwK3V2djc3STlvY2ZmamdOSFRwMEdZckFjaGswS0tWaHd4cCtycmppQjYzcUFBQUFWSDlJUCtpZ2c5SkpKNTJVcGt5WmtqcDE2cFRxNit2VFhYZmRsVTQ0NFlSMHlDR0h0RThwV2J5dVhWUGFZb3VVZHRnaHBRMDNMSGRwQUFBQTZNaVFmc1laWjZRTk50Z2dEUnMyTEpzMGJxT05Oa3E3N0xKTDJuSEhIYk1aMzhrQk03MERBQURVeHBqMG1DenVONy81VFRybGxGUFM0NDgvbmdYMUxiZmNNcTI3N3JydFUwS1duSm5lQVFBQWFpdWtGNjJ4eGhyWmhSelNrZzRBQUZBYklmM0xYLzV5cTdkZmNza2x5MU1lMnFJbFhVZ0hBQUNvalpEKzl0dHZON2xlVjFlWGRYdWZNV05HdGxZNlpTU2tBd0FBMUZaSXYrYWFheGJaRmpPOEgzbmtrV25FaUJGdFZTNEFBQUNvT1ozYjVFNDZkMDdISFhkY091Kzg4OXJpN2xoV1d0SUJBQUFxV3B1RTlQRGNjOCtsQlFzV3ROWGRzU3pNN2c0QUFGQmIzZDJqeGJ4VW9WQklyNy8rZXJydXV1dlNtREZqMnJKc0xDc3Q2UUFBQUxVUjBoOSsrT0ZGdXJvUEdqUW8vZlNuUC8zUW1kOXBaN3E3QXdBQTFGWkl2K1dXVzlxbkpDdy8zZDBCQUFBcVdwdU5TU2RIdEtRREFBQlViMHY2bGx0dW1Ub3RZU3Z0UXc4OXRMeGxZbGxwU1FjQUFLaitrTDcvL3Z1M2YwbG9PMXJTQVFBQXFqZWtqeHMzcnYxTHd2SXpjUndBQUVCRk15YTltdWp1RGdBQVVGdXp1eTljdURDZGQ5NTU2Y29ycjB5VEowOU84K2ZQYjNMN1cyKzkxWmJsWTFsb1NRY0FBS2lObHZUeDQ4ZW5jODg5TngxNDRJSHBuWGZlU2NjZGQxejYxS2MrbGEyWGZ0cHBwN1ZQS1ZreVd0SUJBQUJxSzZULytjOS9Uci81elcvUzhjY2ZuN3AyN1pvT1B2amc5TnZmL2phZGV1cXA2WjU3N21tZlVySjB0S1FEQUFEVVJraWZNbVZLMm5UVFRiUGYrL1RwazdXbWgwOTg0aFBwdXV1dWEvc1NzdVJNSEFjQUFGQmJJWDMxMVZkUHI3LytldmI3aUJFajBvMDMzcGo5ZnYvOTk2Y2VQWHEwZlFsWmNycTdBd0FBMUZaSVArQ0FBOUxFaVJPejM0ODU1cGgweWltbnBIWFhYVGNkY3NnaDZjdGYvbko3bEpHbHBTVWRBQUNnTm1aM1ArdXNzeHAvajhuajFseHp6WFQzM1hkblFYM2ZmZmR0Ni9LeE5IUjNCd0FBcUsyUVBuZnUzTlN6WjgvRzZ6dnNzRU4yQVFBQUFEcTR1L3NxcTZ5U3hvd1preVpNbUpEcTYrdmJwMVFzLzVoMHJla0FBQURWSDlKLy8vdmZwOW16WjZkUGZ2S1RhZWpRb2VsYjMvcFdldUNCQjlxbmRDd2RFOGNCQUFEVTNzUnhWMTExVlpvNmRXbzY0NHd6MHBOUFBwbDFkMTl2dmZYUzZhZWYzajZsWk9scFNRY0FBS2ora0Y3VXQyL2ZkTmhoaDJWTHNEMzY2S05waFJWV1NPUEhqMi9iMHJGMHRLUURBQURVWmtpUENlU3V2UExLdFAvKys2ZXR0dG9xdmZYV1crbkVFMDlzMjlLeGRJeEpCd0FBcUszWjNmLzk3Mytudi96bEwrbmFhNjlOWGJ0MlRaLzV6R2V5MXZSZGR0bWxmVXJJc2hIU0FRQUFxaitreDVqMFQzemlFK2tQZi9oRDJudnZ2Vk8zYnQzYXAyUXNQZDNkQVFBQWFpdWt4NFJ4TVI2ZG5OT1NEZ0FBVVAxajBnWDBITk9TRGdBQVVKc1R4NUZESm80REFBQ29hRUo2dFJMU0FRQUFLbzZRWG0xMGVRY0FBS2ora1A3ODg4K25ndGJaeXVGWUFRQUFWRzlJWDNmZGRkUDA2ZE1icng5NDRJSFpUTy9rakpaMEFBQ0E2Zy9welZ2UnI3LysrdlRlZSsrMVI1bG9DeSsrR04wZlVwbzJyZHdsQVFBQW9MM1dTU2ZudW5SSnFiNCtwZi85NzROdG8wYWwxS3RYT1VzRkFBQkFXN2FrZCtyVUticzAzMGJPYkw1NVNxdXYzbkRwL1A3aHJhc3JkNmtBQUFCb3k1YjA2TzUrNktHSHBoNDllbVRYNTg2ZG03Nys5YStuRlZaWW9jbCtWMTk5OVpMZUplMWgxVlViTHVHTk4rSkFtVVFPQUFDZzJrTDZtREZqbWx6LzRoZS8yQjdsb1MwVmV6b0k2UUFBQU5VVjBpKzk5TkwyTFFudFIwZ0hBQUNvcmpIcFZDQnpCZ0FBQUZRVUliMmE2ZTRPQUFCUVVZVDBhaWFrQXdBQVZCUWh2Wm9KNlFBQUFCVkZTQWNBQUlDY0VOS3JtWlowQUFDQWlpS2tWek1oSFFBQW9LSUk2ZFZNU0FjQUFLZ29Ram9BQUFEa2hKQmV6YlNrQXdBQVZCUWh2Wm9KNlFBQUFCVWxGeUg5Z2dzdVNNT0hEMDg5ZS9aTTIyKy9mYnJ2dnZzV3UrOXZmdk9iOUpHUGZDU3R0TkpLMldYVXFGR3Q3bC9UaEhRQUFJQ0tVdmFRZnNVVlY2VGpqanN1alJzM0xqMzAwRU5wODgwM1Q2TkhqMDdUcGsxcmNmOWJiNzAxSFh6d3dlbVdXMjVKa3laTlNzT0dEVXQ3N3JsbmV2WFZWenU4N0JWRFNBY0FBS2dJWlEvcDU1NTdianI4OE1QVFlZY2RsamJhYUtOMDBVVVhwZDY5ZTZkTExybWt4ZjMvL09jL3AyOTg0eHRwaXkyMlNCdHNzRUg2N1c5L20rcnI2OVBFaVJNN3ZPd1YwNUlPQUFCQVJlaGF6Z2VmUDM5K2V2REJCOVBZc1dNYnQzWHUzRG5yd2g2dDVFdGk5dXpacWE2dUxnMFlNS0RGMitmTm01ZGRpbWJPbkpuOWpMK0pTMTRWeTdZOFpleTBjR0ZLQ3hha3d2ejVjVWR0V0Rwb216b0s3VTA5SmUvVVVmSk9IU1h2Nmlxa2ppNU4rY29hMHQ5NDQ0MjBjT0hDTkhqdzRDYmI0L3BUVHoyMVJQZHgwa2tucGRWV1d5MEw5aTA1ODh3ejAvang0eGZaZnVPTk4yWXQ5bmszWWNLRVpmN2JsWjU1Sm5XZk1TTzk4K2FiYWU2Z1FXMWFMbWlMT2dvZFJUMGw3OVJSOGs0ZEplOG01THlPUnVOeVJZVDA1WFhXV1dlbHl5Ky9QQnVuSHBQT3RTUmE2V1BNZTJsTGVuRWNlNzkrL1ZLZXo3UkVSZHRqanoxU3QyN2RsdWsrT2cwY21OSzBhYW13MldZcHJiRkdtNWVSMnRZV2RSVGFtM3BLM3FtajVKMDZTdDdWVlVnZExmYm96bjFJSHpod1lPclNwVXVhT25WcWsrMXhmY2lRSWEzKzdUbm5uSk9GOUp0dXVpbHRGaUYwTVhyMDZKRmRtb3NEbU9lRDJDYmxqTC9yMnJYaFp3VThWeXBUcGJ5WHFHM3FLWG1uanBKMzZpaDUxeTNuZFhScHlsYldpZU82ZCsrZXR0NTY2eWFUdmhVbmdSczVjdVJpLys3c3M4OU9QL2pCRDlJTk45eVF0dGxtbXc0cWJRV3lCQnNBQUVCRktYdDM5K2lLUG1iTW1DeHNiN2ZkZHVuODg4OVA3NzMzWGpiYmV6amtrRVBTMEtGRHM3SGw0Y2MvL25FNjlkUlQwMS8rOHBkc2JmVXBVNlprMi92MDZaTmRLQ0drQXdBQVZKU3loL1FERHp3d1RaOCtQUXZlRWJoamFiVm9JUzlPSmpkNTh1UnN4dmVpQ3krOE1Kc1Yvak9mK1V5VCs0bDExazg3N2JRT0wzK3VDZWtBQUFBVnBld2hQUng5OU5IWnBTVXhLVnlwRjE5OHNZTktCUUFBQUIycnJHUFNhV2RhMGdFQUFDcUtrRjdOaEhRQUFJQ0tJcVJYTXlFZEFBQ2dvZ2pwQUFBQWtCTkNlalhUa2c0QUFGQlJoUFJxSnFRREFBQlVGQ0c5RmtMNm5Ea3B6WmlSMHF4WjVTNFJBQUFBZVY4bm5YWU82Wk1uTjF6Q1pwdWx0T2FhWlMwV0FBQUFMZE9TWHMxV1d5MmxQbjFTNnRVcnBhN3ZuNDk1OTkxeWx3b0FBSURGMEpKZXpRWU1TR24zM1J0K2YvcnBsSjU1eHZoMEFBQ0FITk9TWGl0TUlnY0FBSkI3UW5xdEVOSUJBQUJ5VDBpdk5VSTZBQUJBYmducHRVSkxPZ0FBUU80SjZiV2k4L3VIV2tnSEFBRElMU0c5MWdqcEFBQUF1U1drMXdyZDNRRUFBSEpQU0s4VlFqb0FBRUR1Q2VtMUZ0SUJBQURJTFNHOVZtaEpCd0FBeUQwaHZWWUk2UUFBQUxrbnBOY0tJUjBBQUNEM2hQUmFJYVFEQUFEa25wQmVLNFIwQUFDQTNCUFNhNFdRRGdBQWtIdENlcTBRMGdFQUFISlBTSzhWUWpvQUFFRHVDZW0xUWtnSEFBRElQU0c5VmdqcEFBQUF1U2VrMXhvaEhRQUFJTGVFOUZxaEpSMEFBQ0QzaFBSYTBmbjlReTJrQXdBQTVKYVFEZ0FBQURraHBOY0szZDBCQUFCeXIydTVDMEFIaC9TRkMxTjY2NjJHMzFkY01hVXVYY3BhTEFBQUFENGdwTmZhbVBSNTgxSzY2NjRQUXZvdXU1UzFXQUFBQUh4QWQvZGEwYmR2U29NSHA3VENDaW4xNnRXd2JkYXNjcGNLQUFDQUVsclNhNm03KzNiYk5mdytaMDVLTjkxa2ZEb0FBRURPYUVtdlJTYVJBd0FBeUNVaHZSWUo2UUFBQUxra3BOZnlKSEpCVUFjQUFNZ05JYjJXVzlLRGtBNEFBSkFiUW5vdEV0SUJBQUJ5U1VpdjlaQmVYMS9Pa2dBQUFGQkNTSzlGV3RJQkFBQnlTVWl2UlVJNkFBQkFMZ25wdGNveWJBQUFBTGtqcE5jcUlSMEFBQ0IzaFBSYUphUURBQURranBCZXF6cS9mK2lGZEFBQWdOd1EwbXVWbG5RQUFJRGNFZEpyUGFSYkp4MEFBQ0EzaFBSYXBTVWRBQUFnZDRUMFdpV2tBd0FBNUk2UVhxdUVkQUFBZ053UjBtdVZrQTRBQUpBN1FucXRFdElCQUFCeXAydTVDMENaMTBtZk5pMmxPWE5TNnRFanBVR0R5bDBxQUFDQW1pYWsxM3BJZi9iWkQ3YnR0Rk5LQXdhVXJVZ0FBQUMxVG5mM1dyWGVlaWtOSHB6U0txdWsxSzFidzdab1VRY0FBS0JzdEtUWHFnam9jUW4zM0pQUzlPbkdwd01BQUpTWmxuUk1JZ2NBQUpBVFFqb2ZqRSt2cnk5M1NRQUFBR3Fha0k2V2RBQUFnSndRMHRHU0RnQUFrQk5DT2xyU0FRQUFja0pJNTRPV2RDRWRBQUNncklSMFBtaEoxOTBkQUFDZ3JJUjBkSGNIQUFESUNTRWQzZDBCQUFCeVFraEhkM2NBQUlDY0VOTFJrZzRBQUpBVFFqcGEwZ0VBQUhLaTdDSDlnZ3N1U01PSEQwODllL1pNMjIrL2ZicnZ2dnNXdSs4VFR6eVJQdjNwVDJmN2QrclVLWjEvL3ZrZFd0YXFaZUk0QUFDQVhDaHJTTC9paWl2U2NjY2RsOGFORzVjZWV1aWh0UG5tbTZmUm8wZW5hZE9tdGJqLzdObXowOXBycjUzT091dXNOR1RJa0E0dmI5WFMzUjBBQUNBWHloclN6ejMzM0hUNDRZZW53dzQ3TEcyMDBVYnBvb3N1U3IxNzkwNlhYSEpKaS90dnUrMjI2U2MvK1VrNjZLQ0RVbzhlUFRxOHZGVkxkM2NBQUlCYzZGcXVCNTQvZjM1NjhNRUgwOWl4WXh1M2RlN2NPWTBhTlNwTm1qU3B6UjVuM3J4NTJhVm81c3laMmMrNnVycnNrbGZGc25WSUdSY3NTSjBXTEVocHlwU1U0clh2MUNrVjFsb3JwUUVEMnYreHFWZ2RXa2RoR2FtbjVKMDZTdDZwbytSZFhZWFUwYVVwWDlsQytodHZ2SkVXTGx5WUJnOGUzR1I3WEgvcXFhZmE3SEhPUFBQTU5INzgrRVcyMzNqampWbXJmZDVObURDaDNSK2o1MXR2cFJXZmZiYkp0bm45KzZjWjY2M1g3bzlONWV1SU9nckxTejBsNzlSUjhrNGRKZThtNUx5T3h0RHQzSWYwamhJdDlUSHV2YlFsZmRpd1lXblBQZmRNL2ZyMVMzaysweElWYlk4OTlramR1blZyM3dlTHNlaFRwMGIzaHBUZWZqdDFldm5sbEFZT1RJVWRkbWpmeDZXaWRXZ2RoV1drbnBKMzZpaDVwNDZTZDNVVlVrZUxQYnB6SGRJSERoeVl1blRwa3FaR09Dd1IxOXR5VXJnWXU5N1MrUFU0Z0hrK2lCMWV6bUhER242Ky9uckRKU2FUcTREWGgvS3JsUGNTdFUwOUplL1VVZkpPSFNYdnV1VzhqaTVOMmNvMmNWejM3dDNUMWx0dm5TWk9uTmk0cmI2K1BycytjdVRJY2hVTGs4Z0JBQUNVVFZtN3UwYzM5REZqeHFSdHR0a21iYmZkZHRtNjUrKzk5MTQyMjNzNDVKQkQwdENoUTdOeDVjWEo1cDU4OHNuRzMxOTk5ZFgweUNPUHBENTkrcVIxMWxtbm5FK2xlbGlPRFFBQW9EWkQrb0VISHBpbVQ1K2VUajMxMURSbHlwUzB4UlpicEJ0dXVLRnhNcm5Ka3lkbk03NFh2ZmJhYTJuTExiZHN2SDdPT2Vka2wxMTMzVFhkZXV1dFpYa09WYWY0ZW10SkJ3QUE2SEJsbnpqdTZLT1B6aTR0YVI2OGh3OGZuZ3BhZU51WGtBNEFBRkEyWlJ1VFRzN0hwRHNaQWdBQTBPR0VkSnJTa2c0QUFGQTJRanBOQ2VrQUFBQmxJNlRUbEpBT0FBQlFOa0k2VFJtVERnQUFVRFpDT2sxcFNRY0FBQ2diSVoyV1EzcTBwR3ROQndBQXFLMTEwc2xwZC9mdy9QTU4xL3YzVDJuQWdIS1dDZ0FBb0NZSTZUVFZwVXRETUk5VzlDZWYvS0IxZmZUb2xMcXFMZ0FBQU8xSjZxS3BDT1NiYlpiU0cyODBYSC90dFlieDZYVjFRam9BQUVBN2s3cFkxQnByTkZ6Q3RHa05BZDFFY2dBQUFPM094SEVzMlVSeUN4ZVd1eVFBQUFCVlQwaW5kWlprQXdBQTZEQkNPcTBUMGdFQUFEcU1rRTdyaEhRQUFJQU9JNlRUT2lFZEFBQ2d3d2pwdEU1SUJ3QUE2REJDT3EwVDBnRUFBRHFNa0U3cmhIUUFBSUFPSTZUVHVpNWRHbjRLNlFBQUFPMnVhL3MvQkZYUmt2N29veWs5OWxoSzNicWx0TzIyS2EyMFVybExCZ0FBVUhXMHBOTzZZaGd2RkJwYTArZk5TMm5hdEhLWENnQUFvQ3BwU2FkMWE2K2QwdENoRFFIOW1XZFNtanhaMTNjQUFJQjJJcVR6NFhyMGFQcHo0Y0t5RmdjQUFLQmE2ZTdPa2pQVE93QUFRTHNTMGxuNm1kNjFwQU1BQUxRTElaMGxweVVkQUFDZ1hRbnBMRGt0NlFBQUFPMUtTR2ZwUTdxV2RBQUFnSFlocExQMDNkMjFwQU1BQUxRTFM3Q3g5QzNwNzd5VDBoMTNwTlNwVTBwcnJORndBUUFBWUxrSjZTeTUzcjAvYUVtZk1hUGg5M256aEhRQUFJQTJJcVN6NVByMFNXblhYVk9hTTZmaDh0aGpLUzFZVU81U0FRQUFWQTBobmFYVHIxL0RaZmJzaHV2R3B3TUFBTFFaRThleC9NdXhGUXJsTGcwQUFFQlZFTkpaTmwxTE9tRllrZzBBQUtCTkNPa3MzM0pzUVpkM0FBQ0FOaUdrczJ4aStUWHJwZ01BQUxRcEU4ZXhmRjNlNTg5UDZZVVhVdXJldldHSnR0VldLM2VwQUFBQUtwYVF6ckxyMXEwaHBELzMzQWZiVmxnaHBSVlhMR2VwQUFBQUtwYnU3aXk3VFRkTmFZMDFVaG8ycktFbFBjeWRXKzVTQVFBQVZDd3Q2U3k3UVlNYUxtSFNwSlRlZUNPbEJRdktYU29BQUlDS3BTV2R0bDJTVFVnSEFBQllaa0k2YmFOTGw0YWZRam9BQU1BeUU5SnAyNVoweTdFQkFBQXNNMlBTYWR1US91cXJLYzJjMmRDeVBtSkVTdjM2bGJ0a0FBQUFGVU5JcDIzMDZ0WHdjOWFzaGt2UmxsdVdyVWdBQUFDVlJraW5iY1JTYkxFTVcxMWRTbSsvbmRJcnJ6U3NvUTRBQU1BU0U5SnBHOUc5ZmVqUWh0OTc5R2dJNlNhUkF3QUFXQ29tanFQdGRldlc4RE5hMVFFQUFGaGlXdEpwdjVBZTNkM256R240dldmUGxEcDFLbXV4QUFBQThrNUlwLzFtZXA4M0w2V2JibXI0UFdaNTMzWFhzaFlMQUFBZzczUjNwKzMxN3AzU2dBRXBkZTdjY0FteExKdnU3d0FBQUszU2trN2JpMjd0TyszMHdmWHJyMDlwNGNLRzd1L0ZydkFBQUFBc1FrczY3UytXWmd1V1pBTUFBR2lWbG5RNkpxVEhCSExQUHRzd2dWeGNIekhpZzdIckFBQUFaS1FrMmwrdlhpbTk4MDVLVTZZMDNiYkdHdVVzRlFBQVFPNEk2YlMvalRkT2FjVVZVeW9VVXBvMkxhVVpNejVZbWcwQUFJQkdRam9kTTl2N2V1dDljRDFDZWl6UEJnQUFRQk5DT2gyclI0K0duNis4a3RMMDZRMHp3Y2Y0OURYWExIZkpBQUFBeWs1SXo2a1hYM3d4dmZycXErbVpaNTVKM2JwMVN6MTY5RWhyVmtPUTdkKy80V2NzeVRaN2RzUHZ6ejh2cEFNQUFBanArYlh2dnZ1bXA1OSt1c20yTDM3eGkrbVBmL3hqcXZpUS9yR1BOWFIzbnpzM3BRY2VhUGdKQUFDQWRkSXJ5Wi8rOUtjMHB4b21YSXN4Nml1dGxOS2dRUTNYRnl4STZaWmJHaTczMzU5U2ZYMjVTd2dBQUZBV1d0SnozSksrMm1xcnBhRkRoNlo3N3JrblBSdHJqS2VVeG80ZG0vcjM3NSsyM25ycmJKK0tGdXVrOSttVDBxeFpEWmNRUDJPNXRnanhBQUFBTlVaSXo2a3p6amdqWFgvOTlXbnZ2ZmRPNDhlUFR6LzYwWSt5N1QvNzJjOGE5N25qamp2U3pqdnZuQ3BhbEgvbXpJYmZuM3l5WWViM21GVHV2ZmRTNnRJbHBWVldhZmdKQUFCUUEzUjNyd0NMYXpHLytPS0wwMVZYWFpVbVRweVlGa1NYOFVyVXJWdEtLNi9jY0ltMTFNT0xMNmIwOE1NTjQ5V2ZlNjdjSlFRQUFPZ3dRbm9GMkg3NzdkTUxMN3lRYnJqaGh2VGIzLzYyeVJqMXozM3VjMm5VcUZIcHBKTk9TaFZ2cmJWU0dqS2tZYXg2djM0TjI2Wk9UZW5WVnhzdXhkbmdBUUFBcXBUdTdoVmkrUERoMldYKy9QbnB0Tk5PUzY5RWwvQVM1NTU3YnRhYTNybHo1N1RmZnZ1bDNYZmZQVldjdm4xVDJuYmJodC9mZWl1bHUrNXE2UDcrMEVNTjIzcjFTbW5VcUxJV0VRQUFvRDBKNlJXbWUvZnU2YmJiYmt2Ly9PYy9zMUIrL1BISE45NzI4NS8vUFB0NS92bm5wM3Z2dlRjTkhqdzREUm8wS1BXTzJkUXJUVXdjTjN6NEJ4UEt2ZmxtU2pHei9iMzNwdFM1Yzd3UUtXMjhjY1BrY3dBQUFGVkN3cWxBYTYrOWR2cm1ONytaL1I0Qi9NZ2pqMnl4aTN6eDloaXp2c01PTzZTSzBxbFRTcHR1K3NIMWFGV1AxdlZwMHo3WUZtRjl3SUNHbndNSE5veHZCd0FBcUdER3BGZTRyMy85NituNTU1L1BsbWs3ODh3ekY3bDk5dXpaYWVUSWtkbXliYXV1dW1yNjFhOStsU3JTMWx1bnRQbm1EWmRWVi8xZ2dybm9DaDhUek4xK2UwTnJlMXptemkxM2FRRUFBSmFKbHZRcXNOWmFhMldYN2JiYkx2WHAweWRibXEydXJpNWRjODAxamZ1ODg4NDcyZVdvbzQ3S0x0RnRmdlhWVjArWFhYWlo2dHUzYnhvd1lFQmFZNDAxVW03MTdKbFNzWHl4TEZ1b3EydVlUSzU0dWZ2dUQvYVBWdmpvRWw5Y3hpMWE1Z0VBQUhKT1NLOGluVHAxU2tjZmZYUjJDVmRlZVdVNjY2eXowcHc1YzlKVFR6M1ZaTitZZ0M1YTRIZlpaWmZHYlJIYUR6cm9vTlNsUzVkczJiZGlsL200SHZlZHE4Qyt6VFlmWEgvMDBZWVc5RkFjdy83WVl4L2NIbUU5Wm8wUDBRcGZEUGtBQUFBNWs0dVFmc0VGRjZTZi9PUW5hY3FVS1duenpUZFB2L2pGTDdKVzRjV0p0Y0ZQT2VXVTlPS0xMNloxMTEwMy9makhQMDU3NzcxM2g1YTVFc1R5YkhFSjA2Wk5TMGNjY1VTYVBIbHlkbm16R0dwTHhJeng1NXh6VHZaN3ZLWkZQWHIwU1B2c3MwODJFVjIvZnYzU2xsdHVtWVlPSFpvRjl5MjIyQ0t0c01JS3FhdzIyK3lEMzJQYytqUFBwRlFvUlBlQmh0YjIrZk5UbWp5NTRmYml6eEN0N0t1di9rR0xleXo5RmljQVFvOGVXdDhCQUlEYUMrbFhYSEZGT3U2NDQ5SkZGMTJVdGR6R3pPU2pSNDlPVHovOWRGcWxoUmJQdSsrK094MTg4TUhaK090UGZPSVQ2UzkvK1V2YWYvLzkwME1QUFpRMjJXU1RzanlIU2hDdjViWFhYdHQ0L2ZycnI4OW1pSyt2cjA4WFgzeHhxMzg3Yjk2OGRQWFZWeS8yOWdqcEVkaFhXbW1sN0tSSmRLWHYxcTFidG1SY2RMOHZQdjdLSzYvY0dQb2o1TWMrWGJ0MmJiekU5ZGcvVGdSRTYzM3hFc3ZLTGJHWVNLNTBrcnlYWC81Z2pQcnp6emNFOXFLRkMxTjY2YVVQcnBmMk5valFIa3ZDUlZDUEdlUmozZllvUjF5UDUxU2NWVDRDZmpIWXgrMFI3Z0VBQUpaUnAwSWhtaHpMSjRMNXR0dHVtMzc1eTE5bTF5TTBEaHMyTEIxenpESHA1Sk5QWG1UL0F3ODhNTDMzM250WndDeUttY3VqUlRlQy9vZVpPWE5tV25IRkZiUHgyUkVHODZwdXh4MVQzUU1QcEc0Ulh0djVzZW9MaGZSNG9aQm1GZ3BwZGtycEZ3c1dwQmtwcGFnWWQ5WFhwenpvRWljREloTy8vM3ZuOXk5ZE9uWDY0UGYzZjBaOGp0ZXNVOG5sd2ZKV2N3QUFvSjJjMXExYk9tbm16TlN6MkhpV1EwdVRROHZha2g3am9oOTg4TUUwZHV6WXhtM1JhanBxMUtnMGFkS2tGdjhtdGtmTGU2bG9lUzl0Slc3ZUNoeVgwaGNueE1ScWNjbXJ3cVJKS1d1VHJhdExDenZnOFRZdStmMWpKYi9IS3hUdHl3dFNTdStsbE81TktVMTlQOEQvTDZYMHd2dS94NnY2NnZ1L3Q0ZDREUnFPWERQQ053QUExTFRUNnVyU2xuLytjL3I0SVlla3ZGcWE3Rm5Xa1A3R0cyK2toUXNYWm1PZFM4WDE1aE9kRmNXNDlaYjJqKzB0aVc3eDQ4ZVBYMlQ3alRmZW1LMGhubGVqTzNkT25YUFFpaDBWcEhRUXdVNnQ3QnV0OE1YVElhL0ZPUGozZjU4VDQ5M2ZEOW9ScWFmSC9HN3ZCLys2OTM4V0x6UGV2NStGTFZ5S2YxUC8vdlg2a2t2cDlicjNMNFdTUzBlYzZBQUFBRHJlYWpFMVZaY3UyWkRldklxbHNTdG1USHA3aTFiNjBwYjNhRW1QN3ZSNzdybG52cnU3di90dXVtN0NoTFRISG50a1k3VXJRYS8zTDZGL1NtbWpsQjh6WnN4SXM0b3p2MmNOOElWc2FFWDhYTjVMOGY1S2xYa1VTWWRZc0dCQnV1ZWVlN0xoSmpHbkFPMmpGdXBTZTlmVGUrKzlOeHRhVmV2MVZGM0twMHFzbytwU2JXblBPcW91MFZaMTlNMDMzMHg3N2JWWHJuTlRzVWYza2lqci93WURCdzdNSmdhYk9qVTZVSDhncmc4cExwblZUR3hmbXYxamtySzROQmNITU04SHNkTEttWGVEQmczS0xyUnRsNTNvRFJNck1haWo1TG1leG4vYzhlVlNQU1d2ZGZTdHQ5N0tUbmlxbytTMWpyNzk5dHRwNU1pUjZpaTVyYVBYWDM5OTduUFQwcFJ0S2FiTmJuc3hDL2pXVzIrZEprNmMyTGd0V2pmamVud1F0Q1MybCs0ZkpreVlzTmo5QVFBQW9GS1V2VjlWZEVVZk0yWk0ybWFiYmJJV3VWaUNMV1p2UCt5d3c3TGJEem5ra0d5NXJoaGJIbzQ5OXRpMDY2NjdwcC8rOUtmWjJ0MlhYMzU1ZXVDQkI5S3ZmLzNyTWo4VEFBQUFxUENRSGt1cVRaOCtQWjE2NnFuWjVHK3hsTm9OTjl6UU9EbmM1TW1UbTZ5VHZlT09PMlpybzMvLys5OVAzLzN1ZDdOMXVXTm1kMnVrQXdBQVVPbktIdExEMFVjZm5WMWFjdXV0dHk2eTdiT2YvV3gyQVFBQWdHcFMxakhwQUFBQXdBZUVkQUFBQU1nSklSMEFBQUJ5UWtnSEFBQ0FuQkRTQVFBQUlDZUVkQUFBQU1nSklSMEFBQUJ5UWtnSEFBQ0FuQkRTQVFBQUlDZUVkQUFBQU1nSklSMEFBQUJ5UWtnSEFBQ0FuQkRTQVFBQUlDZTZwaHBUS0JTeW56Tm56a3g1VmxkWGwyYlBucDJWczF1M2J1VXVEaXhDSGFVU3FLZmtuVHBLM3FtajVGMWRoZFRSWXY0czV0SFcxRnhJZi9mZGQ3T2Z3NFlOSzNkUkFBQUFxTEU4dXVLS0s3YTZUNmZDa2tUNUtsSmZYNTllZSsyMTFMZHYzOVNwVTZlVTV6TXRjU0xoNVpkZlR2MzY5U3QzY1dBUjZpaVZRRDBsNzlSUjhrNGRKZTltVmtnZGpkZ2RBWDIxMVZaTG5UdTNQdXE4NWxyUzR3VlpmZlhWVTZXSWlwYm55Z2JxS0pWQVBTWHYxRkh5VGgwbDcvcFZRQjM5c0JiMEloUEhBUUFBUUU0STZRQUFBSkFUUW5wTzllalJJNDBiTnk3N0NYbWtqbElKMUZQeVRoMGw3OVJSOHE1SEZkYlJtcHM0RGdBQUFQSktTem9BQUFEa2hKQU9BQUFBT1NHa0F3QUFRRTRJNlFBQUFKQVRRbnBPWFhEQkJXbjQ4T0dwWjgrZWFmdnR0MC8zM1hkZnVZdEVGVHJ0dE5OU3AwNmRtbHcyMkdDRHh0dm56cDJiampycXFMVHl5aXVuUG4zNnBFOS8rdE5wNnRTcFRlNWo4dVRKYVo5OTlrbTllL2RPcTZ5eVNqcnh4QlBUZ2dVTG11eHo2NjIzcHEyMjJpcWJkWE9kZGRaSmwxMTJXWWM5UnlyTDdiZmZudmJkZDkrMDJtcXJaZlh4Mm11dmJYSjd6SFY2NnFtbnBsVlhYVFgxNnRVcmpSbzFLdjN2Zi85cnNzOWJiNzJWdnZDRkw2UisvZnFsL3YzN3A2OTg1U3RwMXF4WlRmWjU5TkZIMDBjKzhwSHNNM2JZc0dIcDdMUFBYcVFzVjExMVZmWitpSDAyM1hUVGRQMzExN2ZUczZiYTZ1bWhoeDY2eUdmclhudnQxV1FmOVpUMmN1YVpaNlp0dDkwMjllM2JOL3QvZWYvOTkwOVBQLzEwazMwNjh2OTMzMmxabGpxNjIyNjdMZkk1K3ZXdmY3MTI2bWpNN2s2K1hINzU1WVh1M2JzWExybmtrc0lUVHp4Uk9Qend3d3Y5Ky9jdlRKMDZ0ZHhGbzhxTUd6ZXVzUEhHR3hkZWYvMzF4c3YwNmRNYmIvLzYxNzllR0Rac1dHSGl4SW1GQng1NG9MREREanNVZHR4eHg4YmJGeXhZVU5oa2swMEtvMGFOS2p6ODhNT0Y2NisvdmpCdzRNREMyTEZqRy9kNS92bm5DNzE3OXk0Y2Q5eHhoU2VmZkxMd2kxLzhvdENsUzVmQ0RUZmMwT0hQbC95TE92Uzk3MzJ2Y1BYVlY4ZktJNFZycnJtbXllMW5uWFZXWWNVVlZ5eGNlKzIxaGYvODV6K0YvZmJicjdEV1dtc1Y1c3laMDdqUFhudnRWZGg4ODgwTDk5eHpUK0dPTys0b3JMUE9Pb1dERHo2NDhmWjMzbm1uTUhqdzRNSVh2dkNGd3VPUFAxNzQ2MS8vV3VqVnExZmg0b3N2YnR6bnJydnV5dXJwMldlZm5kWGI3My8vKzRWdTNib1ZIbnZzc1E1NkphamtlanBtekppc0hwWit0cjcxMWx0TjlsRlBhUytqUjQ4dVhIcnBwVm05ZWVTUlJ3cDc3NzEzWVkwMTFpak1taldydy85Lzk1MldaYTJqdSs2NmExWmZTajlINDNPeFZ1cW9rSjVEMjIyM1hlR29vNDVxdkw1dzRjTENhcXV0VmpqenpEUExXaTZxVDRUMCtKTFlraGt6Wm1SZjlxNjY2cXJHYmYvOTczK3pMNlNUSmszS3JzY0hZdWZPblF0VHBreHAzT2ZDQ3k4czlPdlhyekJ2M3J6cytuZSs4NTNzUkVDcEF3ODhNUHVBaHRZMER6LzE5ZldGSVVPR0ZIN3lrNTgwcWFjOWV2VElBa3lJLzRUajcrNi8vLzdHZmY3MXIzOFZPblhxVkhqMTFWZXo2Ny82MWE4S0s2MjBVbU1kRFNlZGRGSmgvZlhYYjd6K3VjOTlyckRQUHZzMEtjLzIyMjlmK05yWHZ0Wk96NVpLdGJpUS9zbFBmbkt4ZjZPZTBwR21UWnVXMWJmYmJydXR3LzkvOTUyV1phbWp4WkIrN0xISEZoYW4ydXVvN3U0NU0zLysvUFRnZ3c5bVhUaUxPbmZ1bkYyZk5HbFNXY3RHZFlxdXd0RmxjKzIxMTg2NlhrYlhvUkQxc0s2dXJrbGRqQzZWYTZ5eFJtTmRqSi9SdlhMdzRNR04rNHdlUFRyTm5Ea3pQZkhFRTQzN2xONUhjUi8xbWFYMXdnc3ZwQ2xUcGpTcFR5dXV1R0xXTmEyMFRrYlg0VzIyMmFaeG45Zy9Qa2Z2dmZmZXhuMTIyV1dYMUwxNzl5WjFNcnJhdmYzMjI0MzdxTGNzaitoaUdkMHYxMTkvL1hUa2tVZW1OOTk4cy9FMjlaU085TTQ3NzJRL0J3d1kwS0gvdi90T3k3TFcwYUkvLy9uUGFlREFnV21UVFRaSlk4ZU9UYk5uejI2OHJkcnJhTmV5UGpxTGVPT05OOUxDaFF1YlZMZ1ExNTk2NnFteWxZdnFGT0VteHViRWw4alhYMzg5alI4L1Bodi8rUGpqajJkaEtMNGN4aGZKNW5VeGJndnhzNlc2V3J5dHRYM2lRM1RPbkRuWnVHSllFc1U2MVZKOUtxMXZFWXhLZGUzYU5mdVB2M1NmdGRaYWE1SDdLTjYyMGtvckxiYmVGdThEV2hQanp6LzFxVTlsOWV5NTU1NUwzLzN1ZDlQSFAvN3g3RXRmbHk1ZDFGTTZUSDE5ZmZyV3Q3NlZkdHBwcHl6b2hJNzYvejFPSnZsT3k3TFUwZkQ1ejM4K3Jibm1tbGxEVXN6UGNkSkpKMlVuS2ErKyt1cWFxS05DT3RTdytOSll0TmxtbTJXaFBUNFFyN3p5U3VFWllCa2RkTkJCamI5SFMwOTh2bzRZTVNKclhmL1l4ejVXMXJKUlcySnl1RGp4ZnVlZGQ1YTdLTEJVZGZTSUk0NW84amthRThiRzUyZWMrSXpQMDJxbnUzdk9SSmVPT012ZWZJYk51RDVreUpDeWxZdmFFR2ZWMTF0dnZmVHNzODltOVMyNkFjMllNV094ZFRGK3RsUlhpN2UxdGsvTWFPeEVBRXVqV0tkYSszeU1uOU9tVFd0eWU4ejBHak5wdDBXOTlUbk1zb2poUlBIL2UzeTJCdldVam5EMDBVZW5mLzd6bittV1cyNUpxNisrZXVQMmp2ci8zWGRhbHJXT3RpUWFra0xwNTJnMTExRWhQV2VpKzlIV1cyK2RKazZjMktRYlNGd2ZPWEprV2N0RzlZdmxmK0lNWlp5dGpIcllyVnUzSm5VeHVobkZtUFZpWFl5Zmp6MzJXSk12bXhNbVRNZysvRGJhYUtQR2ZVcnZvN2lQK3N6U2lxNi84WjltYVgyS0xtc3hocmUwVHNZWHp4aGpWblR6elRkbm42UEYvK0JqbjFoQ0s4WmtsdGJKR1BZUlhZaUwrNmkzdEpWWFhua2xHNU1lbjYxQlBhVTl4WHlHRVg2dXVlYWFyRjQxSHpiUlVmKy8rMDdMc3RiUmxqenl5Q1BaejlMUDBhcXVvMldkdG80V3hWSUFNVnZ4WlpkZGxzMEFlOFFSUjJSTEFaVE9YZ2h0NGZqamp5L2NldXV0aFJkZWVDRmJ5aWVXc1lqbEsyS1d6ZUlTTGJFa3hzMDMzNXd0MFRKeTVNanMwbno1aXozMzNETmJRaU9XdEJnMGFGQ0x5MStjZU9LSjJleXhGMXh3Z1NYWVdLeDMzMzAzVzBvbEx2RmYxTG5ubnB2OS90SkxMelV1d1JhZmgzLy8rOThMano3NmFEYURka3RMc0cyNTVaYUZlKys5dDNEbm5YY1cxbDEzM1NaTFc4WE14ckcwMVplKzlLVnMrWmY0ekkwNjJueHBxNjVkdXhiT09lZWNyTjdHU2dpV3RtSko2bW5jZHNJSkoyU3paTWRuNjAwMzNWVFlhcXV0c25vNGQrN2N4dnRRVDJrdlJ4NTVaTFpVWmZ6L1hycDgxZXpac3h2MzZhai8zMzJuWlZucTZMUFBQbHM0L2ZUVHM3b1puNlB4Zi83YWE2OWQyR1dYWFdxbWpncnBPUlhyK01XSFo2emJGMHNEeERxcTBOWmlHWXBWVjEwMXEyZERodzdOcnNjSFkxRUVuMjk4NHh2Wk1rRHhJWGZBQVFka0g2S2xYbnp4eGNMSFAvN3hiUDNlQ1BnUi9PdnE2cHJzYzhzdHR4UzIyR0tMN0hIaVF6Yld4b1NXUkYySjBOUDhFa3RhRlpkaE8rV1VVN0x3RXYrcGZ1eGpIeXM4L2ZUVFRlN2p6VGZmek1KT256NTlzcVZZRGp2c3NDdzRsWW8xMW5mZWVlZnNQcUx1Ui9odjdzb3JyeXlzdDk1NldiMk5KVnl1dSs2NmRuNzJWRU05alMrWjhhVXh2aXhHWUY1enpUV3pkWGViZitGVFQya3ZMZFhOdUpUKzM5dVIvNy83VHN2UzF0SEpreWRuZ1h6QWdBSFo1OTg2NjZ5VEJlM1NkZEtydlk1MmluL0syNVlQQUFBQUJHUFNBUUFBSUNlRWRBQUFBTWdKSVIwQUFBQnlRa2dIQUFDQW5CRFNBUUFBSUNlRWRBQUFBTWdKSVIwQUFBQnlRa2dIQUFDQW5CRFNBWUFPZDlsbGw2WCsvZnVYdXhnQWtEdENPZ0RrMkpRcFU5S3h4eDZiMWxsbm5kU3paODgwZVBEZ3ROTk9PNlVMTDd3d3paNDlPMVdDNGNPSHAvUFBQNy9KdGdNUFBEQTk4OHd6WlNzVEFPUlYxM0lYQUFCbzJmUFBQNThGOG1oeFB1T01NOUttbTI2YWV2VG9rUjU3N0xIMDYxLy9PZzBkT2pUdHQ5OStaU2xib1ZCSUN4Y3VURjI3THR0WGlWNjllbVVYQUtBcExla0FrRlBmK01ZM3NoRDh3QU1QcE05OTduTnB3dzAzVEd1dnZYYjY1Q2MvbWE2NzdycTA3Nzc3WnZ2Tm1ERWpmZldyWDAyREJnMUsvZnIxU3gvOTZFZlRmLzd6bjhiN09lMjAwOUlXVzJ5Ui92akhQMmF0Mml1dXVHSTY2S0NEMHJ2dnZ0dTRUMzE5ZlRyenpEUFRXbXV0bFlYbnpUZmZQUDNmLy8xZjQrMjMzbnByNnRTcFUvclh2LzZWdHQ1NjYreGt3WjEzM3BtZWUrNjVyRHpSd3QrblQ1KzA3YmJicHB0dXVxbng3M2JiYmJmMDBrc3ZwVzkvKzl2WjM4ZGxjZDNkbzNmQWlCRWpVdmZ1M2RQNjY2K2ZsYmRVL08xdmYvdmJkTUFCQjZUZXZYdW5kZGRkTi8yLy8vZi8ydUdWQjREeUVkSUJJSWZlZlBQTmRPT05ONmFqampvcXJiRENDaTN1VXd5OG4vM3NaOU8wYWRPeUFQM2dndyttcmJiYUtuM3NZeDlMYjczMVZ1TytFYWF2dmZiYTlNOS8vak83M0hiYmJlbXNzODVxdkQwQytoLys4SWQwMFVVWHBTZWVlQ0lMMVYvODRoZXovVXFkZlBMSjJkLzk5Ny8vVFp0dHRsbWFOV3RXMm52dnZkUEVpUlBUd3c4L25QYmFhNi9zNU1Ia3laT3ovYSsrK3VxMCt1cXJwOU5QUHoyOS92cnIyYVVsMTF4elRkYXQvL2pqajArUFAvNTQrdHJYdnBZT08reXdkTXN0dHpUWmIvejQ4ZGtKaTBjZmZUUjczQzk4NFF0Tm5pY0FWTHdDQUpBNzk5eHpUeUgrbTc3NjZxdWJiRjk1NVpVTEs2eXdRbmI1em5lK1U3ampqanNLL2ZyMUs4eWRPN2ZKZmlOR2pDaGNmUEhGMmUvanhvMHI5TzdkdXpCejVzekcyMDg4OGNUQzl0dHZuLzBlZnh1MzMzMzMzVTN1NHl0ZitVcmg0SU1Qem42LzVaWmJzdkpjZSsyMUgxcjJqVGZldVBDTFgveWk4ZnFhYTY1Wk9PKzg4NXJzYyttbGx4WldYSEhGeHVzNzdyaGo0ZkRERDIreXoyYy8rOW5DM252djNYZzlIdi83My85KzQvVlpzMlpsMi83MXIzOTlhSmtBb0ZJWWt3NEFGZVMrKys3THVxWkhDL0s4ZWZPeWJ1M1JtcjN5eWlzMzJXL09uRGxaNjNsUmRIUHYyN2R2NC9WVlYxMDFhMzBQeno3N2JEWUozUjU3N05Ia1B1YlBuNSsyM0hMTEp0dTIyV2FiSnRmanNhTTdmWFMvajFieUJRc1daSTlkYkVsZlV0RXlmOFFSUnpUWkZ1UHhmL2F6bnpYWkZxMzNSZEhESUxyM0Y1OEhBRlFESVIwQWNpaG1jNC91N0U4Ly9YU1Q3VEVtUFJRblhZdVFISUU3eG93M1Z6cm11MXUzYmsxdWkvdU9zRis4anhCQk95YWpLeFZqejBzMTczcC93Z2tucEFrVEpxUnp6amtuSzNPVTZ6T2YrVXdXOE50RGE4OERBS3FCa0E0QU9SUXQ0OUd5L2N0Zi9qSWRjOHd4aXgyWEh1UFBZNW0ybUdBdVdzdVh4VVliYlpTRjhXajkzblhYWFpmcWIrKzY2NjUwNktHSFpwTzVGUVAvaXkrKzJHU2ZtQWd1Wm9KdlRVeUtGL2MxWnN5WUp2Y2RaUU9BV2lLa0EwQk8vZXBYdjhxNmZFY1g4K2hTSGwyOU8zZnVuTzYvLy83MDFGTlBaYk9zanhvMUtvMGNPVEx0di8vKzZleXp6MDdycmJkZWV1MjExN0pXOFFqT3pidW50eVM2d1VlTGVFd1dGNjNTTysrOGMzcm5uWGV5a0J6ZHlVdURjM014dzNwTURoZVR4VVdyOWltbm5MSkl5M2FjUExqOTl0dXpHZVhqWk1EQWdRTVh1WjhUVHp3eG14QXV1dGZIYy9ySFAvNlIzVy9wVFBFQVVBdUVkQURJcVZpT0xHWk1qelhTeDQ0ZG0xNTU1WlVzNUVicmNvVHFXS0l0Z3ZIMTExK2Z2dmU5NzJXem9VK2ZQajBOR1RJazdiTExMdG15YUV2cUJ6LzRRYmFFVzh6eUh1dXpSMWY1YUtYLzduZS8yK3Jmblh2dXVlbkxYLzV5Mm5ISEhiUHdmZEpKSjZXWk0yYzIyU2RtZG8vWjJ1UDV4RGo2aGpuZ21vcVREREgrUExyTnh5enZzUlRjcFpkZW1pM2hCZ0MxcEZQTUhsZnVRZ0FBQUFEV1NRY0FBSURjRU5JQkFBQWdKNFIwQUFBQXlBa2hIUUFBQUhKQ1NBY0FBSUNjRU5JQkFBQWdKNFIwQUFBQXlBa2hIUUFBQUhKQ1NBY0FBSUNjRU5JQkFBQWdKNFIwQUFBQVNQbncvd0doZzVuVTlXK3Zhd0FBQUFCSlJVNUVya0pnZ2c9PVwiLFxuICAgIG9iamVjdFR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgb2JqZWN0VWxpZDogXCIwMUpUSFJUMlJOWVRRSE5ETlMwVlBYNDQyU1wiLFxuICAgIHNoYXJkVHhJZHM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiMlwiLFxuICAgIG5hbWU6IFwiR3JhcGggVmlzdWFsaXphdGlvblwiLFxuICAgIGRhdGVVcGxvYWRlZDogXCIyMDI1LTAzLTE4VDExOjQ1OjAwWlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkNvbXBsZXggZ3JhcGggZGF0YSB2aXN1YWxpemF0aW9uXCIsXG4gICAgZmlsZVR5cGU6IFwicG5nXCIsXG4gICAgaW5kZXhpbmdUeElkOiB1bmRlZmluZWQsXG4gICAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0OiB1bmRlZmluZWQsXG4gICAgb2JqZWN0RGF0YTpcbiAgICAgIFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQTY0QUFBRkdDQVlBQUFCcWpzSzBBQUFBQkhOQ1NWUUlDQWdJZkFoa2lBQUFJQUJKUkVGVWVKenMzWGRjVkZmNlAvQ1BTSmxZQUljQks0cEVFVlRLV2hJVFViR3hsa1JSTjhheWRvMG1halNKMGF6K0pBYS91bXJjUkRlYWFNUWVTMHdnR0ZmTldyRWxsdWdxS0dLSm9GaHhRTEZscFBuNzR6TEQ5SHFIR2VEemZyMTRLY09kYzU4N2R3YnVjODg1ejZueTRzVUxFQkVSRVJFUkVUa3JGMGNIUUVSRVJFUkVSR1FNRTFjaUlpSWlJaUp5YWt4Y2lZaUlpSWlJeUtreGNTVWlJaUlpSWlLbnhzU1ZpSWlJaUlpSW5Cb1RWeUlpSWlJaUluSnFURnlKaUlpSWlJaklxVEZ4SlNJaUlpSWlJcWZHeEpXSWlJaUlpSWljR2hOWElpSWlJaUlpY21wTVhJbUlpSWlJaU1pcE1YRWxJaUlpSWlJaXA4YkVsWWlJaUlpSWlKd2FFMWNpSWlJaUlpSnlha3hjaVlpSWlJaUl5S2t4Y1NVaUlpSWlJaUtueHNTVmlJaUlpSWlJbkJvVFZ5SWlJaUlpSW5KcVRGeUppSWlJaUlqSXFURnhKU0lpSWlJaUlxZkd4SldJaUlpSWlJaWNHaE5YSWlJaUlpSWljbXBNWEltSWlJaUlpTWlwTVhFbElpSWlJaUlpcDhiRWxZaUlpSWlJaUp3YUUxY2lJaUlpSWlKeWFreGNpWWlJaUlpSXlLa3hjU1VpSWlJaUlpS254c1NWaUlpSWlJaUluQm9UVnlJaUlpSWlJbkpxVEZ5SmlJaUlpSWpJcVRGeEpTSWlJaUlpSXFmR3hKV0lpSWlJaUlpY0doTlhJaUlpSWlJaWNtcE1YSW1JaUlpSWlNaXBNWEVsSWlJaUlpSWlwOGJFbFlpSWlJaUlpSndhRTFjaUlpSWlJaUp5YXE2T0RvQ0lpSWlJaU1vTkNZQTZKZjhQTUxIdHc1SXZCWUM3ZG95SktnRW1ya1JFUkVSRXBFOEFnQ2dBRVFBaWlvdUwvK0xpNHVKcFEzdlhBWnd0K1VvdStTSXlTNVVYTDE0NE9nWWlJaUlpSW5JT01SQ1MxUmdBamZSdGtMQXRFUUJ3OHVUdmVQandvY0dHMnJScEJhbFVpbVlod1dnWjJ0elFab2NBSkpWOFpWb2JORlY4VEZ5SmlJaUlpQ3EzQ0FCVGk0dUwrMm4zcUNac1M4U2VQZnR3NHRRcDNNMitpOXpjKzFidnBLRi9Zd1ExYVlMUWxxSG8yYXNIb3JwMDFON2tISUFsRUpKWXd4a3hWVXBNWEltSWlJaUlLcWVSQUtZQ0NGYytjRDQxRFJ2WGY0Zi83dDJMdFBSVXUrNWNLdlZGcS9BSTlJdnBpM0VUeHFvZUx5b3FlbHkxYXRWRUFIUEFYbGdxd2NTVmlJaUlpS2h5R1ZsVVZCUlh0V3BWZndDUVo4c1J2Mm9ONHRldXhZMnNESWNFSkpGVVErUnI3VEY5K3NmYVBiSGJJU1N3WngwU0dEa05KcTVFUkVSRVJKV0RSc0o2UGpVTi96ZDNIbmI5ZHpjVWltZU9qazJsb1g5ampCMDFDcC9NbXE3KzhIcVV3eDVZVnpmM0NKVE9HMWFYQ2FFNFZWSmhRVDZIUlp1QmlTc1JFUkVSVWNVV0FXSHVhQ2RBU0ZpbmZ6d0Qrdzd1ZFd4VUpraWx2cGc2YWJKMkF2c1poQVRXcVpVa3JLclgzSWk4a3UyV01JRTFqb2tyRVJFUkVWSEZOUWZBcDRBd0pIald6RmlzM2JqR3NSRlpTQ3IxeGZLbFN6RmdZSC9sUTljaHpNOU5kbFJNeHJpNnVVOEY4S1hhUTNrUVlsVWY3aHdEdGJuRkVBcFRqU3dzeU9lUWFBT1l1QklSRVJGUkZJUmVPVzhJYTNjR2xEeWVXZkwxRUtWcmIxTDVFQUZnSFVxU28xVXI0dkhSak9sT05TVFlVcSswZlEwcnZsbXV2clNPMC9XK3VycTVMd0V3UmUyaHoyQ2dOOVhWelQwQXdqbFM5c3JtQVloaThxb2ZFMWNpSWlLaXlzY2JRbzlQRElDK0ZqNTNPNFRsU3RhSkhCT0paMlJ4Y2ZGU0Z4Y1hUM20ySERIOTM4TEpVNzg1T2laUlNDVFZNSFA2SityRGh3OUJlQjg3ZkppdHE1dDdESUNmU3I0MU93bDFkWE5mQjJCRXliZm5TcDduOE9OeE5reGNpWWlJaUNvUGJ3anJkWDZndmw1bjhvSERPUDdiY1dSa1pDTHJaaFp1MzdrTEFLaFh0dzc4Ry9palRadFdlSzM5NitvOVhTZ3VMbjdrNHVMeUpZVDVlYnpJZGg2cUhyK0ViWWtZTlc1c3VlNWxOZVNWdHE4aEtmRUh5UHhreXZkaUp6aXc4ckNybTdzM2hORUpYaVVQZFM0c3lFOHVHVGJzcmJacEJJVFBTeWFFd2t4blM1NmZoTktiU0o4VkZ1VFBLWU93eXhVbXJrUkVSRVNWdzV5aW9xSVBxMWF0V2hNUWt0VVZLMVlpK2NoaDVPYmVONnNCcWRRWFVSMDY0di9ObnFWS1lrdVNoaWxnRDZ5amVVTklXa2NBd1BpeDc1Vzd1YXlXa2twOXNYWFRKa1IxNmFoYysvVjlPT2g5cURXdmRYMWhRZjdJa3NkTkpWdWpDZ3Z5MTJrbHZua0FHaFFXNUQreFU3amxFaE5YSWlJaW9vb3RBTUxRM25CQTZJV2JPKytmU0V0UHRhbFJQZk1ObldiSVppWGtEV0grY2JnOFc0N2h3MGZacFdKd3l5YjE4V3FJSndKcXU2Qkp2V0lFK1Q5RDgwYjZUM2ZhZFc5Y3pxcUdxN2Rka0htdkdDY3VQc0w1cTdkRWowa2lxWVovTFZ5RWNSUEdLaDhhQlFja3I2NXU3cGtBR3BWODI3aXdJRCt6NUhIMVpPc2NoTStqbDlwajF3c0w4Z05LdGxXZkg5dXpzQ0QvRi90RlhQNHdjU1VpSWlLcXVDS0tpNHNQS2VjNjJpT2g2ZDkzQUpZdFd3cVpud3hGUlVWWlZhdFc3UU1IRHRtc2hEU1MxbmF2ZDhDTnJBeFJHdmFwNVluT2Y2bUxBWkV1aUltOExVcWJTVWZySWVGb01RNys3dzV5SGp3U3BVMEFpSXVOVTUvM1dxYkphMG1SSmVXTHJrcEVTMzZtbm14MVJza1FZV2hXRkc1Y1dKQ2Y2ZXJtSGdYZ1lNbGoveWdzeUY5Z3A1RExKVmRIQjBCRVJFUkVkakVTd0ZvWEZ4Y2tIemlNUHYxaTdETFhNWEY3QW40L2N3YngzNjVFVkplTy9pV0pza1BuRzFZeVNSQXhhWlZJUE5BeHdoL1QvbFlGSGNLeUFkd1ZKVWlsbU1qYmlJa0VnQ280a3RJVWkzOThnY05uczZCUVBMZXAzZGk0V0FCUUpxOXJTeDVlWjFPajVndFErMytta2UwaXRMWUZoR0hGeXVlb1A3ZXVqVEZWT094eEpTSWlJcXA0SWdEOER3QVd6RnVrdXFpM0o0bWtHbjcrS1FsUlhUbzZSYkdjU21JSmdDbGlKSzBTaVFlR2RnL0VuT0U1a0huWmxrUmFTcDduZ1RrYmZMQnA3eldiRTFobHoydkpuTmVPS0lQM29GWlA2YUhDZ3Z3b3RaOFpTN2EyRnhia3gyaTFwZHorMzRVRitWUDBQS2ZTY25GMEFFUkVSRVFrcW9EaTR1SkRRTmtsclFDZ1VEeERuMzR4U0Q1d0dDNHVMcDVGUlVVL1E3T2FLb2tyQWlYeklZY1BIMlZUMHZxM0xzMXdaYU1YbGsyK1hlWkpLd0RJdko1ajJlVGJ1TExSQzJQZURMR3ByZGk0V0t4YUVZK1NJbVRyUkFuUWZ2cVdGSFVDQUxpNnVVYzRNaGhueHg1WElpSWlvb3JsTElEdzVBT0hFZDB6dXN4M3J0N3pDcUZnVTFTWkIxRTVKQVBvWk12TmlaWk42dU9MQ2RWS2hnUTdqN1RyM2hpeHNORHFZazRTU1RWY3UzSVpNajhaVUVielhkVjZTdk1LQy9LOTlUd09DSE5jQTFBNmxCblFMTTZrdmc3czVNS0MvR1YyQzdnY1lvOHJFUkVSVWNVeEJ5WHpIZnYwaXpHMXJWMG9GTTh3OXAzeGtHZkxBYUFUaExtMkpLNG9BSjNrMlhMTVgyUmQvWjR4YjRiZzFOZFBSRWxhMDY1N0krbG9QU1FkclljaktYNDJ0OWU4MFVPYyt2cUoxYjJ2Q3NVekRCOCtDZ0JRVkZRVVozTkE1dGxlOHE5WHlkQmh2UW9MOHRjQldLcjJVS09TNGs2QVVKVmJpY1BzdGJESGxZaUlpS2hpQ0NncUtrcXBXclZxemNqSXpqaDU2amVIQnRPLzd3QnMzYlpKT2QrMUViaE1qcGpXQVJoaFRXK3JST0tCbi8rdm9WVUphOXAxYit3NlVRTkh6ai9IYmZtZkpudEVXemFwajNxeWw5Q2hwUWQ2dmZyRTROSTV4aHhKOFVPZi8zZkRxcm12WjM0L28xeXV5ZTY5cnE1dTdpTlIycE9xbXVlcTNlTmFXSkNmWERJaytIOXFqNCtDa0tncUg5T29URXdDSnE1RVJFUkVGY002QUNNU3RpVmk4TEFoVmpjaWxmcWlqbDhkUEhuNnhPWUt0V3FKdzJjUWVvTkpCTVhGeFhrdUxpNmVUWnFFV0hTT0F1cjc0c2lTS2hiTlkwMjc3bzJ2ZjY2R3BLTzNiRjYreHFlV0oySWk2K085UG9iWGY5VkhudWVCRGxOZklQUFdmWXYyTjJyWWFLeU0veG9RZWtQdFBnVEIxYzA5R2NJb0F3RDRvTEFnZjRsVzcrdlp3b0w4aHlYYnFqLytFTUxuVjdsRVRyL0NndndrZThaYUhqRnhKU0lpSWlyL3ZBRThBSUNJOExaSVMwKzE2TWxTcVMrbVRwcU1zZU5HSytjRnFxeGFFWS8xMzIyeXFnZTNXK2Z1MlBYTERtV3ZxNWZGRFpBK0VRRCtkejQxRGEzYXRETDdTWlltclVsSDYySHBUMy9pZUdxbWRWR2EwQzQwQUZQNnZXVDIrckRXSks4Ti9Sdmo2dFdMeXZmZnB4RG1CZHR0Q0c3SmtOK3pBSlR2OVE4S0MvS1htSGlPYWgzZWtvZldGeGJrajdSVGlPVWE1N2dTRVJFUmxYOGpBU0JoVzZMRlNldW9ZYU54OTA0V1BwazFYU2RwQllCeEU4Ymk2TkdEMkxKeE15U1NhaGExdmUvZ1hweFBUWU9MaTRzbnlxREhxNUtJQW9ELy9Qd2ZzNTlnU2RLYWR0MGJiZCtyZ2NGeEYrMld0QUxBOGRSTURJNjdpTGJ2MVVEYWRkUEZwMlZlejNGa1NSVUUxUGMxZXg4M3NqSWd6NVlyMzM5ZlFoaUttd2xoR2FFQXF3STNvbVE5MWlnQWVTVVBmZW5xNXA2c2I4NnJxNXU3dDZ1Yis1eVNlSmkwbXFGUzlMaStTS25pRGVFWGVoUllscDJJaUtnOGVnZ2dxVXJZaTNXT0RzUkpuUVVRM3F2SG05aDNjSy9aVDFLdWVXbXU1QU9IMGFkZkRCU0taMlkvcDZ5SGExWUNjd0I4T243c2UxaTdjWTFaVDVnN3RnV21EYnhwY3J0Slg5WEQ2aDBYeldyVHA1WW42dnJVUkkyWDNOQWk0Q1hWNDFuM0MzQmIvaWVlL0psdlVlL29tRGREc0d5eTZkN1hJeWwraUo1MnhleDJHL28zUnB0V3JkQzFTMmYwNngramZYTm1PNFRYVTlSZTJKSTVyT3RRbXBBQ1FqS3IzSSszMXM4QVlHbGhRZjVVa0VFVlBuRXRTVnFUb2Z2bUlDSWlvdkxuRUlDWUttRXZXT2luVkEwQWp3SEEwMHRxZGxLcExKNWtLVXZuMEdvTjErUndZZHZOZ1lXSjY1YllFS05EY3RPdWUyUEFuR2RHRTgyQStyN28ya3FHYm4rQjJjTjdBU0hSL08vdjdqaDI0YW5KSHR5QStyNUltRlBONVB6WGw2THpqUDdjbUZmYXZvWTNldmJVdm1HekZNTHJLdXJ2bFpLQ1RYTUFOREt5MlhZQWN3b0w4bGxGMklUS2tMaXVBekRDMFhFUUVSR1JhSlpXQ1h2Qm5vbFNFUUQrWjhtNnJWcnJYRnJNMHA1ZHRTSk5md0dYK2JEVkhGaVl1Qzcvb0FWRzk5VGY0NXAwdEI1R0xicW10MnF2Uk9LQm9kMERMUzZtWklnOHp3UHIvdXVMSlFsWkJnczlTU1FlV0RzOTBHaHliRXZpcXFTYzE2Mld3RjZITUNKQTlQZG5TUTlzQkRTSEp5ZERyVmdUbVZhaDU3aVc5TFl5YVNVaUlxcFlSam82QUNjVEFRQzdkLzFpOWhONi9iV24xVWtyQUV5Zi9yRkYyLzkyN0ZmbGZ5T3MzaWxaN1pzZCtuT2p4ZHNhWUhEY1JaMmtWU0x4d055eExmRGdad21XVGI0dFN0SUtDUE5VcHcyOGladmZWOEdXMkJDOTgxVVZpdWNZSEhjUmk3YzFNQml6R0hKejd5TTJMaFlSNFcxeFBqVU5BQm9WRlJVZGhoMSt2eFFXNUo4dExNaGZWMWlRUDBmdEs1bEpxMlVxZE9JSy9uSWtJaUtxaUx4YzNkem5HUGlhV2xMWnN6S3BBUURYYjF3Myt3bHYvVzJBVFR1TTZ0TFJva0pOdi85K1J2bmZBSnQyVENyZTN1YVhiVGwvOVJZNmYxUkxWUVJKbnVlQlNWL1Z3K3o0Q3pyYi9xMUxNMXpaNkdYV25GaGJ4RVRleHNXMStaZzd0Z1VrRWcrZG44K092NEMrc2I2cW1OT3VlMlBTVi9Vdzc3dXJvc2FSbHA2SzF5TWpzV3BGUEtwV3JWb1R3bHFzSTBYZENZbWlRZzhWZnBGU0pRckFRVWZIUVVSRVJPSnlhKzFtYXBQdEFLYVdWUG1zNkpZQ2VOK1NaWEJ1WjkyMHFjY1ZzR3paSGJVQ1RWelAxWFpSQUE1YU1qVGNIRDYxUExGbFZtMTBDTXNXclUxenlmTTgwUE1mYmpoLzlaYmVud2ZVOTdWNERWZHJhQlVyNndlQWE2azZFVmRIQjBEaWkxc1ppdHhIVlZUZkwvazR4WUhSaUd0RWJFdWMvNk8wNk1UcFRkY2NHRTBwWjQyTGlLZ0M2MnpnOFFnQVV3SDBCUkRsNnVZK3NyQWdueGVmV214TldpMTFJVjFWcVRhZ1RIZGNNWjBGU251OUxhbndiRWk3MEFEOEVQc01NcSt5VDFvQllRanhxYStmWTlKWElYcXJHcGRGMGdvQXNYR3hBSUJQWmsxSGNYSHhlaGNYbDNBSXk5V1FFMkRpYW9UMjNkeUMwd1U2MjdRZUdvaVU5Q3lyOTdGaGJtTU03blhaNnVmcnMvM3dVNDJZbHVpWmhtTE9zWWxCN1AyYy8rT1pUYSszdlRoclhHVDVqWnl5K214VVZoWDV4cHBZc25Na1dQRmpVeHc4L1J5L1g3Z0RoVUlCQUpCSUpBZ0s4RVhMbDZ0aGVLOG42Tm91MDJBYit2NDI2WHN2Nit1MW5EZ294T3p6MHZtZElCdzluYUh4V0Zpd3Y4N05PMXYzbzA5aFFYNnlnUjhsQTFqaTZ1WStGY0s2alQrNXVybi9oUlU3SGV2SjR5Zksvd1k0TUl5SzRpR0VFUVY5ZS8yMUp4SzNKOWpVV0hTN0p0Z2VaM2xpbUhiZEc1ZXpxbUhmLzNSLzFxcUpDNXJXejdlNDkzYlo1TnNJcU4xQzd4RG1zaEliRjR0MnI3VkRWSmVPbmhCNlhEbjEwRWt3Y1NXaUNzMmNHemxVZG5nK2pOdXlLd2p2ekxzRGhTSmQ1MmNLaFFJcDZWbElTUWMyN3dSa1BqTE1HbFVia3dhTGU0RzNPaWtEby90SUVkWXMxMlNzMmttck15a3N5Ri9pNnViK0VNSjh0U1F3WWFLS0pRbEEzLzgzZTVaTmlhdWxTZXVSRkQ5OHU4c0ZCLzkzQnprUERNK3BYbDN5cjBUaWdZNFIvdWo3bW9mQnFzYmFoTG0xamsxZSsvU0xVVmJkRG9jd3RIMk93NElobFlwZW5JbUlpS2hjV0xhbEJZYlB6bEQxc0pvaXo4bkRCNHN2by9NN1FhTEdvVkFvTUNyT2VOR1g3QndKUGx4aVBMRlZGeGJzci9QWXF5M01PMDViRkJia3I0UFFNOVdvWkQxRm9vcGlYVkZSVVZiTDBPYm8zOWY2UWx1clA5Sy9KSTIycEtQMTBQYTlHb2llZGdVL0hyaGtjQ2tiYlFyRmMrdzVmaFVUdjd5QUJtKy93S1N2NnBuMXZHa0RieUs2WFJPenRyVUhoZUlaaGc4ZkJRQW9MaTcrQUlENWxiRElidGpqS3JLSmcwSXMycjdGeS9hdDJHYUlicHoyR2E1WFZ2c2hFZ3ZmcytRSTJUa1MvR1BaRGF1ZTI3Q091OGpSQUNucFdWaTJwWVhCM3R6NWE0SWd6OUdkaCtha2xQTmRSd0pZNTlCSWlFUlV0V3JWV0FCcmx5MWJpdVFqaDVHYmE5bHczNEQ2dnBCNTZhN2RxaTd0dWpkR0xDekUrYXUyZjk1ekhqekM2aDJQa0hUVUU4c20xemU2VGlzQStQdWFMTUNtbzZGL1k5U3BVd2N0Z2tOd0lmMGluangrWW5ZQk1XMzdEdTVGd3JaRURCalkzeFBDNzVFNVZqVkVvbUhpYXNTR3VZMjFIakU5RjdXOHpOY3FxempMeSt0QnBNVDNMRG5DaWgrYjZnd1Bsdmw0NGQwQmRkSFVYN2l3dkpMbGdZT25uMnNNenczdzk4UDZ1UE4yaVduZTJuc1lHQzJCbjQ5bXoyaktKU21XYjdYc0l0YXp1dTdsaHRqMUhRd3BMTWpQZEhWelB3ZWdVNW5za0tqc3JBTXdVdVluNjdSMTB5YjA2UmRqVWFHbXV6bVBBRWdNL256eHRnYVk5OTFWblRWZWJaWHo0QkVHeHozQzM3bzB3OFpQN29yU1pyZk8zYkhvODRWb0dkcGM1MmZ5YkRsbXpZekZsaCsyV2x6SWF1NjhmMkxBd1A0b0xpNyt3TVhGWlFtRStjWGtJRXhjalNpclA2cjZaT2RJTUg5TkVJNmNmYUthRHliejhjS3JMWDN4ZHJjaW0yTlRMNVNocjVDR3RyaVZvVGg0K2puU00zTWh6OGtESUZ3d3ZSNVd5MmlSRUV2MnMvOTRBTDdhOWhKT25MK3Yya2RZc0QvNmRxeU8yUEhtM3kxVEZqWTVjNmtRV2ZlZWE4eW5zK1kxRkNzdTlmakVPTGRUUHcvVGFFTWlrYUJOaTdybzNOb0RFLzUyUmVkaTAxWlRQdy9UdUZnMVZWZ2xPMGVDK3RGRnF1OEQvUDF3SmFtMHpIM0tKU25XL053QTU2NG9jRFA3S1RLenNqVzJmVDJzRmo0YWV0dmtQRHREU292VGFCYW8wUzRTbzEwZ3paTDNySzNuVXQrK2xHM3VQSmFqZWswQy9QM1F1NzBQWm82K2JQSzhPdXY3eTlyem9WMWt5Rml4TEV0L3I1bVNja21LMkpXMWNlSGFJOVc1RVBQM3NMb3psd3AxSHZ2dlY4VUlhNmI1T3laV0xhNmRoNjVpeFNlVzkwaVlTNTZUaDQrWE50TkpqSVZoeEk4dGFpdThxUVJIVDRzWW5PVjRzVWtWMWNqaTR1SnpVVjA2ZXE1ZEZZOVI0OGFhblp3cEZNK1JkRFJRYjgvbnNBVjE4T01CdzNOTUErcjdvazB6S1JyNXVhSk5VTEhPejYvZWRrSG12V0tjdVBqSTRCSTNQeDY0aFBRYjliSDdud1Y2ZTM1UFhEUTlIRmtpcVlhMXErSXhZR0IvZzl2SS9HUllHZjgxSmsrWmhKaCtBM0FqeS95NStXbnBxVGlmbW9hV29jMDlBY1NBb3pZY2lvbXJDZnVQQnlBNzF4MWRYNzBoZWlKZ1NOektVSHkrSVJNS2hlWWRiWGxPSG5ZZXlzUE9ROEMzU1VINC9wLzJqMm4vOFFEOFBmWUo1RG02aFVJeXM3S1JtWldOelR1QjNwMUM4TzJzREt2akdSSGJFcHQzWHRKNVhGbUlaT1B1K2toWStLZkpkbEl1U2RGK2RJSGV3aWFBNW11NGVGTWdkdi83dHRHWXhZcExTWXh6bTUwalFmc3hQc2pNMG14RG9WRGc2T2tNSEQwTmZMNUJnakV4UWFMMkhvN3VjeFBMdDVaK3YvTllqdEhDT2l0K2JBcWc5RHdNNnlrRklQenhXcmFsQlQ1WWZCbUEvbDRiOWZmV2tONHQ3ZGFqWkF0N2ZFNzNIdy9BaEFVRk91YzJNeXNieTdkbVkrY3hQeHhibldPd3ZmTDgvbkkycFo5OXpRVE5YcitIcys3cFhyVFZrZW0vK0F4cmxvdWtMM0tSY2ttS3NHYVpOdS9ibU0wN0wyRjRyd0RWemNtNGxhRklTZGYvKzlVU01oOHZBSEtiMjZGeUtRSkM1V2RUUGVDSFN2NU5ockFjeWRtU3IvSW1vT1RMRzdyVmFaVS9VMHJXK3ZsRENNZXMvRmVmVEJjWGwwN0Z4Y1dIQmd6czcra2prMW5VOHpwcTBUVUFwY21yUE04RFkvN2xpVDNIZGE5OWZHcDVJaWF5UHQ3cjh3ek5HejBFWUY1dnFUelBEK3YrNjR2VnU3TjFsclU1Zi9VV09rejF4Y2NERzZpS042VmQ5OGJFZjFmQithdVpSdHVWU0tyaDU1K1NFTldsbzFseHRBeHRqdU8vSGtHNzF6dFlsTHorMzl4NTJMcHRFOERFMWVHWXVKclFZNkp3b1cyUFpXdjBpVnNaaXJuZm1yNG9PSG82QSszSEdMK0l0ZFd5TFMzd2oyVTN6Q29Vc3ZQUVZiUy9abDA4TVIrR1lPY2gzVitRNmpLenNqRmdoaDhBNDhOVndwcmxva1oxbVZreHA2Um40ZTEvTk1iQmIvV2ZWekhqQXNRN3R6M2ZyNGZNTE9OTDd5Z1VDaHc1KzhUb05wWUthNWFMeU5hbFZVUXpzN0t4LzNpQXdkNzJnNmMxWDVNSmY3dWkrbi9IVm5mTTN1L21uWmRRcTJhWVV5Vko5dmljUG5yNkhIK1BmYTdxMWRjbk15c2JQZC9YMzVOWTN0OWZ6cVJwVEgxa1pobi83QVBpL2g3V041VDJuWG1ORVRmK25zRlJCOWFPUnJEVTlLOWNjTHFkY0ZQajh3MlpHaitUU0NSbUY1TlNWOC9YRTB4Y0t5MHZtRGRzdTVQV3Z5Z3VMbjdrNHVKeUVFSkYzU1E0VjA5NkFJVEVOQUpBVk1uM2pTeHN3OVRyY2c1Q0VwOWM4cVZNWnM4cWs5ZW9MaDA5STE5cmozMEg5NXExUTRYaU9RYkhYWVJFNG9FNlBwN0l2SlVOUUhNSkc0bkVBeE5qbXVEL1J0OEVZSHhlcWo0eXIrZVlOdkFtcGcwRWtvNkdZTkpYdHpTS08yWGV1bytKWDk1SDdEcFAxS3ptZ2N4Ymhxc1ZxNXM1L1JPemsxWlZMSDR5eEgrN0V0RTlvODErVHZLUnd3Q0E0dUxpemk0dUxoRW9uemRRS2dRbXJrNWsvL0VBalF0UGlVU0NqNGNIcUlibExkdlNBa3UvZjZnYXNwYVpsYTEzR0pkWXNXZ25yVElmTDd6ZHZaNnFFdVQzKzZwaS80bWJxbTFhQkhyQ3owZi9jQkJENGxhR1l1Y2h6WXR0NVREY3B2N1BrWlBuaG4ybmlySHowRldOb2FUR1JMZXJnODA3OHhEWnVqSENtMHBVOFY3Sjh0QlppdVBvNlF4czJSV2tjMU5DN0xqRU9yZjdqd2RveEs4K1hGYzU5UGI3dmJjaHo4bkRvc202UTNkczFibTFoOFp3dncyN2FxQnJPOTN0c25Na0d2UHdJbHMzaHA5UDZXc2MxaXdYQWY3MWNmZitJM1I5dFFGYU5YTlZ6ZU03Y1VHaU9nYWwxVWtabURsYWQ2NmRNY3JrenZSUVU4dHVTTm5yYzZyY1hpS1JvSC9YUnFoVjB3VVBIaGNqY2Y5MWpjOWhTbnFXem51MlBMeS83SFUreERZaXRxWGVwRlZaRlZkN2JWU3hmZy9yRzBxNzg5QlY3RHdFUkxZT1FuaFRDZDdzOE1qbzJxMWkwSGVjS2VsWm1QcDVHQjQ4TG9aQ29mbmFqSWxwYk5aODExZGJLTEJjM0ZDcG5MbWJmUmZqeDc1bmRzR2M1c0docUZHekJsb0VoNkJObTFaNHJmM3J5dUdhZlV1KzFrS29HSjBFeC9TQ0JVQklVSlZmZXBQVTg2bHB1SFF4SGJtNXVmajk5ek9xeC9NZTVTSDlrdTd2dTFmYnRsWDl2M0hqQURSdDJnVE5Rb0tWY3pmRFM3NzZBcnFKdkl1THk2Y0F2dXpZb1lQWmlhdVNRdkZjcHpjVUFOcUZCdUNIMkdlUWVZbFRURFFtOGpaaUlxdGcwbGNoV0wxRDgzZEh6b05IeUhsZ1hqc04vUnZqazFuVHJZb2hxa3RIZE92YzNlelhLRGYzdnZwdzRmOEJ1QTdoUGJjT3dvMEVLaU5WWHJ4NDRlZ1k3T1pGU3BVb0FBZHRhVU01WjhwUWo2c2w4NjlNMFc3cmwrWDFkUzVTU29meGxTWkxwemZYMUxqemJrNU1wdWFDYWJmUnUxTVRKSDJoZTNHaUhOcllJdEJUNzg5TjdhZHV0RXdqUVJuU1cvOEZvS0hlSkgzSGxuSkppanF5WndhVEhPM2h2L3FPVGV5NHhEcTMydk5NRGIzZmpGVUR0VlhOOWpWVmlaVE14d3QzOXVqMm1taS9MbDlPQzlLSngxaHZiWGFPQkQzZnI2ZnhtczErSjlpcU9jV1dma1l0L1d4WWV5NjE5d1VJYzFtMWUrK3ljeVFJSDF4RDQvMm9QYis0UEwyL0xEMGZaVG5ITmVXU0ZLMkhhQTROam16ZFdHTTRzTDdYRWRCL2ZpMlJuU1BCeTMzY1RQWmVtanZIVnZ0MUEwei9MUUNFMTIzUjVHTFZhQ01sZlQycnlubnIrdHJRZnUyMzdBckM4Tm1sTjdOTXpaRTNSNVd3RjFYTTNkYlZ6VDBaUUtmQ2dueXpuMVBPTEFYd2ZrUjRXN01ycU9ZL3QzMjBsaVg3RTROVTZvdW9EaDNSdFV0bmpKc3dWdlY0U1FMM0pRQjdGODhKZ0RCY2RDU0VCRkpEd3JaRTdObXpEeGZTTCtMdTNic1dEVWMxUi9QZ1VBUTNDMEpFZURqZTZQT0d2a0pFNXdDRXk3UGxDR3dhWkhFaEltMGZEV3BSMHN0cUgwbEg2MkhVb210V0ZYLzZZUEtIV0xoNHZ0WDdUajV3MktKZTEyNmR1Nk5qaHc0WU8yNDBaSDR5OVIrdGgxQngySmw2L3lzc3J1TnF4UDdqQWFyL243aGd1T3FhT3JmV2JtWjl0UjRhcUxNdjlZdU1JYjJiNmIybzkvTlJJTzZkNmhxUHJmbTVnZmtIWlFidFdBTDgvZlFtcFFEUXRWMG1qcTNPTWZoelk3YnNDdEs0R0E4TDlqZllheEU3UHRYc3BZYkNtdVVhN1puN2ZNcFZTQ1NsNTFON2JwblljZG56M01hdEROWDd1TDJTVmdEbzM3WDBwckk4SncvTHRyVFEyVVo5bUxCRUl0RWJqN0dlSXo4ZkJhWU4xUndRa3Z2SThkZWI5djZjSml6OFUrZTk2K2Vqd0xzRDZtbzhwajVNdDZLOXZ4d3BkbVZ0amU5bFBsNDZjMWo5ZkJRNHRqcEg0M2NJb1BsYVR2MDh6S3kvQStyOGZCVDQ1NlNHT3UxcUUrYllYc1h3MlJsb1BUUlE0KytVV0xxMnk5VDV2YVl2b2Jha01KU2ZOTi9tdUloeWMrOGpjWHNDSms2WkJFOHZLUVlOSElyenFXbHdjWEh4QlBCcFVWSFJEUWhMbG9pNTVxWTNoTVRrTElBTUFGK2lKR2xOMkphSVFRT0hva21URUxoN1NEQjQyQkNzM2JnR0owLzlKbnJTQ2dpRmdoSzNKeUEyTGhhdDJyUkNuYnIrR0RSd0tKSVBIRlp1RWc0SXcyRWpYMnR2MDc3bWpyVnYwZ29JdmE4Ly8xOURTQ1FlRmorM1o2OGVOdTA3cWt0SFNDVFZ6TjUrMzhHOWlJMkxSVDMvQm9pTTdJeUViWW5LSDQwb0xpNitEdUdHQnRrWkUxY2pzblBGWHh2UGtCMUhQRFcrSDk3TDhQeXh3YjB1bHhTMkVKeTdJdTRjVisxWXByeHQvUGUvdFhPN3RHOEdqSHJqSmFQYnp4d3R6aEJDUHg4RmdnSjhWZDlyOTBxSUhaZVk1L2JORHBvVjl1WittNDdXUXdNUnR6SVUyVG5tM1Z5eDFVZEROZWUzN0R1bE9XUlVlNWl3ZXFKckNlM2VKR2VZVTJuUHoybUF2NS9CSGp2MStjSDJqTWtaM2wrT2RPSzg1akM1NkhaMTlQNSs4L05SNkx5dnhYaC9UaHA4QWNmV3VLbUc2NXFTa3A2RkhoTnloREEzQUFBZ0FFbEVRVlJ2R2J6QllJc2xINmNnd04vUDRNOG5EZ3F4YU5peTlyWlN6NG83Mm92S2hrTHhESW5iRTlDcVRTdEVoTGRGd3JaRVZLMWF0U2FBVDBzU2laRWk3R1pPU1Z0Zm9xUW5jOEc4UllpTTdBeFBMeWtHRHh1Q3hPMEpka2xTemFGTTVLTjdScU5PWFgrTUgvc2U1Tm5DS0tnTkc5WmFsSmlwRy9ObUNLWU50Ry9TcXRRaExCdHJwd2VhM2xDTHBYTmI5UWtNZU5tcTU1MDg5UnNHRHh1Q2lQQzJTRDV3V0huajVDZXdjSlBkY1k2cms5QytnTnh4eEJNN2pvUVplVVpwOHBDZUtXNkJEdTFZQmtiL0lXcjdTdG9YZXFiMjQrZWpRRml3N3ZBM2JjcmxjTFNYNzVGSUpBZ0s4RVhMbDZ2aDluM0RsZkRFamt2TWM5dTFYYVpHZ1NTZ3RNTHg1eHNrNlBwcVk5R1g2ZEFXMWl4WDQzajNuN2lKN0p6UythZmExWVFOSlZMS09aTkh6ajdCNWN6N0dzT1A2L2w2b2tORURSaXFPdXdvOXZ5Y2VsWTNmTWRaZUczMTkyNVZ0UGVYSTJrWHh0cTg4eEkyN3pUVXE2ZzUxL055cHU3Y01HdUVOY3ZGNlUyNUdwOFBVNy96UHQrUWlRbC9zMndPdURsV2ZPS0dIaE4xSHcvdzk3TjVtSzl5VGp1UkdOTFNVekY0MkJBMG54ZUtKVi8rQzFGZE9ucENtQU03c3VRcjA4SW1veUFrSVkxY1hGeHdQalVOMHorZWdhTy9IYk41K0syOTVPYmV4OXFOYTdCMjR4clZtcWJ2anB1QUw3LzZ3dUsydXYzRnZPMk9wUGpoMjEwdVNML3hSR1BKbTRENnZnank5MExmMXp4VWxZS05pWW04RFo5YW5ob0ZtOHFEdFBSVVJQZU14cWhobzdFeS9tc0FHSUhTNGx3Y09td0hURnlOVU85NU0vZHV1cm5EV2JYdk5qOTZxcm1HbnlXTHV4dXJRbW9ON1ZqS2Foa2dNZlpqYlBrZWhVS2h1Z2d2eTdqRVByY0h2NzJzZDVrZWhVS2hLdVppNytXUytuYXNybm9kRlFvRlZ2eFlPdjlVZlpod2dMK2YzbDRaUTh1MkFNSXh5M1B5TEQ1UFpjR1pQcWRLRmZIOVZSNVpVMW5YbUxCbXVWanlzWEJqSVR0SGdtMTdYc2ErVThVYUJmSFU5ejEvamUxelJyVUpRNGJEZE41VDFxNGRLL1B4VXIzbk9IU1k3RUdaU1BUdk93RExsaTJGekUvV3FhaW9LS1ZxMWFydncvemVzS2tRZWxoVkNhdWxoWTRjYmQvQnZXalZaaTlHRFJ1Tmh2Nk5SZThSVGpwYXI2UXlzUDdSUUptMzdpUHoxbjNzT1E3RXJ2UEV5TC82bXh4MlhMT2FoOW1GbVp6TjJvMXJjT0xVS2V6YnV4c3lQMWs0aElyUFVXRHlLam9tcmlKenBpVTd4S0xlbStiTSs4bk9rU0Rtb3h5Tmk3cmVuWnFnVzFzWCtIZ0pSVW11WkhuZ2oxc3ZzT2Y0WGJNVGliSTZma3Vzanp1UGo0Wks4YTlOOWZRZXk5SFRHUWFYVFJGRDdQaFVmTDZodEVqVHdkUFBFUXZkWWNLOTIvdEF1WGFyMHBaZFFUb1ZjUHQzYllRZTdVb3ZaRTlja0NEelRvSGVpM1N5UDBlL3Y4cTdWMXNvQUxOdVlwcjM5OExQUjRGSmd5OWcwbURoTS9iT3ZDYlllZWlxeGpaaVR4bFJXdkp4Q3I3ZlcxcXNUcGhEYlYwRjVYY0gxRVh1bzNvQWdLN3RLdDdmU25JZWlkc1RrSHprTUpZdlhZb0JBL3ZYaE5EN0dnWFR3NGZYUWVnMXc0SjVpekIvMFFLbjdXRTF4OXFOYTZ4NjN1K1hYUkFUcWZ0NDZScXY1dDhnelhud0NQL2FlZ0VKUjN5Uk1LZGF5ZnF2dXUwS3kvQ1VYMm5wcVdqM2VnY2MvL1dJTW5sZEI4NTdGUjBUVnlmUklhS0dSZytUclJVcXhZeGwyNTZYN1ZLTXhkTDlaT2RJakE2Wm03OG1TS01IejFqVlNxRjZxdjdFVmV5NDdIVnV3NXJsWW4yYzBNNys0d0hZc0t1R1JpOVpTbnFXMGNxOXR1cmZ0WkZxZjBkUFp5RGxraFJKeWZXaFBreDRkQi9kTzZ6ZkptbCtuL1F2SDUwTDRjRzloSC8xVlVaMUpHZjZuQ3BWMVBlWElZWnVKQWx6Y0l0c2FsdTdjcTZoYXVLbURPNTFXZlVldGtSMmpnUWZMMjFpZEo5K1Bnb2tmWEZScDdpVGRzKzdtTDZZS3NYdzJYbVErWGpoOHlsWFRUL0JBR3VxZ2hOWkt6ZjNQZ1lQRzRMK1B3N0ExbTJiQU5QRE9OZVZiSU5lUGQ0c2Q3MnNZbHFlZEJWL2JkTVFIY0pLazBsNW5nYzZUSDJCekZ2Vy9RN0l2SFVmN1NkN1lPMzBRTVJFbGs1WlVTYkQybXZIbGtjM3NqTFVrOWUrRUFxRnpYRnNWQlVMaXpNWmtYbW5kT2tBc2VZdkdkS2tnZVlGbDlpVmdpMmhYYUJsNmZlbVJ6cFlVN2hGKzVqWC91ZFBvOXZQWHhOazlPZmFQUTdHZXIrTkRmMFdPNjZ5T0xkZDIyVmlmZHg1L0xLOHZzYmoyb1Y3eEtSZHBHbk56dzAwaGdsSHRtNnNONEg2L2NJZDFmL0RndjJOSmo3T2xMUUN6dlU1VmFxbzd5OUR0dTNSWDB4RG1GdHRtNjZ2YXI1MmlmdXZHLzNkdG1XWDhjKytKWlRMN0d6ZWVRbE5ZK29iYlZ0ZkpXSC8ycFpYNVRUWDRGNlhNYVIzTTN3eFZlcDBvMCtJVEVuY25vQ0k4TGJLb2tYS1laemFWU2VuZ2ttcmlrTHhITkhUcnFCdnJDOG1mVlVQd3hiVVFkTmhlWHJYZWJXMDNjRnhGeEV5eWgyTHR6VkEzMWhmTkIyV2h6M0hyYjhoNW14dVpHVmcrUEJSeW04L2hYQ3poRVRDeE5VSTlXVlM3RDFjY2RMZ0N4clZQbGNuWlJoZDVpQnVaU2hHeExhMFN5eGQyMlZxVkxYTXpNcEd6SWY2aDcxbDUwalFlbWdnMm8veHNUaDVuVFQ0Z3NiU0R5bnBXUWIzRTdjeTFPVGNQZTBlQjBQeHBGeVNHazJJeEk1THpIT3JmTDBOWGRTYTZ2M2FzaXRJNDhzV1FwR20wdmZKem1NNUdzT0VPN2ZXZnlHdC9sbDY5TlJ3Z1JaN1ZFb0ZoUE52TFdmNm5Ob2pKbHZmWDlZd2RUNkVJbDJsbG43L1VPZXp2Zjk0QUQ3ZmtHbHpMRzkzMDd3Sm9GQW8wSDZNajg3cm1YSkppczd2Q091U2luViszLzVIUTlYYXNKbFoyUmcrT3dOTlkrcGo2dWRoR3AvWnFaK0hJZWFqSEozbnQycG0zd0ZVNitQTzIxU1V5OVJ5UUVUMnBCekdlVDQxRFFEQzgvTUxqcUEwZVkxQ3laeFdKcTJhOWh5L2l0VTdMdUxIQTVlc1dtdlZrTXhiOXpFNy9nTDJITDhxYXJ2T1l0L0J2VmkxSWw3NTdSSkh4bExSY0tpd0U1azFxalkrV0N3TVgxVW9GSWo1S0FkallzSXd1czlOVmMvVnNpMHRzUFkvZnlJbFhSZ2JtUGNrQk4vT3loRDlMcml3QUgzcDl6c1BYVVhkYUJuZTdsNVBtTDhGNEpmajdramNmeDBLaFpBRXRoL2poMk9yY3l5SzVlUGhBUnJ6SFhjZXVvcldRd1BSdDJOMU5QVi9qcHc4Tit3N1ZZeWRoMHhYNnRFZU12bk92TVk2cjgyV1hVR0kvZllwZ01kbEZoY2czcm45ZUdrVHBLUmZ3dkRad09KTlFqd1QvbllGZmo2S2tybHZqUUdVM3JuVTdqMGZQbHV6UUlNMXd4blZxUmRwVWw1MEE4S1FTMFBEQXNPQy9WVTNEakt6c2pIMTh6Q2QzbkZsOFNZeCtOZjIwSGhmREpqeEVxYTgzUUkrWGdYNDViZzdodmQ2WWxGQzVreWZVN0Zqc3ZYOVpRNUx6OGVyTFJSWXJ2Yjh6S3hzdk54SGd2NWRtNkJXVFJkUjUwSVA3blVaMys4TDBaZy9tcG1WalI0VGdRRC8rdkNzN29GSFQ1K1h2TmVGM3lHYmQxNnkrZnpHclF6RjBkTzZ2MHN5czdLeGZHdTJ4dkhySS9QeE1ycGtFcEV6a1VpcUlURGdaUVEzQzRLWHA1ZmViVTZjT29VblQ1K0lXbFRvUmxZR1hvK014TTgvSlNHcVM4ZVdFSHBlWTFCU3RHbkJ2RVZsbXJRcVh3ZWxhNWwvbE92NXRLUnA5bWVmb1YvL0dNajhaSjBnM0J4SmRteEVGUU1UVnlOdTM5ZThLRXU1SkxYcmZMWkpneThnOTFHb0ttRlNLQlJZdnZVaWxtOEZTcGZDMEwzamJZK0w0YTd0TWpIN25WQ041RTJlazRmbFcvTU1Ya1ExOEtzT1FMY253SmpZOGFrNGMwbnpRdEZRNVYvbG1vTHFDWks2MFgxdVluVlM2UnkxbllldTR1VVRFZ1FGQ01WQWJ0OS9CSG1POEVkUWV5NmJQZU1DeERtM0taZWtTTngvWFNlZXVkOHEyeWlDZWxJaERNTzFiL0VjN1NKTlNzS1FTLzA5MGFQZWVBa2ZxTDJPeTdkZXhQZDdaYWpuS3d3N0ZaYkdTZGZvOWJaRnEyYXUySG1vOVB2TXJHeDhzTGowWFBWbzE5aWk5cHpwY3lwbVRHWDEvckwwZkF6dWRSbUxOMm5PZFZZb0ZEcFZqeU5iTjlibzhiZld0N015MFA2YW44N24yZGpuRzdEdC9NYU9UMFh1b3pDc1RzcXdLZ0dmTmFvMi9IemtWdStmeU40YStqZkdnSmgrNk5tcmg4WHJieVpzUzhRUFB3ckZsbkp6YlIycStneDkrc1Vvazlkd0FHY0JlSjFQVGNQOFJRdHNhbHRiOCtCUVZYSWVIZDBOQURCZ1lIK3pueS9QbHVOUThtRmN1WElWR1JtWk9ISHFGTkxTbld1ZXVGVHFpNm1USm1Qc3VOR1ErY2xVajh1ejVZaGZ0UWJ4YTllS2V2T2hvWDlqdEduVnl1QU5EMHNOR3ZnV01qTGFHdng1M3FNOC9IN21qRlhIa0p0N0g3Tm14aXFYeVprS0pxNmlZT0pxaEhZbHpRdC95T3hlaUVYb3BWSXVGV0w4QXNiYXdpR1d4TkxVUHdnZkxzazFXWUhYbGxpU3ZyaW9kL2tOZFdIQi90ajk3OXZvK1g0OXc5czB5OFczczRMd3pydzdxdGRPdVFTT2trUWl3Y2ZEQTdEOThGT1Q4eWZGaWt2SjFuTWIxaXdYeDlaSU1Tck8xMlRzQWY1KzJQM3YyMGEzRVl0NmtTWWw3U0dYNmlZTnZvQ3JOeldYMkZBdWdhTWs4L0hDZDNFMTBHUGlMWDFOV0NSMmZDbzI3cTV2TXZHd3RFMW4rWnlLRlZOWnZiK3NPUis3LzMwYjdjZm9KcE5LWWNIKytQNmZOMUEvMnFxUU5QajVLSEFsNlpiSnp6NGcvRDRaRTlOWWxHcnlTejVPd2VnK1VzU3ViS0JUTWRnUW1ZOFh2cGdxeGVCZTRoZlBJeEpEdDg3ZE1XYjBLSXNTTm0wREJ2WlhQVDloV3lKV3IxbHJVOCtvUXZFTWc0WU94Zmx6LzRQTVQrWUZBQlBlbldoVGI2ZEVVZzFob2VGbzMrNDFxNUp6ZldSK01yMnZtektSMy9YZjNRN3RvZjFnOG9kWXVIaSszcC9KL0dUNFpOWjBmREpyT21aTW0yblZXckxxbWdlSDRydnYxcU5sYUhPYjJ0SDJ5YXpwWm0xbjdiSkkyM2Z1d0VwOERRQjlBUVRBOHZXRVNRdm51RHFoMlBHcCtPUG5Ba3djRklMSTFvMDFlcDdDZ3YweHBIY3puTjVjczB3dWhnZjN1b3c3ZStTWS9VNndYV05SRm43cDNhbUp4bnk5c0dCL3pING5HS2MzWFRPclIyTndyOHY0NCtjQ0RPbmRUTlVUQ2dnWGVMMDdOY0d4Tlc0V1ZiWVVLeTRsVzg5dFdMTmNuTjUwRGFjMzE4U1EzczAwNXBpcXgzVWw2VmFaRlZIUkx0SWs4L0V5T1JkdXljY3BlbC9YQUg4L1RCd1Vnbk5iTEJ1K2E4cXgxVG1ZT0NoRTR6MFJGdXlQaVlOQzBQWFZHMWExNlV5ZlU3RmlLcXYzbDZYbnc4OUhvZmM1eXZlTHBaOURjNnlQTzQvVG0ydGk0cUFRamRkQklwR29ZajIyeGszVUpkRENtdVVpNll1THVMV25LbWEvRTR6ZW5acG9IQzhnZkw0aVd6Zkc3SGVDY1dlUDNLWjVwMFQyMHRDL01iWnMzSXhkdit5d0tXblZObUJnZit6NlpRZk8vSDRHM1RwM3Q3cWQzTno3YVBkNkI4aXo1VWcrY0JnblQvMW1jUnNTU1RWMDY5d2R5NWN1dzZPOFhCdzllaEFMRjg4WEpXazFac0RBL3RpNmJSTWU1ZVVpTGpZT3pZUHRVdy9DbUxqWU9JTkpxN2FGaStkanorNDlWdStyVytmdU9IdnVsT2hKcXlWYWhqYkhybDkySUM0MnpxTG41ZWJlVjUvcnlxVnhSRkRseFlzWGpvN0JibDZrVklrQ2NORFJjUkE1RTJFcG9JdVFTQ1I0Zk16NFhGOXpwRnlTb3ZXUTBuYU1MVU5FUkNTV0ttRXZxcGk3cmF1YmV6S0FUb1VGK1dZL3A1eFpDdUQ5aVBDMlpnOG56WDl1KzgwZWZmc2JOV3kwY25pazNTVnNTOFNNbWJPc0hvNnFUSDR0NlVtVFNLcmgzWEVUekU3Y3lrTEN0a1JNbkRMRjVxSFU1akRXMDJxTU5UMnYzVHAzeDY1ZmRsaThMM3NhUC9ZOWk5YkhWVHVHN1dEeWFqUDJ1QkpWTXNxbGdOcTBxR3ZWOCtOV2hxcXF6cVpja21MQWpKYzBmcTV2N1ZZaUlxcllKSkpxV0w1MFdaa2xyWURRKzNqODF5UG8zM2VBVmMvZmQzQ3Z4VW5yeno4bE9WWFNDZ2l2dzkwN1dWYS9EdWFTU24ydFB2YUZpK2RES3ZVMWUzdUpwQm8yYkZocjFiN3NhV1g4MXhZZHg1bHpad0VBeGNYRm5lMFZVMlhDeEpXb2tsaTJwUVZhRHkwdGN2T09GZmY5c25NaytIeERKb2JQem9CYmF6ZTBIdkpZWTk3aHhFRWhkcDhIVGtSRXprV1owSTJiTUxiTTl5M3prMkhydGswV0QrTzBSa2xSSjd2dngxcGJ0MjNDOHFYTElKRlVzMHY3VXlkTkxyUG5SNzdXWHFQZ2t6TVpNWFNZMmRzcWU4RmRYRnc4b2J0K01GbUlpU3RSSlRGdjdUMmtwR2RCSXBGZzlqdkJWczJObTc4bXlHRGhud0IvUHc0UkppS3FaSlJKcTZNVHVrOW1UY2VlM1h2c2xyVDE3enZBNGNkb2puRVR4dUxubjVMczhqcTgwZWNObTU0L2R0eG9zN2Z0RjlQWHBuM1oweXV2dExGbys0UnRpY3IvUm9nZVRDVlRvUlBYS21FdmtnRVlMNGRMVkVtOE82QXVOc3h0ak1mSEhsdFVvRXJkNkQ0M2RZcjJLQXZrWEVteXZRSXdFWkdacnB2ZWhNckN2eFl1Y3BxRUxxcExSN3NsYmY5djlpelIyN1NYcUM0ZHNYWlZ2T2tOTFdScmdTUkxlbENsVXFsTis3SW5NUXVPa1dVcXczSTRjd0I4NmVnZ2lCek4ybVJWWFZpelhLeVAweDRLZkt2a2k0aW96RXkxY1BzQWV3UlIyYzJlOVErbnU0aVA2dElSLzFxNENCT25UQksxWFVkV3RiWEdnSUg5OGNISkQyMWVpb2JJbVZUb0hsY0FxQkwyWWdtQXo1NCtxL3JjMGJFUUVSR1JUZklBaktvUzlpTEozQ2U0dXJsSEFXZ0VvYW9uaWNqWmtsYWxjUlBHNG9QSkg0clduaU9XbkJIRHdzWHp5MjNzVjY2WXQ1NjFJNmdOL2FVeVZobDZYRkVsN01XY0RxR0IrNHVLWHh4MmMzVzU5L1gwcDJOZkNiMzN4TkZ4RVJFUmtVWE9WZ2w3OGREQzU4d3ArZGZzWkpmS3Y0V0w1K08vZS9lYXZUeVFNWGV6NzRvUWtXTjg5OTE2dEdyVHl0RmhXT3p3a1NQNEJOTWRIWVplUC95WTRPZ1FLcTBLdlk2ck5sYzM5eVFBZlFHc0x5eklIK25nY0lpSWlNaU9YTjNjMXdFWUFlQmNZVUYrUlM2TTRwQjFYSjJkUEZ1T3dLWkJVQ2llMmR6VzdheWJUbHZsMWhSTDF4NDFSSXozakx1SHhPeHR6L3greHVtR2FGdnpubEo3M1dvQnNQVEdHNm1wOEVPRnRZd0VjQTdBQ0ZjMzkyUlhOL2NBeDRaRFJFUkVZbk4xYy9jdXVWazlBc0x3NHBHT2pZZ2NRZVludzd2akpvalNWdndxMnhNL1I1a3M4bnpmc3ZMM3Y0OXdkQWc2aGc4ZlpWSFNxcmJtYXg2WXROcXNVdlc0QXNJZk13REpBTUpMSHRwZTh2MVpCNFZFUkVSRTRvZ28rWW9CNEFXaCtuQk1ZVUYrUmY4Ynp4NVhJK3JVOVZldHAya3RxZFFYNTgvOXI5ejJ1dmJxOFNiMkhkeHJVeHRsM2VNS0FOMDZkOGVHRFd1ZDRuVzM1alhzMXJrN2R2MnlBeER5alJoN3hGV1pWSW81cnVvS0MvSWZBb2h3ZFhPZkErRU9iTitTTHlJaUlxb1k4Z0I4Qm1CSnlkOTljaEI1dGh6eHE5Ymc4SkVqdUgzbkxxNWwvZ0dGNGhra2ttb0lESGdad2MyQzBMVkxaNHliTU5adU1VeWROQm14Y2JFMnRaR2JleC9EaDQ5U0ppRVdTejV3R0RseXVlcjdQWHYyd2R2Ylc3VW1hTE9RWUxzT2krMFgwOWZteE5VUjloM2NpNWJoZjhIVVNaUHh5U3pIekhsZHRTSWVDeGYvQ3pleU1peCtydHA2dE1saXhsUlpWYm9lVjIydWJ1N0t1N01CRGc2RmlJaUliUE1Rd05uQ2d2eGtSd2RTeHB5dXgxV2VMY2VzbWJIWThzTldzNFpXU3FXKzZOdjdUY3liSDJlWDNqVXhlbDBCb2NMd2Q5K3RONXBrSm14THhKNDkrM0FoL1NLdS9uSFY3UDFLSk5VUUZocU9OM3IydEV1UzV1a2x0V20rcnlONlhMVXBxeVNmUFhmSzVsZ0dEUnlLOUV1WGpXNmp2TkZpRGFuVUYzZnZaQ20vYlF3ZzA2cUdTS1hTSjY1RVJFUkU1WnhUSmE2clZzVGpveG5UcmJyZ2wwcDlzWHpwVXRHWDJwa3hiYWFvYTVwMjY5d2RIVHQwUU5PbVRaQ2JtNHZmZnorREU2ZE9pVkxGR0JCZWg3bWZmaXBxVDNSa1pHZWNQUFdiMWM5M2hzUlZTWXhZTFBtOFdHUFVzTkZZR2Y4MUFCd0NFR1czSFZVaVRGeUppSWlJeWplblNWekZtRXNKQUhHeGNhTDJPc3F6NWFqbjMwQzA5c3FLMmh4Sm05bGFYWmlKcS9tMDVrUjNCb2NLaTZLeVZSVW1JaUlpSWpzUUsya0ZnTmk0V0N5WXQwaVV0Z0Nod3ZBcmJWOFRyYjJ5c3UvZ1h2VHE4YVlvYlVWSGR4T2xIVEp0N3FlZktwUFdRMkRTS2hvbXJrUkVSRVJra3huVFpvcGUvQ2MyTGhhclZzU0wxbDc3ZHVVdmNRV0U1RldNMTZGVFZFY1JvaUZUdW5YdXJqN0VlNm9qWTZsb21MZ1NFUkVSa2RXU0R4d1dkZjZvdW85bVRJYzhXMjU2UXpNTUcvRjNVZHB4aE5tZmZXWnpHODZ3cEV4RjE5Qy9NVFpzV0t2ODlqTnd1VTFSTVhFbElpSWlJcXROL2VBanU3V3RVRHpEOE9HalJHbXJaV2h6U0tXK29yUlYxbkp6N3lQNXdHR2IyMm5vMzFpRWFFaWZodjZOY2Z6WEkrcERoT2M0TnFLS2g0a3JFUkVSRVZrbFlWdWlYU3V6QXNKUTJmT3BhYUswMWVUbEpxSzA0d2hiTm0rMXVZMGExV3VJRUFscDAwcGF6d0dJY1hCSUZSSVRWeUlpSWlLeXlwZi8vcXBNOWpQOTR4bWl0Tk1pT0VTVWRxd2hsZnFpZVhDbzZzdlMzdDhUcDJ4ZnU1VEUxNy92QUZ5OWVsRTlhWTJDc0tZMGljelYwUUVRRVJFUlVma2p6NWJidEM2b0pZNytka3lVZHRxMGFXWFRrakNtTkE4T3hhdHQyNkpObTFhUVNxWG9GTlhSckxtbDhtdzVEaVVmeHBVclY1R1JrWWtUcDA3aFd1WWZWcTJGUzJXamVYQW9acy82aC9xYXcrc2hGR05pMG1vblRGeUppSWlJeUdMeHEreVhBR3BUS0o0aFlWdWllcEpnRmFsVUtsSkVBb21rR2lKZmE0OStNWDNWSzhsYVRPWW4wM3RzeVFjT1kvZXVYNUNROUpNdFlaS0lYbW43R2o1NGY3THFmQlVYRno5eWNYSDVGTUFTeDBaVzhURnhKU0lpSWlLTG5UMTNya3ozdDJmUFBwc1RWN0dXaEpGS2ZURjEwbVI4TW11NktPMFpFdFdsSTZLNmRNVEN4Zk5GcTY1TWxtc2VISXBCQTkvQ0czM2VRTXZRNXVvL1d1L2k0aklIUUtaREFxdGttTGdTRVJFUmtjWFNMMTB1MC8xZFNMOW9jeHUyTGdramtWVER1K01tWU9IaStUYkhZaWt1WitNNHI3WnRxMzZUNGpxQUpBZzlySm1PaXFreVl1SktSRVJFUkJhN20zMjNUUGYzNVBHVE10MmZ0b2IralpIMFU0SjJqeHRWTGtzaHpHTWxCMkRpU2tSRVJFUVd5ODI5NytnUXlreTN6dDJ4NjVjZGpnNkRISStGbHh5SXkrRVFFUkVSRVJuQXBKWElPVEJ4SlNJaUlpTFNvM2x3S0pOV0lpZkJ4SldJaUlpSUxDYVYram82Qkx1U1NLcGgzOTdkamc2RGlFb3djU1VpSWlJaWk5WHhxMU9tKzZ0UnMwYVo3dS9kY1JOWXlaZklpYkE0RXhFUkVSRlpMTGhaRU5MU1U4dHNmeTJDUTJ4dXc5eTFVS1ZTWDdzc2VaTjg0REIyNy9vRkR4OCt4SWxUcDNSK0h0d3NDRjZlWG9pTzdvWk9VUjJaT0R1ZkNBQUI0REk0RHNIRWxZaUlpSWdzRmhFZWpzVHRDV1cyditqb2JqYTNjU2o1c0ZuYmpSZzZ6T1o5S2NtejVaZzFNeGJiZCs0d1dZbFplU05nN2NZMUFJUWxlTHBHZGNia0taTzRESTl6NkZ2eWRRakF1cEl2S2lNY0treEVSRVJFRm51anp4dGx0aStKcEJvR0RPeHZjenU1dWJsbWJUZHN4Tjl0M2hjQXJGb1JqOENtUVZpN2NZMVZ5d2ZkeU1yQTJvMXIwS3BOSzBTRXR4VWxKckxjOXAwNzBLdkhtMWd3YjVHeTE3NFRnTFVBemdLSWNtUnNsUWtUVnlJaUlpS3lXTXZRNW1nZUhGb20rNHA4cmIwbzdmeisreG1UMnpUMGJ5eEs3K2FDZVlzd2Njb2tLQlRQYkc0TFFKa095eVpOdWJuM3NlL2dYc1RHeFNLd2FSQUdEUnlxVEdEREFSd0VzQVNBdDBPRHJBU1l1QklSRVJHUlZRWU5mS3RNOWpObTlDaFIycm1RZnRIa05tMWF0Yko1UCtkVDB4QWJGMnR6TytSOEZJcG5TTnllZ01DbVFSZy85ajNsdzFNQUpJUEpxMTB4Y1NVaUlpSWlxM3d5YXpvYStqZTI2ejZhQjRlS01rd1lBSzcrY2RYa05vMGFOcko1UDlNL25tRnpHK1RjRklwbldMdHhEWm8wQ2NINTFEUUFDQzhxS2txQlVNQ0o3S0JTRkdjS1dYRFNHMElYZmd3QUx3ZUhRMFJFNHJvT0lBbkFuSXVmdlBMUTBjRVFWVFlMNTgvRDRHRkQ3TksyUkZJTjMzMjNYcFMyenFlbW1UWFA5SlZYMnRpOHIzMEg5OXJjQnBVUE43SXk4SHBrSkg3K0tRbFJYVHI2US9oN0ZBR0FmNDlFVnVGN1hFdVMxbVFBSThDa2xZaW9JbXFFMG1GYVJGVEdCZ3pzajFIRFJ0dWw3Wm5UUHhHdG11NS9mdjZQS08yWWtuekF2TXJGbGlxcitjUmtPWVhpR2ZyMGkxR2UrMGJnM3lPN3FQQ0pLNENSRUNaT0V4RlJ4Ulllc3VEa1NFY0hRVlFacll6L0d0MDZkeGUxelc2ZHUrT1RXZE5GYSs4L3UzZUwxcFl4T1hMejFvcTExRis3aS92NlZuYjE2dFlSdFQxbDhxcFd0R21KcUR1Z1NwRzR4amc2QUNJaUtqTUJqZzZBcUxMYTljc08wWkxYL24wSFlOY3ZPMFJwQ3hEV1VqMTU2amZSMmpPbVdVaXc2RzFLSk5WRVc2S0hCQjA3ZEJDOVRZWGlHYnAxNzZuOGRnbzQzMVZVbFNGeEphcVVaQjZ1R0JJa2MzUVlSR1VxZjgvU1QxM2QzRitvZloxMWRYTmY1K3JtSHVYbzJJZ3FnMTIvN01BSGt6KzArdmtTU1RVc1g3b01XN2R0RWpFcUlIN1ZHbEhiTTZabGFITklKTlZFYlhQd1c0TkVHekpOQW5zVkZrdExUOFdNYVRPVjM3TFhWVVJNWEN1STNnMjlOYjZhZTNrNE9pUnlzSVhSZ1pqZFB4REo0eVB3Ym1odHlEd3FSUzAyS2dQTnZUeDBmdWM0QzFlL2dFTUFQbFA3ZWdpaHhzRkJWemQzWGtBUWxZR0ZpK2Zqek85bkxPcDlsVWlxb1Z2bjdyaDI1VExHVFJncmVrenhhOWVLM3FZeGc5OGFKRnBiM1RwM3g4cjRyMFZyajBvZC8vV0k2RVBjQWVDYlZTdVVRNFk3QVlnU2ZRZVZWS1cra3UzZDBCdUxod1RaMUViS3RjZDRlNXZwTmNIc1RmczQxdTIvaGJSVHR4d1VUYWtaYmV0alpOZjZHbytGTERqcG9HZ3FqOTROdmZGNkN5R1pxRjNMSGUvM0ZrcjdmNU42ejVGaEVTckdaK0xOSUpuT01leDBrbU53aWVpYlhMaDEzaHoxeDF6ZDNBTWczUFdlNHVybTdsMVlrRC9TQWFFUlZTb3RRNXRqMXk4N2NENDFEUnZYZjRkangzL0QxVCt1YWxUMWxVcDkwZVRsSm5palowK01IVGNhTWovN2pCSksySmFJRzFrWlptOS81WXJwSlhOTW1UYy9EdHQzN2pDcmlyRXgzVHAzRjNYSWRFV1JmT0F3b3JwMHRMa2RtWjlNOVQ2OWRERmQ1K2Q3OXV5ejZqd3FGTTh3YTJhczhvYkRWTEJZa3lncWRlSktWQkhKUEZ6eGNjOEFqY2YrdmZNNmsxWTdxd2dKYVVWVldKQ2ZDU0RHMWMxOUhZQVJybTd1WndzTDh0bjdTbFFHV29ZMng4TEY4eDBhdzl4NS83Um8rN1BuenRtOFQ1bWZERnMzYmNMWWQ4WmJsRFFyU1NUVjhPNjRDUTUvN1p5VjJBV3dXb1kyMXpzVWU4REEvbGlKcnpGajJreDhzMm9GRklwblpyZTVmZWNPck1UWEFOQVhnRGU0UEk3Tk9GU1lxSUlaRTFZYnRXdTVBd0NlS29vd2RzMEZKcTFFQUVwNldxOERtT1BZU0lpb3JLeGFFWSswOUZTTG52UDdtVE9pN0R1cVMwY2MvL1VJUmcwYmJmYWNWNm5VRng5TS9oRFhybHhtMG1xRUdMM2lsbGk0ZUQ1Ky9pbkpvcm5MdWJuMzFaZEdZckZZRWJESGxhZ0NVYzVqWGJkZkdDWis5UHBESE10KzZzaVFpSnpOSEFCclhkM2Nvd29MOHBNZEhBc1IyWkU4VzQ3Wm4zMW04Zk51WkdYZ2ZHcWFLTVdRWkg0eXJJei9HaXZqdjBiQ3RrVHMyYk1QV1RlemNQdk9YUUJBalpvMTBDSTRCSTBiQitDTlBtK3dBSk9aTWpJeXkzeWZVVjA2NHQxeEUvRGxWMStZL1p3dG03Y3FoelJIQVZobm44Z3FqMHFkdU82ODhkRGd2S3lMbjd5aThmMjYvYmV3MEFubWpKWTNDMC94ZFN0TDh1ZUZmTDJkSEQ4VERwZGM4bThFT09lSXFFS2JOR21LMVhOTXYxcTZUUFNDU0FNRzlzZUFnZjFGYmJPeU9uSHFsRVAydTNEeGZLemZ0TkhzOTVWYW5BSDJpcWt5cWRTSnE1aDZOL1JHZERNcHdnTTlWY00wVTY0OXhwbU1SMWlkY2cveTU0Vld0eTN6Y01XWXNOcG8xZGdUWVlFMUFRRFg3dnlKTTljZVllbkpXeGExTFVhY1E0SmtlTFdScDAxeHE2WUFBQ0FBU1VSQlZFNGJkeDg4eDU1THVkaDVvM1FJdjZsNWY0WnVFQXdKa3FGdmhDL0NBbXZpcWFJSTUvNTRqUDJYY3JINWN1bWNCdTFqdWZjZ0gzL2Nmb2JFYzlrYU1XaFR2cDVCZGFvai9PV2FxQzZwcXRySDVidFB6WG9kZWpmMFJ2OXdQMVVCcEhzUDhuSHUyaU9jdVA1SUkwWkxOUGZ5d0p0Qk1vM3pmTzlCUHU0OWVHN3kvTmh5VE9YMUhCalMzcTg2SWh0NW8xVmpUOVN1NWFFeGJQcVAyOC9NZnErYmV6Nk1GWGxUZjIyVnI2dWh6NFRNd3hWSFBtaWw4ZmllMDNKTTJYdE5iOXM3UjRRaXNPNUxxdSt2M2ZrVHZkZW4yblQ4aHQ0THl2Zjd5L1dxWWZjWjgvNVlXeHZIOXdORFZLKzMrdXNqbHNLQy9FeFhOM2RBbUc5RVJCWFVnbm1Ma0xnOXdlcm5xODFQSkNlVWxwNEtlYmJjYmdXOWpJbnEwTkhzOTlhMXpEK1UvKzFrdDRBcUVTYXVOcEo1dUdKaGRLQXFnVkVYRmxnVFlZRTE4VmI3T3ZoaTEzV3JFcHIyZnRVeHIxOVQxVVdmVW1EZGx4Qlk5eVgwYkMzRGxNMjZWZERzRVdkN3YrcVkyVE5RNDJKWm93M1VSSFJyR2FKUHl6SDM4QTJyRTQrbDNRTVIzYnIwRjFGMVNWVzgza0tva3V1LzN3TUxUOTNDM0E2TjhMZjJ0VFdlVjd1V08yclhjc2ZyTGJ6UjBrQVArWXkyOWZGVyt6cW9McW1xOGJqNlB0NXFYd2MvSEx0cnNGZE1PejdsdnFOYnl4RGRXb1ozSGpUQTU3c3pqU1p1K3VMU1RtYlVqeWtzc0NaNnR2TEZ0d2R2NnB3Zk1ZN0oxREU2Mnprd3hORHJxR3pmM1BlNkplY2pUMkg5VFNsMTh1ZUYySE5hcnZHNmh3ZDY2dDFXNXVHcTh6bjh6NWxzMFk1ZjNidWh0VlZWcWMxbGp6aUlpTXlWZk9BdzVpOWFZRk1idWJuM01XUGFUTTR6ZFdMeHE5YmdrMW5UeTN5L1hidDBOanR4dGFTWUU1bkc0a3cya0htNFl2MmdFTDNKb0xycWtxcVkzVDhRUTRJc3V5dlUzcTg2bGc0SjFrbGF0ZHRlT2lUWTduSDJidWlOcFVPQzlTYXQycUpieTdDOGIxT1QyK256VnZzNk9rbWh1cEZkNitQN2dTRTZDWk8rN2JUWGxsemFQUkFqdTliWFNaaTBWWmRVeGNpdTliRzBlNkRPejRZRXlZekdCOERvK2RKbjladEJCaS95dGR1ZDNUOVE0N2pFT0NadHpuNE9qTW5LZTI3V2R0VWxWZkZocjBabzcxZGQ1MmVXbmc4eG5iaitTR2NmK21KOEs4aEg1N0VmTHVlSWN2enE2bmw3WUV6WEJtYTFxVTdzT0loSWZDVnJUTnBrd2J4RklrUWlydVFEaDlHblg0d29DY00zcTFiZ2ZHcWFDRkdSUFd6ZDlvTkQ5aXVWU2gyeVgyTGlhcE1wcjlUWFNlUlNyajNHdXYyM3NPZTBIRThWUlJvLys3QlhJMVh4SEhQTTdCbW85d0wvMnAwL2tYTHRzYXA5VTBtQXJYRTI5L0xBWi8xZjF0blBVMFVSVXE0OXhyVTdmK284L3Uva0c2WVBVQTlUeHdKQVp4aWhJZEhOU24reHpHaGJYMjh5ZHU5QlBsS3VQY2E5Qi9tNnoyOHR3NHkybWduTTBOZnFhbnovNjRXSFdMZi9GbjY5VU5xN21uTHRzZG05clhNN05OSjdRMEg3SEN2dE9TMVh0UzNXTVdsejluTmd6T2JMbXUvbmxHdVA5YjVIQWVFNEI0WnJKdC9XbkkrSGlnS0Q4U3YzbjNMdE1SNlowVE83K2JKY3A1MGV6WFJmc3pZQlhqcHh5SjhYMm56ODJxSmJ5OHg2UDJnVE93NGlFdCtoNU1PbU56SmgvcUlGR0RSd3FBalJpRVBNcEJVUWVzdGkrZzBRcFMweHFGV29kUWhiazNneGJwYW9TMHRQUmNLMlJGSGJORWRaVnpTbVVod3FiS1htWGg0NlBVN2FCWnphbnhONlRKVVhmdFVsVlRFbXJMWlp3eCtIQk1sMGtzMTdEL0oxaHFBYUc1SW5WcHpqWDlIdElkdWpOUnk0dVpjSFB2MXJJRjZ1VncxVE5xZmJWTWwyM2Y1YldKMGlMTjh5SnF5MjN1TjdxaWhTRFRGczd1V0I4YS9vSmtYS1laYk52VHgwMm5pcUtNS25pWDlvdkpaRGdtVDRzRmNqaldNZDJiVStkbHlXSTYya0IwbjduSXpaY1ZuMS8rYUhoVGhXbmpSdmVLdStjNk12THVYUTJtTVhIcWptTzRwNVRQbzQ4emt3WmZYK203aVI5MXpuNWtGekx3OThIaE9rY1E2alc4c0F0ZGZVMnZOeGJOdEZ2Wi9GdDdkZE5DdG1kYnZQM05kb3AwUHpXc0NSNjZydlpSNnVPc24xbmt1NXF2OWJlL3ltS09mVm43LzNGQzFybSs0aHRUYU95M2M0cklySUNuY0FvRjdkT21Zdi9mTERqd2syRlFwS1BuQVlDc1V6Skc1UFFLOGVqN0RybHgxV3R5VUdzWk5XcFJ0WkdlalY0MDJISDkrQ2VZdXdaTmxYdUhzbnkrbzI1Tmx5aTVjR1V2ZWZuLzlqVTlYaitGVnJySDZ1SVJPblRFR25xSTVsT3RmMThKRWpaYll2MHNRZVZ5c05EcXVqOGYyMU8zL3FKS1RIc3A5aTlmNmJHbzkxYkc3ZThJSlhHK25PYlp2MTB4V2RpOENGcDRSZVUzdkZLZk53MVVsR2ZyM3dFRlAyWHRPWXc1cVc5eHh2Yjd0b2M5S3FqRS8rdkZCVklUZmwybU9kN2RUbnhhWGxQY2VVdmRkMGVuT1VRM2ExWHdNQW1MSTVYZWUxM0h4WmprOFQvOURaVnQvemxaWjJEMVQxVGl2ak1EZkJNamV1aGFkdVljcm1kSTBpUGZZOHB2SjJEclI5azNwUGI0OTNXdDV6Zkp4MFdlZHg1VEJWVzg2SG1IWm96ZmZVSGk2c1BVejQzb044alJpdFBYNURuaXFLTUczelpmUmVuNHJaUjY2YlBackEyamhtSDdtT3Q3ZGQxUGdpSXBQdUFvQi9BMyt6bjdEcnY3dHQ2Z0ZidE9oejFmLzNIZHlMWGozZUZMMUh6Vnd6cHMxRWRNOW91ODBuVkI2Zm93d2FPQlN4Y2JISXpiMXZVNitucllsai9OcTFOajNmSGtON2MzUHZZL2p3VWFLM2E0ZzhXNDZqdngwemUzdXAxTmVPMFZRK1RGeXRGRlJYY3dIaXcybTVlcmY3NFhLT3h2Zm16QkVGZ0NiMU5DOG1mNzFnZUQxT1l6MTh0c1laM1VoMzJPU2FFNGIzWit1YW9mcmlPNVB4U09jeGZjVmNEQjJiOW10ZzdMWGNlZU9oVHBMV1NxMUFqdnFRWUVEb0tUcnlRU3NzN1I1bzhUeTlWbHFGZDR6RnBmMjRtTWVremRuUGdUbUdCTWt3dDBNamZEOHdCTjhQRE1IUzdvR1kwYlkrYXVrWnF1OHRjZE83RDB2T2g1alM4cDdySEwvNmNHSHRZY0w2cXZ4YWMveUdmTEhML0dUVm5uRVFrVkZYQVNBNnVwdlpUMUFvbm1IU3BDbFc3U3hoV3lMMkhkeXI4ZGkrZzN2Ujd2VU9aVHFjOVh4cUdpTEMyMXEwcnFhMTloM2NpeVpOUXNwMHpxdnkrTlFMQVUxNGQ2SlZiY216NVZpeTdDdWI0cm1SbFlFWjAyWmE5ZHhWSytKdDZ1MDFwaXh2TEF3ZlBzcWlHeVIxL0ZRM3hRL1pKYUJLaGtPRnJmUnlQYzBMOFpGZGpRL1pWZGU3b2JmSkMwSHRCUGZ5WGNNWHlzWjYrR3lOMDkvTFErZHhlMTYwMjRQMmZFeGpyeVVnSkducXoxRS9GMnRPM0ZJdDM2Sk9XVkU0NWRwamZQWmY4M3BkTFRuSDJzUThwckpRVnZFYXFzSWRCcUd0a1REODNyZmxmSWd0K1dLdXh2RXJod3ZyR3lhczNrTnJ5L0hyYys5QnZxalYwSzJOZzRoTXVnb0k2NFJpbVBsUFN0eWVnQVh6d2kycXpKcDg0REJHalJ1cjkyYzNzaklRM1RNYW80YU54cno1Y1hZYnZpblBsbVBXekZocytXRnJtVlp0dlpHVmdkY2pJL0h1dUFsMnJ6WThZOXBNZkxOcWhjN3huVHoxR3hiTVcyUnhOZDJZL205WnZhYXR1bTlXclVEUFhqMFExYVdqMmM5SlBuQVlIODJ3Yi9YZmZRZjNJakt5TTVJU2Y3RGIrMjdHdEprNk4yeE0rV3YzN3NyL25oVTlvRXFJUGE1V3NxWmdpU09VbHpqTGkyUFpUekZsYzdyZUlqT0FrS0J0R05XU1ZWSWR3SndxM09YRkQ1ZHpOSW9iS1ljTGF3OFRUcm4yV0hXVHhCN0hmKzZhYmsrN0tSWHBQQkNWSTNjQlhBZUFWOXErWnRFVFkrTmlNWDdzZTJadG03QXQwYXg1cEdzM3JrRmcweUNNSC91ZXFNT0h6NmVtWWZ6WTl4RFlOQWhyTjY1eHlGSWpDc1V6ZlBuVkY2aFQxMS8wcXNyeWJEa1d6RnVFT25YOThlVlhYeGc4UGt2T21UeGJqb2p3dGpoNTZqZFJZbFFvbnFGUHZ4aXNXaEZ2MXZhclZzUmJOZmRZSXFsbWVpTXRKMC85aHNDbVFhS2ZsL09wYVlpTTdHeFZ6MzdQWGoyVS8wMFdNNmJLaW9tcmxiUXJmeW9ybzVyejlWQlJZSEg3UVhVTUowTE45ZlNLaWhXbnZtVXR5bHRTcHAxa3RtcHNmTmlwOW11dFBXenpXUFpUOUY2ZmltbWJMK3V0eWx4ZFVoV2pYelhkbzZRZGw3RnpiT3E1dGg2VHZaVkZ2QVBEYTJ2Y3FIbXFLTUxjeEdzSVdYQVNJUXRPb3NPWFp6QTMwZkM4VkZ2T2g5amt6d3R4N01JRGpjZDZOSlBwREJOT3ZsZzZOTnZXNDlmbjlrUHo1bXVyczBjY1JHU1dKQUI0bzJkUGk1KzRkdU1hVlNLbUw5RmN0U0lldlhxOGljSERocGlkZ0NnVXo3QjI0eHJVODIrQVhqM2V4S29WOFZZbHNja0hEbVBHdEpsbzBpUUVyZHEwRWkxaFhiNTBHZnIzdGI1aWNHN3VmY1RHeGNMVFM2bzZQbXZJcytXcTF6ZXdhWkJxTHFzcHBzNlplcEl2OWhCZGhlSVpKazZaaElqd3RnYVBlOVdLZUVTRXQ4WEVLWk9zT2wrL0hqMXFWZktxVUR4VG5aZEJBNGRhWFhWWSszMW5UZUxmMEwreGVzOTBzbFdCa0FZT0ZiYlN1V3VQTklvV25idjJTTlJpTGRydHY5N0NHKzFQVk5jN1RIZjhLNGFUSkZ2anZKVDNITE8xSGh2OWFuMGMyNkZiWEFVUWtscG5HMHA4NXRvampXR2dZWUUxRFE3WGJ1OVhYV2NvcG5hVlU1bUhLK1RQQzdIenhrUHN2UEVRc3NPdW1QSktmWTJLdEsrMzhBWk1GQ0RVanN2WU9XN3U1WUZzUlpHcUlKYll4MlJ2WlJGdit4YTFOTDVYTHg0RlFMVmN6R3pvWDN2Vmx2TmhEOXZPM2RQNDdIWm9Ya3VqRi9PcG9namZwTjVUZlcvcjhZdkZXZUlncW9TV0FKanl5YXpwV0xMc0s0dUhoU29Uc2RpNFdFaWx2cWpqVndkUG5qN0JqYXdNbXdQYmQzQXY5aDNjaTRsVEpxR2hmMk1FTldrQy93Yis4UGIyeGl1dnRGRnRkL0xrNzNqNDhDSHlIdVVoL2RKbFhNdjh3eTY5cW5HeGNSZzNZU3o2OVkvQjcyZk8ySFNNQ3NVemc4Y0hhTTQ3dm5MbEtqSXlNZ0VBRjlJdjR1N2R1emJ0Vzk4NUE0QzcyWGRGR1Jac1NscDZLaVpPbWFRNjdoclZhNmdldDBXM3p0M1JNclE1QnI4MUNHczNXbGRRU2xueE9uRjdBakFNcXZoZWJkdlc0SE95Ym1iaDlwMjdvaVg2WTBlcGlrYXRCMkJkc1FqU3dNVFZTbnN1NVdwY1ZFYTNsdUhkdTA4MUxpUUJJY21aM2JFaGJqOThidFl5T0VycGQ1OGlHcHBqOU9mMWE2cDNPUng5YTJPS0ZhZjhlU0gybkpickpORkxGWUVheStFb254L2RXb1ovNzd5dTA3NGpiVW01cTdQTXlXZjlYNGFYMWdWMTc0YmUrS3oveTNxZnIvUnVhRzJNNmRvQXEvZmZWQjJqL0hraFpoKzVyck1QYStKYU9pUllaL2tWWlZ6M0h1Ump4TmFMa0Q4dkZQV1l5a0paeEd2T3NQamVEWFdMalJtTDBkenpZWWp5Um83TXd4WE52RHdzdXFsekxQc3A3ajNJVnlXcjJrTnZ0WHRrYlQxK3NkZ2F4OXdPalhTS2ViR3lNSkZaTWlFVWdPazBkZEpreE1iRld0MVFidTU5dXlVK043SXlSRW1HclJVWEc2ZWFIeXJ6a3lIKzI1V2lMcU9qZlh6V0psNldzdWM1TTRlWTUzVFI1d3NCQUN2anY4Yis1SU9pdEsxc3cxNEZvclJKcGI3cTg1RFhsY2xPS3dFbXJsYmFlZU1oaGw5N3JGRkE1ZjNlamZCR0t6OVZaZFdnT3RVMUN2blU4L2JRU1BhTStTYjFIdDUrdmE3R3hXcnRXdTVZUENRSTc5MzVFMC8rTE1UTDlhcVp2RWdVSTg2VkoyK2hmWXRhR3Z0U0wwWUVRS2Q5NVRFNGc3Uzg1L2p4MkQyTnBLUzZwQ3IrZjN2M0hoOUZkZmNQL0NNa2FRckJJTGVOTFRjVFJSQXhDNVVVZ1hBSGhVQWJGUHB3TFFFVWhJQkNmVVRiSURlbFZYOEtjcXZWeHdJaE54NmhRcXZJSlZCQTBBY3Z3RVpFTEJqSzFleEdGQldrTVluTTc0L2xETE96TTdzemU1MGtuL2ZydFMvSTd1eWNNK2VjT1RQZm5abHpucm8vR1ZNdXRvVHI0Zyt3M2ZRVHpXZnkxdTQ2THo5RDJPd25NWmpjdnlVYXh0ZkhJeGx0OEYvZGI4YStUeS9pY2tWMVFMZTI2dVhyaFRIdDhQakZTcTk4SmQvOFUrU082b0FKNjQrRmJKc2lKUkw1VlFaNUFERDJucHZ4YllYN3luaXpuOFJnWkx1bW1OeS9wZWs4R3FtUEN6OVU0N3NLNy8zNnRVa2RQYmJEN04wSTZqbGRsVjR2OGR5L2d0MytVQWsySCsxdWJ1QTFtQmNSR2JZQXdPNG5jK2JndFRWcm9ob2dXcEV5YUFVdys4Y2ZmL3hkbjM2OVd2MWowK2F3ekFGTDV0My82d2M4NW9yZHZPbHY2TjZ6WjQycm02Zm56eGYvM1F2ZUpod3lERnlEa1AzM0U4Z2QxY0hqOXNMa20zK0s1SnUxVHpSN2RMd0p0NWU0Y0tIYzJPMkZPWnRPWU5tWTlsN0JxWHIwMCs4cmZ2UVp3QWFiejArLy9RSHozeWpGd3Z0VHZOTFJPOEZzbjlRUWlNeVBXb1k4dGU4MGJveXY3M1YxMm5aVG5PNGdNanNPWHZDNCt2eG8yczg5dHQ5MlU1enVWVmJsczRmKzh2V3p4ai94dWpWV0wxKzJtK0p3ZStKUGNLRzhPaVRiRkVuaHpxODZ5RXUrK2FkNFlVdzd2R0F5ajRIV3g5NHozK0FSdERHUm1uOS8vZGlsR2JpZUxQdVBWeEFjaXUwUEJhdmtnNmlPMmdQM2JZa1RYbnYxRlF3YVBDaksyYkdHK1BnR2VQRzU1L0hRdy9Kb3lCTUJySzFmdi82ZXExZXY3dTNUcjllTkRGNmpyMG1UNWxpNWNwbjRjemFBV1hkMnVxUE5tdjk1RGFQSGo0bGl6c3daMEhlZ3NxMWxSVEVydFE0SFp3ckNoUitxTVdIOU1hKzVQYldjTFBzUEhpMzh6UFN0Z284V2Z1WTF3SktTNjJJbEhpMzhMT3o1M0hMbUc3OTVFZGJ1T2gvUzUzMUQ1ZEhpazFpNzY3elhZRXBxMzFmOHFMa05UKzA3YmVqN093NWVNSFcxZWZLYng3SHhYZi9MYTlWTnNOc1VhZUhNNzNNZm5zZU9nNzRIL2xpN3kzOFFIR2g5aUN1Mm9YVGhoMnJOL1ZacnZ0eFFiWCt3ckpJUG9qcHMxdFdyVjcvcjA2OFhGczFiRk8yOFJGM3JWcmZnSDVzMjQ2R0hIOFNQUC81NENkZUMxbXNmTytyVnE5ZGJsTmMvTm0wT2FFQ2cydUwrWHo4UTFJQlZ3WWlQYjREMUJRVmlLcHU5Y0Qrem5YbjE2dFh2SHZqTi9UV21MYmR1ZFF2V3JWc2ovbHdJOXkzOEZDSzg0aHFrQ3o5VVkvS2J4NUZSMGhqZDJpUjYzT2JtdWxpSmtwUGY0ZjNUM3dVMEZ5TGdEbDVIclAwRWsrK3lvY3N0TjhyclBsbjJIN3p6NmRmNDY4Y3VRN2NlaHlLZjc1Wi9qejZ2T0RDdGt3M3RreG9pTmZsRytTclV4eWN2NFhqWkZSUjk3SXo0YmFobVBQZmhlZnoxWTVkY251SjI2KzhyZmtSSjZTVWNkMzd2czB6VjN4ZGxLTDYvNjE5ZkIxVFhUKzA3amFLUG5SaldycG5IZWwwWEsxSDZ4UlY4ZE9wYjNXQTQyRzJLdEhEbTk5SGlrNWptL0I1M3QwMlViMzgvV2ZZZmZQN0Y5M2k5eElWM3k3ODNOSTl4b1BYeDFMN1R1RnhSalY1M05KSHZjRGhaOWg4Y092bWR4M3lyWnV6NjE5ZGVWNEQvK3JGMld3alY5Z2ZMS3ZrZ3FxTytxVmV2M3E5eDdaYmhkL2J0TXozM1pHMHhvTzlBckZ1M0JzMWFOTVBWcTFlL3ExKy9mbTk0ejZjcGd0ZTlmZnIxdXZHOS9mdVJPZnlCT25lYjlZQytBN0grOVFJQXdKRDd2b3Q0bS9uRG5DZlJwMTh2WEwxNjlidDY5ZXBsWG52Ym9XekxBSUo2ZGp2Y1dyZTZCUWZlMjZjTXZoZEVOMGUxencyU0pFVTdEMkhWNGRrUDlnRG9IZTE4RUJGUlJDdzg5bVRhQWw4THhNVEdTUUFXVmxkVitseU9xSWJMQXJBR0FJYmNONnhPQmE5Tm1qVEgwL1BuSzIvWDNBc2dFNzVIZHJYRFBhVlFHd0NZK3VEMGlBMnNGRzFwWGUvQjVqYzJpSUFMUUdUYmpIajIrRnJRcXZYalFoYXV0ZVU5LzN6SGtyZDBxNExXRWdCOXdKR0VRNDYzQ2hNUkVSSFZQbXZoZnQ0VmIyOTdzOGJjYWhtTStQZ0dtRGgrRWo0cE9hd01XaGZDV0JEaGdEdDQvVHZnSHRGMng5WWR1S045cDNCbDF4SUc5QjJJL2Z0M2k0QXJGNG8yRSs3Ymh1UGpHMkRIMWgxNE1tY09xcXVyTDllclYyOEN2SU5Xd04yV080dGJ1aytlT0k2MHJ2ZUVOVzltRE9nN2tFRnJoREJ3SlNJaUlxcWRzdUIrcGhOUDVzekJqcTA3MEtSSjg1QW4wcnJWTFdGWnIxSHg4UTB3b085QXZMZC9QMTU1N2MvS1d6VnZnYm5iTmIrQis4cnNjQkVrT1VvK3hLSjVpNks2ZmVFUUg5OEFxNWF0eE52YjVFbm5jK0Z1TDFuWC9vLzFyeGRnMWJLVllYbnU5NDcyblhEeXhISDU5dUNZbUpoMHVLOTQ2M0hVcTFjdkZVQkpzeGJOc0gvL2JxeGF0aktxOWRLa1NYTzVEQlZ0cmc4WXRJWU5BMWNpSWlLaTJtc3RGSUdZcyt3c0pvNmZGSkpncEVtVDVsZzBieEUrLy93WW5HVm5zV3JaeW9oZW9XelNwRGttanArRWt5ZU80KzF0YjRwcFZFNERHQTUzQUhFcXdGVnZybGV2WGh0Y0MrQ2V6SmtEWjlsWkxKcTNLS0xiSndMeVF4OGR3dXladnd0WkFEbWc3MENjUEhGY2VWVjZOanhIdjgwQ01QSEhIMys4OU5EREQrTGtpZU1oYlRPcmxxMkVvK1JEK1FxbHp1M0JXazdCZlZWOElRQTg5UENEY3IxRU1vQnQzZW9XTEpxM0NNNnlzNEZjMmFjZzFJVm5YRjhDOEdpMDgwRkVSQkV4KzlpVGFTLzVXb0RQdUZJZDFSYnVrVnAvRFFBWHlpL2d0ZjlaSGRCOHI2MWIzWUlISjA1VXpvbnE0Wk1qbnlJdk54OS8yN3dwNUlNY05XblNISDNTZStIaGg2ZWlUNzlleW85T3czMTFkVzFJRTNTWDJ3SUFFOFFiZS83NUR2N3lsMWV3Wjk4NytQcnJMME9hV0h4OEE5elZLUlZEQncvV0xOOW5GejhmVUowMWFkSWN2ODRZaHBtUHpsRE9rMW9DZDVDcUZ6VGE0VzR6dlFGM204bjV3eno4ZmN1YnByYzdyZXM5V3R1MEVJRVBZTlFXaXZZTUFIOTcvUTM4ZGZVYUhDcHhoTHhlV3JlNkJYZDM2YUxWN3ZiQ1hZYW5RcG9nYWFvTGdXdGJ1SGZJeENobmhZaUl3dXRiQUcyUFBabW0rNHQzVEd5Y0hjQmhBTE9ycXlwOUJyaEV0VlFmdUlNRmVlREtUNDU4aXJmKzhSWWNKU1g0N0YvSGNmbjd5M0pnMUxyVkxVaG9tSUQydDdlRFBUVVZRMzgxVkJuNEFOZEhUejBGOTFROEUrdlZxM2VqZXQzdjdOdUhMOHFjK1BRemM1TzgzOUcrRTM1MmN4SjZwYWVqMnozZDFFRUQ0SDRtZFMxODMyWWFDbTBCTExoNjllcHc5ZmJsNWVianlDZEhjUHp6endNS0tHOU51UlVkMjNmQW9FRUQ4TUJ2N2xjdlVnTDM5bVhDWUozRnh6ZEFjdHNVSkRSS1FJOXU5MkR3a1B1Q0RmS3pyaTB2VDFhKzU1L3ZZT3ZiMjNEa2t5UDRvc3dKWjdsVERoYVZiYVovdjc0WWZuK214OEJQY0YvSlhvRFFCSHQyQUxPZytHRkJLMzltMnAwb1B4OXRIbkJ2dzFxNDUwNm1DS24xZ1NzQWRIajJBenUrL2VKOUpQNHNMdHA1SVNLaXNDZ0JrSFhzeVRTZnQ1dkZ4TVpsd1QwNlpkL3Fxc285RWNnWGtWWDFBWkNsRHNTTXVEYjY2eWE0cjNocDdYT1pjTS9CcWJudVQ0NThpbjhkdXo0SC9RY2ZmSVJiYjAxR2t5Wk41UGQ2OSttbERuYVUvZzUzb0xvWmtiODFzekd1YlI4VVYvdVU5dnp6SFh4MXdUMEYydGRmZjQyUFBqb0VBQmcwYUlDOFROTm16YlNDY0tFRTE3ZFBXYjUydUg4Y01GMW4xNGh5V3h2QWR3SDNObWRCWjd2OU9IMHQ3WmNRbnF1VGplSE9tMGVBcjZhc0d6VmZkWEt0emU5RzlOb2RvWTRFcmdBUUV4dTM0TVlXYmVZM3NmZWZIWnMreWNoOTlFUkVWRE9jT3ZaazJpa2pDOGJFeHAwQ2dPcXF5clpoekE5UlRkUG4yc3NPZHdEUUZ0ZXZycFhBZlpKK0N1NGdhZytNUFk4bzJPRU9KdXpYWG0xOEwrN2w5TFgwUk5wN1RINC8zUG9vWG0xaGZ2dStoZmYyR1FtSzdMaGVaMjNocnJkVTFUcUI2L1ZsZEwxR0tldTA4YlYveGQyTndiYVpVT2dEei9KSjliR3NscjJJYnY1SlExMEtYQnZqK2k4OGJhdXJLdmxMQ1JGUkhSSVRHN2NXN3R2SkpsWlhWYTZOYm02STZyVDRheTlmS3E2OWFxSUVBREVHbHVPNWFPUTE5dkZaTllETGtjb0ltVmRuQWxjQWlJbU55d1N3Q2U1Zm9yS3FxeXJEL1R3RUVSRkZXVXhzWEZ0Y0g4UWp0N3FxTWl1cUdTSWlJaUxUNmxUZ0NnQXhzWEY5NEw0M1BSR2V0NThRRVZIdEltNWZFODg3TGF1dXFwd1Z4ZndRRVJGUmdPcGM0QXJJdHcxbjRmcjkrUnh4bUlpb2R0b0w5NCtUTDFWWFZaNktjbDZJaUlnb1FIVXljQ1VpSWlJaUlxS2FvMTYwTTBCRVJFUkVSRVRrQ3dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScERGeUppSWlJaUlqSTBoaTRFaEVSRVJFUmthVXhjQ1VpSWlJaUlpSkxZK0JLUkVSRVJFUkVsc2JBbFlpSWlJaUlpQ3lOZ1NzUkVSRVJFUkZaR2dOWElpSWlJaUlpc2pRR3JrUkVSRVJFUkdScE1kSE9RRFRGeE1ZMUJwQUpvQzJBUGxITkRCRVJFUkVSa1RZSGdGTUE5bFJYVlRxaW5KZW91RUdTcEdqbkllS3VCYXd2QVpnUTdid1FFUkVSRVJHWnNCZkFyTG9Xd05hNXdEVW1OczRPWUErQVJQRmVoL1ozb3NQdHQrUEdHeE4xdjBkRVJFUkVSQlJwMzMzM0xZNzk2MTg0ZWVva2ZxaTRvdnhvWW5WVjVkb29aU3ZpNmxUZ2VpMW8zUXZnUmdESUdqOEpmL3pUMDJoaGF4N2RqQkVSRVJFUkVmbXgrT2xuOGRLS0ZiaDQ4VXZ4VnAwSlh1dGE0T29Ba1BxVCtBWjRhL05tOU8zZko5cFpJaUlpSWlJaU1xemM5U1YrMmEwSHpwNDdKZDdxWEJkdUc2NHpvd3JIeE1abEFVZ0ZnQmVmZTU1Qkt4RVJFUkVSMVRndGJNM3gvb0YzOFpQNEJ1S3RCVkhNVHNUVW1jQVZ3Q3pBL1R6cnc5T25SRHN2UkVSRVJFUkVBV2xoYTQ0L3pIbFMvUG5ybU5pNHRsSE1Ua1RVaWNEMTJpakNxUUNRUGUzaEtPZUdpSWlJaUlnb09BOU5tYXo4czArVXNoRXhkU0p3QldBWC83bi9nZUhSekFjUkVSRVJFVkhRV3RpYW8wUDdPOFdmYmFPWWxZaW9LNEdyakNNSUV4RVJFUkVSMVN4MUxuQWxJaUlpSWlLaW1vV0JLeEVSRVJFUkVWa2FBMWNpSWlJaUlpS3lOQWF1UkVSRVJFUkVaR2tNWEltSWlJaUlpTWpTR0xnU0VSRVJFUkdScGNWRU93TTF5bytYZ1MveklGM0lBYTVlakdqU056UjZDRWlhQS96MDFvaW1TMFJFUkVSRUZHMjg0bXJVajVlQnp3ZERLcDhlOGFBVkFLUkwvd1BweEczQTVjTVJUNXVJaUlpSWlDaWFHTGdhOVdVZXBCLzJSenNYd0puL2luWU9pSWlJaUlpSUlvcTNDaHYxYmFIaFJYY2RhSXMzOTkySUxlOStoVk5ueXowK3F6cFlGVlEycE9vVGVIYnVWTng2NTBDTUhEVWlxSFVSRVJFUkVSSFZCTHppYXBDL3E2MHJpenBpd3J3N2NmT2dacmd2K3p4V3JUL21GYlNHeXVYTDMyUDZleC91TGdBQUlBQkpSRUZVSTQraVU2Y3VLSGQ5R1pZMHJLWjQrMDRVYjk4Smx6TThaVnJUdUp6bEdKWXhITVhiZDBZN0t4RlYyOXJCdURGWktNZ3JpblkyYWcwcnRBK1hzMXpPQndWditkS1ZHRGNtQzQ1REpkSE9DbEdkMGRtZWhwblpzMDMxcFFWNVJTaklLMkxmUitFbFNWS3RmOVdQaWUxVFB5WldxaDhUS3dYcWFnbDBYelpiTTBtczM5L0wxM3FNdnFSTGh5U1hzMXdhTkhDSWRPZWRuUVBlSnF1d3AzYVY2c2ZFU2tPSFpPb3VJOG92ZjExaEJIUG16WjdhVlVwT2JoLzFmQXdka2luVmo0bVY3S2xkbzVxUFNBdW1IWmlwdTNrNUM2UVowMmRKaHc4NkFzbW1sTCt1VUVwT2J1K3pmcFl0V1NIVmo0bVZiTGFXa3JQTXBia09zVy9ZYkMybEhkdUtBOHBMWFdLRmZpSi9YYUVVN1BFbTNBNGZkRWd6cHMrUzV1VXM4UHJNWm1zcDFZK0oxZndzMGc0ZmRFZ05FeEtsK2pHeDBvenBzMEt5VHF2MDRVU0JDbmNibmpGOWx0eUhtZWtIeEhlVXh6MXhMQTNWL2t2YTdyeXpzeWovQlpJRjRxNXd2bmpGTlFRR2RVdUtlSm90Yk0yUmw3Y1dKMCtkeE81ZGV5S2VmcWdVYjkrSkkwY2RBSURkNyt5Mi9KVzBJMGNkT0gybU5LcDVLTWdyd3RZZFc5Q3BveDJISFI5RU5TODFpWm02Vy96Y1lyejg2aW9jUGZwcHdPbWRQbE1xdDIwMWw3TWNmNWczRjgyYTJyRHQ3YmRnUzJyaDlmblU2ZFBrNzEvKy9oTEt5K3ZHM1JVVWZrZVBmb3FYWDEyRnhjOHQ5dnJzd2xjdUFNRFhGNytKZExhOFRKejBFQ29xcmlEbmlSeXNXTFUwSk9zTWRSL2UyWjZHbU5nNG42K1oyYk1OcmN2bExNZTRNVmxJU21vbGYxZnZ5cGZ5YzYzM1kyTGpOTy9tS01ncjhsaUdhcDV3bm9jVWI5K0psMTlkaGZqNEJzaGRuWXVGejh3UGFuMy9lR3NMWG41MUZWNStkVldJY2hpY2dyd2lETXNZam9SR2pUMzJvZmx6RitwK1IyKy9Ua3BxWmZxcU5BV1B6N2lHUU5jT0VncTNSRDdkRnJibXlMaDNNQW9LMXFOdi96NlJ6MEFJTEY5K3ZUT3JxTGlDWjU3K1U4aE9VR3FyamgzdndOYTMzc2JBZXdkRU95c1VoRTBiTitLdTFMdThnbFlBMkZtOEN4VVZWd0FBSDczL0lleGRVaU9kUGFxanpwODlCd0NhN1RMU25uL3VqMmpldkhtZGFQOHVaem02OStqdEZaQWNPZXJBa2FNT3JGbTNCdnYzN2pWVkZvODlQZ2RqeDQvMmVHL2Vna1VoeVMvVlRzMmJOMGZ1Nmx4MDdIaEhyZHZ2aG1VTXg5WWQzaWZyWWgvTEwxcVA5OTdkYTdqdnUvQ1ZDeSsvdWdwdmI5dG02bnNVSEY1eERZSGZEUEk4MExSdDFRSnRXMFdtQWQ5NFkySkUwZ2tIbDdNY3U5L1pEUUFZUENnREFMRGhieHY5Zm0vKzNJVklTZW5nOFl1WG12akZ1aUN2Q011WHJrUktTZ2VNRzVNbGY3NTg2VXI1bC9La3BGWVlsakU4NEdlb0hJZEtNRzVNbHB5bmhFYU4wZG1lWnVyWnhZSzhJblMycHlHaFVXUDUrOHJuUkpScDNQM0xyaGc4ZEFoU1VqcDQvVW9vZmsxUFNtb0Z4NkVTOUVydmo2U2tWaDdMaXJTU2tscHAvdEk0TTN1Mi9MbXY3ZkZWeGtiWDRhdE1lNlgzbDh1alYzcC9uL1VUcXZwME9jczlya0pNblQ0Tk1iRng2SlhlMzJNWjVWV1JsSlFPaHErb2lMeDI3OUViZzRjT1FmY2V2ZjErVit2a1lXYjJiTG05NmFXdjF4WTYyOU93Zk9sS3piUzAycUdaZGl5ZXZVNUthcVZiYjRIa1M4MXMrd0NNbFpteVRjL01ubzJrcEZaSVNtcmwwWGZvNVVPdkwxSVMrNG5aZG1PMmoxRnVxOGkvdUNvd2YrNUNUSjArVFY1V2ZYVXUxZjRML0x4VlMvbnY1VXRYeXV2UlNrZDUxUy9VZmNmZ29VUFFzM2R2M1cwVlpTTFNDZlRxaDBoVFhJWFI2bHVObURZbFcvUFZyVnVhMys4KzgvU2Y1S0MxZTdkMCtidHRXcWNBQUxyWWYyRTZrTGp3bGN1ampjM01ubTNxU3Azb1U3WGF2MmhmL3NySmFIOHAybXhDbzhaeWU5Q3FTelBIU2w5dDBHdy9aS1J2VTZjZFNGc3lrbzVaeXVPajNoVkd4NkVTRE1zWWp2dUdETVdFU1JOdzM1Q2h1c2RSVWFkaWYxSFhnWm50Vks5RDcwNENrVC9SanN3ZTU4ZU55WktEMXZqNEJoZzhLQVBUcG1SajFNZ3hhTmJVQnNCOWwxVDNIcjExMTlHc3FjMWp2eGI3NXVrenBYam02VCtaMm40S1FyVHZWWTdFSzl6UHVGNHRnZlRJdUx1azVVOTJsSnovakpmL0R1Y3pyc0xraVZPbHlST25CcnhkMFNTZW8waE9iaTg1eTF6eXMweGF6MjJJOGt0T2JxOVpydXBuQ2NYNzZUMzd5ZjhmTzNxQ0pFbVNOSGIwQlBrOWthWjRqdERmTTQxYXo5RHQyRmFzKzB5emtlY1NsYytUcUY4aUhWOXBLSjhkRWMvWE5VeEk5TmcycmZKUXZwWXRXU0d2USt0N1d0dmpxNHlOcmtPTDhyazI1Y3RtYTZuWlJveldwNUhuSDUxbExvODB4ZnJTZS9hVFA5ZHJnOHBudFBXZWN4VFBKbXZWaXpBdlo0SG05dWV2Sy9TWnZ0aVBqTFlGWloxTGt1OTJhT1Q1SkdlWlMzNCtVbGwyRFJNU1BlckJiTDdVekxZUE0yV21YSmUvUGtZdkg4cTB6TmE5SHFOOWpLOXRGYzlTKzJwZnlqSVFmL3ZxbTlYUHcwYXk3eERsMlRBaDBhTyt4SHIwYVBVRGVta2FhZmZpT1hSMWZadmxhejFpMzlmYURyMWpuM0kvUEh6UTRWR1B5cGN2ODNJV3lPdFFVclpIcmVmekJhUDlwZWg3R2lZa2VpeXYzamVDUFZZcTI0K1pmc2hvMzJiME9PMnJ2SXlrbzlXRzllajFPOG84TFZ1eVFuY2ZhSmlRNlBXY3ExYWRLcit2YkpOYTdWcTluZjdXWVRaL2FvY1BPano2UWZWNW5ycWRxdGVudDY4cHp4ZWlQZDVJWFhyR05lb1ppTVNyZmdRQ1Y2MUFWbXNuWStCNm5laTRST2ZwYThBaGRXZnJMSE5KempLWDdpQUM2bzV0N09nSlV2NjZRbytBUW5saUpqcFhmeWVSZWdlTW9VTXlwUjNiaWlWbm1VdmFzYTFZN2dUOXJVK1pIN0ZkaHc4NnBLRkRNcjFPcW9jT3laUlBZQTRmZE1nbmZUWmJTODMxcGZmc0p4MCs2SkIyYkN2Mk9FaG92YThzOHhuVFowbkxscXlReXpoL1hhRzhuSEo3OU1yWXpEcTBLQWNrRXR1ci9MNnkvTTNVcDVtRHZkNnlvc3lUazl2TEI3LzhkWVZlSi9aYWdhdnlSRW1jUU8zWVZ1ejFYVitCaGRoSDlNcEdMM2oyVitkNjdWRDVvNEMvY2hObFkwL3RLcmRiOFo2eUhzemtTNHVaOWlGSmtxa3lVNTdjNUs4cmxQZEY4Yjd5aEVma0l6bTV2Ynp2aXhQOVFPdmVGeU45ak5hMmltVzFmdURTT2lacWxhR29SMlZaaVpQMGhnbUpjbjFIc3U5UXB5Mk9CNzRDS2IzdG16RjlsdCsrVlkveXhGd01RcU44R1IzY1J0bk83S2xkcFhrNUMzeit5S2Qzd3F4c3c4b2YzdlFDZlYvMGZyUVF4MTEvKzZyUi9sTGtSeXdqNmxMckJ5K2p4MHAvKzRxWmZzaG8zeWJTRHJRdEdVM0hhSjhzQmdBVWRiQnN5UXBwMlpJVlVuSnllN25NbEhYY01DRlIzaGVVNTFicWZWeTlUdlV4eTEvZ3FqeXVwUGZzSitXdks1VHpwVjZIMmZ4cFVTNnI5OE9vcnlCVTczM2xkNHo4QUJsT0RGeHIyYXMrQTFmTFVaN0lpUTVIK1d1bCtoY3g4YjdXeU1QS3psNjl2UHFYU3EwVE1IWGF2anBBc3djTWZ3Y3J2WU9mRWNwT1UzbFNvTFVkeWhOcXZmZk5ibzllR1p0Wmg1cnlsMUYxR1dzRnFXYnEwMmpkNlMyckxHLzFDYVU0RUl0NjFBb01SRjdWVjRUVTM5WDd2ako5WDJVanR0ZGZXMUJlUmZIVkRyWDJMelc5c2xIV1p5RDVValBiUHN5V21mTEVXR3ZieERxVStWQzNCV1VBb2k1REkzVnZsSHAvOHJXdGFtWURWMlYvYlRidjRlbzd4RHJHanA1Z2F2UnZJMldrMWJmcVVaNllhNzJVKzQwWXpWbjlFcDlwL1dEVk1DRlJHam9rVS9lWTZPc2tXK3NLNVl6cHMweGRKZGJxWTBXQTRldnVDRFA5cGZKSEpMMWdQWmhqcFZiN01kb1BtZW5iL0pXRHI3WmtKaDJqKzdueWpnWmwyaUpnbFNUZkl3Z3JQeFB0Vk5sMnRPN3dVYmRKcmJZbTZsczlvcjd5dUMzV1lUWi8vc3JCRjczOVFyeG5zN1gwMkcrVlB3QkZleFQydWhTNGNuQW1pb3BYWG4wTmdQdTVIZkZBKzhCN0I2Qk42eFNjUGxPS0YxNVlpdnpDdFY3Zkd6WHFOMTd2amJoL09ONDdzQThuU285N2ZaWTVMTlBqdWFEako5ekxuRHQvWHZlNXRaM0Z1N3dHdFBESGNhZ0VmLzNyV2x5OGVCRTMzWFFUbXR6VUdNRDFFVHIxaVB5TXVIKzQ2VFJ1dXpVRjhmRU5VRkZ4QlY5KzZUM2lySEtnZ0hhM3QvUDd2dUJ5bHVOL2kxN0hCeDkrQkFCK3QwZGR4b0dzUXhDaitNYkhOL0NxZzdIalIyUHE5R255b0VWQStPcFRiejFDYm00K2NuUHo1Yi9QbkQzcmtSOHQ0ck16Wjg5NjVOWElkNVhwK3lzYnJlM1Zxbk90Y3RScWgyTC9Lbk9XK2MwYjRGMDJ5bVhNNWt2TmJQc0l0TXlVenlScURiaWh6SWQ2a0xTQkEvcDdEUUFTYk4wRC92c1lYOXNhckxIalIrT3h4K2Znd2xjdUxGKzZFby9Nbm9ITmIyNEdBRXlkOHFDOFhDVDdqbEVqeDJEOWhrTDUxYVoxQ2g2ZGtZMUhaczh3dlgwdVp6bit2UEpsbEo3OE53QWdyZXZkUHZ2V1FJblJuTlZXckZvS2U1ZFVsSjQ0am1lZS9oTTIvRzJqdkswVkZWZXdkY2NXN0g1bk56WnQzR2hxVUw0VnE1Ymk3VzNiNU9kYTI3Uk93WXBWUzcyZUgvUmw2cFFIOGQ2QmZmSjRGTVhiZCtMMG1WTEV4emZBZjQzMlBoNExadnJMcVE4K2lNWFBMY2JXSFZ1d2RjY1d0R21kZ25HalIzbU1hQnZNc2RMZnNjZFhQMlMyYnpON25GYXV3MHc2UnJ4M1lCOEFvRk5IdThkK3B0emUvZSsrSy85ZlBZTHdpbFZMNWZZcWxoTWozWGZxYVBkWXo5anhvekZoMGdSRCtSTDFjSFBTelI3cjBHcmJadk9uNWRLbFM3cWZEY3R3dDZjM3Qyd3lsRyt0L1hmd29JeWdSMThtNHhpNFVzUTVEcFhJSGVvaHgwSE5JZmszdjdrWkxtZDUwS08wcFhXOTIrUHZ5OSs3TzdBVHBjZDFweW94YTJiMmJMa3pFd2NvbzBSKy9Kay9kNkU4ZFlYWk5Nd28zcjRUdzBlTThGaS92L1RVWlJ6SU9nSVZqdm8wWXYyR1F0UGZFWGs5NURnb3QzK3JNTm9PalFpa2JHcTdZT3MrbUQ0bVZFWStNQUl2djdvS0c5L1loS2JObXFLaTRncWFOYlhKSjlLUjdqdnlDOWNpcmV2ZFdKTzdUcDRlNUhkemZvY1RuNWVhR3BtK0lLOUkvZ0ZEcEJWb0c2NnVxZ3pvZTRJdHFRVldyRnFLRmF1V3lzSDBQOTdhZ2lOSEhhaW91SUxseTFlWkhrMytMMzllZ2NGRGg4ai9OMHY5bzhXSno5MUJzUEpIWjMvOGxlZkNaK2FqM2UzdDhNS0xTK1c2WFB6Y1lwU2UvTGY4QTdiUlBpcWMrNHEvN1FqVmNkcUtmV2lqUm8xQ3RpNVJOdW9mUTRPWlZzWlgvbnIyNkNHZkg0Z2YzZ0IzV3hFL01xYWtkSkIvNE9uVTBXNDQzV2xUc2prVFJvUnhWR0dLdUJkZXVMNlQ2M1hzRlJWWDhPZVZMM3U5djM3OTYxN3ZiWHpEL1V2WmJTbmVWdytiTm12cThiZFlKbk5ZSnFxcktqVmZabjdSZERuTDVZTms3dXBjWEw3MERhcXJLcEc3T3RmUTkwVit4RGJvcFNFT2hzbzB6cDg5aC9qNEJvYnphc1REMDJlaW91SUtSbzBjZy9Obno2RzZxaEtYTDMzamMzdlVaUnpJT29TT0hlOEE0SzUvclZFZzFlMGwxUFZwSkcrQWU0b2FyYlNjenJPNjN4ZDVuZmpiaWFhL0N3QURCcnBITnZaWE5tSTVNM3kxUS9GZXU5dTg5eS9CU05tRW9oN010bzl3bFptdmZCVHYzT1cxZkRCMWI3U1A4Yld0b1RCNWNoWUFkL0F0K3VHUkQ0eVFQNDlHMy9ISTdCazQ3UGdBNTgrZXc2aVJZd0FZRzVsZWFkNkNSYWlvdUlKcFU3TEQycmNDN2lCUXEvNkI2eU8xaWxGU2JVa3RzUENaK1I1emRaODdmOTUwbWdQdkhZQlJJOGRnMnBUc2dLZFFFL1c4OFkxTmVIdmJOZ0NlVjlxMW1PMHZ4NDRmTGRmbHRDblpBRHdET0tQSHltQ094NEZ1eDlqeG80TStUb2VqRHhVQjJKR2pEcS9SZDBXUTJMTkhEL2s5OVVqRHlyOVQ3N29MQU9TUmROWHJOTlBuOU8zVkY0RG5xTmN1WnpsR2p2VGVQclA1MHpKNWNwYjgvei9NbXl1UGdEejNxZC9MTTFvb1I5disxZEFNemZWMDZtaEhkVlVsUG5yL1E3bE9mVjNwcGZCZzRFb1JKMjR4eTNraUIrZlBudk42aVk0a3YyaTkxM2UzN3RnaVQzbmdjcFpqWnZacytRcUdYbWVqTkhIQ2IrVThLRHZhZ3J3aXBLUjBNRDJrZTlrWDEzOHhWSjc4SGpqd2dkYmlYdjc3TVhlbi9kNkJmVjdiSllicDEwdERPZGRucUxqSzNXa05Ibnl2eDYvcFJyY24ySFhZdTZUS0I5dkhIcCtEZ3J3aXVKemxLTWdyd21PUHovRmFQdFQxS1lpRDBvRURIOERsTEVmeDlwMGVlWnM0NlNINW9DM3FTemxsamhhUjF6WHIxbmprMWNoM0FmZUpyTmczOU1wbThLQ01nTzVTVUxaRE1RMkZldi95ZGFLcUxodHhVbFM4ZldkQVV5VVlTY2RJK3doWG1hbnpVYng5SjF6T2NzeWZ1MUJ6bnNCZzZ0NW9IMk5MYW9IdTNkTGxQSWx0RlhVZ2JvbFRLOTYrRTQ1REpYNm5sUkRiTEc1ZEJUeFBDQ1BkZHlpbjlMQWx0Y0NFQ2VNTXA2T1ZwdkwyOEk5TFBnNm9iNTJaUFZ2ejVlK2szdVVzeDMzM0RjWDZEWVc0KzVkZDBTdTl2L3hkNVcyOXlwTjRNMTVjOG54UVY0VW1UODRDNFA3UlF0d203QytJTXROZml1MFZkMW5OZmVyM1h1c0w1bGhwcGczNjJ3Njl2aTNZNDNRNCtsRGxPZEVESTBkaCtkS1Y4dFE0M1h2MGhzdFpqc21UcytUajNZdkxsc3J0ZFdiMmJMeTR6TjFtNHVNYnlIVXk1TDc3dk5hcG5tTExuNmVmWGlDbitmS3JxeEFURzRlZnQycXBlVGVLMmZ4cHNYZEpsWC9ZcXFpNGd1RWpSbUJZeG5BODgvU2ZrSmpvUGFXazFpTlU2dlZOL08xRUFPNEFYajI5VTJkN0dqcmIwM1FmWDZJZ1Jmc2gyMGk4Nm5Od0pzc1FneVNZSFlCRi9LMDN0TDU2d0FaZmd4ZW9wMDlSRG9nUnlGUUtJazhORXhLbDlKNzlwT1RrOWg3cjlNZklFUC9LTk95cFhiM1NFSU01NkEyNll2UjlaZG5ZVTd0Szl0U3VIcU5US3IrdlY4Wm0xcUVsMk9sdzlPclQ2SUFXa3VRNW1JT3lmZWtONHkvUzlsY1B5b0Y3bEhsdG1KQ29PUmlPK3Z1QlRJZGp0QzBFT3gzTzRZTU8zYkpSMW9QWmZHbWxFKzdwY05SdFJPdjlZS2JEOFZYM1dvejJNVWEzVld0cUZMM3BjSlNVbzVTcUJ3V0taTitoYkN2cUtWVDh0VlYxMnNyUmRrV2FXbjJySG4rRE14bmRmM3p0Zjc3YXF0RVJVUFh5YkpUeU8xcURKR294MGwrcXA1QlJ0bTExT21hUGxiNzJGVFA5a05HK3plaHhXby9SZEh6dG8ycEdwc1BSRzhsZWJJdDZhcUJncDhPUkpNbHJ0Z09SanRZNnpPUXYwTEpRdnRTRFJ1bnRVeUwvZXRNVlJYS0tuTG8wT0JPdnVGSkVyY2xkQjhCOWE2Y2VlNWRVK2NxQnVDVk5UQkM5YU1FODVEeVJJOSt1SWlhRWZtZWY1KzE1WW5rdCtZVnJzZVQ1SlI3UE1YVHFhRWZ1Nmx6TkFhSDhyZmU5ZC9kaThLQU1KRFJzaE9Nbmp1T085dTN4eXA5Zjlwc1BZY1dxcGNoZG5ZdE9IZTJJajIrQStQZ0c2TjR0SFZ2ZmVsditWVnVaeG9uUzQ3aXhVU05zMnJoUmQvMkJ2cDlmdUZhZVdQdklVUWUrdTNRSkEvcjExOXdldlhXWldZY1dlNWRVN04rN0Y5MjdwY3ZsTVhoUUJrb2NCNUhRMFBzNUZxUDFhYVF1aE9YTGxzanBOMnRxUTkvZXZRQzRyK3lVT0E1aTFNZ3hIbTF3OEtBTTdOKzcxK3RXUEhXYWIyN1pKT2Uxb3VJS0VobzJrcityZFFWRC9YMWJVZ3VVbGg3em1QeThUZXNVVEp1U2pkTFNZNXBYRG8yMkJhMTJLTXJSeU5VYWU1ZFV1V3pFdWp0MXRHUEo4MHMwOXl1emJWU1pqcG4yWWFiTXpPUkpuUS9SRnkxYU1FL3pPMmJyWHNsb0gyTkxhb0gzM3QzcnNhM05tdG93YXVRWXZQZnVYbmxiYlVrdDhNZEZ6M2lVUjRzV3pYMldBZUMrTlZkOExxNGlDNUhzTzhhT0g0MnRiNzB0bDhucE02VnluZnBycTFyMU1tMUt0dHkzQXZEWnQ0YkxpbFZMOGRIN0gzcjBMU0svNnZxTEJtVjlQL0pJdHFIdkdPa3ZCOTQ3d0dPN1Q1OHBoYTNGelpnMkpkdHJ3Qnl6eDBvangyTWorN3pSdnMzc2NWck5hRHBtMnVhYld6WWg1NGtjaitOajkyN3BXUEw4RW5sZldmak1mT3pmNjg2N3VMcXByQ2ZsZ0dlaWp4azFjb3k4YktlT2RtemFhTzRXL1lIM0RvRFRlUlpiMzNwYnZyVzZWKzkwK2ZPT2QxeS9kZHBNL3Z5VlJlN3FYTG5QVnBaSHpoTTV5RjJkaTJaTmJjakxYV05vWC92REUwOEFjRi9GblRqcElVTjVvT0RkSUVsU3RQTVFkakd4Y1gwQTdBWUNIenhCK3ZnR1U4dlArbjkzWWRYNlkxN3ZWeDJzQ2loOXBSdVNEd0VKblFFQUQwNTZHQUR3MnVxL0JMMWVJaUlpSXNGeHFBVDJMcW55d0VOdFdxZWd0TlQ3M0liSWpNNzJOUFRzMFFPVEoyZkIzaVVWeGR0MzR1SHBNK1ZuVFpjOHZ5U2dFY0tERllwQlFhT2hVNmN1T1BiWkp3Q3dzTHFxY2tHVXN4TldIRldZaUlpSWlEeTRuT1hvMmJ1M3h6T2FqODR3ZHJXVlNFOUJYaEdPSEhYZ3lGR0g1dlF5M2J1bFJ5Vm9CYlNuUHlOcjRhM0NSRVJFUk9TaDdJc3kzSmJTenVOVytHZ0ZGRlI3REJqWUg5T21aS043dDNUNXRtZnhhRXJPRXpsZWozNFJLZkdLS3hFUkVSRjVzSGRKOVppT2h5Z1V4SHpGUklGZzRCcEZFK2JkaVU5S3ZZZEpQMWh3TWdxNUlTSWlJaUlpc2lZR3JsSDBTZWtWZlB5Wi9zVHpSRVJFUkVSRXhHZGNpWWlJaUlpSXlPSjR4WlhJSXViUFhZaXZMMzZEdVUvOW5pUGJFVmxBOGZhZEFJQzdVdS9pUGhrR0xtYzVQaTc1R0FDODVrQW1JaUpTNHhWWGlyamk3VHZSMlo2RzVVdFhhdjZ0VkpCWGhHRVp3NUdTMGdFeHNYRklTZW1BWVJuRFVaQlhGSkc4T2c2VllHYjJiTXlmdTlEcnM2U2tWb2lKamRQOExKQjBYbHkyRkMrL3VnbzdpMnYzaUhvRmVVVklTZW1BenZhMGFHZUZhb0g1Y3hjaUpqWU9TVW10UXI3dXdVT0hZUERRSWZJK0djNjBhcHBRN01jN2kzZkpaU3pVeERMV3kvUDh1UXN4TTNzMkhJZEtEQzBmN256VnhMSWxJbExpRlZlS0tKZXpITU5IakVCQ3cwWm8ycXlweDk4ZDdtanZzZXl3ak9IWXVtT0x4M3VuejVUaTlKbFNiTjJ4QmV2WHY0NDN0MndLYTM2UEh2MVVubWRzNFRQelBUNjc4SlVMQVBEMXhXK0NUbWZpcEljQUFMbXJjekYyL09pZzEyZDFZcEp4b21DSi9VL3NqN1VsclpvZ0hQdHhUU3hqdlR3dmZtNHhBS0JidHpUWXU2VDZYVDdjK2FxSlpVdEVwTVFycm1IeTB1TWZvK3BnbGRkTDZXREJTYi9MMURZN2kzZWhvdUlLOG5MWFlPejQwUjUvSzI4VlV3YXRnd2RsWU90YmIrUDgyWFBJWFoyTFRoM3RBSUJ2di9zdUt0c2duRDk3RHVmUG5ndkpzTzdidHIyRnk1ZStxUk5CSzFFb3JWaTFWTjRYYTFOYWRWVk5MR096ZVk3VU5uYnJsb1kyclZNUUg5OUE4Mjhpb3BxR2dhdEJOelI0SU5wWnVLNStvMmpuSUdBSERyam5oTXZOemRmOEczRGZnaWFDMW1sVHN2SG1sazBZZU84QTJKSmFZT3o0MFRqcytBQTVUK1Jnd3didjI0Vm5acy8ydUsxNFp2WnNyMlhFTGI0RmVVV1ltVDBiU1VtdGtKVFVDdVBHWkhrc04zL3VRa3lkUGszK095WTJUdjRlQUtUYWY0R2Z0MnJwY2R1eTBYVVg1QlY1M0xJbG5wOVR2dys0YnlNZU55WkwzaTZ4YldadVVTN0lLMEpuZXhvU0dqVkdRcVBHNkd4UGs1L2Y4N2VjK3Jac1pSNGRoMHJRSzcwL2twSmE2ZDd1YllhUjlBVlJKbUs1bWRtejRYS1crMXkzeUxmTFdZNWhHY1BsZEhxbDkvZTZuVTlkN3I3eUk5cGRRcVBHU0VucGdIRmpzalR6WXFSOW1sbWZtcWdQOVhZcDI2V2c5WjZ2OTVjdlhZbk85alM1RElkbERQY3FNejFHNmtyVVNWSlNLOTA2MFZLUVY0U2Z0MnFKVlBzdlBONHowMGIxeXMxSVdzclBmTzFqb2RpUGpaU1IwVDdJWHpyanhtVEo2L0xWVm8xU3QzMjk3ZFlyWTM5dFNHdTcvYldqVVBVMzZqeTduT1dJaVkyVHZ6dDEralRFeE1haFYzcC96ZVdYTDEycGV3dnZ6T3paaUltTjg3b2wyMGhmMHJIakhRQ0FMdGZTVWY5TlJGVGpTSkpVNjEvMVkyTDcxSStKbGVySHhFb0IrMmF2ZExVRVVYOUpKeDd3eU5ia2lWT2x5Uk9uQnI1ZEVUWmoraXhKV1JmcXZ5Vkprb1lPeVpUcXg4Ukt5Y250RGEvWFdlYVNrcFBieSt0U3ZwS1QyMHZPTXBlOHJIamZabXZwdGF3OXRhdTgzTHljQlZMRGhFU3ZaZkxYRlhxc1IveHRadDM1NndxOXRsdnYvUjNiaWpXM3EzNU1yRFJqK2l5L1phTXNZNzF0OGJlY01oMlJ4NFlKaVpybHMyekpDcC81MGR0Mm8rbEwwdlUyMGpBaDBhT3N4NDZlNERkZDlYZkVxMkZDb25UNG9NTlF1ZS9ZVnV5Vjc0WUppUjV0TUwxblAza1pNKzNUeVBxMEhEN28wS3dQbTYybC9MNVdXMVcrcC9mKzJORVRQTXBKdVc1bG1Xa3hVbGZPTXBmSFp5SU5kWjFvMFdwUFp0cW9tWElMcE8ySzd3YTdIeHN0STZOOWtLOTA5TnJxMENHWlBzdGRqejIxcTI3YjE2czc1WHRHMnBEV092WDJiVWtLYlgranpyT3p6T1dWdm5JZjFscGVheCtWSkVsT2IxN09Bci8xbys1TGJMYVdVbkp5ZTNuYmJiYVdrajIxcTk5OWlvaHFsanZ2N0N6NmdRV1NCZUt1Y0w2aW5vRkl2T3FISW5DVkpFazYvVVIwZzliUGVrclNEMlVlV2FwcGdldThuQVh5U1pYVzM1SjAvVUR0S3doUkV5Y1dObHRMS1g5ZG9lUXNjMG41NndybGRTbFB1SlFuZHZuckNxWERCeDN5OSt2SHhIb2MxSDJkbkdtZDRCdGR0NW5BVld5ZjJLN0RCeDFTZXM5K1h1V21SYm0rR2RObnlkOGZPaVRUNHlSSGJ6bGx3S0oxOHA3ZXM1OTArS0JEMnJHdFdDNXJmeWZIdmdJTkkrbUxjbTZZa0NqbjMxbm1rcjluSkYyOWRxTE8rOUFobWRLT2JjV1NzOHdsN2RoV0xKOHdLb05JOFYxUnR5SXZ5blprcG4wYVdaOFdFUnpvcGFIWFZ2MEZyc3B5RSs4NXkxeHlldjRDYWlOMUpkcXpQYldyL0w1NHo5LzYvYlVuZjIzVVRMbVphYnZxZlV5U0F0K1B6WlNSbWY3TlZ6cktnQ2QvWGFIaElGNU45UEhLOGhGdFFCbDBhWlduY3B2OHRTSGx1dWJsTEpEM1dhMDZEM1YvbzFjV2V2dVkxdktpM0pWOWdmaXhRNW0ybWI2RWlPb0dCcTYxN0JXeXdGV1NKT25TSVduUHVtSFMrK3Z2ZGwvOWpOU3J2RUNTcWk5NVphZW1CYTVHS0U4b2pGRCt1dTNyQkVFYytMWFdyN2VPUUFOWGYrczJHN2o2Mm1aZko2SkdULzU5TGFjOFlWYm5VWG5pS0U1UUd5WWsra3pMMTBtYmtmUWw2WG81angwOXdmRFZBMlc2eWl1bTZzOThyVy9aa2hWZWdZYnloRkc5WGtreTN6NzlyVS9MNFlNT1Eya0VFcmhxblZCTGt1Y1ZSRjgvR1BpcksyWDVLTGRYdVUxR2Y1RFFlczlYR3pWYmJtYmJyajlHOTJNelpXU21mek9hamlSZHYrcXVkOVZRajY4Zk9FVFpHUWxjL2UzdllobGY3VlI4TjlUOVRTZ0NWK1ZkQW9LNnpNMzJKVVJVTjlTbHdKWFB1SnFWMEJsWGYvWTdaTXo4QXJoMVkrUmV6Y2NBOVJPOHNyTnI5ejl4eXkxdEkxMEtZZFdzcVEwQWNQSGlSVVBMaTZrcTR1TWJlQTF1TkhiOGFIa2dDdlUwTTkyNlhYOW1LTlJ6TklaNjNXSmFubkZqc2pBemV6Yit0K2gxZWJ1Ky9QSkwzZThkUDNFY0FERGkvdUUrMSs5ck9mRmVtYlBNNnpQbHRyVzd2UjBBb0tMaWlzKzBRcEgrcUpGakFBRHJOeFRpN2w5MlJVcEtCOFBQMThiSE4vQ2FNMUxaVG80ZS9WUitYMTN1WDMzMUZRRFBVVG1uUHZnZ0FHRHJqaTBZUEhTSTEvTjdadHVudi9WcEVYbjJsMFlnUk4yY08zOGU0OFpreVMvbGMrbStwbkR5VjFmSzcrYm01c3ZyZitHRnBackxtT1dyallhaTNJenVZMERnKzNFZ1pSUklINlNYenJneFdUaHo5aXlBNjl0cjFJbFMvL3UyUDJiMjkxR2pmdVB4OThCN0IzanQyNUhzYjR3YU8zNDBtalcxb2FMaWlyenV6Vzl1QmdCTW5lTHVFd0k5MWhFUjFSYWNEaWNBZmZ2M1FVTERobmh3MHNONGJmVmZvcGFQeFU4L2k4dmZmNCtIcGt5T1doN0NvZDF0N1hEaEt4Zis3LzMzbzUwVlM1Zy9kNkU4clVKOGZBTlRnZUhsN3krRmRMbHdNWnQrZnVGYXBIVzlHMnR5MStISVVRZE9ueW5GNytiOERpYytMdzNKS00rQWUvQVRNUldTcjNKZitNeDh0THU5SFY2OGdmYTZBQUFIOGtsRVFWUjRjYW1jbDhYUExVYnB5WDhqdjNDdDZYUkR2YjVnaWJvNVVYb2NSNDQ2VEgvZlRGMnQzMUFZa2p4SGt0RzJHOHgrckJTcE1ySlNYWVI2ZjdkaWZ3TUFJeDhZZ1pkZlhZV05iMnhDMDJaTlVWRnhCYzJhMmpqYVBCSFJOYnppR3FEVnI3MktvZzNyMGYyZTN0aTlhMDlFMDk2OWF3L3VIWlNCUHo3L0xGNHZLa0FMVy9PSXBoOXU0dGZsMDJkS2RVZXluRDkzb1R4UzVJQ0I3cEVhS3lxdWFJNkFLMDRReFhKV294d1o4L2kvam50OUprNTJjMWZuNHZLbGIxQmRWWW56Wjg4WnVocDBXNHI3Q3RQR04zelBkK3RyT2ZGZXU5dmErVTB2VUlHay84anNHVGpzK0FEbno1NlRyNGhzK050R3YybjVheWNkTzk0Qmw3TmNEbHFWNVo2N09sZHpuV0swNi9ObnoySGFsR3dBMTAvOEEybWZ2dGFuUll3VzZpOE5MY28ycHpWeXNhaWJ6R0dacUs2cTFIejVPN0gyVlZjaTd3RHcwZnNmQnJUK1FBVlRib0tSZlN6WS9UaFNaV1FrSGFmenJLbDFHdG0zalRDNnY2OWYvN3JIMzhYYmQzcnMyMGJ6RktyK3hvekprN01BQUljY0IrWHRHUG5BQ1Buem1uNnNJeUlLRmdQWEFQWHQzd2YvL3Z3RUdqVkt3RzlHajVXbk40akU2emVqeHdJQUR1emZqNzc5KzBTM0lNSmc3UGpSR0R3b0F3RHc4cXVyTUN4ak9JcTM3NFRMV1k2Q3ZDTDBTdStQeGM4dHhuMURoc0xsTEljdHFZVzgvR09QejBGQlhwRzg3R09QendIZ25nczIyRnQyaTdmdmhPTlFpZUVwUUh4Um5pQStPSGtxSElkS1VKQlhoRmRlZTgxanViSXZydCt1cGp3WkVmUGYrdlBmajdrRC8vY083Sk9uYjNBNXkrWHBJc1MyS0pjVFU2K0k1ZDQ3c0EvQTlSOFV3c0ZzK3AzdGFmTHRzN2FrRnBnd1laeXA5UFRhU2FlT2R0aTdwT3FXdTVpK1NhbFhlbis1YkcxSkxURDNxZDk3Zkc2MmZmcGJueFo3bDFSNWZtTzlOTlRFOHErODlwcmN0a2VPOUE1K0prNzRMUUQzYll2S2srV0N2Q0trcEhUUW5GWkp5VjlkS2ZNK2NkSkRjdkJjdkgybjdyUk5vUkpJdWFrWjJjZUMzWThqVlVicWRFVC9JTFpIVE9kaXhxK0d1dHUrVnZtSWZkc2ZNL3Y3MWgxYk1IL3VRcmljNVNqZXZoTVBUNThKNFBxK0RVU3V2eEUvU2h3NDhJR2NIMTlFK1ZkVVhKR25oSnM4T1V2K1BCekhPbkVydU40MFFFUkVsaEx0aDJ3ajhRcnA0RXdVTWNxQk83UmU2c0ZIekU2SFkyUWFFT1UwQmVyUGd4bndScEswcDRoUWptUXFpTzFxbUpBbzJWTzdTc25KN1QzeTVHOEFuM0JOaDZQZW40d08xaExzZERqSzc2dW5qUEUxb0pmWjZYQ1U1WjdlczU5WHVVdVM5eFFueW1XVWc4UVliWjlHMTZmRjdIUTRZcUFwZFJsb0xhdWVEa2VaanBFcGlQelYxZUdERHMwNjhiZCtkUnErM3RON1AxTFQ0UVM3SHhzdEl6TjlrQmIxdER2cTlpSHlhV1k2SEwyKzNNaDBPRWJia0xMZS9PM2JraFRhL2thdkxOVGJiV1JnSytWK3FUVkN1NWxqblJGRytrNGlzcmE2TkRoVDFETVFpVmQ5QnE0MVZ2NjZRaW05WnovNUpESTV1YjAwZEVpbTdzaVNNNmJQa2cvcXljbnROUS9HNHNSR2I3NDg5ZnZMbHF6d1dLYzRjZE5hM3N5Nm5XVXVhZXpvQ1pMTjFsS3kyVnBLTTZiUGtrOW9sS1BXT3N0YzB0QWhtWElaMkZPN2VrenpZR1RrMmZ4MWhaSTl0YXNjZEtUMzdLZjVQZlZ5OXRTdXVxTlhxcWZ3MEh0Zkt3Mjk1WXlrTDBudUFFK1VpYSs2MWtxM2ZreXNQQldKc2p6VWJVcFo3alpiUzNrcUUzWGV4VFFhL3RxZEpCbHJuMmJXcC9WZDVYWU5IWkxwY3lUU1pVdFdTUGJVcnBMTjFsSXVBMS83Z1pHNlVUTmFWOHI5UVp5MCs1c1RXSkswMjVQWk5xcFhidXF5TU5OMjFmdFlLUFpqSTJWa3RuL3psWTVvZzZMOWEwMFZabVFxSDBueWJ2dnpjaFlZcmpzamJValp4bWRNbnlXWHM5YStyVXdyRlAyTmtYWmxzN1dVNTJMMVYzWWlIVi90MzBoZllvUjZubGdpcW5ucVV1QjZneVJKMGI3b0czWXhzWEY5QU93R2dPcXF5dWhtaG9paW9pQ3ZDQk1tVFFCUTkvcUJtTmc0QU83bkt6blFDOVZHYk9ORVZGZDE2dFFGeHo3N0JBQVdWbGRWTG9oeWRzS0t6N2dTRVJFUkVSR1JwVEZ3SmFJNlJjd1RYSmZVeFcybXVvVnRuSWlvOXVPdHdrUkVSRVJFUkRVUWJ4VW1JaUlpSWlJaXNnZ0dya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVV4Y0NVaUlpSWlJaUpMWStCS1JFUkVSRVJFbHNiQWxZaUlpSWlJaUN5TmdTc1JFUkVSRVJGWkdnTlhJaUlpSWlJaXNqUUdya1JFUkVSRVJHUnBERnlKaUlpSWlJakkwaGk0RWhFUkVSRVJrYVhWbGNEMWxQalBodlVibzVnTklpSWlJaUtpMERoNTZxVDQ3emZSekVjazFJbkF0YnFxOGhTQTB3Q3dZZVBmb3BzWklpSWlJaUtpSUcxWXZ4RS9WRndSZis2SllsWWlvazRFcnRkc0JvQXQyN2ZpU01rbjBjNExFUkVSRVJGUndCWXQvcVA0NytucXFrcEhOUE1TQ1hVcGNIMEp3SGMvVkZ6QnJ6THZSN25yeTJqbmg0aUlpSWlJeUxSN0IyWGcyR2Z5eGJnRlVjeEt4TlNad1BYYTdjS1BBc0RaYzZmd3kyNDlzSHZYbnFqbWlZaUlpSWlJeUtoeTE1ZTRkMUFHZHUwdUZtLzl2YnFxY20wVXN4UXhOMGlTRk8wOFJGUk1iTnhMdUJiQUFrRGEzZmVneHozM0lDM3Q3aWptaW9pSWlJaUlTTnZ4RTUvam5YMzdzUC8vM2xVKzExb0NvRTkxVldXdEg1Z0pxSU9CS3dERXhNWmxBbGdMSURIS1dTRWlJaUlpSWpKcllYVlY1WUpvWnlLUzZtVGdDZ0F4c1hHTkFXUmVlL1VCZzFnaUlpSWlJckt1dlFBY0FGNjY5aGhrblZKbkExY2lJaUlpSWlLcUdlck00RXhFUkVSRVJFUlVNekZ3SlNJaUlpSWlJa3RqNEVwRVJFUkVSRVNXeHNDVmlJaUlpSWlJTEkyQkt4RVJFUkVSRVZrYUExY2lJaUlpSWlLeU5BYXVSRVJFUkVSRVpHa01YSW1JaUlpSWlNalNHTGdTRVJFUkVSR1JwVEZ3SlNJaUlpSWlJa3Y3LzIzWnRINVZQREhGQUFBQUFFbEZUa1N1UW1DQ1wiLFxuICAgIG9iamVjdFR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgb2JqZWN0VWxpZDogXCIwMUpUS0VUNTQzMDVSMkdIRUhFQ1czM0EwQ1wiLFxuICAgIHNoYXJkVHhJZHM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiM1wiLFxuICAgIG5hbWU6IFwiQ29tcGFueSBMb2dvXCIsXG4gICAgZGF0ZVVwbG9hZGVkOiBcIjIwMjUtMDUtMDZUMjM6MjA6MTVaXCIsXG4gICAgZGVzY3JpcHRpb246IFwiT2ZmaWNpYWwgY29tcGFueSBsb2dvIGluIFBORyBmb3JtYXRcIixcbiAgICBmaWxlVHlwZTogXCJwbmdcIixcbiAgICBpbmRleGluZ1R4SWQ6XG4gICAgICBcIjhkYmM2MWJmZDkyZjQ4MzJkN2ZhYzc0NGI2NjFjYTQ1YmFiOGUwODcyNmNhZTAzYmU4NjY1OGM2MDE2YmFjMWZcIixcbiAgICBpbmRleGluZ1R4U3VibWl0dGVkQXQ6IFwiMjAyNS0wNS0wNlQyMzoyNjoyNVpcIixcbiAgICBvYmplY3REYXRhOlxuICAgICAgXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBR29BQUFCZ0NBWUFBQUQxdXVmeEFBQUFDWEJJV1hNQUFDRTRBQUFoT0FGRmxqRmdBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUNBNlNVUkJWSGdCN1YxOWxGMVZkZC83M0R0dlpwSk04b1lRY1VJd2t6OFF0TGFkc01DaVZqUEJmc21IeVdEdHNrZ2hzVlpwVnhjSitOR3kycEprcmJxb0NrMndDaTQvbWtSRVJZdkVpc2dmMmt5b1hYNHZrdHBpMjZoNVNDQ1JFR1pJR0diZXV4K25lNSt6ejdubnZubVRUSkxKNTJTdjNMbjNuZnZ4N2p1L3UvZis3WDMydVFFNEs2ZUZJSnlWbHFLMW5rbXJYK2Z0TVlCbk94Ri9BU2RSVGdwUSs3VHVTdmZEeFJxeWl3SDFwUWc0WDROK1Jpbjg5c3U3NDMrRmt5eXAxdGRobmk5RHhCazU5VkdTZ0VveUdLMm4yYTU2US84a3lXSEhvcGRWdHNNSmxCTUcxRlBQdlhRK1pwVTM1MUgrWmdWNEVhQ2FCWkJEaENybk5ZbEdWTFRBNTgrclJuZkNTUkxTcEQvVEFNdDRnNENDUmtZZ3BWclYwenhxSkJDWjdSeFVJOVZSbHNIMmVxYS9NNHFWYlcvcXhUMXdIT1c0QWxWN3B2NnFLSTdmVEZvelFCb3pYeUg5Zk9vTDg4VzByUVNjQWloYWVML083enp2blBiNzRRUUxZWE1lM2N4bnpiM1FraEpJYWNZZ1FWUlBDQ2dDS2NsMHhLQWx1VktOUk5OQzIzUk1JNFdmalNYdzQ5SDZTL2YvMGV2UGZScW1XS1ljcUozNzk4K09HMTNYb29MZklUUXVNeDFQLytqcHpBa28va0o2VkJrTUFBYk9nOFBhWkk3TitkZ0RMNnZHUytBRUN3RjFIVDFKMTRIY2N5TkQxaHhhY3RZa0FzaHFVajNSQkE0b0JpOGw3YXBURzdlenRoRjRVU09IL3gzTHN2dEdzdXo3TnkrZHV4dW1RS1lNcUYxN0c3OUZ2Zis3a09QYk1JS1pwQzJNZ09sODZuZ1BsdE1rUG9jYmxUVjNGaUJ3MjNST203cDYzc3pqYTA2YUpjdjBMVXJCRldDMUNRbUFPR0dUUjZDWUpiR0FHRTNLV01Nc2NIWWZtMFlDa2JYUWdNckhBTzNURDBhNnN2N21LMmNjRTJESEROVE8zWTNMVlF3MzArWnJ5K0RZRGxjTWt0RWdEWkZDWS9vWUtBc1MzNEJpaFBoNGFtRnRzajRMMitJVERoUnAxREphdlR1am0wdXNacWhHSTdmcnhBQWtvTEU1ekFoRUJzcnVzK2JQQUdTT0k4S0JBcW9CTjgzd3l5TWorcTRQMzNqT0wrRW81S2lCMnJsYkw4Q29jU2NCY1ptOUVtbUxkTDVCQmRpMFljNGJFZnNtTGVEUmZ2Rk5GaER2cDFoeUlSVDY2WGx6NHJmQ0NSYW01SFFqWDJLelJrQ3BlbWExeEpvNWJjMWNVbWdRRVFrbUdrd3lyR2FSOXJGNVRITGFickJHNmRpWVRqYWg1anhqR2grZ3kvekR4NDRRTUFWSEtEdjM2OWsvMzVQY3JxTGtNYUxWcnpVLzBQa2g2dk5jR3l3SUU3U2tRYlRIUEJJQ2tyMlMwUjdiem1RQ1BVanN2eDZHa3lCa21rZnlETDZZWnhvWkZDSVNTTnBsdGpPNlhmWkJ0STFwbWpNWVNLWlNFZlBETE9kMitreUczV3hUZTZyTk9lQS81M3dzTFZxL2N5eEpuM2pYdmIvNnlIVWZmMmJoWk8vdGlJRGF1YmR4T1JudWIyaWRyd1RSUnZZclNpNGs1czREWjBWTEovZ0czczd0bHZOTFhxUDR6elB6cXZHbjRDUkpIT01Yc2lUL1FxWnpDcVhJTGh0Z1BHQUVSRTRBTUNnR0NHVUFOVURaZFdhT29jZk9nRzJCellMMmxEU093YVgybXdtM2J3MXMrTlVOazdtdlNRSEZXclNUdEFneS9TWHErQXNzT2JBbVM2T0pONFF3c0ptamJSQy9oQ0Q3ckY5eXZvbVBzeGFTdDNLek1vQ0IycnEvRWIwVFRyTE1taFYvbmhqNW55UmFmNVU2KzFjcGc4VGFRQ0F4eVJCdFFkRVlkQ0JrbWQzbVk5bG5rVjhpVU5DZVEvc1NxMUhVUm15UmowMWhFV25ucHJmZTllejZ3OTNUWVgzVVQ1NSs2WUlLdG4xSzZmeFZyQXJrZzNLMFoybEh0UTJKZ0FJVS9zaCtLVGNVM01DUW14Z0tXZnVLbU1tc05SeWtvKzVYS3Z2UnZHcmx4M0FLeWhOUGpWMDRsdWgzVU1kZk9wYm1DNHdmNG5pcUlTU2lJQmttMWpMc1QyS3VKRVZMTWdnY1Erc1RTenFJb0poekdGeitEdnBUVStuWTBpMjNMYXExdW9kREFyVnpqMzYxenBQUFVLZWViMk1jcXdOS2V0dXhPMkZ5d3ZoRWc2UWRoZkVwQTZJSmJtV3RmeGhoOU1sNVZUd2x3WmxJQnY5cjVCcWk0TXVvMHkrbmptYS9aUWhEUFN2aUtHWitTWWFPQlJyQWhQMEo2WEMwWGl0bVdTaFAvcUhBbWhDby8zNnkvbXRSaEE5RUNycWdDRm85OWJhK2hieVY1UWxCNENwYXBTMmdpbzdMaGQxeHpFU2cvVWpuK2IzejUxVitCS2V4UFBpREZ5N0xzdWlPMFNSL0JkTjBFeEF6V013R0RUaFlBR1BvdkFGU1lqQTAycGZudWxYL0QyVTZ1K0tSRHk0bzVSSmJBc1hVVzBQNktQVjVsd2RJVEpXTGY1aU9Rd2dTK3lqTnpkckVUbHBNbzVKMEEyY2JxT0VqNTU4Q1NkZXBsSTNiRGw2YnBObHFNb2NMeFFTU2xrRmt6UjBCMWpBMDNtaFI0b05qanJPMGtqNFNkYUkrRThaTXpjTlJqSXUzM05KVGM5OHpqa3l3VDhvaCtRcFpzTm5tT2tJU3pMWDRCTW9ObVM5Z2orTXZZdEZnVUJpa1hPdndrdXlIL3UxQUZyM2xUQU9KWmVXU3JxK08xYlByc2pSN01CUEtidG1lb2VNVWUxSHkxakJFSmhMZzJrelhoU0NCNFdST2I3Q2FwN0IxK2ZvOXZlNTd4Z0ZWZ2ZndTlra1FtakhQc1lPc2d3MW1qU1laM3NZUEJGZ0M0VFhRYUpxNlovNjViYXN2bm9jSDRReVZtNitjdTN2MVZYTnZKVWIzajhUa09ZVWtGTnpFVnBBS0d5Uk5RNDYvdER6OFBvYlJZZ0oxWVFycFllL05VdHpvUHBlQStwL2Q5YmZUd2E4RDQrRHNxYkpkZ0VYK2hqWElXanZ4V1dBcE9ST0lDRDJqNHpUUTMvU2NFOTBMMDBSdVd6YjNMcUxlZjBmaldRYWsxSUpsNDYzTWFSV1dBREVTV0MyM2pZYWw1ZjFYZlhqM2F2UFo3V2VUMXc3eEE3UzVvQ0FHRHFpQ1JGZzZicFEyUnc5ZWtYQ1ZpL0xEY3MrQ2N5djN3RFNVOTMzKytac29uZlJoVHliTVVBaVloTzBFQktJa0pkOUYvdXBnWEYva05Tcks0OThuNDNWQmtWRUFJUWVvVzEyS3g5VWtMZVNEWGJSTWs3L2t2dWtLRXN0ZDE1L3p5VFRMNzJVTnlxMFdHZTNLZzU0VUdsMDJnUUJRK0NuZlVwMlZkcXdxZ0VMNDB5QldNdGxzZE9ORm9rbUZacUdQajl4bE9iQ1ZPT3JwaW83dmcya3VXUnJmUWVBY1NFeFdnck1aR2tPVHg5MUxZWW9MZGoycHlMVWVid1lCVmh1Z2ZybzdlUjMxLzRMaURBMmhHbkhNNUxhVnRXOGxMVk1tT1M2YXArR2VlZlB3R1pqbThxbjNudk1DK2F0UDJOUVRCN1l0UWlFSlkveG43ZlRESG11R0hPeitxZ0dLT3ZweWw3K0RrdVlVeVZJelZBRmE2ekQ0VlNqNUlKdVpZQXdyT3ZvaG5CVWpCNVBSajFzQ3dhRmxFMDYyajdHNVhZZCtQd0JOU2R1dk9TcGlHWnlqalZZMWRRcy9KY05PcUl5Q29UTjdQemlyVFlWc3VXWFJNREcreDRLbnV5QUFXcnlNbU1NZ1dTM0l1Wlh4L0Rid0lyaTZtQm00SVhNUWR1ampKbkI1Tzd0Zkljb3doUit4TmFlUkFrNTVVY2ZwTGhubDc4eEdLeC9sM0VWSkVXVFR0Y2s1eXYrUm9TUnZBc0hSYkN0S2NIY0RncHkzVTBJNHRDUmgzU2pUV1NtTGUvcWJmVHY2TWIzQUwwRVpJTHVwWGNBcjFzdWQ0UVlBSlFQQmdKUXlEa1p5LzhWSFBFdzhqWVJpem1vSUNLOWJBVGZlOUJYQ2JkTEg2aWtzaUliZ1pnTmJOS202WXJqQ1hUY0FTZWk4SVI2WHdWa3BDZEh0UHJQaEdKNlFDTnRrR1hTUmpHMGhZZ0lGS0h5aWFhamNNNDhTeTVPS0lqLzA3aDBhRFdXWUNpTG9lV2E0Y1NtY0ZTUExQN0s3anpwb29mdHN3TkFhd3h5ZmFXdVpWQkFKZlJSMFJQK2lkVEFReU9qTHdGOVVPRFhoZGk0UXRvVXA4cVZhU1Z1azhZUlhENTJxb2xYYnFqQW1DZ0xZWW1oRDJIT0pwamNENTFqZmhYUHhBUG13NzduQkVPNXo1M2UwUzc2YWkxcC94Y0lhcEV5ZEE1L0N3MDIyTkpuK1hITldxMGliYUlpQyttNkYrMXpTcG9EUk9ZQ0M0QmEwYmxJd3JiY0ZLU1RjVU95eDlCdDk1R3hQbEVIQWd1WEo1NkpHejVZbHh4clg3dHZIZzQ3VFU1YXYyVlhOYUR5cDNPRWhBdzhTczdvODVsZGlodEpPMGV3bUQ5U2lsMWUrVDJkL1Q0dEdlZDhrUXhnZ0RndEtYNTNiMFY3TmlYUE9rcmp3U3ZYa2JkbGRNRTBsbmRYeEVLMTZlYnZvZUdmdG1qSVIyb1ZTL3FnU0xhZXphOTk0ZjgvbUVyTk82L3BETmpiQ29nUU10Zk5CQnNISTF1UVpMMWh3ZS9DeGxmM0NuTFZ2OGY0RDJVZW5rMmF4SmwxejU5NkhxQXY2Sno1S3U3OUZaa0ZiUXUzVFJZSW1yNUpzYktscEN5OXg0Y0wySnpCU2Z5OVpjY21PWStuQ1hOTnE0aXBIeTgwVkM2Wm9xMTBOQmVVYjZJL2FzL3RHUm5RUG5PSENQaW1mMWI0VmVHNlZDSGQwaVhiYnVoSWI3alRGVkg0L0ZGcEc2M1dQU2tYU3VGaDE0Ym54WnJyTVYrV0x0QXBIYlAzQUlOZm5LY2Y4dUNJcDkzemVCVnRGTVV4UEk5ZjNQRCtTWGdWbnFGenowYjJyOHd3ZXA4N29heHBPTHdXMjNzd0JGTG02SUN0UjhsMEtOeno4Z1o1MTdtUExJR3ZuenYyeks5WFpuNk8rdmdqTUVMdXJOcEpzT2ROMnhhVmZkdlpGRUlNSnN6ZVpkc213RTZBOHJCbnhjZnF4Ukt1N1QvUXNqZU1sYi8vWW5pVnBpcmZUVU1ZVnJrQWwzQjlxRGtDUkxuQkFoVFRkdGVmV0R1NTQrSVB6RjRmWHdvbHVnaWVrZFdTek54R3R1RGlTdUNxWUljaHJKaEdCdGhrZ1hBSTNLQ09qOHhqVVBPY05ycFJsZy9wSUF1cWZUMWZBYnZqMDg3L1JHR3ZjbktTd2dtZDZhQWRRRTFqTy96UkxFNENsei9STVB6N3lVdjJLd1hXTGhzTnpFQTRqVHoyWC9EVjkzL1VBYnN4SmxXc2pFTnlkYVdIek9xeXg0QjBNbEdXSXl2azFiYjBjL2p0NXZFZG16OER2d0drZ04zMzYyVGVTR2YvYlJxTDczV3pFVE9yemVIK1laWEJwb1daLzVJOXBTcnBLeGRmbXI3Ky9aMldyN3o0c1VDeS9mSzd4RnpIaW43c0tXUUEvMTBrWE16SmNLZ3RMNWM3c3kraVB6REkwVktRb2xPR2cyWlkzN3lGdnVaMG96cU96WnAzWTJlYUhrL2Q5NGRuZlRsTjFWWnJxNndtWWMrd2NKMXRneWR1dHppbHBESGVMc29tQlp1MHFnWWk0K3VIM3YvenVpZTVqVWtDeFBIMUFYNFJKdG9FQW1hOU1nQ3RESElhS0V6ajhCUEdJcjA4eDhaYlNicklhcU5CMFNxYmUwM28vUU1LY2FDOGR1VDJIZEFlazhZNVpzM0F2bkVENTJDTXZMVGpRR0gxRGtzYXZieVRaMVkwMHQrQ2t4UVFBbnZMSlpjdCtlTjJXY0UrcUwyMkNBRVBpVUtQR0ZWLy9ZTSsyUTUwM2FhQllPQ1pLMi9LYnFNUE5oT1RRNVBuWkdXQ3p3VXFobldaai9KSm9ucHRRN2NyUlpOdkZZN1lJRjdVYk5BYWJhM3lSS09YUEFMUC9wRXppei9POE1WS3BWSDdPazg3Z0dHVExkM1RYUzZweGZqMXZ2RHFwdzZ2cmFmYUtKTVUzMUpPOG0rZm44aXlNdWkzektvcjlUWm15ZllWQmtrTXhFQ2ltckpWcE81US9vczBOQjErc3IydjJSNjNraUlCeThzdDllbjVIVzg2WmgxZGFrK2RObmRjMFB6bEFnVkI1S0V3bStMcEJIcSt4SnRQTUVNSEFmUHBIVkxzUlpmSUhuWm9yMnpSMFpGbmVvS2RoYjVLQVRuTTlRcDNaU0RPSXg4WnlIbFVGYWdPZWk4dHptTWhzWlVtdU0xclBwdzd2b2M2ZldVLzBERE5OSnNtenNRUnlYOFNmR2JPbTdNeDNNd1Blek5ubHVqdzdJd09RejlPNlJYMWVDK1pYRWpzL2xnL1lCbEc4OXV1M3pqdWtGcFV1RGNjZ2U1L1gxNmdvZXcrWnd2Tk1HZ2tMc0VBMFJFSDRIb2x4Z05uNXZNcG5OM2cyZWtlYXc4dzh5enFUSEx0eUJrZGpCM1ZNcHdrZ1M0R0hZVWtFaWgzWTVIV1dhUU5TeW10Q2pEclliSk1HUUVJSEpLWk5tNFU2M2JUeG1qby9aY0FJSkFKT2F3S0l3UU5hZzlHc1ZHYkdwMFh0ZUV0Z0RnRVczZUlnN1YxN09EUFhTbzRKS0NmN0RxUlgwNTFmVFp1TE1UQm5XcmtoRU9Wckx6d0JJVDlIV3RGUlQ3RktuVGFUT3JNcjAzb1cvWkRZWmxCazJpK0RvMXl0SjBpdGgvM01SRC9QUld0WWczSUxDcThUQml1MUFCbWdHS0JVZTVBU0JrYytOd1EwMGhoK1V3czRnTGk5enFBMXRCNXpvR1VhdmJJN1VBNmxTWGFXeHJhakJjaGZCcVpRaGtmMEpWbWVYa1YzZmlXV1FNcUZzcXBvcEpITnBTQnhOblZDbGJTaHcrUU1IVEFDZ1BtSTJ0YTR5ejV6RE5xVWxrdGdraWswUUJsd3RQMmNpZ2F4ZGpsUW5HWlpnTFJmTXlnR0hEclByQVU4Qm9yWERFNmpZVCtiN2NRK0VLR0VPYnZRWjVFTTA2TTVTS2plZlN3QU9abFNvSnpzR3hucGlhQjljUVQ0RnVxMHkwZFRPR2Vzb1FrZ1BjZDFzbkpqeS9MSFlHTTBSd0NUbVhoSzdKeHRoMEtieEFjNWM1ZUxGakZZMXR3eE1Ia1RTTGF0SWRybE5jcUFBeDRvWW5vd0pzRHgybXRZcWcvNzIrbTJ0OUpOZiszRmc2T2JKME1TSmlzeEhBZjUwSmNibzIyVnhvV1IwcStaM1lHWHZ1TGNHQzZZRzhGNWMvanJYTjRDd05renAwV29DLy9qQjlRRUpQZElHZjBTcjhmZ2FQRlBtUW1wclJuTXhReHlQYjdST20wL1oyNmRXVUF6OFc4TVpwYUI5MjBHYU5ISU5GZ21rb3Q2MnVDU1JlMzZrb1h0T0hlMndsaEZ3eENOVmJ2WHdaUUJOYVVhdFhyanZuNFY0U3JTZ243U21Db0J4UU9TUUcwNnBzYXVkb1R1TGdVTHVtT1lOenVDbWUzWUJFeW9OYUpaamtCQU1kZlZBZUU2MzNSMFNDQ01mN0xySkZ6VENZa2xEbDZqV0d2cVFpanEvak9idWR4bzBaanM1L09jektYZjhNcVhWK0RpK1cyNmo4RGgzMkhuS0FPNis1UlN1azBxVjV1N3VuQVFqbEdtQktpL0pJRG9RbXNpQmYxc3FqaUdpcFVkRG9ub0Q3V2JOWUhINDFrWWNUdjltZFdoZFBjTWhmekQ1OHhRUUtra3FNU09VQlVBdXVGLzZ3WkF0S0h3U1lWbU9NYUhCV25JTEtsb0JPYVBUWnNoRUFuSW1rbUM5VmQxNTZNTVNDYVlOdzhWUFZ4NndkeVl0S2NDNTNZcEcxRzRHaTdIUk8yOUNtQmcrc0VTWEJ5TVk5elVXY0hOY0pSeVRFRGQ5T2w5L1hTRk5hUXQvVXdlMnVoWDhiMTVnQ0t3R29YV0owV2tZcVJjWkJwc0c0RmxnRk1XU040MmdORVBvcWRVUVZjbjBqWi9CdWlvS0d2eWNsMEFwU0VBeXBFR1o3N1FhbEJBSXF4UEVqL0ViVW1oVFpVWW9hdUQ3MWxCOTB5RTJSMEtlZ2ljS2oxSXltazV5aHZSN0VPRFFvUU1HQXlLVE80cndESmFaallkbURYcWo3V1Zvd0RzcUlCNjk3MEVVRVFhaERRd0tCb2pIVysxQ1VXYkloNGlvZjNJb3h6QmNWN0xMT09MK1RobEppdVk0K0xJVnVFYTdlTllUTFJ6Qm9FVkUvaDBQTFMzNFREdEc2YU9yVkcvMUF4d1lMU3Ezc2pNYkQ4Yk42VlFZWDlHcDFTSmlWWGJZK1NaRWIzMGhGZmIyeFJVNkhwaXVncXpHNWhhdFBkcndmQkVTRUNEUUd0QzBFeElZUUoxbC9DelFJcW0wWi90ZVZvZjZPenNyRTIyejQ4SXFCVWJkMVd4UG5NdDNlY3FreUtpTzQzUmREcDZzNllDc0pUcElIQnJBeVN0WTZOdFpsRFNta0ZsZjN4VWdHakFNVm9HK2dVVkthYTV0VW9GdHVzRWRqVGFrdHJBNHU1amN0U1A3OUxWTmhqcGphT09oUmh4a1dST0MvYlJQU3hFMFhnekNVS3BzSUtZd2NFdzZGWXE5SzMyd1ZPQkdRU25aY3BNb2hCTnRPRUdnYm1CcnJlT0dxWXVoWFQ5UCszcGoySzFrUXpCUXRZUUpnZ1JhMENFMXJ3VjVzdnVjK0JZclNnMHh3SmpRRkJlMDh4aVB0TW1hWXJhUXZId1lQdU1yc0czWFlKUHdnbVVuKzRaN1kwZzZtOVRhZ2xSU2lKRjJHczczR3Exa2xmUmxNRnl3RmlOaWdJdE0vc1JmTkN1QXRERkI5ZG9lNERXaHh3MW1CUlE3L3o0M3RWMEUrdU5kb2hmOGFZc05IWGlsNnpad2tKVHhNeVp0Z2dDVGJJZzBaTTFSTHMzdDdYaGxodmUxTFVOVGlGNWFpaFpnZ211b0I5SS9qanZ0Y0FvVy90b3pSbklZSUR4d1dJaWpScTVUSW85VGlhb2cyaWVjdk9qL0ZleFpxMmQ2RDRPQzlRNzd0NnppVzdneGhJb29obld2RmxUWmJURWE1WTlWZ0ExKzJKbFRaMDNoMWJiQmlNVnJYM1A3NTFhNEV3a1R3K2x5eUlha3FCZVd4Nll3aUxGaFU1anJEOVNKYzBwbThQUVowRVJWZEl3RXQ3UzZyc25CR3I1K2wza2VHZHNKUVhwTTNHUS9XSXRacXZ3T3dGSmNNZEYxc1o3UmhjcmJ4cUZBZUttQ2tZYmJ2cURXVHZnTkpROVE1ck1ZNzZHc21NcmxBVkpPeGJvUURFMUpaQ2pNNVhLTTBCdkNrdjFGQ0N4UEMzY0owdWIvVlpMb0Jpa051emNTaDNjVnhBQ0ZEcXR4V3hSWHR5YU1mRGdDQ2pvQUEwWlhtVFQrN0hTYTIrK3N2dTAwS0REQ1FQV0Z1bjE5UHVXbFNnNldDMFRiUXNDWVNqWVpSSEFPNUNjdEFTcjVWQnlEQjBicUlQNzdPUU4rMlgyL2E4MkpqQ1ZSYkpQMlc4WFp1VEdreUJjR0tCaElsQzMzSHAxZGVtWkFoSkxUemZXenAydEJySWMzMFdkVWZPWmRHektZWUtmRnczUzdQNkdtaFFLVDlVcHZjTnZuRWI5NGZvOWF3bUkyNzN6TnpHTUxrd2NnV1QyZ1RDL0lOTmdZeWNiMUVaQzN5bTVTazhIRHR3MjBGMkRNMWlHU0x0VVJXK2xuOTNiVEJZQ0ttODFUbUVyVTlaS3MyNUZtUk5RT3A2clBXUEFYWTRRR0RPbXhOeFJZOFFNSmdESFVuUkFheEtSRmMxU2RHV0RYTksyTFdNQUs5Y05kRTlaY3ZKVUZnS3JHcmZyamRSVnl5eVpLQUxsZ3RZWHd6bVRsTVZNM1V2WmMxS2VyWmFaYURGakpzQzJrYllmZmdDVEo3STIyTmhsR3dRcVM3dTVidHJZWm8xYmJydTJld0Nta1hSM0c1OHk4TkpZVHYwSVMxd3M1YmlkZFFOMjVBb0treGNTQ29EeFZvNU40Rkx2bzY2OWE4OEtUcTBnU28wWlFHbjhSOERSU21pMnFMQjdkNnhFN0NnRk9icFdQekM4RXFhcDFOdHhnRHJoU2NlOWZSbmtvZW9wdkRzcnloS2tmUW5YOEh1Z3FOTnZCRWNRSkRRb3BVTkV1L3dWMGZnZjgvcGZUeUtrUFczVWw2NWJ1V2hhbUx0VzBzMXNMY2VWYmhoTjRpckhBRm5LdkdJOG1VQW9hOVlhQTVSNWdaK0dmc3ZvVUlmeGdMdU8weTd4UGNHWEs4a2F1MWNjNEtaMWYxeTh1WEc2U21jbkRjTlR2SWlxZVAvN0JMVi96U1NpbFNuc2QrK1o2SGNkTGRwazVzdGJqVUtiZUdSZy9EUWNMY2VoVDRmWTVDV1NObzJ0ZzdOaWhDRGFEQVhwY3c5K0srMDVWTHNSQ3hSR3YrbnNtdE1pVjNBQ2RocW9JUTVpRDIxNWwzOHZoWm5yaG5hV29xNmQxYVpDS0hjNXlHTlE0RXNaVzFKd0o0Y2tndkxTbHJ4UElhSXJKbEZZMkZiV0hFRFVSZDdLVE1SR2Q0eGl3aWR4QWRIeVU2cHUvRlFRNnJOQkdZVnlUYzNnNktiMmxtdjdFbHBVUGdYdlM3T0NERU5VcUs3MnlVV0pEMEx0b2o5RGNGYkdTVGdaTUpCbU9oNnVkZk5uTVgxNUNZUlNUc290eWxGMmw0UkVseUtSM1VRMERrMC9wNlUwNWVpYVNVT3IwcVptODFoY3h3eGVnUm5ZMTI2NDJZQ2xuZExxZ0xLRHJ4ZkFJdDV5V3RVTFo2VlplbUZpZ0ZyNXErWTJTVHlBMFo3dERvd2l5eXZNVHlHVUtsaURVbU1IbkpJNGkxYjlheDRhcXNKWk1VS0JhaThSNVg3NUdBYXpyU3pQUkJwbWpoVjZudTFRUHQzZ3lyTXcxQmhQTUZ4RmtkY2lnRks5UUxXaVZzRlpNWkpsTnV3SnhMRUtQY0VwT05GbnYzSERKNTRkb3ZHbE9YRlJ2dVhIb1dKcjkwd3lObmJ4VldRR0J2bTRvckRGWnR1SElkR0xicGttaWRpSmhDdWVhUFU0d0RoMzBJcWk0MkgyN2ZLK2pnRFpZS2w0UVNpRUtRZzlsSWx5NkY4R2dwNTRnRE9CNWpwejJqcWpOVEROSmM5aHJTNkRGUHFnaVNqNlJHVHM3b0tVZE1SMzg0aWlDc3hjYU5ZRUZLMzhjQ1ZJY3RiV3M0bTF0TlpRNjlYM1BQckNhcGlta21WNkxYVU12MWxzSWtDYXBSVkFYcHRvK1pvSGF0UEs3bUhxNFhWdXBNUUZ2ajY0ZGR2Qy9sdzZwS2hkZ3lLQmErdnkxbi9tV3dkdWhHa21hYXBYVUJmY0RrY25ZWkRyd0dNRnFwVm8vbWZlKzdJTkhFbTd3RGNjNFBJYTR3TmVCMWlSNzVQTWhUdU0vMno4N0xkZldBdlRSQkxTSk1xbmJkVGdIK1JXNUdDaTRmZm00MWg0Zk5ETWxCOWZNeEdsSzVVcEN2UUErTVJza0VhUy80SkkzdTJIcnJoUXhxdGtHTjRVSXlLdStkemdnWTFmM0RyYUMyZW9NSEZJVXYwUWJhd1JaandSQ00wWmgyWUpBYXpSOGk2M1l4eFFuMXpaVThzZ0g2RE9IdkkrU29HZkQxbjRMYXRqb1ErVHhDT0NMelJFYXlzUlZrQ2NiWDNndXkrZWNhWnd0S0ZYcEJuOGduN3pjbGRvS2E4MWFCNEFaTUVXYmREaUdHYk1TOW5raFkwdFpmWEdaL3ZpdG1ncmFjYWNVbGx5cVU0OHFCVXY2dm5DcVRhbVROa1UvUmRsWjA4cW5hOGNlRjNYSUp6R01wcm9mdm81cEVHNlgveDNTTHBZSmdwc0o5cm4yamhmZWtWemlmT0VRTEY4NFA1bis2anJING9WOXJvaXkxaG1iQWhRNkdyS3Bmb1Z1V1RaMVB6WnNvcXcrRkpIZnM2VU9YWXd3bWpUbFpkMmJvYlRTQTZPNm42S05kZFFmcTNmc2wzdC9iUmZpc01uR3RabzlsWHVtQm90TGV2UUR3a1V5MTl0M05NYmQxYTJSZ0pXSkRVVFhyTjhzYitic2FITTArVzFMYXcxZC9PaE1BUU9lYzdRb0lxenU1ZStadFlwT1V6QzRGQmsxRTgvY3hVcVhWWEJxSFlwZ1ExRjNDblNERVFvellFdUYxME9oT1lPbWk0MEtWbnpsZjNycVVOWHQ1cm5KQld5V2dnR3hxN0dyeW5ENFNwbnpmSEJ0QnVqb1VvNzBMWmtxTC8yeGxkMURzSkpraUhPS3J5WTlxbElMU004bHBQaTlKWXFYR1g4VFdyM3dCRW5KWlZiUi9CVnZ1WWNEalA5NWtndUNoOTY4RG1LRWRRYTBnelJMbFdZUEtkdGdYbUwvQVFDaE9ialFyUHBKckVwUGhuZGVKZ2hNWU1ScU8wMGdyd3R3cVMyK0pYSFIrUDJESTMyS21qakd2c2w5S0QwVWYvUlFDcVk1TEtTZEkycngxTk5KczRPbXVxUVlEbHBaZHFhOTlWb29UN0ZiWEFZT1NLZ1dPNTRhS2lYeU1FcTBvRFZ6b1NWZ1BMRUl3UUxDLzlXK0toeE13L0RvTm1FQUFwTExKTXV6Kzl1cUpFNXJkR0hXZ1E0clBQMFNSMURMWllKL2gxcFdvT080SWF6cUVwUFNSVlVYaVVRcWtTUTVsQjZwNWVlc1Y2NlZpOXJDN2U3OFRqbG5oSEptWVdGTzQ3SnVzbHJwY0pLOTZkMTdxNjVqWVhqbzBOcTBURUI1ZVNPYnc3MWRvSmFROTJ6d2xYV05vSG16SjdYTXFNOUVPNEhtUlZpeldIejFFcjNrTHBPS0ZlY1FxdEpZVUZiR1BlQm44SXB3ekttU2tlRjEvWVRvOEUvSUE2UXlNM0lDTy9KK1NjQVp3b25BcVc1andkcFdUbVJMNXBJamhvb0orc0pzSTRvV2tQazRrWVZ6SCt5ODNCMU1FVW5vUEdSTjRYZVY0V09XYmtwRVFDdUhzTWNBMkhuaEowVmFDTkEyQmFhSy9TQk9qU2RKOXNHQlAvQVdCRHR2RjAzbFJQQzd5ek9nM0ZXejBzSTFDQXRheWRqNWxySk1RUGxaQ01CbGxjaWZvWEJDZzlTRStGb291dkZWTkpBbTFveHFmRXp6czJEaTRWcDFBRllHTTY1TmZFbmVnMzBJOWdvWTJwTm5XOTNSa1U2REYzdXN0Q2t3dXdGbXR2S3RMRzhRTXNtV3JZY0xVQk9wZ3dvSnh1M0R2VkdVZFJmVWJpS3ArNTRQMWJNT2dRZlR3bGRMNTVNWi9ZS0J4MXF3emlUNXNHeDlZWU8wR0x5V0pOcFZHamZab2FCU2JYYTdqV29sV2FHV3VVME10QkdWeWdTQXNXZ2JLRmw4MlI5ME9Ga3lvRUs1WXZmSGVxdFlOc3FBbU01Z2RQcnlRT1daeUJHNFZ6WXd2UUZzeUZNOFNDTzF6STdDeEl3OUZubzg0L1FaS0xjbEJlMzdmYTdxcXVRdkxpWFpFa1JxbncvK09SMEpHaXFvZ2QzMGJJWitGVnZ4Nmc5cmVTNEFoWEtOeDhmNmtWb1gwYktSS0J4Vkc5WklQcm9Ic1pWUGdXK3h6SXc5RGxFNzllTTlwalhESUNmYXVuZUExRjBla0VZRUVKL0tNQzZiYU5Ud2ZUTndNL3g4MkFtVTJ0L3I4TzBienQ5WU0xaDAvWWtIRWM1WVVBMXkyTlBKRXRRcC8zMEEybmhBbEJWOWU4Ukd1Yy9zS3daZ2Y4b0FhSWNZV2dCdU5VWVl6L1IxU1FHUGdiZG9MYWJhMXM2MS9oWVRsTHZvQ2Rrc0tJTU1kZ3hWV1p0TW5MU2dHcVcvL2kvRi9zcTJMR1FBaCtla3NvdjUxaElIZGhYcEdvS1poZlFhOGZVeENmaHVFblBoV1lXNDJ2TjVDVWtJdlkvVFFVYXFNUHRHSE9zQnRzNzJvdzVPNjRhY3pnNVpZQ2FTQjdmOVdKZkZMZlAwYm5tMlpDOVpIdXFQUDJTYnIxcVVqZEl3U3NheXM1QmE5VnBuek9KQXRZd1pUMkd4YVFOY2VCTWNEeEo4QXpIWEl5alZRM2FvTmJSQWJYT2t3eklSUEwvNjlpdnRmNDhIWXNBQUFBQVNVVk9SSzVDWUlJPVwiLFxuICAgIG9iamVjdFR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgb2JqZWN0VWxpZDogXCIwMUpUS1lLWEpYNUMwWjdKMFFYOUpWREI2WVwiLFxuICAgIHNoYXJkVHhJZHM6IFtcbiAgICAgIFwiMzkxZWJkOTAyZWIyZDk1MmQ0MmM3NjQyMjczZjA4ZmI4OWFjN2E3ODlkZGYzZTdmZTBkNTI3NzlhNjE3ODgzNVwiLFxuICAgIF0sXG4gIH0sXG4gIHtcbiAgICBpZDogXCI0XCIsXG4gICAgbmFtZTogXCJTaW1wbGUgVGV4dCBOb3RlXCIsXG4gICAgZGF0ZVVwbG9hZGVkOiBcIjIwMjUtMDUtMDdUMTA6MzA6MDBaXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBiYXNpYyB0ZXh0IG5vdGVcIixcbiAgICBmaWxlVHlwZTogXCJ0ZXh0XCIsXG4gICAgaW5kZXhpbmdUeElkOlxuICAgICAgXCI0YzM4ODU1MDc1OTc4NGVmNDA4Y2ZjMTkyNDUzMjI3Zjk5ZDM0M2JkYmNkMmYzYzFmNDI5Y2Y4MTVmZDExMTI1XCIsXG4gICAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0OiB1bmRlZmluZWQsXG4gICAgb2JqZWN0RGF0YTogXCJTR1ZzYkc4Z2RHaGxjbVU9XCIsXG4gICAgb2JqZWN0VHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgb2JqZWN0VWxpZDogXCIwMUpUUkY0NU5IRkdNTURCMEYwV0hDTUNSNFwiLFxuICAgIHNoYXJkVHhJZHM6IFtcbiAgICAgIFwiYWM1ZGI0ZDkyYWU1MWVkZDQ1ODAwOGZhZTMwMDU3MGYxMDJhNjg0NmY2OTdmZTE4MWQ5NmI2MmExOTczNmI0MVwiLFxuICAgIF0sXG4gIH0sXG4gIHtcbiAgICBpZDogXCI1XCIsXG4gICAgbmFtZTogXCJHcmVldGluZyBOb3RlXCIsXG4gICAgZGF0ZVVwbG9hZGVkOiBcIjIwMjUtMDUtMDdUMTQ6MjI6MDBaXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQSBzaW1wbGUgZ3JlZXRpbmcgbWVzc2FnZVwiLFxuICAgIGZpbGVUeXBlOiBcInRleHRcIixcbiAgICBpbmRleGluZ1R4SWQ6IHVuZGVmaW5lZCxcbiAgICBpbmRleGluZ1R4U3VibWl0dGVkQXQ6IHVuZGVmaW5lZCxcbiAgICBvYmplY3REYXRhOiBcIlNHVnNiRzhnZEdobGNtVWhJU0U9XCIsXG4gICAgb2JqZWN0VHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgb2JqZWN0VWxpZDogXCIwMUpUUkY5SDRSUUo5MUhNU0o2RTRUVjJLUVwiLFxuICAgIHNoYXJkVHhJZHM6IFtdLFxuICB9LFxuICB7XG4gICAgaWQ6IFwiNlwiLFxuICAgIG5hbWU6IFwiSW1wb3J0YW50IE5vdGVcIixcbiAgICBkYXRlVXBsb2FkZWQ6IFwiMjAyNS0wNS0wOFQxNzo0MDowMFpcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBbiBpbXBvcnRhbnQgdGV4dCBub3RlIHdpdGggYWxwaGFiZXRcIixcbiAgICBmaWxlVHlwZTogXCJ0ZXh0XCIsXG4gICAgaW5kZXhpbmdUeElkOlxuICAgICAgXCIyMzlhMTk2ZDFiNGRjMTA0OGMyZWMwMjJjNzE0NzdiNjUxYmEzYWIyZWVhNWNmMjczZjcyMzA0ZDI1N2YwZGJkXCIsXG4gICAgaW5kZXhpbmdUeFN1Ym1pdHRlZEF0OiBcIjIwMjUtMDUtMDhUMTc6NDk6MzJaXCIsXG4gICAgb2JqZWN0RGF0YTogXCJTR1ZzYkc4Z2RHaGxjbVVoSUVGQ1EwUkZSa2RJU1VwTFRFMU9Udz09XCIsXG4gICAgb2JqZWN0VHlwZTogXCJ0ZXh0L3BsYWluXCIsXG4gICAgb2JqZWN0VWxpZDogXCIwMUpUUkZCVFFaWFhBQlRENktCVFZXNzVCSlwiLFxuICAgIHNoYXJkVHhJZHM6IFtcbiAgICAgIFwiNDQ5MTQ3OGZjODcxNDIxM2QzZDhlY2QzZTY0MzhmNDljMmE5Y2M1ZDViNWY4YWUzNTg4MzRmNDM5ODBmNzEyN1wiLFxuICAgIF0sXG4gIH0sXG5dO1xuIiwiLyoqXG4gKiBVcGxvYWRzIGNvbXBvbmVudFxuICogVGhpcyBjb21wb25lbnQgZmV0Y2hlcyBhY2NvdW50IHVwbG9hZHMgZGF0YSBmcm9tIHRoZSBBUEkgYW5kIGRpc3BsYXlzIHRoZW0gaW4gYSBncmlkXG4gKiB3aXRoIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvbiBvcHRpb25zXG4gKi9cblxuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZVJld2FyZEFjY291bnRzIH0gZnJvbSBcIi4vdXNlUmV3YXJkQWNjb3VudHNcIjtcbmltcG9ydCB7IHVzZVVwbG9hZHMsIFVwbG9hZCB9IGZyb20gXCIuL3VzZVVwbG9hZHNcIjtcbmltcG9ydCBVcGxvYWRzR3JpZCBmcm9tIFwiLi9VcGxvYWRzR3JpZFwiO1xuaW1wb3J0IFVwbG9hZHNMaXN0IGZyb20gXCIuL1VwbG9hZHNMaXN0XCI7XG5pbXBvcnQgVXBsb2Fkc0ZpbHRlcnMgZnJvbSBcIi4vVXBsb2Fkc0ZpbHRlcnNcIjtcbmltcG9ydCB7IHVzZVdhbGxldCB9IGZyb20gXCIuLi8uLi9jb250ZXh0L1dhbGxldENvbnRleHRcIjtcbmltcG9ydCB7IEV4cGxvcmVyTGluayB9IGZyb20gXCIuLi91aS9GaW5pc2hTY3JlZW5cIjtcbmltcG9ydCB7IG1vY2tVcGxvYWRzIH0gZnJvbSBcIi4vbW9ja0RhdGFcIjtcblxuaW50ZXJmYWNlIFVwbG9hZHNQcm9wcyB7XG4gIGxpbWl0PzogbnVtYmVyO1xufVxuXG50eXBlIFZpZXdNb2RlID0gXCJncmlkXCIgfCBcImxpc3RcIjtcblxuY29uc3QgZGF0ZUZpbHRlck9wdGlvbnMgPSBbXG4gIHsgaWQ6IFwic2VsZWN0XCIsIGxhYmVsOiBcIlNlbGVjdFwiIH0sXG4gIHsgaWQ6IFwidG9kYXlcIiwgbGFiZWw6IFwiVG9kYXlcIiB9LFxuICB7IGlkOiBcIndlZWtcIiwgbGFiZWw6IFwiVGhpcyBXZWVrXCIgfSxcbiAgeyBpZDogXCJtb250aFwiLCBsYWJlbDogXCJUaGlzIE1vbnRoXCIgfSxcbiAgeyBpZDogXCJ5ZWFyXCIsIGxhYmVsOiBcIlRoaXMgWWVhclwiIH0sXG5dO1xuXG5jb25zdCB0eXBlRmlsdGVyT3B0aW9ucyA9IFtcbiAgeyBpZDogXCJhbGxcIiwgbGFiZWw6IFwiQWxsXCIgfSxcbiAgeyBpZDogXCJwZGZcIiwgbGFiZWw6IFwiUERGXCIgfSxcbiAgeyBpZDogXCJ0ZXh0XCIsIGxhYmVsOiBcIlRleHRcIiB9LFxuICB7IGlkOiBcInBuZ1wiLCBsYWJlbDogXCJQTkdcIiB9LFxuICB7IGlkOiBcImpwZWdcIiwgbGFiZWw6IFwiSlBFRy9KUEdcIiB9LFxuXTtcblxuY29uc3QgVXBsb2FkczogUmVhY3QuRkM8VXBsb2Fkc1Byb3BzPiA9ICh7IGxpbWl0ID0gOSB9KSA9PiB7XG4gIGNvbnN0IFtkYXRlRmlsdGVyLCBzZXREYXRlRmlsdGVyXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJzZWxlY3RcIik7XG4gIGNvbnN0IFt0eXBlRmlsdGVyLCBzZXRUeXBlRmlsdGVyXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJhbGxcIik7XG4gIGNvbnN0IFtzZWFyY2hRdWVyeSwgc2V0U2VhcmNoUXVlcnldID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgY29uc3QgW3ZpZXdNb2RlLCBzZXRWaWV3TW9kZV0gPSB1c2VTdGF0ZTxWaWV3TW9kZT4oXCJncmlkXCIpO1xuXG4gIGNvbnN0IHsgZGVmYXVsdFdhbGxldCB9ID0gdXNlV2FsbGV0KCk7XG4gIGNvbnN0IHJld2FyZEFjY291bnRzID0gdXNlUmV3YXJkQWNjb3VudHMoKTtcbiAgY29uc3Qge1xuICAgIGFsbFVwbG9hZHMsXG4gICAgZmlsdGVyZWRVcGxvYWRzLFxuICAgIGRpc3BsYXllZFVwbG9hZHMsXG4gICAgc2V0RmlsdGVyZWRVcGxvYWRzLFxuICAgIHNldERpc3BsYXllZFVwbG9hZHMsXG4gICAgbG9hZGluZyxcbiAgICBlcnJvcixcbiAgICBwYWdlc0RhdGEsXG4gICAgbGFzdE9iamVjdFVsaWRzLFxuICAgIGN1cnJlbnRQYWdlLFxuICAgIHNldEN1cnJlbnRQYWdlLFxuICAgIGhhc01vcmVQYWdlcyxcbiAgICBzZXRBbGxVcGxvYWRzLFxuICAgIHNldFBhZ2VzRGF0YSxcbiAgICBzZXRMYXN0T2JqZWN0VWxpZHMsXG4gICAgc2V0SGFzTW9yZVBhZ2VzLFxuICAgIGZldGNoTmV4dFBhZ2UsXG4gIH0gPSB1c2VVcGxvYWRzKHsgbGltaXQsIHJld2FyZEFjY291bnRzIH0pO1xuXG4gIC8vIEZpbHRlcmluZyBsb2dpY1xuICAvLyBVc2UgbW9ja0RhdGEgY3VhbmRvIG5vIGhheSBkYXRvcyByZWFsZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWxsVXBsb2Fkcy5sZW5ndGggPT09IDAgJiYgIWxvYWRpbmcpIHtcbiAgICAgIHNldEFsbFVwbG9hZHMobW9ja1VwbG9hZHMpO1xuICAgIH1cbiAgfSwgW2FsbFVwbG9hZHMubGVuZ3RoLCBsb2FkaW5nLCBzZXRBbGxVcGxvYWRzXSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZmlsdGVyZWQgPSBbLi4uYWxsVXBsb2Fkc107XG4gICAgLy8gRGF0ZSBmaWx0ZXJcbiAgICBpZiAoZGF0ZUZpbHRlciAhPT0gXCJzZWxlY3RcIikge1xuICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgIGNvbnN0IHRvZGF5ID0gbmV3IERhdGUobm93LmdldEZ1bGxZZWFyKCksIG5vdy5nZXRNb250aCgpLCBub3cuZ2V0RGF0ZSgpKTtcbiAgICAgIGNvbnN0IHRoaXNXZWVrID0gbmV3IERhdGUodG9kYXkpO1xuICAgICAgdGhpc1dlZWsuc2V0RGF0ZSh0b2RheS5nZXREYXRlKCkgLSA3KTtcbiAgICAgIGNvbnN0IHRoaXNNb250aCA9IG5ldyBEYXRlKHRvZGF5KTtcbiAgICAgIHRoaXNNb250aC5zZXRNb250aCh0b2RheS5nZXRNb250aCgpIC0gMSk7XG4gICAgICBjb25zdCB0aGlzWWVhciA9IG5ldyBEYXRlKHRvZGF5KTtcbiAgICAgIHRoaXNZZWFyLnNldEZ1bGxZZWFyKHRvZGF5LmdldEZ1bGxZZWFyKCkgLSAxKTtcbiAgICAgIGZpbHRlcmVkID0gZmlsdGVyZWQuZmlsdGVyKCh1cGxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdXBsb2FkRGF0ZSA9IG5ldyBEYXRlKHVwbG9hZC5kYXRlVXBsb2FkZWQpO1xuICAgICAgICBzd2l0Y2ggKGRhdGVGaWx0ZXIpIHtcbiAgICAgICAgICBjYXNlIFwidG9kYXlcIjpcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWREYXRlID49IHRvZGF5O1xuICAgICAgICAgIGNhc2UgXCJ3ZWVrXCI6XG4gICAgICAgICAgICByZXR1cm4gdXBsb2FkRGF0ZSA+PSB0aGlzV2VlaztcbiAgICAgICAgICBjYXNlIFwibW9udGhcIjpcbiAgICAgICAgICAgIHJldHVybiB1cGxvYWREYXRlID49IHRoaXNNb250aDtcbiAgICAgICAgICBjYXNlIFwieWVhclwiOlxuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZERhdGUgPj0gdGhpc1llYXI7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gVHlwZSBmaWx0ZXJcbiAgICBpZiAodHlwZUZpbHRlciAhPT0gXCJhbGxcIikge1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoKHVwbG9hZCkgPT4ge1xuICAgICAgICBpZiAoIXVwbG9hZC5maWxlVHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBsb3dlckZpbGVUeXBlID0gdXBsb2FkLmZpbGVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHN3aXRjaCAodHlwZUZpbHRlcikge1xuICAgICAgICAgIGNhc2UgXCJwZGZcIjpcbiAgICAgICAgICAgIHJldHVybiBsb3dlckZpbGVUeXBlLmluY2x1ZGVzKFwicGRmXCIpO1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICByZXR1cm4gbG93ZXJGaWxlVHlwZS5pbmNsdWRlcyhcInRleHRcIik7XG4gICAgICAgICAgY2FzZSBcInBuZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGxvd2VyRmlsZVR5cGUuaW5jbHVkZXMoXCJwbmdcIik7XG4gICAgICAgICAgY2FzZSBcImpwZWdcIjpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIGxvd2VyRmlsZVR5cGUuaW5jbHVkZXMoXCJqcGVnXCIpIHx8IGxvd2VyRmlsZVR5cGUuaW5jbHVkZXMoXCJqcGdcIilcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gU2VhcmNoXG4gICAgaWYgKHNlYXJjaFF1ZXJ5LnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgY29uc3QgcXVlcnkgPSBzZWFyY2hRdWVyeS50b0xvd2VyQ2FzZSgpO1xuICAgICAgZmlsdGVyZWQgPSBmaWx0ZXJlZC5maWx0ZXIoXG4gICAgICAgICh1cGxvYWQpID0+XG4gICAgICAgICAgKHVwbG9hZC5uYW1lICYmIHVwbG9hZC5uYW1lLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMocXVlcnkpKSB8fFxuICAgICAgICAgICh1cGxvYWQuZGVzY3JpcHRpb24gJiZcbiAgICAgICAgICAgIHVwbG9hZC5kZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5KSlcbiAgICAgICk7XG4gICAgfVxuICAgIHNldEZpbHRlcmVkVXBsb2FkcyhmaWx0ZXJlZCk7XG4gICAgc2V0RGlzcGxheWVkVXBsb2FkcyhmaWx0ZXJlZC5zbGljZSgwLCBsaW1pdCkpO1xuICAgIHNldEN1cnJlbnRQYWdlKDEpO1xuICB9LCBbXG4gICAgYWxsVXBsb2FkcyxcbiAgICBkYXRlRmlsdGVyLFxuICAgIHR5cGVGaWx0ZXIsXG4gICAgc2VhcmNoUXVlcnksXG4gICAgbGltaXQsXG4gICAgc2V0RmlsdGVyZWRVcGxvYWRzLFxuICAgIHNldERpc3BsYXllZFVwbG9hZHMsXG4gICAgc2V0Q3VycmVudFBhZ2UsXG4gIF0pO1xuXG4gIGNvbnN0IGhhbmRsZVNlYXJjaCA9IChlOiBSZWFjdC5Gb3JtRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUNvcHlUZXh0ID0gKHRleHQ6IHN0cmluZykgPT4ge1xuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gT3B0aW9uYWw6IHRvYXN0IG5vdGlmaWNhdGlvblxuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IGxvYWRNb3JlID0gKCkgPT4ge1xuICAgIGlmIChoYXNNb3JlUGFnZXMpIGZldGNoTmV4dFBhZ2UoY3VycmVudFBhZ2UgKyAxKTtcbiAgfTtcbiAgY29uc3QgZ29Ub1ByZXZpb3VzUGFnZSA9ICgpID0+IHtcbiAgICBpZiAoY3VycmVudFBhZ2UgPiAxKSB7XG4gICAgICBzZXREaXNwbGF5ZWRVcGxvYWRzKHBhZ2VzRGF0YVtjdXJyZW50UGFnZSAtIDFdIHx8IFtdKTtcbiAgICAgIHNldEN1cnJlbnRQYWdlKGN1cnJlbnRQYWdlIC0gMSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBnb1RvUGFnZSA9IChwYWdlOiBudW1iZXIpID0+IHtcbiAgICBpZiAocGFnZSA9PT0gY3VycmVudFBhZ2UpIHJldHVybjtcbiAgICBpZiAocGFnZSA8IGN1cnJlbnRQYWdlKSB7XG4gICAgICBzZXREaXNwbGF5ZWRVcGxvYWRzKHBhZ2VzRGF0YVtwYWdlXSB8fCBbXSk7XG4gICAgICBzZXRDdXJyZW50UGFnZShwYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmV0Y2hOZXh0UGFnZShwYWdlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gaWYgKCFkZWZhdWx0V2FsbGV0KSB7XG4gIC8vICAgcmV0dXJuIDxkaXYgY2xhc3NOYW1lPVwidXBsb2Fkcy1lcnJvclwiPlBsZWFzZSBjb25uZWN0IGEgd2FsbGV0PC9kaXY+O1xuICAvLyB9XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC13LTd4bCBteC1hdXRvIHAtNSB0ZXh0LXRleHQtcHJpbWFyeSBiZy1wcmltYXJ5LTkwMCBtaW4taC1zY3JlZW5cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyIG1iLTggZmxleC13cmFwXCI+XG4gICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC10ZXh0LXByaW1hcnkgbS0wXCI+TXkgdXBsb2FkczwvaDE+XG4gICAgICAgIDxVcGxvYWRzRmlsdGVyc1xuICAgICAgICAgIGRhdGVGaWx0ZXI9e2RhdGVGaWx0ZXJ9XG4gICAgICAgICAgc2V0RGF0ZUZpbHRlcj17c2V0RGF0ZUZpbHRlcn1cbiAgICAgICAgICB0eXBlRmlsdGVyPXt0eXBlRmlsdGVyfVxuICAgICAgICAgIHNldFR5cGVGaWx0ZXI9e3NldFR5cGVGaWx0ZXJ9XG4gICAgICAgICAgc2VhcmNoUXVlcnk9e3NlYXJjaFF1ZXJ5fVxuICAgICAgICAgIHNldFNlYXJjaFF1ZXJ5PXtzZXRTZWFyY2hRdWVyeX1cbiAgICAgICAgICBvblNlYXJjaD17aGFuZGxlU2VhcmNofVxuICAgICAgICAgIGRhdGVGaWx0ZXJPcHRpb25zPXtkYXRlRmlsdGVyT3B0aW9uc31cbiAgICAgICAgICB0eXBlRmlsdGVyT3B0aW9ucz17dHlwZUZpbHRlck9wdGlvbnN9XG4gICAgICAgICAgdmlld01vZGU9e3ZpZXdNb2RlfVxuICAgICAgICAgIHNldFZpZXdNb2RlPXtzZXRWaWV3TW9kZX1cbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7bG9hZGluZyA/IChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBweS0xMiB0ZXh0LXRleHQtbXV0ZWQgdGV4dC1sZ1wiPkxvYWRpbmcgdXBsb2Fkcy4uLjwvZGl2PlxuICAgICAgKSA6IGVycm9yID8gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRleHQtY2VudGVyIHB5LTEyIHRleHQtdGV4dC1tdXRlZCB0ZXh0LWxnXCI+XG4gICAgICAgICAgRXJyb3IgbG9hZGluZyB1cGxvYWRzLiBVc2luZyBtb2NrIGRhdGEgaW5zdGVhZC5cbiAgICAgICAgPC9kaXY+XG4gICAgICApIDogZGlzcGxheWVkVXBsb2Fkcy5sZW5ndGggPT09IDAgPyAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXIgcHktMTIgdGV4dC10ZXh0LW11dGVkIHRleHQtbGdcIj5ObyB1cGxvYWRzIGZvdW5kLjwvZGl2PlxuICAgICAgKSA6IHZpZXdNb2RlID09PSBcImdyaWRcIiA/IChcbiAgICAgICAgPFVwbG9hZHNHcmlkIHVwbG9hZHM9e2Rpc3BsYXllZFVwbG9hZHN9IG9uQ29weVRleHQ9e2hhbmRsZUNvcHlUZXh0fSAvPlxuICAgICAgKSA6IChcbiAgICAgICAgPFVwbG9hZHNMaXN0IHVwbG9hZHM9e2Rpc3BsYXllZFVwbG9hZHN9IG9uQ29weVRleHQ9e2hhbmRsZUNvcHlUZXh0fSAvPlxuICAgICAgKX1cblxuICAgICAgey8qIE9ubHkgc2hvdyBwYWdpbmF0aW9uIGlmIHdlIGhhdmUgdXBsb2FkcyB0byBkaXNwbGF5ICovfVxuICAgICAge2Rpc3BsYXllZFVwbG9hZHMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgbXQtOCBnYXAtMi41XCI+XG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17Z29Ub1ByZXZpb3VzUGFnZX1cbiAgICAgICAgICAgIGRpc2FibGVkPXtjdXJyZW50UGFnZSA9PT0gMSB8fCBsb2FkaW5nfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcHJpbWFyeS04MDAgYm9yZGVyIGJvcmRlci1ib3JkZXIgcHgtNCBweS0yIHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOmJnLXByaW1hcnktNzAwIHRleHQtdGV4dC1wcmltYXJ5IGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBQcmV2aW91c1xuICAgICAgICAgIDwvYnV0dG9uPlxuXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGl0ZW1zLWNlbnRlciBnYXAtMS41XCI+XG4gICAgICAgICAgICB7Y3VycmVudFBhZ2UgPiAyICYmIChcbiAgICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBnb1RvUGFnZSgxKX0gY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1wcmltYXJ5LTgwMCBib3JkZXIgYm9yZGVyLWJvcmRlciB0ZXh0LXRleHQtcHJpbWFyeSByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyXCI+XG4gICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICB7Y3VycmVudFBhZ2UgPiAzICYmIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtdGV4dC1tdXRlZFwiPi4uLjwvc3Bhbj59XG4gICAgICAgICAgICB7Y3VycmVudFBhZ2UgPiAxICYmIChcbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGdvVG9QYWdlKGN1cnJlbnRQYWdlIC0gMSl9XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1wcmltYXJ5LTgwMCBib3JkZXIgYm9yZGVyLWJvcmRlciB0ZXh0LXRleHQtcHJpbWFyeSByb3VuZGVkLW1kIGN1cnNvci1wb2ludGVyXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtjdXJyZW50UGFnZSAtIDF9XG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwidy04IGgtOCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy1wcmltYXJ5LTYwMCBib3JkZXIgYm9yZGVyLWJvcmRlci1hY3RpdmUgdGV4dC10ZXh0LXByaW1hcnkgcm91bmRlZC1tZCBjdXJzb3ItcG9pbnRlclwiPntjdXJyZW50UGFnZX08L2J1dHRvbj5cbiAgICAgICAgICAgIHtoYXNNb3JlUGFnZXMgJiYgKFxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gZ29Ub1BhZ2UoY3VycmVudFBhZ2UgKyAxKX1cbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LTggaC04IGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIGJnLXByaW1hcnktODAwIGJvcmRlciBib3JkZXItYm9yZGVyIHRleHQtdGV4dC1wcmltYXJ5IHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXJcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge2N1cnJlbnRQYWdlICsgMX1cbiAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAge2hhc01vcmVQYWdlcyAmJiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXRleHQtbXV0ZWRcIj4uLi48L3NwYW4+fVxuICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgb25DbGljaz17bG9hZE1vcmV9XG4gICAgICAgICAgICBkaXNhYmxlZD17IWhhc01vcmVQYWdlcyB8fCBsb2FkaW5nfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcHJpbWFyeS04MDAgYm9yZGVyIGJvcmRlci1ib3JkZXIgdGV4dC10ZXh0LXByaW1hcnkgcHgtNCBweS0yIHJvdW5kZWQtbWQgY3Vyc29yLXBvaW50ZXIgdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGhvdmVyOmJnLXByaW1hcnktNzAwIGRpc2FibGVkOm9wYWNpdHktNTAgZGlzYWJsZWQ6Y3Vyc29yLW5vdC1hbGxvd2VkXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICBOZXh0XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVwbG9hZHM7XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgUmVhY3RET00gZnJvbSBcInJlYWN0LWRvbS9jbGllbnRcIjtcbmltcG9ydCB7IGNyZWF0ZVBvcnRhbCB9IGZyb20gXCJyZWFjdC1kb21cIjtcbmltcG9ydCBcIi4vc3R5bGVzLmNzc1wiO1xuaW1wb3J0IE1haW5VcGxvYWRlciBmcm9tIFwiLi9jb21wb25lbnRzL3VwbG9hZGVyL21haW5VcGxvYWRlclwiO1xuaW1wb3J0IENvbm5lY3RXYWxsZXQgZnJvbSBcIi4vY29tcG9uZW50cy93YWxsZXQvQ29ubmVjdFdhbGxldFwiO1xuaW1wb3J0IHsgV2FsbGV0UHJvdmlkZXIgfSBmcm9tIFwiLi9jb250ZXh0L1dhbGxldENvbnRleHRcIjtcbmltcG9ydCB7IEZpbGVVcGxvYWRQcm92aWRlciB9IGZyb20gXCIuL2NvbnRleHQvRmlsZVVwbG9hZENvbnRleHRcIjtcbmltcG9ydCB7IFR4UHJlcGFyYXRpb25Qcm92aWRlciB9IGZyb20gXCIuL2NvbnRleHQvVHhQcmVwYXJhdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IFR4SW5zY3JpcHRpb25Qcm92aWRlciB9IGZyb20gXCIuL2NvbnRleHQvVHhJbnNjcmlwdGlvbkNvbnRleHRcIjtcbmltcG9ydCB7IFR4U3RhdHVzUHJvdmlkZXIgfSBmcm9tIFwiLi9jb250ZXh0L1R4U3RhdHVzQ29udGV4dFwiO1xuaW1wb3J0IHsgV2FsbGV0TWVudSB9IGZyb20gXCIuL2NvbXBvbmVudHMvd2FsbGV0L1dhbGxldE1lbnVcIjtcbmltcG9ydCB7IEVOVklST05NRU5UIH0gZnJvbSBcIi4vdXRpbHMvYXBpQ29uc3VtcHRpb25cIjtcbmltcG9ydCBIZXhEZWNvZGVyIGZyb20gXCIuL2NvbXBvbmVudHMvZGVjb2Rlci9IZXhEZWNvZGVyXCI7XG5pbXBvcnQgVXBsb2FkcyBmcm9tIFwiLi9jb21wb25lbnRzL3VwbG9hZHMvdXBsb2Fkc1wiO1xuXG5jb25zdCBBcHA6IFJlYWN0LkZDID0gKCk6IFJlYWN0LlJlYWN0RWxlbWVudCA9PiB7XG4gIHJldHVybiA8TWFpblVwbG9hZGVyIC8+O1xufTtcblxuY29uc3QgQ29ubmVjdFdhbGxldEFwcDogUmVhY3QuRkMgPSAoKTogUmVhY3QuUmVhY3RFbGVtZW50ID0+IHtcbiAgcmV0dXJuIDxDb25uZWN0V2FsbGV0IC8+O1xufTtcblxuLy8gU2VsZi1leGVjdXRpbmcgZnVuY3Rpb24gdGhhdCB3b3JrcyB3aGV0aGVyIERPTSBpcyBhbHJlYWR5IGxvYWRlZCBvciBub3RcbihmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGN1cnJlbnRFeGVjdXRpbmdFbnZpcm9ubWVudCA9XG4gICAgd2luZG93LmxvY2F0aW9uLmhvc3QuaW5jbHVkZXMoXCJ3ZWJmbG93LmlvXCIpIHx8XG4gICAgd2luZG93LmxvY2F0aW9uLmhvc3QuaW5jbHVkZXMoXCJsb2NhbGhvc3RcIilcbiAgICAgID8gXCJwcmVwcm9kdWN0aW9uXCJcbiAgICAgIDogXCJwcm9kdWN0aW9uXCI7XG4gIGlmIChjdXJyZW50RXhlY3V0aW5nRW52aXJvbm1lbnQgIT09IEVOVklST05NRU5UKSB7XG4gICAgLyogY29uc29sZS5lcnJvcihgTWlzbWF0Y2hlZCBlbnZpcm9ubWVudDogRXhwZWN0ZWQgJHtFTlZJUk9OTUVOVH0sIGZvdW5kICR7Y3VycmVudEV4ZWN1dGluZ0Vudmlyb25tZW50fWApOyAqL1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBZT1UgQVJFIFdPUktJTkcgSU4gJHtjdXJyZW50RXhlY3V0aW5nRW52aXJvbm1lbnR9IEVOVklST05NRU5UYFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc29sZS5sb2coXCJIRUxMTyBUSEVSRSBGUk9NIFBSRVBST0RcIik7XG5cbiAgY29uc3QgcmVuZGVyQXBwID0gKCkgPT4ge1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJyZWFjdC10YXJnZXRcIik7XG4gICAgY29uc3QgY29ubmVjdFdhbGxldEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbm5lY3Qtd2FsbGV0XCIpO1xuICAgIC8vY29uc3QgaW5zY3JpcHRvckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluc2NyaXB0b3Itcm9vdFwiKTtcbiAgICBjb25zdCBkZWNvZGVyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVjb2RlclwiKTtcbiAgICBjb25zb2xlLmxvZyhcImRlY29kZXJFbGVtZW50XCIsIGRlY29kZXJFbGVtZW50KTtcbiAgICAvKipcbiAgICAgKiBIVE1MIGVsZW1lbnQgd2hlcmUgdGhlIDxVcGxvYWRzIC8+IGNvbXBvbmVudCB3aWxsIGJlIHJlbmRlcmVkLlxuICAgICAqIFRoaXMgZWxlbWVudCBzaG91bGQgaGF2ZSBhbiBpZCBvZiBcInVwbG9hZHNcIiBhbmQgc2hvdWxkIGJlIHByZXNlbnQgaW4gdGhlXG4gICAgICogSFRNTCBkb2N1bWVudC5cbiAgICAgKi9cblxuICAgIGNvbnN0IHVwbG9hZHNFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ1cGxvYWRzXCIpO1xuICAgIGNvbnNvbGUubG9nKFwidXBsb2Fkc0VsZW1lbnRcIiwgdXBsb2Fkc0VsZW1lbnQpO1xuXG4gICAgaWYgKHJvb3RFbGVtZW50IC8qICYmIGluc2NyaXB0b3JFbGVtZW50ICovKSB7XG4gICAgICBjb25zdCByb290ID0gUmVhY3RET00uY3JlYXRlUm9vdChyb290RWxlbWVudCk7XG4gICAgICBjb25zb2xlLmxvZyhcIlJlYWN0IHRhcmdldCBlbGVtZW50IGZvdW5kXCIpO1xuICAgICAgY29uc29sZS5sb2coXCJDb25uZWN0IHdhbGxldCBlbGVtZW50IGZvdW5kXCIpO1xuXG4gICAgICByb290LnJlbmRlcihcbiAgICAgICAgPFJlYWN0LlN0cmljdE1vZGU+XG4gICAgICAgICAgPFdhbGxldFByb3ZpZGVyPlxuICAgICAgICAgICAgPFR4U3RhdHVzUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDxGaWxlVXBsb2FkUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPFR4UHJlcGFyYXRpb25Qcm92aWRlcj5cbiAgICAgICAgICAgICAgICAgIDxUeEluc2NyaXB0aW9uUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgICAgIHtjb25uZWN0V2FsbGV0RWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBvcnRhbCg8Q29ubmVjdFdhbGxldEFwcCAvPiwgY29ubmVjdFdhbGxldEVsZW1lbnQpfVxuICAgICAgICAgICAgICAgICAgICB7cm9vdEVsZW1lbnQgJiYgY3JlYXRlUG9ydGFsKDxBcHAgLz4sIHJvb3RFbGVtZW50KX1cbiAgICAgICAgICAgICAgICAgICAge2RvY3VtZW50LmJvZHkgJiYgY3JlYXRlUG9ydGFsKDxXYWxsZXRNZW51IC8+LCBkb2N1bWVudC5ib2R5KX1cbiAgICAgICAgICAgICAgICAgICAge3VwbG9hZHNFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgY3JlYXRlUG9ydGFsKDxVcGxvYWRzIC8+LCB1cGxvYWRzRWxlbWVudCl9XG4gICAgICAgICAgICAgICAgICAgIHtkZWNvZGVyRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVBvcnRhbCg8SGV4RGVjb2RlciAvPiwgZGVjb2RlckVsZW1lbnQpfVxuICAgICAgICAgICAgICAgICAgICB7Lyoge2NyZWF0ZVBvcnRhbCg8TWFpcW5JbnNjcmlwdG9yIC8+LCBpbnNjcmlwdG9yRWxlbWVudCl9ICovfVxuICAgICAgICAgICAgICAgICAgPC9UeEluc2NyaXB0aW9uUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPC9UeFByZXBhcmF0aW9uUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDwvRmlsZVVwbG9hZFByb3ZpZGVyPlxuICAgICAgICAgICAgPC9UeFN0YXR1c1Byb3ZpZGVyPlxuICAgICAgICAgIDwvV2FsbGV0UHJvdmlkZXI+XG4gICAgICAgIDwvUmVhY3QuU3RyaWN0TW9kZT5cbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIENoZWNrIGlmIERPTSBpcyBhbHJlYWR5IGxvYWRlZFxuICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAvLyBJZiBub3QgbG9hZGVkIHlldCwgd2FpdCBmb3IgRE9NQ29udGVudExvYWRlZFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIHJlbmRlckFwcCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYWxyZWFkeSBsb2FkZWQsIHJ1biBpbW1lZGlhdGVseVxuICAgIHJlbmRlckFwcCgpO1xuICB9XG59KSgpO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwiRmlsZVVwbG9hZENvbnRleHQiLCJ1bmRlZmluZWQiLCJ1c2VGaWxlVXBsb2FkIiwiY29udGV4dCIsIkVycm9yIiwiRmlsZVVwbG9hZFByb3ZpZGVyIiwiX3JlZiIsImNoaWxkcmVuIiwiX3JlZiRtYXhTaXplIiwibWF4U2l6ZSIsIl91c2VTdGF0ZSIsIl91c2VTdGF0ZTIiLCJfc2xpY2VkVG9BcnJheSIsImZpbGUiLCJzZXRGaWxlIiwiX3VzZVN0YXRlMyIsIl91c2VTdGF0ZTQiLCJlcnJvciIsInNldEVycm9yIiwidmFsaWRhdGVGaWxlIiwidmFsaWRUeXBlcyIsImluY2x1ZGVzIiwidHlwZSIsInNpemUiLCJhZGRGaWxlIiwibmV3RmlsZXMiLCJmaWxlVG9BZGQiLCJBcnJheSIsImZyb20iLCJmaWxlV2l0aFByZXZpZXciLCJzdGFydHNXaXRoIiwiT2JqZWN0IiwiYXNzaWduIiwicHJldmlldyIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsInJldm9rZU9iamVjdFVSTCIsInJlbW92ZUZpbGUiLCJjbGVhckZpbGUiLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiLCJ2YWx1ZSIsIlVwbG9hZEljb24iLCJjbGFzc05hbWUiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwieG1sbnMiLCJkIiwiX3R5cGVvZiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwib3duS2V5cyIsImUiLCJyIiwidCIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJmaWx0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwicHVzaCIsImFwcGx5IiwiX29iamVjdFNwcmVhZCIsImFyZ3VtZW50cyIsImxlbmd0aCIsImZvckVhY2giLCJfZGVmaW5lUHJvcGVydHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZGVmaW5lUHJvcGVydGllcyIsImRlZmluZVByb3BlcnR5IiwiX3RvUHJvcGVydHlLZXkiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImkiLCJfdG9QcmltaXRpdmUiLCJ0b1ByaW1pdGl2ZSIsImNhbGwiLCJUeXBlRXJyb3IiLCJTdHJpbmciLCJOdW1iZXIiLCJfYXJyYXlXaXRoSG9sZXMiLCJfaXRlcmFibGVUb0FycmF5TGltaXQiLCJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkiLCJfbm9uSXRlcmFibGVSZXN0IiwiYSIsIl9hcnJheUxpa2VUb0FycmF5IiwidG9TdHJpbmciLCJzbGljZSIsIm5hbWUiLCJ0ZXN0IiwibiIsImwiLCJ1IiwiZiIsIm5leHQiLCJkb25lIiwiaXNBcnJheSIsIlR4U3RhdHVzQ29udGV4dCIsIlR4U3RhdHVzUHJvdmlkZXIiLCJpc1Byb2Nlc3NpbmciLCJjdXJyZW50U3RlcCIsIm5leHRTdGVwIiwicHJlcGFyYXRpb24iLCJzZXRQcmVwYXJhdGlvbiIsImluc2NyaXB0aW9uIiwic2V0SW5zY3JpcHRpb24iLCJzZXRQcmVwYXJhdGlvblN0YXR1cyIsInN0YXR1cyIsInByZXYiLCJzZXRJbnNjcmlwdGlvblN0YXR1cyIsIm1vdmVUb05leHRTdGVwIiwiZmxvdyIsIm5leHRTdGVwTWFwIiwicmVzZXRTdGF0dXMiLCJ1c2VUeFN0YXR1cyIsIm1vdGlvbiIsIkFuaW1hdGVQcmVzZW5jZSIsIlVwbG9hZEJveCIsIl91c2VGaWxlVXBsb2FkIiwiaXNEcmFnZ2luZyIsInNldElzRHJhZ2dpbmciLCJkcmFnQ291bnRlciIsInNldERyYWdDb3VudGVyIiwiX3VzZVR4U3RhdHVzIiwiaGFuZGxlRHJhZ0VudGVyIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJoYW5kbGVEcmFnTGVhdmUiLCJoYW5kbGVEcmFnT3ZlciIsImhhbmRsZURyb3AiLCJmaWxlcyIsImRhdGFUcmFuc2ZlciIsImFsZXJ0IiwiZGl2IiwiY29uY2F0Iiwib25EcmFnRW50ZXIiLCJvbkRyYWdMZWF2ZSIsIm9uRHJhZ092ZXIiLCJvbkRyb3AiLCJpbml0aWFsIiwib3BhY2l0eSIsInkiLCJhbmltYXRlIiwidHJhbnNpdGlvbiIsImR1cmF0aW9uIiwiaWQiLCJvbkNoYW5nZSIsInRhcmdldCIsImFjY2VwdCIsImRpc2FibGVkIiwid2hpbGVIb3ZlciIsInNjYWxlIiwic3RpZmZuZXNzIiwicm90YXRlIiwibW9kZSIsInAiLCJrZXkiLCJleGl0IiwiX3JlZ2VuZXJhdG9yUnVudGltZSIsImhhc093blByb3BlcnR5IiwiYyIsImFzeW5jSXRlcmF0b3IiLCJ0b1N0cmluZ1RhZyIsImRlZmluZSIsIndyYXAiLCJHZW5lcmF0b3IiLCJjcmVhdGUiLCJDb250ZXh0IiwibWFrZUludm9rZU1ldGhvZCIsInRyeUNhdGNoIiwiYXJnIiwiaCIsInMiLCJHZW5lcmF0b3JGdW5jdGlvbiIsIkdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJ2IiwidmFsdWVzIiwiZyIsImRlZmluZUl0ZXJhdG9yTWV0aG9kcyIsIl9pbnZva2UiLCJBc3luY0l0ZXJhdG9yIiwiaW52b2tlIiwicmVzb2x2ZSIsIl9fYXdhaXQiLCJ0aGVuIiwiY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmciLCJtZXRob2QiLCJkZWxlZ2F0ZSIsIm1heWJlSW52b2tlRGVsZWdhdGUiLCJzZW50IiwiX3NlbnQiLCJkaXNwYXRjaEV4Y2VwdGlvbiIsImFicnVwdCIsInJlc3VsdE5hbWUiLCJuZXh0TG9jIiwicHVzaFRyeUVudHJ5IiwidHJ5TG9jIiwiY2F0Y2hMb2MiLCJmaW5hbGx5TG9jIiwiYWZ0ZXJMb2MiLCJ0cnlFbnRyaWVzIiwicmVzZXRUcnlFbnRyeSIsImNvbXBsZXRpb24iLCJyZXNldCIsImlzTmFOIiwiZGlzcGxheU5hbWUiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwibWFyayIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiYXdyYXAiLCJhc3luYyIsIlByb21pc2UiLCJyZXZlcnNlIiwicG9wIiwiY2hhckF0Iiwic3RvcCIsInJ2YWwiLCJoYW5kbGUiLCJjb21wbGV0ZSIsImZpbmlzaCIsIl9jYXRjaCIsImRlbGVnYXRlWWllbGQiLCJhc3luY0dlbmVyYXRvclN0ZXAiLCJfYXN5bmNUb0dlbmVyYXRvciIsIl9uZXh0IiwiX3Rocm93IiwidXNlRWZmZWN0IiwiYWxsU3VwcG9ydGVkV2FsbGV0cyIsImdlcm8iLCJpY29uIiwidXJsIiwibnVmaSIsImJlZ2luIiwibGFjZSIsIldhbGxldENvbnRleHQiLCJ1c2VXYWxsZXQiLCJXYWxsZXRQcm92aWRlciIsImlzTWVudU9wZW4iLCJzZXRJc01lbnVPcGVuIiwiY29ubmVjdGVkV2FsbGV0cyIsInNldENvbm5lY3RlZFdhbGxldHMiLCJfdXNlU3RhdGU1IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIl91c2VTdGF0ZTYiLCJkZWZhdWx0V2FsbGV0Iiwic2V0RGVmYXVsdFdhbGxldCIsIl91c2VTdGF0ZTciLCJfdXNlU3RhdGU4IiwiaW5zdGFsbGVkV2FsbGV0cyIsInNldEluc3RhbGxlZFdhbGxldHMiLCJkZXRlY3RDb25uZWN0ZWRXYWxsZXRzIiwiX2NhbGxlZSIsImNhcmRhbm8iLCJjb25uZWN0ZWQiLCJfaSIsIl9PYmplY3QkZW50cmllcyIsIl9PYmplY3QkZW50cmllcyRfaSIsIndhbGxldCIsImlzRW5hYmxlZCIsImFwaSIsIl9jYWxsZWUkIiwiX2NvbnRleHQiLCJ3aW5kb3ciLCJlbnRyaWVzIiwiZW5hYmxlIiwidDAiLCJjb25zb2xlIiwiY29ubmVjdFdhbGxldCIsIl9yZWYzIiwiX2NhbGxlZTIiLCJ3YWxsZXROYW1lIiwiX2NhbGxlZTIkIiwiX2NvbnRleHQyIiwidG9Mb3dlckNhc2UiLCJsb2ciLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJzZXRJdGVtIiwiX3giLCJkaXNjb25uZWN0V2FsbGV0IiwicmVtb3ZlSXRlbSIsImhhbmRsZVNldERlZmF1bHRXYWxsZXQiLCJvcGVuTWVudSIsImNsb3NlTWVudSIsImRldGVjdEluc3RhbGxlZFdhbGxldHMiLCJpbnN0YWxsZWQiLCJnZXRXYWxsZXRBcGkiLCJmaW5kIiwidyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwid2FsbGV0cyIsIkFQSV9QQVRIIiwiYnVpbGRBcGlVcmwiLCJwYXRoIiwiQVBJX0tFWSIsInRvSGV4IiwiaW5wdXQiLCJlbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJlbmNvZGVUb0hleCIsInN0ciIsImVuY29kZSIsIm1hcCIsImJ5dGUiLCJwYWRTdGFydCIsImpvaW4iLCJiYXNlNjRUb0hleCIsInJhdyIsImF0b2IiLCJyZXN1bHQiLCJoZXgiLCJjaGFyQ29kZUF0IiwidG9VcHBlckNhc2UiLCJFTlZJUk9OTUVOVCIsInByb2Nlc3MiLCJlbnYiLCJUeFByZXBhcmF0aW9uQ29udGV4dCIsInVzZVR4UHJlcGFyYXRpb24iLCJUeFByZXBhcmF0aW9uUHJvdmlkZXIiLCJmaWxlUHJvZ3Jlc3MiLCJzZXRGaWxlUHJvZ3Jlc3MiLCJzZXRJc1Byb2Nlc3NpbmciLCJfdXNlV2FsbGV0Iiwic3VibWlzc2lvblN0YXR1cyIsInNldFN1Ym1pc3Npb25TdGF0dXMiLCJfdXNlU3RhdGU5IiwiX3VzZVN0YXRlMTAiLCJ1bnNpZ25lZFR4SWQiLCJzZXRVbnNpZ25lZFR4SWQiLCJ1cGRhdGVGaWxlUHJvZ3Jlc3MiLCJpbmRleCIsInVwZGF0ZXMiLCJpdGVtIiwiY2xlYXJFcnJvciIsImNvbnN0cnVjdFR4IiwiX3JlZjIiLCJkYXRhIiwiZGF0YVR5cGUiLCJyZXdhcmRBZGRyZXNzZXMiLCJ1dHhvcyIsInRhcmdldEFkZHJlc3MiLCJib2R5IiwicmVzcG9uc2UiLCJlcnJvckRhdGEiLCJlcnJvclJlc3BvbnNlIiwiZ2V0UmV3YXJkQWRkcmVzc2VzIiwiZ2V0VXR4b3MiLCJnZXRVc2VkQWRkcmVzc2VzIiwiZmV0Y2giLCJoZWFkZXJzIiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiY2xvbmUiLCJqc29uIiwidDEiLCJ0ZXh0Iiwic3RhdHVzVGV4dCIsImVuZHBvaW50IiwiX3gyIiwiX3gzIiwicHJlcGFyZUZpbGVzIiwiX2xvb3AiLCJfY29udGV4dDMiLCJwcm9ncmVzcyIsInJlYWRlciIsImZpbGVBc0Jhc2U2NCIsImJhc2U2NENvbnRlbnQiLCJjb25zdHJ1Y3RlZFR4IiwiX2xvb3AkIiwiRmlsZVJlYWRlciIsInJlamVjdCIsIm9ubG9hZCIsIm9uZXJyb3IiLCJyZWFkQXNEYXRhVVJMIiwic3BsaXQiLCJ0eEluZm8iLCJtZXNzYWdlIiwiX3g0IiwicHJlcGFyZVRleHQiLCJfcmVmNCIsIl9jYWxsZWUzIiwidGV4dEZpbGUiLCJfY2FsbGVlMyQiLCJfY29udGV4dDQiLCJGaWxlIiwiYnRvYSIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiX3g1IiwicG9sbEZvckNvbmZpcm1hdGlvbiIsIl9yZWY1IiwiX2NhbGxlZTQiLCJwcmVwYXJlZFR4IiwicmV0cnlJbnRlcnZhbCIsIl9jYWxsZWU0JCIsIl9jb250ZXh0NSIsImV4ZWN1dGlvbkFybiIsInN1Y2Nlc3MiLCJvbmNoYWluIiwicmVzIiwic2V0VGltZW91dCIsIl94NiIsImhhbmRsZVNpZ25BbmRTdWJtaXRFcnJvciIsImVycm9yTWVzc2FnZSIsImluZm8iLCJfcGFyc2VkRXJyb3IkZXJyb3IiLCJwYXJzZWRFcnJvciIsInBhcnNlIiwic2lnbkFuZFN1Ym1pdCIsIl9yZWY2IiwiX2NhbGxlZTUiLCJfZmlsZSR0eEluZm8iLCJ1bnNpZ25lZFR4UmVzcG9uc2UiLCJ1bnNpZ25lZFR4IiwicmV0cnlSZXNwb25zZSIsIl9lcnJvckRhdGEiLCJfZXJyb3JSZXNwb25zZSIsImhleFR4Iiwic2lnbmVkVHgiLCJzdWJtaXRSZXNwb25zZSIsIl9lcnJvckRhdGEyIiwiX2Vycm9yUmVzcG9uc2UyIiwic3VibWl0dGVkVHgiLCJjb25maXJtZWQiLCJfY2FsbGVlNSQiLCJfY29udGV4dDYiLCJ0eGlkIiwiaW5Qcm9ncmVzcyIsInR4Iiwic2lnblR4IiwidDIiLCJ1bGlkIiwid2l0bmVzc1NldCIsInQzIiwidDQiLCJDbG9zZUljb24iLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImluZGV4T2YiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIk1vdGlvblZhbHVlIiwiQnV0dG9uIiwiX3JlZiR2YXJpYW50IiwidmFyaWFudCIsImxvYWRpbmdUZXh0Iiwic3VjY2Vzc1RleHQiLCJpY29uQmVmb3JlIiwiaWNvbkFmdGVyIiwib25DbGljayIsIl9yZWYkYW5pbWF0ZSIsIl9yZWYkY2xhc3NOYW1lIiwicHJvcHMiLCJfZXhjbHVkZWQiLCJpc0xvYWRpbmciLCJzZXRJc0xvYWRpbmciLCJpc1N1Y2Nlc3MiLCJzZXRJc1N1Y2Nlc3MiLCJoYW5kbGVDbGljayIsImV2ZW50IiwiYmFzZUNsYXNzZXMiLCJ2YXJpYW50Q2xhc3NlcyIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJnaG9zdCIsImRpc2FibGVkQ2xhc3NlcyIsInNpemVDbGFzc2VzIiwiYnV0dG9uQ2xhc3NlcyIsImJ1dHRvbiIsIl9leHRlbmRzIiwid2hpbGVUYXAiLCJGcmFnbWVudCIsInJlcGVhdCIsIlBPU0lUSVZFX0lORklOSVRZIiwiZWFzZSIsImRhbXBpbmciLCJjaGlsZCIsInNwYW4iLCJQZGZJY29uIiwiUG5nSWNvbiIsIlBkZ0ljb24iLCJNcDRJY29uIiwiRmlsZUxpc3QiLCJfdXNlVHhQcmVwYXJhdGlvbiIsIngiLCJzcmMiLCJhbHQiLCJ0b0ZpeGVkIiwiRGVsZWdhdGVWaWV3Iiwic2V0VGV4dCIsInBsYWNlaG9sZGVyIiwiVHhJbnNjcmlwdGlvbkNvbnRleHQiLCJpbnNjcmliZUZpbGVzIiwiX2luc2NyaWJlRmlsZXMiLCJpbnNjcmliZVRleHQiLCJfaW5zY3JpYmVUZXh0IiwiX3NpZ25BbmRTdWJtaXQiLCJzZXRVbnNpZ25lZFR4IiwidXNlVHhJbnNjcmlwdGlvbiIsIlR4SW5zY3JpcHRpb25Qcm92aWRlciIsImNvbnN0cnVjdEluc2NyaXB0aW9uVHgiLCJwYXlsb2FkIiwicGF5bG9hZFR5cGUiLCJjaGFuZ2VBZGRyZXNzIiwibWludFRva2VuRm9yUGF5bG9hZCIsIl9jYWxsZWU2IiwiX2NhbGxlZTYkIiwiX2NvbnRleHQ3IiwiX2NhbGxlZTciLCJyZXNwb25zZVRleHQiLCJfZXJyb3JNZXNzYWdlIiwiX2NhbGxlZTckIiwiX2NvbnRleHQ4IiwiX2NhbGxlZTkiLCJfbG9vcDIiLCJfY2FsbGVlOSQiLCJfY29udGV4dDExIiwiX2FwaSIsInNpZ25lZFNoYXJkVHhzIiwiaW5zY3JpYmVTdWJtaXRCb2R5IiwiX2xvb3AyJCIsIl9jb250ZXh0MTAiLCJpbmRleGluZ1R4IiwiaWR4IiwiYWxsIiwic2hhcmRUeHMiLCJfcmVmNyIsIl9jYWxsZWU4Iiwic2hhcmRUeCIsImhleFNoYXJkVHgiLCJfYXBpMiIsIl9jYWxsZWU4JCIsIl9jb250ZXh0OSIsIl94NyIsImluZGV4aW5nVHhUb1N1Ym1pdCIsInR4c1RvU3VibWl0IiwidWxpZE9mT2JqZWN0Iiwib2JqZWN0VWxpZCIsIkxvYWRpbmdTY3JlZW4iLCJfcmVmJHRleHQiLCJyb3RhdGVZIiwiZGVsYXkiLCJocmVmIiwiRXhwbG9yZXJMaW5rIiwidHhJZCIsInJlbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIiwiRmluaXNoU2NyZWVuIiwiX3JlZjIkdGV4dCIsIl9yZWYyJGNsYXNzTmFtZSIsInNldElzUHJlcGFyZWQiLCJzZXRJc0luc2NyaWJlZCIsInNldERlbGVnYXRlVGV4dCIsInByZXBhcmF0aW9uVHhJZCIsImluZGV4aW5nVHhJZCIsInNoYXJkVHhJZHMiLCJfdXNlVHhJbnNjcmlwdGlvbiIsInJlc2V0UHJlcGFyYXRpb24iLCJzaGFyZFR4SWQiLCJhbGxTaGFyZFN1Ym1pc3Npb25zIiwic2hhcmQiLCJzaGFyZFN1Ym1pdHRlZFR4aWQiLCJQcm9ncmVzc0JhciIsInRvdGFsU3RlcHMiLCJzdGVwVGV4dCIsInBoYXNlIiwic3R5bGUiLCJNYWluVXBsb2FkZXIiLCJfcHJlcGFyYXRpb25TdWJtaXNzaW8yIiwiX3Vuc2lnbmVkVHgkc3VjY2VzcyIsIl91bnNpZ25lZFR4JHN1Y2Nlc3MyIiwiYWN0aXZlVmlldyIsInNldEFjdGl2ZVZpZXciLCJpc1ByZXBhcmluZyIsInByZXBhcmVTdGVwIiwicHJlcGFyZU5leHRTdGVwIiwicHJlcGFyZUVycm9yIiwiY2xlYXJQcmVwYXJlRXJyb3IiLCJzaWduQW5kU3VibWl0UHJlcGFyYXRpb24iLCJwcmVwYXJhdGlvblN1Ym1pc3Npb25TdGF0dXMiLCJpc0luc2NyaWJlUHJlcGFyaW5nIiwiaW5zY3JpYmVTdGVwIiwiaW5zY3JpYmVOZXh0U3RlcCIsImluc2NyaWJlRXJyb3IiLCJjbGVhckluc2NyaWJlRXJyb3IiLCJzaWduQW5kU3VibWl0SW5zY3JpcHRpb24iLCJyZXNldEluc2NyaXB0aW9uIiwiaXNQcmVwYXJlZCIsImlzSW5zY3JpYmVkIiwiZGVsZWdhdGVUZXh0IiwiX3ByZXBhcmF0aW9uU3VibWlzc2lvIiwiZ2V0TG9hZGluZ1RleHQiLCJnZXRQcm9ncmVzc1RleHQiLCJnZXRCdXR0b25UZXh0IiwiaXNJbkZpbmFsU3RlcCIsImhhbmRsZVByZXBhcmUiLCJoYW5kbGVJbnNjcmliZSIsImhhbmRsZVNpZ25BbmRTdWJtaXRQcmVwYXJhdGlvbiIsImhhbmRsZVNpZ25BbmRTdWJtaXRJbnNjcmlwdGlvbiIsImhhbmRsZUJhY2siLCJoYW5kbGVDYW5jZWwiLCJzaG93TG9hZGVyIiwiaGFuZGxlTWFpbkJ1dHRvbkNsaWNrIiwiZ2V0VG90YWxTdGVwcyIsImdldEN1cnJlbnRTdGVwIiwicHJlcGFyZVN0ZXBzIiwiaW5zY3JpYmVTdGVwcyIsImVuZCIsImdldFN0ZXBQaGFzZSIsImJvcmRlclJhZGl1cyIsInRyaW0iLCJDb25uZWN0V2FsbGV0IiwiQ2xvc2VJY29uU2Vjb25kYXJ5IiwiV2FsbGV0TWVudSIsImF2YWlsYWJsZVdhbGxldHMiLCJfIiwic29tZSIsIndhbGxldHNUb0luc3RhbGwiLCJjb25uZWN0ZWRXYWxsZXQiLCJpc0RlZmF1bHQiLCJfcmVmOCIsIm9wZW4iLCJpbml0aWFsaXplV2FzbURlY29kZXIiLCJfaW5pdGlhbGl6ZVdhc21EZWNvZGVyIiwid2FzbU1vZHVsZVVybCIsIndhc21VcmwiLCJjb21waWxlZFdhc21EZWNvZGVyIiwid2FzaUhhbmRsZXIiLCJiYXNlV2FzaSIsImltcG9ydE9iamVjdCIsIndhc21JbnN0YW5jZSIsIl9yZXNwb25zZSIsIndhc21CeXRlcyIsIndhc21Nb2R1bGUiLCJfd2FzaUhhbmRsZXIiLCJfYmFzZVdhc2kiLCJfaW1wb3J0T2JqZWN0IiwiX3dhc21JbnN0YW5jZSIsIldlYkFzc2VtYmx5IiwiY29tcGlsZVN0cmVhbWluZyIsImdldCIsInByb3AiLCJwcm9jX2V4aXQiLCJjb2RlIiwiZmRfd3JpdGUiLCJmZCIsImlvdnMiLCJpb3ZzTGVuIiwibndyaXR0ZW4iLCJ3YXNpX3NuYXBzaG90X3ByZXZpZXcxIiwiUHJveHkiLCJpbnN0YW50aWF0ZSIsIndhcm4iLCJhcnJheUJ1ZmZlciIsImNvbXBpbGUiLCJpc1ZhbGlkSGV4U3RyaW5nIiwiaGV4VG9CeXRlcyIsInJlcGxhY2UiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJwYXJzZUludCIsInN1YnN0cmluZyIsImJ5dGVzVG9CYXNlNjQiLCJiaW5TdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJyZWNvbnN0cnVjdE9yaWdpbmFsQnl0ZXMiLCJfcmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzIiwid0luc3RhbmNlIiwiaGV4U3RyaW5nQXJyYXkiLCJ2YWxpZEhleFN0cmluZ3MiLCJoZXhTdHJpbmdQdHJzIiwiaGV4U3RyaW5nQXJyYXlQdHJBZGRyIiwiYmFzZTY0UHRyIiwibWVtIiwidmlldyIsIl9iYXNlIiwiY29tYmluZWRIZXgiLCJiYXNlNjQiLCJleHBvcnRzIiwibWVtb3J5IiwiaHNfaW5pdCIsIndyaXRlQ1N0cmluZyIsIm1hbGxvY19ieXRlc19ocyIsImJ1ZmZlciIsIkRhdGFWaWV3Iiwic2V0VWludDMyIiwicmVjb25zdHJ1Y3RPcmlnaW5hbEJ5dGVzQyIsInJlYWRDU3RyaW5nIiwiZnJlZV9ocyIsInB0ciIsImhzX2V4aXQiLCJjbGVhbnVwRXJyb3IiLCJieXRlTGVuZ3RoIiwibWVtTGVuZ3RoIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJzdWJhcnJheSIsImxlbmd0aE5lZWRlZCIsImJhc2U2NFRvQnl0ZXMiLCJiaW5TdHIiLCJ1c2VSZWYiLCJIZXhEZWNvZGVyIiwic2V0SW5wdXQiLCJmb3JtYXQiLCJzZXRGb3JtYXQiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsInNldFJlc3VsdCIsImxhc3RIZXhJbnB1dCIsImxhc3RCYXNlNjQiLCJpbml0V2FzbSIsIl95aWVsZCRpbml0aWFsaXplV2FzbSIsImluc3QiLCJjdXJyZW50IiwiaGV4cyIsInR4dCIsImFyciIsIm91dCIsImVuZHNXaXRoIiwiX3VudXNlZCIsIkJvb2xlYW4iLCJlcnIiLCJ0YWJzIiwibGFiZWwiLCJ0YWIiLCJkb3dubG9hZCIsInRpdGxlIiwidXNlUmV3YXJkQWNjb3VudHMiLCJyZXdhcmRBY2NvdW50cyIsInNldFJld2FyZEFjY291bnRzIiwiZmV0Y2hSZXdhcmRBY2NvdW50cyIsInVzZVVwbG9hZHMiLCJfcmVmJGxpbWl0IiwibGltaXQiLCJhbGxVcGxvYWRzIiwic2V0QWxsVXBsb2FkcyIsImZpbHRlcmVkVXBsb2FkcyIsInNldEZpbHRlcmVkVXBsb2FkcyIsImRpc3BsYXllZFVwbG9hZHMiLCJzZXREaXNwbGF5ZWRVcGxvYWRzIiwiX3VzZVN0YXRlMTEiLCJfdXNlU3RhdGUxMiIsInBhZ2VzRGF0YSIsInNldFBhZ2VzRGF0YSIsIl91c2VTdGF0ZTEzIiwiX3VzZVN0YXRlMTQiLCJsYXN0T2JqZWN0VWxpZHMiLCJzZXRMYXN0T2JqZWN0VWxpZHMiLCJfdXNlU3RhdGUxNSIsIl91c2VTdGF0ZTE2IiwiY3VycmVudFBhZ2UiLCJzZXRDdXJyZW50UGFnZSIsIl91c2VTdGF0ZTE3IiwiX3VzZVN0YXRlMTgiLCJoYXNNb3JlUGFnZXMiLCJzZXRIYXNNb3JlUGFnZXMiLCJmZXRjaEluaXRpYWxVcGxvYWRzIiwiZm9ybWF0dGVkVXBsb2FkcyIsImxhc3RVbGlkIiwib2JqZWN0cyIsIm1MYXN0T2JqZWN0VWxpZCIsImZldGNoTmV4dFBhZ2UiLCJwYWdlTnVtYmVyIiwibmV3TGFzdFVsaWQiLCJsYXN0T2JqZWN0VWxpZCIsImdldEltYWdlU3JjIiwidXBsb2FkIiwidGh1bWJuYWlsVXJsIiwib2JqZWN0RGF0YSIsIm9iamVjdFR5cGUiLCJmb3JtYXREYXRlIiwiZGF0ZVN0cmluZyIsImRhdGUiLCJEYXRlIiwiZ2V0VGltZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsIlVwbG9hZENhcmQiLCJvbkNvcHlUZXh0IiwiaW5kZXhpbmdUeFN1Ym1pdHRlZEF0IiwiZGVzY3JpcHRpb24iLCJmaWxlVHlwZSIsIlVwbG9hZHNHcmlkIiwidXBsb2FkcyIsIlVwbG9hZExpc3RJdGVtIiwiVXBsb2Fkc0xpc3QiLCJVcGxvYWRzRmlsdGVycyIsImRhdGVGaWx0ZXIiLCJzZXREYXRlRmlsdGVyIiwidHlwZUZpbHRlciIsInNldFR5cGVGaWx0ZXIiLCJzZWFyY2hRdWVyeSIsInNldFNlYXJjaFF1ZXJ5Iiwib25TZWFyY2giLCJkYXRlRmlsdGVyT3B0aW9ucyIsInR5cGVGaWx0ZXJPcHRpb25zIiwidmlld01vZGUiLCJzZXRWaWV3TW9kZSIsIm9uU3VibWl0Iiwicm9sZSIsIm9wdGlvbiIsIm1vY2tVcGxvYWRzIiwiZGF0ZVVwbG9hZGVkIiwiVXBsb2FkcyIsIl91c2VVcGxvYWRzIiwiZmlsdGVyZWQiLCJub3ciLCJ0b2RheSIsImdldEZ1bGxZZWFyIiwiZ2V0TW9udGgiLCJnZXREYXRlIiwidGhpc1dlZWsiLCJzZXREYXRlIiwidGhpc01vbnRoIiwic2V0TW9udGgiLCJ0aGlzWWVhciIsInNldEZ1bGxZZWFyIiwidXBsb2FkRGF0ZSIsImxvd2VyRmlsZVR5cGUiLCJxdWVyeSIsImhhbmRsZVNlYXJjaCIsImhhbmRsZUNvcHlUZXh0IiwibmF2aWdhdG9yIiwiY2xpcGJvYXJkIiwid3JpdGVUZXh0IiwibG9hZE1vcmUiLCJnb1RvUHJldmlvdXNQYWdlIiwiZ29Ub1BhZ2UiLCJwYWdlIiwiUmVhY3RET00iLCJjcmVhdGVQb3J0YWwiLCJBcHAiLCJDb25uZWN0V2FsbGV0QXBwIiwiY3VycmVudEV4ZWN1dGluZ0Vudmlyb25tZW50IiwibG9jYXRpb24iLCJob3N0IiwicmVuZGVyQXBwIiwicm9vdEVsZW1lbnQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiY29ubmVjdFdhbGxldEVsZW1lbnQiLCJkZWNvZGVyRWxlbWVudCIsInVwbG9hZHNFbGVtZW50Iiwicm9vdCIsImNyZWF0ZVJvb3QiLCJyZW5kZXIiLCJTdHJpY3RNb2RlIiwicmVhZHlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///270\n')},408:(module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(354);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(314);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `/*! tailwindcss v4.0.2 | MIT License | https://tailwindcss.com */\n@layer theme, base, components, utilities;\n@layer theme {\n  :root, :host {\n    --font-sans: ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji",\n      "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";\n    --font-serif: ui-serif, Georgia, Cambria, "Times New Roman", Times, serif;\n    --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,\n      "Liberation Mono", "Courier New", monospace;\n    --color-red-50: oklch(0.971 0.013 17.38);\n    --color-red-100: oklch(0.936 0.032 17.717);\n    --color-red-200: oklch(0.885 0.062 18.334);\n    --color-red-300: oklch(0.808 0.114 19.571);\n    --color-red-400: oklch(0.704 0.191 22.216);\n    --color-red-500: oklch(0.637 0.237 25.331);\n    --color-red-600: oklch(0.577 0.245 27.325);\n    --color-red-700: oklch(0.505 0.213 27.518);\n    --color-red-800: oklch(0.444 0.177 26.899);\n    --color-red-900: oklch(0.396 0.141 25.723);\n    --color-red-950: oklch(0.258 0.092 26.042);\n    --color-orange-50: oklch(0.98 0.016 73.684);\n    --color-orange-100: oklch(0.954 0.038 75.164);\n    --color-orange-200: oklch(0.901 0.076 70.697);\n    --color-orange-300: oklch(0.837 0.128 66.29);\n    --color-orange-400: oklch(0.75 0.183 55.934);\n    --color-orange-500: oklch(0.705 0.213 47.604);\n    --color-orange-600: oklch(0.646 0.222 41.116);\n    --color-orange-700: oklch(0.553 0.195 38.402);\n    --color-orange-800: oklch(0.47 0.157 37.304);\n    --color-orange-900: oklch(0.408 0.123 38.172);\n    --color-orange-950: oklch(0.266 0.079 36.259);\n    --color-amber-50: oklch(0.987 0.022 95.277);\n    --color-amber-100: oklch(0.962 0.059 95.617);\n    --color-amber-200: oklch(0.924 0.12 95.746);\n    --color-amber-300: oklch(0.879 0.169 91.605);\n    --color-amber-400: oklch(0.828 0.189 84.429);\n    --color-amber-500: oklch(0.769 0.188 70.08);\n    --color-amber-600: oklch(0.666 0.179 58.318);\n    --color-amber-700: oklch(0.555 0.163 48.998);\n    --color-amber-800: oklch(0.473 0.137 46.201);\n    --color-amber-900: oklch(0.414 0.112 45.904);\n    --color-amber-950: oklch(0.279 0.077 45.635);\n    --color-yellow-50: oklch(0.987 0.026 102.212);\n    --color-yellow-100: oklch(0.973 0.071 103.193);\n    --color-yellow-200: oklch(0.945 0.129 101.54);\n    --color-yellow-300: oklch(0.905 0.182 98.111);\n    --color-yellow-400: oklch(0.852 0.199 91.936);\n    --color-yellow-500: oklch(0.795 0.184 86.047);\n    --color-yellow-600: oklch(0.681 0.162 75.834);\n    --color-yellow-700: oklch(0.554 0.135 66.442);\n    --color-yellow-800: oklch(0.476 0.114 61.907);\n    --color-yellow-900: oklch(0.421 0.095 57.708);\n    --color-yellow-950: oklch(0.286 0.066 53.813);\n    --color-lime-50: oklch(0.986 0.031 120.757);\n    --color-lime-100: oklch(0.967 0.067 122.328);\n    --color-lime-200: oklch(0.938 0.127 124.321);\n    --color-lime-300: oklch(0.897 0.196 126.665);\n    --color-lime-400: oklch(0.841 0.238 128.85);\n    --color-lime-500: oklch(0.768 0.233 130.85);\n    --color-lime-600: oklch(0.648 0.2 131.684);\n    --color-lime-700: oklch(0.532 0.157 131.589);\n    --color-lime-800: oklch(0.453 0.124 130.933);\n    --color-lime-900: oklch(0.405 0.101 131.063);\n    --color-lime-950: oklch(0.274 0.072 132.109);\n    --color-green-50: oklch(0.982 0.018 155.826);\n    --color-green-100: oklch(0.962 0.044 156.743);\n    --color-green-200: oklch(0.925 0.084 155.995);\n    --color-green-300: oklch(0.871 0.15 154.449);\n    --color-green-400: oklch(0.792 0.209 151.711);\n    --color-green-500: oklch(0.723 0.219 149.579);\n    --color-green-600: oklch(0.627 0.194 149.214);\n    --color-green-700: oklch(0.527 0.154 150.069);\n    --color-green-800: oklch(0.448 0.119 151.328);\n    --color-green-900: oklch(0.393 0.095 152.535);\n    --color-green-950: oklch(0.266 0.065 152.934);\n    --color-emerald-50: oklch(0.979 0.021 166.113);\n    --color-emerald-100: oklch(0.95 0.052 163.051);\n    --color-emerald-200: oklch(0.905 0.093 164.15);\n    --color-emerald-300: oklch(0.845 0.143 164.978);\n    --color-emerald-400: oklch(0.765 0.177 163.223);\n    --color-emerald-500: oklch(0.696 0.17 162.48);\n    --color-emerald-600: oklch(0.596 0.145 163.225);\n    --color-emerald-700: oklch(0.508 0.118 165.612);\n    --color-emerald-800: oklch(0.432 0.095 166.913);\n    --color-emerald-900: oklch(0.378 0.077 168.94);\n    --color-emerald-950: oklch(0.262 0.051 172.552);\n    --color-teal-50: oklch(0.984 0.014 180.72);\n    --color-teal-100: oklch(0.953 0.051 180.801);\n    --color-teal-200: oklch(0.91 0.096 180.426);\n    --color-teal-300: oklch(0.855 0.138 181.071);\n    --color-teal-400: oklch(0.777 0.152 181.912);\n    --color-teal-500: oklch(0.704 0.14 182.503);\n    --color-teal-600: oklch(0.6 0.118 184.704);\n    --color-teal-700: oklch(0.511 0.096 186.391);\n    --color-teal-800: oklch(0.437 0.078 188.216);\n    --color-teal-900: oklch(0.386 0.063 188.416);\n    --color-teal-950: oklch(0.277 0.046 192.524);\n    --color-cyan-50: oklch(0.984 0.019 200.873);\n    --color-cyan-100: oklch(0.956 0.045 203.388);\n    --color-cyan-200: oklch(0.917 0.08 205.041);\n    --color-cyan-300: oklch(0.865 0.127 207.078);\n    --color-cyan-400: oklch(0.789 0.154 211.53);\n    --color-cyan-500: oklch(0.715 0.143 215.221);\n    --color-cyan-600: oklch(0.609 0.126 221.723);\n    --color-cyan-700: oklch(0.52 0.105 223.128);\n    --color-cyan-800: oklch(0.45 0.085 224.283);\n    --color-cyan-900: oklch(0.398 0.07 227.392);\n    --color-cyan-950: oklch(0.302 0.056 229.695);\n    --color-sky-50: oklch(0.977 0.013 236.62);\n    --color-sky-100: oklch(0.951 0.026 236.824);\n    --color-sky-200: oklch(0.901 0.058 230.902);\n    --color-sky-300: oklch(0.828 0.111 230.318);\n    --color-sky-400: oklch(0.746 0.16 232.661);\n    --color-sky-500: oklch(0.685 0.169 237.323);\n    --color-sky-600: oklch(0.588 0.158 241.966);\n    --color-sky-700: oklch(0.5 0.134 242.749);\n    --color-sky-800: oklch(0.443 0.11 240.79);\n    --color-sky-900: oklch(0.391 0.09 240.876);\n    --color-sky-950: oklch(0.293 0.066 243.157);\n    --color-blue-50: oklch(0.97 0.014 254.604);\n    --color-blue-100: oklch(0.932 0.032 255.585);\n    --color-blue-200: oklch(0.882 0.059 254.128);\n    --color-blue-300: oklch(0.809 0.105 251.813);\n    --color-blue-400: oklch(0.707 0.165 254.624);\n    --color-blue-500: oklch(0.623 0.214 259.815);\n    --color-blue-600: oklch(0.546 0.245 262.881);\n    --color-blue-700: oklch(0.488 0.243 264.376);\n    --color-blue-800: oklch(0.424 0.199 265.638);\n    --color-blue-900: oklch(0.379 0.146 265.522);\n    --color-blue-950: oklch(0.282 0.091 267.935);\n    --color-indigo-50: oklch(0.962 0.018 272.314);\n    --color-indigo-100: oklch(0.93 0.034 272.788);\n    --color-indigo-200: oklch(0.87 0.065 274.039);\n    --color-indigo-300: oklch(0.785 0.115 274.713);\n    --color-indigo-400: oklch(0.673 0.182 276.935);\n    --color-indigo-500: oklch(0.585 0.233 277.117);\n    --color-indigo-600: oklch(0.511 0.262 276.966);\n    --color-indigo-700: oklch(0.457 0.24 277.023);\n    --color-indigo-800: oklch(0.398 0.195 277.366);\n    --color-indigo-900: oklch(0.359 0.144 278.697);\n    --color-indigo-950: oklch(0.257 0.09 281.288);\n    --color-violet-50: oklch(0.969 0.016 293.756);\n    --color-violet-100: oklch(0.943 0.029 294.588);\n    --color-violet-200: oklch(0.894 0.057 293.283);\n    --color-violet-300: oklch(0.811 0.111 293.571);\n    --color-violet-400: oklch(0.702 0.183 293.541);\n    --color-violet-500: oklch(0.606 0.25 292.717);\n    --color-violet-600: oklch(0.541 0.281 293.009);\n    --color-violet-700: oklch(0.491 0.27 292.581);\n    --color-violet-800: oklch(0.432 0.232 292.759);\n    --color-violet-900: oklch(0.38 0.189 293.745);\n    --color-violet-950: oklch(0.283 0.141 291.089);\n    --color-purple-50: oklch(0.977 0.014 308.299);\n    --color-purple-100: oklch(0.946 0.033 307.174);\n    --color-purple-200: oklch(0.902 0.063 306.703);\n    --color-purple-300: oklch(0.827 0.119 306.383);\n    --color-purple-400: oklch(0.714 0.203 305.504);\n    --color-purple-500: oklch(0.627 0.265 303.9);\n    --color-purple-600: oklch(0.558 0.288 302.321);\n    --color-purple-700: oklch(0.496 0.265 301.924);\n    --color-purple-800: oklch(0.438 0.218 303.724);\n    --color-purple-900: oklch(0.381 0.176 304.987);\n    --color-purple-950: oklch(0.291 0.149 302.717);\n    --color-fuchsia-50: oklch(0.977 0.017 320.058);\n    --color-fuchsia-100: oklch(0.952 0.037 318.852);\n    --color-fuchsia-200: oklch(0.903 0.076 319.62);\n    --color-fuchsia-300: oklch(0.833 0.145 321.434);\n    --color-fuchsia-400: oklch(0.74 0.238 322.16);\n    --color-fuchsia-500: oklch(0.667 0.295 322.15);\n    --color-fuchsia-600: oklch(0.591 0.293 322.896);\n    --color-fuchsia-700: oklch(0.518 0.253 323.949);\n    --color-fuchsia-800: oklch(0.452 0.211 324.591);\n    --color-fuchsia-900: oklch(0.401 0.17 325.612);\n    --color-fuchsia-950: oklch(0.293 0.136 325.661);\n    --color-pink-50: oklch(0.971 0.014 343.198);\n    --color-pink-100: oklch(0.948 0.028 342.258);\n    --color-pink-200: oklch(0.899 0.061 343.231);\n    --color-pink-300: oklch(0.823 0.12 346.018);\n    --color-pink-400: oklch(0.718 0.202 349.761);\n    --color-pink-500: oklch(0.656 0.241 354.308);\n    --color-pink-600: oklch(0.592 0.249 0.584);\n    --color-pink-700: oklch(0.525 0.223 3.958);\n    --color-pink-800: oklch(0.459 0.187 3.815);\n    --color-pink-900: oklch(0.408 0.153 2.432);\n    --color-pink-950: oklch(0.284 0.109 3.907);\n    --color-rose-50: oklch(0.969 0.015 12.422);\n    --color-rose-100: oklch(0.941 0.03 12.58);\n    --color-rose-200: oklch(0.892 0.058 10.001);\n    --color-rose-300: oklch(0.81 0.117 11.638);\n    --color-rose-400: oklch(0.712 0.194 13.428);\n    --color-rose-500: oklch(0.645 0.246 16.439);\n    --color-rose-600: oklch(0.586 0.253 17.585);\n    --color-rose-700: oklch(0.514 0.222 16.935);\n    --color-rose-800: oklch(0.455 0.188 13.697);\n    --color-rose-900: oklch(0.41 0.159 10.272);\n    --color-rose-950: oklch(0.271 0.105 12.094);\n    --color-slate-50: oklch(0.984 0.003 247.858);\n    --color-slate-100: oklch(0.968 0.007 247.896);\n    --color-slate-200: oklch(0.929 0.013 255.508);\n    --color-slate-300: oklch(0.869 0.022 252.894);\n    --color-slate-400: oklch(0.704 0.04 256.788);\n    --color-slate-500: oklch(0.554 0.046 257.417);\n    --color-slate-600: oklch(0.446 0.043 257.281);\n    --color-slate-700: oklch(0.372 0.044 257.287);\n    --color-slate-800: oklch(0.279 0.041 260.031);\n    --color-slate-900: oklch(0.208 0.042 265.755);\n    --color-slate-950: oklch(0.129 0.042 264.695);\n    --color-gray-50: oklch(0.985 0.002 247.839);\n    --color-gray-100: oklch(0.967 0.003 264.542);\n    --color-gray-200: oklch(0.928 0.006 264.531);\n    --color-gray-300: oklch(0.872 0.01 258.338);\n    --color-gray-400: oklch(0.707 0.022 261.325);\n    --color-gray-500: oklch(0.551 0.027 264.364);\n    --color-gray-600: oklch(0.446 0.03 256.802);\n    --color-gray-700: oklch(0.373 0.034 259.733);\n    --color-gray-800: oklch(0.278 0.033 256.848);\n    --color-gray-900: oklch(0.21 0.034 264.665);\n    --color-gray-950: oklch(0.13 0.028 261.692);\n    --color-zinc-50: oklch(0.985 0 0);\n    --color-zinc-100: oklch(0.967 0.001 286.375);\n    --color-zinc-200: oklch(0.92 0.004 286.32);\n    --color-zinc-300: oklch(0.871 0.006 286.286);\n    --color-zinc-400: oklch(0.705 0.015 286.067);\n    --color-zinc-500: oklch(0.552 0.016 285.938);\n    --color-zinc-600: oklch(0.442 0.017 285.786);\n    --color-zinc-700: oklch(0.37 0.013 285.805);\n    --color-zinc-800: oklch(0.274 0.006 286.033);\n    --color-zinc-900: oklch(0.21 0.006 285.885);\n    --color-zinc-950: oklch(0.141 0.005 285.823);\n    --color-neutral-50: oklch(0.985 0 0);\n    --color-neutral-100: oklch(0.97 0 0);\n    --color-neutral-200: oklch(0.922 0 0);\n    --color-neutral-300: oklch(0.87 0 0);\n    --color-neutral-400: oklch(0.708 0 0);\n    --color-neutral-500: oklch(0.556 0 0);\n    --color-neutral-600: oklch(0.439 0 0);\n    --color-neutral-700: oklch(0.371 0 0);\n    --color-neutral-800: oklch(0.269 0 0);\n    --color-neutral-900: oklch(0.205 0 0);\n    --color-neutral-950: oklch(0.145 0 0);\n    --color-stone-50: oklch(0.985 0.001 106.423);\n    --color-stone-100: oklch(0.97 0.001 106.424);\n    --color-stone-200: oklch(0.923 0.003 48.717);\n    --color-stone-300: oklch(0.869 0.005 56.366);\n    --color-stone-400: oklch(0.709 0.01 56.259);\n    --color-stone-500: oklch(0.553 0.013 58.071);\n    --color-stone-600: oklch(0.444 0.011 73.639);\n    --color-stone-700: oklch(0.374 0.01 67.558);\n    --color-stone-800: oklch(0.268 0.007 34.298);\n    --color-stone-900: oklch(0.216 0.006 56.043);\n    --color-stone-950: oklch(0.147 0.004 49.25);\n    --color-black: #000;\n    --color-white: #fff;\n    --spacing: 0.25rem;\n    --breakpoint-sm: 40rem;\n    --breakpoint-md: 48rem;\n    --breakpoint-lg: 64rem;\n    --breakpoint-xl: 80rem;\n    --breakpoint-2xl: 96rem;\n    --container-3xs: 16rem;\n    --container-2xs: 18rem;\n    --container-xs: 20rem;\n    --container-sm: 24rem;\n    --container-md: 28rem;\n    --container-lg: 32rem;\n    --container-xl: 36rem;\n    --container-2xl: 42rem;\n    --container-3xl: 48rem;\n    --container-4xl: 56rem;\n    --container-5xl: 64rem;\n    --container-6xl: 72rem;\n    --container-7xl: 80rem;\n    --text-xs: 0.75rem;\n    --text-xs--line-height: calc(1 / 0.75);\n    --text-sm: 0.875rem;\n    --text-sm--line-height: calc(1.25 / 0.875);\n    --text-base: 1rem;\n    --text-base--line-height: calc(1.5 / 1);\n    --text-lg: 1.125rem;\n    --text-lg--line-height: calc(1.75 / 1.125);\n    --text-xl: 1.25rem;\n    --text-xl--line-height: calc(1.75 / 1.25);\n    --text-2xl: 1.5rem;\n    --text-2xl--line-height: calc(2 / 1.5);\n    --text-3xl: 1.875rem;\n    --text-3xl--line-height: calc(2.25 / 1.875);\n    --text-4xl: 2.25rem;\n    --text-4xl--line-height: calc(2.5 / 2.25);\n    --text-5xl: 3rem;\n    --text-5xl--line-height: 1;\n    --text-6xl: 3.75rem;\n    --text-6xl--line-height: 1;\n    --text-7xl: 4.5rem;\n    --text-7xl--line-height: 1;\n    --text-8xl: 6rem;\n    --text-8xl--line-height: 1;\n    --text-9xl: 8rem;\n    --text-9xl--line-height: 1;\n    --font-weight-thin: 100;\n    --font-weight-extralight: 200;\n    --font-weight-light: 300;\n    --font-weight-normal: 400;\n    --font-weight-medium: 500;\n    --font-weight-semibold: 600;\n    --font-weight-bold: 700;\n    --font-weight-extrabold: 800;\n    --font-weight-black: 900;\n    --tracking-tighter: -0.05em;\n    --tracking-tight: -0.025em;\n    --tracking-normal: 0em;\n    --tracking-wide: 0.025em;\n    --tracking-wider: 0.05em;\n    --tracking-widest: 0.1em;\n    --leading-tight: 1.25;\n    --leading-snug: 1.375;\n    --leading-normal: 1.5;\n    --leading-relaxed: 1.625;\n    --leading-loose: 2;\n    --radius-xs: 0.125rem;\n    --radius-sm: 0.25rem;\n    --radius-md: 0.375rem;\n    --radius-lg: 0.5rem;\n    --radius-xl: 0.75rem;\n    --radius-2xl: 1rem;\n    --radius-3xl: 1.5rem;\n    --radius-4xl: 2rem;\n    --shadow-2xs: 0 1px rgb(0 0 0 / 0.05);\n    --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n    --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1),\n      0 2px 4px -2px rgb(0 0 0 / 0.1);\n    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1),\n      0 4px 6px -4px rgb(0 0 0 / 0.1);\n    --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1),\n      0 8px 10px -6px rgb(0 0 0 / 0.1);\n    --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);\n    --inset-shadow-2xs: inset 0 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-xs: inset 0 1px 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-sm: inset 0 2px 4px rgb(0 0 0 / 0.05);\n    --drop-shadow-xs: 0 1px 1px rgb(0 0 0 / 0.05);\n    --drop-shadow-sm: 0 1px 2px rgb(0 0 0 / 0.15);\n    --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);\n    --drop-shadow-lg: 0 4px 4px rgb(0 0 0 / 0.15);\n    --drop-shadow-xl: 0 9px 7px rgb(0 0 0 / 0.1);\n    --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);\n    --ease-in: cubic-bezier(0.4, 0, 1, 1);\n    --ease-out: cubic-bezier(0, 0, 0.2, 1);\n    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\n    --animate-spin: spin 1s linear infinite;\n    --animate-ping: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;\n    --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n    --animate-bounce: bounce 1s infinite;\n    --blur-xs: 4px;\n    --blur-sm: 8px;\n    --blur-md: 12px;\n    --blur-lg: 16px;\n    --blur-xl: 24px;\n    --blur-2xl: 40px;\n    --blur-3xl: 64px;\n    --perspective-dramatic: 100px;\n    --perspective-near: 300px;\n    --perspective-normal: 500px;\n    --perspective-midrange: 800px;\n    --perspective-distant: 1200px;\n    --aspect-video: 16 / 9;\n    --default-transition-duration: 150ms;\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    --default-font-family: var(--font-sans);\n    --default-font-feature-settings: var(--font-sans--font-feature-settings);\n    --default-font-variation-settings: var(\n      --font-sans--font-variation-settings\n    );\n    --default-mono-font-family: var(--font-mono);\n    --default-mono-font-feature-settings: var(\n      --font-mono--font-feature-settings\n    );\n    --default-mono-font-variation-settings: var(\n      --font-mono--font-variation-settings\n    );\n    --color-primary-tw: #2b80ff;\n    --color-light: #c3d5f7;\n  }\n}\n@layer base {\n  *, ::after, ::before, ::backdrop, ::file-selector-button {\n    box-sizing: border-box;\n    margin: 0;\n    padding: 0;\n    border: 0 solid;\n  }\n  html, :host {\n    line-height: 1.5;\n    -webkit-text-size-adjust: 100%;\n    tab-size: 4;\n    font-family: var( --default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji" );\n    font-feature-settings: var(--default-font-feature-settings, normal);\n    font-variation-settings: var( --default-font-variation-settings, normal );\n    -webkit-tap-highlight-color: transparent;\n  }\n  body {\n    line-height: inherit;\n  }\n  hr {\n    height: 0;\n    color: inherit;\n    border-top-width: 1px;\n  }\n  abbr:where([title]) {\n    -webkit-text-decoration: underline dotted;\n    text-decoration: underline dotted;\n  }\n  h1, h2, h3, h4, h5, h6 {\n    font-size: inherit;\n    font-weight: inherit;\n  }\n  a {\n    color: inherit;\n    -webkit-text-decoration: inherit;\n    text-decoration: inherit;\n  }\n  b, strong {\n    font-weight: bolder;\n  }\n  code, kbd, samp, pre {\n    font-family: var( --default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace );\n    font-feature-settings: var( --default-mono-font-feature-settings, normal );\n    font-variation-settings: var( --default-mono-font-variation-settings, normal );\n    font-size: 1em;\n  }\n  small {\n    font-size: 80%;\n  }\n  sub, sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n  sub {\n    bottom: -0.25em;\n  }\n  sup {\n    top: -0.5em;\n  }\n  table {\n    text-indent: 0;\n    border-color: inherit;\n    border-collapse: collapse;\n  }\n  :-moz-focusring {\n    outline: auto;\n  }\n  progress {\n    vertical-align: baseline;\n  }\n  summary {\n    display: list-item;\n  }\n  ol, ul, menu {\n    list-style: none;\n  }\n  img, svg, video, canvas, audio, iframe, embed, object {\n    display: block;\n    vertical-align: middle;\n  }\n  img, video {\n    max-width: 100%;\n    height: auto;\n  }\n  button, input, select, optgroup, textarea, ::file-selector-button {\n    font: inherit;\n    font-feature-settings: inherit;\n    font-variation-settings: inherit;\n    letter-spacing: inherit;\n    color: inherit;\n    border-radius: 0;\n    background-color: transparent;\n    opacity: 1;\n  }\n  :where(select:is([multiple], [size])) optgroup {\n    font-weight: bolder;\n  }\n  :where(select:is([multiple], [size])) optgroup option {\n    padding-inline-start: 20px;\n  }\n  ::file-selector-button {\n    margin-inline-end: 4px;\n  }\n  ::placeholder {\n    opacity: 1;\n    color: color-mix(in oklab, currentColor 50%, transparent);\n  }\n  textarea {\n    resize: vertical;\n  }\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n  ::-webkit-date-and-time-value {\n    min-height: 1lh;\n    text-align: inherit;\n  }\n  ::-webkit-datetime-edit {\n    display: inline-flex;\n  }\n  ::-webkit-datetime-edit-fields-wrapper {\n    padding: 0;\n  }\n  ::-webkit-datetime-edit, ::-webkit-datetime-edit-year-field, ::-webkit-datetime-edit-month-field, ::-webkit-datetime-edit-day-field, ::-webkit-datetime-edit-hour-field, ::-webkit-datetime-edit-minute-field, ::-webkit-datetime-edit-second-field, ::-webkit-datetime-edit-millisecond-field, ::-webkit-datetime-edit-meridiem-field {\n    padding-block: 0;\n  }\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n  button, input:where([type="button"], [type="reset"], [type="submit"]), ::file-selector-button {\n    appearance: button;\n  }\n  ::-webkit-inner-spin-button, ::-webkit-outer-spin-button {\n    height: auto;\n  }\n  [hidden]:where(:not([hidden="until-found"])) {\n    display: none !important;\n  }\n}\n@layer utilities {\n  .pointer-events-none {\n    pointer-events: none;\n  }\n  .collapse {\n    visibility: collapse;\n  }\n  .visible {\n    visibility: visible;\n  }\n  .absolute {\n    position: absolute;\n  }\n  .fixed {\n    position: fixed;\n  }\n  .relative {\n    position: relative;\n  }\n  .static {\n    position: static;\n  }\n  .inset-0 {\n    inset: calc(var(--spacing) * 0);\n  }\n  .top-0 {\n    top: calc(var(--spacing) * 0);\n  }\n  .top-4 {\n    top: calc(var(--spacing) * 4);\n  }\n  .right-0 {\n    right: calc(var(--spacing) * 0);\n  }\n  .right-4 {\n    right: calc(var(--spacing) * 4);\n  }\n  .z-40 {\n    z-index: 40;\n  }\n  .z-50 {\n    z-index: 50;\n  }\n  .m-0 {\n    margin: calc(var(--spacing) * 0);\n  }\n  .m-1 {\n    margin: calc(var(--spacing) * 1);\n  }\n  .mx-auto {\n    margin-inline: auto;\n  }\n  .my-1 {\n    margin-block: calc(var(--spacing) * 1);\n  }\n  .\\\\!mt-4 {\n    margin-top: calc(var(--spacing) * 4) !important;\n  }\n  .mt-2 {\n    margin-top: calc(var(--spacing) * 2);\n  }\n  .mt-3 {\n    margin-top: calc(var(--spacing) * 3);\n  }\n  .mt-4 {\n    margin-top: calc(var(--spacing) * 4);\n  }\n  .mt-6 {\n    margin-top: calc(var(--spacing) * 6);\n  }\n  .mt-8 {\n    margin-top: calc(var(--spacing) * 8);\n  }\n  .mr-4 {\n    margin-right: calc(var(--spacing) * 4);\n  }\n  .\\\\!mb-6 {\n    margin-bottom: calc(var(--spacing) * 6) !important;\n  }\n  .mb-1 {\n    margin-bottom: calc(var(--spacing) * 1);\n  }\n  .mb-1\\\\.5 {\n    margin-bottom: calc(var(--spacing) * 1.5);\n  }\n  .mb-2 {\n    margin-bottom: calc(var(--spacing) * 2);\n  }\n  .mb-2\\\\.5 {\n    margin-bottom: calc(var(--spacing) * 2.5);\n  }\n  .mb-3 {\n    margin-bottom: calc(var(--spacing) * 3);\n  }\n  .mb-4 {\n    margin-bottom: calc(var(--spacing) * 4);\n  }\n  .mb-6 {\n    margin-bottom: calc(var(--spacing) * 6);\n  }\n  .mb-8 {\n    margin-bottom: calc(var(--spacing) * 8);\n  }\n  .ml-2 {\n    margin-left: calc(var(--spacing) * 2);\n  }\n  .line-clamp-2 {\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 2;\n  }\n  .line-clamp-3 {\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-box-orient: vertical;\n    -webkit-line-clamp: 3;\n  }\n  .\\\\!flex {\n    display: flex !important;\n  }\n  .\\\\!hidden {\n    display: none !important;\n  }\n  .block {\n    display: block;\n  }\n  .contents {\n    display: contents;\n  }\n  .flex {\n    display: flex;\n  }\n  .grid {\n    display: grid;\n  }\n  .hidden {\n    display: none;\n  }\n  .inline-flex {\n    display: inline-flex;\n  }\n  .list-item {\n    display: list-item;\n  }\n  .table {\n    display: table;\n  }\n  .size-1 {\n    width: calc(var(--spacing) * 1);\n    height: calc(var(--spacing) * 1);\n  }\n  .\\\\!h-10 {\n    height: calc(var(--spacing) * 10) !important;\n  }\n  .h-1 {\n    height: calc(var(--spacing) * 1);\n  }\n  .h-2 {\n    height: calc(var(--spacing) * 2);\n  }\n  .h-4 {\n    height: calc(var(--spacing) * 4);\n  }\n  .h-5 {\n    height: calc(var(--spacing) * 5);\n  }\n  .h-6 {\n    height: calc(var(--spacing) * 6);\n  }\n  .h-8 {\n    height: calc(var(--spacing) * 8);\n  }\n  .h-10 {\n    height: calc(var(--spacing) * 10);\n  }\n  .h-12 {\n    height: calc(var(--spacing) * 12);\n  }\n  .h-20 {\n    height: calc(var(--spacing) * 20);\n  }\n  .h-48 {\n    height: calc(var(--spacing) * 48);\n  }\n  .h-56 {\n    height: calc(var(--spacing) * 56);\n  }\n  .h-\\\\[2\\\\.875rem\\\\] {\n    height: 2.875rem;\n  }\n  .h-\\\\[100px\\\\] {\n    height: 100px;\n  }\n  .h-\\\\[150px\\\\] {\n    height: 150px;\n  }\n  .h-\\\\[1rem\\\\] {\n    height: 1rem;\n  }\n  .h-full {\n    height: 100%;\n  }\n  .max-h-56 {\n    max-height: calc(var(--spacing) * 56);\n  }\n  .max-h-64 {\n    max-height: calc(var(--spacing) * 64);\n  }\n  .max-h-\\\\[300px\\\\] {\n    max-height: 300px;\n  }\n  .min-h-\\\\[20rem\\\\] {\n    min-height: 20rem;\n  }\n  .min-h-screen {\n    min-height: 100vh;\n  }\n  .\\\\!w-10 {\n    width: calc(var(--spacing) * 10) !important;\n  }\n  .w-1 {\n    width: calc(var(--spacing) * 1);\n  }\n  .w-1\\\\/4 {\n    width: calc(1/4 * 100%);\n  }\n  .w-4 {\n    width: calc(var(--spacing) * 4);\n  }\n  .w-5 {\n    width: calc(var(--spacing) * 5);\n  }\n  .w-6 {\n    width: calc(var(--spacing) * 6);\n  }\n  .w-8 {\n    width: calc(var(--spacing) * 8);\n  }\n  .w-10 {\n    width: calc(var(--spacing) * 10);\n  }\n  .w-12 {\n    width: calc(var(--spacing) * 12);\n  }\n  .w-20 {\n    width: calc(var(--spacing) * 20);\n  }\n  .w-\\\\[1\\\\.45456rem\\\\] {\n    width: 1.45456rem;\n  }\n  .w-\\\\[2\\\\.875rem\\\\] {\n    width: 2.875rem;\n  }\n  .w-\\\\[100px\\\\] {\n    width: 100px;\n  }\n  .w-full {\n    width: 100%;\n  }\n  .max-w-5xl {\n    max-width: var(--container-5xl);\n  }\n  .max-w-7xl {\n    max-width: var(--container-7xl);\n  }\n  .max-w-\\\\[800px\\\\] {\n    max-width: 800px;\n  }\n  .max-w-full {\n    max-width: 100%;\n  }\n  .max-w-md {\n    max-width: var(--container-md);\n  }\n  .min-w-\\\\[120px\\\\] {\n    min-width: 120px;\n  }\n  .flex-grow {\n    flex-grow: 1;\n  }\n  .border-collapse {\n    border-collapse: collapse;\n  }\n  .transform {\n    transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\n  }\n  .\\\\!cursor-not-allowed {\n    cursor: not-allowed !important;\n  }\n  .cursor-not-allowed {\n    cursor: not-allowed;\n  }\n  .cursor-pointer {\n    cursor: pointer;\n  }\n  .resize {\n    resize: both;\n  }\n  .resize-y {\n    resize: vertical;\n  }\n  .grid-cols-3 {\n    grid-template-columns: repeat(3, minmax(0, 1fr));\n  }\n  .grid-cols-\\\\[1fr_2fr_100px\\\\] {\n    grid-template-columns: 1fr 2fr 100px;\n  }\n  .flex-col {\n    flex-direction: column;\n  }\n  .flex-wrap {\n    flex-wrap: wrap;\n  }\n  .\\\\!items-center {\n    align-items: center !important;\n  }\n  .items-center {\n    align-items: center;\n  }\n  .\\\\!justify-center {\n    justify-content: center !important;\n  }\n  .justify-between {\n    justify-content: space-between;\n  }\n  .justify-center {\n    justify-content: center;\n  }\n  .\\\\!gap-2 {\n    gap: calc(var(--spacing) * 2) !important;\n  }\n  .gap-1\\\\.5 {\n    gap: calc(var(--spacing) * 1.5);\n  }\n  .gap-2 {\n    gap: calc(var(--spacing) * 2);\n  }\n  .gap-2\\\\.5 {\n    gap: calc(var(--spacing) * 2.5);\n  }\n  .gap-3 {\n    gap: calc(var(--spacing) * 3);\n  }\n  .gap-4 {\n    gap: calc(var(--spacing) * 4);\n  }\n  .gap-5 {\n    gap: calc(var(--spacing) * 5);\n  }\n  .gap-6 {\n    gap: calc(var(--spacing) * 6);\n  }\n  .gap-8 {\n    gap: calc(var(--spacing) * 8);\n  }\n  .space-y-1 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 1) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .space-y-2 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .space-y-4 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .space-y-6 {\n    :where(& > :not(:last-child)) {\n      --tw-space-y-reverse: 0;\n      margin-block-start: calc(calc(var(--spacing) * 6) * var(--tw-space-y-reverse));\n      margin-block-end: calc(calc(var(--spacing) * 6) * calc(1 - var(--tw-space-y-reverse)));\n    }\n  }\n  .self-start {\n    align-self: flex-start;\n  }\n  .overflow-auto {\n    overflow: auto;\n  }\n  .overflow-hidden {\n    overflow: hidden;\n  }\n  .overflow-y-auto {\n    overflow-y: auto;\n  }\n  .\\\\!rounded-full {\n    border-radius: calc(infinity * 1px) !important;\n  }\n  .rounded {\n    border-radius: 0.25rem;\n  }\n  .rounded-3xl {\n    border-radius: var(--radius-3xl);\n  }\n  .rounded-4xl {\n    border-radius: var(--radius-4xl);\n  }\n  .rounded-full {\n    border-radius: calc(infinity * 1px);\n  }\n  .rounded-lg {\n    border-radius: var(--radius-lg);\n  }\n  .rounded-md {\n    border-radius: var(--radius-md);\n  }\n  .rounded-xl {\n    border-radius: var(--radius-xl);\n  }\n  .rounded-l-md {\n    border-top-left-radius: var(--radius-md);\n    border-bottom-left-radius: var(--radius-md);\n  }\n  .rounded-r-md {\n    border-top-right-radius: var(--radius-md);\n    border-bottom-right-radius: var(--radius-md);\n  }\n  .\\\\!border {\n    border-style: var(--tw-border-style) !important;\n    border-width: 1px !important;\n  }\n  .border {\n    border-style: var(--tw-border-style);\n    border-width: 1px;\n  }\n  .border-0 {\n    border-style: var(--tw-border-style);\n    border-width: 0px;\n  }\n  .border-2 {\n    border-style: var(--tw-border-style);\n    border-width: 2px;\n  }\n  .border-t {\n    border-top-style: var(--tw-border-style);\n    border-top-width: 1px;\n  }\n  .border-t-2 {\n    border-top-style: var(--tw-border-style);\n    border-top-width: 2px;\n  }\n  .border-r-0 {\n    border-right-style: var(--tw-border-style);\n    border-right-width: 0px;\n  }\n  .border-b-2 {\n    border-bottom-style: var(--tw-border-style);\n    border-bottom-width: 2px;\n  }\n  .border-l-4 {\n    border-left-style: var(--tw-border-style);\n    border-left-width: 4px;\n  }\n  .border-dashed {\n    --tw-border-style: dashed;\n    border-style: dashed;\n  }\n  .border-none {\n    --tw-border-style: none;\n    border-style: none;\n  }\n  .\\\\!border-white {\n    border-color: var(--color-white) !important;\n  }\n  .border-blue-500 {\n    border-color: var(--color-blue-500);\n  }\n  .border-current {\n    border-color: currentColor;\n  }\n  .border-white {\n    border-color: var(--color-white);\n  }\n  .border-white\\\\/20 {\n    border-color: color-mix(in oklab, var(--color-white) 20%, transparent);\n  }\n  .\\\\!bg-transparent {\n    background-color: transparent !important;\n  }\n  .\\\\!bg-white {\n    background-color: var(--color-white) !important;\n  }\n  .bg-\\\\[\\\\#1a1a2a\\\\] {\n    background-color: #1a1a2a;\n  }\n  .bg-\\\\[\\\\#051023\\\\] {\n    background-color: #051023;\n  }\n  .bg-\\\\[\\\\#051023\\\\]\\\\/20 {\n    background-color: color-mix(in oklab, #051023 20%, transparent);\n  }\n  .bg-\\\\[\\\\#f6f6f6\\\\] {\n    background-color: #f6f6f6;\n  }\n  .bg-black {\n    background-color: var(--color-black);\n  }\n  .bg-black\\\\/20 {\n    background-color: color-mix(in oklab, var(--color-black) 20%, transparent);\n  }\n  .bg-blue-500 {\n    background-color: var(--color-blue-500);\n  }\n  .bg-blue-500\\\\/20 {\n    background-color: color-mix(in oklab, var(--color-blue-500) 20%, transparent);\n  }\n  .bg-blue-600 {\n    background-color: var(--color-blue-600);\n  }\n  .bg-primary-tw {\n    background-color: var(--color-primary-tw);\n  }\n  .bg-red-500 {\n    background-color: var(--color-red-500);\n  }\n  .bg-transparent {\n    background-color: transparent;\n  }\n  .bg-white {\n    background-color: var(--color-white);\n  }\n  .bg-white\\\\/5 {\n    background-color: color-mix(in oklab, var(--color-white) 5%, transparent);\n  }\n  .bg-white\\\\/10 {\n    background-color: color-mix(in oklab, var(--color-white) 10%, transparent);\n  }\n  .bg-white\\\\/20 {\n    background-color: color-mix(in oklab, var(--color-white) 20%, transparent);\n  }\n  .object-contain {\n    object-fit: contain;\n  }\n  .object-cover {\n    object-fit: cover;\n  }\n  .\\\\!p-2 {\n    padding: calc(var(--spacing) * 2) !important;\n  }\n  .p-1 {\n    padding: calc(var(--spacing) * 1);\n  }\n  .p-3 {\n    padding: calc(var(--spacing) * 3);\n  }\n  .p-4 {\n    padding: calc(var(--spacing) * 4);\n  }\n  .p-5 {\n    padding: calc(var(--spacing) * 5);\n  }\n  .p-6 {\n    padding: calc(var(--spacing) * 6);\n  }\n  .p-8 {\n    padding: calc(var(--spacing) * 8);\n  }\n  .p-12 {\n    padding: calc(var(--spacing) * 12);\n  }\n  .px-2 {\n    padding-inline: calc(var(--spacing) * 2);\n  }\n  .px-3 {\n    padding-inline: calc(var(--spacing) * 3);\n  }\n  .px-4 {\n    padding-inline: calc(var(--spacing) * 4);\n  }\n  .px-5 {\n    padding-inline: calc(var(--spacing) * 5);\n  }\n  .py-1 {\n    padding-block: calc(var(--spacing) * 1);\n  }\n  .py-2 {\n    padding-block: calc(var(--spacing) * 2);\n  }\n  .py-2\\\\.5 {\n    padding-block: calc(var(--spacing) * 2.5);\n  }\n  .py-3 {\n    padding-block: calc(var(--spacing) * 3);\n  }\n  .py-8 {\n    padding-block: calc(var(--spacing) * 8);\n  }\n  .py-12 {\n    padding-block: calc(var(--spacing) * 12);\n  }\n  .py-\\\\[0\\\\.125rem\\\\] {\n    padding-block: 0.125rem;\n  }\n  .pt-4 {\n    padding-top: calc(var(--spacing) * 4);\n  }\n  .text-center {\n    text-align: center;\n  }\n  .font-mono {\n    font-family: var(--font-mono);\n  }\n  .\\\\!text-sm {\n    font-size: var(--text-sm) !important;\n    line-height: var(--tw-leading, var(--text-sm--line-height)) !important;\n  }\n  .text-2xl {\n    font-size: var(--text-2xl);\n    line-height: var(--tw-leading, var(--text-2xl--line-height));\n  }\n  .text-3xl {\n    font-size: var(--text-3xl);\n    line-height: var(--tw-leading, var(--text-3xl--line-height));\n  }\n  .text-base {\n    font-size: var(--text-base);\n    line-height: var(--tw-leading, var(--text-base--line-height));\n  }\n  .text-lg {\n    font-size: var(--text-lg);\n    line-height: var(--tw-leading, var(--text-lg--line-height));\n  }\n  .text-sm {\n    font-size: var(--text-sm);\n    line-height: var(--tw-leading, var(--text-sm--line-height));\n  }\n  .text-xl {\n    font-size: var(--text-xl);\n    line-height: var(--tw-leading, var(--text-xl--line-height));\n  }\n  .text-xs {\n    font-size: var(--text-xs);\n    line-height: var(--tw-leading, var(--text-xs--line-height));\n  }\n  .text-\\\\[0\\\\.875rem\\\\] {\n    font-size: 0.875rem;\n  }\n  .text-\\\\[1\\\\.25rem\\\\] {\n    font-size: 1.25rem;\n  }\n  .text-\\\\[2rem\\\\] {\n    font-size: 2rem;\n  }\n  .\\\\!font-bold {\n    --tw-font-weight: var(--font-weight-bold) !important;\n    font-weight: var(--font-weight-bold) !important;\n  }\n  .font-bold {\n    --tw-font-weight: var(--font-weight-bold);\n    font-weight: var(--font-weight-bold);\n  }\n  .font-medium {\n    --tw-font-weight: var(--font-weight-medium);\n    font-weight: var(--font-weight-medium);\n  }\n  .font-semibold {\n    --tw-font-weight: var(--font-weight-semibold);\n    font-weight: var(--font-weight-semibold);\n  }\n  .break-all {\n    word-break: break-all;\n  }\n  .text-ellipsis {\n    text-overflow: ellipsis;\n  }\n  .whitespace-pre-wrap {\n    white-space: pre-wrap;\n  }\n  .\\\\!text-light {\n    color: var(--color-light) !important;\n  }\n  .\\\\!text-primary-tw {\n    color: var(--color-primary-tw) !important;\n  }\n  .\\\\!text-white {\n    color: var(--color-white) !important;\n  }\n  .\\\\!text-white\\\\/80 {\n    color: color-mix(in oklab, var(--color-white) 80%, transparent) !important;\n  }\n  .text-\\\\[\\\\#C3D5F7\\\\] {\n    color: #C3D5F7;\n  }\n  .text-blue-400 {\n    color: var(--color-blue-400);\n  }\n  .text-blue-500 {\n    color: var(--color-blue-500);\n  }\n  .text-gray-100 {\n    color: var(--color-gray-100);\n  }\n  .text-gray-200 {\n    color: var(--color-gray-200);\n  }\n  .text-gray-500 {\n    color: var(--color-gray-500);\n  }\n  .text-light {\n    color: var(--color-light);\n  }\n  .text-red-400 {\n    color: var(--color-red-400);\n  }\n  .text-red-500 {\n    color: var(--color-red-500);\n  }\n  .text-red-600 {\n    color: var(--color-red-600);\n  }\n  .text-white {\n    color: var(--color-white);\n  }\n  .text-white\\\\/60 {\n    color: color-mix(in oklab, var(--color-white) 60%, transparent);\n  }\n  .text-white\\\\/80 {\n    color: color-mix(in oklab, var(--color-white) 80%, transparent);\n  }\n  .italic {\n    font-style: italic;\n  }\n  .underline {\n    text-decoration-line: underline;\n  }\n  .\\\\!opacity-50 {\n    opacity: 50% !important;\n  }\n  .opacity-0 {\n    opacity: 0%;\n  }\n  .shadow-lg {\n    --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\n    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n  }\n  .outline {\n    outline-style: var(--tw-outline-style);\n    outline-width: 1px;\n  }\n  .blur {\n    --tw-blur: blur(8px);\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .drop-shadow {\n    --tw-drop-shadow: drop-shadow(0 1px 2px rgb(0 0 0 / 0.1)) drop-shadow( 0 1px 1px rgb(0 0 0 / 0.06));\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .filter {\n    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);\n  }\n  .backdrop-blur-\\\\[2px\\\\] {\n    --tw-backdrop-blur: blur(2px);\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .backdrop-blur-\\\\[10px\\\\] {\n    --tw-backdrop-blur: blur(10px);\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .backdrop-blur-xl {\n    --tw-backdrop-blur: blur(var(--blur-xl));\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .backdrop-filter {\n    -webkit-backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n    backdrop-filter: var(--tw-backdrop-blur,) var(--tw-backdrop-brightness,) var(--tw-backdrop-contrast,) var(--tw-backdrop-grayscale,) var(--tw-backdrop-hue-rotate,) var(--tw-backdrop-invert,) var(--tw-backdrop-opacity,) var(--tw-backdrop-saturate,) var(--tw-backdrop-sepia,);\n  }\n  .\\\\!transition-colors {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to !important;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function)) !important;\n    transition-duration: var(--tw-duration, var(--default-transition-duration)) !important;\n  }\n  .transition {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, -webkit-backdrop-filter, backdrop-filter;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .transition-all {\n    transition-property: all;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .transition-colors {\n    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to;\n    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));\n    transition-duration: var(--tw-duration, var(--default-transition-duration));\n  }\n  .\\\\!duration-300 {\n    --tw-duration: 300ms !important;\n    transition-duration: 300ms !important;\n  }\n  .duration-200 {\n    --tw-duration: 200ms;\n    transition-duration: 200ms;\n  }\n  .duration-300 {\n    --tw-duration: 300ms;\n    transition-duration: 300ms;\n  }\n  .ease-in {\n    --tw-ease: var(--ease-in);\n    transition-timing-function: var(--ease-in);\n  }\n  .ease-in-out {\n    --tw-ease: var(--ease-in-out);\n    transition-timing-function: var(--ease-in-out);\n  }\n  .ease-out {\n    --tw-ease: var(--ease-out);\n    transition-timing-function: var(--ease-out);\n  }\n  .placeholder\\\\:text-white\\\\/40 {\n    &::placeholder {\n      color: color-mix(in oklab, var(--color-white) 40%, transparent);\n    }\n  }\n  .hover\\\\:-translate-y-0\\\\.5 {\n    &:hover {\n      @media (hover: hover) {\n        --tw-translate-y: calc(var(--spacing) * -0.5);\n        translate: var(--tw-translate-x) var(--tw-translate-y);\n      }\n    }\n  }\n  .hover\\\\:-translate-y-1\\\\.5 {\n    &:hover {\n      @media (hover: hover) {\n        --tw-translate-y: calc(var(--spacing) * -1.5);\n        translate: var(--tw-translate-x) var(--tw-translate-y);\n      }\n    }\n  }\n  .hover\\\\:transform {\n    &:hover {\n      @media (hover: hover) {\n        transform: var(--tw-rotate-x) var(--tw-rotate-y) var(--tw-rotate-z) var(--tw-skew-x) var(--tw-skew-y);\n      }\n    }\n  }\n  .hover\\\\:\\\\!bg-transparent {\n    &:hover {\n      @media (hover: hover) {\n        background-color: transparent !important;\n      }\n    }\n  }\n  .hover\\\\:\\\\!bg-white\\\\/10 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: color-mix(in oklab, var(--color-white) 10%, transparent) !important;\n      }\n    }\n  }\n  .hover\\\\:bg-blue-700 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: var(--color-blue-700);\n      }\n    }\n  }\n  .hover\\\\:bg-red-500\\\\/10 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: color-mix(in oklab, var(--color-red-500) 10%, transparent);\n      }\n    }\n  }\n  .hover\\\\:bg-white\\\\/10 {\n    &:hover {\n      @media (hover: hover) {\n        background-color: color-mix(in oklab, var(--color-white) 10%, transparent);\n      }\n    }\n  }\n  .hover\\\\:\\\\!text-white {\n    &:hover {\n      @media (hover: hover) {\n        color: var(--color-white) !important;\n      }\n    }\n  }\n  .hover\\\\:text-blue-300 {\n    &:hover {\n      @media (hover: hover) {\n        color: var(--color-blue-300);\n      }\n    }\n  }\n  .hover\\\\:text-gray-200 {\n    &:hover {\n      @media (hover: hover) {\n        color: var(--color-gray-200);\n      }\n    }\n  }\n  .hover\\\\:opacity-80 {\n    &:hover {\n      @media (hover: hover) {\n        opacity: 80%;\n      }\n    }\n  }\n  .hover\\\\:shadow-lg {\n    &:hover {\n      @media (hover: hover) {\n        --tw-shadow: 0 10px 15px -3px var(--tw-shadow-color, rgb(0 0 0 / 0.1)), 0 4px 6px -4px var(--tw-shadow-color, rgb(0 0 0 / 0.1));\n        box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n      }\n    }\n  }\n  .focus\\\\:border-blue-400 {\n    &:focus {\n      border-color: var(--color-blue-400);\n    }\n  }\n  .focus\\\\:ring-2 {\n    &:focus {\n      --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentColor);\n      box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);\n    }\n  }\n  .focus\\\\:ring-\\\\[\\\\#447BF4\\\\] {\n    &:focus {\n      --tw-ring-color: #447BF4;\n    }\n  }\n  .focus\\\\:outline-none {\n    &:focus {\n      --tw-outline-style: none;\n      outline-style: none;\n    }\n  }\n  .disabled\\\\:cursor-not-allowed {\n    &:disabled {\n      cursor: not-allowed;\n    }\n  }\n  .disabled\\\\:opacity-50 {\n    &:disabled {\n      opacity: 50%;\n    }\n  }\n  .sm\\\\:grid-cols-1 {\n    @media (width >= 40rem) {\n      grid-template-columns: repeat(1, minmax(0, 1fr));\n    }\n  }\n  .md\\\\:order-first {\n    @media (width >= 48rem) {\n      order: calc(-infinity);\n    }\n  }\n  .md\\\\:h-\\\\[150px\\\\] {\n    @media (width >= 48rem) {\n      height: 150px;\n    }\n  }\n  .md\\\\:w-full {\n    @media (width >= 48rem) {\n      width: 100%;\n    }\n  }\n  .md\\\\:grid-cols-1 {\n    @media (width >= 48rem) {\n      grid-template-columns: repeat(1, minmax(0, 1fr));\n    }\n  }\n  .md\\\\:grid-cols-2 {\n    @media (width >= 48rem) {\n      grid-template-columns: repeat(2, minmax(0, 1fr));\n    }\n  }\n  .md\\\\:grid-rows-\\\\[auto_auto_auto\\\\] {\n    @media (width >= 48rem) {\n      grid-template-rows: auto auto auto;\n    }\n  }\n}\n@layer base {\n  :root {\n    --tw-important:   !important;\n  }\n}\n@keyframes spin {\n  to {\n    transform: rotate(360deg);\n  }\n}\n@keyframes ping {\n  75%, 100% {\n    transform: scale(2);\n    opacity: 0;\n  }\n}\n@keyframes pulse {\n  50% {\n    opacity: 0.5;\n  }\n}\n@keyframes bounce {\n  0%, 100% {\n    transform: translateY(-25%);\n    animation-timing-function: cubic-bezier(0.8, 0, 1, 1);\n  }\n  50% {\n    transform: none;\n    animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\n  }\n}\n@property --tw-rotate-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateX(0);\n}\n@property --tw-rotate-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateY(0);\n}\n@property --tw-rotate-z {\n  syntax: "*";\n  inherits: false;\n  initial-value: rotateZ(0);\n}\n@property --tw-skew-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: skewX(0);\n}\n@property --tw-skew-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: skewY(0);\n}\n@property --tw-space-y-reverse {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-border-style {\n  syntax: "*";\n  inherits: false;\n  initial-value: solid;\n}\n@property --tw-font-weight {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-shadow-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-inset-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-inset-shadow-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ring-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ring-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-inset-ring-color {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-inset-ring-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-ring-inset {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ring-offset-width {\n  syntax: "<length>";\n  inherits: false;\n  initial-value: 0px;\n}\n@property --tw-ring-offset-color {\n  syntax: "*";\n  inherits: false;\n  initial-value: #fff;\n}\n@property --tw-ring-offset-shadow {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0 0 #0000;\n}\n@property --tw-outline-style {\n  syntax: "*";\n  inherits: false;\n  initial-value: solid;\n}\n@property --tw-blur {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-brightness {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-contrast {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-grayscale {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-hue-rotate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-invert {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-opacity {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-saturate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-sepia {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-blur {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-brightness {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-contrast {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-grayscale {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-hue-rotate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-invert {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-opacity {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-saturate {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-backdrop-sepia {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-duration {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-ease {\n  syntax: "*";\n  inherits: false;\n}\n@property --tw-translate-x {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-translate-y {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n@property --tw-translate-z {\n  syntax: "*";\n  inherits: false;\n  initial-value: 0;\n}\n`, "",{"version":3,"sources":["webpack://./src/styles.css"],"names":[],"mappings":"AAAA,gEAYA;AAZA,yCAYA;AAZA;EAAA;IAAA;6DAYA;IAZA,yEAYA;IAZA;iDAYA;IAZA,wCAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,2CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,0CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,+CAYA;IAZA,+CAYA;IAZA,6CAYA;IAZA,+CAYA;IAZA,+CAYA;IAZA,+CAYA;IAZA,8CAYA;IAZA,+CAYA;IAZA,0CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,0CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,yCAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,0CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,yCAYA;IAZA,yCAYA;IAZA,0CAYA;IAZA,2CAYA;IAZA,0CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,4CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,8CAYA;IAZA,+CAYA;IAZA,8CAYA;IAZA,+CAYA;IAZA,6CAYA;IAZA,8CAYA;IAZA,+CAYA;IAZA,+CAYA;IAZA,+CAYA;IAZA,8CAYA;IAZA,+CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,0CAYA;IAZA,yCAYA;IAZA,2CAYA;IAZA,0CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,0CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,4CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,6CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,4CAYA;IAZA,4CAYA;IAZA,2CAYA;IAZA,2CAYA;IAZA,iCAYA;IAZA,4CAYA;IAZA,0CAYA;IAZ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ZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;EAZA,gBAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;EAZA,gBAYA;AAAA;AAZA;EAAA,WAYA;EAZA,eAYA;EAZA,gBAYA;AAAA","sourcesContent":["@import \\"tailwindcss\\";\\n\\n@theme {\\n  --color-primary-tw: #2b80ff;\\n  --color-light: #c3d5f7;\\n}\\n\\n@layer base {\\n  :root {\\n    --tw-important: !important;\\n  }\\n}\\n"],"sourceRoot":""}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDA4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUMwRztBQUNqQjtBQUN6Riw4QkFBOEIsbUZBQTJCLENBQUMsNEZBQXFDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1RkFBdUYsV0FBVyxLQUFLLEtBQUssS0FBSyxNQUFNLFdBQVcsS0FBSyxNQUFNLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssTUFBTSxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLE1BQU0sS0FBSyxNQUFNLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxVQUFVLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxXQUFXLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxXQUFXLFVBQVUsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVUsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxLQUFLLFdBQVcsVUFBVSxLQUFLLEtBQUssS0FBSyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLFdBQVcsS0FBSyxLQUFLLFVBQVUsV0FBVyxLQUFLLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFdBQVcsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLEtBQUssS0FBSyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLFdBQVcsS0FBSyxLQUFLLFVBQVUsVUFBVSxXQUFXLEtBQUssS0FBSyxVQUFVLFVBQVUsV0FBVyxpREFBaUQsWUFBWSxnQ0FBZ0MsMkJBQTJCLEdBQUcsaUJBQWlCLFdBQVcsaUNBQWlDLEtBQUssR0FBRyxxQkFBcUI7QUFDdDJiO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vc3JjL3N0eWxlcy5jc3M/MTRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgLyohIHRhaWx3aW5kY3NzIHY0LjAuMiB8IE1JVCBMaWNlbnNlIHwgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20gKi9cbkBsYXllciB0aGVtZSwgYmFzZSwgY29tcG9uZW50cywgdXRpbGl0aWVzO1xuQGxheWVyIHRoZW1lIHtcbiAgOnJvb3QsIDpob3N0IHtcbiAgICAtLWZvbnQtc2FuczogdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsXG4gICAgICBcIlNlZ29lIFVJIEVtb2ppXCIsIFwiU2Vnb2UgVUkgU3ltYm9sXCIsIFwiTm90byBDb2xvciBFbW9qaVwiO1xuICAgIC0tZm9udC1zZXJpZjogdWktc2VyaWYsIEdlb3JnaWEsIENhbWJyaWEsIFwiVGltZXMgTmV3IFJvbWFuXCIsIFRpbWVzLCBzZXJpZjtcbiAgICAtLWZvbnQtbW9ubzogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsXG4gICAgICBcIkxpYmVyYXRpb24gTW9ub1wiLCBcIkNvdXJpZXIgTmV3XCIsIG1vbm9zcGFjZTtcbiAgICAtLWNvbG9yLXJlZC01MDogb2tsY2goMC45NzEgMC4wMTMgMTcuMzgpO1xuICAgIC0tY29sb3ItcmVkLTEwMDogb2tsY2goMC45MzYgMC4wMzIgMTcuNzE3KTtcbiAgICAtLWNvbG9yLXJlZC0yMDA6IG9rbGNoKDAuODg1IDAuMDYyIDE4LjMzNCk7XG4gICAgLS1jb2xvci1yZWQtMzAwOiBva2xjaCgwLjgwOCAwLjExNCAxOS41NzEpO1xuICAgIC0tY29sb3ItcmVkLTQwMDogb2tsY2goMC43MDQgMC4xOTEgMjIuMjE2KTtcbiAgICAtLWNvbG9yLXJlZC01MDA6IG9rbGNoKDAuNjM3IDAuMjM3IDI1LjMzMSk7XG4gICAgLS1jb2xvci1yZWQtNjAwOiBva2xjaCgwLjU3NyAwLjI0NSAyNy4zMjUpO1xuICAgIC0tY29sb3ItcmVkLTcwMDogb2tsY2goMC41MDUgMC4yMTMgMjcuNTE4KTtcbiAgICAtLWNvbG9yLXJlZC04MDA6IG9rbGNoKDAuNDQ0IDAuMTc3IDI2Ljg5OSk7XG4gICAgLS1jb2xvci1yZWQtOTAwOiBva2xjaCgwLjM5NiAwLjE0MSAyNS43MjMpO1xuICAgIC0tY29sb3ItcmVkLTk1MDogb2tsY2goMC4yNTggMC4wOTIgMjYuMDQyKTtcbiAgICAtLWNvbG9yLW9yYW5nZS01MDogb2tsY2goMC45OCAwLjAxNiA3My42ODQpO1xuICAgIC0tY29sb3Itb3JhbmdlLTEwMDogb2tsY2goMC45NTQgMC4wMzggNzUuMTY0KTtcbiAgICAtLWNvbG9yLW9yYW5nZS0yMDA6IG9rbGNoKDAuOTAxIDAuMDc2IDcwLjY5Nyk7XG4gICAgLS1jb2xvci1vcmFuZ2UtMzAwOiBva2xjaCgwLjgzNyAwLjEyOCA2Ni4yOSk7XG4gICAgLS1jb2xvci1vcmFuZ2UtNDAwOiBva2xjaCgwLjc1IDAuMTgzIDU1LjkzNCk7XG4gICAgLS1jb2xvci1vcmFuZ2UtNTAwOiBva2xjaCgwLjcwNSAwLjIxMyA0Ny42MDQpO1xuICAgIC0tY29sb3Itb3JhbmdlLTYwMDogb2tsY2goMC42NDYgMC4yMjIgNDEuMTE2KTtcbiAgICAtLWNvbG9yLW9yYW5nZS03MDA6IG9rbGNoKDAuNTUzIDAuMTk1IDM4LjQwMik7XG4gICAgLS1jb2xvci1vcmFuZ2UtODAwOiBva2xjaCgwLjQ3IDAuMTU3IDM3LjMwNCk7XG4gICAgLS1jb2xvci1vcmFuZ2UtOTAwOiBva2xjaCgwLjQwOCAwLjEyMyAzOC4xNzIpO1xuICAgIC0tY29sb3Itb3JhbmdlLTk1MDogb2tsY2goMC4yNjYgMC4wNzkgMzYuMjU5KTtcbiAgICAtLWNvbG9yLWFtYmVyLTUwOiBva2xjaCgwLjk4NyAwLjAyMiA5NS4yNzcpO1xuICAgIC0tY29sb3ItYW1iZXItMTAwOiBva2xjaCgwLjk2MiAwLjA1OSA5NS42MTcpO1xuICAgIC0tY29sb3ItYW1iZXItMjAwOiBva2xjaCgwLjkyNCAwLjEyIDk1Ljc0Nik7XG4gICAgLS1jb2xvci1hbWJlci0zMDA6IG9rbGNoKDAuODc5IDAuMTY5IDkxLjYwNSk7XG4gICAgLS1jb2xvci1hbWJlci00MDA6IG9rbGNoKDAuODI4IDAuMTg5IDg0LjQyOSk7XG4gICAgLS1jb2xvci1hbWJlci01MDA6IG9rbGNoKDAuNzY5IDAuMTg4IDcwLjA4KTtcbiAgICAtLWNvbG9yLWFtYmVyLTYwMDogb2tsY2goMC42NjYgMC4xNzkgNTguMzE4KTtcbiAgICAtLWNvbG9yLWFtYmVyLTcwMDogb2tsY2goMC41NTUgMC4xNjMgNDguOTk4KTtcbiAgICAtLWNvbG9yLWFtYmVyLTgwMDogb2tsY2goMC40NzMgMC4xMzcgNDYuMjAxKTtcbiAgICAtLWNvbG9yLWFtYmVyLTkwMDogb2tsY2goMC40MTQgMC4xMTIgNDUuOTA0KTtcbiAgICAtLWNvbG9yLWFtYmVyLTk1MDogb2tsY2goMC4yNzkgMC4wNzcgNDUuNjM1KTtcbiAgICAtLWNvbG9yLXllbGxvdy01MDogb2tsY2goMC45ODcgMC4wMjYgMTAyLjIxMik7XG4gICAgLS1jb2xvci15ZWxsb3ctMTAwOiBva2xjaCgwLjk3MyAwLjA3MSAxMDMuMTkzKTtcbiAgICAtLWNvbG9yLXllbGxvdy0yMDA6IG9rbGNoKDAuOTQ1IDAuMTI5IDEwMS41NCk7XG4gICAgLS1jb2xvci15ZWxsb3ctMzAwOiBva2xjaCgwLjkwNSAwLjE4MiA5OC4xMTEpO1xuICAgIC0tY29sb3IteWVsbG93LTQwMDogb2tsY2goMC44NTIgMC4xOTkgOTEuOTM2KTtcbiAgICAtLWNvbG9yLXllbGxvdy01MDA6IG9rbGNoKDAuNzk1IDAuMTg0IDg2LjA0Nyk7XG4gICAgLS1jb2xvci15ZWxsb3ctNjAwOiBva2xjaCgwLjY4MSAwLjE2MiA3NS44MzQpO1xuICAgIC0tY29sb3IteWVsbG93LTcwMDogb2tsY2goMC41NTQgMC4xMzUgNjYuNDQyKTtcbiAgICAtLWNvbG9yLXllbGxvdy04MDA6IG9rbGNoKDAuNDc2IDAuMTE0IDYxLjkwNyk7XG4gICAgLS1jb2xvci15ZWxsb3ctOTAwOiBva2xjaCgwLjQyMSAwLjA5NSA1Ny43MDgpO1xuICAgIC0tY29sb3IteWVsbG93LTk1MDogb2tsY2goMC4yODYgMC4wNjYgNTMuODEzKTtcbiAgICAtLWNvbG9yLWxpbWUtNTA6IG9rbGNoKDAuOTg2IDAuMDMxIDEyMC43NTcpO1xuICAgIC0tY29sb3ItbGltZS0xMDA6IG9rbGNoKDAuOTY3IDAuMDY3IDEyMi4zMjgpO1xuICAgIC0tY29sb3ItbGltZS0yMDA6IG9rbGNoKDAuOTM4IDAuMTI3IDEyNC4zMjEpO1xuICAgIC0tY29sb3ItbGltZS0zMDA6IG9rbGNoKDAuODk3IDAuMTk2IDEyNi42NjUpO1xuICAgIC0tY29sb3ItbGltZS00MDA6IG9rbGNoKDAuODQxIDAuMjM4IDEyOC44NSk7XG4gICAgLS1jb2xvci1saW1lLTUwMDogb2tsY2goMC43NjggMC4yMzMgMTMwLjg1KTtcbiAgICAtLWNvbG9yLWxpbWUtNjAwOiBva2xjaCgwLjY0OCAwLjIgMTMxLjY4NCk7XG4gICAgLS1jb2xvci1saW1lLTcwMDogb2tsY2goMC41MzIgMC4xNTcgMTMxLjU4OSk7XG4gICAgLS1jb2xvci1saW1lLTgwMDogb2tsY2goMC40NTMgMC4xMjQgMTMwLjkzMyk7XG4gICAgLS1jb2xvci1saW1lLTkwMDogb2tsY2goMC40MDUgMC4xMDEgMTMxLjA2Myk7XG4gICAgLS1jb2xvci1saW1lLTk1MDogb2tsY2goMC4yNzQgMC4wNzIgMTMyLjEwOSk7XG4gICAgLS1jb2xvci1ncmVlbi01MDogb2tsY2goMC45ODIgMC4wMTggMTU1LjgyNik7XG4gICAgLS1jb2xvci1ncmVlbi0xMDA6IG9rbGNoKDAuOTYyIDAuMDQ0IDE1Ni43NDMpO1xuICAgIC0tY29sb3ItZ3JlZW4tMjAwOiBva2xjaCgwLjkyNSAwLjA4NCAxNTUuOTk1KTtcbiAgICAtLWNvbG9yLWdyZWVuLTMwMDogb2tsY2goMC44NzEgMC4xNSAxNTQuNDQ5KTtcbiAgICAtLWNvbG9yLWdyZWVuLTQwMDogb2tsY2goMC43OTIgMC4yMDkgMTUxLjcxMSk7XG4gICAgLS1jb2xvci1ncmVlbi01MDA6IG9rbGNoKDAuNzIzIDAuMjE5IDE0OS41NzkpO1xuICAgIC0tY29sb3ItZ3JlZW4tNjAwOiBva2xjaCgwLjYyNyAwLjE5NCAxNDkuMjE0KTtcbiAgICAtLWNvbG9yLWdyZWVuLTcwMDogb2tsY2goMC41MjcgMC4xNTQgMTUwLjA2OSk7XG4gICAgLS1jb2xvci1ncmVlbi04MDA6IG9rbGNoKDAuNDQ4IDAuMTE5IDE1MS4zMjgpO1xuICAgIC0tY29sb3ItZ3JlZW4tOTAwOiBva2xjaCgwLjM5MyAwLjA5NSAxNTIuNTM1KTtcbiAgICAtLWNvbG9yLWdyZWVuLTk1MDogb2tsY2goMC4yNjYgMC4wNjUgMTUyLjkzNCk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTUwOiBva2xjaCgwLjk3OSAwLjAyMSAxNjYuMTEzKTtcbiAgICAtLWNvbG9yLWVtZXJhbGQtMTAwOiBva2xjaCgwLjk1IDAuMDUyIDE2My4wNTEpO1xuICAgIC0tY29sb3ItZW1lcmFsZC0yMDA6IG9rbGNoKDAuOTA1IDAuMDkzIDE2NC4xNSk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTMwMDogb2tsY2goMC44NDUgMC4xNDMgMTY0Ljk3OCk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTQwMDogb2tsY2goMC43NjUgMC4xNzcgMTYzLjIyMyk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTUwMDogb2tsY2goMC42OTYgMC4xNyAxNjIuNDgpO1xuICAgIC0tY29sb3ItZW1lcmFsZC02MDA6IG9rbGNoKDAuNTk2IDAuMTQ1IDE2My4yMjUpO1xuICAgIC0tY29sb3ItZW1lcmFsZC03MDA6IG9rbGNoKDAuNTA4IDAuMTE4IDE2NS42MTIpO1xuICAgIC0tY29sb3ItZW1lcmFsZC04MDA6IG9rbGNoKDAuNDMyIDAuMDk1IDE2Ni45MTMpO1xuICAgIC0tY29sb3ItZW1lcmFsZC05MDA6IG9rbGNoKDAuMzc4IDAuMDc3IDE2OC45NCk7XG4gICAgLS1jb2xvci1lbWVyYWxkLTk1MDogb2tsY2goMC4yNjIgMC4wNTEgMTcyLjU1Mik7XG4gICAgLS1jb2xvci10ZWFsLTUwOiBva2xjaCgwLjk4NCAwLjAxNCAxODAuNzIpO1xuICAgIC0tY29sb3ItdGVhbC0xMDA6IG9rbGNoKDAuOTUzIDAuMDUxIDE4MC44MDEpO1xuICAgIC0tY29sb3ItdGVhbC0yMDA6IG9rbGNoKDAuOTEgMC4wOTYgMTgwLjQyNik7XG4gICAgLS1jb2xvci10ZWFsLTMwMDogb2tsY2goMC44NTUgMC4xMzggMTgxLjA3MSk7XG4gICAgLS1jb2xvci10ZWFsLTQwMDogb2tsY2goMC43NzcgMC4xNTIgMTgxLjkxMik7XG4gICAgLS1jb2xvci10ZWFsLTUwMDogb2tsY2goMC43MDQgMC4xNCAxODIuNTAzKTtcbiAgICAtLWNvbG9yLXRlYWwtNjAwOiBva2xjaCgwLjYgMC4xMTggMTg0LjcwNCk7XG4gICAgLS1jb2xvci10ZWFsLTcwMDogb2tsY2goMC41MTEgMC4wOTYgMTg2LjM5MSk7XG4gICAgLS1jb2xvci10ZWFsLTgwMDogb2tsY2goMC40MzcgMC4wNzggMTg4LjIxNik7XG4gICAgLS1jb2xvci10ZWFsLTkwMDogb2tsY2goMC4zODYgMC4wNjMgMTg4LjQxNik7XG4gICAgLS1jb2xvci10ZWFsLTk1MDogb2tsY2goMC4yNzcgMC4wNDYgMTkyLjUyNCk7XG4gICAgLS1jb2xvci1jeWFuLTUwOiBva2xjaCgwLjk4NCAwLjAxOSAyMDAuODczKTtcbiAgICAtLWNvbG9yLWN5YW4tMTAwOiBva2xjaCgwLjk1NiAwLjA0NSAyMDMuMzg4KTtcbiAgICAtLWNvbG9yLWN5YW4tMjAwOiBva2xjaCgwLjkxNyAwLjA4IDIwNS4wNDEpO1xuICAgIC0tY29sb3ItY3lhbi0zMDA6IG9rbGNoKDAuODY1IDAuMTI3IDIwNy4wNzgpO1xuICAgIC0tY29sb3ItY3lhbi00MDA6IG9rbGNoKDAuNzg5IDAuMTU0IDIxMS41Myk7XG4gICAgLS1jb2xvci1jeWFuLTUwMDogb2tsY2goMC43MTUgMC4xNDMgMjE1LjIyMSk7XG4gICAgLS1jb2xvci1jeWFuLTYwMDogb2tsY2goMC42MDkgMC4xMjYgMjIxLjcyMyk7XG4gICAgLS1jb2xvci1jeWFuLTcwMDogb2tsY2goMC41MiAwLjEwNSAyMjMuMTI4KTtcbiAgICAtLWNvbG9yLWN5YW4tODAwOiBva2xjaCgwLjQ1IDAuMDg1IDIyNC4yODMpO1xuICAgIC0tY29sb3ItY3lhbi05MDA6IG9rbGNoKDAuMzk4IDAuMDcgMjI3LjM5Mik7XG4gICAgLS1jb2xvci1jeWFuLTk1MDogb2tsY2goMC4zMDIgMC4wNTYgMjI5LjY5NSk7XG4gICAgLS1jb2xvci1za3ktNTA6IG9rbGNoKDAuOTc3IDAuMDEzIDIzNi42Mik7XG4gICAgLS1jb2xvci1za3ktMTAwOiBva2xjaCgwLjk1MSAwLjAyNiAyMzYuODI0KTtcbiAgICAtLWNvbG9yLXNreS0yMDA6IG9rbGNoKDAuOTAxIDAuMDU4IDIzMC45MDIpO1xuICAgIC0tY29sb3Itc2t5LTMwMDogb2tsY2goMC44MjggMC4xMTEgMjMwLjMxOCk7XG4gICAgLS1jb2xvci1za3ktNDAwOiBva2xjaCgwLjc0NiAwLjE2IDIzMi42NjEpO1xuICAgIC0tY29sb3Itc2t5LTUwMDogb2tsY2goMC42ODUgMC4xNjkgMjM3LjMyMyk7XG4gICAgLS1jb2xvci1za3ktNjAwOiBva2xjaCgwLjU4OCAwLjE1OCAyNDEuOTY2KTtcbiAgICAtLWNvbG9yLXNreS03MDA6IG9rbGNoKDAuNSAwLjEzNCAyNDIuNzQ5KTtcbiAgICAtLWNvbG9yLXNreS04MDA6IG9rbGNoKDAuNDQzIDAuMTEgMjQwLjc5KTtcbiAgICAtLWNvbG9yLXNreS05MDA6IG9rbGNoKDAuMzkxIDAuMDkgMjQwLjg3Nik7XG4gICAgLS1jb2xvci1za3ktOTUwOiBva2xjaCgwLjI5MyAwLjA2NiAyNDMuMTU3KTtcbiAgICAtLWNvbG9yLWJsdWUtNTA6IG9rbGNoKDAuOTcgMC4wMTQgMjU0LjYwNCk7XG4gICAgLS1jb2xvci1ibHVlLTEwMDogb2tsY2goMC45MzIgMC4wMzIgMjU1LjU4NSk7XG4gICAgLS1jb2xvci1ibHVlLTIwMDogb2tsY2goMC44ODIgMC4wNTkgMjU0LjEyOCk7XG4gICAgLS1jb2xvci1ibHVlLTMwMDogb2tsY2goMC44MDkgMC4xMDUgMjUxLjgxMyk7XG4gICAgLS1jb2xvci1ibHVlLTQwMDogb2tsY2goMC43MDcgMC4xNjUgMjU0LjYyNCk7XG4gICAgLS1jb2xvci1ibHVlLTUwMDogb2tsY2goMC42MjMgMC4yMTQgMjU5LjgxNSk7XG4gICAgLS1jb2xvci1ibHVlLTYwMDogb2tsY2goMC41NDYgMC4yNDUgMjYyLjg4MSk7XG4gICAgLS1jb2xvci1ibHVlLTcwMDogb2tsY2goMC40ODggMC4yNDMgMjY0LjM3Nik7XG4gICAgLS1jb2xvci1ibHVlLTgwMDogb2tsY2goMC40MjQgMC4xOTkgMjY1LjYzOCk7XG4gICAgLS1jb2xvci1ibHVlLTkwMDogb2tsY2goMC4zNzkgMC4xNDYgMjY1LjUyMik7XG4gICAgLS1jb2xvci1ibHVlLTk1MDogb2tsY2goMC4yODIgMC4wOTEgMjY3LjkzNSk7XG4gICAgLS1jb2xvci1pbmRpZ28tNTA6IG9rbGNoKDAuOTYyIDAuMDE4IDI3Mi4zMTQpO1xuICAgIC0tY29sb3ItaW5kaWdvLTEwMDogb2tsY2goMC45MyAwLjAzNCAyNzIuNzg4KTtcbiAgICAtLWNvbG9yLWluZGlnby0yMDA6IG9rbGNoKDAuODcgMC4wNjUgMjc0LjAzOSk7XG4gICAgLS1jb2xvci1pbmRpZ28tMzAwOiBva2xjaCgwLjc4NSAwLjExNSAyNzQuNzEzKTtcbiAgICAtLWNvbG9yLWluZGlnby00MDA6IG9rbGNoKDAuNjczIDAuMTgyIDI3Ni45MzUpO1xuICAgIC0tY29sb3ItaW5kaWdvLTUwMDogb2tsY2goMC41ODUgMC4yMzMgMjc3LjExNyk7XG4gICAgLS1jb2xvci1pbmRpZ28tNjAwOiBva2xjaCgwLjUxMSAwLjI2MiAyNzYuOTY2KTtcbiAgICAtLWNvbG9yLWluZGlnby03MDA6IG9rbGNoKDAuNDU3IDAuMjQgMjc3LjAyMyk7XG4gICAgLS1jb2xvci1pbmRpZ28tODAwOiBva2xjaCgwLjM5OCAwLjE5NSAyNzcuMzY2KTtcbiAgICAtLWNvbG9yLWluZGlnby05MDA6IG9rbGNoKDAuMzU5IDAuMTQ0IDI3OC42OTcpO1xuICAgIC0tY29sb3ItaW5kaWdvLTk1MDogb2tsY2goMC4yNTcgMC4wOSAyODEuMjg4KTtcbiAgICAtLWNvbG9yLXZpb2xldC01MDogb2tsY2goMC45NjkgMC4wMTYgMjkzLjc1Nik7XG4gICAgLS1jb2xvci12aW9sZXQtMTAwOiBva2xjaCgwLjk0MyAwLjAyOSAyOTQuNTg4KTtcbiAgICAtLWNvbG9yLXZpb2xldC0yMDA6IG9rbGNoKDAuODk0IDAuMDU3IDI5My4yODMpO1xuICAgIC0tY29sb3ItdmlvbGV0LTMwMDogb2tsY2goMC44MTEgMC4xMTEgMjkzLjU3MSk7XG4gICAgLS1jb2xvci12aW9sZXQtNDAwOiBva2xjaCgwLjcwMiAwLjE4MyAyOTMuNTQxKTtcbiAgICAtLWNvbG9yLXZpb2xldC01MDA6IG9rbGNoKDAuNjA2IDAuMjUgMjkyLjcxNyk7XG4gICAgLS1jb2xvci12aW9sZXQtNjAwOiBva2xjaCgwLjU0MSAwLjI4MSAyOTMuMDA5KTtcbiAgICAtLWNvbG9yLXZpb2xldC03MDA6IG9rbGNoKDAuNDkxIDAuMjcgMjkyLjU4MSk7XG4gICAgLS1jb2xvci12aW9sZXQtODAwOiBva2xjaCgwLjQzMiAwLjIzMiAyOTIuNzU5KTtcbiAgICAtLWNvbG9yLXZpb2xldC05MDA6IG9rbGNoKDAuMzggMC4xODkgMjkzLjc0NSk7XG4gICAgLS1jb2xvci12aW9sZXQtOTUwOiBva2xjaCgwLjI4MyAwLjE0MSAyOTEuMDg5KTtcbiAgICAtLWNvbG9yLXB1cnBsZS01MDogb2tsY2goMC45NzcgMC4wMTQgMzA4LjI5OSk7XG4gICAgLS1jb2xvci1wdXJwbGUtMTAwOiBva2xjaCgwLjk0NiAwLjAzMyAzMDcuMTc0KTtcbiAgICAtLWNvbG9yLXB1cnBsZS0yMDA6IG9rbGNoKDAuOTAyIDAuMDYzIDMwNi43MDMpO1xuICAgIC0tY29sb3ItcHVycGxlLTMwMDogb2tsY2goMC44MjcgMC4xMTkgMzA2LjM4Myk7XG4gICAgLS1jb2xvci1wdXJwbGUtNDAwOiBva2xjaCgwLjcxNCAwLjIwMyAzMDUuNTA0KTtcbiAgICAtLWNvbG9yLXB1cnBsZS01MDA6IG9rbGNoKDAuNjI3IDAuMjY1IDMwMy45KTtcbiAgICAtLWNvbG9yLXB1cnBsZS02MDA6IG9rbGNoKDAuNTU4IDAuMjg4IDMwMi4zMjEpO1xuICAgIC0tY29sb3ItcHVycGxlLTcwMDogb2tsY2goMC40OTYgMC4yNjUgMzAxLjkyNCk7XG4gICAgLS1jb2xvci1wdXJwbGUtODAwOiBva2xjaCgwLjQzOCAwLjIxOCAzMDMuNzI0KTtcbiAgICAtLWNvbG9yLXB1cnBsZS05MDA6IG9rbGNoKDAuMzgxIDAuMTc2IDMwNC45ODcpO1xuICAgIC0tY29sb3ItcHVycGxlLTk1MDogb2tsY2goMC4yOTEgMC4xNDkgMzAyLjcxNyk7XG4gICAgLS1jb2xvci1mdWNoc2lhLTUwOiBva2xjaCgwLjk3NyAwLjAxNyAzMjAuMDU4KTtcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtMTAwOiBva2xjaCgwLjk1MiAwLjAzNyAzMTguODUyKTtcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtMjAwOiBva2xjaCgwLjkwMyAwLjA3NiAzMTkuNjIpO1xuICAgIC0tY29sb3ItZnVjaHNpYS0zMDA6IG9rbGNoKDAuODMzIDAuMTQ1IDMyMS40MzQpO1xuICAgIC0tY29sb3ItZnVjaHNpYS00MDA6IG9rbGNoKDAuNzQgMC4yMzggMzIyLjE2KTtcbiAgICAtLWNvbG9yLWZ1Y2hzaWEtNTAwOiBva2xjaCgwLjY2NyAwLjI5NSAzMjIuMTUpO1xuICAgIC0tY29sb3ItZnVjaHNpYS02MDA6IG9rbGNoKDAuNTkxIDAuMjkzIDMyMi44OTYpO1xuICAgIC0tY29sb3ItZnVjaHNpYS03MDA6IG9rbGNoKDAuNTE4IDAuMjUzIDMyMy45NDkpO1xuICAgIC0tY29sb3ItZnVjaHNpYS04MDA6IG9rbGNoKDAuNDUyIDAuMjExIDMyNC41OTEpO1xuICAgIC0tY29sb3ItZnVjaHNpYS05MDA6IG9rbGNoKDAuNDAxIDAuMTcgMzI1LjYxMik7XG4gICAgLS1jb2xvci1mdWNoc2lhLTk1MDogb2tsY2goMC4yOTMgMC4xMzYgMzI1LjY2MSk7XG4gICAgLS1jb2xvci1waW5rLTUwOiBva2xjaCgwLjk3MSAwLjAxNCAzNDMuMTk4KTtcbiAgICAtLWNvbG9yLXBpbmstMTAwOiBva2xjaCgwLjk0OCAwLjAyOCAzNDIuMjU4KTtcbiAgICAtLWNvbG9yLXBpbmstMjAwOiBva2xjaCgwLjg5OSAwLjA2MSAzNDMuMjMxKTtcbiAgICAtLWNvbG9yLXBpbmstMzAwOiBva2xjaCgwLjgyMyAwLjEyIDM0Ni4wMTgpO1xuICAgIC0tY29sb3ItcGluay00MDA6IG9rbGNoKDAuNzE4IDAuMjAyIDM0OS43NjEpO1xuICAgIC0tY29sb3ItcGluay01MDA6IG9rbGNoKDAuNjU2IDAuMjQxIDM1NC4zMDgpO1xuICAgIC0tY29sb3ItcGluay02MDA6IG9rbGNoKDAuNTkyIDAuMjQ5IDAuNTg0KTtcbiAgICAtLWNvbG9yLXBpbmstNzAwOiBva2xjaCgwLjUyNSAwLjIyMyAzLjk1OCk7XG4gICAgLS1jb2xvci1waW5rLTgwMDogb2tsY2goMC40NTkgMC4xODcgMy44MTUpO1xuICAgIC0tY29sb3ItcGluay05MDA6IG9rbGNoKDAuNDA4IDAuMTUzIDIuNDMyKTtcbiAgICAtLWNvbG9yLXBpbmstOTUwOiBva2xjaCgwLjI4NCAwLjEwOSAzLjkwNyk7XG4gICAgLS1jb2xvci1yb3NlLTUwOiBva2xjaCgwLjk2OSAwLjAxNSAxMi40MjIpO1xuICAgIC0tY29sb3Itcm9zZS0xMDA6IG9rbGNoKDAuOTQxIDAuMDMgMTIuNTgpO1xuICAgIC0tY29sb3Itcm9zZS0yMDA6IG9rbGNoKDAuODkyIDAuMDU4IDEwLjAwMSk7XG4gICAgLS1jb2xvci1yb3NlLTMwMDogb2tsY2goMC44MSAwLjExNyAxMS42MzgpO1xuICAgIC0tY29sb3Itcm9zZS00MDA6IG9rbGNoKDAuNzEyIDAuMTk0IDEzLjQyOCk7XG4gICAgLS1jb2xvci1yb3NlLTUwMDogb2tsY2goMC42NDUgMC4yNDYgMTYuNDM5KTtcbiAgICAtLWNvbG9yLXJvc2UtNjAwOiBva2xjaCgwLjU4NiAwLjI1MyAxNy41ODUpO1xuICAgIC0tY29sb3Itcm9zZS03MDA6IG9rbGNoKDAuNTE0IDAuMjIyIDE2LjkzNSk7XG4gICAgLS1jb2xvci1yb3NlLTgwMDogb2tsY2goMC40NTUgMC4xODggMTMuNjk3KTtcbiAgICAtLWNvbG9yLXJvc2UtOTAwOiBva2xjaCgwLjQxIDAuMTU5IDEwLjI3Mik7XG4gICAgLS1jb2xvci1yb3NlLTk1MDogb2tsY2goMC4yNzEgMC4xMDUgMTIuMDk0KTtcbiAgICAtLWNvbG9yLXNsYXRlLTUwOiBva2xjaCgwLjk4NCAwLjAwMyAyNDcuODU4KTtcbiAgICAtLWNvbG9yLXNsYXRlLTEwMDogb2tsY2goMC45NjggMC4wMDcgMjQ3Ljg5Nik7XG4gICAgLS1jb2xvci1zbGF0ZS0yMDA6IG9rbGNoKDAuOTI5IDAuMDEzIDI1NS41MDgpO1xuICAgIC0tY29sb3Itc2xhdGUtMzAwOiBva2xjaCgwLjg2OSAwLjAyMiAyNTIuODk0KTtcbiAgICAtLWNvbG9yLXNsYXRlLTQwMDogb2tsY2goMC43MDQgMC4wNCAyNTYuNzg4KTtcbiAgICAtLWNvbG9yLXNsYXRlLTUwMDogb2tsY2goMC41NTQgMC4wNDYgMjU3LjQxNyk7XG4gICAgLS1jb2xvci1zbGF0ZS02MDA6IG9rbGNoKDAuNDQ2IDAuMDQzIDI1Ny4yODEpO1xuICAgIC0tY29sb3Itc2xhdGUtNzAwOiBva2xjaCgwLjM3MiAwLjA0NCAyNTcuMjg3KTtcbiAgICAtLWNvbG9yLXNsYXRlLTgwMDogb2tsY2goMC4yNzkgMC4wNDEgMjYwLjAzMSk7XG4gICAgLS1jb2xvci1zbGF0ZS05MDA6IG9rbGNoKDAuMjA4IDAuMDQyIDI2NS43NTUpO1xuICAgIC0tY29sb3Itc2xhdGUtOTUwOiBva2xjaCgwLjEyOSAwLjA0MiAyNjQuNjk1KTtcbiAgICAtLWNvbG9yLWdyYXktNTA6IG9rbGNoKDAuOTg1IDAuMDAyIDI0Ny44MzkpO1xuICAgIC0tY29sb3ItZ3JheS0xMDA6IG9rbGNoKDAuOTY3IDAuMDAzIDI2NC41NDIpO1xuICAgIC0tY29sb3ItZ3JheS0yMDA6IG9rbGNoKDAuOTI4IDAuMDA2IDI2NC41MzEpO1xuICAgIC0tY29sb3ItZ3JheS0zMDA6IG9rbGNoKDAuODcyIDAuMDEgMjU4LjMzOCk7XG4gICAgLS1jb2xvci1ncmF5LTQwMDogb2tsY2goMC43MDcgMC4wMjIgMjYxLjMyNSk7XG4gICAgLS1jb2xvci1ncmF5LTUwMDogb2tsY2goMC41NTEgMC4wMjcgMjY0LjM2NCk7XG4gICAgLS1jb2xvci1ncmF5LTYwMDogb2tsY2goMC40NDYgMC4wMyAyNTYuODAyKTtcbiAgICAtLWNvbG9yLWdyYXktNzAwOiBva2xjaCgwLjM3MyAwLjAzNCAyNTkuNzMzKTtcbiAgICAtLWNvbG9yLWdyYXktODAwOiBva2xjaCgwLjI3OCAwLjAzMyAyNTYuODQ4KTtcbiAgICAtLWNvbG9yLWdyYXktOTAwOiBva2xjaCgwLjIxIDAuMDM0IDI2NC42NjUpO1xuICAgIC0tY29sb3ItZ3JheS05NTA6IG9rbGNoKDAuMTMgMC4wMjggMjYxLjY5Mik7XG4gICAgLS1jb2xvci16aW5jLTUwOiBva2xjaCgwLjk4NSAwIDApO1xuICAgIC0tY29sb3ItemluYy0xMDA6IG9rbGNoKDAuOTY3IDAuMDAxIDI4Ni4zNzUpO1xuICAgIC0tY29sb3ItemluYy0yMDA6IG9rbGNoKDAuOTIgMC4wMDQgMjg2LjMyKTtcbiAgICAtLWNvbG9yLXppbmMtMzAwOiBva2xjaCgwLjg3MSAwLjAwNiAyODYuMjg2KTtcbiAgICAtLWNvbG9yLXppbmMtNDAwOiBva2xjaCgwLjcwNSAwLjAxNSAyODYuMDY3KTtcbiAgICAtLWNvbG9yLXppbmMtNTAwOiBva2xjaCgwLjU1MiAwLjAxNiAyODUuOTM4KTtcbiAgICAtLWNvbG9yLXppbmMtNjAwOiBva2xjaCgwLjQ0MiAwLjAxNyAyODUuNzg2KTtcbiAgICAtLWNvbG9yLXppbmMtNzAwOiBva2xjaCgwLjM3IDAuMDEzIDI4NS44MDUpO1xuICAgIC0tY29sb3ItemluYy04MDA6IG9rbGNoKDAuMjc0IDAuMDA2IDI4Ni4wMzMpO1xuICAgIC0tY29sb3ItemluYy05MDA6IG9rbGNoKDAuMjEgMC4wMDYgMjg1Ljg4NSk7XG4gICAgLS1jb2xvci16aW5jLTk1MDogb2tsY2goMC4xNDEgMC4wMDUgMjg1LjgyMyk7XG4gICAgLS1jb2xvci1uZXV0cmFsLTUwOiBva2xjaCgwLjk4NSAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC0xMDA6IG9rbGNoKDAuOTcgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtMjAwOiBva2xjaCgwLjkyMiAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC0zMDA6IG9rbGNoKDAuODcgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtNDAwOiBva2xjaCgwLjcwOCAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC01MDA6IG9rbGNoKDAuNTU2IDAgMCk7XG4gICAgLS1jb2xvci1uZXV0cmFsLTYwMDogb2tsY2goMC40MzkgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtNzAwOiBva2xjaCgwLjM3MSAwIDApO1xuICAgIC0tY29sb3ItbmV1dHJhbC04MDA6IG9rbGNoKDAuMjY5IDAgMCk7XG4gICAgLS1jb2xvci1uZXV0cmFsLTkwMDogb2tsY2goMC4yMDUgMCAwKTtcbiAgICAtLWNvbG9yLW5ldXRyYWwtOTUwOiBva2xjaCgwLjE0NSAwIDApO1xuICAgIC0tY29sb3Itc3RvbmUtNTA6IG9rbGNoKDAuOTg1IDAuMDAxIDEwNi40MjMpO1xuICAgIC0tY29sb3Itc3RvbmUtMTAwOiBva2xjaCgwLjk3IDAuMDAxIDEwNi40MjQpO1xuICAgIC0tY29sb3Itc3RvbmUtMjAwOiBva2xjaCgwLjkyMyAwLjAwMyA0OC43MTcpO1xuICAgIC0tY29sb3Itc3RvbmUtMzAwOiBva2xjaCgwLjg2OSAwLjAwNSA1Ni4zNjYpO1xuICAgIC0tY29sb3Itc3RvbmUtNDAwOiBva2xjaCgwLjcwOSAwLjAxIDU2LjI1OSk7XG4gICAgLS1jb2xvci1zdG9uZS01MDA6IG9rbGNoKDAuNTUzIDAuMDEzIDU4LjA3MSk7XG4gICAgLS1jb2xvci1zdG9uZS02MDA6IG9rbGNoKDAuNDQ0IDAuMDExIDczLjYzOSk7XG4gICAgLS1jb2xvci1zdG9uZS03MDA6IG9rbGNoKDAuMzc0IDAuMDEgNjcuNTU4KTtcbiAgICAtLWNvbG9yLXN0b25lLTgwMDogb2tsY2goMC4yNjggMC4wMDcgMzQuMjk4KTtcbiAgICAtLWNvbG9yLXN0b25lLTkwMDogb2tsY2goMC4yMTYgMC4wMDYgNTYuMDQzKTtcbiAgICAtLWNvbG9yLXN0b25lLTk1MDogb2tsY2goMC4xNDcgMC4wMDQgNDkuMjUpO1xuICAgIC0tY29sb3ItYmxhY2s6ICMwMDA7XG4gICAgLS1jb2xvci13aGl0ZTogI2ZmZjtcbiAgICAtLXNwYWNpbmc6IDAuMjVyZW07XG4gICAgLS1icmVha3BvaW50LXNtOiA0MHJlbTtcbiAgICAtLWJyZWFrcG9pbnQtbWQ6IDQ4cmVtO1xuICAgIC0tYnJlYWtwb2ludC1sZzogNjRyZW07XG4gICAgLS1icmVha3BvaW50LXhsOiA4MHJlbTtcbiAgICAtLWJyZWFrcG9pbnQtMnhsOiA5NnJlbTtcbiAgICAtLWNvbnRhaW5lci0zeHM6IDE2cmVtO1xuICAgIC0tY29udGFpbmVyLTJ4czogMThyZW07XG4gICAgLS1jb250YWluZXIteHM6IDIwcmVtO1xuICAgIC0tY29udGFpbmVyLXNtOiAyNHJlbTtcbiAgICAtLWNvbnRhaW5lci1tZDogMjhyZW07XG4gICAgLS1jb250YWluZXItbGc6IDMycmVtO1xuICAgIC0tY29udGFpbmVyLXhsOiAzNnJlbTtcbiAgICAtLWNvbnRhaW5lci0yeGw6IDQycmVtO1xuICAgIC0tY29udGFpbmVyLTN4bDogNDhyZW07XG4gICAgLS1jb250YWluZXItNHhsOiA1NnJlbTtcbiAgICAtLWNvbnRhaW5lci01eGw6IDY0cmVtO1xuICAgIC0tY29udGFpbmVyLTZ4bDogNzJyZW07XG4gICAgLS1jb250YWluZXItN3hsOiA4MHJlbTtcbiAgICAtLXRleHQteHM6IDAuNzVyZW07XG4gICAgLS10ZXh0LXhzLS1saW5lLWhlaWdodDogY2FsYygxIC8gMC43NSk7XG4gICAgLS10ZXh0LXNtOiAwLjg3NXJlbTtcbiAgICAtLXRleHQtc20tLWxpbmUtaGVpZ2h0OiBjYWxjKDEuMjUgLyAwLjg3NSk7XG4gICAgLS10ZXh0LWJhc2U6IDFyZW07XG4gICAgLS10ZXh0LWJhc2UtLWxpbmUtaGVpZ2h0OiBjYWxjKDEuNSAvIDEpO1xuICAgIC0tdGV4dC1sZzogMS4xMjVyZW07XG4gICAgLS10ZXh0LWxnLS1saW5lLWhlaWdodDogY2FsYygxLjc1IC8gMS4xMjUpO1xuICAgIC0tdGV4dC14bDogMS4yNXJlbTtcbiAgICAtLXRleHQteGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDEuNzUgLyAxLjI1KTtcbiAgICAtLXRleHQtMnhsOiAxLjVyZW07XG4gICAgLS10ZXh0LTJ4bC0tbGluZS1oZWlnaHQ6IGNhbGMoMiAvIDEuNSk7XG4gICAgLS10ZXh0LTN4bDogMS44NzVyZW07XG4gICAgLS10ZXh0LTN4bC0tbGluZS1oZWlnaHQ6IGNhbGMoMi4yNSAvIDEuODc1KTtcbiAgICAtLXRleHQtNHhsOiAyLjI1cmVtO1xuICAgIC0tdGV4dC00eGwtLWxpbmUtaGVpZ2h0OiBjYWxjKDIuNSAvIDIuMjUpO1xuICAgIC0tdGV4dC01eGw6IDNyZW07XG4gICAgLS10ZXh0LTV4bC0tbGluZS1oZWlnaHQ6IDE7XG4gICAgLS10ZXh0LTZ4bDogMy43NXJlbTtcbiAgICAtLXRleHQtNnhsLS1saW5lLWhlaWdodDogMTtcbiAgICAtLXRleHQtN3hsOiA0LjVyZW07XG4gICAgLS10ZXh0LTd4bC0tbGluZS1oZWlnaHQ6IDE7XG4gICAgLS10ZXh0LTh4bDogNnJlbTtcbiAgICAtLXRleHQtOHhsLS1saW5lLWhlaWdodDogMTtcbiAgICAtLXRleHQtOXhsOiA4cmVtO1xuICAgIC0tdGV4dC05eGwtLWxpbmUtaGVpZ2h0OiAxO1xuICAgIC0tZm9udC13ZWlnaHQtdGhpbjogMTAwO1xuICAgIC0tZm9udC13ZWlnaHQtZXh0cmFsaWdodDogMjAwO1xuICAgIC0tZm9udC13ZWlnaHQtbGlnaHQ6IDMwMDtcbiAgICAtLWZvbnQtd2VpZ2h0LW5vcm1hbDogNDAwO1xuICAgIC0tZm9udC13ZWlnaHQtbWVkaXVtOiA1MDA7XG4gICAgLS1mb250LXdlaWdodC1zZW1pYm9sZDogNjAwO1xuICAgIC0tZm9udC13ZWlnaHQtYm9sZDogNzAwO1xuICAgIC0tZm9udC13ZWlnaHQtZXh0cmFib2xkOiA4MDA7XG4gICAgLS1mb250LXdlaWdodC1ibGFjazogOTAwO1xuICAgIC0tdHJhY2tpbmctdGlnaHRlcjogLTAuMDVlbTtcbiAgICAtLXRyYWNraW5nLXRpZ2h0OiAtMC4wMjVlbTtcbiAgICAtLXRyYWNraW5nLW5vcm1hbDogMGVtO1xuICAgIC0tdHJhY2tpbmctd2lkZTogMC4wMjVlbTtcbiAgICAtLXRyYWNraW5nLXdpZGVyOiAwLjA1ZW07XG4gICAgLS10cmFja2luZy13aWRlc3Q6IDAuMWVtO1xuICAgIC0tbGVhZGluZy10aWdodDogMS4yNTtcbiAgICAtLWxlYWRpbmctc251ZzogMS4zNzU7XG4gICAgLS1sZWFkaW5nLW5vcm1hbDogMS41O1xuICAgIC0tbGVhZGluZy1yZWxheGVkOiAxLjYyNTtcbiAgICAtLWxlYWRpbmctbG9vc2U6IDI7XG4gICAgLS1yYWRpdXMteHM6IDAuMTI1cmVtO1xuICAgIC0tcmFkaXVzLXNtOiAwLjI1cmVtO1xuICAgIC0tcmFkaXVzLW1kOiAwLjM3NXJlbTtcbiAgICAtLXJhZGl1cy1sZzogMC41cmVtO1xuICAgIC0tcmFkaXVzLXhsOiAwLjc1cmVtO1xuICAgIC0tcmFkaXVzLTJ4bDogMXJlbTtcbiAgICAtLXJhZGl1cy0zeGw6IDEuNXJlbTtcbiAgICAtLXJhZGl1cy00eGw6IDJyZW07XG4gICAgLS1zaGFkb3ctMnhzOiAwIDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcbiAgICAtLXNoYWRvdy14czogMCAxcHggMnB4IDAgcmdiKDAgMCAwIC8gMC4wNSk7XG4gICAgLS1zaGFkb3ctc206IDAgMXB4IDNweCAwIHJnYigwIDAgMCAvIDAuMSksIDAgMXB4IDJweCAtMXB4IHJnYigwIDAgMCAvIDAuMSk7XG4gICAgLS1zaGFkb3ctbWQ6IDAgNHB4IDZweCAtMXB4IHJnYigwIDAgMCAvIDAuMSksXG4gICAgICAwIDJweCA0cHggLTJweCByZ2IoMCAwIDAgLyAwLjEpO1xuICAgIC0tc2hhZG93LWxnOiAwIDEwcHggMTVweCAtM3B4IHJnYigwIDAgMCAvIDAuMSksXG4gICAgICAwIDRweCA2cHggLTRweCByZ2IoMCAwIDAgLyAwLjEpO1xuICAgIC0tc2hhZG93LXhsOiAwIDIwcHggMjVweCAtNXB4IHJnYigwIDAgMCAvIDAuMSksXG4gICAgICAwIDhweCAxMHB4IC02cHggcmdiKDAgMCAwIC8gMC4xKTtcbiAgICAtLXNoYWRvdy0yeGw6IDAgMjVweCA1MHB4IC0xMnB4IHJnYigwIDAgMCAvIDAuMjUpO1xuICAgIC0taW5zZXQtc2hhZG93LTJ4czogaW5zZXQgMCAxcHggcmdiKDAgMCAwIC8gMC4wNSk7XG4gICAgLS1pbnNldC1zaGFkb3cteHM6IGluc2V0IDAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcbiAgICAtLWluc2V0LXNoYWRvdy1zbTogaW5zZXQgMCAycHggNHB4IHJnYigwIDAgMCAvIDAuMDUpO1xuICAgIC0tZHJvcC1zaGFkb3cteHM6IDAgMXB4IDFweCByZ2IoMCAwIDAgLyAwLjA1KTtcbiAgICAtLWRyb3Atc2hhZG93LXNtOiAwIDFweCAycHggcmdiKDAgMCAwIC8gMC4xNSk7XG4gICAgLS1kcm9wLXNoYWRvdy1tZDogMCAzcHggM3B4IHJnYigwIDAgMCAvIDAuMTIpO1xuICAgIC0tZHJvcC1zaGFkb3ctbGc6IDAgNHB4IDRweCByZ2IoMCAwIDAgLyAwLjE1KTtcbiAgICAtLWRyb3Atc2hhZG93LXhsOiAwIDlweCA3cHggcmdiKDAgMCAwIC8gMC4xKTtcbiAgICAtLWRyb3Atc2hhZG93LTJ4bDogMCAyNXB4IDI1cHggcmdiKDAgMCAwIC8gMC4xNSk7XG4gICAgLS1lYXNlLWluOiBjdWJpYy1iZXppZXIoMC40LCAwLCAxLCAxKTtcbiAgICAtLWVhc2Utb3V0OiBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAxKTtcbiAgICAtLWVhc2UtaW4tb3V0OiBjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpO1xuICAgIC0tYW5pbWF0ZS1zcGluOiBzcGluIDFzIGxpbmVhciBpbmZpbml0ZTtcbiAgICAtLWFuaW1hdGUtcGluZzogcGluZyAxcyBjdWJpYy1iZXppZXIoMCwgMCwgMC4yLCAxKSBpbmZpbml0ZTtcbiAgICAtLWFuaW1hdGUtcHVsc2U6IHB1bHNlIDJzIGN1YmljLWJlemllcigwLjQsIDAsIDAuNiwgMSkgaW5maW5pdGU7XG4gICAgLS1hbmltYXRlLWJvdW5jZTogYm91bmNlIDFzIGluZmluaXRlO1xuICAgIC0tYmx1ci14czogNHB4O1xuICAgIC0tYmx1ci1zbTogOHB4O1xuICAgIC0tYmx1ci1tZDogMTJweDtcbiAgICAtLWJsdXItbGc6IDE2cHg7XG4gICAgLS1ibHVyLXhsOiAyNHB4O1xuICAgIC0tYmx1ci0yeGw6IDQwcHg7XG4gICAgLS1ibHVyLTN4bDogNjRweDtcbiAgICAtLXBlcnNwZWN0aXZlLWRyYW1hdGljOiAxMDBweDtcbiAgICAtLXBlcnNwZWN0aXZlLW5lYXI6IDMwMHB4O1xuICAgIC0tcGVyc3BlY3RpdmUtbm9ybWFsOiA1MDBweDtcbiAgICAtLXBlcnNwZWN0aXZlLW1pZHJhbmdlOiA4MDBweDtcbiAgICAtLXBlcnNwZWN0aXZlLWRpc3RhbnQ6IDEyMDBweDtcbiAgICAtLWFzcGVjdC12aWRlbzogMTYgLyA5O1xuICAgIC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uOiAxNTBtcztcbiAgICAtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gICAgLS1kZWZhdWx0LWZvbnQtZmFtaWx5OiB2YXIoLS1mb250LXNhbnMpO1xuICAgIC0tZGVmYXVsdC1mb250LWZlYXR1cmUtc2V0dGluZ3M6IHZhcigtLWZvbnQtc2Fucy0tZm9udC1mZWF0dXJlLXNldHRpbmdzKTtcbiAgICAtLWRlZmF1bHQtZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IHZhcihcbiAgICAgIC0tZm9udC1zYW5zLS1mb250LXZhcmlhdGlvbi1zZXR0aW5nc1xuICAgICk7XG4gICAgLS1kZWZhdWx0LW1vbm8tZm9udC1mYW1pbHk6IHZhcigtLWZvbnQtbW9ubyk7XG4gICAgLS1kZWZhdWx0LW1vbm8tZm9udC1mZWF0dXJlLXNldHRpbmdzOiB2YXIoXG4gICAgICAtLWZvbnQtbW9uby0tZm9udC1mZWF0dXJlLXNldHRpbmdzXG4gICAgKTtcbiAgICAtLWRlZmF1bHQtbW9uby1mb250LXZhcmlhdGlvbi1zZXR0aW5nczogdmFyKFxuICAgICAgLS1mb250LW1vbm8tLWZvbnQtdmFyaWF0aW9uLXNldHRpbmdzXG4gICAgKTtcbiAgICAtLWNvbG9yLXByaW1hcnktdHc6ICMyYjgwZmY7XG4gICAgLS1jb2xvci1saWdodDogI2MzZDVmNztcbiAgfVxufVxuQGxheWVyIGJhc2Uge1xuICAqLCA6OmFmdGVyLCA6OmJlZm9yZSwgOjpiYWNrZHJvcCwgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICBib3JkZXI6IDAgc29saWQ7XG4gIH1cbiAgaHRtbCwgOmhvc3Qge1xuICAgIGxpbmUtaGVpZ2h0OiAxLjU7XG4gICAgLXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OiAxMDAlO1xuICAgIHRhYi1zaXplOiA0O1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoIC0tZGVmYXVsdC1mb250LWZhbWlseSwgdWktc2Fucy1zZXJpZiwgc3lzdGVtLXVpLCBzYW5zLXNlcmlmLCBcIkFwcGxlIENvbG9yIEVtb2ppXCIsIFwiU2Vnb2UgVUkgRW1vamlcIiwgXCJTZWdvZSBVSSBTeW1ib2xcIiwgXCJOb3RvIENvbG9yIEVtb2ppXCIgKTtcbiAgICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IHZhcigtLWRlZmF1bHQtZm9udC1mZWF0dXJlLXNldHRpbmdzLCBub3JtYWwpO1xuICAgIGZvbnQtdmFyaWF0aW9uLXNldHRpbmdzOiB2YXIoIC0tZGVmYXVsdC1mb250LXZhcmlhdGlvbi1zZXR0aW5ncywgbm9ybWFsICk7XG4gICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgfVxuICBib2R5IHtcbiAgICBsaW5lLWhlaWdodDogaW5oZXJpdDtcbiAgfVxuICBociB7XG4gICAgaGVpZ2h0OiAwO1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDtcbiAgfVxuICBhYmJyOndoZXJlKFt0aXRsZV0pIHtcbiAgICAtd2Via2l0LXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XG4gIH1cbiAgaDEsIGgyLCBoMywgaDQsIGg1LCBoNiB7XG4gICAgZm9udC1zaXplOiBpbmhlcml0O1xuICAgIGZvbnQtd2VpZ2h0OiBpbmhlcml0O1xuICB9XG4gIGEge1xuICAgIGNvbG9yOiBpbmhlcml0O1xuICAgIC13ZWJraXQtdGV4dC1kZWNvcmF0aW9uOiBpbmhlcml0O1xuICAgIHRleHQtZGVjb3JhdGlvbjogaW5oZXJpdDtcbiAgfVxuICBiLCBzdHJvbmcge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gIH1cbiAgY29kZSwga2JkLCBzYW1wLCBwcmUge1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoIC0tZGVmYXVsdC1tb25vLWZvbnQtZmFtaWx5LCB1aS1tb25vc3BhY2UsIFNGTW9uby1SZWd1bGFyLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXCJMaWJlcmF0aW9uIE1vbm9cIiwgXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2UgKTtcbiAgICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IHZhciggLS1kZWZhdWx0LW1vbm8tZm9udC1mZWF0dXJlLXNldHRpbmdzLCBub3JtYWwgKTtcbiAgICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogdmFyKCAtLWRlZmF1bHQtbW9uby1mb250LXZhcmlhdGlvbi1zZXR0aW5ncywgbm9ybWFsICk7XG4gICAgZm9udC1zaXplOiAxZW07XG4gIH1cbiAgc21hbGwge1xuICAgIGZvbnQtc2l6ZTogODAlO1xuICB9XG4gIHN1Yiwgc3VwIHtcbiAgICBmb250LXNpemU6IDc1JTtcbiAgICBsaW5lLWhlaWdodDogMDtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xuICB9XG4gIHN1YiB7XG4gICAgYm90dG9tOiAtMC4yNWVtO1xuICB9XG4gIHN1cCB7XG4gICAgdG9wOiAtMC41ZW07XG4gIH1cbiAgdGFibGUge1xuICAgIHRleHQtaW5kZW50OiAwO1xuICAgIGJvcmRlci1jb2xvcjogaW5oZXJpdDtcbiAgICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xuICB9XG4gIDotbW96LWZvY3VzcmluZyB7XG4gICAgb3V0bGluZTogYXV0bztcbiAgfVxuICBwcm9ncmVzcyB7XG4gICAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xuICB9XG4gIHN1bW1hcnkge1xuICAgIGRpc3BsYXk6IGxpc3QtaXRlbTtcbiAgfVxuICBvbCwgdWwsIG1lbnUge1xuICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gIH1cbiAgaW1nLCBzdmcsIHZpZGVvLCBjYW52YXMsIGF1ZGlvLCBpZnJhbWUsIGVtYmVkLCBvYmplY3Qge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gIH1cbiAgaW1nLCB2aWRlbyB7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIGhlaWdodDogYXV0bztcbiAgfVxuICBidXR0b24sIGlucHV0LCBzZWxlY3QsIG9wdGdyb3VwLCB0ZXh0YXJlYSwgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XG4gICAgZm9udDogaW5oZXJpdDtcbiAgICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IGluaGVyaXQ7XG4gICAgZm9udC12YXJpYXRpb24tc2V0dGluZ3M6IGluaGVyaXQ7XG4gICAgbGV0dGVyLXNwYWNpbmc6IGluaGVyaXQ7XG4gICAgY29sb3I6IGluaGVyaXQ7XG4gICAgYm9yZGVyLXJhZGl1czogMDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICBvcGFjaXR5OiAxO1xuICB9XG4gIDp3aGVyZShzZWxlY3Q6aXMoW211bHRpcGxlXSwgW3NpemVdKSkgb3B0Z3JvdXAge1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkZXI7XG4gIH1cbiAgOndoZXJlKHNlbGVjdDppcyhbbXVsdGlwbGVdLCBbc2l6ZV0pKSBvcHRncm91cCBvcHRpb24ge1xuICAgIHBhZGRpbmctaW5saW5lLXN0YXJ0OiAyMHB4O1xuICB9XG4gIDo6ZmlsZS1zZWxlY3Rvci1idXR0b24ge1xuICAgIG1hcmdpbi1pbmxpbmUtZW5kOiA0cHg7XG4gIH1cbiAgOjpwbGFjZWhvbGRlciB7XG4gICAgb3BhY2l0eTogMTtcbiAgICBjb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCBjdXJyZW50Q29sb3IgNTAlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgdGV4dGFyZWEge1xuICAgIHJlc2l6ZTogdmVydGljYWw7XG4gIH1cbiAgOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uIHtcbiAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gIH1cbiAgOjotd2Via2l0LWRhdGUtYW5kLXRpbWUtdmFsdWUge1xuICAgIG1pbi1oZWlnaHQ6IDFsaDtcbiAgICB0ZXh0LWFsaWduOiBpbmhlcml0O1xuICB9XG4gIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgfVxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1maWVsZHMtd3JhcHBlciB7XG4gICAgcGFkZGluZzogMDtcbiAgfVxuICA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQteWVhci1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtbW9udGgtZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LWRheS1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtaG91ci1maWVsZCwgOjotd2Via2l0LWRhdGV0aW1lLWVkaXQtbWludXRlLWZpZWxkLCA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1zZWNvbmQtZmllbGQsIDo6LXdlYmtpdC1kYXRldGltZS1lZGl0LW1pbGxpc2Vjb25kLWZpZWxkLCA6Oi13ZWJraXQtZGF0ZXRpbWUtZWRpdC1tZXJpZGllbS1maWVsZCB7XG4gICAgcGFkZGluZy1ibG9jazogMDtcbiAgfVxuICA6LW1vei11aS1pbnZhbGlkIHtcbiAgICBib3gtc2hhZG93OiBub25lO1xuICB9XG4gIGJ1dHRvbiwgaW5wdXQ6d2hlcmUoW3R5cGU9XCJidXR0b25cIl0sIFt0eXBlPVwicmVzZXRcIl0sIFt0eXBlPVwic3VibWl0XCJdKSwgOjpmaWxlLXNlbGVjdG9yLWJ1dHRvbiB7XG4gICAgYXBwZWFyYW5jZTogYnV0dG9uO1xuICB9XG4gIDo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbiwgOjotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uIHtcbiAgICBoZWlnaHQ6IGF1dG87XG4gIH1cbiAgW2hpZGRlbl06d2hlcmUoOm5vdChbaGlkZGVuPVwidW50aWwtZm91bmRcIl0pKSB7XG4gICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICB9XG59XG5AbGF5ZXIgdXRpbGl0aWVzIHtcbiAgLnBvaW50ZXItZXZlbnRzLW5vbmUge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG4gIC5jb2xsYXBzZSB7XG4gICAgdmlzaWJpbGl0eTogY29sbGFwc2U7XG4gIH1cbiAgLnZpc2libGUge1xuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gIH1cbiAgLmFic29sdXRlIHtcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIH1cbiAgLmZpeGVkIHtcbiAgICBwb3NpdGlvbjogZml4ZWQ7XG4gIH1cbiAgLnJlbGF0aXZlIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIH1cbiAgLnN0YXRpYyB7XG4gICAgcG9zaXRpb246IHN0YXRpYztcbiAgfVxuICAuaW5zZXQtMCB7XG4gICAgaW5zZXQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAwKTtcbiAgfVxuICAudG9wLTAge1xuICAgIHRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDApO1xuICB9XG4gIC50b3AtNCB7XG4gICAgdG9wOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLnJpZ2h0LTAge1xuICAgIHJpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMCk7XG4gIH1cbiAgLnJpZ2h0LTQge1xuICAgIHJpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLnotNDAge1xuICAgIHotaW5kZXg6IDQwO1xuICB9XG4gIC56LTUwIHtcbiAgICB6LWluZGV4OiA1MDtcbiAgfVxuICAubS0wIHtcbiAgICBtYXJnaW46IGNhbGModmFyKC0tc3BhY2luZykgKiAwKTtcbiAgfVxuICAubS0xIHtcbiAgICBtYXJnaW46IGNhbGModmFyKC0tc3BhY2luZykgKiAxKTtcbiAgfVxuICAubXgtYXV0byB7XG4gICAgbWFyZ2luLWlubGluZTogYXV0bztcbiAgfVxuICAubXktMSB7XG4gICAgbWFyZ2luLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMSk7XG4gIH1cbiAgLlxcXFwhbXQtNCB7XG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLm10LTIge1xuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc3BhY2luZykgKiAyKTtcbiAgfVxuICAubXQtMyB7XG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDMpO1xuICB9XG4gIC5tdC00IHtcbiAgICBtYXJnaW4tdG9wOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLm10LTYge1xuICAgIG1hcmdpbi10b3A6IGNhbGModmFyKC0tc3BhY2luZykgKiA2KTtcbiAgfVxuICAubXQtOCB7XG4gICAgbWFyZ2luLXRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDgpO1xuICB9XG4gIC5tci00IHtcbiAgICBtYXJnaW4tcmlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KTtcbiAgfVxuICAuXFxcXCFtYi02IHtcbiAgICBtYXJnaW4tYm90dG9tOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNikgIWltcG9ydGFudDtcbiAgfVxuICAubWItMSB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICB9XG4gIC5tYi0xXFxcXC41IHtcbiAgICBtYXJnaW4tYm90dG9tOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMS41KTtcbiAgfVxuICAubWItMiB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpO1xuICB9XG4gIC5tYi0yXFxcXC41IHtcbiAgICBtYXJnaW4tYm90dG9tOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMi41KTtcbiAgfVxuICAubWItMyB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDMpO1xuICB9XG4gIC5tYi00IHtcbiAgICBtYXJnaW4tYm90dG9tOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNCk7XG4gIH1cbiAgLm1iLTYge1xuICAgIG1hcmdpbi1ib3R0b206IGNhbGModmFyKC0tc3BhY2luZykgKiA2KTtcbiAgfVxuICAubWItOCB7XG4gICAgbWFyZ2luLWJvdHRvbTogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDgpO1xuICB9XG4gIC5tbC0yIHtcbiAgICBtYXJnaW4tbGVmdDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpO1xuICB9XG4gIC5saW5lLWNsYW1wLTIge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgZGlzcGxheTogLXdlYmtpdC1ib3g7XG4gICAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcbiAgICAtd2Via2l0LWxpbmUtY2xhbXA6IDI7XG4gIH1cbiAgLmxpbmUtY2xhbXAtMyB7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBkaXNwbGF5OiAtd2Via2l0LWJveDtcbiAgICAtd2Via2l0LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xuICAgIC13ZWJraXQtbGluZS1jbGFtcDogMztcbiAgfVxuICAuXFxcXCFmbGV4IHtcbiAgICBkaXNwbGF5OiBmbGV4ICFpbXBvcnRhbnQ7XG4gIH1cbiAgLlxcXFwhaGlkZGVuIHtcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmJsb2NrIHtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgfVxuICAuY29udGVudHMge1xuICAgIGRpc3BsYXk6IGNvbnRlbnRzO1xuICB9XG4gIC5mbGV4IHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICB9XG4gIC5ncmlkIHtcbiAgICBkaXNwbGF5OiBncmlkO1xuICB9XG4gIC5oaWRkZW4ge1xuICAgIGRpc3BsYXk6IG5vbmU7XG4gIH1cbiAgLmlubGluZS1mbGV4IHtcbiAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgfVxuICAubGlzdC1pdGVtIHtcbiAgICBkaXNwbGF5OiBsaXN0LWl0ZW07XG4gIH1cbiAgLnRhYmxlIHtcbiAgICBkaXNwbGF5OiB0YWJsZTtcbiAgfVxuICAuc2l6ZS0xIHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICB9XG4gIC5cXFxcIWgtMTAge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEwKSAhaW1wb3J0YW50O1xuICB9XG4gIC5oLTEge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICB9XG4gIC5oLTIge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpO1xuICB9XG4gIC5oLTQge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC5oLTUge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDUpO1xuICB9XG4gIC5oLTYge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpO1xuICB9XG4gIC5oLTgge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDgpO1xuICB9XG4gIC5oLTEwIHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiAxMCk7XG4gIH1cbiAgLmgtMTIge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEyKTtcbiAgfVxuICAuaC0yMCB7XG4gICAgaGVpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogMjApO1xuICB9XG4gIC5oLTQ4IHtcbiAgICBoZWlnaHQ6IGNhbGModmFyKC0tc3BhY2luZykgKiA0OCk7XG4gIH1cbiAgLmgtNTYge1xuICAgIGhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDU2KTtcbiAgfVxuICAuaC1cXFxcWzJcXFxcLjg3NXJlbVxcXFxdIHtcbiAgICBoZWlnaHQ6IDIuODc1cmVtO1xuICB9XG4gIC5oLVxcXFxbMTAwcHhcXFxcXSB7XG4gICAgaGVpZ2h0OiAxMDBweDtcbiAgfVxuICAuaC1cXFxcWzE1MHB4XFxcXF0ge1xuICAgIGhlaWdodDogMTUwcHg7XG4gIH1cbiAgLmgtXFxcXFsxcmVtXFxcXF0ge1xuICAgIGhlaWdodDogMXJlbTtcbiAgfVxuICAuaC1mdWxsIHtcbiAgICBoZWlnaHQ6IDEwMCU7XG4gIH1cbiAgLm1heC1oLTU2IHtcbiAgICBtYXgtaGVpZ2h0OiBjYWxjKHZhcigtLXNwYWNpbmcpICogNTYpO1xuICB9XG4gIC5tYXgtaC02NCB7XG4gICAgbWF4LWhlaWdodDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDY0KTtcbiAgfVxuICAubWF4LWgtXFxcXFszMDBweFxcXFxdIHtcbiAgICBtYXgtaGVpZ2h0OiAzMDBweDtcbiAgfVxuICAubWluLWgtXFxcXFsyMHJlbVxcXFxdIHtcbiAgICBtaW4taGVpZ2h0OiAyMHJlbTtcbiAgfVxuICAubWluLWgtc2NyZWVuIHtcbiAgICBtaW4taGVpZ2h0OiAxMDB2aDtcbiAgfVxuICAuXFxcXCF3LTEwIHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEwKSAhaW1wb3J0YW50O1xuICB9XG4gIC53LTEge1xuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMSk7XG4gIH1cbiAgLnctMVxcXFwvNCB7XG4gICAgd2lkdGg6IGNhbGMoMS80ICogMTAwJSk7XG4gIH1cbiAgLnctNCB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KTtcbiAgfVxuICAudy01IHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDUpO1xuICB9XG4gIC53LTYge1xuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNik7XG4gIH1cbiAgLnctOCB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAudy0xMCB7XG4gICAgd2lkdGg6IGNhbGModmFyKC0tc3BhY2luZykgKiAxMCk7XG4gIH1cbiAgLnctMTIge1xuICAgIHdpZHRoOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMTIpO1xuICB9XG4gIC53LTIwIHtcbiAgICB3aWR0aDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIwKTtcbiAgfVxuICAudy1cXFxcWzFcXFxcLjQ1NDU2cmVtXFxcXF0ge1xuICAgIHdpZHRoOiAxLjQ1NDU2cmVtO1xuICB9XG4gIC53LVxcXFxbMlxcXFwuODc1cmVtXFxcXF0ge1xuICAgIHdpZHRoOiAyLjg3NXJlbTtcbiAgfVxuICAudy1cXFxcWzEwMHB4XFxcXF0ge1xuICAgIHdpZHRoOiAxMDBweDtcbiAgfVxuICAudy1mdWxsIHtcbiAgICB3aWR0aDogMTAwJTtcbiAgfVxuICAubWF4LXctNXhsIHtcbiAgICBtYXgtd2lkdGg6IHZhcigtLWNvbnRhaW5lci01eGwpO1xuICB9XG4gIC5tYXgtdy03eGwge1xuICAgIG1heC13aWR0aDogdmFyKC0tY29udGFpbmVyLTd4bCk7XG4gIH1cbiAgLm1heC13LVxcXFxbODAwcHhcXFxcXSB7XG4gICAgbWF4LXdpZHRoOiA4MDBweDtcbiAgfVxuICAubWF4LXctZnVsbCB7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICB9XG4gIC5tYXgtdy1tZCB7XG4gICAgbWF4LXdpZHRoOiB2YXIoLS1jb250YWluZXItbWQpO1xuICB9XG4gIC5taW4tdy1cXFxcWzEyMHB4XFxcXF0ge1xuICAgIG1pbi13aWR0aDogMTIwcHg7XG4gIH1cbiAgLmZsZXgtZ3JvdyB7XG4gICAgZmxleC1ncm93OiAxO1xuICB9XG4gIC5ib3JkZXItY29sbGFwc2Uge1xuICAgIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7XG4gIH1cbiAgLnRyYW5zZm9ybSB7XG4gICAgdHJhbnNmb3JtOiB2YXIoLS10dy1yb3RhdGUteCkgdmFyKC0tdHctcm90YXRlLXkpIHZhcigtLXR3LXJvdGF0ZS16KSB2YXIoLS10dy1za2V3LXgpIHZhcigtLXR3LXNrZXcteSk7XG4gIH1cbiAgLlxcXFwhY3Vyc29yLW5vdC1hbGxvd2VkIHtcbiAgICBjdXJzb3I6IG5vdC1hbGxvd2VkICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmN1cnNvci1ub3QtYWxsb3dlZCB7XG4gICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgfVxuICAuY3Vyc29yLXBvaW50ZXIge1xuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgfVxuICAucmVzaXplIHtcbiAgICByZXNpemU6IGJvdGg7XG4gIH1cbiAgLnJlc2l6ZS15IHtcbiAgICByZXNpemU6IHZlcnRpY2FsO1xuICB9XG4gIC5ncmlkLWNvbHMtMyB7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMywgbWlubWF4KDAsIDFmcikpO1xuICB9XG4gIC5ncmlkLWNvbHMtXFxcXFsxZnJfMmZyXzEwMHB4XFxcXF0ge1xuICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDJmciAxMDBweDtcbiAgfVxuICAuZmxleC1jb2wge1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gIH1cbiAgLmZsZXgtd3JhcCB7XG4gICAgZmxleC13cmFwOiB3cmFwO1xuICB9XG4gIC5cXFxcIWl0ZW1zLWNlbnRlciB7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlciAhaW1wb3J0YW50O1xuICB9XG4gIC5pdGVtcy1jZW50ZXIge1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gIH1cbiAgLlxcXFwhanVzdGlmeS1jZW50ZXIge1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmp1c3RpZnktYmV0d2VlbiB7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICB9XG4gIC5qdXN0aWZ5LWNlbnRlciB7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gIH1cbiAgLlxcXFwhZ2FwLTIge1xuICAgIGdhcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmdhcC0xXFxcXC41IHtcbiAgICBnYXA6IGNhbGModmFyKC0tc3BhY2luZykgKiAxLjUpO1xuICB9XG4gIC5nYXAtMiB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMik7XG4gIH1cbiAgLmdhcC0yXFxcXC41IHtcbiAgICBnYXA6IGNhbGModmFyKC0tc3BhY2luZykgKiAyLjUpO1xuICB9XG4gIC5nYXAtMyB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMyk7XG4gIH1cbiAgLmdhcC00IHtcbiAgICBnYXA6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KTtcbiAgfVxuICAuZ2FwLTUge1xuICAgIGdhcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDUpO1xuICB9XG4gIC5nYXAtNiB7XG4gICAgZ2FwOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNik7XG4gIH1cbiAgLmdhcC04IHtcbiAgICBnYXA6IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAuc3BhY2UteS0xIHtcbiAgICA6d2hlcmUoJiA+IDpub3QoOmxhc3QtY2hpbGQpKSB7XG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcbiAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogY2FsYyhjYWxjKHZhcigtLXNwYWNpbmcpICogMSkgKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xuICAgIH1cbiAgfVxuICAuc3BhY2UteS0yIHtcbiAgICA6d2hlcmUoJiA+IDpub3QoOmxhc3QtY2hpbGQpKSB7XG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcbiAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogY2FsYyhjYWxjKHZhcigtLXNwYWNpbmcpICogMikgKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDIpICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xuICAgIH1cbiAgfVxuICAuc3BhY2UteS00IHtcbiAgICA6d2hlcmUoJiA+IDpub3QoOmxhc3QtY2hpbGQpKSB7XG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcbiAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogY2FsYyhjYWxjKHZhcigtLXNwYWNpbmcpICogNCkgKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xuICAgIH1cbiAgfVxuICAuc3BhY2UteS02IHtcbiAgICA6d2hlcmUoJiA+IDpub3QoOmxhc3QtY2hpbGQpKSB7XG4gICAgICAtLXR3LXNwYWNlLXktcmV2ZXJzZTogMDtcbiAgICAgIG1hcmdpbi1ibG9jay1zdGFydDogY2FsYyhjYWxjKHZhcigtLXNwYWNpbmcpICogNikgKiB2YXIoLS10dy1zcGFjZS15LXJldmVyc2UpKTtcbiAgICAgIG1hcmdpbi1ibG9jay1lbmQ6IGNhbGMoY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpICogY2FsYygxIC0gdmFyKC0tdHctc3BhY2UteS1yZXZlcnNlKSkpO1xuICAgIH1cbiAgfVxuICAuc2VsZi1zdGFydCB7XG4gICAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgfVxuICAub3ZlcmZsb3ctYXV0byB7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gIH1cbiAgLm92ZXJmbG93LWhpZGRlbiB7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgfVxuICAub3ZlcmZsb3cteS1hdXRvIHtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICB9XG4gIC5cXFxcIXJvdW5kZWQtZnVsbCB7XG4gICAgYm9yZGVyLXJhZGl1czogY2FsYyhpbmZpbml0eSAqIDFweCkgIWltcG9ydGFudDtcbiAgfVxuICAucm91bmRlZCB7XG4gICAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbiAgfVxuICAucm91bmRlZC0zeGwge1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy0zeGwpO1xuICB9XG4gIC5yb3VuZGVkLTR4bCB7XG4gICAgYm9yZGVyLXJhZGl1czogdmFyKC0tcmFkaXVzLTR4bCk7XG4gIH1cbiAgLnJvdW5kZWQtZnVsbCB7XG4gICAgYm9yZGVyLXJhZGl1czogY2FsYyhpbmZpbml0eSAqIDFweCk7XG4gIH1cbiAgLnJvdW5kZWQtbGcge1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy1sZyk7XG4gIH1cbiAgLnJvdW5kZWQtbWQge1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy1tZCk7XG4gIH1cbiAgLnJvdW5kZWQteGwge1xuICAgIGJvcmRlci1yYWRpdXM6IHZhcigtLXJhZGl1cy14bCk7XG4gIH1cbiAgLnJvdW5kZWQtbC1tZCB7XG4gICAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogdmFyKC0tcmFkaXVzLW1kKTtcbiAgICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiB2YXIoLS1yYWRpdXMtbWQpO1xuICB9XG4gIC5yb3VuZGVkLXItbWQge1xuICAgIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiB2YXIoLS1yYWRpdXMtbWQpO1xuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiB2YXIoLS1yYWRpdXMtbWQpO1xuICB9XG4gIC5cXFxcIWJvcmRlciB7XG4gICAgYm9yZGVyLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpICFpbXBvcnRhbnQ7XG4gICAgYm9yZGVyLXdpZHRoOiAxcHggIWltcG9ydGFudDtcbiAgfVxuICAuYm9yZGVyIHtcbiAgICBib3JkZXItc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7XG4gIH1cbiAgLmJvcmRlci0wIHtcbiAgICBib3JkZXItc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XG4gICAgYm9yZGVyLXdpZHRoOiAwcHg7XG4gIH1cbiAgLmJvcmRlci0yIHtcbiAgICBib3JkZXItc3R5bGU6IHZhcigtLXR3LWJvcmRlci1zdHlsZSk7XG4gICAgYm9yZGVyLXdpZHRoOiAycHg7XG4gIH1cbiAgLmJvcmRlci10IHtcbiAgICBib3JkZXItdG9wLXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xuICAgIGJvcmRlci10b3Atd2lkdGg6IDFweDtcbiAgfVxuICAuYm9yZGVyLXQtMiB7XG4gICAgYm9yZGVyLXRvcC1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcbiAgICBib3JkZXItdG9wLXdpZHRoOiAycHg7XG4gIH1cbiAgLmJvcmRlci1yLTAge1xuICAgIGJvcmRlci1yaWdodC1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcbiAgICBib3JkZXItcmlnaHQtd2lkdGg6IDBweDtcbiAgfVxuICAuYm9yZGVyLWItMiB7XG4gICAgYm9yZGVyLWJvdHRvbS1zdHlsZTogdmFyKC0tdHctYm9yZGVyLXN0eWxlKTtcbiAgICBib3JkZXItYm90dG9tLXdpZHRoOiAycHg7XG4gIH1cbiAgLmJvcmRlci1sLTQge1xuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiB2YXIoLS10dy1ib3JkZXItc3R5bGUpO1xuICAgIGJvcmRlci1sZWZ0LXdpZHRoOiA0cHg7XG4gIH1cbiAgLmJvcmRlci1kYXNoZWQge1xuICAgIC0tdHctYm9yZGVyLXN0eWxlOiBkYXNoZWQ7XG4gICAgYm9yZGVyLXN0eWxlOiBkYXNoZWQ7XG4gIH1cbiAgLmJvcmRlci1ub25lIHtcbiAgICAtLXR3LWJvcmRlci1zdHlsZTogbm9uZTtcbiAgICBib3JkZXItc3R5bGU6IG5vbmU7XG4gIH1cbiAgLlxcXFwhYm9yZGVyLXdoaXRlIHtcbiAgICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLXdoaXRlKSAhaW1wb3J0YW50O1xuICB9XG4gIC5ib3JkZXItYmx1ZS01MDAge1xuICAgIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItYmx1ZS01MDApO1xuICB9XG4gIC5ib3JkZXItY3VycmVudCB7XG4gICAgYm9yZGVyLWNvbG9yOiBjdXJyZW50Q29sb3I7XG4gIH1cbiAgLmJvcmRlci13aGl0ZSB7XG4gICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSk7XG4gIH1cbiAgLmJvcmRlci13aGl0ZVxcXFwvMjAge1xuICAgIGJvcmRlci1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgMjAlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgLlxcXFwhYmctdHJhbnNwYXJlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gIH1cbiAgLlxcXFwhYmctd2hpdGUge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLXdoaXRlKSAhaW1wb3J0YW50O1xuICB9XG4gIC5iZy1cXFxcW1xcXFwjMWExYTJhXFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICMxYTFhMmE7XG4gIH1cbiAgLmJnLVxcXFxbXFxcXCMwNTEwMjNcXFxcXSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzA1MTAyMztcbiAgfVxuICAuYmctXFxcXFtcXFxcIzA1MTAyM1xcXFxdXFxcXC8yMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCAjMDUxMDIzIDIwJSwgdHJhbnNwYXJlbnQpO1xuICB9XG4gIC5iZy1cXFxcW1xcXFwjZjZmNmY2XFxcXF0ge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNmNmY2ZjY7XG4gIH1cbiAgLmJnLWJsYWNrIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibGFjayk7XG4gIH1cbiAgLmJnLWJsYWNrXFxcXC8yMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci1ibGFjaykgMjAlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgLmJnLWJsdWUtNTAwIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTUwMCk7XG4gIH1cbiAgLmJnLWJsdWUtNTAwXFxcXC8yMCB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci1ibHVlLTUwMCkgMjAlLCB0cmFuc3BhcmVudCk7XG4gIH1cbiAgLmJnLWJsdWUtNjAwIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTYwMCk7XG4gIH1cbiAgLmJnLXByaW1hcnktdHcge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLXByaW1hcnktdHcpO1xuICB9XG4gIC5iZy1yZWQtNTAwIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNTAwKTtcbiAgfVxuICAuYmctdHJhbnNwYXJlbnQge1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICB9XG4gIC5iZy13aGl0ZSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3Itd2hpdGUpO1xuICB9XG4gIC5iZy13aGl0ZVxcXFwvNSB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgNSUsIHRyYW5zcGFyZW50KTtcbiAgfVxuICAuYmctd2hpdGVcXFxcLzEwIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSAxMCUsIHRyYW5zcGFyZW50KTtcbiAgfVxuICAuYmctd2hpdGVcXFxcLzIwIHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSAyMCUsIHRyYW5zcGFyZW50KTtcbiAgfVxuICAub2JqZWN0LWNvbnRhaW4ge1xuICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gIH1cbiAgLm9iamVjdC1jb3ZlciB7XG4gICAgb2JqZWN0LWZpdDogY292ZXI7XG4gIH1cbiAgLlxcXFwhcC0yIHtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMikgIWltcG9ydGFudDtcbiAgfVxuICAucC0xIHtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMSk7XG4gIH1cbiAgLnAtMyB7XG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDMpO1xuICB9XG4gIC5wLTQge1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KTtcbiAgfVxuICAucC01IHtcbiAgICBwYWRkaW5nOiBjYWxjKHZhcigtLXNwYWNpbmcpICogNSk7XG4gIH1cbiAgLnAtNiB7XG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDYpO1xuICB9XG4gIC5wLTgge1xuICAgIHBhZGRpbmc6IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAucC0xMiB7XG4gICAgcGFkZGluZzogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEyKTtcbiAgfVxuICAucHgtMiB7XG4gICAgcGFkZGluZy1pbmxpbmU6IGNhbGModmFyKC0tc3BhY2luZykgKiAyKTtcbiAgfVxuICAucHgtMyB7XG4gICAgcGFkZGluZy1pbmxpbmU6IGNhbGModmFyKC0tc3BhY2luZykgKiAzKTtcbiAgfVxuICAucHgtNCB7XG4gICAgcGFkZGluZy1pbmxpbmU6IGNhbGModmFyKC0tc3BhY2luZykgKiA0KTtcbiAgfVxuICAucHgtNSB7XG4gICAgcGFkZGluZy1pbmxpbmU6IGNhbGModmFyKC0tc3BhY2luZykgKiA1KTtcbiAgfVxuICAucHktMSB7XG4gICAgcGFkZGluZy1ibG9jazogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDEpO1xuICB9XG4gIC5weS0yIHtcbiAgICBwYWRkaW5nLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMik7XG4gIH1cbiAgLnB5LTJcXFxcLjUge1xuICAgIHBhZGRpbmctYmxvY2s6IGNhbGModmFyKC0tc3BhY2luZykgKiAyLjUpO1xuICB9XG4gIC5weS0zIHtcbiAgICBwYWRkaW5nLWJsb2NrOiBjYWxjKHZhcigtLXNwYWNpbmcpICogMyk7XG4gIH1cbiAgLnB5LTgge1xuICAgIHBhZGRpbmctYmxvY2s6IGNhbGModmFyKC0tc3BhY2luZykgKiA4KTtcbiAgfVxuICAucHktMTIge1xuICAgIHBhZGRpbmctYmxvY2s6IGNhbGModmFyKC0tc3BhY2luZykgKiAxMik7XG4gIH1cbiAgLnB5LVxcXFxbMFxcXFwuMTI1cmVtXFxcXF0ge1xuICAgIHBhZGRpbmctYmxvY2s6IDAuMTI1cmVtO1xuICB9XG4gIC5wdC00IHtcbiAgICBwYWRkaW5nLXRvcDogY2FsYyh2YXIoLS1zcGFjaW5nKSAqIDQpO1xuICB9XG4gIC50ZXh0LWNlbnRlciB7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICB9XG4gIC5mb250LW1vbm8ge1xuICAgIGZvbnQtZmFtaWx5OiB2YXIoLS1mb250LW1vbm8pO1xuICB9XG4gIC5cXFxcIXRleHQtc20ge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tdGV4dC1zbSkgIWltcG9ydGFudDtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tdHctbGVhZGluZywgdmFyKC0tdGV4dC1zbS0tbGluZS1oZWlnaHQpKSAhaW1wb3J0YW50O1xuICB9XG4gIC50ZXh0LTJ4bCB7XG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LTJ4bCk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtMnhsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LTN4bCB7XG4gICAgZm9udC1zaXplOiB2YXIoLS10ZXh0LTN4bCk7XG4gICAgbGluZS1oZWlnaHQ6IHZhcigtLXR3LWxlYWRpbmcsIHZhcigtLXRleHQtM3hsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LWJhc2Uge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tdGV4dC1iYXNlKTtcbiAgICBsaW5lLWhlaWdodDogdmFyKC0tdHctbGVhZGluZywgdmFyKC0tdGV4dC1iYXNlLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LWxnIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQtbGcpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LWxnLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LXNtIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQtc20pO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXNtLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LXhsIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQteGwpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXhsLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LXhzIHtcbiAgICBmb250LXNpemU6IHZhcigtLXRleHQteHMpO1xuICAgIGxpbmUtaGVpZ2h0OiB2YXIoLS10dy1sZWFkaW5nLCB2YXIoLS10ZXh0LXhzLS1saW5lLWhlaWdodCkpO1xuICB9XG4gIC50ZXh0LVxcXFxbMFxcXFwuODc1cmVtXFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMC44NzVyZW07XG4gIH1cbiAgLnRleHQtXFxcXFsxXFxcXC4yNXJlbVxcXFxdIHtcbiAgICBmb250LXNpemU6IDEuMjVyZW07XG4gIH1cbiAgLnRleHQtXFxcXFsycmVtXFxcXF0ge1xuICAgIGZvbnQtc2l6ZTogMnJlbTtcbiAgfVxuICAuXFxcXCFmb250LWJvbGQge1xuICAgIC0tdHctZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpICFpbXBvcnRhbnQ7XG4gICAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmZvbnQtYm9sZCB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtYm9sZCk7XG4gICAgZm9udC13ZWlnaHQ6IHZhcigtLWZvbnQtd2VpZ2h0LWJvbGQpO1xuICB9XG4gIC5mb250LW1lZGl1bSB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtbWVkaXVtKTtcbiAgICBmb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtbWVkaXVtKTtcbiAgfVxuICAuZm9udC1zZW1pYm9sZCB7XG4gICAgLS10dy1mb250LXdlaWdodDogdmFyKC0tZm9udC13ZWlnaHQtc2VtaWJvbGQpO1xuICAgIGZvbnQtd2VpZ2h0OiB2YXIoLS1mb250LXdlaWdodC1zZW1pYm9sZCk7XG4gIH1cbiAgLmJyZWFrLWFsbCB7XG4gICAgd29yZC1icmVhazogYnJlYWstYWxsO1xuICB9XG4gIC50ZXh0LWVsbGlwc2lzIHtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgfVxuICAud2hpdGVzcGFjZS1wcmUtd3JhcCB7XG4gICAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB9XG4gIC5cXFxcIXRleHQtbGlnaHQge1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1saWdodCkgIWltcG9ydGFudDtcbiAgfVxuICAuXFxcXCF0ZXh0LXByaW1hcnktdHcge1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1wcmltYXJ5LXR3KSAhaW1wb3J0YW50O1xuICB9XG4gIC5cXFxcIXRleHQtd2hpdGUge1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSkgIWltcG9ydGFudDtcbiAgfVxuICAuXFxcXCF0ZXh0LXdoaXRlXFxcXC84MCB7XG4gICAgY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDgwJSwgdHJhbnNwYXJlbnQpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLnRleHQtXFxcXFtcXFxcI0MzRDVGN1xcXFxdIHtcbiAgICBjb2xvcjogI0MzRDVGNztcbiAgfVxuICAudGV4dC1ibHVlLTQwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNDAwKTtcbiAgfVxuICAudGV4dC1ibHVlLTUwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWJsdWUtNTAwKTtcbiAgfVxuICAudGV4dC1ncmF5LTEwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMTAwKTtcbiAgfVxuICAudGV4dC1ncmF5LTIwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktMjAwKTtcbiAgfVxuICAudGV4dC1ncmF5LTUwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWdyYXktNTAwKTtcbiAgfVxuICAudGV4dC1saWdodCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLWxpZ2h0KTtcbiAgfVxuICAudGV4dC1yZWQtNDAwIHtcbiAgICBjb2xvcjogdmFyKC0tY29sb3ItcmVkLTQwMCk7XG4gIH1cbiAgLnRleHQtcmVkLTUwMCB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXJlZC01MDApO1xuICB9XG4gIC50ZXh0LXJlZC02MDAge1xuICAgIGNvbG9yOiB2YXIoLS1jb2xvci1yZWQtNjAwKTtcbiAgfVxuICAudGV4dC13aGl0ZSB7XG4gICAgY29sb3I6IHZhcigtLWNvbG9yLXdoaXRlKTtcbiAgfVxuICAudGV4dC13aGl0ZVxcXFwvNjAge1xuICAgIGNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSA2MCUsIHRyYW5zcGFyZW50KTtcbiAgfVxuICAudGV4dC13aGl0ZVxcXFwvODAge1xuICAgIGNvbG9yOiBjb2xvci1taXgoaW4gb2tsYWIsIHZhcigtLWNvbG9yLXdoaXRlKSA4MCUsIHRyYW5zcGFyZW50KTtcbiAgfVxuICAuaXRhbGljIHtcbiAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gIH1cbiAgLnVuZGVybGluZSB7XG4gICAgdGV4dC1kZWNvcmF0aW9uLWxpbmU6IHVuZGVybGluZTtcbiAgfVxuICAuXFxcXCFvcGFjaXR5LTUwIHtcbiAgICBvcGFjaXR5OiA1MCUgIWltcG9ydGFudDtcbiAgfVxuICAub3BhY2l0eS0wIHtcbiAgICBvcGFjaXR5OiAwJTtcbiAgfVxuICAuc2hhZG93LWxnIHtcbiAgICAtLXR3LXNoYWRvdzogMCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpLCAwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpO1xuICAgIGJveC1zaGFkb3c6IHZhcigtLXR3LWluc2V0LXNoYWRvdyksIHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSwgdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3cpO1xuICB9XG4gIC5vdXRsaW5lIHtcbiAgICBvdXRsaW5lLXN0eWxlOiB2YXIoLS10dy1vdXRsaW5lLXN0eWxlKTtcbiAgICBvdXRsaW5lLXdpZHRoOiAxcHg7XG4gIH1cbiAgLmJsdXIge1xuICAgIC0tdHctYmx1cjogYmx1cig4cHgpO1xuICAgIGZpbHRlcjogdmFyKC0tdHctYmx1ciwpIHZhcigtLXR3LWJyaWdodG5lc3MsKSB2YXIoLS10dy1jb250cmFzdCwpIHZhcigtLXR3LWdyYXlzY2FsZSwpIHZhcigtLXR3LWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1pbnZlcnQsKSB2YXIoLS10dy1zYXR1cmF0ZSwpIHZhcigtLXR3LXNlcGlhLCkgdmFyKC0tdHctZHJvcC1zaGFkb3csKTtcbiAgfVxuICAuZHJvcC1zaGFkb3cge1xuICAgIC0tdHctZHJvcC1zaGFkb3c6IGRyb3Atc2hhZG93KDAgMXB4IDJweCByZ2IoMCAwIDAgLyAwLjEpKSBkcm9wLXNoYWRvdyggMCAxcHggMXB4IHJnYigwIDAgMCAvIDAuMDYpKTtcbiAgICBmaWx0ZXI6IHZhcigtLXR3LWJsdXIsKSB2YXIoLS10dy1icmlnaHRuZXNzLCkgdmFyKC0tdHctY29udHJhc3QsKSB2YXIoLS10dy1ncmF5c2NhbGUsKSB2YXIoLS10dy1odWUtcm90YXRlLCkgdmFyKC0tdHctaW52ZXJ0LCkgdmFyKC0tdHctc2F0dXJhdGUsKSB2YXIoLS10dy1zZXBpYSwpIHZhcigtLXR3LWRyb3Atc2hhZG93LCk7XG4gIH1cbiAgLmZpbHRlciB7XG4gICAgZmlsdGVyOiB2YXIoLS10dy1ibHVyLCkgdmFyKC0tdHctYnJpZ2h0bmVzcywpIHZhcigtLXR3LWNvbnRyYXN0LCkgdmFyKC0tdHctZ3JheXNjYWxlLCkgdmFyKC0tdHctaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWludmVydCwpIHZhcigtLXR3LXNhdHVyYXRlLCkgdmFyKC0tdHctc2VwaWEsKSB2YXIoLS10dy1kcm9wLXNoYWRvdywpO1xuICB9XG4gIC5iYWNrZHJvcC1ibHVyLVxcXFxbMnB4XFxcXF0ge1xuICAgIC0tdHctYmFja2Ryb3AtYmx1cjogYmx1cigycHgpO1xuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XG4gIH1cbiAgLmJhY2tkcm9wLWJsdXItXFxcXFsxMHB4XFxcXF0ge1xuICAgIC0tdHctYmFja2Ryb3AtYmx1cjogYmx1cigxMHB4KTtcbiAgICAtd2Via2l0LWJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xuICAgIGJhY2tkcm9wLWZpbHRlcjogdmFyKC0tdHctYmFja2Ryb3AtYmx1ciwpIHZhcigtLXR3LWJhY2tkcm9wLWJyaWdodG5lc3MsKSB2YXIoLS10dy1iYWNrZHJvcC1jb250cmFzdCwpIHZhcigtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZSwpIHZhcigtLXR3LWJhY2tkcm9wLWh1ZS1yb3RhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1pbnZlcnQsKSB2YXIoLS10dy1iYWNrZHJvcC1vcGFjaXR5LCkgdmFyKC0tdHctYmFja2Ryb3Atc2F0dXJhdGUsKSB2YXIoLS10dy1iYWNrZHJvcC1zZXBpYSwpO1xuICB9XG4gIC5iYWNrZHJvcC1ibHVyLXhsIHtcbiAgICAtLXR3LWJhY2tkcm9wLWJsdXI6IGJsdXIodmFyKC0tYmx1ci14bCkpO1xuICAgIC13ZWJraXQtYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiB2YXIoLS10dy1iYWNrZHJvcC1ibHVyLCkgdmFyKC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzcywpIHZhcigtLXR3LWJhY2tkcm9wLWNvbnRyYXN0LCkgdmFyKC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlLCkgdmFyKC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLWludmVydCwpIHZhcigtLXR3LWJhY2tkcm9wLW9wYWNpdHksKSB2YXIoLS10dy1iYWNrZHJvcC1zYXR1cmF0ZSwpIHZhcigtLXR3LWJhY2tkcm9wLXNlcGlhLCk7XG4gIH1cbiAgLmJhY2tkcm9wLWZpbHRlciB7XG4gICAgLXdlYmtpdC1iYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIsKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzLCkgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUsKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlLCkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSwpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlLCkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IHZhcigtLXR3LWJhY2tkcm9wLWJsdXIsKSB2YXIoLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzLCkgdmFyKC0tdHctYmFja2Ryb3AtY29udHJhc3QsKSB2YXIoLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUsKSB2YXIoLS10dy1iYWNrZHJvcC1odWUtcm90YXRlLCkgdmFyKC0tdHctYmFja2Ryb3AtaW52ZXJ0LCkgdmFyKC0tdHctYmFja2Ryb3Atb3BhY2l0eSwpIHZhcigtLXR3LWJhY2tkcm9wLXNhdHVyYXRlLCkgdmFyKC0tdHctYmFja2Ryb3Atc2VwaWEsKTtcbiAgfVxuICAuXFxcXCF0cmFuc2l0aW9uLWNvbG9ycyB7XG4gICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgb3V0bGluZS1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIC0tdHctZ3JhZGllbnQtZnJvbSwgLS10dy1ncmFkaWVudC12aWEsIC0tdHctZ3JhZGllbnQtdG8gIWltcG9ydGFudDtcbiAgICB0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjogdmFyKC0tdHctZWFzZSwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbikpICFpbXBvcnRhbnQ7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHctZHVyYXRpb24sIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpICFpbXBvcnRhbnQ7XG4gIH1cbiAgLnRyYW5zaXRpb24ge1xuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IGNvbG9yLCBiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXItY29sb3IsIG91dGxpbmUtY29sb3IsIHRleHQtZGVjb3JhdGlvbi1jb2xvciwgZmlsbCwgc3Ryb2tlLCAtLXR3LWdyYWRpZW50LWZyb20sIC0tdHctZ3JhZGllbnQtdmlhLCAtLXR3LWdyYWRpZW50LXRvLCBvcGFjaXR5LCBib3gtc2hhZG93LCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZSwgc2NhbGUsIHJvdGF0ZSwgZmlsdGVyLCAtd2Via2l0LWJhY2tkcm9wLWZpbHRlciwgYmFja2Ryb3AtZmlsdGVyO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS10dy1lYXNlLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSk7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHctZHVyYXRpb24sIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpO1xuICB9XG4gIC50cmFuc2l0aW9uLWFsbCB7XG4gICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogYWxsO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS10dy1lYXNlLCB2YXIoLS1kZWZhdWx0LXRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uKSk7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogdmFyKC0tdHctZHVyYXRpb24sIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi1kdXJhdGlvbikpO1xuICB9XG4gIC50cmFuc2l0aW9uLWNvbG9ycyB7XG4gICAgdHJhbnNpdGlvbi1wcm9wZXJ0eTogY29sb3IsIGJhY2tncm91bmQtY29sb3IsIGJvcmRlci1jb2xvciwgb3V0bGluZS1jb2xvciwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBmaWxsLCBzdHJva2UsIC0tdHctZ3JhZGllbnQtZnJvbSwgLS10dy1ncmFkaWVudC12aWEsIC0tdHctZ3JhZGllbnQtdG87XG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLXR3LWVhc2UsIHZhcigtLWRlZmF1bHQtdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24pKTtcbiAgICB0cmFuc2l0aW9uLWR1cmF0aW9uOiB2YXIoLS10dy1kdXJhdGlvbiwgdmFyKC0tZGVmYXVsdC10cmFuc2l0aW9uLWR1cmF0aW9uKSk7XG4gIH1cbiAgLlxcXFwhZHVyYXRpb24tMzAwIHtcbiAgICAtLXR3LWR1cmF0aW9uOiAzMDBtcyAhaW1wb3J0YW50O1xuICAgIHRyYW5zaXRpb24tZHVyYXRpb246IDMwMG1zICFpbXBvcnRhbnQ7XG4gIH1cbiAgLmR1cmF0aW9uLTIwMCB7XG4gICAgLS10dy1kdXJhdGlvbjogMjAwbXM7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMjAwbXM7XG4gIH1cbiAgLmR1cmF0aW9uLTMwMCB7XG4gICAgLS10dy1kdXJhdGlvbjogMzAwbXM7XG4gICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMzAwbXM7XG4gIH1cbiAgLmVhc2UtaW4ge1xuICAgIC0tdHctZWFzZTogdmFyKC0tZWFzZS1pbik7XG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLWVhc2UtaW4pO1xuICB9XG4gIC5lYXNlLWluLW91dCB7XG4gICAgLS10dy1lYXNlOiB2YXIoLS1lYXNlLWluLW91dCk7XG4gICAgdHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246IHZhcigtLWVhc2UtaW4tb3V0KTtcbiAgfVxuICAuZWFzZS1vdXQge1xuICAgIC0tdHctZWFzZTogdmFyKC0tZWFzZS1vdXQpO1xuICAgIHRyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOiB2YXIoLS1lYXNlLW91dCk7XG4gIH1cbiAgLnBsYWNlaG9sZGVyXFxcXDp0ZXh0LXdoaXRlXFxcXC80MCB7XG4gICAgJjo6cGxhY2Vob2xkZXIge1xuICAgICAgY29sb3I6IGNvbG9yLW1peChpbiBva2xhYiwgdmFyKC0tY29sb3Itd2hpdGUpIDQwJSwgdHJhbnNwYXJlbnQpO1xuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOi10cmFuc2xhdGUteS0wXFxcXC41IHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIC0tdHctdHJhbnNsYXRlLXk6IGNhbGModmFyKC0tc3BhY2luZykgKiAtMC41KTtcbiAgICAgICAgdHJhbnNsYXRlOiB2YXIoLS10dy10cmFuc2xhdGUteCkgdmFyKC0tdHctdHJhbnNsYXRlLXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOi10cmFuc2xhdGUteS0xXFxcXC41IHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIC0tdHctdHJhbnNsYXRlLXk6IGNhbGModmFyKC0tc3BhY2luZykgKiAtMS41KTtcbiAgICAgICAgdHJhbnNsYXRlOiB2YXIoLS10dy10cmFuc2xhdGUteCkgdmFyKC0tdHctdHJhbnNsYXRlLXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOnRyYW5zZm9ybSB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICB0cmFuc2Zvcm06IHZhcigtLXR3LXJvdGF0ZS14KSB2YXIoLS10dy1yb3RhdGUteSkgdmFyKC0tdHctcm90YXRlLXopIHZhcigtLXR3LXNrZXcteCkgdmFyKC0tdHctc2tldy15KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDpcXFxcIWJnLXRyYW5zcGFyZW50IHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6XFxcXCFiZy13aGl0ZVxcXFwvMTAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgMTAlLCB0cmFuc3BhcmVudCkgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDpiZy1ibHVlLTcwMCB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTcwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6YmctcmVkLTUwMFxcXFwvMTAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci1yZWQtNTAwKSAxMCUsIHRyYW5zcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDpiZy13aGl0ZVxcXFwvMTAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogY29sb3ItbWl4KGluIG9rbGFiLCB2YXIoLS1jb2xvci13aGl0ZSkgMTAlLCB0cmFuc3BhcmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6XFxcXCF0ZXh0LXdoaXRlIHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci13aGl0ZSkgIWltcG9ydGFudDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmhvdmVyXFxcXDp0ZXh0LWJsdWUtMzAwIHtcbiAgICAmOmhvdmVyIHtcbiAgICAgIEBtZWRpYSAoaG92ZXI6IGhvdmVyKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTMwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC5ob3ZlclxcXFw6dGV4dC1ncmF5LTIwMCB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICBjb2xvcjogdmFyKC0tY29sb3ItZ3JheS0yMDApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOm9wYWNpdHktODAge1xuICAgICY6aG92ZXIge1xuICAgICAgQG1lZGlhIChob3ZlcjogaG92ZXIpIHtcbiAgICAgICAgb3BhY2l0eTogODAlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAuaG92ZXJcXFxcOnNoYWRvdy1sZyB7XG4gICAgJjpob3ZlciB7XG4gICAgICBAbWVkaWEgKGhvdmVyOiBob3Zlcikge1xuICAgICAgICAtLXR3LXNoYWRvdzogMCAxMHB4IDE1cHggLTNweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpLCAwIDRweCA2cHggLTRweCB2YXIoLS10dy1zaGFkb3ctY29sb3IsIHJnYigwIDAgMCAvIDAuMSkpO1xuICAgICAgICBib3gtc2hhZG93OiB2YXIoLS10dy1pbnNldC1zaGFkb3cpLCB2YXIoLS10dy1pbnNldC1yaW5nLXNoYWRvdyksIHZhcigtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdyksIHZhcigtLXR3LXJpbmctc2hhZG93KSwgdmFyKC0tdHctc2hhZG93KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLmZvY3VzXFxcXDpib3JkZXItYmx1ZS00MDAge1xuICAgICY6Zm9jdXMge1xuICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1jb2xvci1ibHVlLTQwMCk7XG4gICAgfVxuICB9XG4gIC5mb2N1c1xcXFw6cmluZy0yIHtcbiAgICAmOmZvY3VzIHtcbiAgICAgIC0tdHctcmluZy1zaGFkb3c6IHZhcigtLXR3LXJpbmctaW5zZXQsKSAwIDAgMCBjYWxjKDJweCArIHZhcigtLXR3LXJpbmctb2Zmc2V0LXdpZHRoKSkgdmFyKC0tdHctcmluZy1jb2xvciwgY3VycmVudENvbG9yKTtcbiAgICAgIGJveC1zaGFkb3c6IHZhcigtLXR3LWluc2V0LXNoYWRvdyksIHZhcigtLXR3LWluc2V0LXJpbmctc2hhZG93KSwgdmFyKC0tdHctcmluZy1vZmZzZXQtc2hhZG93KSwgdmFyKC0tdHctcmluZy1zaGFkb3cpLCB2YXIoLS10dy1zaGFkb3cpO1xuICAgIH1cbiAgfVxuICAuZm9jdXNcXFxcOnJpbmctXFxcXFtcXFxcIzQ0N0JGNFxcXFxdIHtcbiAgICAmOmZvY3VzIHtcbiAgICAgIC0tdHctcmluZy1jb2xvcjogIzQ0N0JGNDtcbiAgICB9XG4gIH1cbiAgLmZvY3VzXFxcXDpvdXRsaW5lLW5vbmUge1xuICAgICY6Zm9jdXMge1xuICAgICAgLS10dy1vdXRsaW5lLXN0eWxlOiBub25lO1xuICAgICAgb3V0bGluZS1zdHlsZTogbm9uZTtcbiAgICB9XG4gIH1cbiAgLmRpc2FibGVkXFxcXDpjdXJzb3Itbm90LWFsbG93ZWQge1xuICAgICY6ZGlzYWJsZWQge1xuICAgICAgY3Vyc29yOiBub3QtYWxsb3dlZDtcbiAgICB9XG4gIH1cbiAgLmRpc2FibGVkXFxcXDpvcGFjaXR5LTUwIHtcbiAgICAmOmRpc2FibGVkIHtcbiAgICAgIG9wYWNpdHk6IDUwJTtcbiAgICB9XG4gIH1cbiAgLnNtXFxcXDpncmlkLWNvbHMtMSB7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0MHJlbSkge1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMSwgbWlubWF4KDAsIDFmcikpO1xuICAgIH1cbiAgfVxuICAubWRcXFxcOm9yZGVyLWZpcnN0IHtcbiAgICBAbWVkaWEgKHdpZHRoID49IDQ4cmVtKSB7XG4gICAgICBvcmRlcjogY2FsYygtaW5maW5pdHkpO1xuICAgIH1cbiAgfVxuICAubWRcXFxcOmgtXFxcXFsxNTBweFxcXFxdIHtcbiAgICBAbWVkaWEgKHdpZHRoID49IDQ4cmVtKSB7XG4gICAgICBoZWlnaHQ6IDE1MHB4O1xuICAgIH1cbiAgfVxuICAubWRcXFxcOnctZnVsbCB7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0OHJlbSkge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuICB9XG4gIC5tZFxcXFw6Z3JpZC1jb2xzLTEge1xuICAgIEBtZWRpYSAod2lkdGggPj0gNDhyZW0pIHtcbiAgICAgIGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KDEsIG1pbm1heCgwLCAxZnIpKTtcbiAgICB9XG4gIH1cbiAgLm1kXFxcXDpncmlkLWNvbHMtMiB7XG4gICAgQG1lZGlhICh3aWR0aCA+PSA0OHJlbSkge1xuICAgICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoMiwgbWlubWF4KDAsIDFmcikpO1xuICAgIH1cbiAgfVxuICAubWRcXFxcOmdyaWQtcm93cy1cXFxcW2F1dG9fYXV0b19hdXRvXFxcXF0ge1xuICAgIEBtZWRpYSAod2lkdGggPj0gNDhyZW0pIHtcbiAgICAgIGdyaWQtdGVtcGxhdGUtcm93czogYXV0byBhdXRvIGF1dG87XG4gICAgfVxuICB9XG59XG5AbGF5ZXIgYmFzZSB7XG4gIDpyb290IHtcbiAgICAtLXR3LWltcG9ydGFudDogICAhaW1wb3J0YW50O1xuICB9XG59XG5Aa2V5ZnJhbWVzIHNwaW4ge1xuICB0byB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgfVxufVxuQGtleWZyYW1lcyBwaW5nIHtcbiAgNzUlLCAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHNjYWxlKDIpO1xuICAgIG9wYWNpdHk6IDA7XG4gIH1cbn1cbkBrZXlmcmFtZXMgcHVsc2Uge1xuICA1MCUge1xuICAgIG9wYWNpdHk6IDAuNTtcbiAgfVxufVxuQGtleWZyYW1lcyBib3VuY2Uge1xuICAwJSwgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC0yNSUpO1xuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLjgsIDAsIDEsIDEpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiBub25lO1xuICAgIGFuaW1hdGlvbi10aW1pbmctZnVuY3Rpb246IGN1YmljLWJlemllcigwLCAwLCAwLjIsIDEpO1xuICB9XG59XG5AcHJvcGVydHkgLS10dy1yb3RhdGUteCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogcm90YXRlWCgwKTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXJvdGF0ZS15IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiByb3RhdGVZKDApO1xufVxuQHByb3BlcnR5IC0tdHctcm90YXRlLXoge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IHJvdGF0ZVooMCk7XG59XG5AcHJvcGVydHkgLS10dy1za2V3LXgge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IHNrZXdYKDApO1xufVxuQHByb3BlcnR5IC0tdHctc2tldy15IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiBza2V3WSgwKTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXNwYWNlLXktcmV2ZXJzZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJvcmRlci1zdHlsZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogc29saWQ7XG59XG5AcHJvcGVydHkgLS10dy1mb250LXdlaWdodCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXNoYWRvdyB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMCAwICMwMDAwO1xufVxuQHByb3BlcnR5IC0tdHctc2hhZG93LWNvbG9yIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctaW5zZXQtc2hhZG93IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAwIDAgIzAwMDA7XG59XG5AcHJvcGVydHkgLS10dy1pbnNldC1zaGFkb3ctY29sb3Ige1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1yaW5nLWNvbG9yIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctcmluZy1zaGFkb3cge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LWluc2V0LXJpbmctY29sb3Ige1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1pbnNldC1yaW5nLXNoYWRvdyB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMCAwICMwMDAwO1xufVxuQHByb3BlcnR5IC0tdHctcmluZy1pbnNldCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoIHtcbiAgc3ludGF4OiBcIjxsZW5ndGg+XCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMHB4O1xufVxuQHByb3BlcnR5IC0tdHctcmluZy1vZmZzZXQtY29sb3Ige1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6ICNmZmY7XG59XG5AcHJvcGVydHkgLS10dy1yaW5nLW9mZnNldC1zaGFkb3cge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDAgMCAjMDAwMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LW91dGxpbmUtc3R5bGUge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IHNvbGlkO1xufVxuQHByb3BlcnR5IC0tdHctYmx1ciB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJyaWdodG5lc3Mge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1jb250cmFzdCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWdyYXlzY2FsZSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWh1ZS1yb3RhdGUge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1pbnZlcnQge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1vcGFjaXR5IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctc2F0dXJhdGUge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1zZXBpYSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLWJsdXIge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtY29udHJhc3Qge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1ncmF5c2NhbGUge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3AtaW52ZXJ0IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3Atb3BhY2l0eSB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlIHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xufVxuQHByb3BlcnR5IC0tdHctYmFja2Ryb3Atc2VwaWEge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy1kdXJhdGlvbiB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbn1cbkBwcm9wZXJ0eSAtLXR3LWVhc2Uge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG59XG5AcHJvcGVydHkgLS10dy10cmFuc2xhdGUteCB7XG4gIHN5bnRheDogXCIqXCI7XG4gIGluaGVyaXRzOiBmYWxzZTtcbiAgaW5pdGlhbC12YWx1ZTogMDtcbn1cbkBwcm9wZXJ0eSAtLXR3LXRyYW5zbGF0ZS15IHtcbiAgc3ludGF4OiBcIipcIjtcbiAgaW5oZXJpdHM6IGZhbHNlO1xuICBpbml0aWFsLXZhbHVlOiAwO1xufVxuQHByb3BlcnR5IC0tdHctdHJhbnNsYXRlLXoge1xuICBzeW50YXg6IFwiKlwiO1xuICBpbmhlcml0czogZmFsc2U7XG4gIGluaXRpYWwtdmFsdWU6IDA7XG59XG5gLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly8uL3NyYy9zdHlsZXMuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLGdFQVlBO0FBWkEseUNBWUE7QUFaQTtFQUFBO0lBQUE7NkRBWUE7SUFaQSx5RUFZQTtJQVpBO2lEQVlBO0lBWkEsd0NBWUE7SUFaQSwwQ0FZQTtJQVpBLDBDQVlBO0lBWkEsMENBWUE7SUFaQSwwQ0FZQTtJQVpBLDBDQVlBO0lBWkEsMENBWUE7SUFaQSwwQ0FZQTtJQVpBLDBDQVlBO0lBWkEsMENBWUE7SUFaQSwwQ0FZQTtJQVpBLDJDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSwyQ0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNkNBWUE7SUFaQSw4Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDJDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSwyQ0FZQTtJQVpBLDBDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLDhDQVlBO0lBWkEsK0NBWUE7SUFaQSwrQ0FZQTtJQVpBLDZDQVlBO0lBWkEsK0NBWUE7SUFaQSwrQ0FZQTtJQVpBLCtDQVlBO0lBWkEsOENBWUE7SUFaQSwrQ0FZQTtJQVpBLDBDQVlBO0lBWkEsNENBWUE7SUFaQSwyQ0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSwyQ0FZQTtJQVpBLDBDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSwyQ0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDJDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDJDQVlBO0lBWkEsMkNBWUE7SUFaQSwyQ0FZQTtJQVpBLDRDQVlBO0lBWkEseUNBWUE7SUFaQSwyQ0FZQTtJQVpBLDJDQVlBO0lBWkEsMkNBWUE7SUFaQSwwQ0FZQTtJQVpBLDJDQVlBO0lBWkEsMkNBWUE7SUFaQSx5Q0FZQTtJQVpBLHlDQVlBO0lBWkEsMENBWUE7SUFaQSwyQ0FZQTtJQVpBLDBDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw4Q0FZQTtJQVpBLDhDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLDZDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw4Q0FZQTtJQVpBLDhDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLDZDQVlBO0lBWkEsOENBWUE7SUFaQSw2Q0FZQTtJQVpBLDhDQVlBO0lBWkEsNkNBWUE7SUFaQSw4Q0FZQTtJQVpBLDZDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLDhDQVlBO0lBWkEsOENBWUE7SUFaQSw0Q0FZQTtJQVpBLDhDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLDhDQVlBO0lBWkEsOENBWUE7SUFaQSw4Q0FZQTtJQVpBLCtDQVlBO0lBWkEsOENBWUE7SUFaQSwrQ0FZQTtJQVpBLDZDQVlBO0lBWkEsOENBWUE7SUFaQSwrQ0FZQTtJQVpBLCtDQVlBO0lBWkEsK0NBWUE7SUFaQSw4Q0FZQTtJQVpBLCtDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMENBWUE7SUFaQSwwQ0FZQTtJQVpBLDBDQVlBO0lBWkEsMENBWUE7SUFaQSwwQ0FZQTtJQVpBLDBDQVlBO0lBWkEseUNBWUE7SUFaQSwyQ0FZQTtJQVpBLDBDQVlBO0lBWkEsMkNBWUE7SUFaQSwyQ0FZQTtJQVpBLDJDQVlBO0lBWkEsMkNBWUE7SUFaQSwyQ0FZQTtJQVpBLDBDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsNkNBWUE7SUFaQSw2Q0FZQTtJQVpBLDZDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSwyQ0FZQTtJQVpBLGlDQVlBO0lBWkEsNENBWUE7SUFaQSwwQ0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsMkNBWUE7SUFaQSw0Q0FZQTtJQVpBLDJDQVlBO0lBWkEsNENBWUE7SUFaQSxvQ0FZQTtJQVpBLG9DQVlBO0lBWkEscUNBWUE7SUFaQSxvQ0FZQTtJQVpBLHFDQVlBO0lBWkEscUNBWUE7SUFaQSxxQ0FZQTtJQVpBLHFDQVlBO0lBWkEscUNBWUE7SUFaQSxxQ0FZQTtJQVpBLHFDQVlBO0lBWkEsNENBWUE7SUFaQSw0Q0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSwyQ0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSwyQ0FZQTtJQVpBLDRDQVlBO0lBWkEsNENBWUE7SUFaQSwyQ0FZQTtJQVpBLG1CQVlBO0lBWkEsbUJBWUE7SUFaQSxrQkFZQTtJQVpBLHNCQVlBO0lBWkEsc0JBWUE7SUFaQSxzQkFZQTtJQVpBLHNCQVlBO0lBWkEsdUJBWUE7SUFaQSxzQkFZQTtJQVpBLHNCQVlBO0lBWkEscUJBWUE7SUFaQSxxQkFZQTtJQVpBLHFCQVlBO0lBWkEscUJBWUE7SUFaQSxxQkFZQTtJQVpBLHNCQVlBO0lBWkEsc0JBWUE7SUFaQSxzQkFZQTtJQVpBLHNCQVlBO0lBWkEsc0JBWUE7SUFaQSxzQkFZQTtJQVpBLGtCQVlBO0lBWkEsc0NBWUE7SUFaQSxtQkFZQTtJQVpBLDBDQVlBO0lBWkEsaUJBWUE7SUFaQSx1Q0FZQTtJQVpBLG1CQVlBO0lBWkEsMENBWUE7SUFaQSxrQkFZQTtJQVpBLHlDQVlBO0lBWkEsa0JBWUE7SUFaQSxzQ0FZQTtJQVpBLG9CQVlBO0lBWkEsMkNBWUE7SUFaQSxtQkFZQTtJQVpBLHlDQVlBO0lBWkEsZ0JBWUE7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QkFZQTtFQUFBO0VBWkE7SUFBQSx3QkFZQTtFQUFBO0VBWkE7SUFBQSxlQVlBO0lBWkEsbUJBWUE7RUFBQTtFQVpBO0lBQUEsb0JBWUE7RUFBQTtFQVpBO0lBQUEsVUFZQTtFQUFBO0VBWkE7SUFBQSxnQkFZQTtFQUFBO0VBWkE7SUFBQSxnQkFZQTtFQUFBO0VBWkE7SUFBQSxrQkFZQTtFQUFBO0VBWkE7SUFBQSxZQVlBO0VBQUE7RUFaQTtJQUFBLHdCQVlBO0VBQUE7QUFBQTtBQVpBO0VBQUE7SUFBQSxvQkFZQTtFQUFBO0VBWkE7SUFBQSxvQkFZQTtFQUFBO0VBWkE7SUFBQSxtQkFZQTtFQUFBO0VBWkE7SUFBQSxrQkFZQTtFQUFBO0VBWkE7SUFBQSxlQVlBO0VBQUE7RUFaQTtJQUFBLGtCQVlBO0VBQUE7RUFaQTtJQUFBLGdCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLDZCQVlBO0VBQUE7RUFaQTtJQUFBLDZCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLFdBWUE7RUFBQTtFQVpBO0lBQUEsV0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxtQkFZQTtFQUFBO0VBWkE7SUFBQSxzQ0FZQTtFQUFBO0VBWkE7SUFBQSwrQ0FZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSxzQ0FZQTtFQUFBO0VBWkE7SUFBQSxrREFZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx5Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx5Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSxxQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQkFZQTtJQVpBLG9CQVlBO0lBWkEsNEJBWUE7SUFaQSxxQkFZQTtFQUFBO0VBWkE7SUFBQSxnQkFZQTtJQVpBLG9CQVlBO0lBWkEsNEJBWUE7SUFaQSxxQkFZQTtFQUFBO0VBWkE7SUFBQSx3QkFZQTtFQUFBO0VBWkE7SUFBQSx3QkFZQTtFQUFBO0VBWkE7SUFBQSxjQVlBO0VBQUE7RUFaQTtJQUFBLGlCQVlBO0VBQUE7RUFaQTtJQUFBLGFBWUE7RUFBQTtFQVpBO0lBQUEsYUFZQTtFQUFBO0VBWkE7SUFBQSxhQVlBO0VBQUE7RUFaQTtJQUFBLG9CQVlBO0VBQUE7RUFaQTtJQUFBLGtCQVlBO0VBQUE7RUFaQTtJQUFBLGNBWUE7RUFBQTtFQVpBO0lBQUEsK0JBWUE7SUFaQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSw0Q0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxnQkFZQTtFQUFBO0VBWkE7SUFBQSxhQVlBO0VBQUE7RUFaQTtJQUFBLGFBWUE7RUFBQTtFQVpBO0lBQUEsWUFZQTtFQUFBO0VBWkE7SUFBQSxZQVlBO0VBQUE7RUFaQTtJQUFBLHFDQVlBO0VBQUE7RUFaQTtJQUFBLHFDQVlBO0VBQUE7RUFaQTtJQUFBLGlCQVlBO0VBQUE7RUFaQTtJQUFBLGlCQVlBO0VBQUE7RUFaQTtJQUFBLGlCQVlBO0VBQUE7RUFaQTtJQUFBLDJDQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLHVCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLGdDQVlBO0VBQUE7RUFaQTtJQUFBLGdDQVlBO0VBQUE7RUFaQTtJQUFBLGdDQVlBO0VBQUE7RUFaQTtJQUFBLGlCQVlBO0VBQUE7RUFaQTtJQUFBLGVBWUE7RUFBQTtFQVpBO0lBQUEsWUFZQTtFQUFBO0VBWkE7SUFBQSxXQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLCtCQVlBO0VBQUE7RUFaQTtJQUFBLGdCQVlBO0VBQUE7RUFaQTtJQUFBLGVBWUE7RUFBQTtFQVpBO0lBQUEsOEJBWUE7RUFBQTtFQVpBO0lBQUEsZ0JBWUE7RUFBQTtFQVpBO0lBQUEsWUFZQTtFQUFBO0VBWkE7SUFBQSx5QkFZQTtFQUFBO0VBWkE7SUFBQSxxR0FZQTtFQUFBO0VBWkE7SUFBQSw4QkFZQTtFQUFBO0VBWkE7SUFBQSxtQkFZQTtFQUFBO0VBWkE7SUFBQSxlQVlBO0VBQUE7RUFaQTtJQUFBLFlBWUE7RUFBQTtFQVpBO0lBQUEsZ0JBWUE7RUFBQTtFQVpBO0lBQUEsZ0RBWUE7RUFBQTtFQVpBO0lBQUEsb0NBWUE7RUFBQTtFQVpBO0lBQUEsc0JBWUE7RUFBQTtFQVpBO0lBQUEsZUFZQTtFQUFBO0VBWkE7SUFBQSw4QkFZQTtFQUFBO0VBWkE7SUFBQSxtQkFZQTtFQUFBO0VBWkE7SUFBQSxrQ0FZQTtFQUFBO0VBWkE7SUFBQSw4QkFZQTtFQUFBO0VBWkE7SUFBQSx1QkFZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFBQSwrQkFZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQSwrQkFZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQTtNQUFBLHVCQVlBO01BWkEsOEVBWUE7TUFaQSxzRkFZQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUEsdUJBWUE7TUFaQSw4RUFZQTtNQVpBLHNGQVlBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQSx1QkFZQTtNQVpBLDhFQVlBO01BWkEsc0ZBWUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBLHVCQVlBO01BWkEsOEVBWUE7TUFaQSxzRkFZQTtJQUFBO0VBQUE7RUFaQTtJQUFBLHNCQVlBO0VBQUE7RUFaQTtJQUFBLGNBWUE7RUFBQTtFQVpBO0lBQUEsZ0JBWUE7RUFBQTtFQVpBO0lBQUEsZ0JBWUE7RUFBQTtFQVpBO0lBQUEsOENBWUE7RUFBQTtFQVpBO0lBQUEsc0JBWUE7RUFBQTtFQVpBO0lBQUEsZ0NBWUE7RUFBQTtFQVpBO0lBQUEsZ0NBWUE7RUFBQTtFQVpBO0lBQUEsbUNBWUE7RUFBQTtFQVpBO0lBQUEsK0JBWUE7RUFBQTtFQVpBO0lBQUEsK0JBWUE7RUFBQTtFQVpBO0lBQUEsK0JBWUE7RUFBQTtFQVpBO0lBQUEsd0NBWUE7SUFaQSwyQ0FZQTtFQUFBO0VBWkE7SUFBQSx5Q0FZQTtJQVpBLDRDQVlBO0VBQUE7RUFaQTtJQUFBLCtDQVlBO0lBWkEsNEJBWUE7RUFBQTtFQVpBO0lBQUEsb0NBWUE7SUFaQSxpQkFZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtJQVpBLGlCQVlBO0VBQUE7RUFaQTtJQUFBLG9DQVlBO0lBWkEsaUJBWUE7RUFBQTtFQVpBO0lBQUEsd0NBWUE7SUFaQSxxQkFZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtJQVpBLHFCQVlBO0VBQUE7RUFaQTtJQUFBLDBDQVlBO0lBWkEsdUJBWUE7RUFBQTtFQVpBO0lBQUEsMkNBWUE7SUFaQSx3QkFZQTtFQUFBO0VBWkE7SUFBQSx5Q0FZQTtJQVpBLHNCQVlBO0VBQUE7RUFaQTtJQUFBLHlCQVlBO0lBWkEsb0JBWUE7RUFBQTtFQVpBO0lBQUEsdUJBWUE7SUFaQSxrQkFZQTtFQUFBO0VBWkE7SUFBQSwyQ0FZQTtFQUFBO0VBWkE7SUFBQSxtQ0FZQTtFQUFBO0VBWkE7SUFBQSwwQkFZQTtFQUFBO0VBWkE7SUFBQSxnQ0FZQTtFQUFBO0VBWkE7SUFBQSxzRUFZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFBQSwrQ0FZQTtFQUFBO0VBWkE7SUFBQSx5QkFZQTtFQUFBO0VBWkE7SUFBQSx5QkFZQTtFQUFBO0VBWkE7SUFBQSwrREFZQTtFQUFBO0VBWkE7SUFBQSx5QkFZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSwwRUFZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSw2RUFZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx5Q0FZQTtFQUFBO0VBWkE7SUFBQSxzQ0FZQTtFQUFBO0VBWkE7SUFBQSw2QkFZQTtFQUFBO0VBWkE7SUFBQSxvQ0FZQTtFQUFBO0VBWkE7SUFBQSx5RUFZQTtFQUFBO0VBWkE7SUFBQSwwRUFZQTtFQUFBO0VBWkE7SUFBQSwwRUFZQTtFQUFBO0VBWkE7SUFBQSxtQkFZQTtFQUFBO0VBWkE7SUFBQSxpQkFZQTtFQUFBO0VBWkE7SUFBQSw0Q0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxpQ0FZQTtFQUFBO0VBWkE7SUFBQSxrQ0FZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx5Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx1Q0FZQTtFQUFBO0VBWkE7SUFBQSx3Q0FZQTtFQUFBO0VBWkE7SUFB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LDZDQVlBO1FBWkEsc0RBWUE7TUFBQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUE7UUFBQSxxR0FZQTtNQUFBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQTtRQUFBLHdDQVlBO01BQUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBO1FBQUEscUZBWUE7TUFBQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUE7UUFBQSx1Q0FZQTtNQUFBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQTtRQUFBLDRFQVlBO01BQUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBO1FBQUEsMEVBWUE7TUFBQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUE7UUFBQSxvQ0FZQTtNQUFBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQTtRQUFBLDRCQVlBO01BQUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBO1FBQUEsNEJBWUE7TUFBQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUE7UUFBQSxZQVlBO01BQUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBO1FBQUEsK0hBWUE7UUFaQSxzSUFZQTtNQUFBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQSxtQ0FZQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUEsd0hBWUE7TUFaQSxzSUFZQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUEsd0JBWUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBLHdCQVlBO01BWkEsbUJBWUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBLG1CQVlBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQSxZQVlBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQSxnREFZQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUEsc0JBWUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBLGFBWUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBLFdBWUE7SUFBQTtFQUFBO0VBWkE7SUFBQTtNQUFBLGdEQVlBO0lBQUE7RUFBQTtFQVpBO0lBQUE7TUFBQSxnREFZQTtJQUFBO0VBQUE7RUFaQTtJQUFBO01BQUEsa0NBWUE7SUFBQTtFQUFBO0FBQUE7QUFaQTtFQUFBO0lBQUEsNEJBWUE7RUFBQTtBQUFBO0FBWkE7RUFBQTtJQUFBLHlCQVlBO0VBQUE7QUFBQTtBQVpBO0VBQUE7SUFBQSxtQkFZQTtJQVpBLFVBWUE7RUFBQTtBQUFBO0FBWkE7RUFBQTtJQUFBLFlBWUE7RUFBQTtBQUFBO0FBWkE7RUFBQTtJQUFBLDJCQVlBO0lBWkEscURBWUE7RUFBQTtFQVpBO0lBQUEsZUFZQTtJQVpBLHFEQVlBO0VBQUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7RUFaQSx5QkFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtFQVpBLHlCQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0VBWkEseUJBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7RUFaQSx1QkFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtFQVpBLHVCQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0VBWkEsZ0JBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7RUFaQSxvQkFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtFQVpBLHdCQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0VBWkEsd0JBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7RUFaQSx3QkFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtFQVpBLHdCQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLGtCQVlBO0VBWkEsZUFZQTtFQVpBLGtCQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0VBWkEsbUJBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7RUFaQSx3QkFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtFQVpBLG9CQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0FBQUE7QUFaQTtFQUFBLFdBWUE7RUFaQSxlQVlBO0VBWkEsZ0JBWUE7QUFBQTtBQVpBO0VBQUEsV0FZQTtFQVpBLGVBWUE7RUFaQSxnQkFZQTtBQUFBO0FBWkE7RUFBQSxXQVlBO0VBWkEsZUFZQTtFQVpBLGdCQVlBO0FBQUFcIixcInNvdXJjZXNDb250ZW50XCI6W1wiQGltcG9ydCBcXFwidGFpbHdpbmRjc3NcXFwiO1xcblxcbkB0aGVtZSB7XFxuICAtLWNvbG9yLXByaW1hcnktdHc6ICMyYjgwZmY7XFxuICAtLWNvbG9yLWxpZ2h0OiAjYzNkNWY3O1xcbn1cXG5cXG5AbGF5ZXIgYmFzZSB7XFxuICA6cm9vdCB7XFxuICAgIC0tdHctaW1wb3J0YW50OiAhaW1wb3J0YW50O1xcbiAgfVxcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///408\n')},314:module=>{"use strict";eval('\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\nmodule.exports = function (cssWithMappingToString) {\n  var list = [];\n\n  // return the list of modules as css string\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = "";\n      var needLayer = typeof item[5] !== "undefined";\n      if (item[4]) {\n        content += "@supports (".concat(item[4], ") {");\n      }\n      if (item[2]) {\n        content += "@media ".concat(item[2], " {");\n      }\n      if (needLayer) {\n        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");\n      }\n      content += cssWithMappingToString(item);\n      if (needLayer) {\n        content += "}";\n      }\n      if (item[2]) {\n        content += "}";\n      }\n      if (item[4]) {\n        content += "}";\n      }\n      return content;\n    }).join("");\n  };\n\n  // import a list of modules into the list\n  list.i = function i(modules, media, dedupe, supports, layer) {\n    if (typeof modules === "string") {\n      modules = [[null, modules, undefined]];\n    }\n    var alreadyImportedModules = {};\n    if (dedupe) {\n      for (var k = 0; k < this.length; k++) {\n        var id = this[k][0];\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n    for (var _k = 0; _k < modules.length; _k++) {\n      var item = [].concat(modules[_k]);\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        continue;\n      }\n      if (typeof layer !== "undefined") {\n        if (typeof item[5] === "undefined") {\n          item[5] = layer;\n        } else {\n          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");\n          item[5] = layer;\n        }\n      }\n      if (media) {\n        if (!item[2]) {\n          item[2] = media;\n        } else {\n          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");\n          item[2] = media;\n        }\n      }\n      if (supports) {\n        if (!item[4]) {\n          item[4] = "".concat(supports);\n        } else {\n          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");\n          item[4] = supports;\n        }\n      }\n      list.push(item);\n    }\n  };\n  return list;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzE0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzRkFBc0YscUJBQXFCO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qcz8yNGZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///314\n')},354:module=>{"use strict";eval('\n\nmodule.exports = function (item) {\n  var content = item[1];\n  var cssMapping = item[3];\n  if (!cssMapping) {\n    return content;\n  }\n  if (typeof btoa === "function") {\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));\n    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);\n    var sourceMapping = "/*# ".concat(data, " */");\n    return [content].concat([sourceMapping]).join("\\n");\n  }\n  return [content].join("\\n");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzU0LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzP2FmMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///354\n')},606:module=>{eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/ZjI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///606\n")},247:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(606);\n/**\n * @license React\n * react-dom-client.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n\nvar Scheduler = __webpack_require__(982),\n  React = __webpack_require__(540),\n  ReactDOM = __webpack_require__(961);\nfunction formatProdErrorMessage(code) {\n  var url = "https://react.dev/errors/" + code;\n  if (1 < arguments.length) {\n    url += "?args[]=" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += "&args[]=" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    "Minified React error #" +\n    code +\n    "; visit " +\n    url +\n    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."\n  );\n}\nfunction isValidContainer(node) {\n  return !(\n    !node ||\n    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)\n  );\n}\nvar REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"),\n  REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_PORTAL_TYPE = Symbol.for("react.portal"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),\n  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),\n  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),\n  REACT_PROVIDER_TYPE = Symbol.for("react.provider"),\n  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),\n  REACT_CONTEXT_TYPE = Symbol.for("react.context"),\n  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),\n  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"),\n  REACT_MEMO_TYPE = Symbol.for("react.memo"),\n  REACT_LAZY_TYPE = Symbol.for("react.lazy");\nSymbol.for("react.scope");\nSymbol.for("react.debug_trace_mode");\nvar REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");\nSymbol.for("react.legacy_hidden");\nSymbol.for("react.tracing_marker");\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable["@@iterator"];\n  return "function" === typeof maybeIterable ? maybeIterable : null;\n}\nvar REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");\nfunction getComponentNameFromType(type) {\n  if (null == type) return null;\n  if ("function" === typeof type)\n    return type.$$typeof === REACT_CLIENT_REFERENCE\n      ? null\n      : type.displayName || type.name || null;\n  if ("string" === typeof type) return type;\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return "Fragment";\n    case REACT_PORTAL_TYPE:\n      return "Portal";\n    case REACT_PROFILER_TYPE:\n      return "Profiler";\n    case REACT_STRICT_MODE_TYPE:\n      return "StrictMode";\n    case REACT_SUSPENSE_TYPE:\n      return "Suspense";\n    case REACT_SUSPENSE_LIST_TYPE:\n      return "SuspenseList";\n  }\n  if ("object" === typeof type)\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        return (type.displayName || "Context") + ".Provider";\n      case REACT_CONSUMER_TYPE:\n        return (type._context.displayName || "Context") + ".Consumer";\n      case REACT_FORWARD_REF_TYPE:\n        var innerType = type.render;\n        type = type.displayName;\n        type ||\n          ((type = innerType.displayName || innerType.name || ""),\n          (type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef"));\n        return type;\n      case REACT_MEMO_TYPE:\n        return (\n          (innerType = type.displayName || null),\n          null !== innerType\n            ? innerType\n            : getComponentNameFromType(type.type) || "Memo"\n        );\n      case REACT_LAZY_TYPE:\n        innerType = type._payload;\n        type = type._init;\n        try {\n          return getComponentNameFromType(type(innerType));\n        } catch (x) {}\n    }\n  return null;\n}\nvar ReactSharedInternals =\n    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  assign = Object.assign,\n  prefix,\n  suffix;\nfunction describeBuiltInComponentFrame(name) {\n  if (void 0 === prefix)\n    try {\n      throw Error();\n    } catch (x) {\n      var match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = (match && match[1]) || "";\n      suffix =\n        -1 < x.stack.indexOf("\\n    at")\n          ? " (<anonymous>)"\n          : -1 < x.stack.indexOf("@")\n            ? "@unknown:0:0"\n            : "";\n    }\n  return "\\n" + prefix + name + suffix;\n}\nvar reentry = !1;\nfunction describeNativeComponentFrame(fn, construct) {\n  if (!fn || reentry) return "";\n  reentry = !0;\n  var previousPrepareStackTrace = Error.prepareStackTrace;\n  Error.prepareStackTrace = void 0;\n  try {\n    var RunInRootFrame = {\n      DetermineComponentFrameRoot: function () {\n        try {\n          if (construct) {\n            var Fake = function () {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, "props", {\n              set: function () {\n                throw Error();\n              }\n            });\n            if ("object" === typeof Reflect && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                var control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x$0) {\n                control = x$0;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x$1) {\n              control = x$1;\n            }\n            (Fake = fn()) &&\n              "function" === typeof Fake.catch &&\n              Fake.catch(function () {});\n          }\n        } catch (sample) {\n          if (sample && control && "string" === typeof sample.stack)\n            return [sample.stack, control.stack];\n        }\n        return [null, null];\n      }\n    };\n    RunInRootFrame.DetermineComponentFrameRoot.displayName =\n      "DetermineComponentFrameRoot";\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(\n      RunInRootFrame.DetermineComponentFrameRoot,\n      "name"\n    );\n    namePropDescriptor &&\n      namePropDescriptor.configurable &&\n      Object.defineProperty(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        "name",\n        { value: "DetermineComponentFrameRoot" }\n      );\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n      sampleStack = _RunInRootFrame$Deter[0],\n      controlStack = _RunInRootFrame$Deter[1];\n    if (sampleStack && controlStack) {\n      var sampleLines = sampleStack.split("\\n"),\n        controlLines = controlStack.split("\\n");\n      for (\n        namePropDescriptor = RunInRootFrame = 0;\n        RunInRootFrame < sampleLines.length &&\n        !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot");\n\n      )\n        RunInRootFrame++;\n      for (\n        ;\n        namePropDescriptor < controlLines.length &&\n        !controlLines[namePropDescriptor].includes(\n          "DetermineComponentFrameRoot"\n        );\n\n      )\n        namePropDescriptor++;\n      if (\n        RunInRootFrame === sampleLines.length ||\n        namePropDescriptor === controlLines.length\n      )\n        for (\n          RunInRootFrame = sampleLines.length - 1,\n            namePropDescriptor = controlLines.length - 1;\n          1 <= RunInRootFrame &&\n          0 <= namePropDescriptor &&\n          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];\n\n        )\n          namePropDescriptor--;\n      for (\n        ;\n        1 <= RunInRootFrame && 0 <= namePropDescriptor;\n        RunInRootFrame--, namePropDescriptor--\n      )\n        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\n            do\n              if (\n                (RunInRootFrame--,\n                namePropDescriptor--,\n                0 > namePropDescriptor ||\n                  sampleLines[RunInRootFrame] !==\n                    controlLines[namePropDescriptor])\n              ) {\n                var frame =\n                  "\\n" +\n                  sampleLines[RunInRootFrame].replace(" at new ", " at ");\n                fn.displayName &&\n                  frame.includes("<anonymous>") &&\n                  (frame = frame.replace("<anonymous>", fn.displayName));\n                return frame;\n              }\n            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\n          }\n          break;\n        }\n    }\n  } finally {\n    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);\n  }\n  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "")\n    ? describeBuiltInComponentFrame(previousPrepareStackTrace)\n    : "";\n}\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n    case 27:\n    case 5:\n      return describeBuiltInComponentFrame(fiber.type);\n    case 16:\n      return describeBuiltInComponentFrame("Lazy");\n    case 13:\n      return describeBuiltInComponentFrame("Suspense");\n    case 19:\n      return describeBuiltInComponentFrame("SuspenseList");\n    case 0:\n    case 15:\n      return (fiber = describeNativeComponentFrame(fiber.type, !1)), fiber;\n    case 11:\n      return (\n        (fiber = describeNativeComponentFrame(fiber.type.render, !1)), fiber\n      );\n    case 1:\n      return (fiber = describeNativeComponentFrame(fiber.type, !0)), fiber;\n    default:\n      return "";\n  }\n}\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = "";\n    do\n      (info += describeFiber(workInProgress)),\n        (workInProgress = workInProgress.return);\n    while (workInProgress);\n    return info;\n  } catch (x) {\n    return "\\nError generating stack: " + x.message + "\\n" + x.stack;\n  }\n}\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber,\n    nearestMounted = fiber;\n  if (fiber.alternate) for (; node.return; ) node = node.return;\n  else {\n    fiber = node;\n    do\n      (node = fiber),\n        0 !== (node.flags & 4098) && (nearestMounted = node.return),\n        (fiber = node.return);\n    while (fiber);\n  }\n  return 3 === node.tag ? nearestMounted : null;\n}\nfunction getSuspenseInstanceFromFiber(fiber) {\n  if (13 === fiber.tag) {\n    var suspenseState = fiber.memoizedState;\n    null === suspenseState &&\n      ((fiber = fiber.alternate),\n      null !== fiber && (suspenseState = fiber.memoizedState));\n    if (null !== suspenseState) return suspenseState.dehydrated;\n  }\n  return null;\n}\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber)\n    throw Error(formatProdErrorMessage(188));\n}\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    alternate = getNearestMountedFiber(fiber);\n    if (null === alternate) throw Error(formatProdErrorMessage(188));\n    return alternate !== fiber ? null : fiber;\n  }\n  for (var a = fiber, b = alternate; ; ) {\n    var parentA = a.return;\n    if (null === parentA) break;\n    var parentB = parentA.alternate;\n    if (null === parentB) {\n      b = parentA.return;\n      if (null !== b) {\n        a = b;\n        continue;\n      }\n      break;\n    }\n    if (parentA.child === parentB.child) {\n      for (parentB = parentA.child; parentB; ) {\n        if (parentB === a) return assertIsMounted(parentA), fiber;\n        if (parentB === b) return assertIsMounted(parentA), alternate;\n        parentB = parentB.sibling;\n      }\n      throw Error(formatProdErrorMessage(188));\n    }\n    if (a.return !== b.return) (a = parentA), (b = parentB);\n    else {\n      for (var didFindChild = !1, child$2 = parentA.child; child$2; ) {\n        if (child$2 === a) {\n          didFindChild = !0;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child$2 === b) {\n          didFindChild = !0;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child$2 = child$2.sibling;\n      }\n      if (!didFindChild) {\n        for (child$2 = parentB.child; child$2; ) {\n          if (child$2 === a) {\n            didFindChild = !0;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child$2 === b) {\n            didFindChild = !0;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child$2 = child$2.sibling;\n        }\n        if (!didFindChild) throw Error(formatProdErrorMessage(189));\n      }\n    }\n    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));\n  }\n  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));\n  return a.stateNode.current === a ? fiber : alternate;\n}\nfunction findCurrentHostFiberImpl(node) {\n  var tag = node.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n  for (node = node.child; null !== node; ) {\n    tag = findCurrentHostFiberImpl(node);\n    if (null !== tag) return tag;\n    node = node.sibling;\n  }\n  return null;\n}\nvar isArrayImpl = Array.isArray,\n  ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  sharedNotPendingObject = {\n    pending: !1,\n    data: null,\n    method: null,\n    action: null\n  },\n  valueStack = [],\n  index = -1;\nfunction createCursor(defaultValue) {\n  return { current: defaultValue };\n}\nfunction pop(cursor) {\n  0 > index ||\n    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);\n}\nfunction push(cursor, value) {\n  index++;\n  valueStack[index] = cursor.current;\n  cursor.current = value;\n}\nvar contextStackCursor = createCursor(null),\n  contextFiberStackCursor = createCursor(null),\n  rootInstanceStackCursor = createCursor(null),\n  hostTransitionProviderCursor = createCursor(null);\nfunction pushHostContainer(fiber, nextRootInstance) {\n  push(rootInstanceStackCursor, nextRootInstance);\n  push(contextFiberStackCursor, fiber);\n  push(contextStackCursor, null);\n  fiber = nextRootInstance.nodeType;\n  switch (fiber) {\n    case 9:\n    case 11:\n      nextRootInstance = (nextRootInstance = nextRootInstance.documentElement)\n        ? (nextRootInstance = nextRootInstance.namespaceURI)\n          ? getOwnHostContext(nextRootInstance)\n          : 0\n        : 0;\n      break;\n    default:\n      if (\n        ((fiber = 8 === fiber ? nextRootInstance.parentNode : nextRootInstance),\n        (nextRootInstance = fiber.tagName),\n        (fiber = fiber.namespaceURI))\n      )\n        (fiber = getOwnHostContext(fiber)),\n          (nextRootInstance = getChildHostContextProd(fiber, nextRootInstance));\n      else\n        switch (nextRootInstance) {\n          case "svg":\n            nextRootInstance = 1;\n            break;\n          case "math":\n            nextRootInstance = 2;\n            break;\n          default:\n            nextRootInstance = 0;\n        }\n  }\n  pop(contextStackCursor);\n  push(contextStackCursor, nextRootInstance);\n}\nfunction popHostContainer() {\n  pop(contextStackCursor);\n  pop(contextFiberStackCursor);\n  pop(rootInstanceStackCursor);\n}\nfunction pushHostContext(fiber) {\n  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);\n  var context = contextStackCursor.current;\n  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);\n  context !== JSCompiler_inline_result &&\n    (push(contextFiberStackCursor, fiber),\n    push(contextStackCursor, JSCompiler_inline_result));\n}\nfunction popHostContext(fiber) {\n  contextFiberStackCursor.current === fiber &&\n    (pop(contextStackCursor), pop(contextFiberStackCursor));\n  hostTransitionProviderCursor.current === fiber &&\n    (pop(hostTransitionProviderCursor),\n    (HostTransitionContext._currentValue = sharedNotPendingObject));\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\n  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,\n  cancelCallback$1 = Scheduler.unstable_cancelCallback,\n  shouldYield = Scheduler.unstable_shouldYield,\n  requestPaint = Scheduler.unstable_requestPaint,\n  now = Scheduler.unstable_now,\n  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,\n  ImmediatePriority = Scheduler.unstable_ImmediatePriority,\n  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,\n  NormalPriority$1 = Scheduler.unstable_NormalPriority,\n  LowPriority = Scheduler.unstable_LowPriority,\n  IdlePriority = Scheduler.unstable_IdlePriority,\n  log$1 = Scheduler.log,\n  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,\n  rendererID = null,\n  injectedHook = null;\nfunction onCommitRoot(root) {\n  if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)\n    try {\n      injectedHook.onCommitFiberRoot(\n        rendererID,\n        root,\n        void 0,\n        128 === (root.current.flags & 128)\n      );\n    } catch (err) {}\n}\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\n  if (injectedHook && "function" === typeof injectedHook.setStrictMode)\n    try {\n      injectedHook.setStrictMode(rendererID, newIsStrictMode);\n    } catch (err) {}\n}\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n  log = Math.log,\n  LN2 = Math.LN2;\nfunction clz32Fallback(x) {\n  x >>>= 0;\n  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n}\nvar nextTransitionLane = 128,\n  nextRetryLane = 4194304;\nfunction getHighestPriorityLanes(lanes) {\n  var pendingSyncLanes = lanes & 42;\n  if (0 !== pendingSyncLanes) return pendingSyncLanes;\n  switch (lanes & -lanes) {\n    case 1:\n      return 1;\n    case 2:\n      return 2;\n    case 4:\n      return 4;\n    case 8:\n      return 8;\n    case 16:\n      return 16;\n    case 32:\n      return 32;\n    case 64:\n      return 64;\n    case 128:\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return lanes & 4194176;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return lanes & 62914560;\n    case 67108864:\n      return 67108864;\n    case 134217728:\n      return 134217728;\n    case 268435456:\n      return 268435456;\n    case 536870912:\n      return 536870912;\n    case 1073741824:\n      return 0;\n    default:\n      return lanes;\n  }\n}\nfunction getNextLanes(root, wipLanes) {\n  var pendingLanes = root.pendingLanes;\n  if (0 === pendingLanes) return 0;\n  var nextLanes = 0,\n    suspendedLanes = root.suspendedLanes,\n    pingedLanes = root.pingedLanes,\n    warmLanes = root.warmLanes;\n  root = 0 !== root.finishedLanes;\n  var nonIdlePendingLanes = pendingLanes & 134217727;\n  0 !== nonIdlePendingLanes\n    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),\n      0 !== pendingLanes\n        ? (nextLanes = getHighestPriorityLanes(pendingLanes))\n        : ((pingedLanes &= nonIdlePendingLanes),\n          0 !== pingedLanes\n            ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n            : root ||\n              ((warmLanes = nonIdlePendingLanes & ~warmLanes),\n              0 !== warmLanes &&\n                (nextLanes = getHighestPriorityLanes(warmLanes)))))\n    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),\n      0 !== nonIdlePendingLanes\n        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))\n        : 0 !== pingedLanes\n          ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n          : root ||\n            ((warmLanes = pendingLanes & ~warmLanes),\n            0 !== warmLanes &&\n              (nextLanes = getHighestPriorityLanes(warmLanes))));\n  return 0 === nextLanes\n    ? 0\n    : 0 !== wipLanes &&\n        wipLanes !== nextLanes &&\n        0 === (wipLanes & suspendedLanes) &&\n        ((suspendedLanes = nextLanes & -nextLanes),\n        (warmLanes = wipLanes & -wipLanes),\n        suspendedLanes >= warmLanes ||\n          (32 === suspendedLanes && 0 !== (warmLanes & 4194176)))\n      ? wipLanes\n      : nextLanes;\n}\nfunction checkIfRootIsPrerendering(root, renderLanes) {\n  return (\n    0 ===\n    (root.pendingLanes &\n      ~(root.suspendedLanes & ~root.pingedLanes) &\n      renderLanes)\n  );\n}\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case 1:\n    case 2:\n    case 4:\n    case 8:\n      return currentTime + 250;\n    case 16:\n    case 32:\n    case 64:\n    case 128:\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return currentTime + 5e3;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return -1;\n    case 67108864:\n    case 134217728:\n    case 268435456:\n    case 536870912:\n    case 1073741824:\n      return -1;\n    default:\n      return -1;\n  }\n}\nfunction claimNextTransitionLane() {\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  0 === (nextTransitionLane & 4194176) && (nextTransitionLane = 128);\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n  return lane;\n}\nfunction createLaneMap(initial) {\n  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);\n  return laneMap;\n}\nfunction markRootUpdated$1(root, updateLane) {\n  root.pendingLanes |= updateLane;\n  268435456 !== updateLane &&\n    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));\n}\nfunction markRootFinished(\n  root,\n  finishedLanes,\n  remainingLanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  var previouslyPendingLanes = root.pendingLanes;\n  root.pendingLanes = remainingLanes;\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n  root.warmLanes = 0;\n  root.expiredLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n  root.shellSuspendCounter = 0;\n  var entanglements = root.entanglements,\n    expirationTimes = root.expirationTimes,\n    hiddenUpdates = root.hiddenUpdates;\n  for (\n    remainingLanes = previouslyPendingLanes & ~remainingLanes;\n    0 < remainingLanes;\n\n  ) {\n    var index$7 = 31 - clz32(remainingLanes),\n      lane = 1 << index$7;\n    entanglements[index$7] = 0;\n    expirationTimes[index$7] = -1;\n    var hiddenUpdatesForLane = hiddenUpdates[index$7];\n    if (null !== hiddenUpdatesForLane)\n      for (\n        hiddenUpdates[index$7] = null, index$7 = 0;\n        index$7 < hiddenUpdatesForLane.length;\n        index$7++\n      ) {\n        var update = hiddenUpdatesForLane[index$7];\n        null !== update && (update.lane &= -536870913);\n      }\n    remainingLanes &= ~lane;\n  }\n  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n  0 !== suspendedRetryLanes &&\n    0 === updatedLanes &&\n    0 !== root.tag &&\n    (root.suspendedLanes |=\n      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n}\nfunction markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n  root.pendingLanes |= spawnedLane;\n  root.suspendedLanes &= ~spawnedLane;\n  var spawnedLaneIndex = 31 - clz32(spawnedLane);\n  root.entangledLanes |= spawnedLane;\n  root.entanglements[spawnedLaneIndex] =\n    root.entanglements[spawnedLaneIndex] |\n    1073741824 |\n    (entangledLanes & 4194218);\n}\nfunction markRootEntangled(root, entangledLanes) {\n  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  for (root = root.entanglements; rootEntangledLanes; ) {\n    var index$8 = 31 - clz32(rootEntangledLanes),\n      lane = 1 << index$8;\n    (lane & entangledLanes) | (root[index$8] & entangledLanes) &&\n      (root[index$8] |= entangledLanes);\n    rootEntangledLanes &= ~lane;\n  }\n}\nfunction lanesToEventPriority(lanes) {\n  lanes &= -lanes;\n  return 2 < lanes\n    ? 8 < lanes\n      ? 0 !== (lanes & 134217727)\n        ? 32\n        : 268435456\n      : 8\n    : 2;\n}\nfunction resolveUpdatePriority() {\n  var updatePriority = ReactDOMSharedInternals.p;\n  if (0 !== updatePriority) return updatePriority;\n  updatePriority = window.event;\n  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    return (ReactDOMSharedInternals.p = priority), fn();\n  } finally {\n    ReactDOMSharedInternals.p = previousPriority;\n  }\n}\nvar randomKey = Math.random().toString(36).slice(2),\n  internalInstanceKey = "__reactFiber$" + randomKey,\n  internalPropsKey = "__reactProps$" + randomKey,\n  internalContainerInstanceKey = "__reactContainer$" + randomKey,\n  internalEventHandlersKey = "__reactEvents$" + randomKey,\n  internalEventHandlerListenersKey = "__reactListeners$" + randomKey,\n  internalEventHandlesSetKey = "__reactHandles$" + randomKey,\n  internalRootNodeResourcesKey = "__reactResources$" + randomKey,\n  internalHoistableMarker = "__reactMarker$" + randomKey;\nfunction detachDeletedInstance(node) {\n  delete node[internalInstanceKey];\n  delete node[internalPropsKey];\n  delete node[internalEventHandlersKey];\n  delete node[internalEventHandlerListenersKey];\n  delete node[internalEventHandlesSetKey];\n}\nfunction getClosestInstanceFromNode(targetNode) {\n  var targetInst = targetNode[internalInstanceKey];\n  if (targetInst) return targetInst;\n  for (var parentNode = targetNode.parentNode; parentNode; ) {\n    if (\n      (targetInst =\n        parentNode[internalContainerInstanceKey] ||\n        parentNode[internalInstanceKey])\n    ) {\n      parentNode = targetInst.alternate;\n      if (\n        null !== targetInst.child ||\n        (null !== parentNode && null !== parentNode.child)\n      )\n        for (\n          targetNode = getParentSuspenseInstance(targetNode);\n          null !== targetNode;\n\n        ) {\n          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;\n          targetNode = getParentSuspenseInstance(targetNode);\n        }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\nfunction getInstanceFromNode(node) {\n  if (\n    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])\n  ) {\n    var tag = node.tag;\n    if (\n      5 === tag ||\n      6 === tag ||\n      13 === tag ||\n      26 === tag ||\n      27 === tag ||\n      3 === tag\n    )\n      return node;\n  }\n  return null;\n}\nfunction getNodeFromInstance(inst) {\n  var tag = inst.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\n  throw Error(formatProdErrorMessage(33));\n}\nfunction getResourcesFromRoot(root) {\n  var resources = root[internalRootNodeResourcesKey];\n  resources ||\n    (resources = root[internalRootNodeResourcesKey] =\n      { hoistableStyles: new Map(), hoistableScripts: new Map() });\n  return resources;\n}\nfunction markNodeAsHoistable(node) {\n  node[internalHoistableMarker] = !0;\n}\nvar allNativeEvents = new Set(),\n  registrationNameDependencies = {};\nfunction registerTwoPhaseEvent(registrationName, dependencies) {\n  registerDirectEvent(registrationName, dependencies);\n  registerDirectEvent(registrationName + "Capture", dependencies);\n}\nfunction registerDirectEvent(registrationName, dependencies) {\n  registrationNameDependencies[registrationName] = dependencies;\n  for (\n    registrationName = 0;\n    registrationName < dependencies.length;\n    registrationName++\n  )\n    allNativeEvents.add(dependencies[registrationName]);\n}\nvar canUseDOM = !(\n    "undefined" === typeof window ||\n    "undefined" === typeof window.document ||\n    "undefined" === typeof window.document.createElement\n  ),\n  VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n    "^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$"\n  ),\n  illegalAttributeNameCache = {},\n  validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n    return !0;\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n    return (validatedAttributeNameCache[attributeName] = !0);\n  illegalAttributeNameCache[attributeName] = !0;\n  return !1;\n}\nfunction setValueForAttribute(node, name, value) {\n  if (isAttributeNameSafe(name))\n    if (null === value) node.removeAttribute(name);\n    else {\n      switch (typeof value) {\n        case "undefined":\n        case "function":\n        case "symbol":\n          node.removeAttribute(name);\n          return;\n        case "boolean":\n          var prefix$10 = name.toLowerCase().slice(0, 5);\n          if ("data-" !== prefix$10 && "aria-" !== prefix$10) {\n            node.removeAttribute(name);\n            return;\n          }\n      }\n      node.setAttribute(name, "" + value);\n    }\n}\nfunction setValueForKnownAttribute(node, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case "undefined":\n      case "function":\n      case "symbol":\n      case "boolean":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttribute(name, "" + value);\n  }\n}\nfunction setValueForNamespacedAttribute(node, namespace, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case "undefined":\n      case "function":\n      case "symbol":\n      case "boolean":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttributeNS(namespace, name, "" + value);\n  }\n}\nfunction getToStringValue(value) {\n  switch (typeof value) {\n    case "bigint":\n    case "boolean":\n    case "number":\n    case "string":\n    case "undefined":\n      return value;\n    case "object":\n      return value;\n    default:\n      return "";\n  }\n}\nfunction isCheckable(elem) {\n  var type = elem.type;\n  return (\n    (elem = elem.nodeName) &&\n    "input" === elem.toLowerCase() &&\n    ("checkbox" === type || "radio" === type)\n  );\n}\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? "checked" : "value",\n    descriptor = Object.getOwnPropertyDescriptor(\n      node.constructor.prototype,\n      valueField\n    ),\n    currentValue = "" + node[valueField];\n  if (\n    !node.hasOwnProperty(valueField) &&\n    "undefined" !== typeof descriptor &&\n    "function" === typeof descriptor.get &&\n    "function" === typeof descriptor.set\n  ) {\n    var get = descriptor.get,\n      set = descriptor.set;\n    Object.defineProperty(node, valueField, {\n      configurable: !0,\n      get: function () {\n        return get.call(this);\n      },\n      set: function (value) {\n        currentValue = "" + value;\n        set.call(this, value);\n      }\n    });\n    Object.defineProperty(node, valueField, {\n      enumerable: descriptor.enumerable\n    });\n    return {\n      getValue: function () {\n        return currentValue;\n      },\n      setValue: function (value) {\n        currentValue = "" + value;\n      },\n      stopTracking: function () {\n        node._valueTracker = null;\n        delete node[valueField];\n      }\n    };\n  }\n}\nfunction track(node) {\n  node._valueTracker || (node._valueTracker = trackValueOnNode(node));\n}\nfunction updateValueIfChanged(node) {\n  if (!node) return !1;\n  var tracker = node._valueTracker;\n  if (!tracker) return !0;\n  var lastValue = tracker.getValue();\n  var value = "";\n  node &&\n    (value = isCheckable(node)\n      ? node.checked\n        ? "true"\n        : "false"\n      : node.value);\n  node = value;\n  return node !== lastValue ? (tracker.setValue(node), !0) : !1;\n}\nfunction getActiveElement(doc) {\n  doc = doc || ("undefined" !== typeof document ? document : void 0);\n  if ("undefined" === typeof doc) return null;\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\nvar escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n"\\\\]/g;\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\n  return value.replace(\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\n    function (ch) {\n      return "\\\\" + ch.charCodeAt(0).toString(16) + " ";\n    }\n  );\n}\nfunction updateInput(\n  element,\n  value,\n  defaultValue,\n  lastDefaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name\n) {\n  element.name = "";\n  null != type &&\n  "function" !== typeof type &&\n  "symbol" !== typeof type &&\n  "boolean" !== typeof type\n    ? (element.type = type)\n    : element.removeAttribute("type");\n  if (null != value)\n    if ("number" === type) {\n      if ((0 === value && "" === element.value) || element.value != value)\n        element.value = "" + getToStringValue(value);\n    } else\n      element.value !== "" + getToStringValue(value) &&\n        (element.value = "" + getToStringValue(value));\n  else\n    ("submit" !== type && "reset" !== type) || element.removeAttribute("value");\n  null != value\n    ? setDefaultValue(element, type, getToStringValue(value))\n    : null != defaultValue\n      ? setDefaultValue(element, type, getToStringValue(defaultValue))\n      : null != lastDefaultValue && element.removeAttribute("value");\n  null == checked &&\n    null != defaultChecked &&\n    (element.defaultChecked = !!defaultChecked);\n  null != checked &&\n    (element.checked =\n      checked && "function" !== typeof checked && "symbol" !== typeof checked);\n  null != name &&\n  "function" !== typeof name &&\n  "symbol" !== typeof name &&\n  "boolean" !== typeof name\n    ? (element.name = "" + getToStringValue(name))\n    : element.removeAttribute("name");\n}\nfunction initInput(\n  element,\n  value,\n  defaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name,\n  isHydrating\n) {\n  null != type &&\n    "function" !== typeof type &&\n    "symbol" !== typeof type &&\n    "boolean" !== typeof type &&\n    (element.type = type);\n  if (null != value || null != defaultValue) {\n    if (\n      !(\n        ("submit" !== type && "reset" !== type) ||\n        (void 0 !== value && null !== value)\n      )\n    )\n      return;\n    defaultValue =\n      null != defaultValue ? "" + getToStringValue(defaultValue) : "";\n    value = null != value ? "" + getToStringValue(value) : defaultValue;\n    isHydrating || value === element.value || (element.value = value);\n    element.defaultValue = value;\n  }\n  checked = null != checked ? checked : defaultChecked;\n  checked =\n    "function" !== typeof checked && "symbol" !== typeof checked && !!checked;\n  element.checked = isHydrating ? element.checked : !!checked;\n  element.defaultChecked = !!checked;\n  null != name &&\n    "function" !== typeof name &&\n    "symbol" !== typeof name &&\n    "boolean" !== typeof name &&\n    (element.name = name);\n}\nfunction setDefaultValue(node, type, value) {\n  ("number" === type && getActiveElement(node.ownerDocument) === node) ||\n    node.defaultValue === "" + value ||\n    (node.defaultValue = "" + value);\n}\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  node = node.options;\n  if (multiple) {\n    multiple = {};\n    for (var i = 0; i < propValue.length; i++)\n      multiple["$" + propValue[i]] = !0;\n    for (propValue = 0; propValue < node.length; propValue++)\n      (i = multiple.hasOwnProperty("$" + node[propValue].value)),\n        node[propValue].selected !== i && (node[propValue].selected = i),\n        i && setDefaultSelected && (node[propValue].defaultSelected = !0);\n  } else {\n    propValue = "" + getToStringValue(propValue);\n    multiple = null;\n    for (i = 0; i < node.length; i++) {\n      if (node[i].value === propValue) {\n        node[i].selected = !0;\n        setDefaultSelected && (node[i].defaultSelected = !0);\n        return;\n      }\n      null !== multiple || node[i].disabled || (multiple = node[i]);\n    }\n    null !== multiple && (multiple.selected = !0);\n  }\n}\nfunction updateTextarea(element, value, defaultValue) {\n  if (\n    null != value &&\n    ((value = "" + getToStringValue(value)),\n    value !== element.value && (element.value = value),\n    null == defaultValue)\n  ) {\n    element.defaultValue !== value && (element.defaultValue = value);\n    return;\n  }\n  element.defaultValue =\n    null != defaultValue ? "" + getToStringValue(defaultValue) : "";\n}\nfunction initTextarea(element, value, defaultValue, children) {\n  if (null == value) {\n    if (null != children) {\n      if (null != defaultValue) throw Error(formatProdErrorMessage(92));\n      if (isArrayImpl(children)) {\n        if (1 < children.length) throw Error(formatProdErrorMessage(93));\n        children = children[0];\n      }\n      defaultValue = children;\n    }\n    null == defaultValue && (defaultValue = "");\n    value = defaultValue;\n  }\n  defaultValue = getToStringValue(value);\n  element.defaultValue = defaultValue;\n  children = element.textContent;\n  children === defaultValue &&\n    "" !== children &&\n    null !== children &&\n    (element.value = children);\n}\nfunction setTextContent(node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n    if (\n      firstChild &&\n      firstChild === node.lastChild &&\n      3 === firstChild.nodeType\n    ) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n}\nvar unitlessNumbers = new Set(\n  "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(\n    " "\n  )\n);\nfunction setValueForStyle(style, styleName, value) {\n  var isCustomProperty = 0 === styleName.indexOf("--");\n  null == value || "boolean" === typeof value || "" === value\n    ? isCustomProperty\n      ? style.setProperty(styleName, "")\n      : "float" === styleName\n        ? (style.cssFloat = "")\n        : (style[styleName] = "")\n    : isCustomProperty\n      ? style.setProperty(styleName, value)\n      : "number" !== typeof value ||\n          0 === value ||\n          unitlessNumbers.has(styleName)\n        ? "float" === styleName\n          ? (style.cssFloat = value)\n          : (style[styleName] = ("" + value).trim())\n        : (style[styleName] = value + "px");\n}\nfunction setValueForStyles(node, styles, prevStyles) {\n  if (null != styles && "object" !== typeof styles)\n    throw Error(formatProdErrorMessage(62));\n  node = node.style;\n  if (null != prevStyles) {\n    for (var styleName in prevStyles)\n      !prevStyles.hasOwnProperty(styleName) ||\n        (null != styles && styles.hasOwnProperty(styleName)) ||\n        (0 === styleName.indexOf("--")\n          ? node.setProperty(styleName, "")\n          : "float" === styleName\n            ? (node.cssFloat = "")\n            : (node[styleName] = ""));\n    for (var styleName$16 in styles)\n      (styleName = styles[styleName$16]),\n        styles.hasOwnProperty(styleName$16) &&\n          prevStyles[styleName$16] !== styleName &&\n          setValueForStyle(node, styleName$16, styleName);\n  } else\n    for (var styleName$17 in styles)\n      styles.hasOwnProperty(styleName$17) &&\n        setValueForStyle(node, styleName$17, styles[styleName$17]);\n}\nfunction isCustomElement(tagName) {\n  if (-1 === tagName.indexOf("-")) return !1;\n  switch (tagName) {\n    case "annotation-xml":\n    case "color-profile":\n    case "font-face":\n    case "font-face-src":\n    case "font-face-uri":\n    case "font-face-format":\n    case "font-face-name":\n    case "missing-glyph":\n      return !1;\n    default:\n      return !0;\n  }\n}\nvar aliases = new Map([\n    ["acceptCharset", "accept-charset"],\n    ["htmlFor", "for"],\n    ["httpEquiv", "http-equiv"],\n    ["crossOrigin", "crossorigin"],\n    ["accentHeight", "accent-height"],\n    ["alignmentBaseline", "alignment-baseline"],\n    ["arabicForm", "arabic-form"],\n    ["baselineShift", "baseline-shift"],\n    ["capHeight", "cap-height"],\n    ["clipPath", "clip-path"],\n    ["clipRule", "clip-rule"],\n    ["colorInterpolation", "color-interpolation"],\n    ["colorInterpolationFilters", "color-interpolation-filters"],\n    ["colorProfile", "color-profile"],\n    ["colorRendering", "color-rendering"],\n    ["dominantBaseline", "dominant-baseline"],\n    ["enableBackground", "enable-background"],\n    ["fillOpacity", "fill-opacity"],\n    ["fillRule", "fill-rule"],\n    ["floodColor", "flood-color"],\n    ["floodOpacity", "flood-opacity"],\n    ["fontFamily", "font-family"],\n    ["fontSize", "font-size"],\n    ["fontSizeAdjust", "font-size-adjust"],\n    ["fontStretch", "font-stretch"],\n    ["fontStyle", "font-style"],\n    ["fontVariant", "font-variant"],\n    ["fontWeight", "font-weight"],\n    ["glyphName", "glyph-name"],\n    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],\n    ["glyphOrientationVertical", "glyph-orientation-vertical"],\n    ["horizAdvX", "horiz-adv-x"],\n    ["horizOriginX", "horiz-origin-x"],\n    ["imageRendering", "image-rendering"],\n    ["letterSpacing", "letter-spacing"],\n    ["lightingColor", "lighting-color"],\n    ["markerEnd", "marker-end"],\n    ["markerMid", "marker-mid"],\n    ["markerStart", "marker-start"],\n    ["overlinePosition", "overline-position"],\n    ["overlineThickness", "overline-thickness"],\n    ["paintOrder", "paint-order"],\n    ["panose-1", "panose-1"],\n    ["pointerEvents", "pointer-events"],\n    ["renderingIntent", "rendering-intent"],\n    ["shapeRendering", "shape-rendering"],\n    ["stopColor", "stop-color"],\n    ["stopOpacity", "stop-opacity"],\n    ["strikethroughPosition", "strikethrough-position"],\n    ["strikethroughThickness", "strikethrough-thickness"],\n    ["strokeDasharray", "stroke-dasharray"],\n    ["strokeDashoffset", "stroke-dashoffset"],\n    ["strokeLinecap", "stroke-linecap"],\n    ["strokeLinejoin", "stroke-linejoin"],\n    ["strokeMiterlimit", "stroke-miterlimit"],\n    ["strokeOpacity", "stroke-opacity"],\n    ["strokeWidth", "stroke-width"],\n    ["textAnchor", "text-anchor"],\n    ["textDecoration", "text-decoration"],\n    ["textRendering", "text-rendering"],\n    ["transformOrigin", "transform-origin"],\n    ["underlinePosition", "underline-position"],\n    ["underlineThickness", "underline-thickness"],\n    ["unicodeBidi", "unicode-bidi"],\n    ["unicodeRange", "unicode-range"],\n    ["unitsPerEm", "units-per-em"],\n    ["vAlphabetic", "v-alphabetic"],\n    ["vHanging", "v-hanging"],\n    ["vIdeographic", "v-ideographic"],\n    ["vMathematical", "v-mathematical"],\n    ["vectorEffect", "vector-effect"],\n    ["vertAdvY", "vert-adv-y"],\n    ["vertOriginX", "vert-origin-x"],\n    ["vertOriginY", "vert-origin-y"],\n    ["wordSpacing", "word-spacing"],\n    ["writingMode", "writing-mode"],\n    ["xmlnsXlink", "xmlns:xlink"],\n    ["xHeight", "x-height"]\n  ]),\n  isJavaScriptProtocol =\n    /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i;\nfunction sanitizeURL(url) {\n  return isJavaScriptProtocol.test("" + url)\n    ? "javascript:throw new Error(\'React has blocked a javascript: URL as a security precaution.\')"\n    : url;\n}\nvar currentReplayingEvent = null;\nfunction getEventTarget(nativeEvent) {\n  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\n  nativeEvent.correspondingUseElement &&\n    (nativeEvent = nativeEvent.correspondingUseElement);\n  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\n}\nvar restoreTarget = null,\n  restoreQueue = null;\nfunction restoreStateOfTarget(target) {\n  var internalInstance = getInstanceFromNode(target);\n  if (internalInstance && (target = internalInstance.stateNode)) {\n    var props = target[internalPropsKey] || null;\n    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {\n      case "input":\n        updateInput(\n          target,\n          props.value,\n          props.defaultValue,\n          props.defaultValue,\n          props.checked,\n          props.defaultChecked,\n          props.type,\n          props.name\n        );\n        internalInstance = props.name;\n        if ("radio" === props.type && null != internalInstance) {\n          for (props = target; props.parentNode; ) props = props.parentNode;\n          props = props.querySelectorAll(\n            \'input[name="\' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                "" + internalInstance\n              ) +\n              \'"][type="radio"]\'\n          );\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          ) {\n            var otherNode = props[internalInstance];\n            if (otherNode !== target && otherNode.form === target.form) {\n              var otherProps = otherNode[internalPropsKey] || null;\n              if (!otherProps) throw Error(formatProdErrorMessage(90));\n              updateInput(\n                otherNode,\n                otherProps.value,\n                otherProps.defaultValue,\n                otherProps.defaultValue,\n                otherProps.checked,\n                otherProps.defaultChecked,\n                otherProps.type,\n                otherProps.name\n              );\n            }\n          }\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          )\n            (otherNode = props[internalInstance]),\n              otherNode.form === target.form && updateValueIfChanged(otherNode);\n        }\n        break a;\n      case "textarea":\n        updateTextarea(target, props.value, props.defaultValue);\n        break a;\n      case "select":\n        (internalInstance = props.value),\n          null != internalInstance &&\n            updateOptions(target, !!props.multiple, internalInstance, !1);\n    }\n  }\n}\nvar isInsideEventHandler = !1;\nfunction batchedUpdates$1(fn, a, b) {\n  if (isInsideEventHandler) return fn(a, b);\n  isInsideEventHandler = !0;\n  try {\n    var JSCompiler_inline_result = fn(a);\n    return JSCompiler_inline_result;\n  } finally {\n    if (\n      ((isInsideEventHandler = !1),\n      null !== restoreTarget || null !== restoreQueue)\n    )\n      if (\n        (flushSyncWork$1(),\n        restoreTarget &&\n          ((a = restoreTarget),\n          (fn = restoreQueue),\n          (restoreQueue = restoreTarget = null),\n          restoreStateOfTarget(a),\n          fn))\n      )\n        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);\n  }\n}\nfunction getListener(inst, registrationName) {\n  var stateNode = inst.stateNode;\n  if (null === stateNode) return null;\n  var props = stateNode[internalPropsKey] || null;\n  if (null === props) return null;\n  stateNode = props[registrationName];\n  a: switch (registrationName) {\n    case "onClick":\n    case "onClickCapture":\n    case "onDoubleClick":\n    case "onDoubleClickCapture":\n    case "onMouseDown":\n    case "onMouseDownCapture":\n    case "onMouseMove":\n    case "onMouseMoveCapture":\n    case "onMouseUp":\n    case "onMouseUpCapture":\n    case "onMouseEnter":\n      (props = !props.disabled) ||\n        ((inst = inst.type),\n        (props = !(\n          "button" === inst ||\n          "input" === inst ||\n          "select" === inst ||\n          "textarea" === inst\n        )));\n      inst = !props;\n      break a;\n    default:\n      inst = !1;\n  }\n  if (inst) return null;\n  if (stateNode && "function" !== typeof stateNode)\n    throw Error(\n      formatProdErrorMessage(231, registrationName, typeof stateNode)\n    );\n  return stateNode;\n}\nvar passiveBrowserEventsSupported = !1;\nif (canUseDOM)\n  try {\n    var options = {};\n    Object.defineProperty(options, "passive", {\n      get: function () {\n        passiveBrowserEventsSupported = !0;\n      }\n    });\n    window.addEventListener("test", options, options);\n    window.removeEventListener("test", options, options);\n  } catch (e) {\n    passiveBrowserEventsSupported = !1;\n  }\nvar root = null,\n  startText = null,\n  fallbackText = null;\nfunction getData() {\n  if (fallbackText) return fallbackText;\n  var start,\n    startValue = startText,\n    startLength = startValue.length,\n    end,\n    endValue = "value" in root ? root.value : root.textContent,\n    endLength = endValue.length;\n  for (\n    start = 0;\n    start < startLength && startValue[start] === endValue[start];\n    start++\n  );\n  var minEnd = startLength - start;\n  for (\n    end = 1;\n    end <= minEnd &&\n    startValue[startLength - end] === endValue[endLength - end];\n    end++\n  );\n  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));\n}\nfunction getEventCharCode(nativeEvent) {\n  var keyCode = nativeEvent.keyCode;\n  "charCode" in nativeEvent\n    ? ((nativeEvent = nativeEvent.charCode),\n      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))\n    : (nativeEvent = keyCode);\n  10 === nativeEvent && (nativeEvent = 13);\n  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\n}\nfunction functionThatReturnsTrue() {\n  return !0;\n}\nfunction functionThatReturnsFalse() {\n  return !1;\n}\nfunction createSyntheticEvent(Interface) {\n  function SyntheticBaseEvent(\n    reactName,\n    reactEventType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    this._reactName = reactName;\n    this._targetInst = targetInst;\n    this.type = reactEventType;\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEventTarget;\n    this.currentTarget = null;\n    for (var propName in Interface)\n      Interface.hasOwnProperty(propName) &&\n        ((reactName = Interface[propName]),\n        (this[propName] = reactName\n          ? reactName(nativeEvent)\n          : nativeEvent[propName]));\n    this.isDefaultPrevented = (\n      null != nativeEvent.defaultPrevented\n        ? nativeEvent.defaultPrevented\n        : !1 === nativeEvent.returnValue\n    )\n      ? functionThatReturnsTrue\n      : functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    return this;\n  }\n  assign(SyntheticBaseEvent.prototype, {\n    preventDefault: function () {\n      this.defaultPrevented = !0;\n      var event = this.nativeEvent;\n      event &&\n        (event.preventDefault\n          ? event.preventDefault()\n          : "unknown" !== typeof event.returnValue && (event.returnValue = !1),\n        (this.isDefaultPrevented = functionThatReturnsTrue));\n    },\n    stopPropagation: function () {\n      var event = this.nativeEvent;\n      event &&\n        (event.stopPropagation\n          ? event.stopPropagation()\n          : "unknown" !== typeof event.cancelBubble &&\n            (event.cancelBubble = !0),\n        (this.isPropagationStopped = functionThatReturnsTrue));\n    },\n    persist: function () {},\n    isPersistent: functionThatReturnsTrue\n  });\n  return SyntheticBaseEvent;\n}\nvar EventInterface = {\n    eventPhase: 0,\n    bubbles: 0,\n    cancelable: 0,\n    timeStamp: function (event) {\n      return event.timeStamp || Date.now();\n    },\n    defaultPrevented: 0,\n    isTrusted: 0\n  },\n  SyntheticEvent = createSyntheticEvent(EventInterface),\n  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),\n  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),\n  lastMovementX,\n  lastMovementY,\n  lastMouseEvent,\n  MouseEventInterface = assign({}, UIEventInterface, {\n    screenX: 0,\n    screenY: 0,\n    clientX: 0,\n    clientY: 0,\n    pageX: 0,\n    pageY: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    getModifierState: getEventModifierState,\n    button: 0,\n    buttons: 0,\n    relatedTarget: function (event) {\n      return void 0 === event.relatedTarget\n        ? event.fromElement === event.srcElement\n          ? event.toElement\n          : event.fromElement\n        : event.relatedTarget;\n    },\n    movementX: function (event) {\n      if ("movementX" in event) return event.movementX;\n      event !== lastMouseEvent &&\n        (lastMouseEvent && "mousemove" === event.type\n          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),\n            (lastMovementY = event.screenY - lastMouseEvent.screenY))\n          : (lastMovementY = lastMovementX = 0),\n        (lastMouseEvent = event));\n      return lastMovementX;\n    },\n    movementY: function (event) {\n      return "movementY" in event ? event.movementY : lastMovementY;\n    }\n  }),\n  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),\n  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),\n  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),\n  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),\n  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),\n  AnimationEventInterface = assign({}, EventInterface, {\n    animationName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),\n  ClipboardEventInterface = assign({}, EventInterface, {\n    clipboardData: function (event) {\n      return "clipboardData" in event\n        ? event.clipboardData\n        : window.clipboardData;\n    }\n  }),\n  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),\n  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),\n  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),\n  normalizeKey = {\n    Esc: "Escape",\n    Spacebar: " ",\n    Left: "ArrowLeft",\n    Up: "ArrowUp",\n    Right: "ArrowRight",\n    Down: "ArrowDown",\n    Del: "Delete",\n    Win: "OS",\n    Menu: "ContextMenu",\n    Apps: "ContextMenu",\n    Scroll: "ScrollLock",\n    MozPrintableKey: "Unidentified"\n  },\n  translateToKey = {\n    8: "Backspace",\n    9: "Tab",\n    12: "Clear",\n    13: "Enter",\n    16: "Shift",\n    17: "Control",\n    18: "Alt",\n    19: "Pause",\n    20: "CapsLock",\n    27: "Escape",\n    32: " ",\n    33: "PageUp",\n    34: "PageDown",\n    35: "End",\n    36: "Home",\n    37: "ArrowLeft",\n    38: "ArrowUp",\n    39: "ArrowRight",\n    40: "ArrowDown",\n    45: "Insert",\n    46: "Delete",\n    112: "F1",\n    113: "F2",\n    114: "F3",\n    115: "F4",\n    116: "F5",\n    117: "F6",\n    118: "F7",\n    119: "F8",\n    120: "F9",\n    121: "F10",\n    122: "F11",\n    123: "F12",\n    144: "NumLock",\n    145: "ScrollLock",\n    224: "Meta"\n  },\n  modifierKeyToProp = {\n    Alt: "altKey",\n    Control: "ctrlKey",\n    Meta: "metaKey",\n    Shift: "shiftKey"\n  };\nfunction modifierStateGetter(keyArg) {\n  var nativeEvent = this.nativeEvent;\n  return nativeEvent.getModifierState\n    ? nativeEvent.getModifierState(keyArg)\n    : (keyArg = modifierKeyToProp[keyArg])\n      ? !!nativeEvent[keyArg]\n      : !1;\n}\nfunction getEventModifierState() {\n  return modifierStateGetter;\n}\nvar KeyboardEventInterface = assign({}, UIEventInterface, {\n    key: function (nativeEvent) {\n      if (nativeEvent.key) {\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n        if ("Unidentified" !== key) return key;\n      }\n      return "keypress" === nativeEvent.type\n        ? ((nativeEvent = getEventCharCode(nativeEvent)),\n          13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent))\n        : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type\n          ? translateToKey[nativeEvent.keyCode] || "Unidentified"\n          : "";\n    },\n    code: 0,\n    location: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    repeat: 0,\n    locale: 0,\n    getModifierState: getEventModifierState,\n    charCode: function (event) {\n      return "keypress" === event.type ? getEventCharCode(event) : 0;\n    },\n    keyCode: function (event) {\n      return "keydown" === event.type || "keyup" === event.type\n        ? event.keyCode\n        : 0;\n    },\n    which: function (event) {\n      return "keypress" === event.type\n        ? getEventCharCode(event)\n        : "keydown" === event.type || "keyup" === event.type\n          ? event.keyCode\n          : 0;\n    }\n  }),\n  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),\n  PointerEventInterface = assign({}, MouseEventInterface, {\n    pointerId: 0,\n    width: 0,\n    height: 0,\n    pressure: 0,\n    tangentialPressure: 0,\n    tiltX: 0,\n    tiltY: 0,\n    twist: 0,\n    pointerType: 0,\n    isPrimary: 0\n  }),\n  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),\n  TouchEventInterface = assign({}, UIEventInterface, {\n    touches: 0,\n    targetTouches: 0,\n    changedTouches: 0,\n    altKey: 0,\n    metaKey: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    getModifierState: getEventModifierState\n  }),\n  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),\n  TransitionEventInterface = assign({}, EventInterface, {\n    propertyName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),\n  WheelEventInterface = assign({}, MouseEventInterface, {\n    deltaX: function (event) {\n      return "deltaX" in event\n        ? event.deltaX\n        : "wheelDeltaX" in event\n          ? -event.wheelDeltaX\n          : 0;\n    },\n    deltaY: function (event) {\n      return "deltaY" in event\n        ? event.deltaY\n        : "wheelDeltaY" in event\n          ? -event.wheelDeltaY\n          : "wheelDelta" in event\n            ? -event.wheelDelta\n            : 0;\n    },\n    deltaZ: 0,\n    deltaMode: 0\n  }),\n  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),\n  ToggleEventInterface = assign({}, EventInterface, {\n    newState: 0,\n    oldState: 0\n  }),\n  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),\n  END_KEYCODES = [9, 13, 27, 32],\n  canUseCompositionEvent = canUseDOM && "CompositionEvent" in window,\n  documentMode = null;\ncanUseDOM &&\n  "documentMode" in document &&\n  (documentMode = document.documentMode);\nvar canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode,\n  useFallbackCompositionData =\n    canUseDOM &&\n    (!canUseCompositionEvent ||\n      (documentMode && 8 < documentMode && 11 >= documentMode)),\n  SPACEBAR_CHAR = String.fromCharCode(32),\n  hasSpaceKeypress = !1;\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case "keyup":\n      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\n    case "keydown":\n      return 229 !== nativeEvent.keyCode;\n    case "keypress":\n    case "mousedown":\n    case "focusout":\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction getDataFromCustomEvent(nativeEvent) {\n  nativeEvent = nativeEvent.detail;\n  return "object" === typeof nativeEvent && "data" in nativeEvent\n    ? nativeEvent.data\n    : null;\n}\nvar isComposing = !1;\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case "compositionend":\n      return getDataFromCustomEvent(nativeEvent);\n    case "keypress":\n      if (32 !== nativeEvent.which) return null;\n      hasSpaceKeypress = !0;\n      return SPACEBAR_CHAR;\n    case "textInput":\n      return (\n        (domEventName = nativeEvent.data),\n        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName\n      );\n    default:\n      return null;\n  }\n}\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\n  if (isComposing)\n    return "compositionend" === domEventName ||\n      (!canUseCompositionEvent &&\n        isFallbackCompositionEnd(domEventName, nativeEvent))\n      ? ((domEventName = getData()),\n        (fallbackText = startText = root = null),\n        (isComposing = !1),\n        domEventName)\n      : null;\n  switch (domEventName) {\n    case "paste":\n      return null;\n    case "keypress":\n      if (\n        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||\n        (nativeEvent.ctrlKey && nativeEvent.altKey)\n      ) {\n        if (nativeEvent.char && 1 < nativeEvent.char.length)\n          return nativeEvent.char;\n        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\n      }\n      return null;\n    case "compositionend":\n      return useFallbackCompositionData && "ko" !== nativeEvent.locale\n        ? null\n        : nativeEvent.data;\n    default:\n      return null;\n  }\n}\nvar supportedInputTypes = {\n  color: !0,\n  date: !0,\n  datetime: !0,\n  "datetime-local": !0,\n  email: !0,\n  month: !0,\n  number: !0,\n  password: !0,\n  range: !0,\n  search: !0,\n  tel: !0,\n  text: !0,\n  time: !0,\n  url: !0,\n  week: !0\n};\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return "input" === nodeName\n    ? !!supportedInputTypes[elem.type]\n    : "textarea" === nodeName\n      ? !0\n      : !1;\n}\nfunction createAndAccumulateChangeEvent(\n  dispatchQueue,\n  inst,\n  nativeEvent,\n  target\n) {\n  restoreTarget\n    ? restoreQueue\n      ? restoreQueue.push(target)\n      : (restoreQueue = [target])\n    : (restoreTarget = target);\n  inst = accumulateTwoPhaseListeners(inst, "onChange");\n  0 < inst.length &&\n    ((nativeEvent = new SyntheticEvent(\n      "onChange",\n      "change",\n      null,\n      nativeEvent,\n      target\n    )),\n    dispatchQueue.push({ event: nativeEvent, listeners: inst }));\n}\nvar activeElement$1 = null,\n  activeElementInst$1 = null;\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance(targetInst);\n  if (updateValueIfChanged(targetNode)) return targetInst;\n}\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\n  if ("change" === domEventName) return targetInst;\n}\nvar isInputEventSupported = !1;\nif (canUseDOM) {\n  var JSCompiler_inline_result$jscomp$283;\n  if (canUseDOM) {\n    var isSupported$jscomp$inline_418 = "oninput" in document;\n    if (!isSupported$jscomp$inline_418) {\n      var element$jscomp$inline_419 = document.createElement("div");\n      element$jscomp$inline_419.setAttribute("oninput", "return;");\n      isSupported$jscomp$inline_418 =\n        "function" === typeof element$jscomp$inline_419.oninput;\n    }\n    JSCompiler_inline_result$jscomp$283 = isSupported$jscomp$inline_418;\n  } else JSCompiler_inline_result$jscomp$283 = !1;\n  isInputEventSupported =\n    JSCompiler_inline_result$jscomp$283 &&\n    (!document.documentMode || 9 < document.documentMode);\n}\nfunction stopWatchingForValueChange() {\n  activeElement$1 &&\n    (activeElement$1.detachEvent("onpropertychange", handlePropertyChange),\n    (activeElementInst$1 = activeElement$1 = null));\n}\nfunction handlePropertyChange(nativeEvent) {\n  if (\n    "value" === nativeEvent.propertyName &&\n    getInstIfValueChanged(activeElementInst$1)\n  ) {\n    var dispatchQueue = [];\n    createAndAccumulateChangeEvent(\n      dispatchQueue,\n      activeElementInst$1,\n      nativeEvent,\n      getEventTarget(nativeEvent)\n    );\n    batchedUpdates$1(runEventInBatch, dispatchQueue);\n  }\n}\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n  "focusin" === domEventName\n    ? (stopWatchingForValueChange(),\n      (activeElement$1 = target),\n      (activeElementInst$1 = targetInst),\n      activeElement$1.attachEvent("onpropertychange", handlePropertyChange))\n    : "focusout" === domEventName && stopWatchingForValueChange();\n}\nfunction getTargetInstForInputEventPolyfill(domEventName) {\n  if (\n    "selectionchange" === domEventName ||\n    "keyup" === domEventName ||\n    "keydown" === domEventName\n  )\n    return getInstIfValueChanged(activeElementInst$1);\n}\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\n  if ("click" === domEventName) return getInstIfValueChanged(targetInst);\n}\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n  if ("input" === domEventName || "change" === domEventName)\n    return getInstIfValueChanged(targetInst);\n}\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = "function" === typeof Object.is ? Object.is : is;\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) return !0;\n  if (\n    "object" !== typeof objA ||\n    null === objA ||\n    "object" !== typeof objB ||\n    null === objB\n  )\n    return !1;\n  var keysA = Object.keys(objA),\n    keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return !1;\n  for (keysB = 0; keysB < keysA.length; keysB++) {\n    var currentKey = keysA[keysB];\n    if (\n      !hasOwnProperty.call(objB, currentKey) ||\n      !objectIs(objA[currentKey], objB[currentKey])\n    )\n      return !1;\n  }\n  return !0;\n}\nfunction getLeafNode(node) {\n  for (; node && node.firstChild; ) node = node.firstChild;\n  return node;\n}\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  root = 0;\n  for (var nodeEnd; node; ) {\n    if (3 === node.nodeType) {\n      nodeEnd = root + node.textContent.length;\n      if (root <= offset && nodeEnd >= offset)\n        return { node: node, offset: offset - root };\n      root = nodeEnd;\n    }\n    a: {\n      for (; node; ) {\n        if (node.nextSibling) {\n          node = node.nextSibling;\n          break a;\n        }\n        node = node.parentNode;\n      }\n      node = void 0;\n    }\n    node = getLeafNode(node);\n  }\n}\nfunction containsNode(outerNode, innerNode) {\n  return outerNode && innerNode\n    ? outerNode === innerNode\n      ? !0\n      : outerNode && 3 === outerNode.nodeType\n        ? !1\n        : innerNode && 3 === innerNode.nodeType\n          ? containsNode(outerNode, innerNode.parentNode)\n          : "contains" in outerNode\n            ? outerNode.contains(innerNode)\n            : outerNode.compareDocumentPosition\n              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)\n              : !1\n    : !1;\n}\nfunction getActiveElementDeep(containerInfo) {\n  containerInfo =\n    null != containerInfo &&\n    null != containerInfo.ownerDocument &&\n    null != containerInfo.ownerDocument.defaultView\n      ? containerInfo.ownerDocument.defaultView\n      : window;\n  for (\n    var element = getActiveElement(containerInfo.document);\n    element instanceof containerInfo.HTMLIFrameElement;\n\n  ) {\n    try {\n      var JSCompiler_inline_result =\n        "string" === typeof element.contentWindow.location.href;\n    } catch (err) {\n      JSCompiler_inline_result = !1;\n    }\n    if (JSCompiler_inline_result) containerInfo = element.contentWindow;\n    else break;\n    element = getActiveElement(containerInfo.document);\n  }\n  return element;\n}\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName &&\n    (("input" === nodeName &&\n      ("text" === elem.type ||\n        "search" === elem.type ||\n        "tel" === elem.type ||\n        "url" === elem.type ||\n        "password" === elem.type)) ||\n      "textarea" === nodeName ||\n      "true" === elem.contentEditable)\n  );\n}\nfunction restoreSelection(priorSelectionInformation, containerInfo) {\n  var curFocusedElem = getActiveElementDeep(containerInfo);\n  containerInfo = priorSelectionInformation.focusedElem;\n  var priorSelectionRange = priorSelectionInformation.selectionRange;\n  if (\n    curFocusedElem !== containerInfo &&\n    containerInfo &&\n    containerInfo.ownerDocument &&\n    containsNode(containerInfo.ownerDocument.documentElement, containerInfo)\n  ) {\n    if (null !== priorSelectionRange && hasSelectionCapabilities(containerInfo))\n      if (\n        ((priorSelectionInformation = priorSelectionRange.start),\n        (curFocusedElem = priorSelectionRange.end),\n        void 0 === curFocusedElem &&\n          (curFocusedElem = priorSelectionInformation),\n        "selectionStart" in containerInfo)\n      )\n        (containerInfo.selectionStart = priorSelectionInformation),\n          (containerInfo.selectionEnd = Math.min(\n            curFocusedElem,\n            containerInfo.value.length\n          ));\n      else if (\n        ((curFocusedElem =\n          ((priorSelectionInformation =\n            containerInfo.ownerDocument || document) &&\n            priorSelectionInformation.defaultView) ||\n          window),\n        curFocusedElem.getSelection)\n      ) {\n        curFocusedElem = curFocusedElem.getSelection();\n        var length = containerInfo.textContent.length,\n          start = Math.min(priorSelectionRange.start, length);\n        priorSelectionRange =\n          void 0 === priorSelectionRange.end\n            ? start\n            : Math.min(priorSelectionRange.end, length);\n        !curFocusedElem.extend &&\n          start > priorSelectionRange &&\n          ((length = priorSelectionRange),\n          (priorSelectionRange = start),\n          (start = length));\n        length = getNodeForCharacterOffset(containerInfo, start);\n        var endMarker = getNodeForCharacterOffset(\n          containerInfo,\n          priorSelectionRange\n        );\n        length &&\n          endMarker &&\n          (1 !== curFocusedElem.rangeCount ||\n            curFocusedElem.anchorNode !== length.node ||\n            curFocusedElem.anchorOffset !== length.offset ||\n            curFocusedElem.focusNode !== endMarker.node ||\n            curFocusedElem.focusOffset !== endMarker.offset) &&\n          ((priorSelectionInformation =\n            priorSelectionInformation.createRange()),\n          priorSelectionInformation.setStart(length.node, length.offset),\n          curFocusedElem.removeAllRanges(),\n          start > priorSelectionRange\n            ? (curFocusedElem.addRange(priorSelectionInformation),\n              curFocusedElem.extend(endMarker.node, endMarker.offset))\n            : (priorSelectionInformation.setEnd(\n                endMarker.node,\n                endMarker.offset\n              ),\n              curFocusedElem.addRange(priorSelectionInformation)));\n      }\n    priorSelectionInformation = [];\n    for (\n      curFocusedElem = containerInfo;\n      (curFocusedElem = curFocusedElem.parentNode);\n\n    )\n      1 === curFocusedElem.nodeType &&\n        priorSelectionInformation.push({\n          element: curFocusedElem,\n          left: curFocusedElem.scrollLeft,\n          top: curFocusedElem.scrollTop\n        });\n    "function" === typeof containerInfo.focus && containerInfo.focus();\n    for (\n      containerInfo = 0;\n      containerInfo < priorSelectionInformation.length;\n      containerInfo++\n    )\n      (curFocusedElem = priorSelectionInformation[containerInfo]),\n        (curFocusedElem.element.scrollLeft = curFocusedElem.left),\n        (curFocusedElem.element.scrollTop = curFocusedElem.top);\n  }\n}\nvar skipSelectionChangeEvent =\n    canUseDOM && "documentMode" in document && 11 >= document.documentMode,\n  activeElement = null,\n  activeElementInst = null,\n  lastSelection = null,\n  mouseDown = !1;\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  var doc =\n    nativeEventTarget.window === nativeEventTarget\n      ? nativeEventTarget.document\n      : 9 === nativeEventTarget.nodeType\n        ? nativeEventTarget\n        : nativeEventTarget.ownerDocument;\n  mouseDown ||\n    null == activeElement ||\n    activeElement !== getActiveElement(doc) ||\n    ((doc = activeElement),\n    "selectionStart" in doc && hasSelectionCapabilities(doc)\n      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })\n      : ((doc = (\n          (doc.ownerDocument && doc.ownerDocument.defaultView) ||\n          window\n        ).getSelection()),\n        (doc = {\n          anchorNode: doc.anchorNode,\n          anchorOffset: doc.anchorOffset,\n          focusNode: doc.focusNode,\n          focusOffset: doc.focusOffset\n        })),\n    (lastSelection && shallowEqual(lastSelection, doc)) ||\n      ((lastSelection = doc),\n      (doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect")),\n      0 < doc.length &&\n        ((nativeEvent = new SyntheticEvent(\n          "onSelect",\n          "select",\n          null,\n          nativeEvent,\n          nativeEventTarget\n        )),\n        dispatchQueue.push({ event: nativeEvent, listeners: doc }),\n        (nativeEvent.target = activeElement))));\n}\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes["Webkit" + styleProp] = "webkit" + eventName;\n  prefixes["Moz" + styleProp] = "moz" + eventName;\n  return prefixes;\n}\nvar vendorPrefixes = {\n    animationend: makePrefixMap("Animation", "AnimationEnd"),\n    animationiteration: makePrefixMap("Animation", "AnimationIteration"),\n    animationstart: makePrefixMap("Animation", "AnimationStart"),\n    transitionrun: makePrefixMap("Transition", "TransitionRun"),\n    transitionstart: makePrefixMap("Transition", "TransitionStart"),\n    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),\n    transitionend: makePrefixMap("Transition", "TransitionEnd")\n  },\n  prefixedEventNames = {},\n  style = {};\ncanUseDOM &&\n  ((style = document.createElement("div").style),\n  "AnimationEvent" in window ||\n    (delete vendorPrefixes.animationend.animation,\n    delete vendorPrefixes.animationiteration.animation,\n    delete vendorPrefixes.animationstart.animation),\n  "TransitionEvent" in window ||\n    delete vendorPrefixes.transitionend.transition);\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\n  if (!vendorPrefixes[eventName]) return eventName;\n  var prefixMap = vendorPrefixes[eventName],\n    styleProp;\n  for (styleProp in prefixMap)\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\n  return eventName;\n}\nvar ANIMATION_END = getVendorPrefixedEventName("animationend"),\n  ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"),\n  ANIMATION_START = getVendorPrefixedEventName("animationstart"),\n  TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"),\n  TRANSITION_START = getVendorPrefixedEventName("transitionstart"),\n  TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"),\n  TRANSITION_END = getVendorPrefixedEventName("transitionend"),\n  topLevelEventsToReactNames = new Map(),\n  simpleEventPluginEvents =\n    "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll scrollEnd toggle touchMove waiting wheel".split(\n      " "\n    );\nfunction registerSimpleEvent(domEventName, reactName) {\n  topLevelEventsToReactNames.set(domEventName, reactName);\n  registerTwoPhaseEvent(reactName, [domEventName]);\n}\nvar concurrentQueues = [],\n  concurrentQueuesIndex = 0,\n  concurrentlyUpdatedLanes = 0;\nfunction finishQueueingConcurrentUpdates() {\n  for (\n    var endIndex = concurrentQueuesIndex,\n      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);\n    i < endIndex;\n\n  ) {\n    var fiber = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var queue = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var update = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var lane = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    if (null !== queue && null !== update) {\n      var pending = queue.pending;\n      null === pending\n        ? (update.next = update)\n        : ((update.next = pending.next), (pending.next = update));\n      queue.pending = update;\n    }\n    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n  }\n}\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n  concurrentlyUpdatedLanes |= lane;\n  fiber.lanes |= lane;\n  fiber = fiber.alternate;\n  null !== fiber && (fiber.lanes |= lane);\n}\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  enqueueUpdate$1(fiber, queue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\n  enqueueUpdate$1(fiber, null, null, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n  sourceFiber.lanes |= lane;\n  var alternate = sourceFiber.alternate;\n  null !== alternate && (alternate.lanes |= lane);\n  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )\n    (parent.childLanes |= lane),\n      (alternate = parent.alternate),\n      null !== alternate && (alternate.childLanes |= lane),\n      22 === parent.tag &&\n        ((sourceFiber = parent.stateNode),\n        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),\n      (sourceFiber = parent),\n      (parent = parent.return);\n  isHidden &&\n    null !== update &&\n    3 === sourceFiber.tag &&\n    ((parent = sourceFiber.stateNode),\n    (isHidden = 31 - clz32(lane)),\n    (parent = parent.hiddenUpdates),\n    (sourceFiber = parent[isHidden]),\n    null === sourceFiber\n      ? (parent[isHidden] = [update])\n      : sourceFiber.push(update),\n    (update.lane = lane | 536870912));\n}\nfunction getRootForUpdatedFiber(sourceFiber) {\n  if (50 < nestedUpdateCount)\n    throw (\n      ((nestedUpdateCount = 0),\n      (rootWithNestedUpdates = null),\n      Error(formatProdErrorMessage(185)))\n    );\n  for (var parent = sourceFiber.return; null !== parent; )\n    (sourceFiber = parent), (parent = sourceFiber.return);\n  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;\n}\nvar emptyContextObject = {},\n  CapturedStacks = new WeakMap();\nfunction createCapturedValueAtFiber(value, source) {\n  if ("object" === typeof value && null !== value) {\n    var existing = CapturedStacks.get(value);\n    if (void 0 !== existing) return existing;\n    source = {\n      value: value,\n      source: source,\n      stack: getStackByFiberInDevAndProd(source)\n    };\n    CapturedStacks.set(value, source);\n    return source;\n  }\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\nvar forkStack = [],\n  forkStackIndex = 0,\n  treeForkProvider = null,\n  treeForkCount = 0,\n  idStack = [],\n  idStackIndex = 0,\n  treeContextProvider = null,\n  treeContextId = 1,\n  treeContextOverflow = "";\nfunction pushTreeFork(workInProgress, totalChildren) {\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  workInProgress = treeContextOverflow;\n  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n  baseIdWithLeadingBit &= ~(1 << baseLength);\n  index += 1;\n  var length = 32 - clz32(totalChildren) + baseLength;\n  if (30 < length) {\n    var numberOfOverflowBits = baseLength - (baseLength % 5);\n    length = (\n      baseIdWithLeadingBit &\n      ((1 << numberOfOverflowBits) - 1)\n    ).toString(32);\n    baseIdWithLeadingBit >>= numberOfOverflowBits;\n    baseLength -= numberOfOverflowBits;\n    treeContextId =\n      (1 << (32 - clz32(totalChildren) + baseLength)) |\n      (index << baseLength) |\n      baseIdWithLeadingBit;\n    treeContextOverflow = length + workInProgress;\n  } else\n    (treeContextId =\n      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),\n      (treeContextOverflow = workInProgress);\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  null !== workInProgress.return &&\n    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n}\nfunction popTreeContext(workInProgress) {\n  for (; workInProgress === treeForkProvider; )\n    (treeForkProvider = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null),\n      (treeForkCount = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null);\n  for (; workInProgress === treeContextProvider; )\n    (treeContextProvider = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextOverflow = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextId = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null);\n}\nvar hydrationParentFiber = null,\n  nextHydratableInstance = null,\n  isHydrating = !1,\n  hydrationErrors = null,\n  rootOrSingletonContext = !1,\n  HydrationMismatchException = Error(formatProdErrorMessage(519));\nfunction throwOnHydrationMismatch(fiber) {\n  var error = Error(formatProdErrorMessage(418, ""));\n  queueHydrationError(createCapturedValueAtFiber(error, fiber));\n  throw HydrationMismatchException;\n}\nfunction prepareToHydrateHostInstance(fiber) {\n  var instance = fiber.stateNode,\n    type = fiber.type,\n    props = fiber.memoizedProps;\n  instance[internalInstanceKey] = fiber;\n  instance[internalPropsKey] = props;\n  switch (type) {\n    case "dialog":\n      listenToNonDelegatedEvent("cancel", instance);\n      listenToNonDelegatedEvent("close", instance);\n      break;\n    case "iframe":\n    case "object":\n    case "embed":\n      listenToNonDelegatedEvent("load", instance);\n      break;\n    case "video":\n    case "audio":\n      for (type = 0; type < mediaEventTypes.length; type++)\n        listenToNonDelegatedEvent(mediaEventTypes[type], instance);\n      break;\n    case "source":\n      listenToNonDelegatedEvent("error", instance);\n      break;\n    case "img":\n    case "image":\n    case "link":\n      listenToNonDelegatedEvent("error", instance);\n      listenToNonDelegatedEvent("load", instance);\n      break;\n    case "details":\n      listenToNonDelegatedEvent("toggle", instance);\n      break;\n    case "input":\n      listenToNonDelegatedEvent("invalid", instance);\n      initInput(\n        instance,\n        props.value,\n        props.defaultValue,\n        props.checked,\n        props.defaultChecked,\n        props.type,\n        props.name,\n        !0\n      );\n      track(instance);\n      break;\n    case "select":\n      listenToNonDelegatedEvent("invalid", instance);\n      break;\n    case "textarea":\n      listenToNonDelegatedEvent("invalid", instance),\n        initTextarea(instance, props.value, props.defaultValue, props.children),\n        track(instance);\n  }\n  type = props.children;\n  ("string" !== typeof type &&\n    "number" !== typeof type &&\n    "bigint" !== typeof type) ||\n  instance.textContent === "" + type ||\n  !0 === props.suppressHydrationWarning ||\n  checkForUnmatchedText(instance.textContent, type)\n    ? (null != props.popover &&\n        (listenToNonDelegatedEvent("beforetoggle", instance),\n        listenToNonDelegatedEvent("toggle", instance)),\n      null != props.onScroll && listenToNonDelegatedEvent("scroll", instance),\n      null != props.onScrollEnd &&\n        listenToNonDelegatedEvent("scrollend", instance),\n      null != props.onClick && (instance.onclick = noop$1),\n      (instance = !0))\n    : (instance = !1);\n  instance || throwOnHydrationMismatch(fiber);\n}\nfunction popToNextHostParent(fiber) {\n  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )\n    switch (hydrationParentFiber.tag) {\n      case 3:\n      case 27:\n        rootOrSingletonContext = !0;\n        return;\n      case 5:\n      case 13:\n        rootOrSingletonContext = !1;\n        return;\n      default:\n        hydrationParentFiber = hydrationParentFiber.return;\n    }\n}\nfunction popHydrationState(fiber) {\n  if (fiber !== hydrationParentFiber) return !1;\n  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;\n  var shouldClear = !1,\n    JSCompiler_temp;\n  if ((JSCompiler_temp = 3 !== fiber.tag && 27 !== fiber.tag)) {\n    if ((JSCompiler_temp = 5 === fiber.tag))\n      (JSCompiler_temp = fiber.type),\n        (JSCompiler_temp =\n          !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) ||\n          shouldSetTextContent(fiber.type, fiber.memoizedProps));\n    JSCompiler_temp = !JSCompiler_temp;\n  }\n  JSCompiler_temp && (shouldClear = !0);\n  shouldClear && nextHydratableInstance && throwOnHydrationMismatch(fiber);\n  popToNextHostParent(fiber);\n  if (13 === fiber.tag) {\n    fiber = fiber.memoizedState;\n    fiber = null !== fiber ? fiber.dehydrated : null;\n    if (!fiber) throw Error(formatProdErrorMessage(317));\n    a: {\n      fiber = fiber.nextSibling;\n      for (shouldClear = 0; fiber; ) {\n        if (8 === fiber.nodeType)\n          if (((JSCompiler_temp = fiber.data), "/$" === JSCompiler_temp)) {\n            if (0 === shouldClear) {\n              nextHydratableInstance = getNextHydratable(fiber.nextSibling);\n              break a;\n            }\n            shouldClear--;\n          } else\n            ("$" !== JSCompiler_temp &&\n              "$!" !== JSCompiler_temp &&\n              "$?" !== JSCompiler_temp) ||\n              shouldClear++;\n        fiber = fiber.nextSibling;\n      }\n      nextHydratableInstance = null;\n    }\n  } else\n    nextHydratableInstance = hydrationParentFiber\n      ? getNextHydratable(fiber.stateNode.nextSibling)\n      : null;\n  return !0;\n}\nfunction resetHydrationState() {\n  nextHydratableInstance = hydrationParentFiber = null;\n  isHydrating = !1;\n}\nfunction queueHydrationError(error) {\n  null === hydrationErrors\n    ? (hydrationErrors = [error])\n    : hydrationErrors.push(error);\n}\nvar SuspenseException = Error(formatProdErrorMessage(460)),\n  SuspenseyCommitException = Error(formatProdErrorMessage(474)),\n  noopSuspenseyCommitThenable = { then: function () {} };\nfunction isThenableResolved(thenable) {\n  thenable = thenable.status;\n  return "fulfilled" === thenable || "rejected" === thenable;\n}\nfunction noop$3() {}\nfunction trackUsedThenable(thenableState, thenable, index) {\n  index = thenableState[index];\n  void 0 === index\n    ? thenableState.push(thenable)\n    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));\n  switch (thenable.status) {\n    case "fulfilled":\n      return thenable.value;\n    case "rejected":\n      thenableState = thenable.reason;\n      if (thenableState === SuspenseException)\n        throw Error(formatProdErrorMessage(483));\n      throw thenableState;\n    default:\n      if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);\n      else {\n        thenableState = workInProgressRoot;\n        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)\n          throw Error(formatProdErrorMessage(482));\n        thenableState = thenable;\n        thenableState.status = "pending";\n        thenableState.then(\n          function (fulfilledValue) {\n            if ("pending" === thenable.status) {\n              var fulfilledThenable = thenable;\n              fulfilledThenable.status = "fulfilled";\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          function (error) {\n            if ("pending" === thenable.status) {\n              var rejectedThenable = thenable;\n              rejectedThenable.status = "rejected";\n              rejectedThenable.reason = error;\n            }\n          }\n        );\n      }\n      switch (thenable.status) {\n        case "fulfilled":\n          return thenable.value;\n        case "rejected":\n          thenableState = thenable.reason;\n          if (thenableState === SuspenseException)\n            throw Error(formatProdErrorMessage(483));\n          throw thenableState;\n      }\n      suspendedThenable = thenable;\n      throw SuspenseException;\n  }\n}\nvar suspendedThenable = null;\nfunction getSuspendedThenable() {\n  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\n  var thenable = suspendedThenable;\n  suspendedThenable = null;\n  return thenable;\n}\nvar thenableState$1 = null,\n  thenableIndexCounter$1 = 0;\nfunction unwrapThenable(thenable) {\n  var index = thenableIndexCounter$1;\n  thenableIndexCounter$1 += 1;\n  null === thenableState$1 && (thenableState$1 = []);\n  return trackUsedThenable(thenableState$1, thenable, index);\n}\nfunction coerceRef(workInProgress, element) {\n  element = element.props.ref;\n  workInProgress.ref = void 0 !== element ? element : null;\n}\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)\n    throw Error(formatProdErrorMessage(525));\n  returnFiber = Object.prototype.toString.call(newChild);\n  throw Error(\n    formatProdErrorMessage(\n      31,\n      "[object Object]" === returnFiber\n        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"\n        : returnFiber\n    )\n  );\n}\nfunction resolveLazy(lazyType) {\n  var init = lazyType._init;\n  return init(lazyType._payload);\n}\nfunction createChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (shouldTrackSideEffects) {\n      var deletions = returnFiber.deletions;\n      null === deletions\n        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))\n        : deletions.push(childToDelete);\n    }\n  }\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) return null;\n    for (; null !== currentFirstChild; )\n      deleteChild(returnFiber, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return null;\n  }\n  function mapRemainingChildren(currentFirstChild) {\n    for (var existingChildren = new Map(); null !== currentFirstChild; )\n      null !== currentFirstChild.key\n        ? existingChildren.set(currentFirstChild.key, currentFirstChild)\n        : existingChildren.set(currentFirstChild.index, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return existingChildren;\n  }\n  function useFiber(fiber, pendingProps) {\n    fiber = createWorkInProgress(fiber, pendingProps);\n    fiber.index = 0;\n    fiber.sibling = null;\n    return fiber;\n  }\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects)\n      return (newFiber.flags |= 1048576), lastPlacedIndex;\n    newIndex = newFiber.alternate;\n    if (null !== newIndex)\n      return (\n        (newIndex = newIndex.index),\n        newIndex < lastPlacedIndex\n          ? ((newFiber.flags |= 33554434), lastPlacedIndex)\n          : newIndex\n      );\n    newFiber.flags |= 33554434;\n    return lastPlacedIndex;\n  }\n  function placeSingleChild(newFiber) {\n    shouldTrackSideEffects &&\n      null === newFiber.alternate &&\n      (newFiber.flags |= 33554434);\n    return newFiber;\n  }\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (null === current || 6 !== current.tag)\n      return (\n        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, textContent);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE)\n      return updateFragment(\n        returnFiber,\n        current,\n        element.props.children,\n        lanes,\n        element.key\n      );\n    if (\n      null !== current &&\n      (current.elementType === elementType ||\n        ("object" === typeof elementType &&\n          null !== elementType &&\n          elementType.$$typeof === REACT_LAZY_TYPE &&\n          resolveLazy(elementType) === current.type))\n    )\n      return (\n        (current = useFiber(current, element.props)),\n        coerceRef(current, element),\n        (current.return = returnFiber),\n        current\n      );\n    current = createFiberFromTypeAndProps(\n      element.type,\n      element.key,\n      element.props,\n      null,\n      returnFiber.mode,\n      lanes\n    );\n    coerceRef(current, element);\n    current.return = returnFiber;\n    return current;\n  }\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (\n      null === current ||\n      4 !== current.tag ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    )\n      return (\n        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, portal.children || []);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (null === current || 7 !== current.tag)\n      return (\n        (current = createFiberFromFragment(\n          fragment,\n          returnFiber.mode,\n          lanes,\n          key\n        )),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, fragment);\n    current.return = returnFiber;\n    return current;\n  }\n  function createChild(returnFiber, newChild, lanes) {\n    if (\n      ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n    )\n      return (\n        (newChild = createFiberFromText(\n          "" + newChild,\n          returnFiber.mode,\n          lanes\n        )),\n        (newChild.return = returnFiber),\n        newChild\n      );\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (lanes = createFiberFromTypeAndProps(\n              newChild.type,\n              newChild.key,\n              newChild.props,\n              null,\n              returnFiber.mode,\n              lanes\n            )),\n            coerceRef(lanes, newChild),\n            (lanes.return = returnFiber),\n            lanes\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (newChild = createFiberFromPortal(\n              newChild,\n              returnFiber.mode,\n              lanes\n            )),\n            (newChild.return = returnFiber),\n            newChild\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return createChild(returnFiber, newChild, lanes);\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (newChild = createFiberFromFragment(\n            newChild,\n            returnFiber.mode,\n            lanes,\n            null\n          )),\n          (newChild.return = returnFiber),\n          newChild\n        );\n      if ("function" === typeof newChild.then)\n        return createChild(returnFiber, unwrapThenable(newChild), lanes);\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return createChild(\n          returnFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    var key = null !== oldFiber ? oldFiber.key : null;\n    if (\n      ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n    )\n      return null !== key\n        ? null\n        : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return newChild.key === key\n            ? updateElement(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_PORTAL_TYPE:\n          return newChild.key === key\n            ? updatePortal(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            updateSlot(returnFiber, oldFiber, newChild, lanes)\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return null !== key\n          ? null\n          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      if ("function" === typeof newChild.then)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    lanes\n  ) {\n    if (\n      ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n    )\n      return (\n        (existingChildren = existingChildren.get(newIdx) || null),\n        updateTextNode(returnFiber, existingChildren, "" + newChild, lanes)\n      );\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updateElement(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updatePortal(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return updateFromMap(\n            existingChildren,\n            returnFiber,\n            newIdx,\n            newChild,\n            lanes\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (existingChildren = existingChildren.get(newIdx) || null),\n          updateFragment(returnFiber, existingChildren, newChild, lanes, null)\n        );\n      if ("function" === typeof newChild.then)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null;\n      null !== oldFiber && newIdx < newChildren.length;\n      newIdx++\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        lanes\n      );\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (newIdx === newChildren.length)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; newIdx < newChildren.length; newIdx++)\n        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),\n          null !== oldFiber &&\n            ((currentFirstChild = placeChild(\n              oldFiber,\n              currentFirstChild,\n              newIdx\n            )),\n            null === previousNewFiber\n              ? (resultingFirstChild = oldFiber)\n              : (previousNewFiber.sibling = oldFiber),\n            (previousNewFiber = oldFiber));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      newIdx < newChildren.length;\n      newIdx++\n    )\n      (nextOldFiber = updateFromMap(\n        oldFiber,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        lanes\n      )),\n        null !== nextOldFiber &&\n          (shouldTrackSideEffects &&\n            null !== nextOldFiber.alternate &&\n            oldFiber.delete(\n              null === nextOldFiber.key ? newIdx : nextOldFiber.key\n            ),\n          (currentFirstChild = placeChild(\n            nextOldFiber,\n            currentFirstChild,\n            newIdx\n          )),\n          null === previousNewFiber\n            ? (resultingFirstChild = nextOldFiber)\n            : (previousNewFiber.sibling = nextOldFiber),\n          (previousNewFiber = nextOldFiber));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    if (null == newChildren) throw Error(formatProdErrorMessage(151));\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null,\n        step = newChildren.next();\n      null !== oldFiber && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (step.done)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; !step.done; newIdx++, step = newChildren.next())\n        (step = createChild(returnFiber, step.value, lanes)),\n          null !== step &&\n            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n            null === previousNewFiber\n              ? (resultingFirstChild = step)\n              : (previousNewFiber.sibling = step),\n            (previousNewFiber = step));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      !step.done;\n      newIdx++, step = newChildren.next()\n    )\n      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),\n        null !== step &&\n          (shouldTrackSideEffects &&\n            null !== step.alternate &&\n            oldFiber.delete(null === step.key ? newIdx : step.key),\n          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n          null === previousNewFiber\n            ? (resultingFirstChild = step)\n            : (previousNewFiber.sibling = step),\n          (previousNewFiber = step));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildFibersImpl(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    lanes\n  ) {\n    "object" === typeof newChild &&\n      null !== newChild &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      null === newChild.key &&\n      (newChild = newChild.props.children);\n    if ("object" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          a: {\n            for (var key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key) {\n                key = newChild.type;\n                if (key === REACT_FRAGMENT_TYPE) {\n                  if (7 === currentFirstChild.tag) {\n                    deleteRemainingChildren(\n                      returnFiber,\n                      currentFirstChild.sibling\n                    );\n                    lanes = useFiber(\n                      currentFirstChild,\n                      newChild.props.children\n                    );\n                    lanes.return = returnFiber;\n                    returnFiber = lanes;\n                    break a;\n                  }\n                } else if (\n                  currentFirstChild.elementType === key ||\n                  ("object" === typeof key &&\n                    null !== key &&\n                    key.$$typeof === REACT_LAZY_TYPE &&\n                    resolveLazy(key) === currentFirstChild.type)\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.props);\n                  coerceRef(lanes, newChild);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                }\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                break;\n              } else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            newChild.type === REACT_FRAGMENT_TYPE\n              ? ((lanes = createFiberFromFragment(\n                  newChild.props.children,\n                  returnFiber.mode,\n                  lanes,\n                  newChild.key\n                )),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes))\n              : ((lanes = createFiberFromTypeAndProps(\n                  newChild.type,\n                  newChild.key,\n                  newChild.props,\n                  null,\n                  returnFiber.mode,\n                  lanes\n                )),\n                coerceRef(lanes, newChild),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes));\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_PORTAL_TYPE:\n          a: {\n            for (key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key)\n                if (\n                  4 === currentFirstChild.tag &&\n                  currentFirstChild.stateNode.containerInfo ===\n                    newChild.containerInfo &&\n                  currentFirstChild.stateNode.implementation ===\n                    newChild.implementation\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.children || []);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                } else {\n                  deleteRemainingChildren(returnFiber, currentFirstChild);\n                  break;\n                }\n              else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            lanes.return = returnFiber;\n            returnFiber = lanes;\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            reconcileChildFibersImpl(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes\n            )\n          );\n      }\n      if (isArrayImpl(newChild))\n        return reconcileChildrenArray(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      if (getIteratorFn(newChild)) {\n        key = getIteratorFn(newChild);\n        if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));\n        newChild = key.call(newChild);\n        return reconcileChildrenIterator(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      }\n      if ("function" === typeof newChild.then)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return ("string" === typeof newChild && "" !== newChild) ||\n      "number" === typeof newChild ||\n      "bigint" === typeof newChild\n      ? ((newChild = "" + newChild),\n        null !== currentFirstChild && 6 === currentFirstChild.tag\n          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),\n            (lanes = useFiber(currentFirstChild, newChild)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes))\n          : (deleteRemainingChildren(returnFiber, currentFirstChild),\n            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes)),\n        placeSingleChild(returnFiber))\n      : deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n  return function (returnFiber, currentFirstChild, newChild, lanes) {\n    try {\n      thenableIndexCounter$1 = 0;\n      var firstChildFiber = reconcileChildFibersImpl(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        lanes\n      );\n      thenableState$1 = null;\n      return firstChildFiber;\n    } catch (x) {\n      if (x === SuspenseException) throw x;\n      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);\n      fiber.lanes = lanes;\n      fiber.return = returnFiber;\n      return fiber;\n    } finally {\n    }\n  };\n}\nvar reconcileChildFibers = createChildReconciler(!0),\n  mountChildFibers = createChildReconciler(!1),\n  currentTreeHiddenStackCursor = createCursor(null),\n  prevEntangledRenderLanesCursor = createCursor(0);\nfunction pushHiddenContext(fiber, context) {\n  fiber = entangledRenderLanes;\n  push(prevEntangledRenderLanesCursor, fiber);\n  push(currentTreeHiddenStackCursor, context);\n  entangledRenderLanes = fiber | context.baseLanes;\n}\nfunction reuseHiddenContextOnStack() {\n  push(prevEntangledRenderLanesCursor, entangledRenderLanes);\n  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);\n}\nfunction popHiddenContext() {\n  entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n  pop(currentTreeHiddenStackCursor);\n  pop(prevEntangledRenderLanesCursor);\n}\nvar suspenseHandlerStackCursor = createCursor(null),\n  shellBoundary = null;\nfunction pushPrimaryTreeSuspenseHandler(handler) {\n  var current = handler.alternate;\n  push(suspenseStackCursor, suspenseStackCursor.current & 1);\n  push(suspenseHandlerStackCursor, handler);\n  null === shellBoundary &&\n    (null === current || null !== currentTreeHiddenStackCursor.current\n      ? (shellBoundary = handler)\n      : null !== current.memoizedState && (shellBoundary = handler));\n}\nfunction pushOffscreenSuspenseHandler(fiber) {\n  if (22 === fiber.tag) {\n    if (\n      (push(suspenseStackCursor, suspenseStackCursor.current),\n      push(suspenseHandlerStackCursor, fiber),\n      null === shellBoundary)\n    ) {\n      var current = fiber.alternate;\n      null !== current &&\n        null !== current.memoizedState &&\n        (shellBoundary = fiber);\n    }\n  } else reuseSuspenseHandlerOnStack(fiber);\n}\nfunction reuseSuspenseHandlerOnStack() {\n  push(suspenseStackCursor, suspenseStackCursor.current);\n  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);\n}\nfunction popSuspenseHandler(fiber) {\n  pop(suspenseHandlerStackCursor);\n  shellBoundary === fiber && (shellBoundary = null);\n  pop(suspenseStackCursor);\n}\nvar suspenseStackCursor = createCursor(0);\nfunction findFirstSuspended(row) {\n  for (var node = row; null !== node; ) {\n    if (13 === node.tag) {\n      var state = node.memoizedState;\n      if (\n        null !== state &&\n        ((state = state.dehydrated),\n        null === state || "$?" === state.data || "$!" === state.data)\n      )\n        return node;\n    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n      if (0 !== (node.flags & 128)) return node;\n    } else if (null !== node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) break;\n    for (; null === node.sibling; ) {\n      if (null === node.return || node.return === row) return null;\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\nvar AbortControllerLocal =\n    "undefined" !== typeof AbortController\n      ? AbortController\n      : function () {\n          var listeners = [],\n            signal = (this.signal = {\n              aborted: !1,\n              addEventListener: function (type, listener) {\n                listeners.push(listener);\n              }\n            });\n          this.abort = function () {\n            signal.aborted = !0;\n            listeners.forEach(function (listener) {\n              return listener();\n            });\n          };\n        },\n  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,\n  NormalPriority = Scheduler.unstable_NormalPriority,\n  CacheContext = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    Consumer: null,\n    Provider: null,\n    _currentValue: null,\n    _currentValue2: null,\n    _threadCount: 0\n  };\nfunction createCache() {\n  return {\n    controller: new AbortControllerLocal(),\n    data: new Map(),\n    refCount: 0\n  };\n}\nfunction releaseCache(cache) {\n  cache.refCount--;\n  0 === cache.refCount &&\n    scheduleCallback$2(NormalPriority, function () {\n      cache.controller.abort();\n    });\n}\nvar currentEntangledListeners = null,\n  currentEntangledPendingCount = 0,\n  currentEntangledLane = 0,\n  currentEntangledActionThenable = null;\nfunction entangleAsyncAction(transition, thenable) {\n  if (null === currentEntangledListeners) {\n    var entangledListeners = (currentEntangledListeners = []);\n    currentEntangledPendingCount = 0;\n    currentEntangledLane = requestTransitionLane();\n    currentEntangledActionThenable = {\n      status: "pending",\n      value: void 0,\n      then: function (resolve) {\n        entangledListeners.push(resolve);\n      }\n    };\n  }\n  currentEntangledPendingCount++;\n  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n  return thenable;\n}\nfunction pingEngtangledActionScope() {\n  if (\n    0 === --currentEntangledPendingCount &&\n    null !== currentEntangledListeners\n  ) {\n    null !== currentEntangledActionThenable &&\n      (currentEntangledActionThenable.status = "fulfilled");\n    var listeners = currentEntangledListeners;\n    currentEntangledListeners = null;\n    currentEntangledLane = 0;\n    currentEntangledActionThenable = null;\n    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();\n  }\n}\nfunction chainThenableValue(thenable, result) {\n  var listeners = [],\n    thenableWithOverride = {\n      status: "pending",\n      value: null,\n      reason: null,\n      then: function (resolve) {\n        listeners.push(resolve);\n      }\n    };\n  thenable.then(\n    function () {\n      thenableWithOverride.status = "fulfilled";\n      thenableWithOverride.value = result;\n      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);\n    },\n    function (error) {\n      thenableWithOverride.status = "rejected";\n      thenableWithOverride.reason = error;\n      for (error = 0; error < listeners.length; error++)\n        (0, listeners[error])(void 0);\n    }\n  );\n  return thenableWithOverride;\n}\nvar prevOnStartTransitionFinish = ReactSharedInternals.S;\nReactSharedInternals.S = function (transition, returnValue) {\n  "object" === typeof returnValue &&\n    null !== returnValue &&\n    "function" === typeof returnValue.then &&\n    entangleAsyncAction(transition, returnValue);\n  null !== prevOnStartTransitionFinish &&\n    prevOnStartTransitionFinish(transition, returnValue);\n};\nvar resumedCache = createCursor(null);\nfunction peekCacheFromPool() {\n  var cacheResumedFromPreviousRender = resumedCache.current;\n  return null !== cacheResumedFromPreviousRender\n    ? cacheResumedFromPreviousRender\n    : workInProgressRoot.pooledCache;\n}\nfunction pushTransition(offscreenWorkInProgress, prevCachePool) {\n  null === prevCachePool\n    ? push(resumedCache, resumedCache.current)\n    : push(resumedCache, prevCachePool.pool);\n}\nfunction getSuspendedCache() {\n  var cacheFromPool = peekCacheFromPool();\n  return null === cacheFromPool\n    ? null\n    : { parent: CacheContext._currentValue, pool: cacheFromPool };\n}\nvar renderLanes = 0,\n  currentlyRenderingFiber$1 = null,\n  currentHook = null,\n  workInProgressHook = null,\n  didScheduleRenderPhaseUpdate = !1,\n  didScheduleRenderPhaseUpdateDuringThisPass = !1,\n  shouldDoubleInvokeUserFnsInHooksDEV = !1,\n  localIdCounter = 0,\n  thenableIndexCounter = 0,\n  thenableState = null,\n  globalClientIdCounter = 0;\nfunction throwInvalidHookError() {\n  throw Error(formatProdErrorMessage(321));\n}\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (null === prevDeps) return !1;\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)\n    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n  return !0;\n}\nfunction renderWithHooks(\n  current,\n  workInProgress,\n  Component,\n  props,\n  secondArg,\n  nextRenderLanes\n) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber$1 = workInProgress;\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = 0;\n  ReactSharedInternals.H =\n    null === current || null === current.memoizedState\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  nextRenderLanes = Component(props, secondArg);\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  didScheduleRenderPhaseUpdateDuringThisPass &&\n    (nextRenderLanes = renderWithHooksAgain(\n      workInProgress,\n      Component,\n      props,\n      secondArg\n    ));\n  finishRenderingHooks(current);\n  return nextRenderLanes;\n}\nfunction finishRenderingHooks(current) {\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n  didScheduleRenderPhaseUpdate = !1;\n  thenableIndexCounter = 0;\n  thenableState = null;\n  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));\n  null === current ||\n    didReceiveUpdate ||\n    ((current = current.dependencies),\n    null !== current &&\n      checkIfContextChanged(current) &&\n      (didReceiveUpdate = !0));\n}\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n  currentlyRenderingFiber$1 = workInProgress;\n  var numberOfReRenders = 0;\n  do {\n    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);\n    thenableIndexCounter = 0;\n    didScheduleRenderPhaseUpdateDuringThisPass = !1;\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\n    numberOfReRenders += 1;\n    workInProgressHook = currentHook = null;\n    if (null != workInProgress.updateQueue) {\n      var children = workInProgress.updateQueue;\n      children.lastEffect = null;\n      children.events = null;\n      children.stores = null;\n      null != children.memoCache && (children.memoCache.index = 0);\n    }\n    ReactSharedInternals.H = HooksDispatcherOnRerender;\n    children = Component(props, secondArg);\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  return children;\n}\nfunction TransitionAwareHostComponent() {\n  var dispatcher = ReactSharedInternals.H,\n    maybeThenable = dispatcher.useState()[0];\n  maybeThenable =\n    "function" === typeof maybeThenable.then\n      ? useThenable(maybeThenable)\n      : maybeThenable;\n  dispatcher = dispatcher.useState()[0];\n  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&\n    (currentlyRenderingFiber$1.flags |= 1024);\n  return maybeThenable;\n}\nfunction checkDidRenderIdHook() {\n  var didRenderIdHook = 0 !== localIdCounter;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.flags &= -2053;\n  current.lanes &= ~lanes;\n}\nfunction resetHooksOnUnwind(workInProgress) {\n  if (didScheduleRenderPhaseUpdate) {\n    for (\n      workInProgress = workInProgress.memoizedState;\n      null !== workInProgress;\n\n    ) {\n      var queue = workInProgress.queue;\n      null !== queue && (queue.pending = null);\n      workInProgress = workInProgress.next;\n    }\n    didScheduleRenderPhaseUpdate = !1;\n  }\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber$1 = null;\n  didScheduleRenderPhaseUpdateDuringThisPass = !1;\n  thenableIndexCounter = localIdCounter = 0;\n  thenableState = null;\n}\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n  null === workInProgressHook\n    ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook)\n    : (workInProgressHook = workInProgressHook.next = hook);\n  return workInProgressHook;\n}\nfunction updateWorkInProgressHook() {\n  if (null === currentHook) {\n    var nextCurrentHook = currentlyRenderingFiber$1.alternate;\n    nextCurrentHook =\n      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n  } else nextCurrentHook = currentHook.next;\n  var nextWorkInProgressHook =\n    null === workInProgressHook\n      ? currentlyRenderingFiber$1.memoizedState\n      : workInProgressHook.next;\n  if (null !== nextWorkInProgressHook)\n    (workInProgressHook = nextWorkInProgressHook),\n      (currentHook = nextCurrentHook);\n  else {\n    if (null === nextCurrentHook) {\n      if (null === currentlyRenderingFiber$1.alternate)\n        throw Error(formatProdErrorMessage(467));\n      throw Error(formatProdErrorMessage(310));\n    }\n    currentHook = nextCurrentHook;\n    nextCurrentHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n    null === workInProgressHook\n      ? (currentlyRenderingFiber$1.memoizedState = workInProgressHook =\n          nextCurrentHook)\n      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);\n  }\n  return workInProgressHook;\n}\nvar createFunctionComponentUpdateQueue;\ncreateFunctionComponentUpdateQueue = function () {\n  return { lastEffect: null, events: null, stores: null, memoCache: null };\n};\nfunction useThenable(thenable) {\n  var index = thenableIndexCounter;\n  thenableIndexCounter += 1;\n  null === thenableState && (thenableState = []);\n  thenable = trackUsedThenable(thenableState, thenable, index);\n  index = currentlyRenderingFiber$1;\n  null ===\n    (null === workInProgressHook\n      ? index.memoizedState\n      : workInProgressHook.next) &&\n    ((index = index.alternate),\n    (ReactSharedInternals.H =\n      null === index || null === index.memoizedState\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate));\n  return thenable;\n}\nfunction use(usable) {\n  if (null !== usable && "object" === typeof usable) {\n    if ("function" === typeof usable.then) return useThenable(usable);\n    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n  }\n  throw Error(formatProdErrorMessage(438, String(usable)));\n}\nfunction useMemoCache(size) {\n  var memoCache = null,\n    updateQueue = currentlyRenderingFiber$1.updateQueue;\n  null !== updateQueue && (memoCache = updateQueue.memoCache);\n  if (null == memoCache) {\n    var current = currentlyRenderingFiber$1.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      null !== current &&\n        ((current = current.memoCache),\n        null != current &&\n          (memoCache = {\n            data: current.data.map(function (array) {\n              return array.slice();\n            }),\n            index: 0\n          })));\n  }\n  null == memoCache && (memoCache = { data: [], index: 0 });\n  null === updateQueue &&\n    ((updateQueue = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber$1.updateQueue = updateQueue));\n  updateQueue.memoCache = memoCache;\n  updateQueue = memoCache.data[memoCache.index];\n  if (void 0 === updateQueue)\n    for (\n      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;\n      current < size;\n      current++\n    )\n      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n  memoCache.index++;\n  return updateQueue;\n}\nfunction basicStateReducer(state, action) {\n  return "function" === typeof action ? action(state) : action;\n}\nfunction updateReducer(reducer) {\n  var hook = updateWorkInProgressHook();\n  return updateReducerImpl(hook, currentHook, reducer);\n}\nfunction updateReducerImpl(hook, current, reducer) {\n  var queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var baseQueue = hook.baseQueue,\n    pendingQueue = queue.pending;\n  if (null !== pendingQueue) {\n    if (null !== baseQueue) {\n      var baseFirst = baseQueue.next;\n      baseQueue.next = pendingQueue.next;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n  pendingQueue = hook.baseState;\n  if (null === baseQueue) hook.memoizedState = pendingQueue;\n  else {\n    current = baseQueue.next;\n    var newBaseQueueFirst = (baseFirst = null),\n      newBaseQueueLast = null,\n      update = current,\n      didReadFromEntangledAsyncAction$54 = !1;\n    do {\n      var updateLane = update.lane & -536870913;\n      if (\n        updateLane !== update.lane\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        var revertLane = update.revertLane;\n        if (0 === revertLane)\n          null !== newBaseQueueLast &&\n            (newBaseQueueLast = newBaseQueueLast.next =\n              {\n                lane: 0,\n                revertLane: 0,\n                action: update.action,\n                hasEagerState: update.hasEagerState,\n                eagerState: update.eagerState,\n                next: null\n              }),\n            updateLane === currentEntangledLane &&\n              (didReadFromEntangledAsyncAction$54 = !0);\n        else if ((renderLanes & revertLane) === revertLane) {\n          update = update.next;\n          revertLane === currentEntangledLane &&\n            (didReadFromEntangledAsyncAction$54 = !0);\n          continue;\n        } else\n          (updateLane = {\n            lane: 0,\n            revertLane: update.revertLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          }),\n            null === newBaseQueueLast\n              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),\n                (baseFirst = pendingQueue))\n              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),\n            (currentlyRenderingFiber$1.lanes |= revertLane),\n            (workInProgressRootSkippedLanes |= revertLane);\n        updateLane = update.action;\n        shouldDoubleInvokeUserFnsInHooksDEV &&\n          reducer(pendingQueue, updateLane);\n        pendingQueue = update.hasEagerState\n          ? update.eagerState\n          : reducer(pendingQueue, updateLane);\n      } else\n        (revertLane = {\n          lane: updateLane,\n          revertLane: update.revertLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        }),\n          null === newBaseQueueLast\n            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),\n              (baseFirst = pendingQueue))\n            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),\n          (currentlyRenderingFiber$1.lanes |= updateLane),\n          (workInProgressRootSkippedLanes |= updateLane);\n      update = update.next;\n    } while (null !== update && update !== current);\n    null === newBaseQueueLast\n      ? (baseFirst = pendingQueue)\n      : (newBaseQueueLast.next = newBaseQueueFirst);\n    if (\n      !objectIs(pendingQueue, hook.memoizedState) &&\n      ((didReceiveUpdate = !0),\n      didReadFromEntangledAsyncAction$54 &&\n        ((reducer = currentEntangledActionThenable), null !== reducer))\n    )\n      throw reducer;\n    hook.memoizedState = pendingQueue;\n    hook.baseState = baseFirst;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = pendingQueue;\n  }\n  null === baseQueue && (queue.lanes = 0);\n  return [hook.memoizedState, queue.dispatch];\n}\nfunction rerenderReducer(reducer) {\n  var hook = updateWorkInProgressHook(),\n    queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var dispatch = queue.dispatch,\n    lastRenderPhaseUpdate = queue.pending,\n    newState = hook.memoizedState;\n  if (null !== lastRenderPhaseUpdate) {\n    queue.pending = null;\n    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);\n    do (newState = reducer(newState, update.action)), (update = update.next);\n    while (update !== lastRenderPhaseUpdate);\n    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n    hook.memoizedState = newState;\n    null === hook.baseQueue && (hook.baseState = newState);\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1,\n    hook = updateWorkInProgressHook(),\n    isHydrating$jscomp$0 = isHydrating;\n  if (isHydrating$jscomp$0) {\n    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));\n    getServerSnapshot = getServerSnapshot();\n  } else getServerSnapshot = getSnapshot();\n  var snapshotChanged = !objectIs(\n    (currentHook || hook).memoizedState,\n    getServerSnapshot\n  );\n  snapshotChanged &&\n    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));\n  hook = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [\n    subscribe\n  ]);\n  if (\n    hook.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)\n  ) {\n    fiber.flags |= 2048;\n    pushEffect(\n      9,\n      updateStoreInstance.bind(\n        null,\n        fiber,\n        hook,\n        getServerSnapshot,\n        getSnapshot\n      ),\n      { destroy: void 0 },\n      null\n    );\n    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\n    isHydrating$jscomp$0 ||\n      0 !== (renderLanes & 60) ||\n      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n  }\n  return getServerSnapshot;\n}\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= 16384;\n  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };\n  getSnapshot = currentlyRenderingFiber$1.updateQueue;\n  null === getSnapshot\n    ? ((getSnapshot = createFunctionComponentUpdateQueue()),\n      (currentlyRenderingFiber$1.updateQueue = getSnapshot),\n      (getSnapshot.stores = [fiber]))\n    : ((renderedSnapshot = getSnapshot.stores),\n      null === renderedSnapshot\n        ? (getSnapshot.stores = [fiber])\n        : renderedSnapshot.push(fiber));\n}\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n}\nfunction subscribeToStore(fiber, inst, subscribe) {\n  return subscribe(function () {\n    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n  });\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction forceStoreRerender(fiber) {\n  var root = enqueueConcurrentRenderForLane(fiber, 2);\n  null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n}\nfunction mountStateImpl(initialState) {\n  var hook = mountWorkInProgressHook();\n  if ("function" === typeof initialState) {\n    var initialStateInitializer = initialState;\n    initialState = initialStateInitializer();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(!0);\n      try {\n        initialStateInitializer();\n      } finally {\n        setIsStrictModeForDevtools(!1);\n      }\n    }\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  hook.queue = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  return hook;\n}\nfunction updateOptimisticImpl(hook, current, passthrough, reducer) {\n  hook.baseState = passthrough;\n  return updateReducerImpl(\n    hook,\n    currentHook,\n    "function" === typeof reducer ? reducer : basicStateReducer\n  );\n}\nfunction dispatchActionState(\n  fiber,\n  actionQueue,\n  setPendingState,\n  setState,\n  payload\n) {\n  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));\n  fiber = actionQueue.action;\n  if (null !== fiber) {\n    var actionNode = {\n      payload: payload,\n      action: fiber,\n      next: null,\n      isTransition: !0,\n      status: "pending",\n      value: null,\n      reason: null,\n      listeners: [],\n      then: function (listener) {\n        actionNode.listeners.push(listener);\n      }\n    };\n    null !== ReactSharedInternals.T\n      ? setPendingState(!0)\n      : (actionNode.isTransition = !1);\n    setState(actionNode);\n    setPendingState = actionQueue.pending;\n    null === setPendingState\n      ? ((actionNode.next = actionQueue.pending = actionNode),\n        runActionStateAction(actionQueue, actionNode))\n      : ((actionNode.next = setPendingState.next),\n        (actionQueue.pending = setPendingState.next = actionNode));\n  }\n}\nfunction runActionStateAction(actionQueue, node) {\n  var action = node.action,\n    payload = node.payload,\n    prevState = actionQueue.state;\n  if (node.isTransition) {\n    var prevTransition = ReactSharedInternals.T,\n      currentTransition = {};\n    ReactSharedInternals.T = currentTransition;\n    try {\n      var returnValue = action(prevState, payload),\n        onStartTransitionFinish = ReactSharedInternals.S;\n      null !== onStartTransitionFinish &&\n        onStartTransitionFinish(currentTransition, returnValue);\n      handleActionReturnValue(actionQueue, node, returnValue);\n    } catch (error) {\n      onActionError(actionQueue, node, error);\n    } finally {\n      ReactSharedInternals.T = prevTransition;\n    }\n  } else\n    try {\n      (prevTransition = action(prevState, payload)),\n        handleActionReturnValue(actionQueue, node, prevTransition);\n    } catch (error$60) {\n      onActionError(actionQueue, node, error$60);\n    }\n}\nfunction handleActionReturnValue(actionQueue, node, returnValue) {\n  null !== returnValue &&\n  "object" === typeof returnValue &&\n  "function" === typeof returnValue.then\n    ? returnValue.then(\n        function (nextState) {\n          onActionSuccess(actionQueue, node, nextState);\n        },\n        function (error) {\n          return onActionError(actionQueue, node, error);\n        }\n      )\n    : onActionSuccess(actionQueue, node, returnValue);\n}\nfunction onActionSuccess(actionQueue, actionNode, nextState) {\n  actionNode.status = "fulfilled";\n  actionNode.value = nextState;\n  notifyActionListeners(actionNode);\n  actionQueue.state = nextState;\n  actionNode = actionQueue.pending;\n  null !== actionNode &&\n    ((nextState = actionNode.next),\n    nextState === actionNode\n      ? (actionQueue.pending = null)\n      : ((nextState = nextState.next),\n        (actionNode.next = nextState),\n        runActionStateAction(actionQueue, nextState)));\n}\nfunction onActionError(actionQueue, actionNode, error) {\n  var last = actionQueue.pending;\n  actionQueue.pending = null;\n  if (null !== last) {\n    last = last.next;\n    do\n      (actionNode.status = "rejected"),\n        (actionNode.reason = error),\n        notifyActionListeners(actionNode),\n        (actionNode = actionNode.next);\n    while (actionNode !== last);\n  }\n  actionQueue.action = null;\n}\nfunction notifyActionListeners(actionNode) {\n  actionNode = actionNode.listeners;\n  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();\n}\nfunction actionStateReducer(oldState, newState) {\n  return newState;\n}\nfunction mountActionState(action, initialStateProp) {\n  if (isHydrating) {\n    var ssrFormState = workInProgressRoot.formState;\n    if (null !== ssrFormState) {\n      a: {\n        var JSCompiler_inline_result = currentlyRenderingFiber$1;\n        if (isHydrating) {\n          if (nextHydratableInstance) {\n            b: {\n              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;\n              for (\n                var inRootOrSingleton = rootOrSingletonContext;\n                8 !== JSCompiler_inline_result$jscomp$0.nodeType;\n\n              ) {\n                if (!inRootOrSingleton) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n                JSCompiler_inline_result$jscomp$0 = getNextHydratable(\n                  JSCompiler_inline_result$jscomp$0.nextSibling\n                );\n                if (null === JSCompiler_inline_result$jscomp$0) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n              }\n              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;\n              JSCompiler_inline_result$jscomp$0 =\n                "F!" === inRootOrSingleton || "F" === inRootOrSingleton\n                  ? JSCompiler_inline_result$jscomp$0\n                  : null;\n            }\n            if (JSCompiler_inline_result$jscomp$0) {\n              nextHydratableInstance = getNextHydratable(\n                JSCompiler_inline_result$jscomp$0.nextSibling\n              );\n              JSCompiler_inline_result =\n                "F!" === JSCompiler_inline_result$jscomp$0.data;\n              break a;\n            }\n          }\n          throwOnHydrationMismatch(JSCompiler_inline_result);\n        }\n        JSCompiler_inline_result = !1;\n      }\n      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);\n    }\n  }\n  ssrFormState = mountWorkInProgressHook();\n  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n  JSCompiler_inline_result = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: actionStateReducer,\n    lastRenderedState: initialStateProp\n  };\n  ssrFormState.queue = JSCompiler_inline_result;\n  ssrFormState = dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    JSCompiler_inline_result\n  );\n  JSCompiler_inline_result.dispatch = ssrFormState;\n  JSCompiler_inline_result = mountStateImpl(!1);\n  inRootOrSingleton = dispatchOptimisticSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    !1,\n    JSCompiler_inline_result.queue\n  );\n  JSCompiler_inline_result = mountWorkInProgressHook();\n  JSCompiler_inline_result$jscomp$0 = {\n    state: initialStateProp,\n    dispatch: null,\n    action: action,\n    pending: null\n  };\n  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;\n  ssrFormState = dispatchActionState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    JSCompiler_inline_result$jscomp$0,\n    inRootOrSingleton,\n    ssrFormState\n  );\n  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;\n  JSCompiler_inline_result.memoizedState = action;\n  return [initialStateProp, ssrFormState, !1];\n}\nfunction updateActionState(action) {\n  var stateHook = updateWorkInProgressHook();\n  return updateActionStateImpl(stateHook, currentHook, action);\n}\nfunction updateActionStateImpl(stateHook, currentStateHook, action) {\n  currentStateHook = updateReducerImpl(\n    stateHook,\n    currentStateHook,\n    actionStateReducer\n  )[0];\n  stateHook = updateReducer(basicStateReducer)[0];\n  currentStateHook =\n    "object" === typeof currentStateHook &&\n    null !== currentStateHook &&\n    "function" === typeof currentStateHook.then\n      ? useThenable(currentStateHook)\n      : currentStateHook;\n  var actionQueueHook = updateWorkInProgressHook(),\n    actionQueue = actionQueueHook.queue,\n    dispatch = actionQueue.dispatch;\n  action !== actionQueueHook.memoizedState &&\n    ((currentlyRenderingFiber$1.flags |= 2048),\n    pushEffect(\n      9,\n      actionStateActionEffect.bind(null, actionQueue, action),\n      { destroy: void 0 },\n      null\n    ));\n  return [currentStateHook, dispatch, stateHook];\n}\nfunction actionStateActionEffect(actionQueue, action) {\n  actionQueue.action = action;\n}\nfunction rerenderActionState(action) {\n  var stateHook = updateWorkInProgressHook(),\n    currentStateHook = currentHook;\n  if (null !== currentStateHook)\n    return updateActionStateImpl(stateHook, currentStateHook, action);\n  updateWorkInProgressHook();\n  stateHook = stateHook.memoizedState;\n  currentStateHook = updateWorkInProgressHook();\n  var dispatch = currentStateHook.queue.dispatch;\n  currentStateHook.memoizedState = action;\n  return [stateHook, dispatch, !1];\n}\nfunction pushEffect(tag, create, inst, deps) {\n  tag = { tag: tag, create: create, inst: inst, deps: deps, next: null };\n  create = currentlyRenderingFiber$1.updateQueue;\n  null === create &&\n    ((create = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber$1.updateQueue = create));\n  inst = create.lastEffect;\n  null === inst\n    ? (create.lastEffect = tag.next = tag)\n    : ((deps = inst.next),\n      (inst.next = tag),\n      (tag.next = deps),\n      (create.lastEffect = tag));\n  return tag;\n}\nfunction updateRef() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = mountWorkInProgressHook();\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(\n    1 | hookFlags,\n    create,\n    { destroy: void 0 },\n    void 0 === deps ? null : deps\n  );\n}\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var inst = hook.memoizedState.inst;\n  null !== currentHook &&\n  null !== deps &&\n  areHookInputsEqual(deps, currentHook.memoizedState.deps)\n    ? (hook.memoizedState = pushEffect(hookFlags, create, inst, deps))\n    : ((currentlyRenderingFiber$1.flags |= fiberFlags),\n      (hook.memoizedState = pushEffect(1 | hookFlags, create, inst, deps)));\n}\nfunction mountEffect(create, deps) {\n  mountEffectImpl(8390656, 8, create, deps);\n}\nfunction updateEffect(create, deps) {\n  updateEffectImpl(2048, 8, create, deps);\n}\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(4, 2, create, deps);\n}\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(4, 4, create, deps);\n}\nfunction imperativeHandleEffect(create, ref) {\n  if ("function" === typeof ref) {\n    create = create();\n    var refCleanup = ref(create);\n    return function () {\n      "function" === typeof refCleanup ? refCleanup() : ref(null);\n    };\n  }\n  if (null !== ref && void 0 !== ref)\n    return (\n      (create = create()),\n      (ref.current = create),\n      function () {\n        ref.current = null;\n      }\n    );\n}\nfunction updateImperativeHandle(ref, create, deps) {\n  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);\n}\nfunction mountDebugValue() {}\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  hook.memoizedState = [callback, deps];\n  return callback;\n}\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  prevState = nextCreate();\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    setIsStrictModeForDevtools(!0);\n    try {\n      nextCreate();\n    } finally {\n      setIsStrictModeForDevtools(!1);\n    }\n  }\n  hook.memoizedState = [prevState, deps];\n  return prevState;\n}\nfunction mountDeferredValueImpl(hook, value, initialValue) {\n  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))\n    return (hook.memoizedState = value);\n  hook.memoizedState = initialValue;\n  hook = requestDeferredLane();\n  currentlyRenderingFiber$1.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return initialValue;\n}\nfunction updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n  if (objectIs(value, prevValue)) return value;\n  if (null !== currentTreeHiddenStackCursor.current)\n    return (\n      (hook = mountDeferredValueImpl(hook, value, initialValue)),\n      objectIs(hook, prevValue) || (didReceiveUpdate = !0),\n      hook\n    );\n  if (0 === (renderLanes & 42))\n    return (didReceiveUpdate = !0), (hook.memoizedState = value);\n  hook = requestDeferredLane();\n  currentlyRenderingFiber$1.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return prevValue;\n}\nfunction startTransition(fiber, queue, pendingState, finishedState, callback) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  ReactDOMSharedInternals.p =\n    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n  try {\n    var returnValue = callback(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    if (\n      null !== returnValue &&\n      "object" === typeof returnValue &&\n      "function" === typeof returnValue.then\n    ) {\n      var thenableForFinishedState = chainThenableValue(\n        returnValue,\n        finishedState\n      );\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        thenableForFinishedState,\n        requestUpdateLane(fiber)\n      );\n    } else\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        finishedState,\n        requestUpdateLane(fiber)\n      );\n  } catch (error) {\n    dispatchSetStateInternal(\n      fiber,\n      queue,\n      { then: function () {}, status: "rejected", reason: error },\n      requestUpdateLane()\n    );\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction noop$2() {}\nfunction startHostTransition(formFiber, pendingState, action, formData) {\n  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));\n  var queue = ensureFormComponentIsStateful(formFiber).queue;\n  startTransition(\n    formFiber,\n    queue,\n    pendingState,\n    sharedNotPendingObject,\n    null === action\n      ? noop$2\n      : function () {\n          requestFormReset$1(formFiber);\n          return action(formData);\n        }\n  );\n}\nfunction ensureFormComponentIsStateful(formFiber) {\n  var existingStateHook = formFiber.memoizedState;\n  if (null !== existingStateHook) return existingStateHook;\n  existingStateHook = {\n    memoizedState: sharedNotPendingObject,\n    baseState: sharedNotPendingObject,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: sharedNotPendingObject\n    },\n    next: null\n  };\n  var initialResetState = {};\n  existingStateHook.next = {\n    memoizedState: initialResetState,\n    baseState: initialResetState,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: initialResetState\n    },\n    next: null\n  };\n  formFiber.memoizedState = existingStateHook;\n  formFiber = formFiber.alternate;\n  null !== formFiber && (formFiber.memoizedState = existingStateHook);\n  return existingStateHook;\n}\nfunction requestFormReset$1(formFiber) {\n  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());\n}\nfunction useHostTransitionStatus() {\n  return readContext(HostTransitionContext);\n}\nfunction updateId() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction updateRefresh() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction refreshCache(fiber) {\n  for (var provider = fiber.return; null !== provider; ) {\n    switch (provider.tag) {\n      case 24:\n      case 3:\n        var lane = requestUpdateLane();\n        fiber = createUpdate(lane);\n        var root$63 = enqueueUpdate(provider, fiber, lane);\n        null !== root$63 &&\n          (scheduleUpdateOnFiber(root$63, provider, lane),\n          entangleTransitions(root$63, provider, lane));\n        provider = { cache: createCache() };\n        fiber.payload = provider;\n        return;\n    }\n    provider = provider.return;\n  }\n}\nfunction dispatchReducerAction(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  action = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  isRenderPhaseUpdate(fiber)\n    ? enqueueRenderPhaseUpdate(queue, action)\n    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),\n      null !== action &&\n        (scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane)));\n}\nfunction dispatchSetState(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  dispatchSetStateInternal(fiber, queue, action, lane);\n}\nfunction dispatchSetStateInternal(fiber, queue, action, lane) {\n  var update = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n  else {\n    var alternate = fiber.alternate;\n    if (\n      0 === fiber.lanes &&\n      (null === alternate || 0 === alternate.lanes) &&\n      ((alternate = queue.lastRenderedReducer), null !== alternate)\n    )\n      try {\n        var currentState = queue.lastRenderedState,\n          eagerState = alternate(currentState, action);\n        update.hasEagerState = !0;\n        update.eagerState = eagerState;\n        if (objectIs(eagerState, currentState))\n          return (\n            enqueueUpdate$1(fiber, queue, update, 0),\n            null === workInProgressRoot && finishQueueingConcurrentUpdates(),\n            !1\n          );\n      } catch (error) {\n      } finally {\n      }\n    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (null !== action)\n      return (\n        scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane),\n        !0\n      );\n  }\n  return !1;\n}\nfunction dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n  action = {\n    lane: 2,\n    revertLane: requestTransitionLane(),\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) {\n    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));\n  } else\n    (throwIfDuringRender = enqueueConcurrentHookUpdate(\n      fiber,\n      queue,\n      action,\n      2\n    )),\n      null !== throwIfDuringRender &&\n        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n}\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return (\n    fiber === currentlyRenderingFiber$1 ||\n    (null !== alternate && alternate === currentlyRenderingFiber$1)\n  );\n}\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =\n    !0;\n  var pending = queue.pending;\n  null === pending\n    ? (update.next = update)\n    : ((update.next = pending.next), (pending.next = update));\n  queue.pending = update;\n}\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (0 !== (lane & 4194176)) {\n    var queueLanes = queue.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    queue.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nvar ContextOnlyDispatcher = {\n  readContext: readContext,\n  use: use,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError\n};\nContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\nContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\nContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\nContextOnlyDispatcher.useFormState = throwInvalidHookError;\nContextOnlyDispatcher.useActionState = throwInvalidHookError;\nContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\nvar HooksDispatcherOnMount = {\n  readContext: readContext,\n  use: use,\n  useCallback: function (callback, deps) {\n    mountWorkInProgressHook().memoizedState = [\n      callback,\n      void 0 === deps ? null : deps\n    ];\n    return callback;\n  },\n  useContext: readContext,\n  useEffect: mountEffect,\n  useImperativeHandle: function (ref, create, deps) {\n    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n    mountEffectImpl(\n      4194308,\n      4,\n      imperativeHandleEffect.bind(null, create, ref),\n      deps\n    );\n  },\n  useLayoutEffect: function (create, deps) {\n    return mountEffectImpl(4194308, 4, create, deps);\n  },\n  useInsertionEffect: function (create, deps) {\n    mountEffectImpl(4, 2, create, deps);\n  },\n  useMemo: function (nextCreate, deps) {\n    var hook = mountWorkInProgressHook();\n    deps = void 0 === deps ? null : deps;\n    var nextValue = nextCreate();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(!0);\n      try {\n        nextCreate();\n      } finally {\n        setIsStrictModeForDevtools(!1);\n      }\n    }\n    hook.memoizedState = [nextValue, deps];\n    return nextValue;\n  },\n  useReducer: function (reducer, initialArg, init) {\n    var hook = mountWorkInProgressHook();\n    if (void 0 !== init) {\n      var initialState = init(initialArg);\n      if (shouldDoubleInvokeUserFnsInHooksDEV) {\n        setIsStrictModeForDevtools(!0);\n        try {\n          init(initialArg);\n        } finally {\n          setIsStrictModeForDevtools(!1);\n        }\n      }\n    } else initialState = initialArg;\n    hook.memoizedState = hook.baseState = initialState;\n    reducer = {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: reducer,\n      lastRenderedState: initialState\n    };\n    hook.queue = reducer;\n    reducer = reducer.dispatch = dispatchReducerAction.bind(\n      null,\n      currentlyRenderingFiber$1,\n      reducer\n    );\n    return [hook.memoizedState, reducer];\n  },\n  useRef: function (initialValue) {\n    var hook = mountWorkInProgressHook();\n    initialValue = { current: initialValue };\n    return (hook.memoizedState = initialValue);\n  },\n  useState: function (initialState) {\n    initialState = mountStateImpl(initialState);\n    var queue = initialState.queue,\n      dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n    queue.dispatch = dispatch;\n    return [initialState.memoizedState, dispatch];\n  },\n  useDebugValue: mountDebugValue,\n  useDeferredValue: function (value, initialValue) {\n    var hook = mountWorkInProgressHook();\n    return mountDeferredValueImpl(hook, value, initialValue);\n  },\n  useTransition: function () {\n    var stateHook = mountStateImpl(!1);\n    stateHook = startTransition.bind(\n      null,\n      currentlyRenderingFiber$1,\n      stateHook.queue,\n      !0,\n      !1\n    );\n    mountWorkInProgressHook().memoizedState = stateHook;\n    return [!1, stateHook];\n  },\n  useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n    var fiber = currentlyRenderingFiber$1,\n      hook = mountWorkInProgressHook();\n    if (isHydrating) {\n      if (void 0 === getServerSnapshot)\n        throw Error(formatProdErrorMessage(407));\n      getServerSnapshot = getServerSnapshot();\n    } else {\n      getServerSnapshot = getSnapshot();\n      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\n      0 !== (workInProgressRootRenderLanes & 60) ||\n        pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n    }\n    hook.memoizedState = getServerSnapshot;\n    var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };\n    hook.queue = inst;\n    mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n      subscribe\n    ]);\n    fiber.flags |= 2048;\n    pushEffect(\n      9,\n      updateStoreInstance.bind(\n        null,\n        fiber,\n        inst,\n        getServerSnapshot,\n        getSnapshot\n      ),\n      { destroy: void 0 },\n      null\n    );\n    return getServerSnapshot;\n  },\n  useId: function () {\n    var hook = mountWorkInProgressHook(),\n      identifierPrefix = workInProgressRoot.identifierPrefix;\n    if (isHydrating) {\n      var JSCompiler_inline_result = treeContextOverflow;\n      var idWithLeadingBit = treeContextId;\n      JSCompiler_inline_result =\n        (\n          idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))\n        ).toString(32) + JSCompiler_inline_result;\n      identifierPrefix =\n        ":" + identifierPrefix + "R" + JSCompiler_inline_result;\n      JSCompiler_inline_result = localIdCounter++;\n      0 < JSCompiler_inline_result &&\n        (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));\n      identifierPrefix += ":";\n    } else\n      (JSCompiler_inline_result = globalClientIdCounter++),\n        (identifierPrefix =\n          ":" +\n          identifierPrefix +\n          "r" +\n          JSCompiler_inline_result.toString(32) +\n          ":");\n    return (hook.memoizedState = identifierPrefix);\n  },\n  useCacheRefresh: function () {\n    return (mountWorkInProgressHook().memoizedState = refreshCache.bind(\n      null,\n      currentlyRenderingFiber$1\n    ));\n  }\n};\nHooksDispatcherOnMount.useMemoCache = useMemoCache;\nHooksDispatcherOnMount.useHostTransitionStatus = useHostTransitionStatus;\nHooksDispatcherOnMount.useFormState = mountActionState;\nHooksDispatcherOnMount.useActionState = mountActionState;\nHooksDispatcherOnMount.useOptimistic = function (passthrough) {\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = hook.baseState = passthrough;\n  var queue = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: null,\n    lastRenderedState: null\n  };\n  hook.queue = queue;\n  hook = dispatchOptimisticSetState.bind(\n    null,\n    currentlyRenderingFiber$1,\n    !0,\n    queue\n  );\n  queue.dispatch = hook;\n  return [passthrough, hook];\n};\nvar HooksDispatcherOnUpdate = {\n  readContext: readContext,\n  use: use,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: updateReducer,\n  useRef: updateRef,\n  useState: function () {\n    return updateReducer(basicStateReducer);\n  },\n  useDebugValue: mountDebugValue,\n  useDeferredValue: function (value, initialValue) {\n    var hook = updateWorkInProgressHook();\n    return updateDeferredValueImpl(\n      hook,\n      currentHook.memoizedState,\n      value,\n      initialValue\n    );\n  },\n  useTransition: function () {\n    var booleanOrThenable = updateReducer(basicStateReducer)[0],\n      start = updateWorkInProgressHook().memoizedState;\n    return [\n      "boolean" === typeof booleanOrThenable\n        ? booleanOrThenable\n        : useThenable(booleanOrThenable),\n      start\n    ];\n  },\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId\n};\nHooksDispatcherOnUpdate.useCacheRefresh = updateRefresh;\nHooksDispatcherOnUpdate.useMemoCache = useMemoCache;\nHooksDispatcherOnUpdate.useHostTransitionStatus = useHostTransitionStatus;\nHooksDispatcherOnUpdate.useFormState = updateActionState;\nHooksDispatcherOnUpdate.useActionState = updateActionState;\nHooksDispatcherOnUpdate.useOptimistic = function (passthrough, reducer) {\n  var hook = updateWorkInProgressHook();\n  return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n};\nvar HooksDispatcherOnRerender = {\n  readContext: readContext,\n  use: use,\n  useCallback: updateCallback,\n  useContext: readContext,\n  useEffect: updateEffect,\n  useImperativeHandle: updateImperativeHandle,\n  useInsertionEffect: updateInsertionEffect,\n  useLayoutEffect: updateLayoutEffect,\n  useMemo: updateMemo,\n  useReducer: rerenderReducer,\n  useRef: updateRef,\n  useState: function () {\n    return rerenderReducer(basicStateReducer);\n  },\n  useDebugValue: mountDebugValue,\n  useDeferredValue: function (value, initialValue) {\n    var hook = updateWorkInProgressHook();\n    return null === currentHook\n      ? mountDeferredValueImpl(hook, value, initialValue)\n      : updateDeferredValueImpl(\n          hook,\n          currentHook.memoizedState,\n          value,\n          initialValue\n        );\n  },\n  useTransition: function () {\n    var booleanOrThenable = rerenderReducer(basicStateReducer)[0],\n      start = updateWorkInProgressHook().memoizedState;\n    return [\n      "boolean" === typeof booleanOrThenable\n        ? booleanOrThenable\n        : useThenable(booleanOrThenable),\n      start\n    ];\n  },\n  useSyncExternalStore: updateSyncExternalStore,\n  useId: updateId\n};\nHooksDispatcherOnRerender.useCacheRefresh = updateRefresh;\nHooksDispatcherOnRerender.useMemoCache = useMemoCache;\nHooksDispatcherOnRerender.useHostTransitionStatus = useHostTransitionStatus;\nHooksDispatcherOnRerender.useFormState = rerenderActionState;\nHooksDispatcherOnRerender.useActionState = rerenderActionState;\nHooksDispatcherOnRerender.useOptimistic = function (passthrough, reducer) {\n  var hook = updateWorkInProgressHook();\n  if (null !== currentHook)\n    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n  hook.baseState = passthrough;\n  return [passthrough, hook.queue.dispatch];\n};\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  ctor,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  ctor = workInProgress.memoizedState;\n  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);\n  getDerivedStateFromProps =\n    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps\n      ? ctor\n      : assign({}, ctor, getDerivedStateFromProps);\n  workInProgress.memoizedState = getDerivedStateFromProps;\n  0 === workInProgress.lanes &&\n    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);\n}\nvar classComponentUpdater = {\n  isMounted: function (component) {\n    return (component = component._reactInternals)\n      ? getNearestMountedFiber(component) === component\n      : !1;\n  },\n  enqueueSetState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 1;\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 2;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    callback = enqueueUpdate(inst, update, lane);\n    null !== callback &&\n      (scheduleUpdateOnFiber(callback, inst, lane),\n      entangleTransitions(callback, inst, lane));\n  }\n};\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext\n) {\n  workInProgress = workInProgress.stateNode;\n  return "function" === typeof workInProgress.shouldComponentUpdate\n    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)\n    : ctor.prototype && ctor.prototype.isPureReactComponent\n      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      : !0;\n}\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext\n) {\n  workInProgress = instance.state;\n  "function" === typeof instance.componentWillReceiveProps &&\n    instance.componentWillReceiveProps(newProps, nextContext);\n  "function" === typeof instance.UNSAFE_componentWillReceiveProps &&\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  instance.state !== workInProgress &&\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n}\nfunction resolveClassComponentProps(Component, baseProps) {\n  var newProps = baseProps;\n  if ("ref" in baseProps) {\n    newProps = {};\n    for (var propName in baseProps)\n      "ref" !== propName && (newProps[propName] = baseProps[propName]);\n  }\n  if ((Component = Component.defaultProps)) {\n    newProps === baseProps && (newProps = assign({}, newProps));\n    for (var propName$67 in Component)\n      void 0 === newProps[propName$67] &&\n        (newProps[propName$67] = Component[propName$67]);\n  }\n  return newProps;\n}\nvar reportGlobalError =\n  "function" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          "object" === typeof window &&\n          "function" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent("error", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              "object" === typeof error &&\n              null !== error &&\n              "string" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          "object" === typeof process &&\n          "function" === typeof process.emit\n        ) {\n          process.emit("uncaughtException", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction defaultOnUncaughtError(error) {\n  reportGlobalError(error);\n}\nfunction defaultOnCaughtError(error) {\n  console.error(error);\n}\nfunction defaultOnRecoverableError(error) {\n  reportGlobalError(error);\n}\nfunction logUncaughtError(root, errorInfo) {\n  try {\n    var onUncaughtError = root.onUncaughtError;\n    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });\n  } catch (e$68) {\n    setTimeout(function () {\n      throw e$68;\n    });\n  }\n}\nfunction logCaughtError(root, boundary, errorInfo) {\n  try {\n    var onCaughtError = root.onCaughtError;\n    onCaughtError(errorInfo.value, {\n      componentStack: errorInfo.stack,\n      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n    });\n  } catch (e$69) {\n    setTimeout(function () {\n      throw e$69;\n    });\n  }\n}\nfunction createRootErrorUpdate(root, errorInfo, lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  lane.payload = { element: null };\n  lane.callback = function () {\n    logUncaughtError(root, errorInfo);\n  };\n  return lane;\n}\nfunction createClassErrorUpdate(lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  return lane;\n}\nfunction initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if ("function" === typeof getDerivedStateFromError) {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromError(error);\n    };\n    update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n    };\n  }\n  var inst = fiber.stateNode;\n  null !== inst &&\n    "function" === typeof inst.componentDidCatch &&\n    (update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n      "function" !== typeof getDerivedStateFromError &&\n        (null === legacyErrorBoundariesThatAlreadyFailed\n          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))\n          : legacyErrorBoundariesThatAlreadyFailed.add(this));\n      var stack = errorInfo.stack;\n      this.componentDidCatch(errorInfo.value, {\n        componentStack: null !== stack ? stack : ""\n      });\n    });\n}\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  rootRenderLanes\n) {\n  sourceFiber.flags |= 32768;\n  if (\n    null !== value &&\n    "object" === typeof value &&\n    "function" === typeof value.then\n  ) {\n    returnFiber = sourceFiber.alternate;\n    null !== returnFiber &&\n      propagateParentContextChanges(\n        returnFiber,\n        sourceFiber,\n        rootRenderLanes,\n        !0\n      );\n    sourceFiber = suspenseHandlerStackCursor.current;\n    if (null !== sourceFiber) {\n      switch (sourceFiber.tag) {\n        case 13:\n          return (\n            null === shellBoundary\n              ? renderDidSuspendDelayIfPossible()\n              : null === sourceFiber.alternate &&\n                0 === workInProgressRootExitStatus &&\n                (workInProgressRootExitStatus = 3),\n            (sourceFiber.flags &= -257),\n            (sourceFiber.flags |= 65536),\n            (sourceFiber.lanes = rootRenderLanes),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? (sourceFiber.updateQueue = new Set([value]))\n                  : returnFiber.add(value),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n        case 22:\n          return (\n            (sourceFiber.flags |= 65536),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? ((returnFiber = {\n                      transitions: null,\n                      markerInstances: null,\n                      retryQueue: new Set([value])\n                    }),\n                    (sourceFiber.updateQueue = returnFiber))\n                  : ((sourceFiber = returnFiber.retryQueue),\n                    null === sourceFiber\n                      ? (returnFiber.retryQueue = new Set([value]))\n                      : sourceFiber.add(value)),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n      }\n      throw Error(formatProdErrorMessage(435, sourceFiber.tag));\n    }\n    attachPingListener(root, value, rootRenderLanes);\n    renderDidSuspendDelayIfPossible();\n    return !1;\n  }\n  if (isHydrating)\n    return (\n      (returnFiber = suspenseHandlerStackCursor.current),\n      null !== returnFiber\n        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),\n          (returnFiber.flags |= 65536),\n          (returnFiber.lanes = rootRenderLanes),\n          value !== HydrationMismatchException &&\n            ((root = Error(formatProdErrorMessage(422), { cause: value })),\n            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))\n        : (value !== HydrationMismatchException &&\n            ((returnFiber = Error(formatProdErrorMessage(423), {\n              cause: value\n            })),\n            queueHydrationError(\n              createCapturedValueAtFiber(returnFiber, sourceFiber)\n            )),\n          (root = root.current.alternate),\n          (root.flags |= 65536),\n          (rootRenderLanes &= -rootRenderLanes),\n          (root.lanes |= rootRenderLanes),\n          (value = createCapturedValueAtFiber(value, sourceFiber)),\n          (rootRenderLanes = createRootErrorUpdate(\n            root.stateNode,\n            value,\n            rootRenderLanes\n          )),\n          enqueueCapturedUpdate(root, rootRenderLanes),\n          4 !== workInProgressRootExitStatus &&\n            (workInProgressRootExitStatus = 2)),\n      !1\n    );\n  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });\n  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);\n  null === workInProgressRootConcurrentErrors\n    ? (workInProgressRootConcurrentErrors = [wrapperError])\n    : workInProgressRootConcurrentErrors.push(wrapperError);\n  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);\n  if (null === returnFiber) return !0;\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  sourceFiber = returnFiber;\n  do {\n    switch (sourceFiber.tag) {\n      case 3:\n        return (\n          (sourceFiber.flags |= 65536),\n          (root = rootRenderLanes & -rootRenderLanes),\n          (sourceFiber.lanes |= root),\n          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),\n          enqueueCapturedUpdate(sourceFiber, root),\n          !1\n        );\n      case 1:\n        if (\n          ((returnFiber = sourceFiber.type),\n          (wrapperError = sourceFiber.stateNode),\n          0 === (sourceFiber.flags & 128) &&\n            ("function" === typeof returnFiber.getDerivedStateFromError ||\n              (null !== wrapperError &&\n                "function" === typeof wrapperError.componentDidCatch &&\n                (null === legacyErrorBoundariesThatAlreadyFailed ||\n                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))\n        )\n          return (\n            (sourceFiber.flags |= 65536),\n            (rootRenderLanes &= -rootRenderLanes),\n            (sourceFiber.lanes |= rootRenderLanes),\n            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),\n            initializeClassErrorUpdate(\n              rootRenderLanes,\n              root,\n              sourceFiber,\n              value\n            ),\n            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),\n            !1\n          );\n    }\n    sourceFiber = sourceFiber.return;\n  } while (null !== sourceFiber);\n  return !1;\n}\nvar SelectiveHydrationException = Error(formatProdErrorMessage(461)),\n  didReceiveUpdate = !1;\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  workInProgress.child =\n    null === current\n      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)\n      : reconcileChildFibers(\n          workInProgress,\n          current.child,\n          nextChildren,\n          renderLanes\n        );\n}\nfunction updateForwardRef(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  Component = Component.render;\n  var ref = workInProgress.ref;\n  if ("ref" in nextProps) {\n    var propsWithoutRef = {};\n    for (var key in nextProps)\n      "ref" !== key && (propsWithoutRef[key] = nextProps[key]);\n  } else propsWithoutRef = nextProps;\n  prepareToReadContext(workInProgress);\n  nextProps = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    propsWithoutRef,\n    ref,\n    renderLanes\n  );\n  key = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && key && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null === current) {\n    var type = Component.type;\n    if (\n      "function" === typeof type &&\n      !shouldConstruct(type) &&\n      void 0 === type.defaultProps &&\n      null === Component.compare\n    )\n      return (\n        (workInProgress.tag = 15),\n        (workInProgress.type = type),\n        updateSimpleMemoComponent(\n          current,\n          workInProgress,\n          type,\n          nextProps,\n          renderLanes\n        )\n      );\n    current = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      workInProgress,\n      workInProgress.mode,\n      renderLanes\n    );\n    current.ref = workInProgress.ref;\n    current.return = workInProgress;\n    return (workInProgress.child = current);\n  }\n  type = current.child;\n  if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n    var prevProps = type.memoizedProps;\n    Component = Component.compare;\n    Component = null !== Component ? Component : shallowEqual;\n    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  workInProgress.flags |= 1;\n  current = createWorkInProgress(type, nextProps);\n  current.ref = workInProgress.ref;\n  current.return = workInProgress;\n  return (workInProgress.child = current);\n}\nfunction updateSimpleMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null !== current) {\n    var prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref\n    )\n      if (\n        ((didReceiveUpdate = !1),\n        (workInProgress.pendingProps = nextProps = prevProps),\n        checkScheduledUpdateOrContext(current, renderLanes))\n      )\n        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n      else\n        return (\n          (workInProgress.lanes = current.lanes),\n          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n        );\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderLanes\n  );\n}\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    nextChildren = nextProps.children,\n    nextIsDetached = 0 !== (workInProgress.stateNode._pendingVisibility & 2),\n    prevState = null !== current ? current.memoizedState : null;\n  markRef(current, workInProgress);\n  if ("hidden" === nextProps.mode || nextIsDetached) {\n    if (0 !== (workInProgress.flags & 128)) {\n      nextProps =\n        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n      if (null !== current) {\n        nextChildren = workInProgress.child = current.child;\n        for (nextIsDetached = 0; null !== nextChildren; )\n          (nextIsDetached =\n            nextIsDetached | nextChildren.lanes | nextChildren.childLanes),\n            (nextChildren = nextChildren.sibling);\n        workInProgress.childLanes = nextIsDetached & ~nextProps;\n      } else (workInProgress.childLanes = 0), (workInProgress.child = null);\n      return deferHiddenOffscreenComponent(\n        current,\n        workInProgress,\n        nextProps,\n        renderLanes\n      );\n    }\n    if (0 !== (renderLanes & 536870912))\n      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),\n        null !== current &&\n          pushTransition(\n            workInProgress,\n            null !== prevState ? prevState.cachePool : null\n          ),\n        null !== prevState\n          ? pushHiddenContext(workInProgress, prevState)\n          : reuseHiddenContextOnStack(),\n        pushOffscreenSuspenseHandler(workInProgress);\n    else\n      return (\n        (workInProgress.lanes = workInProgress.childLanes = 536870912),\n        deferHiddenOffscreenComponent(\n          current,\n          workInProgress,\n          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,\n          renderLanes\n        )\n      );\n  } else\n    null !== prevState\n      ? (pushTransition(workInProgress, prevState.cachePool),\n        pushHiddenContext(workInProgress, prevState),\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (workInProgress.memoizedState = null))\n      : (null !== current && pushTransition(workInProgress, null),\n        reuseHiddenContextOnStack(),\n        reuseSuspenseHandlerOnStack(workInProgress));\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nfunction deferHiddenOffscreenComponent(\n  current,\n  workInProgress,\n  nextBaseLanes,\n  renderLanes\n) {\n  var JSCompiler_inline_result = peekCacheFromPool();\n  JSCompiler_inline_result =\n    null === JSCompiler_inline_result\n      ? null\n      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };\n  workInProgress.memoizedState = {\n    baseLanes: nextBaseLanes,\n    cachePool: JSCompiler_inline_result\n  };\n  null !== current && pushTransition(workInProgress, null);\n  reuseHiddenContextOnStack();\n  pushOffscreenSuspenseHandler(workInProgress);\n  null !== current &&\n    propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n  return null;\n}\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n  if (null === ref)\n    null !== current &&\n      null !== current.ref &&\n      (workInProgress.flags |= 2097664);\n  else {\n    if ("function" !== typeof ref && "object" !== typeof ref)\n      throw Error(formatProdErrorMessage(284));\n    if (null === current || current.ref !== ref)\n      workInProgress.flags |= 2097664;\n  }\n}\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  Component = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    void 0,\n    renderLanes\n  );\n  nextProps = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, Component, renderLanes);\n  return workInProgress.child;\n}\nfunction replayFunctionComponent(\n  current,\n  workInProgress,\n  nextProps,\n  Component,\n  secondArg,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  workInProgress.updateQueue = null;\n  nextProps = renderWithHooksAgain(\n    workInProgress,\n    Component,\n    nextProps,\n    secondArg\n  );\n  finishRenderingHooks(current);\n  Component = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && Component && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateClassComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  if (null === workInProgress.stateNode) {\n    var context = emptyContextObject,\n      contextType = Component.contextType;\n    "object" === typeof contextType &&\n      null !== contextType &&\n      (context = readContext(contextType));\n    context = new Component(nextProps, context);\n    workInProgress.memoizedState =\n      null !== context.state && void 0 !== context.state ? context.state : null;\n    context.updater = classComponentUpdater;\n    workInProgress.stateNode = context;\n    context._reactInternals = workInProgress;\n    context = workInProgress.stateNode;\n    context.props = nextProps;\n    context.state = workInProgress.memoizedState;\n    context.refs = {};\n    initializeUpdateQueue(workInProgress);\n    contextType = Component.contextType;\n    context.context =\n      "object" === typeof contextType && null !== contextType\n        ? readContext(contextType)\n        : emptyContextObject;\n    context.state = workInProgress.memoizedState;\n    contextType = Component.getDerivedStateFromProps;\n    "function" === typeof contextType &&\n      (applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        contextType,\n        nextProps\n      ),\n      (context.state = workInProgress.memoizedState));\n    "function" === typeof Component.getDerivedStateFromProps ||\n      "function" === typeof context.getSnapshotBeforeUpdate ||\n      ("function" !== typeof context.UNSAFE_componentWillMount &&\n        "function" !== typeof context.componentWillMount) ||\n      ((contextType = context.state),\n      "function" === typeof context.componentWillMount &&\n        context.componentWillMount(),\n      "function" === typeof context.UNSAFE_componentWillMount &&\n        context.UNSAFE_componentWillMount(),\n      contextType !== context.state &&\n        classComponentUpdater.enqueueReplaceState(context, context.state, null),\n      processUpdateQueue(workInProgress, nextProps, context, renderLanes),\n      suspendIfUpdateReadFromEntangledAsyncAction(),\n      (context.state = workInProgress.memoizedState));\n    "function" === typeof context.componentDidMount &&\n      (workInProgress.flags |= 4194308);\n    nextProps = !0;\n  } else if (null === current) {\n    context = workInProgress.stateNode;\n    var unresolvedOldProps = workInProgress.memoizedProps,\n      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);\n    context.props = oldProps;\n    var oldContext = context.context,\n      contextType$jscomp$0 = Component.contextType;\n    contextType = emptyContextObject;\n    "object" === typeof contextType$jscomp$0 &&\n      null !== contextType$jscomp$0 &&\n      (contextType = readContext(contextType$jscomp$0));\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    contextType$jscomp$0 =\n      "function" === typeof getDerivedStateFromProps ||\n      "function" === typeof context.getSnapshotBeforeUpdate;\n    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n    contextType$jscomp$0 ||\n      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        "function" !== typeof context.componentWillReceiveProps) ||\n      ((unresolvedOldProps || oldContext !== contextType) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          contextType\n        ));\n    hasForceUpdate = !1;\n    var oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    oldContext = workInProgress.memoizedState;\n    unresolvedOldProps || oldState !== oldContext || hasForceUpdate\n      ? ("function" === typeof getDerivedStateFromProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            getDerivedStateFromProps,\n            nextProps\n          ),\n          (oldContext = workInProgress.memoizedState)),\n        (oldProps =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            oldProps,\n            nextProps,\n            oldState,\n            oldContext,\n            contextType\n          ))\n          ? (contextType$jscomp$0 ||\n              ("function" !== typeof context.UNSAFE_componentWillMount &&\n                "function" !== typeof context.componentWillMount) ||\n              ("function" === typeof context.componentWillMount &&\n                context.componentWillMount(),\n              "function" === typeof context.UNSAFE_componentWillMount &&\n                context.UNSAFE_componentWillMount()),\n            "function" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308))\n          : ("function" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = oldContext)),\n        (context.props = nextProps),\n        (context.state = oldContext),\n        (context.context = contextType),\n        (nextProps = oldProps))\n      : ("function" === typeof context.componentDidMount &&\n          (workInProgress.flags |= 4194308),\n        (nextProps = !1));\n  } else {\n    context = workInProgress.stateNode;\n    cloneUpdateQueue(current, workInProgress);\n    contextType = workInProgress.memoizedProps;\n    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);\n    context.props = contextType$jscomp$0;\n    getDerivedStateFromProps = workInProgress.pendingProps;\n    oldState = context.context;\n    oldContext = Component.contextType;\n    oldProps = emptyContextObject;\n    "object" === typeof oldContext &&\n      null !== oldContext &&\n      (oldProps = readContext(oldContext));\n    unresolvedOldProps = Component.getDerivedStateFromProps;\n    (oldContext =\n      "function" === typeof unresolvedOldProps ||\n      "function" === typeof context.getSnapshotBeforeUpdate) ||\n      ("function" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        "function" !== typeof context.componentWillReceiveProps) ||\n      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          oldProps\n        ));\n    hasForceUpdate = !1;\n    oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    var newState = workInProgress.memoizedState;\n    contextType !== getDerivedStateFromProps ||\n    oldState !== newState ||\n    hasForceUpdate ||\n    (null !== current &&\n      null !== current.dependencies &&\n      checkIfContextChanged(current.dependencies))\n      ? ("function" === typeof unresolvedOldProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            unresolvedOldProps,\n            nextProps\n          ),\n          (newState = workInProgress.memoizedState)),\n        (contextType$jscomp$0 =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            contextType$jscomp$0,\n            nextProps,\n            oldState,\n            newState,\n            oldProps\n          ) ||\n          (null !== current &&\n            null !== current.dependencies &&\n            checkIfContextChanged(current.dependencies)))\n          ? (oldContext ||\n              ("function" !== typeof context.UNSAFE_componentWillUpdate &&\n                "function" !== typeof context.componentWillUpdate) ||\n              ("function" === typeof context.componentWillUpdate &&\n                context.componentWillUpdate(nextProps, newState, oldProps),\n              "function" === typeof context.UNSAFE_componentWillUpdate &&\n                context.UNSAFE_componentWillUpdate(\n                  nextProps,\n                  newState,\n                  oldProps\n                )),\n            "function" === typeof context.componentDidUpdate &&\n              (workInProgress.flags |= 4),\n            "function" === typeof context.getSnapshotBeforeUpdate &&\n              (workInProgress.flags |= 1024))\n          : ("function" !== typeof context.componentDidUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 4),\n            "function" !== typeof context.getSnapshotBeforeUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 1024),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = newState)),\n        (context.props = nextProps),\n        (context.state = newState),\n        (context.context = oldProps),\n        (nextProps = contextType$jscomp$0))\n      : ("function" !== typeof context.componentDidUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 4),\n        "function" !== typeof context.getSnapshotBeforeUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 1024),\n        (nextProps = !1));\n  }\n  context = nextProps;\n  markRef(current, workInProgress);\n  nextProps = 0 !== (workInProgress.flags & 128);\n  context || nextProps\n    ? ((context = workInProgress.stateNode),\n      (Component =\n        nextProps && "function" !== typeof Component.getDerivedStateFromError\n          ? null\n          : context.render()),\n      (workInProgress.flags |= 1),\n      null !== current && nextProps\n        ? ((workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            current.child,\n            null,\n            renderLanes\n          )),\n          (workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            null,\n            Component,\n            renderLanes\n          )))\n        : reconcileChildren(current, workInProgress, Component, renderLanes),\n      (workInProgress.memoizedState = context.state),\n      (current = workInProgress.child))\n    : (current = bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderLanes\n      ));\n  return current;\n}\nfunction mountHostRootWithoutHydrating(\n  current,\n  workInProgress,\n  nextChildren,\n  renderLanes\n) {\n  resetHydrationState();\n  workInProgress.flags |= 256;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nvar SUSPENDED_MARKER = { dehydrated: null, treeContext: null, retryLane: 0 };\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };\n}\nfunction getRemainingWorkInPrimaryTree(\n  current,\n  primaryTreeDidDefer,\n  renderLanes\n) {\n  current = null !== current ? current.childLanes & ~renderLanes : 0;\n  primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n  return current;\n}\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    showFallback = !1,\n    didSuspend = 0 !== (workInProgress.flags & 128),\n    JSCompiler_temp;\n  (JSCompiler_temp = didSuspend) ||\n    (JSCompiler_temp =\n      null !== current && null === current.memoizedState\n        ? !1\n        : 0 !== (suspenseStackCursor.current & 2));\n  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));\n  JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n  workInProgress.flags &= -33;\n  if (null === current) {\n    if (isHydrating) {\n      showFallback\n        ? pushPrimaryTreeSuspenseHandler(workInProgress)\n        : reuseSuspenseHandlerOnStack(workInProgress);\n      if (isHydrating) {\n        var nextInstance = nextHydratableInstance,\n          JSCompiler_temp$jscomp$0;\n        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {\n          c: {\n            JSCompiler_temp$jscomp$0 = nextInstance;\n            for (\n              nextInstance = rootOrSingletonContext;\n              8 !== JSCompiler_temp$jscomp$0.nodeType;\n\n            ) {\n              if (!nextInstance) {\n                nextInstance = null;\n                break c;\n              }\n              JSCompiler_temp$jscomp$0 = getNextHydratable(\n                JSCompiler_temp$jscomp$0.nextSibling\n              );\n              if (null === JSCompiler_temp$jscomp$0) {\n                nextInstance = null;\n                break c;\n              }\n            }\n            nextInstance = JSCompiler_temp$jscomp$0;\n          }\n          null !== nextInstance\n            ? ((workInProgress.memoizedState = {\n                dehydrated: nextInstance,\n                treeContext:\n                  null !== treeContextProvider\n                    ? { id: treeContextId, overflow: treeContextOverflow }\n                    : null,\n                retryLane: 536870912\n              }),\n              (JSCompiler_temp$jscomp$0 = createFiberImplClass(\n                18,\n                null,\n                null,\n                0\n              )),\n              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),\n              (JSCompiler_temp$jscomp$0.return = workInProgress),\n              (workInProgress.child = JSCompiler_temp$jscomp$0),\n              (hydrationParentFiber = workInProgress),\n              (nextHydratableInstance = null),\n              (JSCompiler_temp$jscomp$0 = !0))\n            : (JSCompiler_temp$jscomp$0 = !1);\n        }\n        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);\n      }\n      nextInstance = workInProgress.memoizedState;\n      if (\n        null !== nextInstance &&\n        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)\n      )\n        return (\n          "$!" === nextInstance.data\n            ? (workInProgress.lanes = 16)\n            : (workInProgress.lanes = 536870912),\n          null\n        );\n      popSuspenseHandler(workInProgress);\n    }\n    nextInstance = nextProps.children;\n    nextProps = nextProps.fallback;\n    if (showFallback)\n      return (\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (showFallback = workInProgress.mode),\n        (nextInstance = mountWorkInProgressOffscreenFiber(\n          { mode: "hidden", children: nextInstance },\n          showFallback\n        )),\n        (nextProps = createFiberFromFragment(\n          nextProps,\n          showFallback,\n          renderLanes,\n          null\n        )),\n        (nextInstance.return = workInProgress),\n        (nextProps.return = workInProgress),\n        (nextInstance.sibling = nextProps),\n        (workInProgress.child = nextInstance),\n        (showFallback = workInProgress.child),\n        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),\n        (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n          current,\n          JSCompiler_temp,\n          renderLanes\n        )),\n        (workInProgress.memoizedState = SUSPENDED_MARKER),\n        nextProps\n      );\n    pushPrimaryTreeSuspenseHandler(workInProgress);\n    return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n  }\n  JSCompiler_temp$jscomp$0 = current.memoizedState;\n  if (\n    null !== JSCompiler_temp$jscomp$0 &&\n    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),\n    null !== nextInstance)\n  ) {\n    if (didSuspend)\n      workInProgress.flags & 256\n        ? (pushPrimaryTreeSuspenseHandler(workInProgress),\n          (workInProgress.flags &= -257),\n          (workInProgress = retrySuspenseComponentWithoutHydrating(\n            current,\n            workInProgress,\n            renderLanes\n          )))\n        : null !== workInProgress.memoizedState\n          ? (reuseSuspenseHandlerOnStack(workInProgress),\n            (workInProgress.child = current.child),\n            (workInProgress.flags |= 128),\n            (workInProgress = null))\n          : (reuseSuspenseHandlerOnStack(workInProgress),\n            (showFallback = nextProps.fallback),\n            (nextInstance = workInProgress.mode),\n            (nextProps = mountWorkInProgressOffscreenFiber(\n              { mode: "visible", children: nextProps.children },\n              nextInstance\n            )),\n            (showFallback = createFiberFromFragment(\n              showFallback,\n              nextInstance,\n              renderLanes,\n              null\n            )),\n            (showFallback.flags |= 2),\n            (nextProps.return = workInProgress),\n            (showFallback.return = workInProgress),\n            (nextProps.sibling = showFallback),\n            (workInProgress.child = nextProps),\n            reconcileChildFibers(\n              workInProgress,\n              current.child,\n              null,\n              renderLanes\n            ),\n            (nextProps = workInProgress.child),\n            (nextProps.memoizedState =\n              mountSuspenseOffscreenState(renderLanes)),\n            (nextProps.childLanes = getRemainingWorkInPrimaryTree(\n              current,\n              JSCompiler_temp,\n              renderLanes\n            )),\n            (workInProgress.memoizedState = SUSPENDED_MARKER),\n            (workInProgress = showFallback));\n    else if (\n      (pushPrimaryTreeSuspenseHandler(workInProgress),\n      "$!" === nextInstance.data)\n    ) {\n      JSCompiler_temp =\n        nextInstance.nextSibling && nextInstance.nextSibling.dataset;\n      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;\n      JSCompiler_temp = digest;\n      nextProps = Error(formatProdErrorMessage(419));\n      nextProps.stack = "";\n      nextProps.digest = JSCompiler_temp;\n      queueHydrationError({ value: nextProps, source: null, stack: null });\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else if (\n      (didReceiveUpdate ||\n        propagateParentContextChanges(current, workInProgress, renderLanes, !1),\n      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),\n      didReceiveUpdate || JSCompiler_temp)\n    ) {\n      JSCompiler_temp = workInProgressRoot;\n      if (null !== JSCompiler_temp) {\n        nextProps = renderLanes & -renderLanes;\n        if (0 !== (nextProps & 42)) nextProps = 1;\n        else\n          switch (nextProps) {\n            case 2:\n              nextProps = 1;\n              break;\n            case 8:\n              nextProps = 4;\n              break;\n            case 32:\n              nextProps = 16;\n              break;\n            case 128:\n            case 256:\n            case 512:\n            case 1024:\n            case 2048:\n            case 4096:\n            case 8192:\n            case 16384:\n            case 32768:\n            case 65536:\n            case 131072:\n            case 262144:\n            case 524288:\n            case 1048576:\n            case 2097152:\n            case 4194304:\n            case 8388608:\n            case 16777216:\n            case 33554432:\n              nextProps = 64;\n              break;\n            case 268435456:\n              nextProps = 134217728;\n              break;\n            default:\n              nextProps = 0;\n          }\n        nextProps =\n          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))\n            ? 0\n            : nextProps;\n        if (0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)\n          throw (\n            ((JSCompiler_temp$jscomp$0.retryLane = nextProps),\n            enqueueConcurrentRenderForLane(current, nextProps),\n            scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),\n            SelectiveHydrationException)\n          );\n      }\n      "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else\n      "$?" === nextInstance.data\n        ? ((workInProgress.flags |= 128),\n          (workInProgress.child = current.child),\n          (workInProgress = retryDehydratedSuspenseBoundary.bind(\n            null,\n            current\n          )),\n          (nextInstance._reactRetry = workInProgress),\n          (workInProgress = null))\n        : ((current = JSCompiler_temp$jscomp$0.treeContext),\n          (nextHydratableInstance = getNextHydratable(\n            nextInstance.nextSibling\n          )),\n          (hydrationParentFiber = workInProgress),\n          (isHydrating = !0),\n          (hydrationErrors = null),\n          (rootOrSingletonContext = !1),\n          null !== current &&\n            ((idStack[idStackIndex++] = treeContextId),\n            (idStack[idStackIndex++] = treeContextOverflow),\n            (idStack[idStackIndex++] = treeContextProvider),\n            (treeContextId = current.id),\n            (treeContextOverflow = current.overflow),\n            (treeContextProvider = workInProgress)),\n          (workInProgress = mountSuspensePrimaryChildren(\n            workInProgress,\n            nextProps.children\n          )),\n          (workInProgress.flags |= 4096));\n    return workInProgress;\n  }\n  if (showFallback)\n    return (\n      reuseSuspenseHandlerOnStack(workInProgress),\n      (showFallback = nextProps.fallback),\n      (nextInstance = workInProgress.mode),\n      (JSCompiler_temp$jscomp$0 = current.child),\n      (digest = JSCompiler_temp$jscomp$0.sibling),\n      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n        mode: "hidden",\n        children: nextProps.children\n      })),\n      (nextProps.subtreeFlags =\n        JSCompiler_temp$jscomp$0.subtreeFlags & 31457280),\n      null !== digest\n        ? (showFallback = createWorkInProgress(digest, showFallback))\n        : ((showFallback = createFiberFromFragment(\n            showFallback,\n            nextInstance,\n            renderLanes,\n            null\n          )),\n          (showFallback.flags |= 2)),\n      (showFallback.return = workInProgress),\n      (nextProps.return = workInProgress),\n      (nextProps.sibling = showFallback),\n      (workInProgress.child = nextProps),\n      (nextProps = showFallback),\n      (showFallback = workInProgress.child),\n      (nextInstance = current.child.memoizedState),\n      null === nextInstance\n        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))\n        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),\n          null !== JSCompiler_temp$jscomp$0\n            ? ((digest = CacheContext._currentValue),\n              (JSCompiler_temp$jscomp$0 =\n                JSCompiler_temp$jscomp$0.parent !== digest\n                  ? { parent: digest, pool: digest }\n                  : JSCompiler_temp$jscomp$0))\n            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),\n          (nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n          })),\n      (showFallback.memoizedState = nextInstance),\n      (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n        current,\n        JSCompiler_temp,\n        renderLanes\n      )),\n      (workInProgress.memoizedState = SUSPENDED_MARKER),\n      nextProps\n    );\n  pushPrimaryTreeSuspenseHandler(workInProgress);\n  renderLanes = current.child;\n  current = renderLanes.sibling;\n  renderLanes = createWorkInProgress(renderLanes, {\n    mode: "visible",\n    children: nextProps.children\n  });\n  renderLanes.return = workInProgress;\n  renderLanes.sibling = null;\n  null !== current &&\n    ((JSCompiler_temp = workInProgress.deletions),\n    null === JSCompiler_temp\n      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))\n      : JSCompiler_temp.push(current));\n  workInProgress.child = renderLanes;\n  workInProgress.memoizedState = null;\n  return renderLanes;\n}\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n  primaryChildren = mountWorkInProgressOffscreenFiber(\n    { mode: "visible", children: primaryChildren },\n    workInProgress.mode\n  );\n  primaryChildren.return = workInProgress;\n  return (workInProgress.child = primaryChildren);\n}\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n  return createFiberFromOffscreen(offscreenProps, mode, 0, null);\n}\nfunction retrySuspenseComponentWithoutHydrating(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  current = mountSuspensePrimaryChildren(\n    workInProgress,\n    workInProgress.pendingProps.children\n  );\n  current.flags |= 2;\n  workInProgress.memoizedState = null;\n  return current;\n}\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes |= renderLanes;\n  var alternate = fiber.alternate;\n  null !== alternate && (alternate.lanes |= renderLanes);\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\nfunction initSuspenseListRenderState(\n  workInProgress,\n  isBackwards,\n  tail,\n  lastContentRow,\n  tailMode\n) {\n  var renderState = workInProgress.memoizedState;\n  null === renderState\n    ? (workInProgress.memoizedState = {\n        isBackwards: isBackwards,\n        rendering: null,\n        renderingStartTime: 0,\n        last: lastContentRow,\n        tail: tail,\n        tailMode: tailMode\n      })\n    : ((renderState.isBackwards = isBackwards),\n      (renderState.rendering = null),\n      (renderState.renderingStartTime = 0),\n      (renderState.last = lastContentRow),\n      (renderState.tail = tail),\n      (renderState.tailMode = tailMode));\n}\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    revealOrder = nextProps.revealOrder,\n    tailMode = nextProps.tail;\n  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);\n  nextProps = suspenseStackCursor.current;\n  if (0 !== (nextProps & 2))\n    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);\n  else {\n    if (null !== current && 0 !== (current.flags & 128))\n      a: for (current = workInProgress.child; null !== current; ) {\n        if (13 === current.tag)\n          null !== current.memoizedState &&\n            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (19 === current.tag)\n          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (null !== current.child) {\n          current.child.return = current;\n          current = current.child;\n          continue;\n        }\n        if (current === workInProgress) break a;\n        for (; null === current.sibling; ) {\n          if (null === current.return || current.return === workInProgress)\n            break a;\n          current = current.return;\n        }\n        current.sibling.return = current.return;\n        current = current.sibling;\n      }\n    nextProps &= 1;\n  }\n  push(suspenseStackCursor, nextProps);\n  switch (revealOrder) {\n    case "forwards":\n      renderLanes = workInProgress.child;\n      for (revealOrder = null; null !== renderLanes; )\n        (current = renderLanes.alternate),\n          null !== current &&\n            null === findFirstSuspended(current) &&\n            (revealOrder = renderLanes),\n          (renderLanes = renderLanes.sibling);\n      renderLanes = revealOrder;\n      null === renderLanes\n        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))\n        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));\n      initSuspenseListRenderState(\n        workInProgress,\n        !1,\n        revealOrder,\n        renderLanes,\n        tailMode\n      );\n      break;\n    case "backwards":\n      renderLanes = null;\n      revealOrder = workInProgress.child;\n      for (workInProgress.child = null; null !== revealOrder; ) {\n        current = revealOrder.alternate;\n        if (null !== current && null === findFirstSuspended(current)) {\n          workInProgress.child = revealOrder;\n          break;\n        }\n        current = revealOrder.sibling;\n        revealOrder.sibling = renderLanes;\n        renderLanes = revealOrder;\n        revealOrder = current;\n      }\n      initSuspenseListRenderState(\n        workInProgress,\n        !0,\n        renderLanes,\n        null,\n        tailMode\n      );\n      break;\n    case "together":\n      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n      break;\n    default:\n      workInProgress.memoizedState = null;\n  }\n  return workInProgress.child;\n}\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  null !== current && (workInProgress.dependencies = current.dependencies);\n  workInProgressRootSkippedLanes |= workInProgress.lanes;\n  if (0 === (renderLanes & workInProgress.childLanes))\n    if (null !== current) {\n      if (\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        0 === (renderLanes & workInProgress.childLanes))\n      )\n        return null;\n    } else return null;\n  if (null !== current && workInProgress.child !== current.child)\n    throw Error(formatProdErrorMessage(153));\n  if (null !== workInProgress.child) {\n    current = workInProgress.child;\n    renderLanes = createWorkInProgress(current, current.pendingProps);\n    workInProgress.child = renderLanes;\n    for (renderLanes.return = workInProgress; null !== current.sibling; )\n      (current = current.sibling),\n        (renderLanes = renderLanes.sibling =\n          createWorkInProgress(current, current.pendingProps)),\n        (renderLanes.return = workInProgress);\n    renderLanes.sibling = null;\n  }\n  return workInProgress.child;\n}\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  if (0 !== (current.lanes & renderLanes)) return !0;\n  current = current.dependencies;\n  return null !== current && checkIfContextChanged(current) ? !0 : !1;\n}\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  switch (workInProgress.tag) {\n    case 3:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n      resetHydrationState();\n      break;\n    case 27:\n    case 5:\n      pushHostContext(workInProgress);\n      break;\n    case 4:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case 10:\n      pushProvider(\n        workInProgress,\n        workInProgress.type,\n        workInProgress.memoizedProps.value\n      );\n      break;\n    case 13:\n      var state = workInProgress.memoizedState;\n      if (null !== state) {\n        if (null !== state.dehydrated)\n          return (\n            pushPrimaryTreeSuspenseHandler(workInProgress),\n            (workInProgress.flags |= 128),\n            null\n          );\n        if (0 !== (renderLanes & workInProgress.child.childLanes))\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        current = bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes\n        );\n        return null !== current ? current.sibling : null;\n      }\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      break;\n    case 19:\n      var didSuspendBefore = 0 !== (current.flags & 128);\n      state = 0 !== (renderLanes & workInProgress.childLanes);\n      state ||\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        (state = 0 !== (renderLanes & workInProgress.childLanes)));\n      if (didSuspendBefore) {\n        if (state)\n          return updateSuspenseListComponent(\n            current,\n            workInProgress,\n            renderLanes\n          );\n        workInProgress.flags |= 128;\n      }\n      didSuspendBefore = workInProgress.memoizedState;\n      null !== didSuspendBefore &&\n        ((didSuspendBefore.rendering = null),\n        (didSuspendBefore.tail = null),\n        (didSuspendBefore.lastEffect = null));\n      push(suspenseStackCursor, suspenseStackCursor.current);\n      if (state) break;\n      else return null;\n    case 22:\n    case 23:\n      return (\n        (workInProgress.lanes = 0),\n        updateOffscreenComponent(current, workInProgress, renderLanes)\n      );\n    case 24:\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n  }\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (null !== current)\n    if (current.memoizedProps !== workInProgress.pendingProps)\n      didReceiveUpdate = !0;\n    else {\n      if (\n        !checkScheduledUpdateOrContext(current, renderLanes) &&\n        0 === (workInProgress.flags & 128)\n      )\n        return (\n          (didReceiveUpdate = !1),\n          attemptEarlyBailoutIfNoScheduledUpdate(\n            current,\n            workInProgress,\n            renderLanes\n          )\n        );\n      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n    }\n  else\n    (didReceiveUpdate = !1),\n      isHydrating &&\n        0 !== (workInProgress.flags & 1048576) &&\n        pushTreeId(workInProgress, treeForkCount, workInProgress.index);\n  workInProgress.lanes = 0;\n  switch (workInProgress.tag) {\n    case 16:\n      a: {\n        current = workInProgress.pendingProps;\n        var lazyComponent = workInProgress.elementType,\n          init = lazyComponent._init;\n        lazyComponent = init(lazyComponent._payload);\n        workInProgress.type = lazyComponent;\n        if ("function" === typeof lazyComponent)\n          shouldConstruct(lazyComponent)\n            ? ((current = resolveClassComponentProps(lazyComponent, current)),\n              (workInProgress.tag = 1),\n              (workInProgress = updateClassComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )))\n            : ((workInProgress.tag = 0),\n              (workInProgress = updateFunctionComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )));\n        else {\n          if (void 0 !== lazyComponent && null !== lazyComponent)\n            if (\n              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)\n            ) {\n              workInProgress.tag = 11;\n              workInProgress = updateForwardRef(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            } else if (init === REACT_MEMO_TYPE) {\n              workInProgress.tag = 14;\n              workInProgress = updateMemoComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            }\n          workInProgress =\n            getComponentNameFromType(lazyComponent) || lazyComponent;\n          throw Error(formatProdErrorMessage(306, workInProgress, ""));\n        }\n      }\n      return workInProgress;\n    case 0:\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 1:\n      return (\n        (lazyComponent = workInProgress.type),\n        (init = resolveClassComponentProps(\n          lazyComponent,\n          workInProgress.pendingProps\n        )),\n        updateClassComponent(\n          current,\n          workInProgress,\n          lazyComponent,\n          init,\n          renderLanes\n        )\n      );\n    case 3:\n      a: {\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        if (null === current) throw Error(formatProdErrorMessage(387));\n        var nextProps = workInProgress.pendingProps;\n        init = workInProgress.memoizedState;\n        lazyComponent = init.element;\n        cloneUpdateQueue(current, workInProgress);\n        processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n        var nextState = workInProgress.memoizedState;\n        nextProps = nextState.cache;\n        pushProvider(workInProgress, CacheContext, nextProps);\n        nextProps !== init.cache &&\n          propagateContextChanges(\n            workInProgress,\n            [CacheContext],\n            renderLanes,\n            !0\n          );\n        suspendIfUpdateReadFromEntangledAsyncAction();\n        nextProps = nextState.element;\n        if (init.isDehydrated)\n          if (\n            ((init = {\n              element: nextProps,\n              isDehydrated: !1,\n              cache: nextState.cache\n            }),\n            (workInProgress.updateQueue.baseState = init),\n            (workInProgress.memoizedState = init),\n            workInProgress.flags & 256)\n          ) {\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              nextProps,\n              renderLanes\n            );\n            break a;\n          } else if (nextProps !== lazyComponent) {\n            lazyComponent = createCapturedValueAtFiber(\n              Error(formatProdErrorMessage(424)),\n              workInProgress\n            );\n            queueHydrationError(lazyComponent);\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              nextProps,\n              renderLanes\n            );\n            break a;\n          } else\n            for (\n              nextHydratableInstance = getNextHydratable(\n                workInProgress.stateNode.containerInfo.firstChild\n              ),\n                hydrationParentFiber = workInProgress,\n                isHydrating = !0,\n                hydrationErrors = null,\n                rootOrSingletonContext = !0,\n                renderLanes = mountChildFibers(\n                  workInProgress,\n                  null,\n                  nextProps,\n                  renderLanes\n                ),\n                workInProgress.child = renderLanes;\n              renderLanes;\n\n            )\n              (renderLanes.flags = (renderLanes.flags & -3) | 4096),\n                (renderLanes = renderLanes.sibling);\n        else {\n          resetHydrationState();\n          if (nextProps === lazyComponent) {\n            workInProgress = bailoutOnAlreadyFinishedWork(\n              current,\n              workInProgress,\n              renderLanes\n            );\n            break a;\n          }\n          reconcileChildren(current, workInProgress, nextProps, renderLanes);\n        }\n        workInProgress = workInProgress.child;\n      }\n      return workInProgress;\n    case 26:\n      return (\n        markRef(current, workInProgress),\n        null === current\n          ? (renderLanes = getResource(\n              workInProgress.type,\n              null,\n              workInProgress.pendingProps,\n              null\n            ))\n            ? (workInProgress.memoizedState = renderLanes)\n            : isHydrating ||\n              ((renderLanes = workInProgress.type),\n              (current = workInProgress.pendingProps),\n              (lazyComponent = getOwnerDocumentFromRootContainer(\n                rootInstanceStackCursor.current\n              ).createElement(renderLanes)),\n              (lazyComponent[internalInstanceKey] = workInProgress),\n              (lazyComponent[internalPropsKey] = current),\n              setInitialProperties(lazyComponent, renderLanes, current),\n              markNodeAsHoistable(lazyComponent),\n              (workInProgress.stateNode = lazyComponent))\n          : (workInProgress.memoizedState = getResource(\n              workInProgress.type,\n              current.memoizedProps,\n              workInProgress.pendingProps,\n              current.memoizedState\n            )),\n        null\n      );\n    case 27:\n      return (\n        pushHostContext(workInProgress),\n        null === current &&\n          isHydrating &&\n          ((lazyComponent = workInProgress.stateNode =\n            resolveSingletonInstance(\n              workInProgress.type,\n              workInProgress.pendingProps,\n              rootInstanceStackCursor.current\n            )),\n          (hydrationParentFiber = workInProgress),\n          (rootOrSingletonContext = !0),\n          (nextHydratableInstance = getNextHydratable(\n            lazyComponent.firstChild\n          ))),\n        (lazyComponent = workInProgress.pendingProps.children),\n        null !== current || isHydrating\n          ? reconcileChildren(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            )\n          : (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            )),\n        markRef(current, workInProgress),\n        workInProgress.child\n      );\n    case 5:\n      if (null === current && isHydrating) {\n        if ((init = lazyComponent = nextHydratableInstance))\n          (lazyComponent = canHydrateInstance(\n            lazyComponent,\n            workInProgress.type,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== lazyComponent\n              ? ((workInProgress.stateNode = lazyComponent),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = getNextHydratable(\n                  lazyComponent.firstChild\n                )),\n                (rootOrSingletonContext = !1),\n                (init = !0))\n              : (init = !1);\n        init || throwOnHydrationMismatch(workInProgress);\n      }\n      pushHostContext(workInProgress);\n      init = workInProgress.type;\n      nextProps = workInProgress.pendingProps;\n      nextState = null !== current ? current.memoizedProps : null;\n      lazyComponent = nextProps.children;\n      shouldSetTextContent(init, nextProps)\n        ? (lazyComponent = null)\n        : null !== nextState &&\n          shouldSetTextContent(init, nextState) &&\n          (workInProgress.flags |= 32);\n      null !== workInProgress.memoizedState &&\n        ((init = renderWithHooks(\n          current,\n          workInProgress,\n          TransitionAwareHostComponent,\n          null,\n          null,\n          renderLanes\n        )),\n        (HostTransitionContext._currentValue = init));\n      markRef(current, workInProgress);\n      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);\n      return workInProgress.child;\n    case 6:\n      if (null === current && isHydrating) {\n        if ((current = renderLanes = nextHydratableInstance))\n          (renderLanes = canHydrateTextInstance(\n            renderLanes,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== renderLanes\n              ? ((workInProgress.stateNode = renderLanes),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = null),\n                (current = !0))\n              : (current = !1);\n        current || throwOnHydrationMismatch(workInProgress);\n      }\n      return null;\n    case 13:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case 4:\n      return (\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        ),\n        (lazyComponent = workInProgress.pendingProps),\n        null === current\n          ? (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            ))\n          : reconcileChildren(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            ),\n        workInProgress.child\n      );\n    case 11:\n      return updateForwardRef(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 7:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 8:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 12:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 10:\n      return (\n        (lazyComponent = workInProgress.pendingProps),\n        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),\n        reconcileChildren(\n          current,\n          workInProgress,\n          lazyComponent.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 9:\n      return (\n        (init = workInProgress.type._context),\n        (lazyComponent = workInProgress.pendingProps.children),\n        prepareToReadContext(workInProgress),\n        (init = readContext(init)),\n        (lazyComponent = lazyComponent(init)),\n        (workInProgress.flags |= 1),\n        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),\n        workInProgress.child\n      );\n    case 14:\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 15:\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 19:\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    case 22:\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    case 24:\n      return (\n        prepareToReadContext(workInProgress),\n        (lazyComponent = readContext(CacheContext)),\n        null === current\n          ? ((init = peekCacheFromPool()),\n            null === init &&\n              ((init = workInProgressRoot),\n              (nextProps = createCache()),\n              (init.pooledCache = nextProps),\n              nextProps.refCount++,\n              null !== nextProps && (init.pooledCacheLanes |= renderLanes),\n              (init = nextProps)),\n            (workInProgress.memoizedState = {\n              parent: lazyComponent,\n              cache: init\n            }),\n            initializeUpdateQueue(workInProgress),\n            pushProvider(workInProgress, CacheContext, init))\n          : (0 !== (current.lanes & renderLanes) &&\n              (cloneUpdateQueue(current, workInProgress),\n              processUpdateQueue(workInProgress, null, null, renderLanes),\n              suspendIfUpdateReadFromEntangledAsyncAction()),\n            (init = current.memoizedState),\n            (nextProps = workInProgress.memoizedState),\n            init.parent !== lazyComponent\n              ? ((init = { parent: lazyComponent, cache: lazyComponent }),\n                (workInProgress.memoizedState = init),\n                0 === workInProgress.lanes &&\n                  (workInProgress.memoizedState =\n                    workInProgress.updateQueue.baseState =\n                      init),\n                pushProvider(workInProgress, CacheContext, lazyComponent))\n              : ((lazyComponent = nextProps.cache),\n                pushProvider(workInProgress, CacheContext, lazyComponent),\n                lazyComponent !== init.cache &&\n                  propagateContextChanges(\n                    workInProgress,\n                    [CacheContext],\n                    renderLanes,\n                    !0\n                  ))),\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 29:\n      throw workInProgress.pendingProps;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nvar valueCursor = createCursor(null),\n  currentlyRenderingFiber = null,\n  lastContextDependency = null;\nfunction pushProvider(providerFiber, context, nextValue) {\n  push(valueCursor, context._currentValue);\n  context._currentValue = nextValue;\n}\nfunction popProvider(context) {\n  context._currentValue = valueCursor.current;\n  pop(valueCursor);\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  for (; null !== parent; ) {\n    var alternate = parent.alternate;\n    (parent.childLanes & renderLanes) !== renderLanes\n      ? ((parent.childLanes |= renderLanes),\n        null !== alternate && (alternate.childLanes |= renderLanes))\n      : null !== alternate &&\n        (alternate.childLanes & renderLanes) !== renderLanes &&\n        (alternate.childLanes |= renderLanes);\n    if (parent === propagationRoot) break;\n    parent = parent.return;\n  }\n}\nfunction propagateContextChanges(\n  workInProgress,\n  contexts,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  var fiber = workInProgress.child;\n  null !== fiber && (fiber.return = workInProgress);\n  for (; null !== fiber; ) {\n    var list = fiber.dependencies;\n    if (null !== list) {\n      var nextFiber = fiber.child;\n      list = list.firstContext;\n      a: for (; null !== list; ) {\n        var dependency = list;\n        list = fiber;\n        for (var i = 0; i < contexts.length; i++)\n          if (dependency.context === contexts[i]) {\n            list.lanes |= renderLanes;\n            dependency = list.alternate;\n            null !== dependency && (dependency.lanes |= renderLanes);\n            scheduleContextWorkOnParentPath(\n              list.return,\n              renderLanes,\n              workInProgress\n            );\n            forcePropagateEntireTree || (nextFiber = null);\n            break a;\n          }\n        list = dependency.next;\n      }\n    } else if (18 === fiber.tag) {\n      nextFiber = fiber.return;\n      if (null === nextFiber) throw Error(formatProdErrorMessage(341));\n      nextFiber.lanes |= renderLanes;\n      list = nextFiber.alternate;\n      null !== list && (list.lanes |= renderLanes);\n      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n      nextFiber = null;\n    } else nextFiber = fiber.child;\n    if (null !== nextFiber) nextFiber.return = fiber;\n    else\n      for (nextFiber = fiber; null !== nextFiber; ) {\n        if (nextFiber === workInProgress) {\n          nextFiber = null;\n          break;\n        }\n        fiber = nextFiber.sibling;\n        if (null !== fiber) {\n          fiber.return = nextFiber.return;\n          nextFiber = fiber;\n          break;\n        }\n        nextFiber = nextFiber.return;\n      }\n    fiber = nextFiber;\n  }\n}\nfunction propagateParentContextChanges(\n  current,\n  workInProgress,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  current = null;\n  for (\n    var parent = workInProgress, isInsidePropagationBailout = !1;\n    null !== parent;\n\n  ) {\n    if (!isInsidePropagationBailout)\n      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n      else if (0 !== (parent.flags & 262144)) break;\n    if (10 === parent.tag) {\n      var currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent = currentParent.memoizedProps;\n      if (null !== currentParent) {\n        var context = parent.type;\n        objectIs(parent.pendingProps.value, currentParent.value) ||\n          (null !== current ? current.push(context) : (current = [context]));\n      }\n    } else if (parent === hostTransitionProviderCursor.current) {\n      currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent.memoizedState.memoizedState !==\n        parent.memoizedState.memoizedState &&\n        (null !== current\n          ? current.push(HostTransitionContext)\n          : (current = [HostTransitionContext]));\n    }\n    parent = parent.return;\n  }\n  null !== current &&\n    propagateContextChanges(\n      workInProgress,\n      current,\n      renderLanes,\n      forcePropagateEntireTree\n    );\n  workInProgress.flags |= 262144;\n}\nfunction checkIfContextChanged(currentDependencies) {\n  for (\n    currentDependencies = currentDependencies.firstContext;\n    null !== currentDependencies;\n\n  ) {\n    if (\n      !objectIs(\n        currentDependencies.context._currentValue,\n        currentDependencies.memoizedValue\n      )\n    )\n      return !0;\n    currentDependencies = currentDependencies.next;\n  }\n  return !1;\n}\nfunction prepareToReadContext(workInProgress) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  workInProgress = workInProgress.dependencies;\n  null !== workInProgress && (workInProgress.firstContext = null);\n}\nfunction readContext(context) {\n  return readContextForConsumer(currentlyRenderingFiber, context);\n}\nfunction readContextDuringReconciliation(consumer, context) {\n  null === currentlyRenderingFiber && prepareToReadContext(consumer);\n  return readContextForConsumer(consumer, context);\n}\nfunction readContextForConsumer(consumer, context) {\n  var value = context._currentValue;\n  context = { context: context, memoizedValue: value, next: null };\n  if (null === lastContextDependency) {\n    if (null === consumer) throw Error(formatProdErrorMessage(308));\n    lastContextDependency = context;\n    consumer.dependencies = { lanes: 0, firstContext: context };\n    consumer.flags |= 524288;\n  } else lastContextDependency = lastContextDependency.next = context;\n  return value;\n}\nvar hasForceUpdate = !1;\nfunction initializeUpdateQueue(fiber) {\n  fiber.updateQueue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: { pending: null, lanes: 0, hiddenCallbacks: null },\n    callbacks: null\n  };\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  current = current.updateQueue;\n  workInProgress.updateQueue === current &&\n    (workInProgress.updateQueue = {\n      baseState: current.baseState,\n      firstBaseUpdate: current.firstBaseUpdate,\n      lastBaseUpdate: current.lastBaseUpdate,\n      shared: current.shared,\n      callbacks: null\n    });\n}\nfunction createUpdate(lane) {\n  return { lane: lane, tag: 0, payload: null, callback: null, next: null };\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n  if (null === updateQueue) return null;\n  updateQueue = updateQueue.shared;\n  if (0 !== (executionContext & 2)) {\n    var pending = updateQueue.pending;\n    null === pending\n      ? (update.next = update)\n      : ((update.next = pending.next), (pending.next = update));\n    updateQueue.pending = update;\n    update = getRootForUpdatedFiber(fiber);\n    markUpdateLaneFromFiberToRoot(fiber, null, lane);\n    return update;\n  }\n  enqueueUpdate$1(fiber, updateQueue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction entangleTransitions(root, fiber, lane) {\n  fiber = fiber.updateQueue;\n  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194176))) {\n    var queueLanes = fiber.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    fiber.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  var queue = workInProgress.updateQueue,\n    current = workInProgress.alternate;\n  if (\n    null !== current &&\n    ((current = current.updateQueue), queue === current)\n  ) {\n    var newFirst = null,\n      newLast = null;\n    queue = queue.firstBaseUpdate;\n    if (null !== queue) {\n      do {\n        var clone = {\n          lane: queue.lane,\n          tag: queue.tag,\n          payload: queue.payload,\n          callback: null,\n          next: null\n        };\n        null === newLast\n          ? (newFirst = newLast = clone)\n          : (newLast = newLast.next = clone);\n        queue = queue.next;\n      } while (null !== queue);\n      null === newLast\n        ? (newFirst = newLast = capturedUpdate)\n        : (newLast = newLast.next = capturedUpdate);\n    } else newFirst = newLast = capturedUpdate;\n    queue = {\n      baseState: current.baseState,\n      firstBaseUpdate: newFirst,\n      lastBaseUpdate: newLast,\n      shared: current.shared,\n      callbacks: current.callbacks\n    };\n    workInProgress.updateQueue = queue;\n    return;\n  }\n  workInProgress = queue.lastBaseUpdate;\n  null === workInProgress\n    ? (queue.firstBaseUpdate = capturedUpdate)\n    : (workInProgress.next = capturedUpdate);\n  queue.lastBaseUpdate = capturedUpdate;\n}\nvar didReadFromEntangledAsyncAction = !1;\nfunction suspendIfUpdateReadFromEntangledAsyncAction() {\n  if (didReadFromEntangledAsyncAction) {\n    var entangledActionThenable = currentEntangledActionThenable;\n    if (null !== entangledActionThenable) throw entangledActionThenable;\n  }\n}\nfunction processUpdateQueue(\n  workInProgress$jscomp$0,\n  props,\n  instance$jscomp$0,\n  renderLanes\n) {\n  didReadFromEntangledAsyncAction = !1;\n  var queue = workInProgress$jscomp$0.updateQueue;\n  hasForceUpdate = !1;\n  var firstBaseUpdate = queue.firstBaseUpdate,\n    lastBaseUpdate = queue.lastBaseUpdate,\n    pendingQueue = queue.shared.pending;\n  if (null !== pendingQueue) {\n    queue.shared.pending = null;\n    var lastPendingUpdate = pendingQueue,\n      firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    null === lastBaseUpdate\n      ? (firstBaseUpdate = firstPendingUpdate)\n      : (lastBaseUpdate.next = firstPendingUpdate);\n    lastBaseUpdate = lastPendingUpdate;\n    var current = workInProgress$jscomp$0.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      (pendingQueue = current.lastBaseUpdate),\n      pendingQueue !== lastBaseUpdate &&\n        (null === pendingQueue\n          ? (current.firstBaseUpdate = firstPendingUpdate)\n          : (pendingQueue.next = firstPendingUpdate),\n        (current.lastBaseUpdate = lastPendingUpdate)));\n  }\n  if (null !== firstBaseUpdate) {\n    var newState = queue.baseState;\n    lastBaseUpdate = 0;\n    current = firstPendingUpdate = lastPendingUpdate = null;\n    pendingQueue = firstBaseUpdate;\n    do {\n      var updateLane = pendingQueue.lane & -536870913,\n        isHiddenUpdate = updateLane !== pendingQueue.lane;\n      if (\n        isHiddenUpdate\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        0 !== updateLane &&\n          updateLane === currentEntangledLane &&\n          (didReadFromEntangledAsyncAction = !0);\n        null !== current &&\n          (current = current.next =\n            {\n              lane: 0,\n              tag: pendingQueue.tag,\n              payload: pendingQueue.payload,\n              callback: null,\n              next: null\n            });\n        a: {\n          var workInProgress = workInProgress$jscomp$0,\n            update = pendingQueue;\n          updateLane = props;\n          var instance = instance$jscomp$0;\n          switch (update.tag) {\n            case 1:\n              workInProgress = update.payload;\n              if ("function" === typeof workInProgress) {\n                newState = workInProgress.call(instance, newState, updateLane);\n                break a;\n              }\n              newState = workInProgress;\n              break a;\n            case 3:\n              workInProgress.flags = (workInProgress.flags & -65537) | 128;\n            case 0:\n              workInProgress = update.payload;\n              updateLane =\n                "function" === typeof workInProgress\n                  ? workInProgress.call(instance, newState, updateLane)\n                  : workInProgress;\n              if (null === updateLane || void 0 === updateLane) break a;\n              newState = assign({}, newState, updateLane);\n              break a;\n            case 2:\n              hasForceUpdate = !0;\n          }\n        }\n        updateLane = pendingQueue.callback;\n        null !== updateLane &&\n          ((workInProgress$jscomp$0.flags |= 64),\n          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),\n          (isHiddenUpdate = queue.callbacks),\n          null === isHiddenUpdate\n            ? (queue.callbacks = [updateLane])\n            : isHiddenUpdate.push(updateLane));\n      } else\n        (isHiddenUpdate = {\n          lane: updateLane,\n          tag: pendingQueue.tag,\n          payload: pendingQueue.payload,\n          callback: pendingQueue.callback,\n          next: null\n        }),\n          null === current\n            ? ((firstPendingUpdate = current = isHiddenUpdate),\n              (lastPendingUpdate = newState))\n            : (current = current.next = isHiddenUpdate),\n          (lastBaseUpdate |= updateLane);\n      pendingQueue = pendingQueue.next;\n      if (null === pendingQueue)\n        if (((pendingQueue = queue.shared.pending), null === pendingQueue))\n          break;\n        else\n          (isHiddenUpdate = pendingQueue),\n            (pendingQueue = isHiddenUpdate.next),\n            (isHiddenUpdate.next = null),\n            (queue.lastBaseUpdate = isHiddenUpdate),\n            (queue.shared.pending = null);\n    } while (1);\n    null === current && (lastPendingUpdate = newState);\n    queue.baseState = lastPendingUpdate;\n    queue.firstBaseUpdate = firstPendingUpdate;\n    queue.lastBaseUpdate = current;\n    null === firstBaseUpdate && (queue.shared.lanes = 0);\n    workInProgressRootSkippedLanes |= lastBaseUpdate;\n    workInProgress$jscomp$0.lanes = lastBaseUpdate;\n    workInProgress$jscomp$0.memoizedState = newState;\n  }\n}\nfunction callCallback(callback, context) {\n  if ("function" !== typeof callback)\n    throw Error(formatProdErrorMessage(191, callback));\n  callback.call(context);\n}\nfunction commitCallbacks(updateQueue, context) {\n  var callbacks = updateQueue.callbacks;\n  if (null !== callbacks)\n    for (\n      updateQueue.callbacks = null, updateQueue = 0;\n      updateQueue < callbacks.length;\n      updateQueue++\n    )\n      callCallback(callbacks[updateQueue], context);\n}\nfunction commitHookEffectListMount(flags, finishedWork) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          lastEffect = void 0;\n          var create = updateQueue.create,\n            inst = updateQueue.inst;\n          lastEffect = create();\n          inst.destroy = lastEffect;\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHookEffectListUnmount(\n  flags,\n  finishedWork,\n  nearestMountedAncestor$jscomp$0\n) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          var inst = updateQueue.inst,\n            destroy = inst.destroy;\n          if (void 0 !== destroy) {\n            inst.destroy = void 0;\n            lastEffect = finishedWork;\n            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0;\n            try {\n              destroy();\n            } catch (error) {\n              captureCommitPhaseError(\n                lastEffect,\n                nearestMountedAncestor,\n                error\n              );\n            }\n          }\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitClassCallbacks(finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  if (null !== updateQueue) {\n    var instance = finishedWork.stateNode;\n    try {\n      commitCallbacks(updateQueue, instance);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\nfunction safelyCallComponentWillUnmount(\n  current,\n  nearestMountedAncestor,\n  instance\n) {\n  instance.props = resolveClassComponentProps(\n    current.type,\n    current.memoizedProps\n  );\n  instance.state = current.memoizedState;\n  try {\n    instance.componentWillUnmount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    var ref = current.ref;\n    if (null !== ref) {\n      var instance = current.stateNode;\n      switch (current.tag) {\n        case 26:\n        case 27:\n        case 5:\n          var instanceToUse = instance;\n          break;\n        default:\n          instanceToUse = instance;\n      }\n      "function" === typeof ref\n        ? (current.refCleanup = ref(instanceToUse))\n        : (ref.current = instanceToUse);\n    }\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref,\n    refCleanup = current.refCleanup;\n  if (null !== ref)\n    if ("function" === typeof refCleanup)\n      try {\n        refCleanup();\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      } finally {\n        (current.refCleanup = null),\n          (current = current.alternate),\n          null != current && (current.refCleanup = null);\n      }\n    else if ("function" === typeof ref)\n      try {\n        ref(null);\n      } catch (error$112) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error$112);\n      }\n    else ref.current = null;\n}\nfunction commitHostMount(finishedWork) {\n  var type = finishedWork.type,\n    props = finishedWork.memoizedProps,\n    instance = finishedWork.stateNode;\n  try {\n    a: switch (type) {\n      case "button":\n      case "input":\n      case "select":\n      case "textarea":\n        props.autoFocus && instance.focus();\n        break a;\n      case "img":\n        props.src\n          ? (instance.src = props.src)\n          : props.srcSet && (instance.srcset = props.srcSet);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHostUpdate(finishedWork, newProps, oldProps) {\n  try {\n    var domElement = finishedWork.stateNode;\n    updateProperties(domElement, finishedWork.type, oldProps, newProps);\n    domElement[internalPropsKey] = newProps;\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction isHostParent(fiber) {\n  return (\n    5 === fiber.tag ||\n    3 === fiber.tag ||\n    26 === fiber.tag ||\n    27 === fiber.tag ||\n    4 === fiber.tag\n  );\n}\nfunction getHostSibling(fiber) {\n  a: for (;;) {\n    for (; null === fiber.sibling; ) {\n      if (null === fiber.return || isHostParent(fiber.return)) return null;\n      fiber = fiber.return;\n    }\n    fiber.sibling.return = fiber.return;\n    for (\n      fiber = fiber.sibling;\n      5 !== fiber.tag &&\n      6 !== fiber.tag &&\n      27 !== fiber.tag &&\n      18 !== fiber.tag;\n\n    ) {\n      if (fiber.flags & 2) continue a;\n      if (null === fiber.child || 4 === fiber.tag) continue a;\n      else (fiber.child.return = fiber), (fiber = fiber.child);\n    }\n    if (!(fiber.flags & 2)) return fiber.stateNode;\n  }\n}\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before\n        ? 8 === parent.nodeType\n          ? parent.parentNode.insertBefore(node, before)\n          : parent.insertBefore(node, before)\n        : (8 === parent.nodeType\n            ? ((before = parent.parentNode), before.insertBefore(node, parent))\n            : ((before = parent), before.appendChild(node)),\n          (parent = parent._reactRootContainer),\n          (null !== parent && void 0 !== parent) ||\n            null !== before.onclick ||\n            (before.onclick = noop$1));\n  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))\n    for (\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        (node = node.sibling);\n}\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before ? parent.insertBefore(node, before) : parent.appendChild(node);\n  else if (4 !== tag && 27 !== tag && ((node = node.child), null !== node))\n    for (\n      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);\n}\nvar offscreenSubtreeIsHidden = !1,\n  offscreenSubtreeWasHidden = !1,\n  needsFormReset = !1,\n  PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set,\n  nextEffect = null,\n  shouldFireAfterActiveInstanceBlur = !1;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  root = root.containerInfo;\n  eventsEnabled = _enabled;\n  root = getActiveElementDeep(root);\n  if (hasSelectionCapabilities(root)) {\n    if ("selectionStart" in root)\n      var JSCompiler_temp = {\n        start: root.selectionStart,\n        end: root.selectionEnd\n      };\n    else\n      a: {\n        JSCompiler_temp =\n          ((JSCompiler_temp = root.ownerDocument) &&\n            JSCompiler_temp.defaultView) ||\n          window;\n        var selection =\n          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\n        if (selection && 0 !== selection.rangeCount) {\n          JSCompiler_temp = selection.anchorNode;\n          var anchorOffset = selection.anchorOffset,\n            focusNode = selection.focusNode;\n          selection = selection.focusOffset;\n          try {\n            JSCompiler_temp.nodeType, focusNode.nodeType;\n          } catch (e$20) {\n            JSCompiler_temp = null;\n            break a;\n          }\n          var length = 0,\n            start = -1,\n            end = -1,\n            indexWithinAnchor = 0,\n            indexWithinFocus = 0,\n            node = root,\n            parentNode = null;\n          b: for (;;) {\n            for (var next; ; ) {\n              node !== JSCompiler_temp ||\n                (0 !== anchorOffset && 3 !== node.nodeType) ||\n                (start = length + anchorOffset);\n              node !== focusNode ||\n                (0 !== selection && 3 !== node.nodeType) ||\n                (end = length + selection);\n              3 === node.nodeType && (length += node.nodeValue.length);\n              if (null === (next = node.firstChild)) break;\n              parentNode = node;\n              node = next;\n            }\n            for (;;) {\n              if (node === root) break b;\n              parentNode === JSCompiler_temp &&\n                ++indexWithinAnchor === anchorOffset &&\n                (start = length);\n              parentNode === focusNode &&\n                ++indexWithinFocus === selection &&\n                (end = length);\n              if (null !== (next = node.nextSibling)) break;\n              node = parentNode;\n              parentNode = node.parentNode;\n            }\n            node = next;\n          }\n          JSCompiler_temp =\n            -1 === start || -1 === end ? null : { start: start, end: end };\n        } else JSCompiler_temp = null;\n      }\n    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };\n  } else JSCompiler_temp = null;\n  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };\n  _enabled = !1;\n  for (nextEffect = firstChild; null !== nextEffect; )\n    if (\n      ((firstChild = nextEffect),\n      (root = firstChild.child),\n      0 !== (firstChild.subtreeFlags & 1028) && null !== root)\n    )\n      (root.return = firstChild), (nextEffect = root);\n    else\n      for (; null !== nextEffect; ) {\n        firstChild = nextEffect;\n        focusNode = firstChild.alternate;\n        root = firstChild.flags;\n        switch (firstChild.tag) {\n          case 0:\n            break;\n          case 11:\n          case 15:\n            break;\n          case 1:\n            if (0 !== (root & 1024) && null !== focusNode) {\n              root = void 0;\n              JSCompiler_temp = firstChild;\n              anchorOffset = focusNode.memoizedProps;\n              focusNode = focusNode.memoizedState;\n              selection = JSCompiler_temp.stateNode;\n              try {\n                var resolvedPrevProps = resolveClassComponentProps(\n                  JSCompiler_temp.type,\n                  anchorOffset,\n                  JSCompiler_temp.elementType === JSCompiler_temp.type\n                );\n                root = selection.getSnapshotBeforeUpdate(\n                  resolvedPrevProps,\n                  focusNode\n                );\n                selection.__reactInternalSnapshotBeforeUpdate = root;\n              } catch (error) {\n                captureCommitPhaseError(\n                  JSCompiler_temp,\n                  JSCompiler_temp.return,\n                  error\n                );\n              }\n            }\n            break;\n          case 3:\n            if (0 !== (root & 1024))\n              if (\n                ((root = firstChild.stateNode.containerInfo),\n                (JSCompiler_temp = root.nodeType),\n                9 === JSCompiler_temp)\n              )\n                clearContainerSparingly(root);\n              else if (1 === JSCompiler_temp)\n                switch (root.nodeName) {\n                  case "HEAD":\n                  case "HTML":\n                  case "BODY":\n                    clearContainerSparingly(root);\n                    break;\n                  default:\n                    root.textContent = "";\n                }\n            break;\n          case 5:\n          case 26:\n          case 27:\n          case 6:\n          case 4:\n          case 17:\n            break;\n          default:\n            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));\n        }\n        root = firstChild.sibling;\n        if (null !== root) {\n          root.return = firstChild.return;\n          nextEffect = root;\n          break;\n        }\n        nextEffect = firstChild.return;\n      }\n  resolvedPrevProps = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = !1;\n  return resolvedPrevProps;\n}\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitHookEffectListMount(5, finishedWork);\n      break;\n    case 1:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (flags & 4)\n        if (((finishedRoot = finishedWork.stateNode), null === current))\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        else {\n          var prevProps = resolveClassComponentProps(\n            finishedWork.type,\n            current.memoizedProps\n          );\n          current = current.memoizedState;\n          try {\n            finishedRoot.componentDidUpdate(\n              prevProps,\n              current,\n              finishedRoot.__reactInternalSnapshotBeforeUpdate\n            );\n          } catch (error$111) {\n            captureCommitPhaseError(\n              finishedWork,\n              finishedWork.return,\n              error$111\n            );\n          }\n        }\n      flags & 64 && commitClassCallbacks(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (flags & 64 && ((flags = finishedWork.updateQueue), null !== flags)) {\n        finishedRoot = null;\n        if (null !== finishedWork.child)\n          switch (finishedWork.child.tag) {\n            case 27:\n            case 5:\n              finishedRoot = finishedWork.child.stateNode;\n              break;\n            case 1:\n              finishedRoot = finishedWork.child.stateNode;\n          }\n        try {\n          commitCallbacks(flags, finishedRoot);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 26:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 27:\n    case 5:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      null === current && flags & 4 && commitHostMount(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 12:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      break;\n    case 22:\n      prevProps =\n        null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n      if (!prevProps) {\n        current =\n          (null !== current && null !== current.memoizedState) ||\n          offscreenSubtreeWasHidden;\n        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,\n          prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n        offscreenSubtreeIsHidden = prevProps;\n        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden\n          ? recursivelyTraverseReappearLayoutEffects(\n              finishedRoot,\n              finishedWork,\n              0 !== (finishedWork.subtreeFlags & 8772)\n            )\n          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      }\n      flags & 512 &&\n        ("manual" === finishedWork.memoizedProps.mode\n          ? safelyAttachRef(finishedWork, finishedWork.return)\n          : safelyDetachRef(finishedWork, finishedWork.return));\n      break;\n    default:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n  }\n}\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n  null !== alternate &&\n    ((fiber.alternate = null), detachFiberAfterEffects(alternate));\n  fiber.child = null;\n  fiber.deletions = null;\n  fiber.sibling = null;\n  5 === fiber.tag &&\n    ((alternate = fiber.stateNode),\n    null !== alternate && detachDeletedInstance(alternate));\n  fiber.stateNode = null;\n  fiber.return = null;\n  fiber.dependencies = null;\n  fiber.memoizedProps = null;\n  fiber.memoizedState = null;\n  fiber.pendingProps = null;\n  fiber.stateNode = null;\n  fiber.updateQueue = null;\n}\nvar hostParent = null,\n  hostParentIsContainer = !1;\nfunction recursivelyTraverseDeletionEffects(\n  finishedRoot,\n  nearestMountedAncestor,\n  parent\n) {\n  for (parent = parent.child; null !== parent; )\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),\n      (parent = parent.sibling);\n}\nfunction commitDeletionEffectsOnFiber(\n  finishedRoot,\n  nearestMountedAncestor,\n  deletedFiber\n) {\n  if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n    } catch (err) {}\n  switch (deletedFiber.tag) {\n    case 26:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      deletedFiber.memoizedState\n        ? deletedFiber.memoizedState.count--\n        : deletedFiber.stateNode &&\n          ((deletedFiber = deletedFiber.stateNode),\n          deletedFiber.parentNode.removeChild(deletedFiber));\n      break;\n    case 27:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      var prevHostParent = hostParent,\n        prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = deletedFiber.stateNode;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      deletedFiber = deletedFiber.stateNode;\n      for (\n        nearestMountedAncestor = deletedFiber.attributes;\n        nearestMountedAncestor.length;\n\n      )\n        deletedFiber.removeAttributeNode(nearestMountedAncestor[0]);\n      detachDeletedInstance(deletedFiber);\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 5:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n    case 6:\n      prevHostParentIsContainer = hostParent;\n      var prevHostParentIsContainer$119 = hostParentIsContainer;\n      hostParent = null;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParentIsContainer;\n      hostParentIsContainer = prevHostParentIsContainer$119;\n      if (null !== hostParent)\n        if (hostParentIsContainer)\n          try {\n            (finishedRoot = hostParent),\n              (prevHostParent = deletedFiber.stateNode),\n              8 === finishedRoot.nodeType\n                ? finishedRoot.parentNode.removeChild(prevHostParent)\n                : finishedRoot.removeChild(prevHostParent);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n        else\n          try {\n            hostParent.removeChild(deletedFiber.stateNode);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n      break;\n    case 18:\n      null !== hostParent &&\n        (hostParentIsContainer\n          ? ((nearestMountedAncestor = hostParent),\n            (deletedFiber = deletedFiber.stateNode),\n            8 === nearestMountedAncestor.nodeType\n              ? clearSuspenseBoundary(\n                  nearestMountedAncestor.parentNode,\n                  deletedFiber\n                )\n              : 1 === nearestMountedAncestor.nodeType &&\n                clearSuspenseBoundary(nearestMountedAncestor, deletedFiber),\n            retryIfBlockedOn(nearestMountedAncestor))\n          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n      break;\n    case 4:\n      prevHostParent = hostParent;\n      prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = deletedFiber.stateNode.containerInfo;\n      hostParentIsContainer = !0;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 1:\n      offscreenSubtreeWasHidden ||\n        (safelyDetachRef(deletedFiber, nearestMountedAncestor),\n        (prevHostParent = deletedFiber.stateNode),\n        "function" === typeof prevHostParent.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            deletedFiber,\n            nearestMountedAncestor,\n            prevHostParent\n          ));\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 21:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 22:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      offscreenSubtreeWasHidden =\n        (prevHostParent = offscreenSubtreeWasHidden) ||\n        null !== deletedFiber.memoizedState;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      offscreenSubtreeWasHidden = prevHostParent;\n      break;\n    default:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n  }\n}\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (\n    null === finishedWork.memoizedState &&\n    ((finishedRoot = finishedWork.alternate),\n    null !== finishedRoot &&\n      ((finishedRoot = finishedRoot.memoizedState),\n      null !== finishedRoot &&\n        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))\n  )\n    try {\n      retryIfBlockedOn(finishedRoot);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n}\nfunction getRetryCache(finishedWork) {\n  switch (finishedWork.tag) {\n    case 13:\n    case 19:\n      var retryCache = finishedWork.stateNode;\n      null === retryCache &&\n        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n      return retryCache;\n    case 22:\n      return (\n        (finishedWork = finishedWork.stateNode),\n        (retryCache = finishedWork._retryCache),\n        null === retryCache &&\n          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),\n        retryCache\n      );\n    default:\n      throw Error(formatProdErrorMessage(435, finishedWork.tag));\n  }\n}\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\n  var retryCache = getRetryCache(finishedWork);\n  wakeables.forEach(function (wakeable) {\n    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n    retryCache.has(wakeable) ||\n      (retryCache.add(wakeable), wakeable.then(retry, retry));\n  });\n}\nfunction recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (null !== deletions)\n    for (var i = 0; i < deletions.length; i++) {\n      var childToDelete = deletions[i],\n        root = root$jscomp$0,\n        returnFiber = parentFiber,\n        parent = returnFiber;\n      a: for (; null !== parent; ) {\n        switch (parent.tag) {\n          case 27:\n          case 5:\n            hostParent = parent.stateNode;\n            hostParentIsContainer = !1;\n            break a;\n          case 3:\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = !0;\n            break a;\n          case 4:\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = !0;\n            break a;\n        }\n        parent = parent.return;\n      }\n      if (null === hostParent) throw Error(formatProdErrorMessage(160));\n      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);\n      hostParent = null;\n      hostParentIsContainer = !1;\n      root = childToDelete.alternate;\n      null !== root && (root.return = null);\n      childToDelete.return = null;\n    }\n  if (parentFiber.subtreeFlags & 13878)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),\n        (parentFiber = parentFiber.sibling);\n}\nvar currentHoistableRoot = null;\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\n  var current = finishedWork.alternate,\n    flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),\n        commitHookEffectListMount(3, finishedWork),\n        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));\n      break;\n    case 1:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      flags & 64 &&\n        offscreenSubtreeIsHidden &&\n        ((finishedWork = finishedWork.updateQueue),\n        null !== finishedWork &&\n          ((flags = finishedWork.callbacks),\n          null !== flags &&\n            ((current = finishedWork.shared.hiddenCallbacks),\n            (finishedWork.shared.hiddenCallbacks =\n              null === current ? flags : current.concat(flags)))));\n      break;\n    case 26:\n      var hoistableRoot = currentHoistableRoot;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (flags & 4) {\n        var currentResource = null !== current ? current.memoizedState : null;\n        flags = finishedWork.memoizedState;\n        if (null === current)\n          if (null === flags)\n            if (null === finishedWork.stateNode) {\n              a: {\n                flags = finishedWork.type;\n                current = finishedWork.memoizedProps;\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n                b: switch (flags) {\n                  case "title":\n                    currentResource =\n                      hoistableRoot.getElementsByTagName("title")[0];\n                    if (\n                      !currentResource ||\n                      currentResource[internalHoistableMarker] ||\n                      currentResource[internalInstanceKey] ||\n                      "http://www.w3.org/2000/svg" ===\n                        currentResource.namespaceURI ||\n                      currentResource.hasAttribute("itemprop")\n                    )\n                      (currentResource = hoistableRoot.createElement(flags)),\n                        hoistableRoot.head.insertBefore(\n                          currentResource,\n                          hoistableRoot.querySelector("head > title")\n                        );\n                    setInitialProperties(currentResource, flags, current);\n                    currentResource[internalInstanceKey] = finishedWork;\n                    markNodeAsHoistable(currentResource);\n                    flags = currentResource;\n                    break a;\n                  case "link":\n                    var maybeNodes = getHydratableHoistableCache(\n                      "link",\n                      "href",\n                      hoistableRoot\n                    ).get(flags + (current.href || ""));\n                    if (maybeNodes)\n                      for (var i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute("href") ===\n                            (null == current.href ? null : current.href) &&\n                            currentResource.getAttribute("rel") ===\n                              (null == current.rel ? null : current.rel) &&\n                            currentResource.getAttribute("title") ===\n                              (null == current.title ? null : current.title) &&\n                            currentResource.getAttribute("crossorigin") ===\n                              (null == current.crossOrigin\n                                ? null\n                                : current.crossOrigin))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  case "meta":\n                    if (\n                      (maybeNodes = getHydratableHoistableCache(\n                        "meta",\n                        "content",\n                        hoistableRoot\n                      ).get(flags + (current.content || "")))\n                    )\n                      for (i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute("content") ===\n                            (null == current.content\n                              ? null\n                              : "" + current.content) &&\n                            currentResource.getAttribute("name") ===\n                              (null == current.name ? null : current.name) &&\n                            currentResource.getAttribute("property") ===\n                              (null == current.property\n                                ? null\n                                : current.property) &&\n                            currentResource.getAttribute("http-equiv") ===\n                              (null == current.httpEquiv\n                                ? null\n                                : current.httpEquiv) &&\n                            currentResource.getAttribute("charset") ===\n                              (null == current.charSet\n                                ? null\n                                : current.charSet))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  default:\n                    throw Error(formatProdErrorMessage(468, flags));\n                }\n                currentResource[internalInstanceKey] = finishedWork;\n                markNodeAsHoistable(currentResource);\n                flags = currentResource;\n              }\n              finishedWork.stateNode = flags;\n            } else\n              mountHoistable(\n                hoistableRoot,\n                finishedWork.type,\n                finishedWork.stateNode\n              );\n          else\n            finishedWork.stateNode = acquireResource(\n              hoistableRoot,\n              flags,\n              finishedWork.memoizedProps\n            );\n        else\n          currentResource !== flags\n            ? (null === currentResource\n                ? null !== current.stateNode &&\n                  ((current = current.stateNode),\n                  current.parentNode.removeChild(current))\n                : currentResource.count--,\n              null === flags\n                ? mountHoistable(\n                    hoistableRoot,\n                    finishedWork.type,\n                    finishedWork.stateNode\n                  )\n                : acquireResource(\n                    hoistableRoot,\n                    flags,\n                    finishedWork.memoizedProps\n                  ))\n            : null === flags &&\n              null !== finishedWork.stateNode &&\n              commitHostUpdate(\n                finishedWork,\n                finishedWork.memoizedProps,\n                current.memoizedProps\n              );\n      }\n      break;\n    case 27:\n      if (flags & 4 && null === finishedWork.alternate) {\n        hoistableRoot = finishedWork.stateNode;\n        currentResource = finishedWork.memoizedProps;\n        try {\n          for (var node = hoistableRoot.firstChild; node; ) {\n            var nextNode = node.nextSibling,\n              nodeName = node.nodeName;\n            node[internalHoistableMarker] ||\n              "HEAD" === nodeName ||\n              "BODY" === nodeName ||\n              "SCRIPT" === nodeName ||\n              "STYLE" === nodeName ||\n              ("LINK" === nodeName &&\n                "stylesheet" === node.rel.toLowerCase()) ||\n              hoistableRoot.removeChild(node);\n            node = nextNode;\n          }\n          for (\n            var type = finishedWork.type, attributes = hoistableRoot.attributes;\n            attributes.length;\n\n          )\n            hoistableRoot.removeAttributeNode(attributes[0]);\n          setInitialProperties(hoistableRoot, type, currentResource);\n          hoistableRoot[internalInstanceKey] = finishedWork;\n          hoistableRoot[internalPropsKey] = currentResource;\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n    case 5:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (finishedWork.flags & 32) {\n        hoistableRoot = finishedWork.stateNode;\n        try {\n          setTextContent(hoistableRoot, "");\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      flags & 4 &&\n        null != finishedWork.stateNode &&\n        ((hoistableRoot = finishedWork.memoizedProps),\n        commitHostUpdate(\n          finishedWork,\n          hoistableRoot,\n          null !== current ? current.memoizedProps : hoistableRoot\n        ));\n      flags & 1024 && (needsFormReset = !0);\n      break;\n    case 6:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4) {\n        if (null === finishedWork.stateNode)\n          throw Error(formatProdErrorMessage(162));\n        flags = finishedWork.memoizedProps;\n        current = finishedWork.stateNode;\n        try {\n          current.nodeValue = flags;\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 3:\n      tagCaches = null;\n      hoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(root.containerInfo);\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      currentHoistableRoot = hoistableRoot;\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)\n        try {\n          retryIfBlockedOn(root.containerInfo);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      needsFormReset &&\n        ((needsFormReset = !1), recursivelyResetForms(finishedWork));\n      break;\n    case 4:\n      flags = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(\n        finishedWork.stateNode.containerInfo\n      );\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      currentHoistableRoot = flags;\n      break;\n    case 12:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      finishedWork.child.flags & 8192 &&\n        (null !== finishedWork.memoizedState) !==\n          (null !== current && null !== current.memoizedState) &&\n        (globalMostRecentFallbackTime = now());\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 22:\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      node = null !== finishedWork.memoizedState;\n      nextNode = null !== current && null !== current.memoizedState;\n      nodeName = offscreenSubtreeIsHidden;\n      type = offscreenSubtreeWasHidden;\n      offscreenSubtreeIsHidden = nodeName || node;\n      offscreenSubtreeWasHidden = type || nextNode;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      offscreenSubtreeWasHidden = type;\n      offscreenSubtreeIsHidden = nodeName;\n      commitReconciliationEffects(finishedWork);\n      root = finishedWork.stateNode;\n      root._current = finishedWork;\n      root._visibility &= -3;\n      root._visibility |= root._pendingVisibility & 2;\n      if (\n        flags & 8192 &&\n        ((root._visibility = node\n          ? root._visibility & -2\n          : root._visibility | 1),\n        node &&\n          ((root = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden),\n          null === current ||\n            nextNode ||\n            root ||\n            recursivelyTraverseDisappearLayoutEffects(finishedWork)),\n        null === finishedWork.memoizedProps ||\n          "manual" !== finishedWork.memoizedProps.mode)\n      )\n        a: for (current = null, root = finishedWork; ; ) {\n          if (5 === root.tag || 26 === root.tag || 27 === root.tag) {\n            if (null === current) {\n              nextNode = current = root;\n              try {\n                if (((hoistableRoot = nextNode.stateNode), node))\n                  (currentResource = hoistableRoot.style),\n                    "function" === typeof currentResource.setProperty\n                      ? currentResource.setProperty(\n                          "display",\n                          "none",\n                          "important"\n                        )\n                      : (currentResource.display = "none");\n                else {\n                  maybeNodes = nextNode.stateNode;\n                  i = nextNode.memoizedProps.style;\n                  var display =\n                    void 0 !== i && null !== i && i.hasOwnProperty("display")\n                      ? i.display\n                      : null;\n                  maybeNodes.style.display =\n                    null == display || "boolean" === typeof display\n                      ? ""\n                      : ("" + display).trim();\n                }\n              } catch (error) {\n                captureCommitPhaseError(nextNode, nextNode.return, error);\n              }\n            }\n          } else if (6 === root.tag) {\n            if (null === current) {\n              nextNode = root;\n              try {\n                nextNode.stateNode.nodeValue = node\n                  ? ""\n                  : nextNode.memoizedProps;\n              } catch (error) {\n                captureCommitPhaseError(nextNode, nextNode.return, error);\n              }\n            }\n          } else if (\n            ((22 !== root.tag && 23 !== root.tag) ||\n              null === root.memoizedState ||\n              root === finishedWork) &&\n            null !== root.child\n          ) {\n            root.child.return = root;\n            root = root.child;\n            continue;\n          }\n          if (root === finishedWork) break a;\n          for (; null === root.sibling; ) {\n            if (null === root.return || root.return === finishedWork) break a;\n            current === root && (current = null);\n            root = root.return;\n          }\n          current === root && (current = null);\n          root.sibling.return = root.return;\n          root = root.sibling;\n        }\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((current = flags.retryQueue),\n          null !== current &&\n            ((flags.retryQueue = null),\n            attachSuspenseRetryListeners(finishedWork, current))));\n      break;\n    case 19:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 21:\n      break;\n    default:\n      recursivelyTraverseMutationEffects(root, finishedWork),\n        commitReconciliationEffects(finishedWork);\n  }\n}\nfunction commitReconciliationEffects(finishedWork) {\n  var flags = finishedWork.flags;\n  if (flags & 2) {\n    try {\n      if (27 !== finishedWork.tag) {\n        a: {\n          for (var parent = finishedWork.return; null !== parent; ) {\n            if (isHostParent(parent)) {\n              var JSCompiler_inline_result = parent;\n              break a;\n            }\n            parent = parent.return;\n          }\n          throw Error(formatProdErrorMessage(160));\n        }\n        switch (JSCompiler_inline_result.tag) {\n          case 27:\n            var parent$jscomp$0 = JSCompiler_inline_result.stateNode,\n              before = getHostSibling(finishedWork);\n            insertOrAppendPlacementNode(finishedWork, before, parent$jscomp$0);\n            break;\n          case 5:\n            var parent$113 = JSCompiler_inline_result.stateNode;\n            JSCompiler_inline_result.flags & 32 &&\n              (setTextContent(parent$113, ""),\n              (JSCompiler_inline_result.flags &= -33));\n            var before$114 = getHostSibling(finishedWork);\n            insertOrAppendPlacementNode(finishedWork, before$114, parent$113);\n            break;\n          case 3:\n          case 4:\n            var parent$115 = JSCompiler_inline_result.stateNode.containerInfo,\n              before$116 = getHostSibling(finishedWork);\n            insertOrAppendPlacementNodeIntoContainer(\n              finishedWork,\n              before$116,\n              parent$115\n            );\n            break;\n          default:\n            throw Error(formatProdErrorMessage(161));\n        }\n      }\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    finishedWork.flags &= -3;\n  }\n  flags & 4096 && (finishedWork.flags &= -4097);\n}\nfunction recursivelyResetForms(parentFiber) {\n  if (parentFiber.subtreeFlags & 1024)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var fiber = parentFiber;\n      recursivelyResetForms(fiber);\n      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();\n      parentFiber = parentFiber.sibling;\n    }\n}\nfunction recursivelyTraverseLayoutEffects(root, parentFiber) {\n  if (parentFiber.subtreeFlags & 8772)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedWork = parentFiber;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 14:\n      case 15:\n        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 1:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        var instance = finishedWork.stateNode;\n        "function" === typeof instance.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            finishedWork,\n            finishedWork.return,\n            instance\n          );\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 26:\n      case 27:\n      case 5:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 22:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      default:\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseReappearLayoutEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var current = parentFiber.alternate,\n      finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(4, finishedWork);\n        break;\n      case 1:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        current = finishedWork;\n        finishedRoot = current.stateNode;\n        if ("function" === typeof finishedRoot.componentDidMount)\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        current = finishedWork;\n        finishedRoot = current.updateQueue;\n        if (null !== finishedRoot) {\n          var instance = current.stateNode;\n          try {\n            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;\n            if (null !== hiddenCallbacks)\n              for (\n                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;\n                finishedRoot < hiddenCallbacks.length;\n                finishedRoot++\n              )\n                callCallback(hiddenCallbacks[finishedRoot], instance);\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        }\n        includeWorkInProgressEffects &&\n          flags & 64 &&\n          commitClassCallbacks(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 26:\n      case 27:\n      case 5:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          null === current &&\n          flags & 4 &&\n          commitHostMount(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 12:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        break;\n      case 13:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 4 &&\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        break;\n      case 22:\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseReappearLayoutEffects(\n            finishedRoot,\n            finishedWork,\n            includeWorkInProgressEffects\n          );\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      default:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitOffscreenPassiveMountEffects(current, finishedWork) {\n  var previousCache = null;\n  null !== current &&\n    null !== current.memoizedState &&\n    null !== current.memoizedState.cachePool &&\n    (previousCache = current.memoizedState.cachePool.pool);\n  current = null;\n  null !== finishedWork.memoizedState &&\n    null !== finishedWork.memoizedState.cachePool &&\n    (current = finishedWork.memoizedState.cachePool.pool);\n  current !== previousCache &&\n    (null != current && current.refCount++,\n    null != previousCache && releaseCache(previousCache));\n}\nfunction commitCachePassiveMountEffect(current, finishedWork) {\n  current = null;\n  null !== finishedWork.alternate &&\n    (current = finishedWork.alternate.memoizedState.cache);\n  finishedWork = finishedWork.memoizedState.cache;\n  finishedWork !== current &&\n    (finishedWork.refCount++, null != current && releaseCache(current));\n}\nfunction recursivelyTraversePassiveMountEffects(\n  root,\n  parentFiber,\n  committedLanes,\n  committedTransitions\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveMountOnFiber(\n        root,\n        parentFiber,\n        committedLanes,\n        committedTransitions\n      ),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveMountOnFiber(\n  finishedRoot,\n  finishedWork,\n  committedLanes,\n  committedTransitions\n) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 && commitHookEffectListMount(9, finishedWork);\n      break;\n    case 3:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        ((finishedRoot = null),\n        null !== finishedWork.alternate &&\n          (finishedRoot = finishedWork.alternate.memoizedState.cache),\n        (finishedWork = finishedWork.memoizedState.cache),\n        finishedWork !== finishedRoot &&\n          (finishedWork.refCount++,\n          null != finishedRoot && releaseCache(finishedRoot)));\n      break;\n    case 12:\n      if (flags & 2048) {\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n        finishedRoot = finishedWork.stateNode;\n        try {\n          var _finishedWork$memoize2 = finishedWork.memoizedProps,\n            id = _finishedWork$memoize2.id,\n            onPostCommit = _finishedWork$memoize2.onPostCommit;\n          "function" === typeof onPostCommit &&\n            onPostCommit(\n              id,\n              null === finishedWork.alternate ? "mount" : "update",\n              finishedRoot.passiveEffectDuration,\n              -0\n            );\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      } else\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n      break;\n    case 23:\n      break;\n    case 22:\n      _finishedWork$memoize2 = finishedWork.stateNode;\n      null !== finishedWork.memoizedState\n        ? _finishedWork$memoize2._visibility & 4\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)\n        : _finishedWork$memoize2._visibility & 4\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : ((_finishedWork$memoize2._visibility |= 4),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              0 !== (finishedWork.subtreeFlags & 10256)\n            ));\n      flags & 2048 &&\n        commitOffscreenPassiveMountEffects(\n          finishedWork.alternate,\n          finishedWork\n        );\n      break;\n    case 24:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n  }\n}\nfunction recursivelyTraverseReconnectPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  committedLanes$jscomp$0,\n  committedTransitions$jscomp$0,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      committedLanes = committedLanes$jscomp$0,\n      committedTransitions = committedTransitions$jscomp$0,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(8, finishedWork);\n        break;\n      case 23:\n        break;\n      case 22:\n        var instance = finishedWork.stateNode;\n        null !== finishedWork.memoizedState\n          ? instance._visibility & 4\n            ? recursivelyTraverseReconnectPassiveEffects(\n                finishedRoot,\n                finishedWork,\n                committedLanes,\n                committedTransitions,\n                includeWorkInProgressEffects\n              )\n            : recursivelyTraverseAtomicPassiveEffects(\n                finishedRoot,\n                finishedWork\n              )\n          : ((instance._visibility |= 4),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              includeWorkInProgressEffects\n            ));\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitOffscreenPassiveMountEffects(\n            finishedWork.alternate,\n            finishedWork\n          );\n        break;\n      case 24:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n        break;\n      default:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseAtomicPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var finishedRoot = finishedRoot$jscomp$0,\n        finishedWork = parentFiber,\n        flags = finishedWork.flags;\n      switch (finishedWork.tag) {\n        case 22:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitOffscreenPassiveMountEffects(\n              finishedWork.alternate,\n              finishedWork\n            );\n          break;\n        case 24:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n          break;\n        default:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n      }\n      parentFiber = parentFiber.sibling;\n    }\n}\nvar suspenseyCommitFlag = 8192;\nfunction recursivelyAccumulateSuspenseyCommit(parentFiber) {\n  if (parentFiber.subtreeFlags & suspenseyCommitFlag)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      accumulateSuspenseyCommitOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction accumulateSuspenseyCommitOnFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      fiber.flags & suspenseyCommitFlag &&\n        null !== fiber.memoizedState &&\n        suspendResource(\n          currentHoistableRoot,\n          fiber.memoizedState,\n          fiber.memoizedProps\n        );\n      break;\n    case 5:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      break;\n    case 3:\n    case 4:\n      var previousHoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      currentHoistableRoot = previousHoistableRoot;\n      break;\n    case 22:\n      null === fiber.memoizedState &&\n        ((previousHoistableRoot = fiber.alternate),\n        null !== previousHoistableRoot &&\n        null !== previousHoistableRoot.memoizedState\n          ? ((previousHoistableRoot = suspenseyCommitFlag),\n            (suspenseyCommitFlag = 16777216),\n            recursivelyAccumulateSuspenseyCommit(fiber),\n            (suspenseyCommitFlag = previousHoistableRoot))\n          : recursivelyAccumulateSuspenseyCommit(fiber));\n      break;\n    default:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n  }\n}\nfunction detachAlternateSiblings(parentFiber) {\n  var previousFiber = parentFiber.alternate;\n  if (\n    null !== previousFiber &&\n    ((parentFiber = previousFiber.child), null !== parentFiber)\n  ) {\n    previousFiber.child = null;\n    do\n      (previousFiber = parentFiber.sibling),\n        (parentFiber.sibling = null),\n        (parentFiber = previousFiber);\n    while (null !== parentFiber);\n  }\n}\nfunction recursivelyTraversePassiveUnmountEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveUnmountOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      finishedWork.flags & 2048 &&\n        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 12:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 22:\n      var instance = finishedWork.stateNode;\n      null !== finishedWork.memoizedState &&\n      instance._visibility & 4 &&\n      (null === finishedWork.return || 13 !== finishedWork.return.tag)\n        ? ((instance._visibility &= -5),\n          recursivelyTraverseDisconnectPassiveEffects(finishedWork))\n        : recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n  }\n}\nfunction recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    deletions = parentFiber;\n    switch (deletions.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, deletions, deletions.return);\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n        break;\n      case 22:\n        i = deletions.stateNode;\n        i._visibility & 4 &&\n          ((i._visibility &= -5),\n          recursivelyTraverseDisconnectPassiveEffects(deletions));\n        break;\n      default:\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n  deletedSubtreeRoot,\n  nearestMountedAncestor\n) {\n  for (; null !== nextEffect; ) {\n    var fiber = nextEffect;\n    switch (fiber.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);\n        break;\n      case 23:\n      case 22:\n        if (\n          null !== fiber.memoizedState &&\n          null !== fiber.memoizedState.cachePool\n        ) {\n          var cache = fiber.memoizedState.cachePool.pool;\n          null != cache && cache.refCount++;\n        }\n        break;\n      case 24:\n        releaseCache(fiber.memoizedState.cache);\n    }\n    cache = fiber.child;\n    if (null !== cache) (cache.return = fiber), (nextEffect = cache);\n    else\n      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {\n        cache = nextEffect;\n        var sibling = cache.sibling,\n          returnFiber = cache.return;\n        detachFiberAfterEffects(cache);\n        if (cache === fiber) {\n          nextEffect = null;\n          break a;\n        }\n        if (null !== sibling) {\n          sibling.return = returnFiber;\n          nextEffect = sibling;\n          break a;\n        }\n        nextEffect = returnFiber;\n      }\n  }\n}\nfunction FiberNode(tag, pendingProps, key, mode) {\n  this.tag = tag;\n  this.key = key;\n  this.sibling =\n    this.child =\n    this.return =\n    this.stateNode =\n    this.type =\n    this.elementType =\n      null;\n  this.index = 0;\n  this.refCleanup = this.ref = null;\n  this.pendingProps = pendingProps;\n  this.dependencies =\n    this.memoizedState =\n    this.updateQueue =\n    this.memoizedProps =\n      null;\n  this.mode = mode;\n  this.subtreeFlags = this.flags = 0;\n  this.deletions = null;\n  this.childLanes = this.lanes = 0;\n  this.alternate = null;\n}\nfunction createFiberImplClass(tag, pendingProps, key, mode) {\n  return new FiberNode(tag, pendingProps, key, mode);\n}\nfunction shouldConstruct(Component) {\n  Component = Component.prototype;\n  return !(!Component || !Component.isReactComponent);\n}\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n  null === workInProgress\n    ? ((workInProgress = createFiberImplClass(\n        current.tag,\n        pendingProps,\n        current.key,\n        current.mode\n      )),\n      (workInProgress.elementType = current.elementType),\n      (workInProgress.type = current.type),\n      (workInProgress.stateNode = current.stateNode),\n      (workInProgress.alternate = current),\n      (current.alternate = workInProgress))\n    : ((workInProgress.pendingProps = pendingProps),\n      (workInProgress.type = current.type),\n      (workInProgress.flags = 0),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null));\n  workInProgress.flags = current.flags & 31457280;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  pendingProps = current.dependencies;\n  workInProgress.dependencies =\n    null === pendingProps\n      ? null\n      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n  workInProgress.refCleanup = current.refCleanup;\n  return workInProgress;\n}\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  workInProgress.flags &= 31457282;\n  var current = workInProgress.alternate;\n  null === current\n    ? ((workInProgress.childLanes = 0),\n      (workInProgress.lanes = renderLanes),\n      (workInProgress.child = null),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.memoizedProps = null),\n      (workInProgress.memoizedState = null),\n      (workInProgress.updateQueue = null),\n      (workInProgress.dependencies = null),\n      (workInProgress.stateNode = null))\n    : ((workInProgress.childLanes = current.childLanes),\n      (workInProgress.lanes = current.lanes),\n      (workInProgress.child = current.child),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null),\n      (workInProgress.memoizedProps = current.memoizedProps),\n      (workInProgress.memoizedState = current.memoizedState),\n      (workInProgress.updateQueue = current.updateQueue),\n      (workInProgress.type = current.type),\n      (renderLanes = current.dependencies),\n      (workInProgress.dependencies =\n        null === renderLanes\n          ? null\n          : {\n              lanes: renderLanes.lanes,\n              firstContext: renderLanes.firstContext\n            }));\n  return workInProgress;\n}\nfunction createFiberFromTypeAndProps(\n  type,\n  key,\n  pendingProps,\n  owner,\n  mode,\n  lanes\n) {\n  var fiberTag = 0;\n  owner = type;\n  if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);\n  else if ("string" === typeof type)\n    fiberTag = isHostHoistableType(\n      type,\n      pendingProps,\n      contextStackCursor.current\n    )\n      ? 26\n      : "html" === type || "head" === type || "body" === type\n        ? 27\n        : 5;\n  else\n    a: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = 8;\n        mode |= 24;\n        break;\n      case REACT_PROFILER_TYPE:\n        return (\n          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),\n          (type.elementType = REACT_PROFILER_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_TYPE:\n        return (\n          (type = createFiberImplClass(13, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_LIST_TYPE:\n        return (\n          (type = createFiberImplClass(19, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_LIST_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_OFFSCREEN_TYPE:\n        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n      default:\n        if ("object" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              fiberTag = 10;\n              break a;\n            case REACT_CONSUMER_TYPE:\n              fiberTag = 9;\n              break a;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = 11;\n              break a;\n            case REACT_MEMO_TYPE:\n              fiberTag = 14;\n              break a;\n            case REACT_LAZY_TYPE:\n              fiberTag = 16;\n              owner = null;\n              break a;\n          }\n        fiberTag = 29;\n        pendingProps = Error(\n          formatProdErrorMessage(130, null === type ? "null" : typeof type, "")\n        );\n        owner = null;\n    }\n  key = createFiberImplClass(fiberTag, pendingProps, key, mode);\n  key.elementType = type;\n  key.type = owner;\n  key.lanes = lanes;\n  return key;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  elements = createFiberImplClass(7, elements, key, mode);\n  elements.lanes = lanes;\n  return elements;\n}\nfunction createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n  pendingProps = createFiberImplClass(22, pendingProps, key, mode);\n  pendingProps.elementType = REACT_OFFSCREEN_TYPE;\n  pendingProps.lanes = lanes;\n  var primaryChildInstance = {\n    _visibility: 1,\n    _pendingVisibility: 1,\n    _pendingMarkers: null,\n    _retryCache: null,\n    _transitions: null,\n    _current: null,\n    detach: function () {\n      var fiber = primaryChildInstance._current;\n      if (null === fiber) throw Error(formatProdErrorMessage(456));\n      if (0 === (primaryChildInstance._pendingVisibility & 2)) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root &&\n          ((primaryChildInstance._pendingVisibility |= 2),\n          scheduleUpdateOnFiber(root, fiber, 2));\n      }\n    },\n    attach: function () {\n      var fiber = primaryChildInstance._current;\n      if (null === fiber) throw Error(formatProdErrorMessage(456));\n      if (0 !== (primaryChildInstance._pendingVisibility & 2)) {\n        var root = enqueueConcurrentRenderForLane(fiber, 2);\n        null !== root &&\n          ((primaryChildInstance._pendingVisibility &= -3),\n          scheduleUpdateOnFiber(root, fiber, 2));\n      }\n    }\n  };\n  pendingProps.stateNode = primaryChildInstance;\n  return pendingProps;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  content = createFiberImplClass(6, content, null, mode);\n  content.lanes = lanes;\n  return content;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  mode = createFiberImplClass(\n    4,\n    null !== portal.children ? portal.children : [],\n    portal.key,\n    mode\n  );\n  mode.lanes = lanes;\n  mode.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    implementation: portal.implementation\n  };\n  return mode;\n}\nfunction markUpdate(workInProgress) {\n  workInProgress.flags |= 4;\n}\nfunction preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n  if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))\n    workInProgress.flags &= -16777217;\n  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {\n    resource = suspenseHandlerStackCursor.current;\n    if (\n      null !== resource &&\n      ((workInProgressRootRenderLanes & 4194176) ===\n      workInProgressRootRenderLanes\n        ? null !== shellBoundary\n        : ((workInProgressRootRenderLanes & 62914560) !==\n            workInProgressRootRenderLanes &&\n            0 === (workInProgressRootRenderLanes & 536870912)) ||\n          resource !== shellBoundary)\n    )\n      throw (\n        ((suspendedThenable = noopSuspenseyCommitThenable),\n        SuspenseyCommitException)\n      );\n    workInProgress.flags |= 8192;\n  }\n}\nfunction scheduleRetryEffect(workInProgress, retryQueue) {\n  null !== retryQueue && (workInProgress.flags |= 4);\n  workInProgress.flags & 16384 &&\n    ((retryQueue =\n      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),\n    (workInProgress.lanes |= retryQueue),\n    (workInProgressSuspendedRetryLanes |= retryQueue));\n}\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (!isHydrating)\n    switch (renderState.tailMode) {\n      case "hidden":\n        hasRenderedATailFallback = renderState.tail;\n        for (var lastTailNode = null; null !== hasRenderedATailFallback; )\n          null !== hasRenderedATailFallback.alternate &&\n            (lastTailNode = hasRenderedATailFallback),\n            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);\n        null === lastTailNode\n          ? (renderState.tail = null)\n          : (lastTailNode.sibling = null);\n        break;\n      case "collapsed":\n        lastTailNode = renderState.tail;\n        for (var lastTailNode$131 = null; null !== lastTailNode; )\n          null !== lastTailNode.alternate && (lastTailNode$131 = lastTailNode),\n            (lastTailNode = lastTailNode.sibling);\n        null === lastTailNode$131\n          ? hasRenderedATailFallback || null === renderState.tail\n            ? (renderState.tail = null)\n            : (renderState.tail.sibling = null)\n          : (lastTailNode$131.sibling = null);\n    }\n}\nfunction bubbleProperties(completedWork) {\n  var didBailout =\n      null !== completedWork.alternate &&\n      completedWork.alternate.child === completedWork.child,\n    newChildLanes = 0,\n    subtreeFlags = 0;\n  if (didBailout)\n    for (var child$132 = completedWork.child; null !== child$132; )\n      (newChildLanes |= child$132.lanes | child$132.childLanes),\n        (subtreeFlags |= child$132.subtreeFlags & 31457280),\n        (subtreeFlags |= child$132.flags & 31457280),\n        (child$132.return = completedWork),\n        (child$132 = child$132.sibling);\n  else\n    for (child$132 = completedWork.child; null !== child$132; )\n      (newChildLanes |= child$132.lanes | child$132.childLanes),\n        (subtreeFlags |= child$132.subtreeFlags),\n        (subtreeFlags |= child$132.flags),\n        (child$132.return = completedWork),\n        (child$132 = child$132.sibling);\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps;\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 16:\n    case 15:\n    case 0:\n    case 11:\n    case 7:\n    case 8:\n    case 12:\n    case 9:\n    case 14:\n      return bubbleProperties(workInProgress), null;\n    case 1:\n      return bubbleProperties(workInProgress), null;\n    case 3:\n      renderLanes = workInProgress.stateNode;\n      newProps = null;\n      null !== current && (newProps = current.memoizedState.cache);\n      workInProgress.memoizedState.cache !== newProps &&\n        (workInProgress.flags |= 2048);\n      popProvider(CacheContext);\n      popHostContainer();\n      renderLanes.pendingContext &&\n        ((renderLanes.context = renderLanes.pendingContext),\n        (renderLanes.pendingContext = null));\n      if (null === current || null === current.child)\n        popHydrationState(workInProgress)\n          ? markUpdate(workInProgress)\n          : null === current ||\n            (current.memoizedState.isDehydrated &&\n              0 === (workInProgress.flags & 256)) ||\n            ((workInProgress.flags |= 1024),\n            null !== hydrationErrors &&\n              (queueRecoverableErrors(hydrationErrors),\n              (hydrationErrors = null)));\n      bubbleProperties(workInProgress);\n      return null;\n    case 26:\n      return (\n        (renderLanes = workInProgress.memoizedState),\n        null === current\n          ? (markUpdate(workInProgress),\n            null !== renderLanes\n              ? (bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217)))\n          : renderLanes\n            ? renderLanes !== current.memoizedState\n              ? (markUpdate(workInProgress),\n                bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217))\n            : (current.memoizedProps !== newProps && markUpdate(workInProgress),\n              bubbleProperties(workInProgress),\n              (workInProgress.flags &= -16777217)),\n        null\n      );\n    case 27:\n      popHostContext(workInProgress);\n      renderLanes = rootInstanceStackCursor.current;\n      var type = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        popHydrationState(workInProgress)\n          ? prepareToHydrateHostInstance(workInProgress, current)\n          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),\n            (workInProgress.stateNode = current),\n            markUpdate(workInProgress));\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 5:\n      popHostContext(workInProgress);\n      renderLanes = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        if (popHydrationState(workInProgress))\n          prepareToHydrateHostInstance(workInProgress, current);\n        else {\n          type = getOwnerDocumentFromRootContainer(\n            rootInstanceStackCursor.current\n          );\n          switch (current) {\n            case 1:\n              current = type.createElementNS(\n                "http://www.w3.org/2000/svg",\n                renderLanes\n              );\n              break;\n            case 2:\n              current = type.createElementNS(\n                "http://www.w3.org/1998/Math/MathML",\n                renderLanes\n              );\n              break;\n            default:\n              switch (renderLanes) {\n                case "svg":\n                  current = type.createElementNS(\n                    "http://www.w3.org/2000/svg",\n                    renderLanes\n                  );\n                  break;\n                case "math":\n                  current = type.createElementNS(\n                    "http://www.w3.org/1998/Math/MathML",\n                    renderLanes\n                  );\n                  break;\n                case "script":\n                  current = type.createElement("div");\n                  current.innerHTML = "<script>\\x3c/script>";\n                  current = current.removeChild(current.firstChild);\n                  break;\n                case "select":\n                  current =\n                    "string" === typeof newProps.is\n                      ? type.createElement("select", { is: newProps.is })\n                      : type.createElement("select");\n                  newProps.multiple\n                    ? (current.multiple = !0)\n                    : newProps.size && (current.size = newProps.size);\n                  break;\n                default:\n                  current =\n                    "string" === typeof newProps.is\n                      ? type.createElement(renderLanes, { is: newProps.is })\n                      : type.createElement(renderLanes);\n              }\n          }\n          current[internalInstanceKey] = workInProgress;\n          current[internalPropsKey] = newProps;\n          a: for (type = workInProgress.child; null !== type; ) {\n            if (5 === type.tag || 6 === type.tag)\n              current.appendChild(type.stateNode);\n            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {\n              type.child.return = type;\n              type = type.child;\n              continue;\n            }\n            if (type === workInProgress) break a;\n            for (; null === type.sibling; ) {\n              if (null === type.return || type.return === workInProgress)\n                break a;\n              type = type.return;\n            }\n            type.sibling.return = type.return;\n            type = type.sibling;\n          }\n          workInProgress.stateNode = current;\n          a: switch (\n            (setInitialProperties(current, renderLanes, newProps), renderLanes)\n          ) {\n            case "button":\n            case "input":\n            case "select":\n            case "textarea":\n              current = !!newProps.autoFocus;\n              break a;\n            case "img":\n              current = !0;\n              break a;\n            default:\n              current = !1;\n          }\n          current && markUpdate(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      workInProgress.flags &= -16777217;\n      return null;\n    case 6:\n      if (current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if ("string" !== typeof newProps && null === workInProgress.stateNode)\n          throw Error(formatProdErrorMessage(166));\n        current = rootInstanceStackCursor.current;\n        if (popHydrationState(workInProgress)) {\n          current = workInProgress.stateNode;\n          renderLanes = workInProgress.memoizedProps;\n          newProps = null;\n          type = hydrationParentFiber;\n          if (null !== type)\n            switch (type.tag) {\n              case 27:\n              case 5:\n                newProps = type.memoizedProps;\n            }\n          current[internalInstanceKey] = workInProgress;\n          current =\n            current.nodeValue === renderLanes ||\n            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||\n            checkForUnmatchedText(current.nodeValue, renderLanes)\n              ? !0\n              : !1;\n          current || throwOnHydrationMismatch(workInProgress);\n        } else\n          (current =\n            getOwnerDocumentFromRootContainer(current).createTextNode(\n              newProps\n            )),\n            (current[internalInstanceKey] = workInProgress),\n            (workInProgress.stateNode = current);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 13:\n      newProps = workInProgress.memoizedState;\n      if (\n        null === current ||\n        (null !== current.memoizedState &&\n          null !== current.memoizedState.dehydrated)\n      ) {\n        type = popHydrationState(workInProgress);\n        if (null !== newProps && null !== newProps.dehydrated) {\n          if (null === current) {\n            if (!type) throw Error(formatProdErrorMessage(318));\n            type = workInProgress.memoizedState;\n            type = null !== type ? type.dehydrated : null;\n            if (!type) throw Error(formatProdErrorMessage(317));\n            type[internalInstanceKey] = workInProgress;\n          } else\n            resetHydrationState(),\n              0 === (workInProgress.flags & 128) &&\n                (workInProgress.memoizedState = null),\n              (workInProgress.flags |= 4);\n          bubbleProperties(workInProgress);\n          type = !1;\n        } else\n          null !== hydrationErrors &&\n            (queueRecoverableErrors(hydrationErrors), (hydrationErrors = null)),\n            (type = !0);\n        if (!type) {\n          if (workInProgress.flags & 256)\n            return popSuspenseHandler(workInProgress), workInProgress;\n          popSuspenseHandler(workInProgress);\n          return null;\n        }\n      }\n      popSuspenseHandler(workInProgress);\n      if (0 !== (workInProgress.flags & 128))\n        return (workInProgress.lanes = renderLanes), workInProgress;\n      renderLanes = null !== newProps;\n      current = null !== current && null !== current.memoizedState;\n      if (renderLanes) {\n        newProps = workInProgress.child;\n        type = null;\n        null !== newProps.alternate &&\n          null !== newProps.alternate.memoizedState &&\n          null !== newProps.alternate.memoizedState.cachePool &&\n          (type = newProps.alternate.memoizedState.cachePool.pool);\n        var cache$144 = null;\n        null !== newProps.memoizedState &&\n          null !== newProps.memoizedState.cachePool &&\n          (cache$144 = newProps.memoizedState.cachePool.pool);\n        cache$144 !== type && (newProps.flags |= 2048);\n      }\n      renderLanes !== current &&\n        renderLanes &&\n        (workInProgress.child.flags |= 8192);\n      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n      bubbleProperties(workInProgress);\n      return null;\n    case 4:\n      return (\n        popHostContainer(),\n        null === current &&\n          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 10:\n      return (\n        popProvider(workInProgress.type), bubbleProperties(workInProgress), null\n      );\n    case 19:\n      pop(suspenseStackCursor);\n      type = workInProgress.memoizedState;\n      if (null === type) return bubbleProperties(workInProgress), null;\n      newProps = 0 !== (workInProgress.flags & 128);\n      cache$144 = type.rendering;\n      if (null === cache$144)\n        if (newProps) cutOffTailIfNeeded(type, !1);\n        else {\n          if (\n            0 !== workInProgressRootExitStatus ||\n            (null !== current && 0 !== (current.flags & 128))\n          )\n            for (current = workInProgress.child; null !== current; ) {\n              cache$144 = findFirstSuspended(current);\n              if (null !== cache$144) {\n                workInProgress.flags |= 128;\n                cutOffTailIfNeeded(type, !1);\n                current = cache$144.updateQueue;\n                workInProgress.updateQueue = current;\n                scheduleRetryEffect(workInProgress, current);\n                workInProgress.subtreeFlags = 0;\n                current = renderLanes;\n                for (renderLanes = workInProgress.child; null !== renderLanes; )\n                  resetWorkInProgress(renderLanes, current),\n                    (renderLanes = renderLanes.sibling);\n                push(\n                  suspenseStackCursor,\n                  (suspenseStackCursor.current & 1) | 2\n                );\n                return workInProgress.child;\n              }\n              current = current.sibling;\n            }\n          null !== type.tail &&\n            now() > workInProgressRootRenderTargetTime &&\n            ((workInProgress.flags |= 128),\n            (newProps = !0),\n            cutOffTailIfNeeded(type, !1),\n            (workInProgress.lanes = 4194304));\n        }\n      else {\n        if (!newProps)\n          if (((current = findFirstSuspended(cache$144)), null !== current)) {\n            if (\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              (current = current.updateQueue),\n              (workInProgress.updateQueue = current),\n              scheduleRetryEffect(workInProgress, current),\n              cutOffTailIfNeeded(type, !0),\n              null === type.tail &&\n                "hidden" === type.tailMode &&\n                !cache$144.alternate &&\n                !isHydrating)\n            )\n              return bubbleProperties(workInProgress), null;\n          } else\n            2 * now() - type.renderingStartTime >\n              workInProgressRootRenderTargetTime &&\n              536870912 !== renderLanes &&\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              cutOffTailIfNeeded(type, !1),\n              (workInProgress.lanes = 4194304));\n        type.isBackwards\n          ? ((cache$144.sibling = workInProgress.child),\n            (workInProgress.child = cache$144))\n          : ((current = type.last),\n            null !== current\n              ? (current.sibling = cache$144)\n              : (workInProgress.child = cache$144),\n            (type.last = cache$144));\n      }\n      if (null !== type.tail)\n        return (\n          (workInProgress = type.tail),\n          (type.rendering = workInProgress),\n          (type.tail = workInProgress.sibling),\n          (type.renderingStartTime = now()),\n          (workInProgress.sibling = null),\n          (current = suspenseStackCursor.current),\n          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),\n          workInProgress\n        );\n      bubbleProperties(workInProgress);\n      return null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        (newProps = null !== workInProgress.memoizedState),\n        null !== current\n          ? (null !== current.memoizedState) !== newProps &&\n            (workInProgress.flags |= 8192)\n          : newProps && (workInProgress.flags |= 8192),\n        newProps\n          ? 0 !== (renderLanes & 536870912) &&\n            0 === (workInProgress.flags & 128) &&\n            (bubbleProperties(workInProgress),\n            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))\n          : bubbleProperties(workInProgress),\n        (renderLanes = workInProgress.updateQueue),\n        null !== renderLanes &&\n          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),\n        (renderLanes = null),\n        null !== current &&\n          null !== current.memoizedState &&\n          null !== current.memoizedState.cachePool &&\n          (renderLanes = current.memoizedState.cachePool.pool),\n        (newProps = null),\n        null !== workInProgress.memoizedState &&\n          null !== workInProgress.memoizedState.cachePool &&\n          (newProps = workInProgress.memoizedState.cachePool.pool),\n        newProps !== renderLanes && (workInProgress.flags |= 2048),\n        null !== current && pop(resumedCache),\n        null\n      );\n    case 24:\n      return (\n        (renderLanes = null),\n        null !== current && (renderLanes = current.memoizedState.cache),\n        workInProgress.memoizedState.cache !== renderLanes &&\n          (workInProgress.flags |= 2048),\n        popProvider(CacheContext),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 25:\n      return null;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nfunction unwindWork(current, workInProgress) {\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 1:\n      return (\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 3:\n      return (\n        popProvider(CacheContext),\n        popHostContainer(),\n        (current = workInProgress.flags),\n        0 !== (current & 65536) && 0 === (current & 128)\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 26:\n    case 27:\n    case 5:\n      return popHostContext(workInProgress), null;\n    case 13:\n      popSuspenseHandler(workInProgress);\n      current = workInProgress.memoizedState;\n      if (null !== current && null !== current.dehydrated) {\n        if (null === workInProgress.alternate)\n          throw Error(formatProdErrorMessage(340));\n        resetHydrationState();\n      }\n      current = workInProgress.flags;\n      return current & 65536\n        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n        : null;\n    case 19:\n      return pop(suspenseStackCursor), null;\n    case 4:\n      return popHostContainer(), null;\n    case 10:\n      return popProvider(workInProgress.type), null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        null !== current && pop(resumedCache),\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 24:\n      return popProvider(CacheContext), null;\n    case 25:\n      return null;\n    default:\n      return null;\n  }\n}\nfunction unwindInterruptedWork(current, interruptedWork) {\n  popTreeContext(interruptedWork);\n  switch (interruptedWork.tag) {\n    case 3:\n      popProvider(CacheContext);\n      popHostContainer();\n      break;\n    case 26:\n    case 27:\n    case 5:\n      popHostContext(interruptedWork);\n      break;\n    case 4:\n      popHostContainer();\n      break;\n    case 13:\n      popSuspenseHandler(interruptedWork);\n      break;\n    case 19:\n      pop(suspenseStackCursor);\n      break;\n    case 10:\n      popProvider(interruptedWork.type);\n      break;\n    case 22:\n    case 23:\n      popSuspenseHandler(interruptedWork);\n      popHiddenContext();\n      null !== current && pop(resumedCache);\n      break;\n    case 24:\n      popProvider(CacheContext);\n  }\n}\nvar DefaultAsyncDispatcher = {\n    getCacheForType: function (resourceType) {\n      var cache = readContext(CacheContext),\n        cacheForType = cache.data.get(resourceType);\n      void 0 === cacheForType &&\n        ((cacheForType = resourceType()),\n        cache.data.set(resourceType, cacheForType));\n      return cacheForType;\n    }\n  },\n  PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map,\n  executionContext = 0,\n  workInProgressRoot = null,\n  workInProgress = null,\n  workInProgressRootRenderLanes = 0,\n  workInProgressSuspendedReason = 0,\n  workInProgressThrownValue = null,\n  workInProgressRootDidSkipSuspendedSiblings = !1,\n  workInProgressRootIsPrerendering = !1,\n  workInProgressRootDidAttachPingListener = !1,\n  entangledRenderLanes = 0,\n  workInProgressRootExitStatus = 0,\n  workInProgressRootSkippedLanes = 0,\n  workInProgressRootInterleavedUpdatedLanes = 0,\n  workInProgressRootPingedLanes = 0,\n  workInProgressDeferredLane = 0,\n  workInProgressSuspendedRetryLanes = 0,\n  workInProgressRootConcurrentErrors = null,\n  workInProgressRootRecoverableErrors = null,\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,\n  globalMostRecentFallbackTime = 0,\n  workInProgressRootRenderTargetTime = Infinity,\n  workInProgressTransitions = null,\n  legacyErrorBoundariesThatAlreadyFailed = null,\n  rootDoesHavePassiveEffects = !1,\n  rootWithPendingPassiveEffects = null,\n  pendingPassiveEffectsLanes = 0,\n  pendingPassiveEffectsRemainingLanes = 0,\n  pendingPassiveTransitions = null,\n  nestedUpdateCount = 0,\n  rootWithNestedUpdates = null;\nfunction requestUpdateLane() {\n  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)\n    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n  if (null !== ReactSharedInternals.T) {\n    var actionScopeLane = currentEntangledLane;\n    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();\n  }\n  return resolveUpdatePriority();\n}\nfunction requestDeferredLane() {\n  0 === workInProgressDeferredLane &&\n    (workInProgressDeferredLane =\n      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating\n        ? claimNextTransitionLane()\n        : 536870912);\n  var suspenseHandler = suspenseHandlerStackCursor.current;\n  null !== suspenseHandler && (suspenseHandler.flags |= 32);\n  return workInProgressDeferredLane;\n}\nfunction scheduleUpdateOnFiber(root, fiber, lane) {\n  if (\n    (root === workInProgressRoot && 2 === workInProgressSuspendedReason) ||\n    null !== root.cancelPendingCommit\n  )\n    prepareFreshStack(root, 0),\n      markRootSuspended(\n        root,\n        workInProgressRootRenderLanes,\n        workInProgressDeferredLane,\n        !1\n      );\n  markRootUpdated$1(root, lane);\n  if (0 === (executionContext & 2) || root !== workInProgressRoot)\n    root === workInProgressRoot &&\n      (0 === (executionContext & 2) &&\n        (workInProgressRootInterleavedUpdatedLanes |= lane),\n      4 === workInProgressRootExitStatus &&\n        markRootSuspended(\n          root,\n          workInProgressRootRenderLanes,\n          workInProgressDeferredLane,\n          !1\n        )),\n      ensureRootIsScheduled(root);\n}\nfunction performWorkOnRoot(root$jscomp$0, lanes, forceSync) {\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  var shouldTimeSlice =\n      (!forceSync &&\n        0 === (lanes & 60) &&\n        0 === (lanes & root$jscomp$0.expiredLanes)) ||\n      checkIfRootIsPrerendering(root$jscomp$0, lanes),\n    exitStatus = shouldTimeSlice\n      ? renderRootConcurrent(root$jscomp$0, lanes)\n      : renderRootSync(root$jscomp$0, lanes, !0),\n    renderWasConcurrent = shouldTimeSlice;\n  do {\n    if (0 === exitStatus) {\n      workInProgressRootIsPrerendering &&\n        !shouldTimeSlice &&\n        markRootSuspended(root$jscomp$0, lanes, 0, !1);\n      break;\n    } else if (6 === exitStatus)\n      markRootSuspended(\n        root$jscomp$0,\n        lanes,\n        0,\n        !workInProgressRootDidSkipSuspendedSiblings\n      );\n    else {\n      forceSync = root$jscomp$0.current.alternate;\n      if (\n        renderWasConcurrent &&\n        !isRenderConsistentWithExternalStores(forceSync)\n      ) {\n        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);\n        renderWasConcurrent = !1;\n        continue;\n      }\n      if (2 === exitStatus) {\n        renderWasConcurrent = lanes;\n        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)\n          var JSCompiler_inline_result = 0;\n        else\n          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),\n            (JSCompiler_inline_result =\n              0 !== JSCompiler_inline_result\n                ? JSCompiler_inline_result\n                : JSCompiler_inline_result & 536870912\n                  ? 536870912\n                  : 0);\n        if (0 !== JSCompiler_inline_result) {\n          lanes = JSCompiler_inline_result;\n          a: {\n            var root = root$jscomp$0;\n            exitStatus = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = root.current.memoizedState.isDehydrated;\n            wasRootDehydrated &&\n              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);\n            JSCompiler_inline_result = renderRootSync(\n              root,\n              JSCompiler_inline_result,\n              !1\n            );\n            if (2 !== JSCompiler_inline_result) {\n              if (\n                workInProgressRootDidAttachPingListener &&\n                !wasRootDehydrated\n              ) {\n                root.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                workInProgressRootInterleavedUpdatedLanes |=\n                  renderWasConcurrent;\n                exitStatus = 4;\n                break a;\n              }\n              renderWasConcurrent = workInProgressRootRecoverableErrors;\n              workInProgressRootRecoverableErrors = exitStatus;\n              null !== renderWasConcurrent &&\n                queueRecoverableErrors(renderWasConcurrent);\n            }\n            exitStatus = JSCompiler_inline_result;\n          }\n          renderWasConcurrent = !1;\n          if (2 !== exitStatus) continue;\n        }\n      }\n      if (1 === exitStatus) {\n        prepareFreshStack(root$jscomp$0, 0);\n        markRootSuspended(root$jscomp$0, lanes, 0, !0);\n        break;\n      }\n      a: {\n        shouldTimeSlice = root$jscomp$0;\n        switch (exitStatus) {\n          case 0:\n          case 1:\n            throw Error(formatProdErrorMessage(345));\n          case 4:\n            if ((lanes & 4194176) === lanes) {\n              markRootSuspended(\n                shouldTimeSlice,\n                lanes,\n                workInProgressDeferredLane,\n                !workInProgressRootDidSkipSuspendedSiblings\n              );\n              break a;\n            }\n            break;\n          case 2:\n            workInProgressRootRecoverableErrors = null;\n            break;\n          case 3:\n          case 5:\n            break;\n          default:\n            throw Error(formatProdErrorMessage(329));\n        }\n        shouldTimeSlice.finishedWork = forceSync;\n        shouldTimeSlice.finishedLanes = lanes;\n        if (\n          (lanes & 62914560) === lanes &&\n          ((renderWasConcurrent = globalMostRecentFallbackTime + 300 - now()),\n          10 < renderWasConcurrent)\n        ) {\n          markRootSuspended(\n            shouldTimeSlice,\n            lanes,\n            workInProgressDeferredLane,\n            !workInProgressRootDidSkipSuspendedSiblings\n          );\n          if (0 !== getNextLanes(shouldTimeSlice, 0)) break a;\n          shouldTimeSlice.timeoutHandle = scheduleTimeout(\n            commitRootWhenReady.bind(\n              null,\n              shouldTimeSlice,\n              forceSync,\n              workInProgressRootRecoverableErrors,\n              workInProgressTransitions,\n              workInProgressRootDidIncludeRecursiveRenderUpdate,\n              lanes,\n              workInProgressDeferredLane,\n              workInProgressRootInterleavedUpdatedLanes,\n              workInProgressSuspendedRetryLanes,\n              workInProgressRootDidSkipSuspendedSiblings,\n              2,\n              -0,\n              0\n            ),\n            renderWasConcurrent\n          );\n          break a;\n        }\n        commitRootWhenReady(\n          shouldTimeSlice,\n          forceSync,\n          workInProgressRootRecoverableErrors,\n          workInProgressTransitions,\n          workInProgressRootDidIncludeRecursiveRenderUpdate,\n          lanes,\n          workInProgressDeferredLane,\n          workInProgressRootInterleavedUpdatedLanes,\n          workInProgressSuspendedRetryLanes,\n          workInProgressRootDidSkipSuspendedSiblings,\n          0,\n          -0,\n          0\n        );\n      }\n    }\n    break;\n  } while (1);\n  ensureRootIsScheduled(root$jscomp$0);\n}\nfunction queueRecoverableErrors(errors) {\n  null === workInProgressRootRecoverableErrors\n    ? (workInProgressRootRecoverableErrors = errors)\n    : workInProgressRootRecoverableErrors.push.apply(\n        workInProgressRootRecoverableErrors,\n        errors\n      );\n}\nfunction commitRootWhenReady(\n  root,\n  finishedWork,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  lanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes,\n  didSkipSuspendedSiblings,\n  suspendedCommitReason,\n  completedRenderStartTime,\n  completedRenderEndTime\n) {\n  var subtreeFlags = finishedWork.subtreeFlags;\n  if (subtreeFlags & 8192 || 16785408 === (subtreeFlags & 16785408))\n    if (\n      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),\n      accumulateSuspenseyCommitOnFiber(finishedWork),\n      (finishedWork = waitForCommitToBeReady()),\n      null !== finishedWork)\n    ) {\n      root.cancelPendingCommit = finishedWork(\n        commitRoot.bind(\n          null,\n          root,\n          recoverableErrors,\n          transitions,\n          didIncludeRenderPhaseUpdate,\n          spawnedLane,\n          updatedLanes,\n          suspendedRetryLanes,\n          1,\n          completedRenderStartTime,\n          completedRenderEndTime\n        )\n      );\n      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n      return;\n    }\n  commitRoot(\n    root,\n    recoverableErrors,\n    transitions,\n    didIncludeRenderPhaseUpdate,\n    spawnedLane,\n    updatedLanes,\n    suspendedRetryLanes,\n    suspendedCommitReason,\n    completedRenderStartTime,\n    completedRenderEndTime\n  );\n}\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  for (var node = finishedWork; ; ) {\n    var tag = node.tag;\n    if (\n      (0 === tag || 11 === tag || 15 === tag) &&\n      node.flags & 16384 &&\n      ((tag = node.updateQueue),\n      null !== tag && ((tag = tag.stores), null !== tag))\n    )\n      for (var i = 0; i < tag.length; i++) {\n        var check = tag[i],\n          getSnapshot = check.getSnapshot;\n        check = check.value;\n        try {\n          if (!objectIs(getSnapshot(), check)) return !1;\n        } catch (error) {\n          return !1;\n        }\n      }\n    tag = node.child;\n    if (node.subtreeFlags & 16384 && null !== tag)\n      (tag.return = node), (node = tag);\n    else {\n      if (node === finishedWork) break;\n      for (; null === node.sibling; ) {\n        if (null === node.return || node.return === finishedWork) return !0;\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n  return !0;\n}\nfunction markRootSuspended(\n  root,\n  suspendedLanes,\n  spawnedLane,\n  didAttemptEntireTree\n) {\n  suspendedLanes &= ~workInProgressRootPingedLanes;\n  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n  didAttemptEntireTree = root.expirationTimes;\n  for (var lanes = suspendedLanes; 0 < lanes; ) {\n    var index$6 = 31 - clz32(lanes),\n      lane = 1 << index$6;\n    didAttemptEntireTree[index$6] = -1;\n    lanes &= ~lane;\n  }\n  0 !== spawnedLane &&\n    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n}\nfunction flushSyncWork$1() {\n  return 0 === (executionContext & 6)\n    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)\n    : !0;\n}\nfunction resetWorkInProgressStack() {\n  if (null !== workInProgress) {\n    if (0 === workInProgressSuspendedReason)\n      var interruptedWork = workInProgress.return;\n    else\n      (interruptedWork = workInProgress),\n        (lastContextDependency = currentlyRenderingFiber = null),\n        resetHooksOnUnwind(interruptedWork),\n        (thenableState$1 = null),\n        (thenableIndexCounter$1 = 0),\n        (interruptedWork = workInProgress);\n    for (; null !== interruptedWork; )\n      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),\n        (interruptedWork = interruptedWork.return);\n    workInProgress = null;\n  }\n}\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = 0;\n  var timeoutHandle = root.timeoutHandle;\n  -1 !== timeoutHandle &&\n    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));\n  timeoutHandle = root.cancelPendingCommit;\n  null !== timeoutHandle &&\n    ((root.cancelPendingCommit = null), timeoutHandle());\n  resetWorkInProgressStack();\n  workInProgressRoot = root;\n  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = lanes;\n  workInProgressSuspendedReason = 0;\n  workInProgressThrownValue = null;\n  workInProgressRootDidSkipSuspendedSiblings = !1;\n  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n  workInProgressRootDidAttachPingListener = !1;\n  workInProgressSuspendedRetryLanes =\n    workInProgressDeferredLane =\n    workInProgressRootPingedLanes =\n    workInProgressRootInterleavedUpdatedLanes =\n    workInProgressRootSkippedLanes =\n    workInProgressRootExitStatus =\n      0;\n  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =\n    null;\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n  0 !== (lanes & 8) && (lanes |= lanes & 32);\n  var allEntangledLanes = root.entangledLanes;\n  if (0 !== allEntangledLanes)\n    for (\n      root = root.entanglements, allEntangledLanes &= lanes;\n      0 < allEntangledLanes;\n\n    ) {\n      var index$4 = 31 - clz32(allEntangledLanes),\n        lane = 1 << index$4;\n      lanes |= root[index$4];\n      allEntangledLanes &= ~lane;\n    }\n  entangledRenderLanes = lanes;\n  finishQueueingConcurrentUpdates();\n  return timeoutHandle;\n}\nfunction handleThrow(root, thrownValue) {\n  currentlyRenderingFiber$1 = null;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  thrownValue === SuspenseException\n    ? ((thrownValue = getSuspendedThenable()),\n      (workInProgressSuspendedReason = 3))\n    : thrownValue === SuspenseyCommitException\n      ? ((thrownValue = getSuspendedThenable()),\n        (workInProgressSuspendedReason = 4))\n      : (workInProgressSuspendedReason =\n          thrownValue === SelectiveHydrationException\n            ? 8\n            : null !== thrownValue &&\n                "object" === typeof thrownValue &&\n                "function" === typeof thrownValue.then\n              ? 6\n              : 1);\n  workInProgressThrownValue = thrownValue;\n  null === workInProgress &&\n    ((workInProgressRootExitStatus = 1),\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    ));\n}\nfunction pushDispatcher() {\n  var prevDispatcher = ReactSharedInternals.H;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n}\nfunction pushAsyncDispatcher() {\n  var prevAsyncDispatcher = ReactSharedInternals.A;\n  ReactSharedInternals.A = DefaultAsyncDispatcher;\n  return prevAsyncDispatcher;\n}\nfunction renderDidSuspendDelayIfPossible() {\n  workInProgressRootExitStatus = 4;\n  workInProgressRootDidSkipSuspendedSiblings ||\n    ((workInProgressRootRenderLanes & 4194176) !==\n      workInProgressRootRenderLanes &&\n      null !== suspenseHandlerStackCursor.current) ||\n    (workInProgressRootIsPrerendering = !0);\n  (0 === (workInProgressRootSkippedLanes & 134217727) &&\n    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||\n    null === workInProgressRoot ||\n    markRootSuspended(\n      workInProgressRoot,\n      workInProgressRootRenderLanes,\n      workInProgressDeferredLane,\n      !1\n    );\n}\nfunction renderRootSync(root, lanes, shouldYieldForPrerendering) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)\n    (workInProgressTransitions = null), prepareFreshStack(root, lanes);\n  lanes = !1;\n  var exitStatus = workInProgressRootExitStatus;\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        var unitOfWork = workInProgress,\n          thrownValue = workInProgressThrownValue;\n        switch (workInProgressSuspendedReason) {\n          case 8:\n            resetWorkInProgressStack();\n            exitStatus = 6;\n            break a;\n          case 3:\n          case 2:\n          case 6:\n            null === suspenseHandlerStackCursor.current && (lanes = !0);\n            var reason = workInProgressSuspendedReason;\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n            if (\n              shouldYieldForPrerendering &&\n              workInProgressRootIsPrerendering\n            ) {\n              exitStatus = 0;\n              break a;\n            }\n            break;\n          default:\n            (reason = workInProgressSuspendedReason),\n              (workInProgressSuspendedReason = 0),\n              (workInProgressThrownValue = null),\n              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n        }\n      }\n      workLoopSync();\n      exitStatus = workInProgressRootExitStatus;\n      break;\n    } catch (thrownValue$164) {\n      handleThrow(root, thrownValue$164);\n    }\n  while (1);\n  lanes && root.shellSuspendCounter++;\n  lastContextDependency = currentlyRenderingFiber = null;\n  executionContext = prevExecutionContext;\n  ReactSharedInternals.H = prevDispatcher;\n  ReactSharedInternals.A = prevAsyncDispatcher;\n  null === workInProgress &&\n    ((workInProgressRoot = null),\n    (workInProgressRootRenderLanes = 0),\n    finishQueueingConcurrentUpdates());\n  return exitStatus;\n}\nfunction workLoopSync() {\n  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);\n}\nfunction renderRootConcurrent(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes\n    ? ((workInProgressTransitions = null),\n      (workInProgressRootRenderTargetTime = now() + 500),\n      prepareFreshStack(root, lanes))\n    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(\n        root,\n        lanes\n      ));\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        lanes = workInProgress;\n        var thrownValue = workInProgressThrownValue;\n        b: switch (workInProgressSuspendedReason) {\n          case 1:\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);\n            break;\n          case 2:\n            if (isThenableResolved(thrownValue)) {\n              workInProgressSuspendedReason = 0;\n              workInProgressThrownValue = null;\n              replaySuspendedUnitOfWork(lanes);\n              break;\n            }\n            lanes = function () {\n              2 === workInProgressSuspendedReason &&\n                workInProgressRoot === root &&\n                (workInProgressSuspendedReason = 7);\n              ensureRootIsScheduled(root);\n            };\n            thrownValue.then(lanes, lanes);\n            break a;\n          case 3:\n            workInProgressSuspendedReason = 7;\n            break a;\n          case 4:\n            workInProgressSuspendedReason = 5;\n            break a;\n          case 7:\n            isThenableResolved(thrownValue)\n              ? ((workInProgressSuspendedReason = 0),\n                (workInProgressThrownValue = null),\n                replaySuspendedUnitOfWork(lanes))\n              : ((workInProgressSuspendedReason = 0),\n                (workInProgressThrownValue = null),\n                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));\n            break;\n          case 5:\n            var resource = null;\n            switch (workInProgress.tag) {\n              case 26:\n                resource = workInProgress.memoizedState;\n              case 5:\n              case 27:\n                var hostFiber = workInProgress;\n                if (resource ? preloadResource(resource) : 1) {\n                  workInProgressSuspendedReason = 0;\n                  workInProgressThrownValue = null;\n                  var sibling = hostFiber.sibling;\n                  if (null !== sibling) workInProgress = sibling;\n                  else {\n                    var returnFiber = hostFiber.return;\n                    null !== returnFiber\n                      ? ((workInProgress = returnFiber),\n                        completeUnitOfWork(returnFiber))\n                      : (workInProgress = null);\n                  }\n                  break b;\n                }\n            }\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);\n            break;\n          case 6:\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);\n            break;\n          case 8:\n            resetWorkInProgressStack();\n            workInProgressRootExitStatus = 6;\n            break a;\n          default:\n            throw Error(formatProdErrorMessage(462));\n        }\n      }\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue$166) {\n      handleThrow(root, thrownValue$166);\n    }\n  while (1);\n  lastContextDependency = currentlyRenderingFiber = null;\n  ReactSharedInternals.H = prevDispatcher;\n  ReactSharedInternals.A = prevAsyncDispatcher;\n  executionContext = prevExecutionContext;\n  if (null !== workInProgress) return 0;\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = 0;\n  finishQueueingConcurrentUpdates();\n  return workInProgressRootExitStatus;\n}\nfunction workLoopConcurrent() {\n  for (; null !== workInProgress && !shouldYield(); )\n    performUnitOfWork(workInProgress);\n}\nfunction performUnitOfWork(unitOfWork) {\n  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);\n}\nfunction replaySuspendedUnitOfWork(unitOfWork) {\n  var next = unitOfWork;\n  var current = next.alternate;\n  switch (next.tag) {\n    case 15:\n    case 0:\n      next = replayFunctionComponent(\n        current,\n        next,\n        next.pendingProps,\n        next.type,\n        void 0,\n        workInProgressRootRenderLanes\n      );\n      break;\n    case 11:\n      next = replayFunctionComponent(\n        current,\n        next,\n        next.pendingProps,\n        next.type.render,\n        next.ref,\n        workInProgressRootRenderLanes\n      );\n      break;\n    case 5:\n      resetHooksOnUnwind(next);\n    default:\n      unwindInterruptedWork(current, next),\n        (next = workInProgress =\n          resetWorkInProgress(next, entangledRenderLanes)),\n        (next = beginWork(current, next, entangledRenderLanes));\n  }\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);\n}\nfunction throwAndUnwindWorkLoop(\n  root,\n  unitOfWork,\n  thrownValue,\n  suspendedReason\n) {\n  lastContextDependency = currentlyRenderingFiber = null;\n  resetHooksOnUnwind(unitOfWork);\n  thenableState$1 = null;\n  thenableIndexCounter$1 = 0;\n  var returnFiber = unitOfWork.return;\n  try {\n    if (\n      throwException(\n        root,\n        returnFiber,\n        unitOfWork,\n        thrownValue,\n        workInProgressRootRenderLanes\n      )\n    ) {\n      workInProgressRootExitStatus = 1;\n      logUncaughtError(\n        root,\n        createCapturedValueAtFiber(thrownValue, root.current)\n      );\n      workInProgress = null;\n      return;\n    }\n  } catch (error) {\n    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);\n    workInProgressRootExitStatus = 1;\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    );\n    workInProgress = null;\n    return;\n  }\n  if (unitOfWork.flags & 32768) {\n    if (isHydrating || 1 === suspendedReason) root = !0;\n    else if (\n      workInProgressRootIsPrerendering ||\n      0 !== (workInProgressRootRenderLanes & 536870912)\n    )\n      root = !1;\n    else if (\n      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),\n      2 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)\n    )\n      (suspendedReason = suspenseHandlerStackCursor.current),\n        null !== suspendedReason &&\n          13 === suspendedReason.tag &&\n          (suspendedReason.flags |= 16384);\n    unwindUnitOfWork(unitOfWork, root);\n  } else completeUnitOfWork(unitOfWork);\n}\nfunction completeUnitOfWork(unitOfWork) {\n  var completedWork = unitOfWork;\n  do {\n    if (0 !== (completedWork.flags & 32768)) {\n      unwindUnitOfWork(\n        completedWork,\n        workInProgressRootDidSkipSuspendedSiblings\n      );\n      return;\n    }\n    unitOfWork = completedWork.return;\n    var next = completeWork(\n      completedWork.alternate,\n      completedWork,\n      entangledRenderLanes\n    );\n    if (null !== next) {\n      workInProgress = next;\n      return;\n    }\n    completedWork = completedWork.sibling;\n    if (null !== completedWork) {\n      workInProgress = completedWork;\n      return;\n    }\n    workInProgress = completedWork = unitOfWork;\n  } while (null !== completedWork);\n  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);\n}\nfunction unwindUnitOfWork(unitOfWork, skipSiblings) {\n  do {\n    var next = unwindWork(unitOfWork.alternate, unitOfWork);\n    if (null !== next) {\n      next.flags &= 32767;\n      workInProgress = next;\n      return;\n    }\n    next = unitOfWork.return;\n    null !== next &&\n      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));\n    if (\n      !skipSiblings &&\n      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)\n    ) {\n      workInProgress = unitOfWork;\n      return;\n    }\n    workInProgress = unitOfWork = next;\n  } while (null !== unitOfWork);\n  workInProgressRootExitStatus = 6;\n  workInProgress = null;\n}\nfunction commitRoot(\n  root,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes,\n  suspendedCommitReason,\n  completedRenderStartTime,\n  completedRenderEndTime\n) {\n  var prevTransition = ReactSharedInternals.T,\n    previousUpdateLanePriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 2),\n      (ReactSharedInternals.T = null),\n      commitRootImpl(\n        root,\n        recoverableErrors,\n        transitions,\n        didIncludeRenderPhaseUpdate,\n        previousUpdateLanePriority,\n        spawnedLane,\n        updatedLanes,\n        suspendedRetryLanes,\n        suspendedCommitReason,\n        completedRenderStartTime,\n        completedRenderEndTime\n      );\n  } finally {\n    (ReactSharedInternals.T = prevTransition),\n      (ReactDOMSharedInternals.p = previousUpdateLanePriority);\n  }\n}\nfunction commitRootImpl(\n  root,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  renderPriorityLevel,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  do flushPassiveEffects();\n  while (null !== rootWithPendingPassiveEffects);\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  var finishedWork = root.finishedWork;\n  didIncludeRenderPhaseUpdate = root.finishedLanes;\n  if (null === finishedWork) return null;\n  root.finishedWork = null;\n  root.finishedLanes = 0;\n  if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));\n  root.callbackNode = null;\n  root.callbackPriority = 0;\n  root.cancelPendingCommit = null;\n  var remainingLanes = finishedWork.lanes | finishedWork.childLanes;\n  remainingLanes |= concurrentlyUpdatedLanes;\n  markRootFinished(\n    root,\n    didIncludeRenderPhaseUpdate,\n    remainingLanes,\n    spawnedLane,\n    updatedLanes,\n    suspendedRetryLanes\n  );\n  root === workInProgressRoot &&\n    ((workInProgress = workInProgressRoot = null),\n    (workInProgressRootRenderLanes = 0));\n  (0 === (finishedWork.subtreeFlags & 10256) &&\n    0 === (finishedWork.flags & 10256)) ||\n    rootDoesHavePassiveEffects ||\n    ((rootDoesHavePassiveEffects = !0),\n    (pendingPassiveEffectsRemainingLanes = remainingLanes),\n    (pendingPassiveTransitions = transitions),\n    scheduleCallback$1(NormalPriority$1, function () {\n      flushPassiveEffects(!0);\n      return null;\n    }));\n  transitions = 0 !== (finishedWork.flags & 15990);\n  0 !== (finishedWork.subtreeFlags & 15990) || transitions\n    ? ((transitions = ReactSharedInternals.T),\n      (ReactSharedInternals.T = null),\n      (spawnedLane = ReactDOMSharedInternals.p),\n      (ReactDOMSharedInternals.p = 2),\n      (updatedLanes = executionContext),\n      (executionContext |= 4),\n      commitBeforeMutationEffects(root, finishedWork),\n      commitMutationEffectsOnFiber(finishedWork, root),\n      restoreSelection(selectionInformation, root.containerInfo),\n      (_enabled = !!eventsEnabled),\n      (selectionInformation = eventsEnabled = null),\n      (root.current = finishedWork),\n      commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork),\n      requestPaint(),\n      (executionContext = updatedLanes),\n      (ReactDOMSharedInternals.p = spawnedLane),\n      (ReactSharedInternals.T = transitions))\n    : (root.current = finishedWork);\n  rootDoesHavePassiveEffects\n    ? ((rootDoesHavePassiveEffects = !1),\n      (rootWithPendingPassiveEffects = root),\n      (pendingPassiveEffectsLanes = didIncludeRenderPhaseUpdate))\n    : releaseRootPooledCache(root, remainingLanes);\n  remainingLanes = root.pendingLanes;\n  0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n  ensureRootIsScheduled(root);\n  if (null !== recoverableErrors)\n    for (\n      renderPriorityLevel = root.onRecoverableError, finishedWork = 0;\n      finishedWork < recoverableErrors.length;\n      finishedWork++\n    )\n      (remainingLanes = recoverableErrors[finishedWork]),\n        renderPriorityLevel(remainingLanes.value, {\n          componentStack: remainingLanes.stack\n        });\n  0 !== (pendingPassiveEffectsLanes & 3) && flushPassiveEffects();\n  remainingLanes = root.pendingLanes;\n  0 !== (didIncludeRenderPhaseUpdate & 4194218) && 0 !== (remainingLanes & 42)\n    ? root === rootWithNestedUpdates\n      ? nestedUpdateCount++\n      : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))\n    : (nestedUpdateCount = 0);\n  flushSyncWorkAcrossRoots_impl(0, !1);\n  return null;\n}\nfunction releaseRootPooledCache(root, remainingLanes) {\n  0 === (root.pooledCacheLanes &= remainingLanes) &&\n    ((remainingLanes = root.pooledCache),\n    null != remainingLanes &&\n      ((root.pooledCache = null), releaseCache(remainingLanes)));\n}\nfunction flushPassiveEffects() {\n  if (null !== rootWithPendingPassiveEffects) {\n    var root$170 = rootWithPendingPassiveEffects,\n      remainingLanes = pendingPassiveEffectsRemainingLanes;\n    pendingPassiveEffectsRemainingLanes = 0;\n    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes),\n      prevTransition = ReactSharedInternals.T,\n      previousPriority = ReactDOMSharedInternals.p;\n    try {\n      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;\n      ReactSharedInternals.T = null;\n      if (null === rootWithPendingPassiveEffects)\n        var JSCompiler_inline_result = !1;\n      else {\n        renderPriority = pendingPassiveTransitions;\n        pendingPassiveTransitions = null;\n        var root = rootWithPendingPassiveEffects,\n          lanes = pendingPassiveEffectsLanes;\n        rootWithPendingPassiveEffects = null;\n        pendingPassiveEffectsLanes = 0;\n        if (0 !== (executionContext & 6))\n          throw Error(formatProdErrorMessage(331));\n        var prevExecutionContext = executionContext;\n        executionContext |= 4;\n        commitPassiveUnmountOnFiber(root.current);\n        commitPassiveMountOnFiber(root, root.current, lanes, renderPriority);\n        executionContext = prevExecutionContext;\n        flushSyncWorkAcrossRoots_impl(0, !1);\n        if (\n          injectedHook &&\n          "function" === typeof injectedHook.onPostCommitFiberRoot\n        )\n          try {\n            injectedHook.onPostCommitFiberRoot(rendererID, root);\n          } catch (err) {}\n        JSCompiler_inline_result = !0;\n      }\n      return JSCompiler_inline_result;\n    } finally {\n      (ReactDOMSharedInternals.p = previousPriority),\n        (ReactSharedInternals.T = prevTransition),\n        releaseRootPooledCache(root$170, remainingLanes);\n    }\n  }\n  return !1;\n}\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n  null !== rootFiber &&\n    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n}\nfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n  if (3 === sourceFiber.tag)\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n  else\n    for (; null !== nearestMountedAncestor; ) {\n      if (3 === nearestMountedAncestor.tag) {\n        captureCommitPhaseErrorOnRoot(\n          nearestMountedAncestor,\n          sourceFiber,\n          error\n        );\n        break;\n      } else if (1 === nearestMountedAncestor.tag) {\n        var instance = nearestMountedAncestor.stateNode;\n        if (\n          "function" ===\n            typeof nearestMountedAncestor.type.getDerivedStateFromError ||\n          ("function" === typeof instance.componentDidCatch &&\n            (null === legacyErrorBoundariesThatAlreadyFailed ||\n              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))\n        ) {\n          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n          error = createClassErrorUpdate(2);\n          instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n          null !== instance &&\n            (initializeClassErrorUpdate(\n              error,\n              instance,\n              nearestMountedAncestor,\n              sourceFiber\n            ),\n            markRootUpdated$1(instance, 2),\n            ensureRootIsScheduled(instance));\n          break;\n        }\n      }\n      nearestMountedAncestor = nearestMountedAncestor.return;\n    }\n}\nfunction attachPingListener(root, wakeable, lanes) {\n  var pingCache = root.pingCache;\n  if (null === pingCache) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    var threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else\n    (threadIDs = pingCache.get(wakeable)),\n      void 0 === threadIDs &&\n        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));\n  threadIDs.has(lanes) ||\n    ((workInProgressRootDidAttachPingListener = !0),\n    threadIDs.add(lanes),\n    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),\n    wakeable.then(root, root));\n}\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  var pingCache = root.pingCache;\n  null !== pingCache && pingCache.delete(wakeable);\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n  root.warmLanes &= ~pingedLanes;\n  workInProgressRoot === root &&\n    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&\n    (4 === workInProgressRootExitStatus ||\n    (3 === workInProgressRootExitStatus &&\n      (workInProgressRootRenderLanes & 62914560) ===\n        workInProgressRootRenderLanes &&\n      300 > now() - globalMostRecentFallbackTime)\n      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)\n      : (workInProgressRootPingedLanes |= pingedLanes),\n    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&\n      (workInProgressSuspendedRetryLanes = 0));\n  ensureRootIsScheduled(root);\n}\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  0 === retryLane && (retryLane = claimNextRetryLane());\n  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n  null !== boundaryFiber &&\n    (markRootUpdated$1(boundaryFiber, retryLane),\n    ensureRootIsScheduled(boundaryFiber));\n}\nfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n  var suspenseState = boundaryFiber.memoizedState,\n    retryLane = 0;\n  null !== suspenseState && (retryLane = suspenseState.retryLane);\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n  var retryLane = 0;\n  switch (boundaryFiber.tag) {\n    case 13:\n      var retryCache = boundaryFiber.stateNode;\n      var suspenseState = boundaryFiber.memoizedState;\n      null !== suspenseState && (retryLane = suspenseState.retryLane);\n      break;\n    case 19:\n      retryCache = boundaryFiber.stateNode;\n      break;\n    case 22:\n      retryCache = boundaryFiber.stateNode._retryCache;\n      break;\n    default:\n      throw Error(formatProdErrorMessage(314));\n  }\n  null !== retryCache && retryCache.delete(wakeable);\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction scheduleCallback$1(priorityLevel, callback) {\n  return scheduleCallback$3(priorityLevel, callback);\n}\nvar firstScheduledRoot = null,\n  lastScheduledRoot = null,\n  didScheduleMicrotask = !1,\n  mightHavePendingSyncWork = !1,\n  isFlushingWork = !1,\n  currentEventTransitionLane = 0;\nfunction ensureRootIsScheduled(root) {\n  root !== lastScheduledRoot &&\n    null === root.next &&\n    (null === lastScheduledRoot\n      ? (firstScheduledRoot = lastScheduledRoot = root)\n      : (lastScheduledRoot = lastScheduledRoot.next = root));\n  mightHavePendingSyncWork = !0;\n  didScheduleMicrotask ||\n    ((didScheduleMicrotask = !0),\n    scheduleImmediateTask(processRootScheduleInMicrotask));\n}\nfunction flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n  if (!isFlushingWork && mightHavePendingSyncWork) {\n    isFlushingWork = !0;\n    do {\n      var didPerformSomeWork = !1;\n      for (var root$172 = firstScheduledRoot; null !== root$172; ) {\n        if (!onlyLegacy)\n          if (0 !== syncTransitionLanes) {\n            var pendingLanes = root$172.pendingLanes;\n            if (0 === pendingLanes) var JSCompiler_inline_result = 0;\n            else {\n              var suspendedLanes = root$172.suspendedLanes,\n                pingedLanes = root$172.pingedLanes;\n              JSCompiler_inline_result =\n                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;\n              JSCompiler_inline_result &=\n                pendingLanes & ~(suspendedLanes & ~pingedLanes);\n              JSCompiler_inline_result =\n                JSCompiler_inline_result & 201326677\n                  ? (JSCompiler_inline_result & 201326677) | 1\n                  : JSCompiler_inline_result\n                    ? JSCompiler_inline_result | 2\n                    : 0;\n            }\n            0 !== JSCompiler_inline_result &&\n              ((didPerformSomeWork = !0),\n              performSyncWorkOnRoot(root$172, JSCompiler_inline_result));\n          } else\n            (JSCompiler_inline_result = workInProgressRootRenderLanes),\n              (JSCompiler_inline_result = getNextLanes(\n                root$172,\n                root$172 === workInProgressRoot ? JSCompiler_inline_result : 0\n              )),\n              0 === (JSCompiler_inline_result & 3) ||\n                checkIfRootIsPrerendering(root$172, JSCompiler_inline_result) ||\n                ((didPerformSomeWork = !0),\n                performSyncWorkOnRoot(root$172, JSCompiler_inline_result));\n        root$172 = root$172.next;\n      }\n    } while (didPerformSomeWork);\n    isFlushingWork = !1;\n  }\n}\nfunction processRootScheduleInMicrotask() {\n  mightHavePendingSyncWork = didScheduleMicrotask = !1;\n  var syncTransitionLanes = 0;\n  0 !== currentEventTransitionLane &&\n    (shouldAttemptEagerTransition() &&\n      (syncTransitionLanes = currentEventTransitionLane),\n    (currentEventTransitionLane = 0));\n  for (\n    var currentTime = now(), prev = null, root = firstScheduledRoot;\n    null !== root;\n\n  ) {\n    var next = root.next,\n      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n    if (0 === nextLanes)\n      (root.next = null),\n        null === prev ? (firstScheduledRoot = next) : (prev.next = next),\n        null === next && (lastScheduledRoot = prev);\n    else if (\n      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))\n    )\n      mightHavePendingSyncWork = !0;\n    root = next;\n  }\n  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n}\nfunction scheduleTaskForRootDuringMicrotask(root, currentTime) {\n  for (\n    var suspendedLanes = root.suspendedLanes,\n      pingedLanes = root.pingedLanes,\n      expirationTimes = root.expirationTimes,\n      lanes = root.pendingLanes & -62914561;\n    0 < lanes;\n\n  ) {\n    var index$5 = 31 - clz32(lanes),\n      lane = 1 << index$5,\n      expirationTime = expirationTimes[index$5];\n    if (-1 === expirationTime) {\n      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))\n        expirationTimes[index$5] = computeExpirationTime(lane, currentTime);\n    } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n    lanes &= ~lane;\n  }\n  currentTime = workInProgressRoot;\n  suspendedLanes = workInProgressRootRenderLanes;\n  suspendedLanes = getNextLanes(\n    root,\n    root === currentTime ? suspendedLanes : 0\n  );\n  pingedLanes = root.callbackNode;\n  if (\n    0 === suspendedLanes ||\n    (root === currentTime && 2 === workInProgressSuspendedReason) ||\n    null !== root.cancelPendingCommit\n  )\n    return (\n      null !== pingedLanes &&\n        null !== pingedLanes &&\n        cancelCallback$1(pingedLanes),\n      (root.callbackNode = null),\n      (root.callbackPriority = 0)\n    );\n  if (\n    0 === (suspendedLanes & 3) ||\n    checkIfRootIsPrerendering(root, suspendedLanes)\n  ) {\n    currentTime = suspendedLanes & -suspendedLanes;\n    if (currentTime === root.callbackPriority) return currentTime;\n    null !== pingedLanes && cancelCallback$1(pingedLanes);\n    switch (lanesToEventPriority(suspendedLanes)) {\n      case 2:\n      case 8:\n        suspendedLanes = UserBlockingPriority;\n        break;\n      case 32:\n        suspendedLanes = NormalPriority$1;\n        break;\n      case 268435456:\n        suspendedLanes = IdlePriority;\n        break;\n      default:\n        suspendedLanes = NormalPriority$1;\n    }\n    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n    root.callbackPriority = currentTime;\n    root.callbackNode = suspendedLanes;\n    return currentTime;\n  }\n  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);\n  root.callbackPriority = 2;\n  root.callbackNode = null;\n  return 2;\n}\nfunction performWorkOnRootViaSchedulerTask(root, didTimeout) {\n  var originalCallbackNode = root.callbackNode;\n  if (flushPassiveEffects() && root.callbackNode !== originalCallbackNode)\n    return null;\n  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0\n  );\n  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n  scheduleTaskForRootDuringMicrotask(root, now());\n  return null != root.callbackNode && root.callbackNode === originalCallbackNode\n    ? performWorkOnRootViaSchedulerTask.bind(null, root)\n    : null;\n}\nfunction performSyncWorkOnRoot(root, lanes) {\n  if (flushPassiveEffects()) return null;\n  performWorkOnRoot(root, lanes, !0);\n}\nfunction scheduleImmediateTask(cb) {\n  scheduleMicrotask(function () {\n    0 !== (executionContext & 6)\n      ? scheduleCallback$3(ImmediatePriority, cb)\n      : cb();\n  });\n}\nfunction requestTransitionLane() {\n  0 === currentEventTransitionLane &&\n    (currentEventTransitionLane = claimNextTransitionLane());\n  return currentEventTransitionLane;\n}\nfunction coerceFormActionProp(actionProp) {\n  return null == actionProp ||\n    "symbol" === typeof actionProp ||\n    "boolean" === typeof actionProp\n    ? null\n    : "function" === typeof actionProp\n      ? actionProp\n      : sanitizeURL("" + actionProp);\n}\nfunction createFormDataWithSubmitter(form, submitter) {\n  var temp = submitter.ownerDocument.createElement("input");\n  temp.name = submitter.name;\n  temp.value = submitter.value;\n  form.id && temp.setAttribute("form", form.id);\n  submitter.parentNode.insertBefore(temp, submitter);\n  form = new FormData(form);\n  temp.parentNode.removeChild(temp);\n  return form;\n}\nfunction extractEvents$1(\n  dispatchQueue,\n  domEventName,\n  maybeTargetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  if (\n    "submit" === domEventName &&\n    maybeTargetInst &&\n    maybeTargetInst.stateNode === nativeEventTarget\n  ) {\n    var action = coerceFormActionProp(\n        (nativeEventTarget[internalPropsKey] || null).action\n      ),\n      submitter = nativeEvent.submitter;\n    submitter &&\n      ((domEventName = (domEventName = submitter[internalPropsKey] || null)\n        ? coerceFormActionProp(domEventName.formAction)\n        : submitter.getAttribute("formAction")),\n      null !== domEventName && ((action = domEventName), (submitter = null)));\n    var event = new SyntheticEvent(\n      "action",\n      "action",\n      null,\n      nativeEvent,\n      nativeEventTarget\n    );\n    dispatchQueue.push({\n      event: event,\n      listeners: [\n        {\n          instance: null,\n          listener: function () {\n            if (nativeEvent.defaultPrevented) {\n              if (0 !== currentEventTransitionLane) {\n                var formData = submitter\n                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)\n                  : new FormData(nativeEventTarget);\n                startHostTransition(\n                  maybeTargetInst,\n                  {\n                    pending: !0,\n                    data: formData,\n                    method: nativeEventTarget.method,\n                    action: action\n                  },\n                  null,\n                  formData\n                );\n              }\n            } else\n              "function" === typeof action &&\n                (event.preventDefault(),\n                (formData = submitter\n                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)\n                  : new FormData(nativeEventTarget)),\n                startHostTransition(\n                  maybeTargetInst,\n                  {\n                    pending: !0,\n                    data: formData,\n                    method: nativeEventTarget.method,\n                    action: action\n                  },\n                  action,\n                  formData\n                ));\n          },\n          currentTarget: nativeEventTarget\n        }\n      ]\n    });\n  }\n}\nfor (\n  var i$jscomp$inline_1439 = 0;\n  i$jscomp$inline_1439 < simpleEventPluginEvents.length;\n  i$jscomp$inline_1439++\n) {\n  var eventName$jscomp$inline_1440 =\n      simpleEventPluginEvents[i$jscomp$inline_1439],\n    domEventName$jscomp$inline_1441 =\n      eventName$jscomp$inline_1440.toLowerCase(),\n    capitalizedEvent$jscomp$inline_1442 =\n      eventName$jscomp$inline_1440[0].toUpperCase() +\n      eventName$jscomp$inline_1440.slice(1);\n  registerSimpleEvent(\n    domEventName$jscomp$inline_1441,\n    "on" + capitalizedEvent$jscomp$inline_1442\n  );\n}\nregisterSimpleEvent(ANIMATION_END, "onAnimationEnd");\nregisterSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");\nregisterSimpleEvent(ANIMATION_START, "onAnimationStart");\nregisterSimpleEvent("dblclick", "onDoubleClick");\nregisterSimpleEvent("focusin", "onFocus");\nregisterSimpleEvent("focusout", "onBlur");\nregisterSimpleEvent(TRANSITION_RUN, "onTransitionRun");\nregisterSimpleEvent(TRANSITION_START, "onTransitionStart");\nregisterSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");\nregisterSimpleEvent(TRANSITION_END, "onTransitionEnd");\nregisterDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);\nregisterDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);\nregisterDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);\nregisterDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);\nregisterTwoPhaseEvent(\n  "onChange",\n  "change click focusin focusout input keydown keyup selectionchange".split(" ")\n);\nregisterTwoPhaseEvent(\n  "onSelect",\n  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(\n    " "\n  )\n);\nregisterTwoPhaseEvent("onBeforeInput", [\n  "compositionend",\n  "keypress",\n  "textInput",\n  "paste"\n]);\nregisterTwoPhaseEvent(\n  "onCompositionEnd",\n  "compositionend focusout keydown keypress keyup mousedown".split(" ")\n);\nregisterTwoPhaseEvent(\n  "onCompositionStart",\n  "compositionstart focusout keydown keypress keyup mousedown".split(" ")\n);\nregisterTwoPhaseEvent(\n  "onCompositionUpdate",\n  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")\n);\nvar mediaEventTypes =\n    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(\n      " "\n    ),\n  nonDelegatedEvents = new Set(\n    "beforetoggle cancel close invalid load scroll scrollend toggle"\n      .split(" ")\n      .concat(mediaEventTypes)\n  );\nfunction processDispatchQueue(dispatchQueue, eventSystemFlags) {\n  eventSystemFlags = 0 !== (eventSystemFlags & 4);\n  for (var i = 0; i < dispatchQueue.length; i++) {\n    var _dispatchQueue$i = dispatchQueue[i],\n      event = _dispatchQueue$i.event;\n    _dispatchQueue$i = _dispatchQueue$i.listeners;\n    a: {\n      var previousInstance = void 0;\n      if (eventSystemFlags)\n        for (\n          var i$jscomp$0 = _dispatchQueue$i.length - 1;\n          0 <= i$jscomp$0;\n          i$jscomp$0--\n        ) {\n          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],\n            instance = _dispatchListeners$i.instance,\n            currentTarget = _dispatchListeners$i.currentTarget;\n          _dispatchListeners$i = _dispatchListeners$i.listener;\n          if (instance !== previousInstance && event.isPropagationStopped())\n            break a;\n          previousInstance = _dispatchListeners$i;\n          event.currentTarget = currentTarget;\n          try {\n            previousInstance(event);\n          } catch (error) {\n            reportGlobalError(error);\n          }\n          event.currentTarget = null;\n          previousInstance = instance;\n        }\n      else\n        for (\n          i$jscomp$0 = 0;\n          i$jscomp$0 < _dispatchQueue$i.length;\n          i$jscomp$0++\n        ) {\n          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];\n          instance = _dispatchListeners$i.instance;\n          currentTarget = _dispatchListeners$i.currentTarget;\n          _dispatchListeners$i = _dispatchListeners$i.listener;\n          if (instance !== previousInstance && event.isPropagationStopped())\n            break a;\n          previousInstance = _dispatchListeners$i;\n          event.currentTarget = currentTarget;\n          try {\n            previousInstance(event);\n          } catch (error) {\n            reportGlobalError(error);\n          }\n          event.currentTarget = null;\n          previousInstance = instance;\n        }\n    }\n  }\n}\nfunction listenToNonDelegatedEvent(domEventName, targetElement) {\n  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];\n  void 0 === JSCompiler_inline_result &&\n    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =\n      new Set());\n  var listenerSetKey = domEventName + "__bubble";\n  JSCompiler_inline_result.has(listenerSetKey) ||\n    (addTrappedEventListener(targetElement, domEventName, 2, !1),\n    JSCompiler_inline_result.add(listenerSetKey));\n}\nfunction listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n  var eventSystemFlags = 0;\n  isCapturePhaseListener && (eventSystemFlags |= 4);\n  addTrappedEventListener(\n    target,\n    domEventName,\n    eventSystemFlags,\n    isCapturePhaseListener\n  );\n}\nvar listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);\nfunction listenToAllSupportedEvents(rootContainerElement) {\n  if (!rootContainerElement[listeningMarker]) {\n    rootContainerElement[listeningMarker] = !0;\n    allNativeEvents.forEach(function (domEventName) {\n      "selectionchange" !== domEventName &&\n        (nonDelegatedEvents.has(domEventName) ||\n          listenToNativeEvent(domEventName, !1, rootContainerElement),\n        listenToNativeEvent(domEventName, !0, rootContainerElement));\n    });\n    var ownerDocument =\n      9 === rootContainerElement.nodeType\n        ? rootContainerElement\n        : rootContainerElement.ownerDocument;\n    null === ownerDocument ||\n      ownerDocument[listeningMarker] ||\n      ((ownerDocument[listeningMarker] = !0),\n      listenToNativeEvent("selectionchange", !1, ownerDocument));\n  }\n}\nfunction addTrappedEventListener(\n  targetContainer,\n  domEventName,\n  eventSystemFlags,\n  isCapturePhaseListener\n) {\n  switch (getEventPriority(domEventName)) {\n    case 2:\n      var listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case 8:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    default:\n      listenerWrapper = dispatchEvent;\n  }\n  eventSystemFlags = listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer\n  );\n  listenerWrapper = void 0;\n  !passiveBrowserEventsSupported ||\n    ("touchstart" !== domEventName &&\n      "touchmove" !== domEventName &&\n      "wheel" !== domEventName) ||\n    (listenerWrapper = !0);\n  isCapturePhaseListener\n    ? void 0 !== listenerWrapper\n      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n          capture: !0,\n          passive: listenerWrapper\n        })\n      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)\n    : void 0 !== listenerWrapper\n      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n          passive: listenerWrapper\n        })\n      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);\n}\nfunction dispatchEventForPluginEventSystem(\n  domEventName,\n  eventSystemFlags,\n  nativeEvent,\n  targetInst$jscomp$0,\n  targetContainer\n) {\n  var ancestorInst = targetInst$jscomp$0;\n  if (\n    0 === (eventSystemFlags & 1) &&\n    0 === (eventSystemFlags & 2) &&\n    null !== targetInst$jscomp$0\n  )\n    a: for (;;) {\n      if (null === targetInst$jscomp$0) return;\n      var nodeTag = targetInst$jscomp$0.tag;\n      if (3 === nodeTag || 4 === nodeTag) {\n        var container = targetInst$jscomp$0.stateNode.containerInfo;\n        if (\n          container === targetContainer ||\n          (8 === container.nodeType && container.parentNode === targetContainer)\n        )\n          break;\n        if (4 === nodeTag)\n          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {\n            var grandTag = nodeTag.tag;\n            if (3 === grandTag || 4 === grandTag)\n              if (\n                ((grandTag = nodeTag.stateNode.containerInfo),\n                grandTag === targetContainer ||\n                  (8 === grandTag.nodeType &&\n                    grandTag.parentNode === targetContainer))\n              )\n                return;\n            nodeTag = nodeTag.return;\n          }\n        for (; null !== container; ) {\n          nodeTag = getClosestInstanceFromNode(container);\n          if (null === nodeTag) return;\n          grandTag = nodeTag.tag;\n          if (\n            5 === grandTag ||\n            6 === grandTag ||\n            26 === grandTag ||\n            27 === grandTag\n          ) {\n            targetInst$jscomp$0 = ancestorInst = nodeTag;\n            continue a;\n          }\n          container = container.parentNode;\n        }\n      }\n      targetInst$jscomp$0 = targetInst$jscomp$0.return;\n    }\n  batchedUpdates$1(function () {\n    var targetInst = ancestorInst,\n      nativeEventTarget = getEventTarget(nativeEvent),\n      dispatchQueue = [];\n    a: {\n      var reactName = topLevelEventsToReactNames.get(domEventName);\n      if (void 0 !== reactName) {\n        var SyntheticEventCtor = SyntheticEvent,\n          reactEventType = domEventName;\n        switch (domEventName) {\n          case "keypress":\n            if (0 === getEventCharCode(nativeEvent)) break a;\n          case "keydown":\n          case "keyup":\n            SyntheticEventCtor = SyntheticKeyboardEvent;\n            break;\n          case "focusin":\n            reactEventType = "focus";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case "focusout":\n            reactEventType = "blur";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case "beforeblur":\n          case "afterblur":\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case "click":\n            if (2 === nativeEvent.button) break a;\n          case "auxclick":\n          case "dblclick":\n          case "mousedown":\n          case "mousemove":\n          case "mouseup":\n          case "mouseout":\n          case "mouseover":\n          case "contextmenu":\n            SyntheticEventCtor = SyntheticMouseEvent;\n            break;\n          case "drag":\n          case "dragend":\n          case "dragenter":\n          case "dragexit":\n          case "dragleave":\n          case "dragover":\n          case "dragstart":\n          case "drop":\n            SyntheticEventCtor = SyntheticDragEvent;\n            break;\n          case "touchcancel":\n          case "touchend":\n          case "touchmove":\n          case "touchstart":\n            SyntheticEventCtor = SyntheticTouchEvent;\n            break;\n          case ANIMATION_END:\n          case ANIMATION_ITERATION:\n          case ANIMATION_START:\n            SyntheticEventCtor = SyntheticAnimationEvent;\n            break;\n          case TRANSITION_END:\n            SyntheticEventCtor = SyntheticTransitionEvent;\n            break;\n          case "scroll":\n          case "scrollend":\n            SyntheticEventCtor = SyntheticUIEvent;\n            break;\n          case "wheel":\n            SyntheticEventCtor = SyntheticWheelEvent;\n            break;\n          case "copy":\n          case "cut":\n          case "paste":\n            SyntheticEventCtor = SyntheticClipboardEvent;\n            break;\n          case "gotpointercapture":\n          case "lostpointercapture":\n          case "pointercancel":\n          case "pointerdown":\n          case "pointermove":\n          case "pointerout":\n          case "pointerover":\n          case "pointerup":\n            SyntheticEventCtor = SyntheticPointerEvent;\n            break;\n          case "toggle":\n          case "beforetoggle":\n            SyntheticEventCtor = SyntheticToggleEvent;\n        }\n        var inCapturePhase = 0 !== (eventSystemFlags & 4),\n          accumulateTargetOnly =\n            !inCapturePhase &&\n            ("scroll" === domEventName || "scrollend" === domEventName),\n          reactEventName = inCapturePhase\n            ? null !== reactName\n              ? reactName + "Capture"\n              : null\n            : reactName;\n        inCapturePhase = [];\n        for (\n          var instance = targetInst, lastHostComponent;\n          null !== instance;\n\n        ) {\n          var _instance = instance;\n          lastHostComponent = _instance.stateNode;\n          _instance = _instance.tag;\n          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||\n            null === lastHostComponent ||\n            null === reactEventName ||\n            ((_instance = getListener(instance, reactEventName)),\n            null != _instance &&\n              inCapturePhase.push(\n                createDispatchListener(instance, _instance, lastHostComponent)\n              ));\n          if (accumulateTargetOnly) break;\n          instance = instance.return;\n        }\n        0 < inCapturePhase.length &&\n          ((reactName = new SyntheticEventCtor(\n            reactName,\n            reactEventType,\n            null,\n            nativeEvent,\n            nativeEventTarget\n          )),\n          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));\n      }\n    }\n    if (0 === (eventSystemFlags & 7)) {\n      a: {\n        reactName =\n          "mouseover" === domEventName || "pointerover" === domEventName;\n        SyntheticEventCtor =\n          "mouseout" === domEventName || "pointerout" === domEventName;\n        if (\n          reactName &&\n          nativeEvent !== currentReplayingEvent &&\n          (reactEventType =\n            nativeEvent.relatedTarget || nativeEvent.fromElement) &&\n          (getClosestInstanceFromNode(reactEventType) ||\n            reactEventType[internalContainerInstanceKey])\n        )\n          break a;\n        if (SyntheticEventCtor || reactName) {\n          reactName =\n            nativeEventTarget.window === nativeEventTarget\n              ? nativeEventTarget\n              : (reactName = nativeEventTarget.ownerDocument)\n                ? reactName.defaultView || reactName.parentWindow\n                : window;\n          if (SyntheticEventCtor) {\n            if (\n              ((reactEventType =\n                nativeEvent.relatedTarget || nativeEvent.toElement),\n              (SyntheticEventCtor = targetInst),\n              (reactEventType = reactEventType\n                ? getClosestInstanceFromNode(reactEventType)\n                : null),\n              null !== reactEventType &&\n                ((accumulateTargetOnly =\n                  getNearestMountedFiber(reactEventType)),\n                (inCapturePhase = reactEventType.tag),\n                reactEventType !== accumulateTargetOnly ||\n                  (5 !== inCapturePhase &&\n                    27 !== inCapturePhase &&\n                    6 !== inCapturePhase)))\n            )\n              reactEventType = null;\n          } else (SyntheticEventCtor = null), (reactEventType = targetInst);\n          if (SyntheticEventCtor !== reactEventType) {\n            inCapturePhase = SyntheticMouseEvent;\n            _instance = "onMouseLeave";\n            reactEventName = "onMouseEnter";\n            instance = "mouse";\n            if ("pointerout" === domEventName || "pointerover" === domEventName)\n              (inCapturePhase = SyntheticPointerEvent),\n                (_instance = "onPointerLeave"),\n                (reactEventName = "onPointerEnter"),\n                (instance = "pointer");\n            accumulateTargetOnly =\n              null == SyntheticEventCtor\n                ? reactName\n                : getNodeFromInstance(SyntheticEventCtor);\n            lastHostComponent =\n              null == reactEventType\n                ? reactName\n                : getNodeFromInstance(reactEventType);\n            reactName = new inCapturePhase(\n              _instance,\n              instance + "leave",\n              SyntheticEventCtor,\n              nativeEvent,\n              nativeEventTarget\n            );\n            reactName.target = accumulateTargetOnly;\n            reactName.relatedTarget = lastHostComponent;\n            _instance = null;\n            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&\n              ((inCapturePhase = new inCapturePhase(\n                reactEventName,\n                instance + "enter",\n                reactEventType,\n                nativeEvent,\n                nativeEventTarget\n              )),\n              (inCapturePhase.target = lastHostComponent),\n              (inCapturePhase.relatedTarget = accumulateTargetOnly),\n              (_instance = inCapturePhase));\n            accumulateTargetOnly = _instance;\n            if (SyntheticEventCtor && reactEventType)\n              b: {\n                inCapturePhase = SyntheticEventCtor;\n                reactEventName = reactEventType;\n                instance = 0;\n                for (\n                  lastHostComponent = inCapturePhase;\n                  lastHostComponent;\n                  lastHostComponent = getParent(lastHostComponent)\n                )\n                  instance++;\n                lastHostComponent = 0;\n                for (\n                  _instance = reactEventName;\n                  _instance;\n                  _instance = getParent(_instance)\n                )\n                  lastHostComponent++;\n                for (; 0 < instance - lastHostComponent; )\n                  (inCapturePhase = getParent(inCapturePhase)), instance--;\n                for (; 0 < lastHostComponent - instance; )\n                  (reactEventName = getParent(reactEventName)),\n                    lastHostComponent--;\n                for (; instance--; ) {\n                  if (\n                    inCapturePhase === reactEventName ||\n                    (null !== reactEventName &&\n                      inCapturePhase === reactEventName.alternate)\n                  )\n                    break b;\n                  inCapturePhase = getParent(inCapturePhase);\n                  reactEventName = getParent(reactEventName);\n                }\n                inCapturePhase = null;\n              }\n            else inCapturePhase = null;\n            null !== SyntheticEventCtor &&\n              accumulateEnterLeaveListenersForEvent(\n                dispatchQueue,\n                reactName,\n                SyntheticEventCtor,\n                inCapturePhase,\n                !1\n              );\n            null !== reactEventType &&\n              null !== accumulateTargetOnly &&\n              accumulateEnterLeaveListenersForEvent(\n                dispatchQueue,\n                accumulateTargetOnly,\n                reactEventType,\n                inCapturePhase,\n                !0\n              );\n          }\n        }\n      }\n      a: {\n        reactName = targetInst ? getNodeFromInstance(targetInst) : window;\n        SyntheticEventCtor =\n          reactName.nodeName && reactName.nodeName.toLowerCase();\n        if (\n          "select" === SyntheticEventCtor ||\n          ("input" === SyntheticEventCtor && "file" === reactName.type)\n        )\n          var getTargetInstFunc = getTargetInstForChangeEvent;\n        else if (isTextInputElement(reactName))\n          if (isInputEventSupported)\n            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n          else {\n            getTargetInstFunc = getTargetInstForInputEventPolyfill;\n            var handleEventFunc = handleEventsForInputEventPolyfill;\n          }\n        else\n          (SyntheticEventCtor = reactName.nodeName),\n            !SyntheticEventCtor ||\n            "input" !== SyntheticEventCtor.toLowerCase() ||\n            ("checkbox" !== reactName.type && "radio" !== reactName.type)\n              ? targetInst &&\n                isCustomElement(targetInst.elementType) &&\n                (getTargetInstFunc = getTargetInstForChangeEvent)\n              : (getTargetInstFunc = getTargetInstForClickEvent);\n        if (\n          getTargetInstFunc &&\n          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))\n        ) {\n          createAndAccumulateChangeEvent(\n            dispatchQueue,\n            getTargetInstFunc,\n            nativeEvent,\n            nativeEventTarget\n          );\n          break a;\n        }\n        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);\n        "focusout" === domEventName &&\n          targetInst &&\n          "number" === reactName.type &&\n          null != targetInst.memoizedProps.value &&\n          setDefaultValue(reactName, "number", reactName.value);\n      }\n      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;\n      switch (domEventName) {\n        case "focusin":\n          if (\n            isTextInputElement(handleEventFunc) ||\n            "true" === handleEventFunc.contentEditable\n          )\n            (activeElement = handleEventFunc),\n              (activeElementInst = targetInst),\n              (lastSelection = null);\n          break;\n        case "focusout":\n          lastSelection = activeElementInst = activeElement = null;\n          break;\n        case "mousedown":\n          mouseDown = !0;\n          break;\n        case "contextmenu":\n        case "mouseup":\n        case "dragend":\n          mouseDown = !1;\n          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n          break;\n        case "selectionchange":\n          if (skipSelectionChangeEvent) break;\n        case "keydown":\n        case "keyup":\n          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n      }\n      var fallbackData;\n      if (canUseCompositionEvent)\n        b: {\n          switch (domEventName) {\n            case "compositionstart":\n              var eventType = "onCompositionStart";\n              break b;\n            case "compositionend":\n              eventType = "onCompositionEnd";\n              break b;\n            case "compositionupdate":\n              eventType = "onCompositionUpdate";\n              break b;\n          }\n          eventType = void 0;\n        }\n      else\n        isComposing\n          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&\n            (eventType = "onCompositionEnd")\n          : "keydown" === domEventName &&\n            229 === nativeEvent.keyCode &&\n            (eventType = "onCompositionStart");\n      eventType &&\n        (useFallbackCompositionData &&\n          "ko" !== nativeEvent.locale &&\n          (isComposing || "onCompositionStart" !== eventType\n            ? "onCompositionEnd" === eventType &&\n              isComposing &&\n              (fallbackData = getData())\n            : ((root = nativeEventTarget),\n              (startText = "value" in root ? root.value : root.textContent),\n              (isComposing = !0))),\n        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),\n        0 < handleEventFunc.length &&\n          ((eventType = new SyntheticCompositionEvent(\n            eventType,\n            domEventName,\n            null,\n            nativeEvent,\n            nativeEventTarget\n          )),\n          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),\n          fallbackData\n            ? (eventType.data = fallbackData)\n            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),\n              null !== fallbackData && (eventType.data = fallbackData))));\n      if (\n        (fallbackData = canUseTextInputEvent\n          ? getNativeBeforeInputChars(domEventName, nativeEvent)\n          : getFallbackBeforeInputChars(domEventName, nativeEvent))\n      )\n        (eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput")),\n          0 < eventType.length &&\n            ((handleEventFunc = new SyntheticCompositionEvent(\n              "onBeforeInput",\n              "beforeinput",\n              null,\n              nativeEvent,\n              nativeEventTarget\n            )),\n            dispatchQueue.push({\n              event: handleEventFunc,\n              listeners: eventType\n            }),\n            (handleEventFunc.data = fallbackData));\n      extractEvents$1(\n        dispatchQueue,\n        domEventName,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n    }\n    processDispatchQueue(dispatchQueue, eventSystemFlags);\n  });\n}\nfunction createDispatchListener(instance, listener, currentTarget) {\n  return {\n    instance: instance,\n    listener: listener,\n    currentTarget: currentTarget\n  };\n}\nfunction accumulateTwoPhaseListeners(targetFiber, reactName) {\n  for (\n    var captureName = reactName + "Capture", listeners = [];\n    null !== targetFiber;\n\n  ) {\n    var _instance2 = targetFiber,\n      stateNode = _instance2.stateNode;\n    _instance2 = _instance2.tag;\n    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||\n      null === stateNode ||\n      ((_instance2 = getListener(targetFiber, captureName)),\n      null != _instance2 &&\n        listeners.unshift(\n          createDispatchListener(targetFiber, _instance2, stateNode)\n        ),\n      (_instance2 = getListener(targetFiber, reactName)),\n      null != _instance2 &&\n        listeners.push(\n          createDispatchListener(targetFiber, _instance2, stateNode)\n        ));\n    targetFiber = targetFiber.return;\n  }\n  return listeners;\n}\nfunction getParent(inst) {\n  if (null === inst) return null;\n  do inst = inst.return;\n  while (inst && 5 !== inst.tag && 27 !== inst.tag);\n  return inst ? inst : null;\n}\nfunction accumulateEnterLeaveListenersForEvent(\n  dispatchQueue,\n  event,\n  target,\n  common,\n  inCapturePhase\n) {\n  for (\n    var registrationName = event._reactName, listeners = [];\n    null !== target && target !== common;\n\n  ) {\n    var _instance3 = target,\n      alternate = _instance3.alternate,\n      stateNode = _instance3.stateNode;\n    _instance3 = _instance3.tag;\n    if (null !== alternate && alternate === common) break;\n    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||\n      null === stateNode ||\n      ((alternate = stateNode),\n      inCapturePhase\n        ? ((stateNode = getListener(target, registrationName)),\n          null != stateNode &&\n            listeners.unshift(\n              createDispatchListener(target, stateNode, alternate)\n            ))\n        : inCapturePhase ||\n          ((stateNode = getListener(target, registrationName)),\n          null != stateNode &&\n            listeners.push(\n              createDispatchListener(target, stateNode, alternate)\n            )));\n    target = target.return;\n  }\n  0 !== listeners.length &&\n    dispatchQueue.push({ event: event, listeners: listeners });\n}\nvar NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g,\n  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\nfunction normalizeMarkupForTextOrAttribute(markup) {\n  return ("string" === typeof markup ? markup : "" + markup)\n    .replace(NORMALIZE_NEWLINES_REGEX, "\\n")\n    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");\n}\nfunction checkForUnmatchedText(serverText, clientText) {\n  clientText = normalizeMarkupForTextOrAttribute(clientText);\n  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;\n}\nfunction noop$1() {}\nfunction setProp(domElement, tag, key, value, props, prevValue) {\n  switch (key) {\n    case "children":\n      "string" === typeof value\n        ? "body" === tag ||\n          ("textarea" === tag && "" === value) ||\n          setTextContent(domElement, value)\n        : ("number" === typeof value || "bigint" === typeof value) &&\n          "body" !== tag &&\n          setTextContent(domElement, "" + value);\n      break;\n    case "className":\n      setValueForKnownAttribute(domElement, "class", value);\n      break;\n    case "tabIndex":\n      setValueForKnownAttribute(domElement, "tabindex", value);\n      break;\n    case "dir":\n    case "role":\n    case "viewBox":\n    case "width":\n    case "height":\n      setValueForKnownAttribute(domElement, key, value);\n      break;\n    case "style":\n      setValueForStyles(domElement, value, prevValue);\n      break;\n    case "data":\n      if ("object" !== tag) {\n        setValueForKnownAttribute(domElement, "data", value);\n        break;\n      }\n    case "src":\n    case "href":\n      if ("" === value && ("a" !== tag || "href" !== key)) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      if (\n        null == value ||\n        "function" === typeof value ||\n        "symbol" === typeof value ||\n        "boolean" === typeof value\n      ) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      value = sanitizeURL("" + value);\n      domElement.setAttribute(key, value);\n      break;\n    case "action":\n    case "formAction":\n      if ("function" === typeof value) {\n        domElement.setAttribute(\n          key,\n          "javascript:throw new Error(\'A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\\\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().\')"\n        );\n        break;\n      } else\n        "function" === typeof prevValue &&\n          ("formAction" === key\n            ? ("input" !== tag &&\n                setProp(domElement, tag, "name", props.name, props, null),\n              setProp(\n                domElement,\n                tag,\n                "formEncType",\n                props.formEncType,\n                props,\n                null\n              ),\n              setProp(\n                domElement,\n                tag,\n                "formMethod",\n                props.formMethod,\n                props,\n                null\n              ),\n              setProp(\n                domElement,\n                tag,\n                "formTarget",\n                props.formTarget,\n                props,\n                null\n              ))\n            : (setProp(domElement, tag, "encType", props.encType, props, null),\n              setProp(domElement, tag, "method", props.method, props, null),\n              setProp(domElement, tag, "target", props.target, props, null)));\n      if (\n        null == value ||\n        "symbol" === typeof value ||\n        "boolean" === typeof value\n      ) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      value = sanitizeURL("" + value);\n      domElement.setAttribute(key, value);\n      break;\n    case "onClick":\n      null != value && (domElement.onclick = noop$1);\n      break;\n    case "onScroll":\n      null != value && listenToNonDelegatedEvent("scroll", domElement);\n      break;\n    case "onScrollEnd":\n      null != value && listenToNonDelegatedEvent("scrollend", domElement);\n      break;\n    case "dangerouslySetInnerHTML":\n      if (null != value) {\n        if ("object" !== typeof value || !("__html" in value))\n          throw Error(formatProdErrorMessage(61));\n        key = value.__html;\n        if (null != key) {\n          if (null != props.children) throw Error(formatProdErrorMessage(60));\n          domElement.innerHTML = key;\n        }\n      }\n      break;\n    case "multiple":\n      domElement.multiple =\n        value && "function" !== typeof value && "symbol" !== typeof value;\n      break;\n    case "muted":\n      domElement.muted =\n        value && "function" !== typeof value && "symbol" !== typeof value;\n      break;\n    case "suppressContentEditableWarning":\n    case "suppressHydrationWarning":\n    case "defaultValue":\n    case "defaultChecked":\n    case "innerHTML":\n    case "ref":\n      break;\n    case "autoFocus":\n      break;\n    case "xlinkHref":\n      if (\n        null == value ||\n        "function" === typeof value ||\n        "boolean" === typeof value ||\n        "symbol" === typeof value\n      ) {\n        domElement.removeAttribute("xlink:href");\n        break;\n      }\n      key = sanitizeURL("" + value);\n      domElement.setAttributeNS(\n        "http://www.w3.org/1999/xlink",\n        "xlink:href",\n        key\n      );\n      break;\n    case "contentEditable":\n    case "spellCheck":\n    case "draggable":\n    case "value":\n    case "autoReverse":\n    case "externalResourcesRequired":\n    case "focusable":\n    case "preserveAlpha":\n      null != value && "function" !== typeof value && "symbol" !== typeof value\n        ? domElement.setAttribute(key, "" + value)\n        : domElement.removeAttribute(key);\n      break;\n    case "inert":\n    case "allowFullScreen":\n    case "async":\n    case "autoPlay":\n    case "controls":\n    case "default":\n    case "defer":\n    case "disabled":\n    case "disablePictureInPicture":\n    case "disableRemotePlayback":\n    case "formNoValidate":\n    case "hidden":\n    case "loop":\n    case "noModule":\n    case "noValidate":\n    case "open":\n    case "playsInline":\n    case "readOnly":\n    case "required":\n    case "reversed":\n    case "scoped":\n    case "seamless":\n    case "itemScope":\n      value && "function" !== typeof value && "symbol" !== typeof value\n        ? domElement.setAttribute(key, "")\n        : domElement.removeAttribute(key);\n      break;\n    case "capture":\n    case "download":\n      !0 === value\n        ? domElement.setAttribute(key, "")\n        : !1 !== value &&\n            null != value &&\n            "function" !== typeof value &&\n            "symbol" !== typeof value\n          ? domElement.setAttribute(key, value)\n          : domElement.removeAttribute(key);\n      break;\n    case "cols":\n    case "rows":\n    case "size":\n    case "span":\n      null != value &&\n      "function" !== typeof value &&\n      "symbol" !== typeof value &&\n      !isNaN(value) &&\n      1 <= value\n        ? domElement.setAttribute(key, value)\n        : domElement.removeAttribute(key);\n      break;\n    case "rowSpan":\n    case "start":\n      null == value ||\n      "function" === typeof value ||\n      "symbol" === typeof value ||\n      isNaN(value)\n        ? domElement.removeAttribute(key)\n        : domElement.setAttribute(key, value);\n      break;\n    case "popover":\n      listenToNonDelegatedEvent("beforetoggle", domElement);\n      listenToNonDelegatedEvent("toggle", domElement);\n      setValueForAttribute(domElement, "popover", value);\n      break;\n    case "xlinkActuate":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:actuate",\n        value\n      );\n      break;\n    case "xlinkArcrole":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:arcrole",\n        value\n      );\n      break;\n    case "xlinkRole":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:role",\n        value\n      );\n      break;\n    case "xlinkShow":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:show",\n        value\n      );\n      break;\n    case "xlinkTitle":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:title",\n        value\n      );\n      break;\n    case "xlinkType":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/1999/xlink",\n        "xlink:type",\n        value\n      );\n      break;\n    case "xmlBase":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/XML/1998/namespace",\n        "xml:base",\n        value\n      );\n      break;\n    case "xmlLang":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/XML/1998/namespace",\n        "xml:lang",\n        value\n      );\n      break;\n    case "xmlSpace":\n      setValueForNamespacedAttribute(\n        domElement,\n        "http://www.w3.org/XML/1998/namespace",\n        "xml:space",\n        value\n      );\n      break;\n    case "is":\n      setValueForAttribute(domElement, "is", value);\n      break;\n    case "innerText":\n    case "textContent":\n      break;\n    default:\n      if (\n        !(2 < key.length) ||\n        ("o" !== key[0] && "O" !== key[0]) ||\n        ("n" !== key[1] && "N" !== key[1])\n      )\n        (key = aliases.get(key) || key),\n          setValueForAttribute(domElement, key, value);\n  }\n}\nfunction setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {\n  switch (key) {\n    case "style":\n      setValueForStyles(domElement, value, prevValue);\n      break;\n    case "dangerouslySetInnerHTML":\n      if (null != value) {\n        if ("object" !== typeof value || !("__html" in value))\n          throw Error(formatProdErrorMessage(61));\n        key = value.__html;\n        if (null != key) {\n          if (null != props.children) throw Error(formatProdErrorMessage(60));\n          domElement.innerHTML = key;\n        }\n      }\n      break;\n    case "children":\n      "string" === typeof value\n        ? setTextContent(domElement, value)\n        : ("number" === typeof value || "bigint" === typeof value) &&\n          setTextContent(domElement, "" + value);\n      break;\n    case "onScroll":\n      null != value && listenToNonDelegatedEvent("scroll", domElement);\n      break;\n    case "onScrollEnd":\n      null != value && listenToNonDelegatedEvent("scrollend", domElement);\n      break;\n    case "onClick":\n      null != value && (domElement.onclick = noop$1);\n      break;\n    case "suppressContentEditableWarning":\n    case "suppressHydrationWarning":\n    case "innerHTML":\n    case "ref":\n      break;\n    case "innerText":\n    case "textContent":\n      break;\n    default:\n      if (!registrationNameDependencies.hasOwnProperty(key))\n        a: {\n          if (\n            "o" === key[0] &&\n            "n" === key[1] &&\n            ((props = key.endsWith("Capture")),\n            (tag = key.slice(2, props ? key.length - 7 : void 0)),\n            (prevValue = domElement[internalPropsKey] || null),\n            (prevValue = null != prevValue ? prevValue[key] : null),\n            "function" === typeof prevValue &&\n              domElement.removeEventListener(tag, prevValue, props),\n            "function" === typeof value)\n          ) {\n            "function" !== typeof prevValue &&\n              null !== prevValue &&\n              (key in domElement\n                ? (domElement[key] = null)\n                : domElement.hasAttribute(key) &&\n                  domElement.removeAttribute(key));\n            domElement.addEventListener(tag, value, props);\n            break a;\n          }\n          key in domElement\n            ? (domElement[key] = value)\n            : !0 === value\n              ? domElement.setAttribute(key, "")\n              : setValueForAttribute(domElement, key, value);\n        }\n  }\n}\nfunction setInitialProperties(domElement, tag, props) {\n  switch (tag) {\n    case "div":\n    case "span":\n    case "svg":\n    case "path":\n    case "a":\n    case "g":\n    case "p":\n    case "li":\n      break;\n    case "img":\n      listenToNonDelegatedEvent("error", domElement);\n      listenToNonDelegatedEvent("load", domElement);\n      var hasSrc = !1,\n        hasSrcSet = !1,\n        propKey;\n      for (propKey in props)\n        if (props.hasOwnProperty(propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case "src":\n                hasSrc = !0;\n                break;\n              case "srcSet":\n                hasSrcSet = !0;\n                break;\n              case "children":\n              case "dangerouslySetInnerHTML":\n                throw Error(formatProdErrorMessage(137, tag));\n              default:\n                setProp(domElement, tag, propKey, propValue, props, null);\n            }\n        }\n      hasSrcSet &&\n        setProp(domElement, tag, "srcSet", props.srcSet, props, null);\n      hasSrc && setProp(domElement, tag, "src", props.src, props, null);\n      return;\n    case "input":\n      listenToNonDelegatedEvent("invalid", domElement);\n      var defaultValue = (propKey = propValue = hasSrcSet = null),\n        checked = null,\n        defaultChecked = null;\n      for (hasSrc in props)\n        if (props.hasOwnProperty(hasSrc)) {\n          var propValue$186 = props[hasSrc];\n          if (null != propValue$186)\n            switch (hasSrc) {\n              case "name":\n                hasSrcSet = propValue$186;\n                break;\n              case "type":\n                propValue = propValue$186;\n                break;\n              case "checked":\n                checked = propValue$186;\n                break;\n              case "defaultChecked":\n                defaultChecked = propValue$186;\n                break;\n              case "value":\n                propKey = propValue$186;\n                break;\n              case "defaultValue":\n                defaultValue = propValue$186;\n                break;\n              case "children":\n              case "dangerouslySetInnerHTML":\n                if (null != propValue$186)\n                  throw Error(formatProdErrorMessage(137, tag));\n                break;\n              default:\n                setProp(domElement, tag, hasSrc, propValue$186, props, null);\n            }\n        }\n      initInput(\n        domElement,\n        propKey,\n        defaultValue,\n        checked,\n        defaultChecked,\n        propValue,\n        hasSrcSet,\n        !1\n      );\n      track(domElement);\n      return;\n    case "select":\n      listenToNonDelegatedEvent("invalid", domElement);\n      hasSrc = propValue = propKey = null;\n      for (hasSrcSet in props)\n        if (\n          props.hasOwnProperty(hasSrcSet) &&\n          ((defaultValue = props[hasSrcSet]), null != defaultValue)\n        )\n          switch (hasSrcSet) {\n            case "value":\n              propKey = defaultValue;\n              break;\n            case "defaultValue":\n              propValue = defaultValue;\n              break;\n            case "multiple":\n              hasSrc = defaultValue;\n            default:\n              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);\n          }\n      tag = propKey;\n      props = propValue;\n      domElement.multiple = !!hasSrc;\n      null != tag\n        ? updateOptions(domElement, !!hasSrc, tag, !1)\n        : null != props && updateOptions(domElement, !!hasSrc, props, !0);\n      return;\n    case "textarea":\n      listenToNonDelegatedEvent("invalid", domElement);\n      propKey = hasSrcSet = hasSrc = null;\n      for (propValue in props)\n        if (\n          props.hasOwnProperty(propValue) &&\n          ((defaultValue = props[propValue]), null != defaultValue)\n        )\n          switch (propValue) {\n            case "value":\n              hasSrc = defaultValue;\n              break;\n            case "defaultValue":\n              hasSrcSet = defaultValue;\n              break;\n            case "children":\n              propKey = defaultValue;\n              break;\n            case "dangerouslySetInnerHTML":\n              if (null != defaultValue) throw Error(formatProdErrorMessage(91));\n              break;\n            default:\n              setProp(domElement, tag, propValue, defaultValue, props, null);\n          }\n      initTextarea(domElement, hasSrc, hasSrcSet, propKey);\n      track(domElement);\n      return;\n    case "option":\n      for (checked in props)\n        if (\n          props.hasOwnProperty(checked) &&\n          ((hasSrc = props[checked]), null != hasSrc)\n        )\n          switch (checked) {\n            case "selected":\n              domElement.selected =\n                hasSrc &&\n                "function" !== typeof hasSrc &&\n                "symbol" !== typeof hasSrc;\n              break;\n            default:\n              setProp(domElement, tag, checked, hasSrc, props, null);\n          }\n      return;\n    case "dialog":\n      listenToNonDelegatedEvent("cancel", domElement);\n      listenToNonDelegatedEvent("close", domElement);\n      break;\n    case "iframe":\n    case "object":\n      listenToNonDelegatedEvent("load", domElement);\n      break;\n    case "video":\n    case "audio":\n      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)\n        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);\n      break;\n    case "image":\n      listenToNonDelegatedEvent("error", domElement);\n      listenToNonDelegatedEvent("load", domElement);\n      break;\n    case "details":\n      listenToNonDelegatedEvent("toggle", domElement);\n      break;\n    case "embed":\n    case "source":\n    case "link":\n      listenToNonDelegatedEvent("error", domElement),\n        listenToNonDelegatedEvent("load", domElement);\n    case "area":\n    case "base":\n    case "br":\n    case "col":\n    case "hr":\n    case "keygen":\n    case "meta":\n    case "param":\n    case "track":\n    case "wbr":\n    case "menuitem":\n      for (defaultChecked in props)\n        if (\n          props.hasOwnProperty(defaultChecked) &&\n          ((hasSrc = props[defaultChecked]), null != hasSrc)\n        )\n          switch (defaultChecked) {\n            case "children":\n            case "dangerouslySetInnerHTML":\n              throw Error(formatProdErrorMessage(137, tag));\n            default:\n              setProp(domElement, tag, defaultChecked, hasSrc, props, null);\n          }\n      return;\n    default:\n      if (isCustomElement(tag)) {\n        for (propValue$186 in props)\n          props.hasOwnProperty(propValue$186) &&\n            ((hasSrc = props[propValue$186]),\n            void 0 !== hasSrc &&\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                propValue$186,\n                hasSrc,\n                props,\n                void 0\n              ));\n        return;\n      }\n  }\n  for (defaultValue in props)\n    props.hasOwnProperty(defaultValue) &&\n      ((hasSrc = props[defaultValue]),\n      null != hasSrc &&\n        setProp(domElement, tag, defaultValue, hasSrc, props, null));\n}\nfunction updateProperties(domElement, tag, lastProps, nextProps) {\n  switch (tag) {\n    case "div":\n    case "span":\n    case "svg":\n    case "path":\n    case "a":\n    case "g":\n    case "p":\n    case "li":\n      break;\n    case "input":\n      var name = null,\n        type = null,\n        value = null,\n        defaultValue = null,\n        lastDefaultValue = null,\n        checked = null,\n        defaultChecked = null;\n      for (propKey in lastProps) {\n        var lastProp = lastProps[propKey];\n        if (lastProps.hasOwnProperty(propKey) && null != lastProp)\n          switch (propKey) {\n            case "checked":\n              break;\n            case "value":\n              break;\n            case "defaultValue":\n              lastDefaultValue = lastProp;\n            default:\n              nextProps.hasOwnProperty(propKey) ||\n                setProp(domElement, tag, propKey, null, nextProps, lastProp);\n          }\n      }\n      for (var propKey$203 in nextProps) {\n        var propKey = nextProps[propKey$203];\n        lastProp = lastProps[propKey$203];\n        if (\n          nextProps.hasOwnProperty(propKey$203) &&\n          (null != propKey || null != lastProp)\n        )\n          switch (propKey$203) {\n            case "type":\n              type = propKey;\n              break;\n            case "name":\n              name = propKey;\n              break;\n            case "checked":\n              checked = propKey;\n              break;\n            case "defaultChecked":\n              defaultChecked = propKey;\n              break;\n            case "value":\n              value = propKey;\n              break;\n            case "defaultValue":\n              defaultValue = propKey;\n              break;\n            case "children":\n            case "dangerouslySetInnerHTML":\n              if (null != propKey)\n                throw Error(formatProdErrorMessage(137, tag));\n              break;\n            default:\n              propKey !== lastProp &&\n                setProp(\n                  domElement,\n                  tag,\n                  propKey$203,\n                  propKey,\n                  nextProps,\n                  lastProp\n                );\n          }\n      }\n      updateInput(\n        domElement,\n        value,\n        defaultValue,\n        lastDefaultValue,\n        checked,\n        defaultChecked,\n        type,\n        name\n      );\n      return;\n    case "select":\n      propKey = value = defaultValue = propKey$203 = null;\n      for (type in lastProps)\n        if (\n          ((lastDefaultValue = lastProps[type]),\n          lastProps.hasOwnProperty(type) && null != lastDefaultValue)\n        )\n          switch (type) {\n            case "value":\n              break;\n            case "multiple":\n              propKey = lastDefaultValue;\n            default:\n              nextProps.hasOwnProperty(type) ||\n                setProp(\n                  domElement,\n                  tag,\n                  type,\n                  null,\n                  nextProps,\n                  lastDefaultValue\n                );\n          }\n      for (name in nextProps)\n        if (\n          ((type = nextProps[name]),\n          (lastDefaultValue = lastProps[name]),\n          nextProps.hasOwnProperty(name) &&\n            (null != type || null != lastDefaultValue))\n        )\n          switch (name) {\n            case "value":\n              propKey$203 = type;\n              break;\n            case "defaultValue":\n              defaultValue = type;\n              break;\n            case "multiple":\n              value = type;\n            default:\n              type !== lastDefaultValue &&\n                setProp(\n                  domElement,\n                  tag,\n                  name,\n                  type,\n                  nextProps,\n                  lastDefaultValue\n                );\n          }\n      tag = defaultValue;\n      lastProps = value;\n      nextProps = propKey;\n      null != propKey$203\n        ? updateOptions(domElement, !!lastProps, propKey$203, !1)\n        : !!nextProps !== !!lastProps &&\n          (null != tag\n            ? updateOptions(domElement, !!lastProps, tag, !0)\n            : updateOptions(domElement, !!lastProps, lastProps ? [] : "", !1));\n      return;\n    case "textarea":\n      propKey = propKey$203 = null;\n      for (defaultValue in lastProps)\n        if (\n          ((name = lastProps[defaultValue]),\n          lastProps.hasOwnProperty(defaultValue) &&\n            null != name &&\n            !nextProps.hasOwnProperty(defaultValue))\n        )\n          switch (defaultValue) {\n            case "value":\n              break;\n            case "children":\n              break;\n            default:\n              setProp(domElement, tag, defaultValue, null, nextProps, name);\n          }\n      for (value in nextProps)\n        if (\n          ((name = nextProps[value]),\n          (type = lastProps[value]),\n          nextProps.hasOwnProperty(value) && (null != name || null != type))\n        )\n          switch (value) {\n            case "value":\n              propKey$203 = name;\n              break;\n            case "defaultValue":\n              propKey = name;\n              break;\n            case "children":\n              break;\n            case "dangerouslySetInnerHTML":\n              if (null != name) throw Error(formatProdErrorMessage(91));\n              break;\n            default:\n              name !== type &&\n                setProp(domElement, tag, value, name, nextProps, type);\n          }\n      updateTextarea(domElement, propKey$203, propKey);\n      return;\n    case "option":\n      for (var propKey$219 in lastProps)\n        if (\n          ((propKey$203 = lastProps[propKey$219]),\n          lastProps.hasOwnProperty(propKey$219) &&\n            null != propKey$203 &&\n            !nextProps.hasOwnProperty(propKey$219))\n        )\n          switch (propKey$219) {\n            case "selected":\n              domElement.selected = !1;\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                propKey$219,\n                null,\n                nextProps,\n                propKey$203\n              );\n          }\n      for (lastDefaultValue in nextProps)\n        if (\n          ((propKey$203 = nextProps[lastDefaultValue]),\n          (propKey = lastProps[lastDefaultValue]),\n          nextProps.hasOwnProperty(lastDefaultValue) &&\n            propKey$203 !== propKey &&\n            (null != propKey$203 || null != propKey))\n        )\n          switch (lastDefaultValue) {\n            case "selected":\n              domElement.selected =\n                propKey$203 &&\n                "function" !== typeof propKey$203 &&\n                "symbol" !== typeof propKey$203;\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                lastDefaultValue,\n                propKey$203,\n                nextProps,\n                propKey\n              );\n          }\n      return;\n    case "img":\n    case "link":\n    case "area":\n    case "base":\n    case "br":\n    case "col":\n    case "embed":\n    case "hr":\n    case "keygen":\n    case "meta":\n    case "param":\n    case "source":\n    case "track":\n    case "wbr":\n    case "menuitem":\n      for (var propKey$224 in lastProps)\n        (propKey$203 = lastProps[propKey$224]),\n          lastProps.hasOwnProperty(propKey$224) &&\n            null != propKey$203 &&\n            !nextProps.hasOwnProperty(propKey$224) &&\n            setProp(domElement, tag, propKey$224, null, nextProps, propKey$203);\n      for (checked in nextProps)\n        if (\n          ((propKey$203 = nextProps[checked]),\n          (propKey = lastProps[checked]),\n          nextProps.hasOwnProperty(checked) &&\n            propKey$203 !== propKey &&\n            (null != propKey$203 || null != propKey))\n        )\n          switch (checked) {\n            case "children":\n            case "dangerouslySetInnerHTML":\n              if (null != propKey$203)\n                throw Error(formatProdErrorMessage(137, tag));\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                checked,\n                propKey$203,\n                nextProps,\n                propKey\n              );\n          }\n      return;\n    default:\n      if (isCustomElement(tag)) {\n        for (var propKey$229 in lastProps)\n          (propKey$203 = lastProps[propKey$229]),\n            lastProps.hasOwnProperty(propKey$229) &&\n              void 0 !== propKey$203 &&\n              !nextProps.hasOwnProperty(propKey$229) &&\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                propKey$229,\n                void 0,\n                nextProps,\n                propKey$203\n              );\n        for (defaultChecked in nextProps)\n          (propKey$203 = nextProps[defaultChecked]),\n            (propKey = lastProps[defaultChecked]),\n            !nextProps.hasOwnProperty(defaultChecked) ||\n              propKey$203 === propKey ||\n              (void 0 === propKey$203 && void 0 === propKey) ||\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                defaultChecked,\n                propKey$203,\n                nextProps,\n                propKey\n              );\n        return;\n      }\n  }\n  for (var propKey$234 in lastProps)\n    (propKey$203 = lastProps[propKey$234]),\n      lastProps.hasOwnProperty(propKey$234) &&\n        null != propKey$203 &&\n        !nextProps.hasOwnProperty(propKey$234) &&\n        setProp(domElement, tag, propKey$234, null, nextProps, propKey$203);\n  for (lastProp in nextProps)\n    (propKey$203 = nextProps[lastProp]),\n      (propKey = lastProps[lastProp]),\n      !nextProps.hasOwnProperty(lastProp) ||\n        propKey$203 === propKey ||\n        (null == propKey$203 && null == propKey) ||\n        setProp(domElement, tag, lastProp, propKey$203, nextProps, propKey);\n}\nvar eventsEnabled = null,\n  selectionInformation = null;\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return 9 === rootContainerElement.nodeType\n    ? rootContainerElement\n    : rootContainerElement.ownerDocument;\n}\nfunction getOwnHostContext(namespaceURI) {\n  switch (namespaceURI) {\n    case "http://www.w3.org/2000/svg":\n      return 1;\n    case "http://www.w3.org/1998/Math/MathML":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getChildHostContextProd(parentNamespace, type) {\n  if (0 === parentNamespace)\n    switch (type) {\n      case "svg":\n        return 1;\n      case "math":\n        return 2;\n      default:\n        return 0;\n    }\n  return 1 === parentNamespace && "foreignObject" === type\n    ? 0\n    : parentNamespace;\n}\nfunction shouldSetTextContent(type, props) {\n  return (\n    "textarea" === type ||\n    "noscript" === type ||\n    "string" === typeof props.children ||\n    "number" === typeof props.children ||\n    "bigint" === typeof props.children ||\n    ("object" === typeof props.dangerouslySetInnerHTML &&\n      null !== props.dangerouslySetInnerHTML &&\n      null != props.dangerouslySetInnerHTML.__html)\n  );\n}\nvar currentPopstateTransitionEvent = null;\nfunction shouldAttemptEagerTransition() {\n  var event = window.event;\n  if (event && "popstate" === event.type) {\n    if (event === currentPopstateTransitionEvent) return !1;\n    currentPopstateTransitionEvent = event;\n    return !0;\n  }\n  currentPopstateTransitionEvent = null;\n  return !1;\n}\nvar scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0,\n  cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0,\n  localPromise = "function" === typeof Promise ? Promise : void 0,\n  scheduleMicrotask =\n    "function" === typeof queueMicrotask\n      ? queueMicrotask\n      : "undefined" !== typeof localPromise\n        ? function (callback) {\n            return localPromise\n              .resolve(null)\n              .then(callback)\n              .catch(handleErrorInNextTick);\n          }\n        : scheduleTimeout;\nfunction handleErrorInNextTick(error) {\n  setTimeout(function () {\n    throw error;\n  });\n}\nfunction clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  var node = suspenseInstance,\n    depth = 0;\n  do {\n    var nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && 8 === nextNode.nodeType)\n      if (((node = nextNode.data), "/$" === node)) {\n        if (0 === depth) {\n          parentInstance.removeChild(nextNode);\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        }\n        depth--;\n      } else ("$" !== node && "$?" !== node && "$!" !== node) || depth++;\n    node = nextNode;\n  } while (node);\n  retryIfBlockedOn(suspenseInstance);\n}\nfunction clearContainerSparingly(container) {\n  var nextNode = container.firstChild;\n  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);\n  for (; nextNode; ) {\n    var node = nextNode;\n    nextNode = nextNode.nextSibling;\n    switch (node.nodeName) {\n      case "HTML":\n      case "HEAD":\n      case "BODY":\n        clearContainerSparingly(node);\n        detachDeletedInstance(node);\n        continue;\n      case "SCRIPT":\n      case "STYLE":\n        continue;\n      case "LINK":\n        if ("stylesheet" === node.rel.toLowerCase()) continue;\n    }\n    container.removeChild(node);\n  }\n}\nfunction canHydrateInstance(instance, type, props, inRootOrSingleton) {\n  for (; 1 === instance.nodeType; ) {\n    var anyProps = props;\n    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {\n      if (\n        !inRootOrSingleton &&\n        ("INPUT" !== instance.nodeName || "hidden" !== instance.type)\n      )\n        break;\n    } else if (!inRootOrSingleton)\n      if ("input" === type && "hidden" === instance.type) {\n        var name = null == anyProps.name ? null : "" + anyProps.name;\n        if (\n          "hidden" === anyProps.type &&\n          instance.getAttribute("name") === name\n        )\n          return instance;\n      } else return instance;\n    else if (!instance[internalHoistableMarker])\n      switch (type) {\n        case "meta":\n          if (!instance.hasAttribute("itemprop")) break;\n          return instance;\n        case "link":\n          name = instance.getAttribute("rel");\n          if ("stylesheet" === name && instance.hasAttribute("data-precedence"))\n            break;\n          else if (\n            name !== anyProps.rel ||\n            instance.getAttribute("href") !==\n              (null == anyProps.href ? null : anyProps.href) ||\n            instance.getAttribute("crossorigin") !==\n              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||\n            instance.getAttribute("title") !==\n              (null == anyProps.title ? null : anyProps.title)\n          )\n            break;\n          return instance;\n        case "style":\n          if (instance.hasAttribute("data-precedence")) break;\n          return instance;\n        case "script":\n          name = instance.getAttribute("src");\n          if (\n            (name !== (null == anyProps.src ? null : anyProps.src) ||\n              instance.getAttribute("type") !==\n                (null == anyProps.type ? null : anyProps.type) ||\n              instance.getAttribute("crossorigin") !==\n                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&\n            name &&\n            instance.hasAttribute("async") &&\n            !instance.hasAttribute("itemprop")\n          )\n            break;\n          return instance;\n        default:\n          return instance;\n      }\n    instance = getNextHydratable(instance.nextSibling);\n    if (null === instance) break;\n  }\n  return null;\n}\nfunction canHydrateTextInstance(instance, text, inRootOrSingleton) {\n  if ("" === text) return null;\n  for (; 3 !== instance.nodeType; ) {\n    if (\n      (1 !== instance.nodeType ||\n        "INPUT" !== instance.nodeName ||\n        "hidden" !== instance.type) &&\n      !inRootOrSingleton\n    )\n      return null;\n    instance = getNextHydratable(instance.nextSibling);\n    if (null === instance) return null;\n  }\n  return instance;\n}\nfunction getNextHydratable(node) {\n  for (; null != node; node = node.nextSibling) {\n    var nodeType = node.nodeType;\n    if (1 === nodeType || 3 === nodeType) break;\n    if (8 === nodeType) {\n      nodeType = node.data;\n      if (\n        "$" === nodeType ||\n        "$!" === nodeType ||\n        "$?" === nodeType ||\n        "F!" === nodeType ||\n        "F" === nodeType\n      )\n        break;\n      if ("/$" === nodeType) return null;\n    }\n  }\n  return node;\n}\nfunction getParentSuspenseInstance(targetInstance) {\n  targetInstance = targetInstance.previousSibling;\n  for (var depth = 0; targetInstance; ) {\n    if (8 === targetInstance.nodeType) {\n      var data = targetInstance.data;\n      if ("$" === data || "$!" === data || "$?" === data) {\n        if (0 === depth) return targetInstance;\n        depth--;\n      } else "/$" === data && depth++;\n    }\n    targetInstance = targetInstance.previousSibling;\n  }\n  return null;\n}\nfunction resolveSingletonInstance(type, props, rootContainerInstance) {\n  props = getOwnerDocumentFromRootContainer(rootContainerInstance);\n  switch (type) {\n    case "html":\n      type = props.documentElement;\n      if (!type) throw Error(formatProdErrorMessage(452));\n      return type;\n    case "head":\n      type = props.head;\n      if (!type) throw Error(formatProdErrorMessage(453));\n      return type;\n    case "body":\n      type = props.body;\n      if (!type) throw Error(formatProdErrorMessage(454));\n      return type;\n    default:\n      throw Error(formatProdErrorMessage(451));\n  }\n}\nvar preloadPropsMap = new Map(),\n  preconnectsSet = new Set();\nfunction getHoistableRoot(container) {\n  return "function" === typeof container.getRootNode\n    ? container.getRootNode()\n    : container.ownerDocument;\n}\nvar previousDispatcher = ReactDOMSharedInternals.d;\nReactDOMSharedInternals.d = {\n  f: flushSyncWork,\n  r: requestFormReset,\n  D: prefetchDNS,\n  C: preconnect,\n  L: preload,\n  m: preloadModule,\n  X: preinitScript,\n  S: preinitStyle,\n  M: preinitModuleScript\n};\nfunction flushSyncWork() {\n  var previousWasRendering = previousDispatcher.f(),\n    wasRendering = flushSyncWork$1();\n  return previousWasRendering || wasRendering;\n}\nfunction requestFormReset(form) {\n  var formInst = getInstanceFromNode(form);\n  null !== formInst && 5 === formInst.tag && "form" === formInst.type\n    ? requestFormReset$1(formInst)\n    : previousDispatcher.r(form);\n}\nvar globalDocument = "undefined" === typeof document ? null : document;\nfunction preconnectAs(rel, href, crossOrigin) {\n  var ownerDocument = globalDocument;\n  if (ownerDocument && "string" === typeof href && href) {\n    var limitedEscapedHref =\n      escapeSelectorAttributeValueInsideDoubleQuotes(href);\n    limitedEscapedHref =\n      \'link[rel="\' + rel + \'"][href="\' + limitedEscapedHref + \'"]\';\n    "string" === typeof crossOrigin &&\n      (limitedEscapedHref += \'[crossorigin="\' + crossOrigin + \'"]\');\n    preconnectsSet.has(limitedEscapedHref) ||\n      (preconnectsSet.add(limitedEscapedHref),\n      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),\n      null === ownerDocument.querySelector(limitedEscapedHref) &&\n        ((href = ownerDocument.createElement("link")),\n        setInitialProperties(href, "link", rel),\n        markNodeAsHoistable(href),\n        ownerDocument.head.appendChild(href)));\n  }\n}\nfunction prefetchDNS(href) {\n  previousDispatcher.D(href);\n  preconnectAs("dns-prefetch", href, null);\n}\nfunction preconnect(href, crossOrigin) {\n  previousDispatcher.C(href, crossOrigin);\n  preconnectAs("preconnect", href, crossOrigin);\n}\nfunction preload(href, as, options) {\n  previousDispatcher.L(href, as, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href && as) {\n    var preloadSelector =\n      \'link[rel="preload"][as="\' +\n      escapeSelectorAttributeValueInsideDoubleQuotes(as) +\n      \'"]\';\n    "image" === as\n      ? options && options.imageSrcSet\n        ? ((preloadSelector +=\n            \'[imagesrcset="\' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(\n              options.imageSrcSet\n            ) +\n            \'"]\'),\n          "string" === typeof options.imageSizes &&\n            (preloadSelector +=\n              \'[imagesizes="\' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                options.imageSizes\n              ) +\n              \'"]\'))\n        : (preloadSelector +=\n            \'[href="\' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n            \'"]\')\n      : (preloadSelector +=\n          \'[href="\' +\n          escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n          \'"]\');\n    var key = preloadSelector;\n    switch (as) {\n      case "style":\n        key = getStyleKey(href);\n        break;\n      case "script":\n        key = getScriptKey(href);\n    }\n    preloadPropsMap.has(key) ||\n      ((href = assign(\n        {\n          rel: "preload",\n          href:\n            "image" === as && options && options.imageSrcSet ? void 0 : href,\n          as: as\n        },\n        options\n      )),\n      preloadPropsMap.set(key, href),\n      null !== ownerDocument.querySelector(preloadSelector) ||\n        ("style" === as &&\n          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||\n        ("script" === as &&\n          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||\n        ((as = ownerDocument.createElement("link")),\n        setInitialProperties(as, "link", href),\n        markNodeAsHoistable(as),\n        ownerDocument.head.appendChild(as)));\n  }\n}\nfunction preloadModule(href, options) {\n  previousDispatcher.m(href, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href) {\n    var as = options && "string" === typeof options.as ? options.as : "script",\n      preloadSelector =\n        \'link[rel="modulepreload"][as="\' +\n        escapeSelectorAttributeValueInsideDoubleQuotes(as) +\n        \'"][href="\' +\n        escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n        \'"]\',\n      key = preloadSelector;\n    switch (as) {\n      case "audioworklet":\n      case "paintworklet":\n      case "serviceworker":\n      case "sharedworker":\n      case "worker":\n      case "script":\n        key = getScriptKey(href);\n    }\n    if (\n      !preloadPropsMap.has(key) &&\n      ((href = assign({ rel: "modulepreload", href: href }, options)),\n      preloadPropsMap.set(key, href),\n      null === ownerDocument.querySelector(preloadSelector))\n    ) {\n      switch (as) {\n        case "audioworklet":\n        case "paintworklet":\n        case "serviceworker":\n        case "sharedworker":\n        case "worker":\n        case "script":\n          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))\n            return;\n      }\n      as = ownerDocument.createElement("link");\n      setInitialProperties(as, "link", href);\n      markNodeAsHoistable(as);\n      ownerDocument.head.appendChild(as);\n    }\n  }\n}\nfunction preinitStyle(href, precedence, options) {\n  previousDispatcher.S(href, precedence, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href) {\n    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,\n      key = getStyleKey(href);\n    precedence = precedence || "default";\n    var resource = styles.get(key);\n    if (!resource) {\n      var state = { loading: 0, preload: null };\n      if (\n        (resource = ownerDocument.querySelector(\n          getStylesheetSelectorFromKey(key)\n        ))\n      )\n        state.loading = 5;\n      else {\n        href = assign(\n          { rel: "stylesheet", href: href, "data-precedence": precedence },\n          options\n        );\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForStylesheet(href, options);\n        var link = (resource = ownerDocument.createElement("link"));\n        markNodeAsHoistable(link);\n        setInitialProperties(link, "link", href);\n        link._p = new Promise(function (resolve, reject) {\n          link.onload = resolve;\n          link.onerror = reject;\n        });\n        link.addEventListener("load", function () {\n          state.loading |= 1;\n        });\n        link.addEventListener("error", function () {\n          state.loading |= 2;\n        });\n        state.loading |= 4;\n        insertStylesheet(resource, precedence, ownerDocument);\n      }\n      resource = {\n        type: "stylesheet",\n        instance: resource,\n        count: 1,\n        state: state\n      };\n      styles.set(key, resource);\n    }\n  }\n}\nfunction preinitScript(src, options) {\n  previousDispatcher.X(src, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && src) {\n    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,\n      key = getScriptKey(src),\n      resource = scripts.get(key);\n    resource ||\n      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),\n      resource ||\n        ((src = assign({ src: src, async: !0 }, options)),\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForScript(src, options),\n        (resource = ownerDocument.createElement("script")),\n        markNodeAsHoistable(resource),\n        setInitialProperties(resource, "link", src),\n        ownerDocument.head.appendChild(resource)),\n      (resource = {\n        type: "script",\n        instance: resource,\n        count: 1,\n        state: null\n      }),\n      scripts.set(key, resource));\n  }\n}\nfunction preinitModuleScript(src, options) {\n  previousDispatcher.M(src, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && src) {\n    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,\n      key = getScriptKey(src),\n      resource = scripts.get(key);\n    resource ||\n      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),\n      resource ||\n        ((src = assign({ src: src, async: !0, type: "module" }, options)),\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForScript(src, options),\n        (resource = ownerDocument.createElement("script")),\n        markNodeAsHoistable(resource),\n        setInitialProperties(resource, "link", src),\n        ownerDocument.head.appendChild(resource)),\n      (resource = {\n        type: "script",\n        instance: resource,\n        count: 1,\n        state: null\n      }),\n      scripts.set(key, resource));\n  }\n}\nfunction getResource(type, currentProps, pendingProps, currentResource) {\n  var JSCompiler_inline_result = (JSCompiler_inline_result =\n    rootInstanceStackCursor.current)\n    ? getHoistableRoot(JSCompiler_inline_result)\n    : null;\n  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));\n  switch (type) {\n    case "meta":\n    case "title":\n      return null;\n    case "style":\n      return "string" === typeof pendingProps.precedence &&\n        "string" === typeof pendingProps.href\n        ? ((currentProps = getStyleKey(pendingProps.href)),\n          (pendingProps = getResourcesFromRoot(\n            JSCompiler_inline_result\n          ).hoistableStyles),\n          (currentResource = pendingProps.get(currentProps)),\n          currentResource ||\n            ((currentResource = {\n              type: "style",\n              instance: null,\n              count: 0,\n              state: null\n            }),\n            pendingProps.set(currentProps, currentResource)),\n          currentResource)\n        : { type: "void", instance: null, count: 0, state: null };\n    case "link":\n      if (\n        "stylesheet" === pendingProps.rel &&\n        "string" === typeof pendingProps.href &&\n        "string" === typeof pendingProps.precedence\n      ) {\n        type = getStyleKey(pendingProps.href);\n        var styles$242 = getResourcesFromRoot(\n            JSCompiler_inline_result\n          ).hoistableStyles,\n          resource$243 = styles$242.get(type);\n        resource$243 ||\n          ((JSCompiler_inline_result =\n            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),\n          (resource$243 = {\n            type: "stylesheet",\n            instance: null,\n            count: 0,\n            state: { loading: 0, preload: null }\n          }),\n          styles$242.set(type, resource$243),\n          (styles$242 = JSCompiler_inline_result.querySelector(\n            getStylesheetSelectorFromKey(type)\n          )) &&\n            !styles$242._p &&\n            ((resource$243.instance = styles$242),\n            (resource$243.state.loading = 5)),\n          preloadPropsMap.has(type) ||\n            ((pendingProps = {\n              rel: "preload",\n              as: "style",\n              href: pendingProps.href,\n              crossOrigin: pendingProps.crossOrigin,\n              integrity: pendingProps.integrity,\n              media: pendingProps.media,\n              hrefLang: pendingProps.hrefLang,\n              referrerPolicy: pendingProps.referrerPolicy\n            }),\n            preloadPropsMap.set(type, pendingProps),\n            styles$242 ||\n              preloadStylesheet(\n                JSCompiler_inline_result,\n                type,\n                pendingProps,\n                resource$243.state\n              )));\n        if (currentProps && null === currentResource)\n          throw Error(formatProdErrorMessage(528, ""));\n        return resource$243;\n      }\n      if (currentProps && null !== currentResource)\n        throw Error(formatProdErrorMessage(529, ""));\n      return null;\n    case "script":\n      return (\n        (currentProps = pendingProps.async),\n        (pendingProps = pendingProps.src),\n        "string" === typeof pendingProps &&\n        currentProps &&\n        "function" !== typeof currentProps &&\n        "symbol" !== typeof currentProps\n          ? ((currentProps = getScriptKey(pendingProps)),\n            (pendingProps = getResourcesFromRoot(\n              JSCompiler_inline_result\n            ).hoistableScripts),\n            (currentResource = pendingProps.get(currentProps)),\n            currentResource ||\n              ((currentResource = {\n                type: "script",\n                instance: null,\n                count: 0,\n                state: null\n              }),\n              pendingProps.set(currentProps, currentResource)),\n            currentResource)\n          : { type: "void", instance: null, count: 0, state: null }\n      );\n    default:\n      throw Error(formatProdErrorMessage(444, type));\n  }\n}\nfunction getStyleKey(href) {\n  return \'href="\' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + \'"\';\n}\nfunction getStylesheetSelectorFromKey(key) {\n  return \'link[rel="stylesheet"][\' + key + "]";\n}\nfunction stylesheetPropsFromRawProps(rawProps) {\n  return assign({}, rawProps, {\n    "data-precedence": rawProps.precedence,\n    precedence: null\n  });\n}\nfunction preloadStylesheet(ownerDocument, key, preloadProps, state) {\n  ownerDocument.querySelector(\'link[rel="preload"][as="style"][\' + key + "]")\n    ? (state.loading = 1)\n    : ((key = ownerDocument.createElement("link")),\n      (state.preload = key),\n      key.addEventListener("load", function () {\n        return (state.loading |= 1);\n      }),\n      key.addEventListener("error", function () {\n        return (state.loading |= 2);\n      }),\n      setInitialProperties(key, "link", preloadProps),\n      markNodeAsHoistable(key),\n      ownerDocument.head.appendChild(key));\n}\nfunction getScriptKey(src) {\n  return \'[src="\' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + \'"]\';\n}\nfunction getScriptSelectorFromKey(key) {\n  return "script[async]" + key;\n}\nfunction acquireResource(hoistableRoot, resource, props) {\n  resource.count++;\n  if (null === resource.instance)\n    switch (resource.type) {\n      case "style":\n        var instance = hoistableRoot.querySelector(\n          \'style[data-href~="\' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +\n            \'"]\'\n        );\n        if (instance)\n          return (\n            (resource.instance = instance),\n            markNodeAsHoistable(instance),\n            instance\n          );\n        var styleProps = assign({}, props, {\n          "data-href": props.href,\n          "data-precedence": props.precedence,\n          href: null,\n          precedence: null\n        });\n        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(\n          "style"\n        );\n        markNodeAsHoistable(instance);\n        setInitialProperties(instance, "style", styleProps);\n        insertStylesheet(instance, props.precedence, hoistableRoot);\n        return (resource.instance = instance);\n      case "stylesheet":\n        styleProps = getStyleKey(props.href);\n        var instance$248 = hoistableRoot.querySelector(\n          getStylesheetSelectorFromKey(styleProps)\n        );\n        if (instance$248)\n          return (\n            (resource.state.loading |= 4),\n            (resource.instance = instance$248),\n            markNodeAsHoistable(instance$248),\n            instance$248\n          );\n        instance = stylesheetPropsFromRawProps(props);\n        (styleProps = preloadPropsMap.get(styleProps)) &&\n          adoptPreloadPropsForStylesheet(instance, styleProps);\n        instance$248 = (\n          hoistableRoot.ownerDocument || hoistableRoot\n        ).createElement("link");\n        markNodeAsHoistable(instance$248);\n        var linkInstance = instance$248;\n        linkInstance._p = new Promise(function (resolve, reject) {\n          linkInstance.onload = resolve;\n          linkInstance.onerror = reject;\n        });\n        setInitialProperties(instance$248, "link", instance);\n        resource.state.loading |= 4;\n        insertStylesheet(instance$248, props.precedence, hoistableRoot);\n        return (resource.instance = instance$248);\n      case "script":\n        instance$248 = getScriptKey(props.src);\n        if (\n          (styleProps = hoistableRoot.querySelector(\n            getScriptSelectorFromKey(instance$248)\n          ))\n        )\n          return (\n            (resource.instance = styleProps),\n            markNodeAsHoistable(styleProps),\n            styleProps\n          );\n        instance = props;\n        if ((styleProps = preloadPropsMap.get(instance$248)))\n          (instance = assign({}, props)),\n            adoptPreloadPropsForScript(instance, styleProps);\n        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n        styleProps = hoistableRoot.createElement("script");\n        markNodeAsHoistable(styleProps);\n        setInitialProperties(styleProps, "link", instance);\n        hoistableRoot.head.appendChild(styleProps);\n        return (resource.instance = styleProps);\n      case "void":\n        return null;\n      default:\n        throw Error(formatProdErrorMessage(443, resource.type));\n    }\n  else\n    "stylesheet" === resource.type &&\n      0 === (resource.state.loading & 4) &&\n      ((instance = resource.instance),\n      (resource.state.loading |= 4),\n      insertStylesheet(instance, props.precedence, hoistableRoot));\n  return resource.instance;\n}\nfunction insertStylesheet(instance, precedence, root) {\n  for (\n    var nodes = root.querySelectorAll(\n        \'link[rel="stylesheet"][data-precedence],style[data-precedence]\'\n      ),\n      last = nodes.length ? nodes[nodes.length - 1] : null,\n      prior = last,\n      i = 0;\n    i < nodes.length;\n    i++\n  ) {\n    var node = nodes[i];\n    if (node.dataset.precedence === precedence) prior = node;\n    else if (prior !== last) break;\n  }\n  prior\n    ? prior.parentNode.insertBefore(instance, prior.nextSibling)\n    : ((precedence = 9 === root.nodeType ? root.head : root),\n      precedence.insertBefore(instance, precedence.firstChild));\n}\nfunction adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {\n  null == stylesheetProps.crossOrigin &&\n    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);\n  null == stylesheetProps.referrerPolicy &&\n    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);\n  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);\n}\nfunction adoptPreloadPropsForScript(scriptProps, preloadProps) {\n  null == scriptProps.crossOrigin &&\n    (scriptProps.crossOrigin = preloadProps.crossOrigin);\n  null == scriptProps.referrerPolicy &&\n    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);\n  null == scriptProps.integrity &&\n    (scriptProps.integrity = preloadProps.integrity);\n}\nvar tagCaches = null;\nfunction getHydratableHoistableCache(type, keyAttribute, ownerDocument) {\n  if (null === tagCaches) {\n    var cache = new Map();\n    var caches = (tagCaches = new Map());\n    caches.set(ownerDocument, cache);\n  } else\n    (caches = tagCaches),\n      (cache = caches.get(ownerDocument)),\n      cache || ((cache = new Map()), caches.set(ownerDocument, cache));\n  if (cache.has(type)) return cache;\n  cache.set(type, null);\n  ownerDocument = ownerDocument.getElementsByTagName(type);\n  for (caches = 0; caches < ownerDocument.length; caches++) {\n    var node = ownerDocument[caches];\n    if (\n      !(\n        node[internalHoistableMarker] ||\n        node[internalInstanceKey] ||\n        ("link" === type && "stylesheet" === node.getAttribute("rel"))\n      ) &&\n      "http://www.w3.org/2000/svg" !== node.namespaceURI\n    ) {\n      var nodeKey = node.getAttribute(keyAttribute) || "";\n      nodeKey = type + nodeKey;\n      var existing = cache.get(nodeKey);\n      existing ? existing.push(node) : cache.set(nodeKey, [node]);\n    }\n  }\n  return cache;\n}\nfunction mountHoistable(hoistableRoot, type, instance) {\n  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n  hoistableRoot.head.insertBefore(\n    instance,\n    "title" === type ? hoistableRoot.querySelector("head > title") : null\n  );\n}\nfunction isHostHoistableType(type, props, hostContext) {\n  if (1 === hostContext || null != props.itemProp) return !1;\n  switch (type) {\n    case "meta":\n    case "title":\n      return !0;\n    case "style":\n      if (\n        "string" !== typeof props.precedence ||\n        "string" !== typeof props.href ||\n        "" === props.href\n      )\n        break;\n      return !0;\n    case "link":\n      if (\n        "string" !== typeof props.rel ||\n        "string" !== typeof props.href ||\n        "" === props.href ||\n        props.onLoad ||\n        props.onError\n      )\n        break;\n      switch (props.rel) {\n        case "stylesheet":\n          return (\n            (type = props.disabled),\n            "string" === typeof props.precedence && null == type\n          );\n        default:\n          return !0;\n      }\n    case "script":\n      if (\n        props.async &&\n        "function" !== typeof props.async &&\n        "symbol" !== typeof props.async &&\n        !props.onLoad &&\n        !props.onError &&\n        props.src &&\n        "string" === typeof props.src\n      )\n        return !0;\n  }\n  return !1;\n}\nfunction preloadResource(resource) {\n  return "stylesheet" === resource.type && 0 === (resource.state.loading & 3)\n    ? !1\n    : !0;\n}\nvar suspendedState = null;\nfunction noop() {}\nfunction suspendResource(hoistableRoot, resource, props) {\n  if (null === suspendedState) throw Error(formatProdErrorMessage(475));\n  var state = suspendedState;\n  if (\n    "stylesheet" === resource.type &&\n    ("string" !== typeof props.media ||\n      !1 !== matchMedia(props.media).matches) &&\n    0 === (resource.state.loading & 4)\n  ) {\n    if (null === resource.instance) {\n      var key = getStyleKey(props.href),\n        instance = hoistableRoot.querySelector(\n          getStylesheetSelectorFromKey(key)\n        );\n      if (instance) {\n        hoistableRoot = instance._p;\n        null !== hoistableRoot &&\n          "object" === typeof hoistableRoot &&\n          "function" === typeof hoistableRoot.then &&\n          (state.count++,\n          (state = onUnsuspend.bind(state)),\n          hoistableRoot.then(state, state));\n        resource.state.loading |= 4;\n        resource.instance = instance;\n        markNodeAsHoistable(instance);\n        return;\n      }\n      instance = hoistableRoot.ownerDocument || hoistableRoot;\n      props = stylesheetPropsFromRawProps(props);\n      (key = preloadPropsMap.get(key)) &&\n        adoptPreloadPropsForStylesheet(props, key);\n      instance = instance.createElement("link");\n      markNodeAsHoistable(instance);\n      var linkInstance = instance;\n      linkInstance._p = new Promise(function (resolve, reject) {\n        linkInstance.onload = resolve;\n        linkInstance.onerror = reject;\n      });\n      setInitialProperties(instance, "link", props);\n      resource.instance = instance;\n    }\n    null === state.stylesheets && (state.stylesheets = new Map());\n    state.stylesheets.set(resource, hoistableRoot);\n    (hoistableRoot = resource.state.preload) &&\n      0 === (resource.state.loading & 3) &&\n      (state.count++,\n      (resource = onUnsuspend.bind(state)),\n      hoistableRoot.addEventListener("load", resource),\n      hoistableRoot.addEventListener("error", resource));\n  }\n}\nfunction waitForCommitToBeReady() {\n  if (null === suspendedState) throw Error(formatProdErrorMessage(475));\n  var state = suspendedState;\n  state.stylesheets &&\n    0 === state.count &&\n    insertSuspendedStylesheets(state, state.stylesheets);\n  return 0 < state.count\n    ? function (commit) {\n        var stylesheetTimer = setTimeout(function () {\n          state.stylesheets &&\n            insertSuspendedStylesheets(state, state.stylesheets);\n          if (state.unsuspend) {\n            var unsuspend = state.unsuspend;\n            state.unsuspend = null;\n            unsuspend();\n          }\n        }, 6e4);\n        state.unsuspend = commit;\n        return function () {\n          state.unsuspend = null;\n          clearTimeout(stylesheetTimer);\n        };\n      }\n    : null;\n}\nfunction onUnsuspend() {\n  this.count--;\n  if (0 === this.count)\n    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);\n    else if (this.unsuspend) {\n      var unsuspend = this.unsuspend;\n      this.unsuspend = null;\n      unsuspend();\n    }\n}\nvar precedencesByRoot = null;\nfunction insertSuspendedStylesheets(state, resources) {\n  state.stylesheets = null;\n  null !== state.unsuspend &&\n    (state.count++,\n    (precedencesByRoot = new Map()),\n    resources.forEach(insertStylesheetIntoRoot, state),\n    (precedencesByRoot = null),\n    onUnsuspend.call(state));\n}\nfunction insertStylesheetIntoRoot(root, resource) {\n  if (!(resource.state.loading & 4)) {\n    var precedences = precedencesByRoot.get(root);\n    if (precedences) var last = precedences.get(null);\n    else {\n      precedences = new Map();\n      precedencesByRoot.set(root, precedences);\n      for (\n        var nodes = root.querySelectorAll(\n            "link[data-precedence],style[data-precedence]"\n          ),\n          i = 0;\n        i < nodes.length;\n        i++\n      ) {\n        var node = nodes[i];\n        if (\n          "LINK" === node.nodeName ||\n          "not all" !== node.getAttribute("media")\n        )\n          precedences.set(node.dataset.precedence, node), (last = node);\n      }\n      last && precedences.set(null, last);\n    }\n    nodes = resource.instance;\n    node = nodes.getAttribute("data-precedence");\n    i = precedences.get(node) || last;\n    i === last && precedences.set(null, nodes);\n    precedences.set(node, nodes);\n    this.count++;\n    last = onUnsuspend.bind(this);\n    nodes.addEventListener("load", last);\n    nodes.addEventListener("error", last);\n    i\n      ? i.parentNode.insertBefore(nodes, i.nextSibling)\n      : ((root = 9 === root.nodeType ? root.head : root),\n        root.insertBefore(nodes, root.firstChild));\n    resource.state.loading |= 4;\n  }\n}\nvar HostTransitionContext = {\n  $$typeof: REACT_CONTEXT_TYPE,\n  Provider: null,\n  Consumer: null,\n  _currentValue: sharedNotPendingObject,\n  _currentValue2: sharedNotPendingObject,\n  _threadCount: 0\n};\nfunction FiberRootNode(\n  containerInfo,\n  tag,\n  hydrate,\n  identifierPrefix,\n  onUncaughtError,\n  onCaughtError,\n  onRecoverableError,\n  formState\n) {\n  this.tag = 1;\n  this.containerInfo = containerInfo;\n  this.finishedWork =\n    this.pingCache =\n    this.current =\n    this.pendingChildren =\n      null;\n  this.timeoutHandle = -1;\n  this.callbackNode =\n    this.next =\n    this.pendingContext =\n    this.context =\n    this.cancelPendingCommit =\n      null;\n  this.callbackPriority = 0;\n  this.expirationTimes = createLaneMap(-1);\n  this.entangledLanes =\n    this.shellSuspendCounter =\n    this.errorRecoveryDisabledLanes =\n    this.finishedLanes =\n    this.expiredLanes =\n    this.warmLanes =\n    this.pingedLanes =\n    this.suspendedLanes =\n    this.pendingLanes =\n      0;\n  this.entanglements = createLaneMap(0);\n  this.hiddenUpdates = createLaneMap(null);\n  this.identifierPrefix = identifierPrefix;\n  this.onUncaughtError = onUncaughtError;\n  this.onCaughtError = onCaughtError;\n  this.onRecoverableError = onRecoverableError;\n  this.pooledCache = null;\n  this.pooledCacheLanes = 0;\n  this.formState = formState;\n  this.incompleteTransitions = new Map();\n}\nfunction createFiberRoot(\n  containerInfo,\n  tag,\n  hydrate,\n  initialChildren,\n  hydrationCallbacks,\n  isStrictMode,\n  identifierPrefix,\n  onUncaughtError,\n  onCaughtError,\n  onRecoverableError,\n  transitionCallbacks,\n  formState\n) {\n  containerInfo = new FiberRootNode(\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    formState\n  );\n  tag = 1;\n  !0 === isStrictMode && (tag |= 24);\n  isStrictMode = createFiberImplClass(3, null, null, tag);\n  containerInfo.current = isStrictMode;\n  isStrictMode.stateNode = containerInfo;\n  tag = createCache();\n  tag.refCount++;\n  containerInfo.pooledCache = tag;\n  tag.refCount++;\n  isStrictMode.memoizedState = {\n    element: initialChildren,\n    isDehydrated: hydrate,\n    cache: tag\n  };\n  initializeUpdateQueue(isStrictMode);\n  return containerInfo;\n}\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) return emptyContextObject;\n  parentComponent = emptyContextObject;\n  return parentComponent;\n}\nfunction updateContainerImpl(\n  rootFiber,\n  lane,\n  element,\n  container,\n  parentComponent,\n  callback\n) {\n  parentComponent = getContextForSubtree(parentComponent);\n  null === container.context\n    ? (container.context = parentComponent)\n    : (container.pendingContext = parentComponent);\n  container = createUpdate(lane);\n  container.payload = { element: element };\n  callback = void 0 === callback ? null : callback;\n  null !== callback && (container.callback = callback);\n  element = enqueueUpdate(rootFiber, container, lane);\n  null !== element &&\n    (scheduleUpdateOnFiber(element, rootFiber, lane),\n    entangleTransitions(element, rootFiber, lane));\n}\nfunction markRetryLaneImpl(fiber, retryLane) {\n  fiber = fiber.memoizedState;\n  if (null !== fiber && null !== fiber.dehydrated) {\n    var a = fiber.retryLane;\n    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n  }\n}\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n}\nfunction attemptContinuousHydration(fiber) {\n  if (13 === fiber.tag) {\n    var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n    markRetryLaneIfNotHydrated(fiber, 67108864);\n  }\n}\nvar _enabled = !0;\nfunction dispatchDiscreteEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent\n) {\n  var prevTransition = ReactSharedInternals.T;\n  ReactSharedInternals.T = null;\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 2),\n      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction dispatchContinuousEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent\n) {\n  var prevTransition = ReactSharedInternals.T;\n  ReactSharedInternals.T = null;\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 8),\n      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction dispatchEvent(\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  if (_enabled) {\n    var blockedOn = findInstanceBlockingEvent(nativeEvent);\n    if (null === blockedOn)\n      dispatchEventForPluginEventSystem(\n        domEventName,\n        eventSystemFlags,\n        nativeEvent,\n        return_targetInst,\n        targetContainer\n      ),\n        clearIfContinuousEvent(domEventName, nativeEvent);\n    else if (\n      queueIfContinuousEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent\n      )\n    )\n      nativeEvent.stopPropagation();\n    else if (\n      (clearIfContinuousEvent(domEventName, nativeEvent),\n      eventSystemFlags & 4 &&\n        -1 < discreteReplayableEvents.indexOf(domEventName))\n    ) {\n      for (; null !== blockedOn; ) {\n        var fiber = getInstanceFromNode(blockedOn);\n        if (null !== fiber)\n          switch (fiber.tag) {\n            case 3:\n              fiber = fiber.stateNode;\n              if (fiber.current.memoizedState.isDehydrated) {\n                var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                if (0 !== lanes) {\n                  var root = fiber;\n                  root.pendingLanes |= 2;\n                  for (root.entangledLanes |= 2; lanes; ) {\n                    var lane = 1 << (31 - clz32(lanes));\n                    root.entanglements[1] |= lane;\n                    lanes &= ~lane;\n                  }\n                  ensureRootIsScheduled(fiber);\n                  0 === (executionContext & 6) &&\n                    ((workInProgressRootRenderTargetTime = now() + 500),\n                    flushSyncWorkAcrossRoots_impl(0, !1));\n                }\n              }\n              break;\n            case 13:\n              (root = enqueueConcurrentRenderForLane(fiber, 2)),\n                null !== root && scheduleUpdateOnFiber(root, fiber, 2),\n                flushSyncWork$1(),\n                markRetryLaneIfNotHydrated(fiber, 2);\n          }\n        fiber = findInstanceBlockingEvent(nativeEvent);\n        null === fiber &&\n          dispatchEventForPluginEventSystem(\n            domEventName,\n            eventSystemFlags,\n            nativeEvent,\n            return_targetInst,\n            targetContainer\n          );\n        if (fiber === blockedOn) break;\n        blockedOn = fiber;\n      }\n      null !== blockedOn && nativeEvent.stopPropagation();\n    } else\n      dispatchEventForPluginEventSystem(\n        domEventName,\n        eventSystemFlags,\n        nativeEvent,\n        null,\n        targetContainer\n      );\n  }\n}\nfunction findInstanceBlockingEvent(nativeEvent) {\n  nativeEvent = getEventTarget(nativeEvent);\n  return findInstanceBlockingTarget(nativeEvent);\n}\nvar return_targetInst = null;\nfunction findInstanceBlockingTarget(targetNode) {\n  return_targetInst = null;\n  targetNode = getClosestInstanceFromNode(targetNode);\n  if (null !== targetNode) {\n    var nearestMounted = getNearestMountedFiber(targetNode);\n    if (null === nearestMounted) targetNode = null;\n    else {\n      var tag = nearestMounted.tag;\n      if (13 === tag) {\n        targetNode = getSuspenseInstanceFromFiber(nearestMounted);\n        if (null !== targetNode) return targetNode;\n        targetNode = null;\n      } else if (3 === tag) {\n        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)\n          return 3 === nearestMounted.tag\n            ? nearestMounted.stateNode.containerInfo\n            : null;\n        targetNode = null;\n      } else nearestMounted !== targetNode && (targetNode = null);\n    }\n  }\n  return_targetInst = targetNode;\n  return null;\n}\nfunction getEventPriority(domEventName) {\n  switch (domEventName) {\n    case "beforetoggle":\n    case "cancel":\n    case "click":\n    case "close":\n    case "contextmenu":\n    case "copy":\n    case "cut":\n    case "auxclick":\n    case "dblclick":\n    case "dragend":\n    case "dragstart":\n    case "drop":\n    case "focusin":\n    case "focusout":\n    case "input":\n    case "invalid":\n    case "keydown":\n    case "keypress":\n    case "keyup":\n    case "mousedown":\n    case "mouseup":\n    case "paste":\n    case "pause":\n    case "play":\n    case "pointercancel":\n    case "pointerdown":\n    case "pointerup":\n    case "ratechange":\n    case "reset":\n    case "resize":\n    case "seeked":\n    case "submit":\n    case "toggle":\n    case "touchcancel":\n    case "touchend":\n    case "touchstart":\n    case "volumechange":\n    case "change":\n    case "selectionchange":\n    case "textInput":\n    case "compositionstart":\n    case "compositionend":\n    case "compositionupdate":\n    case "beforeblur":\n    case "afterblur":\n    case "beforeinput":\n    case "blur":\n    case "fullscreenchange":\n    case "focus":\n    case "hashchange":\n    case "popstate":\n    case "select":\n    case "selectstart":\n      return 2;\n    case "drag":\n    case "dragenter":\n    case "dragexit":\n    case "dragleave":\n    case "dragover":\n    case "mousemove":\n    case "mouseout":\n    case "mouseover":\n    case "pointermove":\n    case "pointerout":\n    case "pointerover":\n    case "scroll":\n    case "touchmove":\n    case "wheel":\n    case "mouseenter":\n    case "mouseleave":\n    case "pointerenter":\n    case "pointerleave":\n      return 8;\n    case "message":\n      switch (getCurrentPriorityLevel()) {\n        case ImmediatePriority:\n          return 2;\n        case UserBlockingPriority:\n          return 8;\n        case NormalPriority$1:\n        case LowPriority:\n          return 32;\n        case IdlePriority:\n          return 268435456;\n        default:\n          return 32;\n      }\n    default:\n      return 32;\n  }\n}\nvar hasScheduledReplayAttempt = !1,\n  queuedFocus = null,\n  queuedDrag = null,\n  queuedMouse = null,\n  queuedPointers = new Map(),\n  queuedPointerCaptures = new Map(),\n  queuedExplicitHydrationTargets = [],\n  discreteReplayableEvents =\n    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(\n      " "\n    );\nfunction clearIfContinuousEvent(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case "focusin":\n    case "focusout":\n      queuedFocus = null;\n      break;\n    case "dragenter":\n    case "dragleave":\n      queuedDrag = null;\n      break;\n    case "mouseover":\n    case "mouseout":\n      queuedMouse = null;\n      break;\n    case "pointerover":\n    case "pointerout":\n      queuedPointers.delete(nativeEvent.pointerId);\n      break;\n    case "gotpointercapture":\n    case "lostpointercapture":\n      queuedPointerCaptures.delete(nativeEvent.pointerId);\n  }\n}\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent,\n  blockedOn,\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  if (\n    null === existingQueuedEvent ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  )\n    return (\n      (existingQueuedEvent = {\n        blockedOn: blockedOn,\n        domEventName: domEventName,\n        eventSystemFlags: eventSystemFlags,\n        nativeEvent: nativeEvent,\n        targetContainers: [targetContainer]\n      }),\n      null !== blockedOn &&\n        ((blockedOn = getInstanceFromNode(blockedOn)),\n        null !== blockedOn && attemptContinuousHydration(blockedOn)),\n      existingQueuedEvent\n    );\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  blockedOn = existingQueuedEvent.targetContainers;\n  null !== targetContainer &&\n    -1 === blockedOn.indexOf(targetContainer) &&\n    blockedOn.push(targetContainer);\n  return existingQueuedEvent;\n}\nfunction queueIfContinuousEvent(\n  blockedOn,\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  switch (domEventName) {\n    case "focusin":\n      return (\n        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedFocus,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case "dragenter":\n      return (\n        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedDrag,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case "mouseover":\n      return (\n        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedMouse,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case "pointerover":\n      var pointerId = nativeEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )\n      );\n      return !0;\n    case "gotpointercapture":\n      return (\n        (pointerId = nativeEvent.pointerId),\n        queuedPointerCaptures.set(\n          pointerId,\n          accumulateOrCreateContinuousQueuedReplayableEvent(\n            queuedPointerCaptures.get(pointerId) || null,\n            blockedOn,\n            domEventName,\n            eventSystemFlags,\n            targetContainer,\n            nativeEvent\n          )\n        ),\n        !0\n      );\n  }\n  return !1;\n}\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (null !== targetInst) {\n    var nearestMounted = getNearestMountedFiber(targetInst);\n    if (null !== nearestMounted)\n      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {\n        if (\n          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),\n          null !== targetInst)\n        ) {\n          queuedTarget.blockedOn = targetInst;\n          runWithPriority(queuedTarget.priority, function () {\n            if (13 === nearestMounted.tag) {\n              var lane = requestUpdateLane(),\n                root = enqueueConcurrentRenderForLane(nearestMounted, lane);\n              null !== root &&\n                scheduleUpdateOnFiber(root, nearestMounted, lane);\n              markRetryLaneIfNotHydrated(nearestMounted, lane);\n            }\n          });\n          return;\n        }\n      } else if (\n        3 === targetInst &&\n        nearestMounted.stateNode.current.memoizedState.isDehydrated\n      ) {\n        queuedTarget.blockedOn =\n          3 === nearestMounted.tag\n            ? nearestMounted.stateNode.containerInfo\n            : null;\n        return;\n      }\n  }\n  queuedTarget.blockedOn = null;\n}\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (null !== queuedEvent.blockedOn) return !1;\n  for (\n    var targetContainers = queuedEvent.targetContainers;\n    0 < targetContainers.length;\n\n  ) {\n    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);\n    if (null === nextBlockedOn) {\n      nextBlockedOn = queuedEvent.nativeEvent;\n      var nativeEventClone = new nextBlockedOn.constructor(\n        nextBlockedOn.type,\n        nextBlockedOn\n      );\n      currentReplayingEvent = nativeEventClone;\n      nextBlockedOn.target.dispatchEvent(nativeEventClone);\n      currentReplayingEvent = null;\n    } else\n      return (\n        (targetContainers = getInstanceFromNode(nextBlockedOn)),\n        null !== targetContainers &&\n          attemptContinuousHydration(targetContainers),\n        (queuedEvent.blockedOn = nextBlockedOn),\n        !1\n      );\n    targetContainers.shift();\n  }\n  return !0;\n}\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);\n}\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = !1;\n  null !== queuedFocus &&\n    attemptReplayContinuousQueuedEvent(queuedFocus) &&\n    (queuedFocus = null);\n  null !== queuedDrag &&\n    attemptReplayContinuousQueuedEvent(queuedDrag) &&\n    (queuedDrag = null);\n  null !== queuedMouse &&\n    attemptReplayContinuousQueuedEvent(queuedMouse) &&\n    (queuedMouse = null);\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  queuedEvent.blockedOn === unblocked &&\n    ((queuedEvent.blockedOn = null),\n    hasScheduledReplayAttempt ||\n      ((hasScheduledReplayAttempt = !0),\n      Scheduler.unstable_scheduleCallback(\n        Scheduler.unstable_NormalPriority,\n        replayUnblockedEvents\n      )));\n}\nvar lastScheduledReplayQueue = null;\nfunction scheduleReplayQueueIfNeeded(formReplayingQueue) {\n  lastScheduledReplayQueue !== formReplayingQueue &&\n    ((lastScheduledReplayQueue = formReplayingQueue),\n    Scheduler.unstable_scheduleCallback(\n      Scheduler.unstable_NormalPriority,\n      function () {\n        lastScheduledReplayQueue === formReplayingQueue &&\n          (lastScheduledReplayQueue = null);\n        for (var i = 0; i < formReplayingQueue.length; i += 3) {\n          var form = formReplayingQueue[i],\n            submitterOrAction = formReplayingQueue[i + 1],\n            formData = formReplayingQueue[i + 2];\n          if ("function" !== typeof submitterOrAction)\n            if (null === findInstanceBlockingTarget(submitterOrAction || form))\n              continue;\n            else break;\n          var formInst = getInstanceFromNode(form);\n          null !== formInst &&\n            (formReplayingQueue.splice(i, 3),\n            (i -= 3),\n            startHostTransition(\n              formInst,\n              {\n                pending: !0,\n                data: formData,\n                method: form.method,\n                action: submitterOrAction\n              },\n              submitterOrAction,\n              formData\n            ));\n        }\n      }\n    ));\n}\nfunction retryIfBlockedOn(unblocked) {\n  function unblock(queuedEvent) {\n    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  }\n  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    var queuedTarget = queuedExplicitHydrationTargets[i];\n    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);\n  }\n  for (\n    ;\n    0 < queuedExplicitHydrationTargets.length &&\n    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);\n\n  )\n    attemptExplicitHydrationTarget(i),\n      null === i.blockedOn && queuedExplicitHydrationTargets.shift();\n  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;\n  if (null != i)\n    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {\n      var form = i[queuedTarget],\n        submitterOrAction = i[queuedTarget + 1],\n        formProps = form[internalPropsKey] || null;\n      if ("function" === typeof submitterOrAction)\n        formProps || scheduleReplayQueueIfNeeded(i);\n      else if (formProps) {\n        var action = null;\n        if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))\n          if (\n            ((form = submitterOrAction),\n            (formProps = submitterOrAction[internalPropsKey] || null))\n          )\n            action = formProps.formAction;\n          else {\n            if (null !== findInstanceBlockingTarget(form)) continue;\n          }\n        else action = formProps.action;\n        "function" === typeof action\n          ? (i[queuedTarget + 1] = action)\n          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));\n        scheduleReplayQueueIfNeeded(i);\n      }\n    }\n}\nfunction ReactDOMRoot(internalRoot) {\n  this._internalRoot = internalRoot;\n}\nReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =\n  function (children) {\n    var root = this._internalRoot;\n    if (null === root) throw Error(formatProdErrorMessage(409));\n    var current = root.current,\n      lane = requestUpdateLane();\n    updateContainerImpl(current, lane, children, root, null, null);\n  };\nReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =\n  function () {\n    var root = this._internalRoot;\n    if (null !== root) {\n      this._internalRoot = null;\n      var container = root.containerInfo;\n      0 === root.tag && flushPassiveEffects();\n      updateContainerImpl(root.current, 2, null, root, null, null);\n      flushSyncWork$1();\n      container[internalContainerInstanceKey] = null;\n    }\n  };\nfunction ReactDOMHydrationRoot(internalRoot) {\n  this._internalRoot = internalRoot;\n}\nReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n  if (target) {\n    var updatePriority = resolveUpdatePriority();\n    target = { blockedOn: null, target: target, priority: updatePriority };\n    for (\n      var i = 0;\n      i < queuedExplicitHydrationTargets.length &&\n      0 !== updatePriority &&\n      updatePriority < queuedExplicitHydrationTargets[i].priority;\n      i++\n    );\n    queuedExplicitHydrationTargets.splice(i, 0, target);\n    0 === i && attemptExplicitHydrationTarget(target);\n  }\n};\nvar isomorphicReactPackageVersion$jscomp$inline_1686 = React.version;\nif (\n  "19.0.0" !==\n  isomorphicReactPackageVersion$jscomp$inline_1686\n)\n  throw Error(\n    formatProdErrorMessage(\n      527,\n      isomorphicReactPackageVersion$jscomp$inline_1686,\n      "19.0.0"\n    )\n  );\nReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n  var fiber = componentOrElement._reactInternals;\n  if (void 0 === fiber) {\n    if ("function" === typeof componentOrElement.render)\n      throw Error(formatProdErrorMessage(188));\n    componentOrElement = Object.keys(componentOrElement).join(",");\n    throw Error(formatProdErrorMessage(268, componentOrElement));\n  }\n  componentOrElement = findCurrentFiberUsingSlowPath(fiber);\n  componentOrElement =\n    null !== componentOrElement\n      ? findCurrentHostFiberImpl(componentOrElement)\n      : null;\n  componentOrElement =\n    null === componentOrElement ? null : componentOrElement.stateNode;\n  return componentOrElement;\n};\nvar internals$jscomp$inline_2165 = {\n  bundleType: 0,\n  version: "19.0.0",\n  rendererPackageName: "react-dom",\n  currentDispatcherRef: ReactSharedInternals,\n  findFiberByHostInstance: getClosestInstanceFromNode,\n  reconcilerVersion: "19.0.0"\n};\nif ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n  var hook$jscomp$inline_2166 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (\n    !hook$jscomp$inline_2166.isDisabled &&\n    hook$jscomp$inline_2166.supportsFiber\n  )\n    try {\n      (rendererID = hook$jscomp$inline_2166.inject(\n        internals$jscomp$inline_2165\n      )),\n        (injectedHook = hook$jscomp$inline_2166);\n    } catch (err) {}\n}\nexports.createRoot = function (container, options) {\n  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));\n  var isStrictMode = !1,\n    identifierPrefix = "",\n    onUncaughtError = defaultOnUncaughtError,\n    onCaughtError = defaultOnCaughtError,\n    onRecoverableError = defaultOnRecoverableError,\n    transitionCallbacks = null;\n  null !== options &&\n    void 0 !== options &&\n    (!0 === options.unstable_strictMode && (isStrictMode = !0),\n    void 0 !== options.identifierPrefix &&\n      (identifierPrefix = options.identifierPrefix),\n    void 0 !== options.onUncaughtError &&\n      (onUncaughtError = options.onUncaughtError),\n    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),\n    void 0 !== options.onRecoverableError &&\n      (onRecoverableError = options.onRecoverableError),\n    void 0 !== options.unstable_transitionCallbacks &&\n      (transitionCallbacks = options.unstable_transitionCallbacks));\n  options = createFiberRoot(\n    container,\n    1,\n    !1,\n    null,\n    null,\n    isStrictMode,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    transitionCallbacks,\n    null\n  );\n  container[internalContainerInstanceKey] = options.current;\n  listenToAllSupportedEvents(\n    8 === container.nodeType ? container.parentNode : container\n  );\n  return new ReactDOMRoot(options);\n};\nexports.hydrateRoot = function (container, initialChildren, options) {\n  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));\n  var isStrictMode = !1,\n    identifierPrefix = "",\n    onUncaughtError = defaultOnUncaughtError,\n    onCaughtError = defaultOnCaughtError,\n    onRecoverableError = defaultOnRecoverableError,\n    transitionCallbacks = null,\n    formState = null;\n  null !== options &&\n    void 0 !== options &&\n    (!0 === options.unstable_strictMode && (isStrictMode = !0),\n    void 0 !== options.identifierPrefix &&\n      (identifierPrefix = options.identifierPrefix),\n    void 0 !== options.onUncaughtError &&\n      (onUncaughtError = options.onUncaughtError),\n    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),\n    void 0 !== options.onRecoverableError &&\n      (onRecoverableError = options.onRecoverableError),\n    void 0 !== options.unstable_transitionCallbacks &&\n      (transitionCallbacks = options.unstable_transitionCallbacks),\n    void 0 !== options.formState && (formState = options.formState));\n  initialChildren = createFiberRoot(\n    container,\n    1,\n    !0,\n    initialChildren,\n    null != options ? options : null,\n    isStrictMode,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    transitionCallbacks,\n    formState\n  );\n  initialChildren.context = getContextForSubtree(null);\n  options = initialChildren.current;\n  isStrictMode = requestUpdateLane();\n  identifierPrefix = createUpdate(isStrictMode);\n  identifierPrefix.callback = null;\n  enqueueUpdate(options, identifierPrefix, isStrictMode);\n  initialChildren.current.lanes = isStrictMode;\n  markRootUpdated$1(initialChildren, isStrictMode);\n  ensureRootIsScheduled(initialChildren);\n  container[internalContainerInstanceKey] = initialChildren.current;\n  listenToAllSupportedEvents(container);\n  return new ReactDOMHydrationRoot(initialChildren);\n};\nexports.version = "19.0.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ3LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ2E7QUFDYixnQkFBZ0IsbUJBQU8sQ0FBQyxHQUFXO0FBQ25DLFVBQVUsbUJBQU8sQ0FBQyxHQUFPO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxHQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQXlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCO0FBQzNCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhCQUE4QixvQkFBb0Isb0JBQW9CO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MseUJBQXlCLGlCQUFpQjtBQUMxRTtBQUNBLGlDQUFpQyxzQkFBc0Isa0JBQWtCO0FBQ3pFO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsdUNBQXVDLG9CQUFvQixTQUFTO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUNBQXFDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrREFBa0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0NBQW9DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3Q0FBd0M7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLCtCQUErQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxzQkFBc0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHlDQUF5QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsNEJBQTRCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNEJBQTRCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUE0QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFdBQVc7QUFDWDtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxpQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0IscUNBQXFDO0FBQ2pFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWLDhCQUE4QixPQUFPO0FBQ3JDLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0NBQStDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZDQUE2QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sNENBQTRDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNCQUFzQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywwQkFBMEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsVUFBVTtBQUNWO0FBQ0EsMkNBQTJDO0FBQzNDLElBQUk7QUFDSiwyQkFBMkI7QUFDM0I7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxQkFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsaUJBQWlCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNCQUFzQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQkFBc0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxxQkFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsdUJBQXVCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsaUJBQWlCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsaUJBQWlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsa0JBQWtCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxzQkFBc0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4Q0FBOEM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywyQ0FBMkM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsbUJBQW1CO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBOEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG9DQUFvQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFpQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0RBQWdEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhEQUE4RDtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQ0FBcUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJDQUEyQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzPzM3NWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKlxuIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuKi9cblwidXNlIHN0cmljdFwiO1xudmFyIFNjaGVkdWxlciA9IHJlcXVpcmUoXCJzY2hlZHVsZXJcIiksXG4gIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpLFxuICBSZWFjdERPTSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9IFwiaHR0cHM6Ly9yZWFjdC5kZXYvZXJyb3JzL1wiICsgY29kZTtcbiAgaWYgKDEgPCBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdXJsICs9IFwiP2FyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbMV0pO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgdXJsICs9IFwiJmFyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiAoXG4gICAgXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgK1xuICAgIGNvZGUgK1xuICAgIFwiOyB2aXNpdCBcIiArXG4gICAgdXJsICtcbiAgICBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRDb250YWluZXIobm9kZSkge1xuICByZXR1cm4gIShcbiAgICAhbm9kZSB8fFxuICAgICgxICE9PSBub2RlLm5vZGVUeXBlICYmIDkgIT09IG5vZGUubm9kZVR5cGUgJiYgMTEgIT09IG5vZGUubm9kZVR5cGUpXG4gICk7XG59XG52YXIgUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLFxuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSxcbiAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLFxuICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG5TeW1ib2wuZm9yKFwicmVhY3Quc2NvcGVcIik7XG5TeW1ib2wuZm9yKFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIik7XG5TeW1ib2wuZm9yKFwicmVhY3QubGVnYWN5X2hpZGRlblwiKTtcblN5bWJvbC5mb3IoXCJyZWFjdC50cmFjaW5nX21hcmtlclwiKTtcbnZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWxcIiksXG4gIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobnVsbCA9PT0gbWF5YmVJdGVyYWJsZSB8fCBcIm9iamVjdFwiICE9PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSkgcmV0dXJuIG51bGw7XG4gIG1heWJlSXRlcmFibGUgPVxuICAgIChNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdKSB8fFxuICAgIG1heWJlSXRlcmFibGVbXCJAQGl0ZXJhdG9yXCJdO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVJdGVyYWJsZSA/IG1heWJlSXRlcmFibGUgOiBudWxsO1xufVxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKTtcbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICByZXR1cm4gdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRVxuICAgICAgPyBudWxsXG4gICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSkgcmV0dXJuIHR5cGU7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgfVxuICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgcmV0dXJuICh0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiKSArIFwiLlByb3ZpZGVyXCI7XG4gICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICB2YXIgaW5uZXJUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICB0eXBlIHx8XG4gICAgICAgICAgKCh0eXBlID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8IFwiXCIpLFxuICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGlubmVyVHlwZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbCksXG4gICAgICAgICAgbnVsbCAhPT0gaW5uZXJUeXBlXG4gICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgOiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCBcIk1lbW9cIlxuICAgICAgICApO1xuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIGlubmVyVHlwZSA9IHR5cGUuX3BheWxvYWQ7XG4gICAgICAgIHR5cGUgPSB0eXBlLl9pbml0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZShpbm5lclR5cGUpKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID1cbiAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gIHByZWZpeCxcbiAgc3VmZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICBpZiAodm9pZCAwID09PSBwcmVmaXgpXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IEVycm9yKCk7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgIHByZWZpeCA9IChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgXCJcIjtcbiAgICAgIHN1ZmZpeCA9XG4gICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgPyBcIiAoPGFub255bW91cz4pXCJcbiAgICAgICAgICA6IC0xIDwgeC5zdGFjay5pbmRleE9mKFwiQFwiKVxuICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgfVxuICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG59XG52YXIgcmVlbnRyeSA9ICExO1xuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIGlmICghZm4gfHwgcmVlbnRyeSkgcmV0dXJuIFwiXCI7XG4gIHJlZW50cnkgPSAhMDtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gIHRyeSB7XG4gICAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4JDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4JDEpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChGYWtlID0gZm4oKSkgJiZcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICBGYWtlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiBcInN0cmluZ1wiID09PSB0eXBlb2Ygc2FtcGxlLnN0YWNrKVxuICAgICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgICB9XG4gICAgfTtcbiAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPVxuICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIjtcbiAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgIFwibmFtZVwiXG4gICAgKTtcbiAgICBuYW1lUHJvcERlc2NyaXB0b3IgJiZcbiAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUgJiZcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LFxuICAgICAgICBcIm5hbWVcIixcbiAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICApO1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgY29udHJvbFN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzFdO1xuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KFwiXFxuXCIpLFxuICAgICAgICBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICBmb3IgKFxuICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IgPSBSdW5JblJvb3RGcmFtZSA9IDA7XG4gICAgICAgIFJ1bkluUm9vdEZyYW1lIDwgc2FtcGxlTGluZXMubGVuZ3RoICYmXG4gICAgICAgICFzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0uaW5jbHVkZXMoXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIik7XG5cbiAgICAgIClcbiAgICAgICAgUnVuSW5Sb290RnJhbWUrKztcbiAgICAgIGZvciAoXG4gICAgICAgIDtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAhY29udHJvbExpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIlxuICAgICAgICApO1xuXG4gICAgICApXG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvcisrO1xuICAgICAgaWYgKFxuICAgICAgICBSdW5JblJvb3RGcmFtZSA9PT0gc2FtcGxlTGluZXMubGVuZ3RoIHx8XG4gICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIFJ1bkluUm9vdEZyYW1lID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICAgIDEgPD0gUnVuSW5Sb290RnJhbWUgJiZcbiAgICAgICAgICAwIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgIHNhbXBsZUxpbmVzW1J1bkluUm9vdEZyYW1lXSAhPT0gY29udHJvbExpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl07XG5cbiAgICAgICAgKVxuICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvci0tO1xuICAgICAgZm9yIChcbiAgICAgICAgO1xuICAgICAgICAxIDw9IFJ1bkluUm9vdEZyYW1lICYmIDAgPD0gbmFtZVByb3BEZXNjcmlwdG9yO1xuICAgICAgICBSdW5JblJvb3RGcmFtZS0tLCBuYW1lUHJvcERlc2NyaXB0b3ItLVxuICAgICAgKVxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbUnVuSW5Sb290RnJhbWVdICE9PSBjb250cm9sTGluZXNbbmFtZVByb3BEZXNjcmlwdG9yXSkge1xuICAgICAgICAgIGlmICgxICE9PSBSdW5JblJvb3RGcmFtZSB8fCAxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIGRvXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoUnVuSW5Sb290RnJhbWUtLSxcbiAgICAgICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3ItLSxcbiAgICAgICAgICAgICAgICAwID4gbmFtZVByb3BEZXNjcmlwdG9yIHx8XG4gICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0gIT09XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdKVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPVxuICAgICAgICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tSdW5JblJvb3RGcmFtZV0ucmVwbGFjZShcIiBhdCBuZXcgXCIsIFwiIGF0IFwiKTtcbiAgICAgICAgICAgICAgICBmbi5kaXNwbGF5TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSAmJlxuICAgICAgICAgICAgICAgICAgKGZyYW1lID0gZnJhbWUucmVwbGFjZShcIjxhbm9ueW1vdXM+XCIsIGZuLmRpc3BsYXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoMSA8PSBSdW5JblJvb3RGcmFtZSAmJiAwIDw9IG5hbWVQcm9wRGVzY3JpcHRvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIChyZWVudHJ5ID0gITEpLCAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlKTtcbiAgfVxuICByZXR1cm4gKHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiBcIlwiKVxuICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUocHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSlcbiAgICA6IFwiXCI7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSAyNjpcbiAgICBjYXNlIDI3OlxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcbiAgICBjYXNlIDE2OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiTGF6eVwiKTtcbiAgICBjYXNlIDEzOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VcIik7XG4gICAgY2FzZSAxOTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlTGlzdFwiKTtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJldHVybiAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUsICExKSksIGZpYmVyO1xuICAgIGNhc2UgMTE6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoZmliZXIgPSBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyLCAhMSkpLCBmaWJlclxuICAgICAgKTtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gKGZpYmVyID0gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmaWJlci50eXBlLCAhMCkpLCBmaWJlcjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gXCJcIjtcbiAgICBkb1xuICAgICAgKGluZm8gKz0gZGVzY3JpYmVGaWJlcih3b3JrSW5Qcm9ncmVzcykpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4pO1xuICAgIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIGluZm87XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gXCJcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiBcIiArIHgubWVzc2FnZSArIFwiXFxuXCIgKyB4LnN0YWNrO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXIsXG4gICAgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcbiAgaWYgKGZpYmVyLmFsdGVybmF0ZSkgZm9yICg7IG5vZGUucmV0dXJuOyApIG5vZGUgPSBub2RlLnJldHVybjtcbiAgZWxzZSB7XG4gICAgZmliZXIgPSBub2RlO1xuICAgIGRvXG4gICAgICAobm9kZSA9IGZpYmVyKSxcbiAgICAgICAgMCAhPT0gKG5vZGUuZmxhZ3MgJiA0MDk4KSAmJiAobmVhcmVzdE1vdW50ZWQgPSBub2RlLnJldHVybiksXG4gICAgICAgIChmaWJlciA9IG5vZGUucmV0dXJuKTtcbiAgICB3aGlsZSAoZmliZXIpO1xuICB9XG4gIHJldHVybiAzID09PSBub2RlLnRhZyA/IG5lYXJlc3RNb3VudGVkIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIoZmliZXIpIHtcbiAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG4gICAgbnVsbCA9PT0gc3VzcGVuc2VTdGF0ZSAmJlxuICAgICAgKChmaWJlciA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICBudWxsICE9PSBmaWJlciAmJiAoc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGUpKTtcbiAgICBpZiAobnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSkgcmV0dXJuIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKVxuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg4KSk7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIGFsdGVybmF0ZSA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuICAgIGlmIChudWxsID09PSBhbHRlcm5hdGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg4KSk7XG4gICAgcmV0dXJuIGFsdGVybmF0ZSAhPT0gZmliZXIgPyBudWxsIDogZmliZXI7XG4gIH1cbiAgZm9yICh2YXIgYSA9IGZpYmVyLCBiID0gYWx0ZXJuYXRlOyA7ICkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG4gICAgaWYgKG51bGwgPT09IHBhcmVudEEpIGJyZWFrO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG4gICAgaWYgKG51bGwgPT09IHBhcmVudEIpIHtcbiAgICAgIGIgPSBwYXJlbnRBLnJldHVybjtcbiAgICAgIGlmIChudWxsICE9PSBiKSB7XG4gICAgICAgIGEgPSBiO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgZm9yIChwYXJlbnRCID0gcGFyZW50QS5jaGlsZDsgcGFyZW50QjsgKSB7XG4gICAgICAgIGlmIChwYXJlbnRCID09PSBhKSByZXR1cm4gYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpLCBmaWJlcjtcbiAgICAgICAgaWYgKHBhcmVudEIgPT09IGIpIHJldHVybiBhc3NlcnRJc01vdW50ZWQocGFyZW50QSksIGFsdGVybmF0ZTtcbiAgICAgICAgcGFyZW50QiA9IHBhcmVudEIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg4KSk7XG4gICAgfVxuICAgIGlmIChhLnJldHVybiAhPT0gYi5yZXR1cm4pIChhID0gcGFyZW50QSksIChiID0gcGFyZW50Qik7XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBkaWRGaW5kQ2hpbGQgPSAhMSwgY2hpbGQkMiA9IHBhcmVudEEuY2hpbGQ7IGNoaWxkJDI7ICkge1xuICAgICAgICBpZiAoY2hpbGQkMiA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCQyID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gITA7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQkMiA9IGNoaWxkJDIuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIGZvciAoY2hpbGQkMiA9IHBhcmVudEIuY2hpbGQ7IGNoaWxkJDI7ICkge1xuICAgICAgICAgIGlmIChjaGlsZCQyID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSAhMDtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoaWxkJDIgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9ICEwO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGlsZCQyID0gY2hpbGQkMi5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkwKSk7XG4gIH1cbiAgaWYgKDMgIT09IGEudGFnKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xuICByZXR1cm4gYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSA/IGZpYmVyIDogYWx0ZXJuYXRlO1xufVxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBub2RlO1xuICBmb3IgKG5vZGUgPSBub2RlLmNoaWxkOyBudWxsICE9PSBub2RlOyApIHtcbiAgICB0YWcgPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwobm9kZSk7XG4gICAgaWYgKG51bGwgIT09IHRhZykgcmV0dXJuIHRhZztcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMgPVxuICAgIFJlYWN0RE9NLl9fRE9NX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgc2hhcmVkTm90UGVuZGluZ09iamVjdCA9IHtcbiAgICBwZW5kaW5nOiAhMSxcbiAgICBkYXRhOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBhY3Rpb246IG51bGxcbiAgfSxcbiAgdmFsdWVTdGFjayA9IFtdLFxuICBpbmRleCA9IC0xO1xuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4geyBjdXJyZW50OiBkZWZhdWx0VmFsdWUgfTtcbn1cbmZ1bmN0aW9uIHBvcChjdXJzb3IpIHtcbiAgMCA+IGluZGV4IHx8XG4gICAgKChjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdKSwgKHZhbHVlU3RhY2tbaW5kZXhdID0gbnVsbCksIGluZGV4LS0pO1xufVxuZnVuY3Rpb24gcHVzaChjdXJzb3IsIHZhbHVlKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpLFxuICBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKSxcbiAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlKTtcbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCk7XG4gIGZpYmVyID0gbmV4dFJvb3RJbnN0YW5jZS5ub2RlVHlwZTtcbiAgc3dpdGNoIChmaWJlcikge1xuICAgIGNhc2UgOTpcbiAgICBjYXNlIDExOlxuICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IChuZXh0Um9vdEluc3RhbmNlID0gbmV4dFJvb3RJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQpXG4gICAgICAgID8gKG5leHRSb290SW5zdGFuY2UgPSBuZXh0Um9vdEluc3RhbmNlLm5hbWVzcGFjZVVSSSlcbiAgICAgICAgICA/IGdldE93bkhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpXG4gICAgICAgICAgOiAwXG4gICAgICAgIDogMDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoXG4gICAgICAgICgoZmliZXIgPSA4ID09PSBmaWJlciA/IG5leHRSb290SW5zdGFuY2UucGFyZW50Tm9kZSA6IG5leHRSb290SW5zdGFuY2UpLFxuICAgICAgICAobmV4dFJvb3RJbnN0YW5jZSA9IGZpYmVyLnRhZ05hbWUpLFxuICAgICAgICAoZmliZXIgPSBmaWJlci5uYW1lc3BhY2VVUkkpKVxuICAgICAgKVxuICAgICAgICAoZmliZXIgPSBnZXRPd25Ib3N0Q29udGV4dChmaWJlcikpLFxuICAgICAgICAgIChuZXh0Um9vdEluc3RhbmNlID0gZ2V0Q2hpbGRIb3N0Q29udGV4dFByb2QoZmliZXIsIG5leHRSb290SW5zdGFuY2UpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgICAgICAgY2FzZSBcInN2Z1wiOlxuICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWF0aFwiOlxuICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbmV4dFJvb3RJbnN0YW5jZSA9IDA7XG4gICAgICAgIH1cbiAgfVxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcigpIHtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvcik7XG59XG5mdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJiBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyKTtcbiAgdmFyIGNvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IGdldENoaWxkSG9zdENvbnRleHRQcm9kKGNvbnRleHQsIGZpYmVyLnR5cGUpO1xuICBjb250ZXh0ICE9PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAocHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpLFxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpKTtcbn1cbmZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyICYmXG4gICAgKHBvcChjb250ZXh0U3RhY2tDdXJzb3IpLCBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IpKTtcbiAgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50ID09PSBmaWJlciAmJlxuICAgIChwb3AoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciksXG4gICAgKEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlID0gc2hhcmVkTm90UGVuZGluZ09iamVjdCkpO1xufVxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgc2NoZWR1bGVDYWxsYmFjayQzID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gIGNhbmNlbENhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2ssXG4gIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkLFxuICByZXF1ZXN0UGFpbnQgPSBTY2hlZHVsZXIudW5zdGFibGVfcmVxdWVzdFBhaW50LFxuICBub3cgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93LFxuICBnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IFNjaGVkdWxlci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCxcbiAgSW1tZWRpYXRlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksXG4gIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5LFxuICBOb3JtYWxQcmlvcml0eSQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICBMb3dQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Mb3dQcmlvcml0eSxcbiAgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eSxcbiAgbG9nJDEgPSBTY2hlZHVsZXIubG9nLFxuICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSA9IFNjaGVkdWxlci51bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSxcbiAgcmVuZGVyZXJJRCA9IG51bGwsXG4gIGluamVjdGVkSG9vayA9IG51bGw7XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdClcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJSb290KFxuICAgICAgICByZW5kZXJlcklELFxuICAgICAgICByb290LFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIDEyOCA9PT0gKHJvb3QuY3VycmVudC5mbGFncyAmIDEyOClcbiAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxufVxuZnVuY3Rpb24gc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMobmV3SXNTdHJpY3RNb2RlKSB7XG4gIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGxvZyQxICYmIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlKG5ld0lzU3RyaWN0TW9kZSk7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUpXG4gICAgdHJ5IHtcbiAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxufVxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrLFxuICBsb2cgPSBNYXRoLmxvZyxcbiAgTE4yID0gTWF0aC5MTjI7XG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgeCA+Pj49IDA7XG4gIHJldHVybiAwID09PSB4ID8gMzIgOiAoMzEgLSAoKGxvZyh4KSAvIExOMikgfCAwKSkgfCAwO1xufVxudmFyIG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCxcbiAgbmV4dFJldHJ5TGFuZSA9IDQxOTQzMDQ7XG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICB2YXIgcGVuZGluZ1N5bmNMYW5lcyA9IGxhbmVzICYgNDI7XG4gIGlmICgwICE9PSBwZW5kaW5nU3luY0xhbmVzKSByZXR1cm4gcGVuZGluZ1N5bmNMYW5lcztcbiAgc3dpdGNoIChsYW5lcyAmIC1sYW5lcykge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAxO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiAyO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiA0O1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiA4O1xuICAgIGNhc2UgMTY6XG4gICAgICByZXR1cm4gMTY7XG4gICAgY2FzZSAzMjpcbiAgICAgIHJldHVybiAzMjtcbiAgICBjYXNlIDY0OlxuICAgICAgcmV0dXJuIDY0O1xuICAgIGNhc2UgMTI4OlxuICAgIGNhc2UgMjU2OlxuICAgIGNhc2UgNTEyOlxuICAgIGNhc2UgMTAyNDpcbiAgICBjYXNlIDIwNDg6XG4gICAgY2FzZSA0MDk2OlxuICAgIGNhc2UgODE5MjpcbiAgICBjYXNlIDE2Mzg0OlxuICAgIGNhc2UgMzI3Njg6XG4gICAgY2FzZSA2NTUzNjpcbiAgICBjYXNlIDEzMTA3MjpcbiAgICBjYXNlIDI2MjE0NDpcbiAgICBjYXNlIDUyNDI4ODpcbiAgICBjYXNlIDEwNDg1NzY6XG4gICAgY2FzZSAyMDk3MTUyOlxuICAgICAgcmV0dXJuIGxhbmVzICYgNDE5NDE3NjtcbiAgICBjYXNlIDQxOTQzMDQ6XG4gICAgY2FzZSA4Mzg4NjA4OlxuICAgIGNhc2UgMTY3NzcyMTY6XG4gICAgY2FzZSAzMzU1NDQzMjpcbiAgICAgIHJldHVybiBsYW5lcyAmIDYyOTE0NTYwO1xuICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgICByZXR1cm4gNjcxMDg4NjQ7XG4gICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgICByZXR1cm4gMTM0MjE3NzI4O1xuICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgcmV0dXJuIDI2ODQzNTQ1NjtcbiAgICBjYXNlIDUzNjg3MDkxMjpcbiAgICAgIHJldHVybiA1MzY4NzA5MTI7XG4gICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgcmV0dXJuIDA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBsYW5lcztcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcbiAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgcmV0dXJuIDA7XG4gIHZhciBuZXh0TGFuZXMgPSAwLFxuICAgIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcyxcbiAgICBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXMsXG4gICAgd2FybUxhbmVzID0gcm9vdC53YXJtTGFuZXM7XG4gIHJvb3QgPSAwICE9PSByb290LmZpbmlzaGVkTGFuZXM7XG4gIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgMTM0MjE3NzI3O1xuICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgPyAoKHBlbmRpbmdMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXMpLFxuICAgICAgMCAhPT0gcGVuZGluZ0xhbmVzXG4gICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKHBlbmRpbmdMYW5lcykpXG4gICAgICAgIDogKChwaW5nZWRMYW5lcyAmPSBub25JZGxlUGVuZGluZ0xhbmVzKSxcbiAgICAgICAgICAwICE9PSBwaW5nZWRMYW5lc1xuICAgICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgICAgOiByb290IHx8XG4gICAgICAgICAgICAgICgod2FybUxhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIH53YXJtTGFuZXMpLFxuICAgICAgICAgICAgICAwICE9PSB3YXJtTGFuZXMgJiZcbiAgICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKSlcbiAgICA6ICgobm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcyksXG4gICAgICAwICE9PSBub25JZGxlUGVuZGluZ0xhbmVzXG4gICAgICAgID8gKG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQZW5kaW5nTGFuZXMpKVxuICAgICAgICA6IDAgIT09IHBpbmdlZExhbmVzXG4gICAgICAgICAgPyAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpKVxuICAgICAgICAgIDogcm9vdCB8fFxuICAgICAgICAgICAgKCh3YXJtTGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+d2FybUxhbmVzKSxcbiAgICAgICAgICAgIDAgIT09IHdhcm1MYW5lcyAmJlxuICAgICAgICAgICAgICAobmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMod2FybUxhbmVzKSkpKTtcbiAgcmV0dXJuIDAgPT09IG5leHRMYW5lc1xuICAgID8gMFxuICAgIDogMCAhPT0gd2lwTGFuZXMgJiZcbiAgICAgICAgd2lwTGFuZXMgIT09IG5leHRMYW5lcyAmJlxuICAgICAgICAwID09PSAod2lwTGFuZXMgJiBzdXNwZW5kZWRMYW5lcykgJiZcbiAgICAgICAgKChzdXNwZW5kZWRMYW5lcyA9IG5leHRMYW5lcyAmIC1uZXh0TGFuZXMpLFxuICAgICAgICAod2FybUxhbmVzID0gd2lwTGFuZXMgJiAtd2lwTGFuZXMpLFxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA+PSB3YXJtTGFuZXMgfHxcbiAgICAgICAgICAoMzIgPT09IHN1c3BlbmRlZExhbmVzICYmIDAgIT09ICh3YXJtTGFuZXMgJiA0MTk0MTc2KSkpXG4gICAgICA/IHdpcExhbmVzXG4gICAgICA6IG5leHRMYW5lcztcbn1cbmZ1bmN0aW9uIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgcmV0dXJuIChcbiAgICAwID09PVxuICAgIChyb290LnBlbmRpbmdMYW5lcyAmXG4gICAgICB+KHJvb3Quc3VzcGVuZGVkTGFuZXMgJiB+cm9vdC5waW5nZWRMYW5lcykgJlxuICAgICAgcmVuZGVyTGFuZXMpXG4gICk7XG59XG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgc3dpdGNoIChsYW5lKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDQ6XG4gICAgY2FzZSA4OlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgMjUwO1xuICAgIGNhc2UgMTY6XG4gICAgY2FzZSAzMjpcbiAgICBjYXNlIDY0OlxuICAgIGNhc2UgMTI4OlxuICAgIGNhc2UgMjU2OlxuICAgIGNhc2UgNTEyOlxuICAgIGNhc2UgMTAyNDpcbiAgICBjYXNlIDIwNDg6XG4gICAgY2FzZSA0MDk2OlxuICAgIGNhc2UgODE5MjpcbiAgICBjYXNlIDE2Mzg0OlxuICAgIGNhc2UgMzI3Njg6XG4gICAgY2FzZSA2NTUzNjpcbiAgICBjYXNlIDEzMTA3MjpcbiAgICBjYXNlIDI2MjE0NDpcbiAgICBjYXNlIDUyNDI4ODpcbiAgICBjYXNlIDEwNDg1NzY6XG4gICAgY2FzZSAyMDk3MTUyOlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgNWUzO1xuICAgIGNhc2UgNDE5NDMwNDpcbiAgICBjYXNlIDgzODg2MDg6XG4gICAgY2FzZSAxNjc3NzIxNjpcbiAgICBjYXNlIDMzNTU0NDMyOlxuICAgICAgcmV0dXJuIC0xO1xuICAgIGNhc2UgNjcxMDg4NjQ6XG4gICAgY2FzZSAxMzQyMTc3Mjg6XG4gICAgY2FzZSAyNjg0MzU0NTY6XG4gICAgY2FzZSA1MzY4NzA5MTI6XG4gICAgY2FzZSAxMDczNzQxODI0OlxuICAgICAgcmV0dXJuIC0xO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuICAwID09PSAobmV4dFRyYW5zaXRpb25MYW5lICYgNDE5NDE3NikgJiYgKG5leHRUcmFuc2l0aW9uTGFuZSA9IDEyOCk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG4gIDAgPT09IChuZXh0UmV0cnlMYW5lICYgNjI5MTQ1NjApICYmIChuZXh0UmV0cnlMYW5lID0gNDE5NDMwNCk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY3JlYXRlTGFuZU1hcChpbml0aWFsKSB7XG4gIGZvciAodmFyIGxhbmVNYXAgPSBbXSwgaSA9IDA7IDMxID4gaTsgaSsrKSBsYW5lTWFwLnB1c2goaW5pdGlhbCk7XG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lO1xuICAyNjg0MzU0NTYgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAoKHJvb3Quc3VzcGVuZGVkTGFuZXMgPSAwKSwgKHJvb3QucGluZ2VkTGFuZXMgPSAwKSwgKHJvb3Qud2FybUxhbmVzID0gMCkpO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChcbiAgcm9vdCxcbiAgZmluaXNoZWRMYW5lcyxcbiAgcmVtYWluaW5nTGFuZXMsXG4gIHNwYXduZWRMYW5lLFxuICB1cGRhdGVkTGFuZXMsXG4gIHN1c3BlbmRlZFJldHJ5TGFuZXNcbikge1xuICB2YXIgcHJldmlvdXNseVBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICByb290LnBlbmRpbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LnN1c3BlbmRlZExhbmVzID0gMDtcbiAgcm9vdC5waW5nZWRMYW5lcyA9IDA7XG4gIHJvb3Qud2FybUxhbmVzID0gMDtcbiAgcm9vdC5leHBpcmVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG4gIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzLFxuICAgIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzLFxuICAgIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gIGZvciAoXG4gICAgcmVtYWluaW5nTGFuZXMgPSBwcmV2aW91c2x5UGVuZGluZ0xhbmVzICYgfnJlbWFpbmluZ0xhbmVzO1xuICAgIDAgPCByZW1haW5pbmdMYW5lcztcblxuICApIHtcbiAgICB2YXIgaW5kZXgkNyA9IDMxIC0gY2x6MzIocmVtYWluaW5nTGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNztcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4JDddID0gMDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXgkN10gPSAtMTtcbiAgICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4JDddO1xuICAgIGlmIChudWxsICE9PSBoaWRkZW5VcGRhdGVzRm9yTGFuZSlcbiAgICAgIGZvciAoXG4gICAgICAgIGhpZGRlblVwZGF0ZXNbaW5kZXgkN10gPSBudWxsLCBpbmRleCQ3ID0gMDtcbiAgICAgICAgaW5kZXgkNyA8IGhpZGRlblVwZGF0ZXNGb3JMYW5lLmxlbmd0aDtcbiAgICAgICAgaW5kZXgkNysrXG4gICAgICApIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGhpZGRlblVwZGF0ZXNGb3JMYW5lW2luZGV4JDddO1xuICAgICAgICBudWxsICE9PSB1cGRhdGUgJiYgKHVwZGF0ZS5sYW5lICY9IC01MzY4NzA5MTMpO1xuICAgICAgfVxuICAgIHJlbWFpbmluZ0xhbmVzICY9IH5sYW5lO1xuICB9XG4gIDAgIT09IHNwYXduZWRMYW5lICYmIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCAwKTtcbiAgMCAhPT0gc3VzcGVuZGVkUmV0cnlMYW5lcyAmJlxuICAgIDAgPT09IHVwZGF0ZWRMYW5lcyAmJlxuICAgIDAgIT09IHJvb3QudGFnICYmXG4gICAgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfD1cbiAgICAgIHN1c3BlbmRlZFJldHJ5TGFuZXMgJiB+KHByZXZpb3VzbHlQZW5kaW5nTGFuZXMgJiB+ZmluaXNoZWRMYW5lcykpO1xufVxuZnVuY3Rpb24gbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIGVudGFuZ2xlZExhbmVzKSB7XG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICByb290LnN1c3BlbmRlZExhbmVzICY9IH5zcGF3bmVkTGFuZTtcbiAgdmFyIHNwYXduZWRMYW5lSW5kZXggPSAzMSAtIGNsejMyKHNwYXduZWRMYW5lKTtcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdID1cbiAgICByb290LmVudGFuZ2xlbWVudHNbc3Bhd25lZExhbmVJbmRleF0gfFxuICAgIDEwNzM3NDE4MjQgfFxuICAgIChlbnRhbmdsZWRMYW5lcyAmIDQxOTQyMTgpO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgdmFyIHJvb3RFbnRhbmdsZWRMYW5lcyA9IChyb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzKTtcbiAgZm9yIChyb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzOyByb290RW50YW5nbGVkTGFuZXM7ICkge1xuICAgIHZhciBpbmRleCQ4ID0gMzEgLSBjbHozMihyb290RW50YW5nbGVkTGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkODtcbiAgICAobGFuZSAmIGVudGFuZ2xlZExhbmVzKSB8IChyb290W2luZGV4JDhdICYgZW50YW5nbGVkTGFuZXMpICYmXG4gICAgICAocm9vdFtpbmRleCQ4XSB8PSBlbnRhbmdsZWRMYW5lcyk7XG4gICAgcm9vdEVudGFuZ2xlZExhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICBsYW5lcyAmPSAtbGFuZXM7XG4gIHJldHVybiAyIDwgbGFuZXNcbiAgICA/IDggPCBsYW5lc1xuICAgICAgPyAwICE9PSAobGFuZXMgJiAxMzQyMTc3MjcpXG4gICAgICAgID8gMzJcbiAgICAgICAgOiAyNjg0MzU0NTZcbiAgICAgIDogOFxuICAgIDogMjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVVcGRhdGVQcmlvcml0eSgpIHtcbiAgdmFyIHVwZGF0ZVByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgaWYgKDAgIT09IHVwZGF0ZVByaW9yaXR5KSByZXR1cm4gdXBkYXRlUHJpb3JpdHk7XG4gIHVwZGF0ZVByaW9yaXR5ID0gd2luZG93LmV2ZW50O1xuICByZXR1cm4gdm9pZCAwID09PSB1cGRhdGVQcmlvcml0eSA/IDMyIDogZ2V0RXZlbnRQcmlvcml0eSh1cGRhdGVQcmlvcml0eS50eXBlKTtcbn1cbmZ1bmN0aW9uIHJ1bldpdGhQcmlvcml0eShwcmlvcml0eSwgZm4pIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIHJldHVybiAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByaW9yaXR5KSwgZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gcHJldmlvdXNQcmlvcml0eTtcbiAgfVxufVxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLFxuICBpbnRlcm5hbEluc3RhbmNlS2V5ID0gXCJfX3JlYWN0RmliZXIkXCIgKyByYW5kb21LZXksXG4gIGludGVybmFsUHJvcHNLZXkgPSBcIl9fcmVhY3RQcm9wcyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleSA9IFwiX19yZWFjdENvbnRhaW5lciRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gXCJfX3JlYWN0RXZlbnRzJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbEV2ZW50SGFuZGxlckxpc3RlbmVyc0tleSA9IFwiX19yZWFjdExpc3RlbmVycyRcIiArIHJhbmRvbUtleSxcbiAgaW50ZXJuYWxFdmVudEhhbmRsZXNTZXRLZXkgPSBcIl9fcmVhY3RIYW5kbGVzJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbFJvb3ROb2RlUmVzb3VyY2VzS2V5ID0gXCJfX3JlYWN0UmVzb3VyY2VzJFwiICsgcmFuZG9tS2V5LFxuICBpbnRlcm5hbEhvaXN0YWJsZU1hcmtlciA9IFwiX19yZWFjdE1hcmtlciRcIiArIHJhbmRvbUtleTtcbmZ1bmN0aW9uIGRldGFjaERlbGV0ZWRJbnN0YW5jZShub2RlKSB7XG4gIGRlbGV0ZSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbFByb3BzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XTtcbiAgZGVsZXRlIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJMaXN0ZW5lcnNLZXldO1xuICBkZWxldGUgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlc1NldEtleV07XG59XG5mdW5jdGlvbiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKHRhcmdldEluc3QpIHJldHVybiB0YXJnZXRJbnN0O1xuICBmb3IgKHZhciBwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZS5wYXJlbnROb2RlOyBwYXJlbnROb2RlOyApIHtcbiAgICBpZiAoXG4gICAgICAodGFyZ2V0SW5zdCA9XG4gICAgICAgIHBhcmVudE5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgcGFyZW50Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSlcbiAgICApIHtcbiAgICAgIHBhcmVudE5vZGUgPSB0YXJnZXRJbnN0LmFsdGVybmF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gdGFyZ2V0SW5zdC5jaGlsZCB8fFxuICAgICAgICAobnVsbCAhPT0gcGFyZW50Tm9kZSAmJiBudWxsICE9PSBwYXJlbnROb2RlLmNoaWxkKVxuICAgICAgKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuICAgICAgICAgIG51bGwgIT09IHRhcmdldE5vZGU7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKChwYXJlbnROb2RlID0gdGFyZ2V0Tm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkpIHJldHVybiBwYXJlbnROb2RlO1xuICAgICAgICAgIHRhcmdldE5vZGUgPSBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldE5vZGUpO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgICB9XG4gICAgdGFyZ2V0Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAoXG4gICAgKG5vZGUgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldIHx8IG5vZGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0pXG4gICkge1xuICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICBpZiAoXG4gICAgICA1ID09PSB0YWcgfHxcbiAgICAgIDYgPT09IHRhZyB8fFxuICAgICAgMTMgPT09IHRhZyB8fFxuICAgICAgMjYgPT09IHRhZyB8fFxuICAgICAgMjcgPT09IHRhZyB8fFxuICAgICAgMyA9PT0gdGFnXG4gICAgKVxuICAgICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpIHtcbiAgdmFyIHRhZyA9IGluc3QudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDI2ID09PSB0YWcgfHwgMjcgPT09IHRhZyB8fCA2ID09PSB0YWcpIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMykpO1xufVxuZnVuY3Rpb24gZ2V0UmVzb3VyY2VzRnJvbVJvb3Qocm9vdCkge1xuICB2YXIgcmVzb3VyY2VzID0gcm9vdFtpbnRlcm5hbFJvb3ROb2RlUmVzb3VyY2VzS2V5XTtcbiAgcmVzb3VyY2VzIHx8XG4gICAgKHJlc291cmNlcyA9IHJvb3RbaW50ZXJuYWxSb290Tm9kZVJlc291cmNlc0tleV0gPVxuICAgICAgeyBob2lzdGFibGVTdHlsZXM6IG5ldyBNYXAoKSwgaG9pc3RhYmxlU2NyaXB0czogbmV3IE1hcCgpIH0pO1xuICByZXR1cm4gcmVzb3VyY2VzO1xufVxuZnVuY3Rpb24gbWFya05vZGVBc0hvaXN0YWJsZShub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdID0gITA7XG59XG52YXIgYWxsTmF0aXZlRXZlbnRzID0gbmV3IFNldCgpLFxuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5mdW5jdGlvbiByZWdpc3RlclR3b1BoYXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKSB7XG4gIHJlZ2lzdGVyRGlyZWN0RXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgZGVwZW5kZW5jaWVzKTtcbiAgcmVnaXN0ZXJEaXJlY3RFdmVudChyZWdpc3RyYXRpb25OYW1lICsgXCJDYXB0dXJlXCIsIGRlcGVuZGVuY2llcyk7XG59XG5mdW5jdGlvbiByZWdpc3RlckRpcmVjdEV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGRlcGVuZGVuY2llcykge1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gZGVwZW5kZW5jaWVzO1xuICBmb3IgKFxuICAgIHJlZ2lzdHJhdGlvbk5hbWUgPSAwO1xuICAgIHJlZ2lzdHJhdGlvbk5hbWUgPCBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuICAgIHJlZ2lzdHJhdGlvbk5hbWUrK1xuICApXG4gICAgYWxsTmF0aXZlRXZlbnRzLmFkZChkZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0pO1xufVxudmFyIGNhblVzZURPTSA9ICEoXG4gICAgXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIHdpbmRvdyB8fFxuICAgIFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgfHxcbiAgICBcInVuZGVmaW5lZFwiID09PSB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnRcbiAgKSxcbiAgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBSZWdFeHAoXG4gICAgXCJeWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRdWzpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF0qJFwiXG4gICksXG4gIGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUgPSB7fSxcbiAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSByZXR1cm4gITE7XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKVxuICAgIHJldHVybiAodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITApO1xuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKVxuICAgIGlmIChudWxsID09PSB2YWx1ZSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZWxzZSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIHZhciBwcmVmaXgkMTAgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gICAgICAgICAgaWYgKFwiZGF0YS1cIiAhPT0gcHJlZml4JDEwICYmIFwiYXJpYS1cIiAhPT0gcHJlZml4JDEwKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBcIlwiICsgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKG51bGwgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgXCJcIiArIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKG5vZGUsIG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKG51bGwgPT09IHZhbHVlKSBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUsIFwiXCIgKyB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICByZXR1cm4gKFxuICAgIChlbGVtID0gZWxlbS5ub2RlTmFtZSkgJiZcbiAgICBcImlucHV0XCIgPT09IGVsZW0udG9Mb3dlckNhc2UoKSAmJlxuICAgIChcImNoZWNrYm94XCIgPT09IHR5cGUgfHwgXCJyYWRpb1wiID09PSB0eXBlKVxuICApO1xufVxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyBcImNoZWNrZWRcIiA6IFwidmFsdWVcIixcbiAgICBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgIG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLFxuICAgICAgdmFsdWVGaWVsZFxuICAgICksXG4gICAgY3VycmVudFZhbHVlID0gXCJcIiArIG5vZGVbdmFsdWVGaWVsZF07XG4gIGlmIChcbiAgICAhbm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSAmJlxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBkZXNjcmlwdG9yICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZGVzY3JpcHRvci5nZXQgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBkZXNjcmlwdG9yLnNldFxuICApIHtcbiAgICB2YXIgZ2V0ID0gZGVzY3JpcHRvci5nZXQsXG4gICAgICBzZXQgPSBkZXNjcmlwdG9yLnNldDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2V0LmNhbGwodGhpcyk7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY3VycmVudFZhbHVlID0gXCJcIiArIHZhbHVlO1xuICAgICAgfSxcbiAgICAgIHN0b3BUcmFja2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xuICAgICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciB8fCAobm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChub2RlKSB7XG4gIGlmICghbm9kZSkgcmV0dXJuICExO1xuICB2YXIgdHJhY2tlciA9IG5vZGUuX3ZhbHVlVHJhY2tlcjtcbiAgaWYgKCF0cmFja2VyKSByZXR1cm4gITA7XG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciB2YWx1ZSA9IFwiXCI7XG4gIG5vZGUgJiZcbiAgICAodmFsdWUgPSBpc0NoZWNrYWJsZShub2RlKVxuICAgICAgPyBub2RlLmNoZWNrZWRcbiAgICAgICAgPyBcInRydWVcIlxuICAgICAgICA6IFwiZmFsc2VcIlxuICAgICAgOiBub2RlLnZhbHVlKTtcbiAgbm9kZSA9IHZhbHVlO1xuICByZXR1cm4gbm9kZSAhPT0gbGFzdFZhbHVlID8gKHRyYWNrZXIuc2V0VmFsdWUobm9kZSksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8IChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudCA6IHZvaWQgMCk7XG4gIGlmIChcInVuZGVmaW5lZFwiID09PSB0eXBlb2YgZG9jKSByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cbnZhciBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzUmVnZXggPSAvW1xcblwiXFxcXF0vZztcbmZ1bmN0aW9uIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoXG4gICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3Rlc1JlZ2V4LFxuICAgIGZ1bmN0aW9uIChjaCkge1xuICAgICAgcmV0dXJuIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikgKyBcIiBcIjtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbnB1dChcbiAgZWxlbWVudCxcbiAgdmFsdWUsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgbGFzdERlZmF1bHRWYWx1ZSxcbiAgY2hlY2tlZCxcbiAgZGVmYXVsdENoZWNrZWQsXG4gIHR5cGUsXG4gIG5hbWVcbikge1xuICBlbGVtZW50Lm5hbWUgPSBcIlwiO1xuICBudWxsICE9IHR5cGUgJiZcbiAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICBcInN5bWJvbFwiICE9PSB0eXBlb2YgdHlwZSAmJlxuICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHR5cGVcbiAgICA/IChlbGVtZW50LnR5cGUgPSB0eXBlKVxuICAgIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuICBpZiAobnVsbCAhPSB2YWx1ZSlcbiAgICBpZiAoXCJudW1iZXJcIiA9PT0gdHlwZSkge1xuICAgICAgaWYgKCgwID09PSB2YWx1ZSAmJiBcIlwiID09PSBlbGVtZW50LnZhbHVlKSB8fCBlbGVtZW50LnZhbHVlICE9IHZhbHVlKVxuICAgICAgICBlbGVtZW50LnZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZVxuICAgICAgZWxlbWVudC52YWx1ZSAhPT0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpICYmXG4gICAgICAgIChlbGVtZW50LnZhbHVlID0gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgZWxzZVxuICAgIChcInN1Ym1pdFwiICE9PSB0eXBlICYmIFwicmVzZXRcIiAhPT0gdHlwZSkgfHwgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcbiAgbnVsbCAhPSB2YWx1ZVxuICAgID8gc2V0RGVmYXVsdFZhbHVlKGVsZW1lbnQsIHR5cGUsIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpKVxuICAgIDogbnVsbCAhPSBkZWZhdWx0VmFsdWVcbiAgICAgID8gc2V0RGVmYXVsdFZhbHVlKGVsZW1lbnQsIHR5cGUsIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSlcbiAgICAgIDogbnVsbCAhPSBsYXN0RGVmYXVsdFZhbHVlICYmIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XG4gIG51bGwgPT0gY2hlY2tlZCAmJlxuICAgIG51bGwgIT0gZGVmYXVsdENoZWNrZWQgJiZcbiAgICAoZWxlbWVudC5kZWZhdWx0Q2hlY2tlZCA9ICEhZGVmYXVsdENoZWNrZWQpO1xuICBudWxsICE9IGNoZWNrZWQgJiZcbiAgICAoZWxlbWVudC5jaGVja2VkID1cbiAgICAgIGNoZWNrZWQgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hlY2tlZCk7XG4gIG51bGwgIT0gbmFtZSAmJlxuICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gIFwic3ltYm9sXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gIFwiYm9vbGVhblwiICE9PSB0eXBlb2YgbmFtZVxuICAgID8gKGVsZW1lbnQubmFtZSA9IFwiXCIgKyBnZXRUb1N0cmluZ1ZhbHVlKG5hbWUpKVxuICAgIDogZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJuYW1lXCIpO1xufVxuZnVuY3Rpb24gaW5pdElucHV0KFxuICBlbGVtZW50LFxuICB2YWx1ZSxcbiAgZGVmYXVsdFZhbHVlLFxuICBjaGVja2VkLFxuICBkZWZhdWx0Q2hlY2tlZCxcbiAgdHlwZSxcbiAgbmFtZSxcbiAgaXNIeWRyYXRpbmdcbikge1xuICBudWxsICE9IHR5cGUgJiZcbiAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICAoZWxlbWVudC50eXBlID0gdHlwZSk7XG4gIGlmIChudWxsICE9IHZhbHVlIHx8IG51bGwgIT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgKFwic3VibWl0XCIgIT09IHR5cGUgJiYgXCJyZXNldFwiICE9PSB0eXBlKSB8fFxuICAgICAgICAodm9pZCAwICE9PSB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSlcbiAgICAgIClcbiAgICApXG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdFZhbHVlID1cbiAgICAgIG51bGwgIT0gZGVmYXVsdFZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUoZGVmYXVsdFZhbHVlKSA6IFwiXCI7XG4gICAgdmFsdWUgPSBudWxsICE9IHZhbHVlID8gXCJcIiArIGdldFRvU3RyaW5nVmFsdWUodmFsdWUpIDogZGVmYXVsdFZhbHVlO1xuICAgIGlzSHlkcmF0aW5nIHx8IHZhbHVlID09PSBlbGVtZW50LnZhbHVlIHx8IChlbGVtZW50LnZhbHVlID0gdmFsdWUpO1xuICAgIGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgY2hlY2tlZCA9IG51bGwgIT0gY2hlY2tlZCA/IGNoZWNrZWQgOiBkZWZhdWx0Q2hlY2tlZDtcbiAgY2hlY2tlZCA9XG4gICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgY2hlY2tlZCAmJiAhIWNoZWNrZWQ7XG4gIGVsZW1lbnQuY2hlY2tlZCA9IGlzSHlkcmF0aW5nID8gZWxlbWVudC5jaGVja2VkIDogISFjaGVja2VkO1xuICBlbGVtZW50LmRlZmF1bHRDaGVja2VkID0gISFjaGVja2VkO1xuICBudWxsICE9IG5hbWUgJiZcbiAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBuYW1lICYmXG4gICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICBcImJvb2xlYW5cIiAhPT0gdHlwZW9mIG5hbWUgJiZcbiAgICAoZWxlbWVudC5uYW1lID0gbmFtZSk7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0VmFsdWUobm9kZSwgdHlwZSwgdmFsdWUpIHtcbiAgKFwibnVtYmVyXCIgPT09IHR5cGUgJiYgZ2V0QWN0aXZlRWxlbWVudChub2RlLm93bmVyRG9jdW1lbnQpID09PSBub2RlKSB8fFxuICAgIG5vZGUuZGVmYXVsdFZhbHVlID09PSBcIlwiICsgdmFsdWUgfHxcbiAgICAobm9kZS5kZWZhdWx0VmFsdWUgPSBcIlwiICsgdmFsdWUpO1xufVxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgbm9kZSA9IG5vZGUub3B0aW9ucztcbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgbXVsdGlwbGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgIG11bHRpcGxlW1wiJFwiICsgcHJvcFZhbHVlW2ldXSA9ICEwO1xuICAgIGZvciAocHJvcFZhbHVlID0gMDsgcHJvcFZhbHVlIDwgbm9kZS5sZW5ndGg7IHByb3BWYWx1ZSsrKVxuICAgICAgKGkgPSBtdWx0aXBsZS5oYXNPd25Qcm9wZXJ0eShcIiRcIiArIG5vZGVbcHJvcFZhbHVlXS52YWx1ZSkpLFxuICAgICAgICBub2RlW3Byb3BWYWx1ZV0uc2VsZWN0ZWQgIT09IGkgJiYgKG5vZGVbcHJvcFZhbHVlXS5zZWxlY3RlZCA9IGkpLFxuICAgICAgICBpICYmIHNldERlZmF1bHRTZWxlY3RlZCAmJiAobm9kZVtwcm9wVmFsdWVdLmRlZmF1bHRTZWxlY3RlZCA9ICEwKTtcbiAgfSBlbHNlIHtcbiAgICBwcm9wVmFsdWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wVmFsdWUpO1xuICAgIG11bHRpcGxlID0gbnVsbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKG5vZGVbaV0udmFsdWUgPT09IHByb3BWYWx1ZSkge1xuICAgICAgICBub2RlW2ldLnNlbGVjdGVkID0gITA7XG4gICAgICAgIHNldERlZmF1bHRTZWxlY3RlZCAmJiAobm9kZVtpXS5kZWZhdWx0U2VsZWN0ZWQgPSAhMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG51bGwgIT09IG11bHRpcGxlIHx8IG5vZGVbaV0uZGlzYWJsZWQgfHwgKG11bHRpcGxlID0gbm9kZVtpXSk7XG4gICAgfVxuICAgIG51bGwgIT09IG11bHRpcGxlICYmIChtdWx0aXBsZS5zZWxlY3RlZCA9ICEwKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlVGV4dGFyZWEoZWxlbWVudCwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAoXG4gICAgbnVsbCAhPSB2YWx1ZSAmJlxuICAgICgodmFsdWUgPSBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSkpLFxuICAgIHZhbHVlICE9PSBlbGVtZW50LnZhbHVlICYmIChlbGVtZW50LnZhbHVlID0gdmFsdWUpLFxuICAgIG51bGwgPT0gZGVmYXVsdFZhbHVlKVxuICApIHtcbiAgICBlbGVtZW50LmRlZmF1bHRWYWx1ZSAhPT0gdmFsdWUgJiYgKGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICBlbGVtZW50LmRlZmF1bHRWYWx1ZSA9XG4gICAgbnVsbCAhPSBkZWZhdWx0VmFsdWUgPyBcIlwiICsgZ2V0VG9TdHJpbmdWYWx1ZShkZWZhdWx0VmFsdWUpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIGluaXRUZXh0YXJlYShlbGVtZW50LCB2YWx1ZSwgZGVmYXVsdFZhbHVlLCBjaGlsZHJlbikge1xuICBpZiAobnVsbCA9PSB2YWx1ZSkge1xuICAgIGlmIChudWxsICE9IGNoaWxkcmVuKSB7XG4gICAgICBpZiAobnVsbCAhPSBkZWZhdWx0VmFsdWUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOTIpKTtcbiAgICAgIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpIHtcbiAgICAgICAgaWYgKDEgPCBjaGlsZHJlbi5sZW5ndGgpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoOTMpKTtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHRWYWx1ZSA9IGNoaWxkcmVuO1xuICAgIH1cbiAgICBudWxsID09IGRlZmF1bHRWYWx1ZSAmJiAoZGVmYXVsdFZhbHVlID0gXCJcIik7XG4gICAgdmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cbiAgZGVmYXVsdFZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZSh2YWx1ZSk7XG4gIGVsZW1lbnQuZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICBjaGlsZHJlbiA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XG4gIGNoaWxkcmVuID09PSBkZWZhdWx0VmFsdWUgJiZcbiAgICBcIlwiICE9PSBjaGlsZHJlbiAmJlxuICAgIG51bGwgIT09IGNoaWxkcmVuICYmXG4gICAgKGVsZW1lbnQudmFsdWUgPSBjaGlsZHJlbik7XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgaWYgKFxuICAgICAgZmlyc3RDaGlsZCAmJlxuICAgICAgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiZcbiAgICAgIDMgPT09IGZpcnN0Q2hpbGQubm9kZVR5cGVcbiAgICApIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG52YXIgdW5pdGxlc3NOdW1iZXJzID0gbmV3IFNldChcbiAgXCJhbmltYXRpb25JdGVyYXRpb25Db3VudCBhc3BlY3RSYXRpbyBib3JkZXJJbWFnZU91dHNldCBib3JkZXJJbWFnZVNsaWNlIGJvcmRlckltYWdlV2lkdGggYm94RmxleCBib3hGbGV4R3JvdXAgYm94T3JkaW5hbEdyb3VwIGNvbHVtbkNvdW50IGNvbHVtbnMgZmxleCBmbGV4R3JvdyBmbGV4UG9zaXRpdmUgZmxleFNocmluayBmbGV4TmVnYXRpdmUgZmxleE9yZGVyIGdyaWRBcmVhIGdyaWRSb3cgZ3JpZFJvd0VuZCBncmlkUm93U3BhbiBncmlkUm93U3RhcnQgZ3JpZENvbHVtbiBncmlkQ29sdW1uRW5kIGdyaWRDb2x1bW5TcGFuIGdyaWRDb2x1bW5TdGFydCBmb250V2VpZ2h0IGxpbmVDbGFtcCBsaW5lSGVpZ2h0IG9wYWNpdHkgb3JkZXIgb3JwaGFucyBzY2FsZSB0YWJTaXplIHdpZG93cyB6SW5kZXggem9vbSBmaWxsT3BhY2l0eSBmbG9vZE9wYWNpdHkgc3RvcE9wYWNpdHkgc3Ryb2tlRGFzaGFycmF5IHN0cm9rZURhc2hvZmZzZXQgc3Ryb2tlTWl0ZXJsaW1pdCBzdHJva2VPcGFjaXR5IHN0cm9rZVdpZHRoIE1vekFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IE1vekJveEZsZXggTW96Qm94RmxleEdyb3VwIE1vekxpbmVDbGFtcCBtc0FuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IG1zRmxleCBtc1pvb20gbXNGbGV4R3JvdyBtc0ZsZXhOZWdhdGl2ZSBtc0ZsZXhPcmRlciBtc0ZsZXhQb3NpdGl2ZSBtc0ZsZXhTaHJpbmsgbXNHcmlkQ29sdW1uIG1zR3JpZENvbHVtblNwYW4gbXNHcmlkUm93IG1zR3JpZFJvd1NwYW4gV2Via2l0QW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgV2Via2l0Qm94RmxleCBXZWJLaXRCb3hGbGV4R3JvdXAgV2Via2l0Qm94T3JkaW5hbEdyb3VwIFdlYmtpdENvbHVtbkNvdW50IFdlYmtpdENvbHVtbnMgV2Via2l0RmxleCBXZWJraXRGbGV4R3JvdyBXZWJraXRGbGV4UG9zaXRpdmUgV2Via2l0RmxleFNocmluayBXZWJraXRMaW5lQ2xhbXBcIi5zcGxpdChcbiAgICBcIiBcIlxuICApXG4pO1xuZnVuY3Rpb24gc2V0VmFsdWVGb3JTdHlsZShzdHlsZSwgc3R5bGVOYW1lLCB2YWx1ZSkge1xuICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IDAgPT09IHN0eWxlTmFtZS5pbmRleE9mKFwiLS1cIik7XG4gIG51bGwgPT0gdmFsdWUgfHwgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcIlwiID09PSB2YWx1ZVxuICAgID8gaXNDdXN0b21Qcm9wZXJ0eVxuICAgICAgPyBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIFwiXCIpXG4gICAgICA6IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgID8gKHN0eWxlLmNzc0Zsb2F0ID0gXCJcIilcbiAgICAgICAgOiAoc3R5bGVbc3R5bGVOYW1lXSA9IFwiXCIpXG4gICAgOiBpc0N1c3RvbVByb3BlcnR5XG4gICAgICA/IHN0eWxlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgdmFsdWUpXG4gICAgICA6IFwibnVtYmVyXCIgIT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICAgIDAgPT09IHZhbHVlIHx8XG4gICAgICAgICAgdW5pdGxlc3NOdW1iZXJzLmhhcyhzdHlsZU5hbWUpXG4gICAgICAgID8gXCJmbG9hdFwiID09PSBzdHlsZU5hbWVcbiAgICAgICAgICA/IChzdHlsZS5jc3NGbG9hdCA9IHZhbHVlKVxuICAgICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSAoXCJcIiArIHZhbHVlKS50cmltKCkpXG4gICAgICAgIDogKHN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZSArIFwicHhcIik7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMsIHByZXZTdHlsZXMpIHtcbiAgaWYgKG51bGwgIT0gc3R5bGVzICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiBzdHlsZXMpXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MikpO1xuICBub2RlID0gbm9kZS5zdHlsZTtcbiAgaWYgKG51bGwgIT0gcHJldlN0eWxlcykge1xuICAgIGZvciAodmFyIHN0eWxlTmFtZSBpbiBwcmV2U3R5bGVzKVxuICAgICAgIXByZXZTdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSB8fFxuICAgICAgICAobnVsbCAhPSBzdHlsZXMgJiYgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHx8XG4gICAgICAgICgwID09PSBzdHlsZU5hbWUuaW5kZXhPZihcIi0tXCIpXG4gICAgICAgICAgPyBub2RlLnNldFByb3BlcnR5KHN0eWxlTmFtZSwgXCJcIilcbiAgICAgICAgICA6IFwiZmxvYXRcIiA9PT0gc3R5bGVOYW1lXG4gICAgICAgICAgICA/IChub2RlLmNzc0Zsb2F0ID0gXCJcIilcbiAgICAgICAgICAgIDogKG5vZGVbc3R5bGVOYW1lXSA9IFwiXCIpKTtcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUkMTYgaW4gc3R5bGVzKVxuICAgICAgKHN0eWxlTmFtZSA9IHN0eWxlc1tzdHlsZU5hbWUkMTZdKSxcbiAgICAgICAgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSQxNikgJiZcbiAgICAgICAgICBwcmV2U3R5bGVzW3N0eWxlTmFtZSQxNl0gIT09IHN0eWxlTmFtZSAmJlxuICAgICAgICAgIHNldFZhbHVlRm9yU3R5bGUobm9kZSwgc3R5bGVOYW1lJDE2LCBzdHlsZU5hbWUpO1xuICB9IGVsc2VcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUkMTcgaW4gc3R5bGVzKVxuICAgICAgc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSQxNykgJiZcbiAgICAgICAgc2V0VmFsdWVGb3JTdHlsZShub2RlLCBzdHlsZU5hbWUkMTcsIHN0eWxlc1tzdHlsZU5hbWUkMTddKTtcbn1cbmZ1bmN0aW9uIGlzQ3VzdG9tRWxlbWVudCh0YWdOYW1lKSB7XG4gIGlmICgtMSA9PT0gdGFnTmFtZS5pbmRleE9mKFwiLVwiKSkgcmV0dXJuICExO1xuICBzd2l0Y2ggKHRhZ05hbWUpIHtcbiAgICBjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpcbiAgICBjYXNlIFwiY29sb3ItcHJvZmlsZVwiOlxuICAgIGNhc2UgXCJmb250LWZhY2VcIjpcbiAgICBjYXNlIFwiZm9udC1mYWNlLXNyY1wiOlxuICAgIGNhc2UgXCJmb250LWZhY2UtdXJpXCI6XG4gICAgY2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpcbiAgICBjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpcbiAgICBjYXNlIFwibWlzc2luZy1nbHlwaFwiOlxuICAgICAgcmV0dXJuICExO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gITA7XG4gIH1cbn1cbnZhciBhbGlhc2VzID0gbmV3IE1hcChbXG4gICAgW1wiYWNjZXB0Q2hhcnNldFwiLCBcImFjY2VwdC1jaGFyc2V0XCJdLFxuICAgIFtcImh0bWxGb3JcIiwgXCJmb3JcIl0sXG4gICAgW1wiaHR0cEVxdWl2XCIsIFwiaHR0cC1lcXVpdlwiXSxcbiAgICBbXCJjcm9zc09yaWdpblwiLCBcImNyb3Nzb3JpZ2luXCJdLFxuICAgIFtcImFjY2VudEhlaWdodFwiLCBcImFjY2VudC1oZWlnaHRcIl0sXG4gICAgW1wiYWxpZ25tZW50QmFzZWxpbmVcIiwgXCJhbGlnbm1lbnQtYmFzZWxpbmVcIl0sXG4gICAgW1wiYXJhYmljRm9ybVwiLCBcImFyYWJpYy1mb3JtXCJdLFxuICAgIFtcImJhc2VsaW5lU2hpZnRcIiwgXCJiYXNlbGluZS1zaGlmdFwiXSxcbiAgICBbXCJjYXBIZWlnaHRcIiwgXCJjYXAtaGVpZ2h0XCJdLFxuICAgIFtcImNsaXBQYXRoXCIsIFwiY2xpcC1wYXRoXCJdLFxuICAgIFtcImNsaXBSdWxlXCIsIFwiY2xpcC1ydWxlXCJdLFxuICAgIFtcImNvbG9ySW50ZXJwb2xhdGlvblwiLCBcImNvbG9yLWludGVycG9sYXRpb25cIl0sXG4gICAgW1wiY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyc1wiLCBcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiXSxcbiAgICBbXCJjb2xvclByb2ZpbGVcIiwgXCJjb2xvci1wcm9maWxlXCJdLFxuICAgIFtcImNvbG9yUmVuZGVyaW5nXCIsIFwiY29sb3ItcmVuZGVyaW5nXCJdLFxuICAgIFtcImRvbWluYW50QmFzZWxpbmVcIiwgXCJkb21pbmFudC1iYXNlbGluZVwiXSxcbiAgICBbXCJlbmFibGVCYWNrZ3JvdW5kXCIsIFwiZW5hYmxlLWJhY2tncm91bmRcIl0sXG4gICAgW1wiZmlsbE9wYWNpdHlcIiwgXCJmaWxsLW9wYWNpdHlcIl0sXG4gICAgW1wiZmlsbFJ1bGVcIiwgXCJmaWxsLXJ1bGVcIl0sXG4gICAgW1wiZmxvb2RDb2xvclwiLCBcImZsb29kLWNvbG9yXCJdLFxuICAgIFtcImZsb29kT3BhY2l0eVwiLCBcImZsb29kLW9wYWNpdHlcIl0sXG4gICAgW1wiZm9udEZhbWlseVwiLCBcImZvbnQtZmFtaWx5XCJdLFxuICAgIFtcImZvbnRTaXplXCIsIFwiZm9udC1zaXplXCJdLFxuICAgIFtcImZvbnRTaXplQWRqdXN0XCIsIFwiZm9udC1zaXplLWFkanVzdFwiXSxcbiAgICBbXCJmb250U3RyZXRjaFwiLCBcImZvbnQtc3RyZXRjaFwiXSxcbiAgICBbXCJmb250U3R5bGVcIiwgXCJmb250LXN0eWxlXCJdLFxuICAgIFtcImZvbnRWYXJpYW50XCIsIFwiZm9udC12YXJpYW50XCJdLFxuICAgIFtcImZvbnRXZWlnaHRcIiwgXCJmb250LXdlaWdodFwiXSxcbiAgICBbXCJnbHlwaE5hbWVcIiwgXCJnbHlwaC1uYW1lXCJdLFxuICAgIFtcImdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsXCIsIFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiXSxcbiAgICBbXCJnbHlwaE9yaWVudGF0aW9uVmVydGljYWxcIiwgXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiXSxcbiAgICBbXCJob3JpekFkdlhcIiwgXCJob3Jpei1hZHYteFwiXSxcbiAgICBbXCJob3Jpek9yaWdpblhcIiwgXCJob3Jpei1vcmlnaW4teFwiXSxcbiAgICBbXCJpbWFnZVJlbmRlcmluZ1wiLCBcImltYWdlLXJlbmRlcmluZ1wiXSxcbiAgICBbXCJsZXR0ZXJTcGFjaW5nXCIsIFwibGV0dGVyLXNwYWNpbmdcIl0sXG4gICAgW1wibGlnaHRpbmdDb2xvclwiLCBcImxpZ2h0aW5nLWNvbG9yXCJdLFxuICAgIFtcIm1hcmtlckVuZFwiLCBcIm1hcmtlci1lbmRcIl0sXG4gICAgW1wibWFya2VyTWlkXCIsIFwibWFya2VyLW1pZFwiXSxcbiAgICBbXCJtYXJrZXJTdGFydFwiLCBcIm1hcmtlci1zdGFydFwiXSxcbiAgICBbXCJvdmVybGluZVBvc2l0aW9uXCIsIFwib3ZlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgW1wib3ZlcmxpbmVUaGlja25lc3NcIiwgXCJvdmVybGluZS10aGlja25lc3NcIl0sXG4gICAgW1wicGFpbnRPcmRlclwiLCBcInBhaW50LW9yZGVyXCJdLFxuICAgIFtcInBhbm9zZS0xXCIsIFwicGFub3NlLTFcIl0sXG4gICAgW1wicG9pbnRlckV2ZW50c1wiLCBcInBvaW50ZXItZXZlbnRzXCJdLFxuICAgIFtcInJlbmRlcmluZ0ludGVudFwiLCBcInJlbmRlcmluZy1pbnRlbnRcIl0sXG4gICAgW1wic2hhcGVSZW5kZXJpbmdcIiwgXCJzaGFwZS1yZW5kZXJpbmdcIl0sXG4gICAgW1wic3RvcENvbG9yXCIsIFwic3RvcC1jb2xvclwiXSxcbiAgICBbXCJzdG9wT3BhY2l0eVwiLCBcInN0b3Atb3BhY2l0eVwiXSxcbiAgICBbXCJzdHJpa2V0aHJvdWdoUG9zaXRpb25cIiwgXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCJdLFxuICAgIFtcInN0cmlrZXRocm91Z2hUaGlja25lc3NcIiwgXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiXSxcbiAgICBbXCJzdHJva2VEYXNoYXJyYXlcIiwgXCJzdHJva2UtZGFzaGFycmF5XCJdLFxuICAgIFtcInN0cm9rZURhc2hvZmZzZXRcIiwgXCJzdHJva2UtZGFzaG9mZnNldFwiXSxcbiAgICBbXCJzdHJva2VMaW5lY2FwXCIsIFwic3Ryb2tlLWxpbmVjYXBcIl0sXG4gICAgW1wic3Ryb2tlTGluZWpvaW5cIiwgXCJzdHJva2UtbGluZWpvaW5cIl0sXG4gICAgW1wic3Ryb2tlTWl0ZXJsaW1pdFwiLCBcInN0cm9rZS1taXRlcmxpbWl0XCJdLFxuICAgIFtcInN0cm9rZU9wYWNpdHlcIiwgXCJzdHJva2Utb3BhY2l0eVwiXSxcbiAgICBbXCJzdHJva2VXaWR0aFwiLCBcInN0cm9rZS13aWR0aFwiXSxcbiAgICBbXCJ0ZXh0QW5jaG9yXCIsIFwidGV4dC1hbmNob3JcIl0sXG4gICAgW1widGV4dERlY29yYXRpb25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIl0sXG4gICAgW1widGV4dFJlbmRlcmluZ1wiLCBcInRleHQtcmVuZGVyaW5nXCJdLFxuICAgIFtcInRyYW5zZm9ybU9yaWdpblwiLCBcInRyYW5zZm9ybS1vcmlnaW5cIl0sXG4gICAgW1widW5kZXJsaW5lUG9zaXRpb25cIiwgXCJ1bmRlcmxpbmUtcG9zaXRpb25cIl0sXG4gICAgW1widW5kZXJsaW5lVGhpY2tuZXNzXCIsIFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiXSxcbiAgICBbXCJ1bmljb2RlQmlkaVwiLCBcInVuaWNvZGUtYmlkaVwiXSxcbiAgICBbXCJ1bmljb2RlUmFuZ2VcIiwgXCJ1bmljb2RlLXJhbmdlXCJdLFxuICAgIFtcInVuaXRzUGVyRW1cIiwgXCJ1bml0cy1wZXItZW1cIl0sXG4gICAgW1widkFscGhhYmV0aWNcIiwgXCJ2LWFscGhhYmV0aWNcIl0sXG4gICAgW1widkhhbmdpbmdcIiwgXCJ2LWhhbmdpbmdcIl0sXG4gICAgW1widklkZW9ncmFwaGljXCIsIFwidi1pZGVvZ3JhcGhpY1wiXSxcbiAgICBbXCJ2TWF0aGVtYXRpY2FsXCIsIFwidi1tYXRoZW1hdGljYWxcIl0sXG4gICAgW1widmVjdG9yRWZmZWN0XCIsIFwidmVjdG9yLWVmZmVjdFwiXSxcbiAgICBbXCJ2ZXJ0QWR2WVwiLCBcInZlcnQtYWR2LXlcIl0sXG4gICAgW1widmVydE9yaWdpblhcIiwgXCJ2ZXJ0LW9yaWdpbi14XCJdLFxuICAgIFtcInZlcnRPcmlnaW5ZXCIsIFwidmVydC1vcmlnaW4teVwiXSxcbiAgICBbXCJ3b3JkU3BhY2luZ1wiLCBcIndvcmQtc3BhY2luZ1wiXSxcbiAgICBbXCJ3cml0aW5nTW9kZVwiLCBcIndyaXRpbmctbW9kZVwiXSxcbiAgICBbXCJ4bWxuc1hsaW5rXCIsIFwieG1sbnM6eGxpbmtcIl0sXG4gICAgW1wieEhlaWdodFwiLCBcIngtaGVpZ2h0XCJdXG4gIF0pLFxuICBpc0phdmFTY3JpcHRQcm90b2NvbCA9XG4gICAgL15bXFx1MDAwMC1cXHUwMDFGIF0qaltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSp2W1xcclxcblxcdF0qYVtcXHJcXG5cXHRdKnNbXFxyXFxuXFx0XSpjW1xcclxcblxcdF0qcltcXHJcXG5cXHRdKmlbXFxyXFxuXFx0XSpwW1xcclxcblxcdF0qdFtcXHJcXG5cXHRdKjovaTtcbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICByZXR1cm4gaXNKYXZhU2NyaXB0UHJvdG9jb2wudGVzdChcIlwiICsgdXJsKVxuICAgID8gXCJqYXZhc2NyaXB0OnRocm93IG5ldyBFcnJvcignUmVhY3QgaGFzIGJsb2NrZWQgYSBqYXZhc2NyaXB0OiBVUkwgYXMgYSBzZWN1cml0eSBwcmVjYXV0aW9uLicpXCJcbiAgICA6IHVybDtcbn1cbnZhciBjdXJyZW50UmVwbGF5aW5nRXZlbnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgbmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG4gIG5hdGl2ZUV2ZW50LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50ICYmXG4gICAgKG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO1xuICByZXR1cm4gMyA9PT0gbmF0aXZlRXZlbnQubm9kZVR5cGUgPyBuYXRpdmVFdmVudC5wYXJlbnROb2RlIDogbmF0aXZlRXZlbnQ7XG59XG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGwsXG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmIChpbnRlcm5hbEluc3RhbmNlICYmICh0YXJnZXQgPSBpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSkpIHtcbiAgICB2YXIgcHJvcHMgPSB0YXJnZXRbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgICBhOiBzd2l0Y2ggKCgodGFyZ2V0ID0gaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUpKSB7XG4gICAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgICAgdXBkYXRlSW5wdXQoXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICAgIHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgICAgcHJvcHMuY2hlY2tlZCxcbiAgICAgICAgICBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgICBwcm9wcy50eXBlLFxuICAgICAgICAgIHByb3BzLm5hbWVcbiAgICAgICAgKTtcbiAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IHByb3BzLm5hbWU7XG4gICAgICAgIGlmIChcInJhZGlvXCIgPT09IHByb3BzLnR5cGUgJiYgbnVsbCAhPSBpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICAgICAgZm9yIChwcm9wcyA9IHRhcmdldDsgcHJvcHMucGFyZW50Tm9kZTsgKSBwcm9wcyA9IHByb3BzLnBhcmVudE5vZGU7XG4gICAgICAgICAgcHJvcHMgPSBwcm9wcy5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgICAgJ2lucHV0W25hbWU9XCInICtcbiAgICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhcbiAgICAgICAgICAgICAgICBcIlwiICsgaW50ZXJuYWxJbnN0YW5jZVxuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJ1wiXVt0eXBlPVwicmFkaW9cIl0nXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSA9IDA7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlIDwgcHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZSsrXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJOb2RlID0gcHJvcHNbaW50ZXJuYWxJbnN0YW5jZV07XG4gICAgICAgICAgICBpZiAob3RoZXJOb2RlICE9PSB0YXJnZXQgJiYgb3RoZXJOb2RlLmZvcm0gPT09IHRhcmdldC5mb3JtKSB7XG4gICAgICAgICAgICAgIHZhciBvdGhlclByb3BzID0gb3RoZXJOb2RlW2ludGVybmFsUHJvcHNLZXldIHx8IG51bGw7XG4gICAgICAgICAgICAgIGlmICghb3RoZXJQcm9wcykgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg5MCkpO1xuICAgICAgICAgICAgICB1cGRhdGVJbnB1dChcbiAgICAgICAgICAgICAgICBvdGhlck5vZGUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLmNoZWNrZWQsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICAgICAgICAgICAgICBvdGhlclByb3BzLnR5cGUsXG4gICAgICAgICAgICAgICAgb3RoZXJQcm9wcy5uYW1lXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlID0gMDtcbiAgICAgICAgICAgIGludGVybmFsSW5zdGFuY2UgPCBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlKytcbiAgICAgICAgICApXG4gICAgICAgICAgICAob3RoZXJOb2RlID0gcHJvcHNbaW50ZXJuYWxJbnN0YW5jZV0pLFxuICAgICAgICAgICAgICBvdGhlck5vZGUuZm9ybSA9PT0gdGFyZ2V0LmZvcm0gJiYgdXBkYXRlVmFsdWVJZkNoYW5nZWQob3RoZXJOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhayBhO1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIHVwZGF0ZVRleHRhcmVhKHRhcmdldCwgcHJvcHMudmFsdWUsIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIGJyZWFrIGE7XG4gICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgIChpbnRlcm5hbEluc3RhbmNlID0gcHJvcHMudmFsdWUpLFxuICAgICAgICAgIG51bGwgIT0gaW50ZXJuYWxJbnN0YW5jZSAmJlxuICAgICAgICAgICAgdXBkYXRlT3B0aW9ucyh0YXJnZXQsICEhcHJvcHMubXVsdGlwbGUsIGludGVybmFsSW5zdGFuY2UsICExKTtcbiAgICB9XG4gIH1cbn1cbnZhciBpc0luc2lkZUV2ZW50SGFuZGxlciA9ICExO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSwgYikge1xuICBpZiAoaXNJbnNpZGVFdmVudEhhbmRsZXIpIHJldHVybiBmbihhLCBiKTtcbiAgaXNJbnNpZGVFdmVudEhhbmRsZXIgPSAhMDtcbiAgdHJ5IHtcbiAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZm4oYSk7XG4gICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoXG4gICAgICAoKGlzSW5zaWRlRXZlbnRIYW5kbGVyID0gITEpLFxuICAgICAgbnVsbCAhPT0gcmVzdG9yZVRhcmdldCB8fCBudWxsICE9PSByZXN0b3JlUXVldWUpXG4gICAgKVxuICAgICAgaWYgKFxuICAgICAgICAoZmx1c2hTeW5jV29yayQxKCksXG4gICAgICAgIHJlc3RvcmVUYXJnZXQgJiZcbiAgICAgICAgICAoKGEgPSByZXN0b3JlVGFyZ2V0KSxcbiAgICAgICAgICAoZm4gPSByZXN0b3JlUXVldWUpLFxuICAgICAgICAgIChyZXN0b3JlUXVldWUgPSByZXN0b3JlVGFyZ2V0ID0gbnVsbCksXG4gICAgICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQoYSksXG4gICAgICAgICAgZm4pKVxuICAgICAgKVxuICAgICAgICBmb3IgKGEgPSAwOyBhIDwgZm4ubGVuZ3RoOyBhKyspIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KGZuW2FdKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmIChudWxsID09PSBzdGF0ZU5vZGUpIHJldHVybiBudWxsO1xuICB2YXIgcHJvcHMgPSBzdGF0ZU5vZGVbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbDtcbiAgaWYgKG51bGwgPT09IHByb3BzKSByZXR1cm4gbnVsbDtcbiAgc3RhdGVOb2RlID0gcHJvcHNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGE6IHN3aXRjaCAocmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGNhc2UgXCJvbkNsaWNrXCI6XG4gICAgY2FzZSBcIm9uQ2xpY2tDYXB0dXJlXCI6XG4gICAgY2FzZSBcIm9uRG91YmxlQ2xpY2tcIjpcbiAgICBjYXNlIFwib25Eb3VibGVDbGlja0NhcHR1cmVcIjpcbiAgICBjYXNlIFwib25Nb3VzZURvd25cIjpcbiAgICBjYXNlIFwib25Nb3VzZURvd25DYXB0dXJlXCI6XG4gICAgY2FzZSBcIm9uTW91c2VNb3ZlXCI6XG4gICAgY2FzZSBcIm9uTW91c2VNb3ZlQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlVXBcIjpcbiAgICBjYXNlIFwib25Nb3VzZVVwQ2FwdHVyZVwiOlxuICAgIGNhc2UgXCJvbk1vdXNlRW50ZXJcIjpcbiAgICAgIChwcm9wcyA9ICFwcm9wcy5kaXNhYmxlZCkgfHxcbiAgICAgICAgKChpbnN0ID0gaW5zdC50eXBlKSxcbiAgICAgICAgKHByb3BzID0gIShcbiAgICAgICAgICBcImJ1dHRvblwiID09PSBpbnN0IHx8XG4gICAgICAgICAgXCJpbnB1dFwiID09PSBpbnN0IHx8XG4gICAgICAgICAgXCJzZWxlY3RcIiA9PT0gaW5zdCB8fFxuICAgICAgICAgIFwidGV4dGFyZWFcIiA9PT0gaW5zdFxuICAgICAgICApKSk7XG4gICAgICBpbnN0ID0gIXByb3BzO1xuICAgICAgYnJlYWsgYTtcbiAgICBkZWZhdWx0OlxuICAgICAgaW5zdCA9ICExO1xuICB9XG4gIGlmIChpbnN0KSByZXR1cm4gbnVsbDtcbiAgaWYgKHN0YXRlTm9kZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBzdGF0ZU5vZGUpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDIzMSwgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIHN0YXRlTm9kZSlcbiAgICApO1xuICByZXR1cm4gc3RhdGVOb2RlO1xufVxudmFyIHBhc3NpdmVCcm93c2VyRXZlbnRzU3VwcG9ydGVkID0gITE7XG5pZiAoY2FuVXNlRE9NKVxuICB0cnkge1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9wdGlvbnMsIFwicGFzc2l2ZVwiLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInRlc3RcIiwgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG9wdGlvbnMsIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgPSAhMTtcbiAgfVxudmFyIHJvb3QgPSBudWxsLFxuICBzdGFydFRleHQgPSBudWxsLFxuICBmYWxsYmFja1RleHQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgaWYgKGZhbGxiYWNrVGV4dCkgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbiAgdmFyIHN0YXJ0LFxuICAgIHN0YXJ0VmFsdWUgPSBzdGFydFRleHQsXG4gICAgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aCxcbiAgICBlbmQsXG4gICAgZW5kVmFsdWUgPSBcInZhbHVlXCIgaW4gcm9vdCA/IHJvb3QudmFsdWUgOiByb290LnRleHRDb250ZW50LFxuICAgIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcbiAgZm9yIChcbiAgICBzdGFydCA9IDA7XG4gICAgc3RhcnQgPCBzdGFydExlbmd0aCAmJiBzdGFydFZhbHVlW3N0YXJ0XSA9PT0gZW5kVmFsdWVbc3RhcnRdO1xuICAgIHN0YXJ0KytcbiAgKTtcbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gIGZvciAoXG4gICAgZW5kID0gMTtcbiAgICBlbmQgPD0gbWluRW5kICYmXG4gICAgc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gPT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF07XG4gICAgZW5kKytcbiAgKTtcbiAgcmV0dXJuIChmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgMSA8IGVuZCA/IDEgLSBlbmQgOiB2b2lkIDApKTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuICBcImNoYXJDb2RlXCIgaW4gbmF0aXZlRXZlbnRcbiAgICA/ICgobmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudC5jaGFyQ29kZSksXG4gICAgICAwID09PSBuYXRpdmVFdmVudCAmJiAxMyA9PT0ga2V5Q29kZSAmJiAobmF0aXZlRXZlbnQgPSAxMykpXG4gICAgOiAobmF0aXZlRXZlbnQgPSBrZXlDb2RlKTtcbiAgMTAgPT09IG5hdGl2ZUV2ZW50ICYmIChuYXRpdmVFdmVudCA9IDEzKTtcbiAgcmV0dXJuIDMyIDw9IG5hdGl2ZUV2ZW50IHx8IDEzID09PSBuYXRpdmVFdmVudCA/IG5hdGl2ZUV2ZW50IDogMDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlKCkge1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UoKSB7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEludGVyZmFjZSkge1xuICBmdW5jdGlvbiBTeW50aGV0aWNCYXNlRXZlbnQoXG4gICAgcmVhY3ROYW1lLFxuICAgIHJlYWN0RXZlbnRUeXBlLFxuICAgIHRhcmdldEluc3QsXG4gICAgbmF0aXZlRXZlbnQsXG4gICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgKSB7XG4gICAgdGhpcy5fcmVhY3ROYW1lID0gcmVhY3ROYW1lO1xuICAgIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHRoaXMudHlwZSA9IHJlYWN0RXZlbnRUeXBlO1xuICAgIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIHRoaXMuY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKVxuICAgICAgSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJlxuICAgICAgICAoKHJlYWN0TmFtZSA9IEludGVyZmFjZVtwcm9wTmFtZV0pLFxuICAgICAgICAodGhpc1twcm9wTmFtZV0gPSByZWFjdE5hbWVcbiAgICAgICAgICA/IHJlYWN0TmFtZShuYXRpdmVFdmVudClcbiAgICAgICAgICA6IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXSkpO1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gKFxuICAgICAgbnVsbCAhPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICAgID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICAgICAgICA6ICExID09PSBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZVxuICAgIClcbiAgICAgID8gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWVcbiAgICAgIDogZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgYXNzaWduKFN5bnRoZXRpY0Jhc2VFdmVudC5wcm90b3R5cGUsIHtcbiAgICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gITA7XG4gICAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgICAgZXZlbnQgJiZcbiAgICAgICAgKGV2ZW50LnByZXZlbnREZWZhdWx0XG4gICAgICAgICAgPyBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgOiBcInVua25vd25cIiAhPT0gdHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICYmIChldmVudC5yZXR1cm5WYWx1ZSA9ICExKSxcbiAgICAgICAgKHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWUpKTtcbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICAgIGV2ZW50ICYmXG4gICAgICAgIChldmVudC5zdG9wUHJvcGFnYXRpb25cbiAgICAgICAgICA/IGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgOiBcInVua25vd25cIiAhPT0gdHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAmJlxuICAgICAgICAgICAgKGV2ZW50LmNhbmNlbEJ1YmJsZSA9ICEwKSxcbiAgICAgICAgKHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSkpO1xuICAgIH0sXG4gICAgcGVyc2lzdDogZnVuY3Rpb24gKCkge30sXG4gICAgaXNQZXJzaXN0ZW50OiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZVxuICB9KTtcbiAgcmV0dXJuIFN5bnRoZXRpY0Jhc2VFdmVudDtcbn1cbnZhciBFdmVudEludGVyZmFjZSA9IHtcbiAgICBldmVudFBoYXNlOiAwLFxuICAgIGJ1YmJsZXM6IDAsXG4gICAgY2FuY2VsYWJsZTogMCxcbiAgICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICAgIH0sXG4gICAgZGVmYXVsdFByZXZlbnRlZDogMCxcbiAgICBpc1RydXN0ZWQ6IDBcbiAgfSxcbiAgU3ludGhldGljRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChFdmVudEludGVyZmFjZSksXG4gIFVJRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7IHZpZXc6IDAsIGRldGFpbDogMCB9KSxcbiAgU3ludGhldGljVUlFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFVJRXZlbnRJbnRlcmZhY2UpLFxuICBsYXN0TW92ZW1lbnRYLFxuICBsYXN0TW92ZW1lbnRZLFxuICBsYXN0TW91c2VFdmVudCxcbiAgTW91c2VFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwge1xuICAgIHNjcmVlblg6IDAsXG4gICAgc2NyZWVuWTogMCxcbiAgICBjbGllbnRYOiAwLFxuICAgIGNsaWVudFk6IDAsXG4gICAgcGFnZVg6IDAsXG4gICAgcGFnZVk6IDAsXG4gICAgY3RybEtleTogMCxcbiAgICBzaGlmdEtleTogMCxcbiAgICBhbHRLZXk6IDAsXG4gICAgbWV0YUtleTogMCxcbiAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gICAgYnV0dG9uOiAwLFxuICAgIGJ1dHRvbnM6IDAsXG4gICAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gdm9pZCAwID09PSBldmVudC5yZWxhdGVkVGFyZ2V0XG4gICAgICAgID8gZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnRcbiAgICAgICAgICA/IGV2ZW50LnRvRWxlbWVudFxuICAgICAgICAgIDogZXZlbnQuZnJvbUVsZW1lbnRcbiAgICAgICAgOiBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIH0sXG4gICAgbW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIGlmIChcIm1vdmVtZW50WFwiIGluIGV2ZW50KSByZXR1cm4gZXZlbnQubW92ZW1lbnRYO1xuICAgICAgZXZlbnQgIT09IGxhc3RNb3VzZUV2ZW50ICYmXG4gICAgICAgIChsYXN0TW91c2VFdmVudCAmJiBcIm1vdXNlbW92ZVwiID09PSBldmVudC50eXBlXG4gICAgICAgICAgPyAoKGxhc3RNb3ZlbWVudFggPSBldmVudC5zY3JlZW5YIC0gbGFzdE1vdXNlRXZlbnQuc2NyZWVuWCksXG4gICAgICAgICAgICAobGFzdE1vdmVtZW50WSA9IGV2ZW50LnNjcmVlblkgLSBsYXN0TW91c2VFdmVudC5zY3JlZW5ZKSlcbiAgICAgICAgICA6IChsYXN0TW92ZW1lbnRZID0gbGFzdE1vdmVtZW50WCA9IDApLFxuICAgICAgICAobGFzdE1vdXNlRXZlbnQgPSBldmVudCkpO1xuICAgICAgcmV0dXJuIGxhc3RNb3ZlbWVudFg7XG4gICAgfSxcbiAgICBtb3ZlbWVudFk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwibW92ZW1lbnRZXCIgaW4gZXZlbnQgPyBldmVudC5tb3ZlbWVudFkgOiBsYXN0TW92ZW1lbnRZO1xuICAgIH1cbiAgfSksXG4gIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChNb3VzZUV2ZW50SW50ZXJmYWNlKSxcbiAgRHJhZ0V2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7IGRhdGFUcmFuc2ZlcjogMCB9KSxcbiAgU3ludGhldGljRHJhZ0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRHJhZ0V2ZW50SW50ZXJmYWNlKSxcbiAgRm9jdXNFdmVudEludGVyZmFjZSA9IGFzc2lnbih7fSwgVUlFdmVudEludGVyZmFjZSwgeyByZWxhdGVkVGFyZ2V0OiAwIH0pLFxuICBTeW50aGV0aWNGb2N1c0V2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoRm9jdXNFdmVudEludGVyZmFjZSksXG4gIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIGFuaW1hdGlvbk5hbWU6IDAsXG4gICAgZWxhcHNlZFRpbWU6IDAsXG4gICAgcHNldWRvRWxlbWVudDogMFxuICB9KSxcbiAgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChBbmltYXRpb25FdmVudEludGVyZmFjZSksXG4gIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwiY2xpcGJvYXJkRGF0YVwiIGluIGV2ZW50XG4gICAgICAgID8gZXZlbnQuY2xpcGJvYXJkRGF0YVxuICAgICAgICA6IHdpbmRvdy5jbGlwYm9hcmREYXRhO1xuICAgIH1cbiAgfSksXG4gIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpLFxuICBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwgeyBkYXRhOiAwIH0pLFxuICBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSksXG4gIG5vcm1hbGl6ZUtleSA9IHtcbiAgICBFc2M6IFwiRXNjYXBlXCIsXG4gICAgU3BhY2ViYXI6IFwiIFwiLFxuICAgIExlZnQ6IFwiQXJyb3dMZWZ0XCIsXG4gICAgVXA6IFwiQXJyb3dVcFwiLFxuICAgIFJpZ2h0OiBcIkFycm93UmlnaHRcIixcbiAgICBEb3duOiBcIkFycm93RG93blwiLFxuICAgIERlbDogXCJEZWxldGVcIixcbiAgICBXaW46IFwiT1NcIixcbiAgICBNZW51OiBcIkNvbnRleHRNZW51XCIsXG4gICAgQXBwczogXCJDb250ZXh0TWVudVwiLFxuICAgIFNjcm9sbDogXCJTY3JvbGxMb2NrXCIsXG4gICAgTW96UHJpbnRhYmxlS2V5OiBcIlVuaWRlbnRpZmllZFwiXG4gIH0sXG4gIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAgIDg6IFwiQmFja3NwYWNlXCIsXG4gICAgOTogXCJUYWJcIixcbiAgICAxMjogXCJDbGVhclwiLFxuICAgIDEzOiBcIkVudGVyXCIsXG4gICAgMTY6IFwiU2hpZnRcIixcbiAgICAxNzogXCJDb250cm9sXCIsXG4gICAgMTg6IFwiQWx0XCIsXG4gICAgMTk6IFwiUGF1c2VcIixcbiAgICAyMDogXCJDYXBzTG9ja1wiLFxuICAgIDI3OiBcIkVzY2FwZVwiLFxuICAgIDMyOiBcIiBcIixcbiAgICAzMzogXCJQYWdlVXBcIixcbiAgICAzNDogXCJQYWdlRG93blwiLFxuICAgIDM1OiBcIkVuZFwiLFxuICAgIDM2OiBcIkhvbWVcIixcbiAgICAzNzogXCJBcnJvd0xlZnRcIixcbiAgICAzODogXCJBcnJvd1VwXCIsXG4gICAgMzk6IFwiQXJyb3dSaWdodFwiLFxuICAgIDQwOiBcIkFycm93RG93blwiLFxuICAgIDQ1OiBcIkluc2VydFwiLFxuICAgIDQ2OiBcIkRlbGV0ZVwiLFxuICAgIDExMjogXCJGMVwiLFxuICAgIDExMzogXCJGMlwiLFxuICAgIDExNDogXCJGM1wiLFxuICAgIDExNTogXCJGNFwiLFxuICAgIDExNjogXCJGNVwiLFxuICAgIDExNzogXCJGNlwiLFxuICAgIDExODogXCJGN1wiLFxuICAgIDExOTogXCJGOFwiLFxuICAgIDEyMDogXCJGOVwiLFxuICAgIDEyMTogXCJGMTBcIixcbiAgICAxMjI6IFwiRjExXCIsXG4gICAgMTIzOiBcIkYxMlwiLFxuICAgIDE0NDogXCJOdW1Mb2NrXCIsXG4gICAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgICAyMjQ6IFwiTWV0YVwiXG4gIH0sXG4gIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICAgIEFsdDogXCJhbHRLZXlcIixcbiAgICBDb250cm9sOiBcImN0cmxLZXlcIixcbiAgICBNZXRhOiBcIm1ldGFLZXlcIixcbiAgICBTaGlmdDogXCJzaGlmdEtleVwiXG4gIH07XG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgbmF0aXZlRXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZVxuICAgID8gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpXG4gICAgOiAoa2V5QXJnID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXSlcbiAgICAgID8gISFuYXRpdmVFdmVudFtrZXlBcmddXG4gICAgICA6ICExO1xufVxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBVSUV2ZW50SW50ZXJmYWNlLCB7XG4gICAga2V5OiBmdW5jdGlvbiAobmF0aXZlRXZlbnQpIHtcbiAgICAgIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAgICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICAgICAgaWYgKFwiVW5pZGVudGlmaWVkXCIgIT09IGtleSkgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImtleXByZXNzXCIgPT09IG5hdGl2ZUV2ZW50LnR5cGVcbiAgICAgICAgPyAoKG5hdGl2ZUV2ZW50ID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkpLFxuICAgICAgICAgIDEzID09PSBuYXRpdmVFdmVudCA/IFwiRW50ZXJcIiA6IFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQpKVxuICAgICAgICA6IFwia2V5ZG93blwiID09PSBuYXRpdmVFdmVudC50eXBlIHx8IFwia2V5dXBcIiA9PT0gbmF0aXZlRXZlbnQudHlwZVxuICAgICAgICAgID8gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgXCJVbmlkZW50aWZpZWRcIlxuICAgICAgICAgIDogXCJcIjtcbiAgICB9LFxuICAgIGNvZGU6IDAsXG4gICAgbG9jYXRpb246IDAsXG4gICAgY3RybEtleTogMCxcbiAgICBzaGlmdEtleTogMCxcbiAgICBhbHRLZXk6IDAsXG4gICAgbWV0YUtleTogMCxcbiAgICByZXBlYXQ6IDAsXG4gICAgbG9jYWxlOiAwLFxuICAgIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBldmVudC50eXBlID8gZ2V0RXZlbnRDaGFyQ29kZShldmVudCkgOiAwO1xuICAgIH0sXG4gICAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJrZXlkb3duXCIgPT09IGV2ZW50LnR5cGUgfHwgXCJrZXl1cFwiID09PSBldmVudC50eXBlXG4gICAgICAgID8gZXZlbnQua2V5Q29kZVxuICAgICAgICA6IDA7XG4gICAgfSxcbiAgICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICByZXR1cm4gXCJrZXlwcmVzc1wiID09PSBldmVudC50eXBlXG4gICAgICAgID8gZ2V0RXZlbnRDaGFyQ29kZShldmVudClcbiAgICAgICAgOiBcImtleWRvd25cIiA9PT0gZXZlbnQudHlwZSB8fCBcImtleXVwXCIgPT09IGV2ZW50LnR5cGVcbiAgICAgICAgICA/IGV2ZW50LmtleUNvZGVcbiAgICAgICAgICA6IDA7XG4gICAgfVxuICB9KSxcbiAgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpLFxuICBQb2ludGVyRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIE1vdXNlRXZlbnRJbnRlcmZhY2UsIHtcbiAgICBwb2ludGVySWQ6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIHByZXNzdXJlOiAwLFxuICAgIHRhbmdlbnRpYWxQcmVzc3VyZTogMCxcbiAgICB0aWx0WDogMCxcbiAgICB0aWx0WTogMCxcbiAgICB0d2lzdDogMCxcbiAgICBwb2ludGVyVHlwZTogMCxcbiAgICBpc1ByaW1hcnk6IDBcbiAgfSksXG4gIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IGNyZWF0ZVN5bnRoZXRpY0V2ZW50KFBvaW50ZXJFdmVudEludGVyZmFjZSksXG4gIFRvdWNoRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIFVJRXZlbnRJbnRlcmZhY2UsIHtcbiAgICB0b3VjaGVzOiAwLFxuICAgIHRhcmdldFRvdWNoZXM6IDAsXG4gICAgY2hhbmdlZFRvdWNoZXM6IDAsXG4gICAgYWx0S2V5OiAwLFxuICAgIG1ldGFLZXk6IDAsXG4gICAgY3RybEtleTogMCxcbiAgICBzaGlmdEtleTogMCxcbiAgICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAgfSksXG4gIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUb3VjaEV2ZW50SW50ZXJmYWNlKSxcbiAgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBFdmVudEludGVyZmFjZSwge1xuICAgIHByb3BlcnR5TmFtZTogMCxcbiAgICBlbGFwc2VkVGltZTogMCxcbiAgICBwc2V1ZG9FbGVtZW50OiAwXG4gIH0pLFxuICBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpLFxuICBXaGVlbEV2ZW50SW50ZXJmYWNlID0gYXNzaWduKHt9LCBNb3VzZUV2ZW50SW50ZXJmYWNlLCB7XG4gICAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBcImRlbHRhWFwiIGluIGV2ZW50XG4gICAgICAgID8gZXZlbnQuZGVsdGFYXG4gICAgICAgIDogXCJ3aGVlbERlbHRhWFwiIGluIGV2ZW50XG4gICAgICAgICAgPyAtZXZlbnQud2hlZWxEZWx0YVhcbiAgICAgICAgICA6IDA7XG4gICAgfSxcbiAgICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIFwiZGVsdGFZXCIgaW4gZXZlbnRcbiAgICAgICAgPyBldmVudC5kZWx0YVlcbiAgICAgICAgOiBcIndoZWVsRGVsdGFZXCIgaW4gZXZlbnRcbiAgICAgICAgICA/IC1ldmVudC53aGVlbERlbHRhWVxuICAgICAgICAgIDogXCJ3aGVlbERlbHRhXCIgaW4gZXZlbnRcbiAgICAgICAgICAgID8gLWV2ZW50LndoZWVsRGVsdGFcbiAgICAgICAgICAgIDogMDtcbiAgICB9LFxuICAgIGRlbHRhWjogMCxcbiAgICBkZWx0YU1vZGU6IDBcbiAgfSksXG4gIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBjcmVhdGVTeW50aGV0aWNFdmVudChXaGVlbEV2ZW50SW50ZXJmYWNlKSxcbiAgVG9nZ2xlRXZlbnRJbnRlcmZhY2UgPSBhc3NpZ24oe30sIEV2ZW50SW50ZXJmYWNlLCB7XG4gICAgbmV3U3RhdGU6IDAsXG4gICAgb2xkU3RhdGU6IDBcbiAgfSksXG4gIFN5bnRoZXRpY1RvZ2dsZUV2ZW50ID0gY3JlYXRlU3ludGhldGljRXZlbnQoVG9nZ2xlRXZlbnRJbnRlcmZhY2UpLFxuICBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl0sXG4gIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBjYW5Vc2VET00gJiYgXCJDb21wb3NpdGlvbkV2ZW50XCIgaW4gd2luZG93LFxuICBkb2N1bWVudE1vZGUgPSBudWxsO1xuY2FuVXNlRE9NICYmXG4gIFwiZG9jdW1lbnRNb2RlXCIgaW4gZG9jdW1lbnQgJiZcbiAgKGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBjYW5Vc2VET00gJiYgXCJUZXh0RXZlbnRcIiBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSxcbiAgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPVxuICAgIGNhblVzZURPTSAmJlxuICAgICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fFxuICAgICAgKGRvY3VtZW50TW9kZSAmJiA4IDwgZG9jdW1lbnRNb2RlICYmIDExID49IGRvY3VtZW50TW9kZSkpLFxuICBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiksXG4gIGhhc1NwYWNlS2V5cHJlc3MgPSAhMTtcbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImtleXVwXCI6XG4gICAgICByZXR1cm4gLTEgIT09IEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpO1xuICAgIGNhc2UgXCJrZXlkb3duXCI6XG4gICAgICByZXR1cm4gMjI5ICE9PSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgIHJldHVybiAhMDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIG5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5hdGl2ZUV2ZW50ICYmIFwiZGF0YVwiIGluIG5hdGl2ZUV2ZW50XG4gICAgPyBuYXRpdmVFdmVudC5kYXRhXG4gICAgOiBudWxsO1xufVxudmFyIGlzQ29tcG9zaW5nID0gITE7XG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgIGlmICgzMiAhPT0gbmF0aXZlRXZlbnQud2hpY2gpIHJldHVybiBudWxsO1xuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9ICEwO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG4gICAgY2FzZSBcInRleHRJbnB1dFwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGRvbUV2ZW50TmFtZSA9IG5hdGl2ZUV2ZW50LmRhdGEpLFxuICAgICAgICBkb21FdmVudE5hbWUgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcyA/IG51bGwgOiBkb21FdmVudE5hbWVcbiAgICAgICk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBpZiAoaXNDb21wb3NpbmcpXG4gICAgcmV0dXJuIFwiY29tcG9zaXRpb25lbmRcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgICAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiZcbiAgICAgICAgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKVxuICAgICAgPyAoKGRvbUV2ZW50TmFtZSA9IGdldERhdGEoKSksXG4gICAgICAgIChmYWxsYmFja1RleHQgPSBzdGFydFRleHQgPSByb290ID0gbnVsbCksXG4gICAgICAgIChpc0NvbXBvc2luZyA9ICExKSxcbiAgICAgICAgZG9tRXZlbnROYW1lKVxuICAgICAgOiBudWxsO1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBcImtleXByZXNzXCI6XG4gICAgICBpZiAoXG4gICAgICAgICEobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgfHxcbiAgICAgICAgKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KVxuICAgICAgKSB7XG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIDEgPCBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJiBcImtvXCIgIT09IG5hdGl2ZUV2ZW50LmxvY2FsZVxuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gIGNvbG9yOiAhMCxcbiAgZGF0ZTogITAsXG4gIGRhdGV0aW1lOiAhMCxcbiAgXCJkYXRldGltZS1sb2NhbFwiOiAhMCxcbiAgZW1haWw6ICEwLFxuICBtb250aDogITAsXG4gIG51bWJlcjogITAsXG4gIHBhc3N3b3JkOiAhMCxcbiAgcmFuZ2U6ICEwLFxuICBzZWFyY2g6ICEwLFxuICB0ZWw6ICEwLFxuICB0ZXh0OiAhMCxcbiAgdGltZTogITAsXG4gIHVybDogITAsXG4gIHdlZWs6ICEwXG59O1xuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIFwiaW5wdXRcIiA9PT0gbm9kZU5hbWVcbiAgICA/ICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdXG4gICAgOiBcInRleHRhcmVhXCIgPT09IG5vZGVOYW1lXG4gICAgICA/ICEwXG4gICAgICA6ICExO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KFxuICBkaXNwYXRjaFF1ZXVlLFxuICBpbnN0LFxuICBuYXRpdmVFdmVudCxcbiAgdGFyZ2V0XG4pIHtcbiAgcmVzdG9yZVRhcmdldFxuICAgID8gcmVzdG9yZVF1ZXVlXG4gICAgICA/IHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldClcbiAgICAgIDogKHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdKVxuICAgIDogKHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQpO1xuICBpbnN0ID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGluc3QsIFwib25DaGFuZ2VcIik7XG4gIDAgPCBpbnN0Lmxlbmd0aCAmJlxuICAgICgobmF0aXZlRXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICBcIm9uQ2hhbmdlXCIsXG4gICAgICBcImNoYW5nZVwiLFxuICAgICAgbnVsbCxcbiAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgdGFyZ2V0XG4gICAgKSksXG4gICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IG5hdGl2ZUV2ZW50LCBsaXN0ZW5lcnM6IGluc3QgfSkpO1xufVxudmFyIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGwsXG4gIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGRpc3BhdGNoUXVldWUpIHtcbiAgcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgMCk7XG59XG5mdW5jdGlvbiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCkge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkgcmV0dXJuIHRhcmdldEluc3Q7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChcImNoYW5nZVwiID09PSBkb21FdmVudE5hbWUpIHJldHVybiB0YXJnZXRJbnN0O1xufVxudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9ICExO1xuaWYgKGNhblVzZURPTSkge1xuICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQyODM7XG4gIGlmIChjYW5Vc2VET00pIHtcbiAgICB2YXIgaXNTdXBwb3J0ZWQkanNjb21wJGlubGluZV80MTggPSBcIm9uaW5wdXRcIiBpbiBkb2N1bWVudDtcbiAgICBpZiAoIWlzU3VwcG9ydGVkJGpzY29tcCRpbmxpbmVfNDE4KSB7XG4gICAgICB2YXIgZWxlbWVudCRqc2NvbXAkaW5saW5lXzQxOSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50JGpzY29tcCRpbmxpbmVfNDE5LnNldEF0dHJpYnV0ZShcIm9uaW5wdXRcIiwgXCJyZXR1cm47XCIpO1xuICAgICAgaXNTdXBwb3J0ZWQkanNjb21wJGlubGluZV80MTggPVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBlbGVtZW50JGpzY29tcCRpbmxpbmVfNDE5Lm9uaW5wdXQ7XG4gICAgfVxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjgzID0gaXNTdXBwb3J0ZWQkanNjb21wJGlubGluZV80MTg7XG4gIH0gZWxzZSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDI4MyA9ICExO1xuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPVxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMjgzICYmXG4gICAgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgOSA8IGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG59XG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgYWN0aXZlRWxlbWVudCQxICYmXG4gICAgKGFjdGl2ZUVsZW1lbnQkMS5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIiwgaGFuZGxlUHJvcGVydHlDaGFuZ2UpLFxuICAgIChhY3RpdmVFbGVtZW50SW5zdCQxID0gYWN0aXZlRWxlbWVudCQxID0gbnVsbCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKFxuICAgIFwidmFsdWVcIiA9PT0gbmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICYmXG4gICAgZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0JDEpXG4gICkge1xuICAgIHZhciBkaXNwYXRjaFF1ZXVlID0gW107XG4gICAgY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KFxuICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KVxuICAgICk7XG4gICAgYmF0Y2hlZFVwZGF0ZXMkMShydW5FdmVudEluQmF0Y2gsIGRpc3BhdGNoUXVldWUpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwoZG9tRXZlbnROYW1lLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgXCJmb2N1c2luXCIgPT09IGRvbUV2ZW50TmFtZVxuICAgID8gKHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCksXG4gICAgICAoYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0KSxcbiAgICAgIChhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdCksXG4gICAgICBhY3RpdmVFbGVtZW50JDEuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKSlcbiAgICA6IFwiZm9jdXNvdXRcIiA9PT0gZG9tRXZlbnROYW1lICYmIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKGRvbUV2ZW50TmFtZSkge1xuICBpZiAoXG4gICAgXCJzZWxlY3Rpb25jaGFuZ2VcIiA9PT0gZG9tRXZlbnROYW1lIHx8XG4gICAgXCJrZXl1cFwiID09PSBkb21FdmVudE5hbWUgfHxcbiAgICBcImtleWRvd25cIiA9PT0gZG9tRXZlbnROYW1lXG4gIClcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0JDEpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChcImNsaWNrXCIgPT09IGRvbUV2ZW50TmFtZSkgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbn1cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRJbnN0KSB7XG4gIGlmIChcImlucHV0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcImNoYW5nZVwiID09PSBkb21FdmVudE5hbWUpXG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbn1cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuICh4ID09PSB5ICYmICgwICE9PSB4IHx8IDEgLyB4ID09PSAxIC8geSkpIHx8ICh4ICE9PSB4ICYmIHkgIT09IHkpO1xufVxudmFyIG9iamVjdElzID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgT2JqZWN0LmlzID8gT2JqZWN0LmlzIDogaXM7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHJldHVybiAhMDtcbiAgaWYgKFxuICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpBIHx8XG4gICAgbnVsbCA9PT0gb2JqQSB8fFxuICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBvYmpCIHx8XG4gICAgbnVsbCA9PT0gb2JqQlxuICApXG4gICAgcmV0dXJuICExO1xuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKSxcbiAgICBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHJldHVybiAhMTtcbiAgZm9yIChrZXlzQiA9IDA7IGtleXNCIDwga2V5c0EubGVuZ3RoOyBrZXlzQisrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtrZXlzQl07XG4gICAgaWYgKFxuICAgICAgIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwgY3VycmVudEtleSkgfHxcbiAgICAgICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKVxuICAgIClcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIGZvciAoOyBub2RlICYmIG5vZGUuZmlyc3RDaGlsZDsgKSBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQocm9vdCwgb2Zmc2V0KSB7XG4gIHZhciBub2RlID0gZ2V0TGVhZk5vZGUocm9vdCk7XG4gIHJvb3QgPSAwO1xuICBmb3IgKHZhciBub2RlRW5kOyBub2RlOyApIHtcbiAgICBpZiAoMyA9PT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgbm9kZUVuZCA9IHJvb3QgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgIGlmIChyb290IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldClcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogbm9kZSwgb2Zmc2V0OiBvZmZzZXQgLSByb290IH07XG4gICAgICByb290ID0gbm9kZUVuZDtcbiAgICB9XG4gICAgYToge1xuICAgICAgZm9yICg7IG5vZGU7ICkge1xuICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSB2b2lkIDA7XG4gICAgfVxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIHJldHVybiBvdXRlck5vZGUgJiYgaW5uZXJOb2RlXG4gICAgPyBvdXRlck5vZGUgPT09IGlubmVyTm9kZVxuICAgICAgPyAhMFxuICAgICAgOiBvdXRlck5vZGUgJiYgMyA9PT0gb3V0ZXJOb2RlLm5vZGVUeXBlXG4gICAgICAgID8gITFcbiAgICAgICAgOiBpbm5lck5vZGUgJiYgMyA9PT0gaW5uZXJOb2RlLm5vZGVUeXBlXG4gICAgICAgICAgPyBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICA6IFwiY29udGFpbnNcIiBpbiBvdXRlck5vZGVcbiAgICAgICAgICAgID8gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSlcbiAgICAgICAgICAgIDogb3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgICAgICAgID8gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNilcbiAgICAgICAgICAgICAgOiAhMVxuICAgIDogITE7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50RGVlcChjb250YWluZXJJbmZvKSB7XG4gIGNvbnRhaW5lckluZm8gPVxuICAgIG51bGwgIT0gY29udGFpbmVySW5mbyAmJlxuICAgIG51bGwgIT0gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50ICYmXG4gICAgbnVsbCAhPSBjb250YWluZXJJbmZvLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXdcbiAgICAgID8gY29udGFpbmVySW5mby5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3XG4gICAgICA6IHdpbmRvdztcbiAgZm9yIChcbiAgICB2YXIgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQoY29udGFpbmVySW5mby5kb2N1bWVudCk7XG4gICAgZWxlbWVudCBpbnN0YW5jZW9mIGNvbnRhaW5lckluZm8uSFRNTElGcmFtZUVsZW1lbnQ7XG5cbiAgKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPVxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWY7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICB9XG4gICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgY29udGFpbmVySW5mbyA9IGVsZW1lbnQuY29udGVudFdpbmRvdztcbiAgICBlbHNlIGJyZWFrO1xuICAgIGVsZW1lbnQgPSBnZXRBY3RpdmVFbGVtZW50KGNvbnRhaW5lckluZm8uZG9jdW1lbnQpO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIChcbiAgICBub2RlTmFtZSAmJlxuICAgICgoXCJpbnB1dFwiID09PSBub2RlTmFtZSAmJlxuICAgICAgKFwidGV4dFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgXCJzZWFyY2hcIiA9PT0gZWxlbS50eXBlIHx8XG4gICAgICAgIFwidGVsXCIgPT09IGVsZW0udHlwZSB8fFxuICAgICAgICBcInVybFwiID09PSBlbGVtLnR5cGUgfHxcbiAgICAgICAgXCJwYXNzd29yZFwiID09PSBlbGVtLnR5cGUpKSB8fFxuICAgICAgXCJ0ZXh0YXJlYVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgXCJ0cnVlXCIgPT09IGVsZW0uY29udGVudEVkaXRhYmxlKVxuICApO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLCBjb250YWluZXJJbmZvKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnREZWVwKGNvbnRhaW5lckluZm8pO1xuICBjb250YWluZXJJbmZvID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoXG4gICAgY3VyRm9jdXNlZEVsZW0gIT09IGNvbnRhaW5lckluZm8gJiZcbiAgICBjb250YWluZXJJbmZvICYmXG4gICAgY29udGFpbmVySW5mby5vd25lckRvY3VtZW50ICYmXG4gICAgY29udGFpbnNOb2RlKGNvbnRhaW5lckluZm8ub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGNvbnRhaW5lckluZm8pXG4gICkge1xuICAgIGlmIChudWxsICE9PSBwcmlvclNlbGVjdGlvblJhbmdlICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhjb250YWluZXJJbmZvKSlcbiAgICAgIGlmIChcbiAgICAgICAgKChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uID0gcHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCksXG4gICAgICAgIChjdXJGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uUmFuZ2UuZW5kKSxcbiAgICAgICAgdm9pZCAwID09PSBjdXJGb2N1c2VkRWxlbSAmJlxuICAgICAgICAgIChjdXJGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pLFxuICAgICAgICBcInNlbGVjdGlvblN0YXJ0XCIgaW4gY29udGFpbmVySW5mbylcbiAgICAgIClcbiAgICAgICAgKGNvbnRhaW5lckluZm8uc2VsZWN0aW9uU3RhcnQgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSxcbiAgICAgICAgICAoY29udGFpbmVySW5mby5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLFxuICAgICAgICAgICAgY29udGFpbmVySW5mby52YWx1ZS5sZW5ndGhcbiAgICAgICAgICApKTtcbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAoKGN1ckZvY3VzZWRFbGVtID1cbiAgICAgICAgICAoKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24gPVxuICAgICAgICAgICAgY29udGFpbmVySW5mby5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50KSAmJlxuICAgICAgICAgICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5kZWZhdWx0VmlldykgfHxcbiAgICAgICAgICB3aW5kb3cpLFxuICAgICAgICBjdXJGb2N1c2VkRWxlbS5nZXRTZWxlY3Rpb24pXG4gICAgICApIHtcbiAgICAgICAgY3VyRm9jdXNlZEVsZW0gPSBjdXJGb2N1c2VkRWxlbS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGNvbnRhaW5lckluZm8udGV4dENvbnRlbnQubGVuZ3RoLFxuICAgICAgICAgIHN0YXJ0ID0gTWF0aC5taW4ocHJpb3JTZWxlY3Rpb25SYW5nZS5zdGFydCwgbGVuZ3RoKTtcbiAgICAgICAgcHJpb3JTZWxlY3Rpb25SYW5nZSA9XG4gICAgICAgICAgdm9pZCAwID09PSBwcmlvclNlbGVjdGlvblJhbmdlLmVuZFxuICAgICAgICAgICAgPyBzdGFydFxuICAgICAgICAgICAgOiBNYXRoLm1pbihwcmlvclNlbGVjdGlvblJhbmdlLmVuZCwgbGVuZ3RoKTtcbiAgICAgICAgIWN1ckZvY3VzZWRFbGVtLmV4dGVuZCAmJlxuICAgICAgICAgIHN0YXJ0ID4gcHJpb3JTZWxlY3Rpb25SYW5nZSAmJlxuICAgICAgICAgICgobGVuZ3RoID0gcHJpb3JTZWxlY3Rpb25SYW5nZSksXG4gICAgICAgICAgKHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBzdGFydCksXG4gICAgICAgICAgKHN0YXJ0ID0gbGVuZ3RoKSk7XG4gICAgICAgIGxlbmd0aCA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQoY29udGFpbmVySW5mbywgc3RhcnQpO1xuICAgICAgICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChcbiAgICAgICAgICBjb250YWluZXJJbmZvLFxuICAgICAgICAgIHByaW9yU2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgKTtcbiAgICAgICAgbGVuZ3RoICYmXG4gICAgICAgICAgZW5kTWFya2VyICYmXG4gICAgICAgICAgKDEgIT09IGN1ckZvY3VzZWRFbGVtLnJhbmdlQ291bnQgfHxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmFuY2hvck5vZGUgIT09IGxlbmd0aC5ub2RlIHx8XG4gICAgICAgICAgICBjdXJGb2N1c2VkRWxlbS5hbmNob3JPZmZzZXQgIT09IGxlbmd0aC5vZmZzZXQgfHxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmZvY3VzTm9kZSAhPT0gZW5kTWFya2VyLm5vZGUgfHxcbiAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmZvY3VzT2Zmc2V0ICE9PSBlbmRNYXJrZXIub2Zmc2V0KSAmJlxuICAgICAgICAgICgocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiA9XG4gICAgICAgICAgICBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmNyZWF0ZVJhbmdlKCkpLFxuICAgICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2V0U3RhcnQobGVuZ3RoLm5vZGUsIGxlbmd0aC5vZmZzZXQpLFxuICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLnJlbW92ZUFsbFJhbmdlcygpLFxuICAgICAgICAgIHN0YXJ0ID4gcHJpb3JTZWxlY3Rpb25SYW5nZVxuICAgICAgICAgICAgPyAoY3VyRm9jdXNlZEVsZW0uYWRkUmFuZ2UocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiksXG4gICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCkpXG4gICAgICAgICAgICA6IChwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNldEVuZChcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIubm9kZSxcbiAgICAgICAgICAgICAgICBlbmRNYXJrZXIub2Zmc2V0XG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGN1ckZvY3VzZWRFbGVtLmFkZFJhbmdlKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pKSk7XG4gICAgICB9XG4gICAgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiA9IFtdO1xuICAgIGZvciAoXG4gICAgICBjdXJGb2N1c2VkRWxlbSA9IGNvbnRhaW5lckluZm87XG4gICAgICAoY3VyRm9jdXNlZEVsZW0gPSBjdXJGb2N1c2VkRWxlbS5wYXJlbnROb2RlKTtcblxuICAgIClcbiAgICAgIDEgPT09IGN1ckZvY3VzZWRFbGVtLm5vZGVUeXBlICYmXG4gICAgICAgIHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24ucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogY3VyRm9jdXNlZEVsZW0sXG4gICAgICAgICAgbGVmdDogY3VyRm9jdXNlZEVsZW0uc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGN1ckZvY3VzZWRFbGVtLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250YWluZXJJbmZvLmZvY3VzICYmIGNvbnRhaW5lckluZm8uZm9jdXMoKTtcbiAgICBmb3IgKFxuICAgICAgY29udGFpbmVySW5mbyA9IDA7XG4gICAgICBjb250YWluZXJJbmZvIDwgcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5sZW5ndGg7XG4gICAgICBjb250YWluZXJJbmZvKytcbiAgICApXG4gICAgICAoY3VyRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uW2NvbnRhaW5lckluZm9dKSxcbiAgICAgICAgKGN1ckZvY3VzZWRFbGVtLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGN1ckZvY3VzZWRFbGVtLmxlZnQpLFxuICAgICAgICAoY3VyRm9jdXNlZEVsZW0uZWxlbWVudC5zY3JvbGxUb3AgPSBjdXJGb2N1c2VkRWxlbS50b3ApO1xuICB9XG59XG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID1cbiAgICBjYW5Vc2VET00gJiYgXCJkb2N1bWVudE1vZGVcIiBpbiBkb2N1bWVudCAmJiAxMSA+PSBkb2N1bWVudC5kb2N1bWVudE1vZGUsXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsLFxuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGwsXG4gIGxhc3RTZWxlY3Rpb24gPSBudWxsLFxuICBtb3VzZURvd24gPSAhMTtcbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZG9jID1cbiAgICBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICA/IG5hdGl2ZUV2ZW50VGFyZ2V0LmRvY3VtZW50XG4gICAgICA6IDkgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlXG4gICAgICAgID8gbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICBtb3VzZURvd24gfHxcbiAgICBudWxsID09IGFjdGl2ZUVsZW1lbnQgfHxcbiAgICBhY3RpdmVFbGVtZW50ICE9PSBnZXRBY3RpdmVFbGVtZW50KGRvYykgfHxcbiAgICAoKGRvYyA9IGFjdGl2ZUVsZW1lbnQpLFxuICAgIFwic2VsZWN0aW9uU3RhcnRcIiBpbiBkb2MgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGRvYylcbiAgICAgID8gKGRvYyA9IHsgc3RhcnQ6IGRvYy5zZWxlY3Rpb25TdGFydCwgZW5kOiBkb2Muc2VsZWN0aW9uRW5kIH0pXG4gICAgICA6ICgoZG9jID0gKFxuICAgICAgICAgIChkb2Mub3duZXJEb2N1bWVudCAmJiBkb2Mub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHxcbiAgICAgICAgICB3aW5kb3dcbiAgICAgICAgKS5nZXRTZWxlY3Rpb24oKSksXG4gICAgICAgIChkb2MgPSB7XG4gICAgICAgICAgYW5jaG9yTm9kZTogZG9jLmFuY2hvck5vZGUsXG4gICAgICAgICAgYW5jaG9yT2Zmc2V0OiBkb2MuYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgIGZvY3VzTm9kZTogZG9jLmZvY3VzTm9kZSxcbiAgICAgICAgICBmb2N1c09mZnNldDogZG9jLmZvY3VzT2Zmc2V0XG4gICAgICAgIH0pKSxcbiAgICAobGFzdFNlbGVjdGlvbiAmJiBzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgZG9jKSkgfHxcbiAgICAgICgobGFzdFNlbGVjdGlvbiA9IGRvYyksXG4gICAgICAoZG9jID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKGFjdGl2ZUVsZW1lbnRJbnN0LCBcIm9uU2VsZWN0XCIpKSxcbiAgICAgIDAgPCBkb2MubGVuZ3RoICYmXG4gICAgICAgICgobmF0aXZlRXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICAgICAgXCJvblNlbGVjdFwiLFxuICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICApKSxcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IG5hdGl2ZUV2ZW50LCBsaXN0ZW5lcnM6IGRvYyB9KSxcbiAgICAgICAgKG5hdGl2ZUV2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQpKSkpO1xufVxuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzW1wiV2Via2l0XCIgKyBzdHlsZVByb3BdID0gXCJ3ZWJraXRcIiArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbXCJNb3pcIiArIHN0eWxlUHJvcF0gPSBcIm1velwiICsgZXZlbnROYW1lO1xuICByZXR1cm4gcHJlZml4ZXM7XG59XG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gICAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiQW5pbWF0aW9uXCIsIFwiQW5pbWF0aW9uRW5kXCIpLFxuICAgIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcChcIkFuaW1hdGlvblwiLCBcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxcbiAgICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcChcIkFuaW1hdGlvblwiLCBcIkFuaW1hdGlvblN0YXJ0XCIpLFxuICAgIHRyYW5zaXRpb25ydW46IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvblJ1blwiKSxcbiAgICB0cmFuc2l0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvblN0YXJ0XCIpLFxuICAgIHRyYW5zaXRpb25jYW5jZWw6IG1ha2VQcmVmaXhNYXAoXCJUcmFuc2l0aW9uXCIsIFwiVHJhbnNpdGlvbkNhbmNlbFwiKSxcbiAgICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKFwiVHJhbnNpdGlvblwiLCBcIlRyYW5zaXRpb25FbmRcIilcbiAgfSxcbiAgcHJlZml4ZWRFdmVudE5hbWVzID0ge30sXG4gIHN0eWxlID0ge307XG5jYW5Vc2VET00gJiZcbiAgKChzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUpLFxuICBcIkFuaW1hdGlvbkV2ZW50XCIgaW4gd2luZG93IHx8XG4gICAgKGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uLFxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLFxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFxuICBcIlRyYW5zaXRpb25FdmVudFwiIGluIHdpbmRvdyB8fFxuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHJldHVybiBldmVudE5hbWU7XG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdLFxuICAgIHN0eWxlUHJvcDtcbiAgZm9yIChzdHlsZVByb3AgaW4gcHJlZml4TWFwKVxuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpXG4gICAgICByZXR1cm4gKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF0pO1xuICByZXR1cm4gZXZlbnROYW1lO1xufVxudmFyIEFOSU1BVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbmVuZFwiKSxcbiAgQU5JTUFUSU9OX0lURVJBVElPTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpLFxuICBBTklNQVRJT05fU1RBUlQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcImFuaW1hdGlvbnN0YXJ0XCIpLFxuICBUUkFOU0lUSU9OX1JVTiA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbnJ1blwiKSxcbiAgVFJBTlNJVElPTl9TVEFSVCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbnN0YXJ0XCIpLFxuICBUUkFOU0lUSU9OX0NBTkNFTCA9IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKFwidHJhbnNpdGlvbmNhbmNlbFwiKSxcbiAgVFJBTlNJVElPTl9FTkQgPSBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShcInRyYW5zaXRpb25lbmRcIiksXG4gIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzID0gbmV3IE1hcCgpLFxuICBzaW1wbGVFdmVudFBsdWdpbkV2ZW50cyA9XG4gICAgXCJhYm9ydCBhdXhDbGljayBiZWZvcmVUb2dnbGUgY2FuY2VsIGNhblBsYXkgY2FuUGxheVRocm91Z2ggY2xpY2sgY2xvc2UgY29udGV4dE1lbnUgY29weSBjdXQgZHJhZyBkcmFnRW5kIGRyYWdFbnRlciBkcmFnRXhpdCBkcmFnTGVhdmUgZHJhZ092ZXIgZHJhZ1N0YXJ0IGRyb3AgZHVyYXRpb25DaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgZ290UG9pbnRlckNhcHR1cmUgaW5wdXQgaW52YWxpZCBrZXlEb3duIGtleVByZXNzIGtleVVwIGxvYWQgbG9hZGVkRGF0YSBsb2FkZWRNZXRhZGF0YSBsb2FkU3RhcnQgbG9zdFBvaW50ZXJDYXB0dXJlIG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHBvaW50ZXJDYW5jZWwgcG9pbnRlckRvd24gcG9pbnRlck1vdmUgcG9pbnRlck91dCBwb2ludGVyT3ZlciBwb2ludGVyVXAgcHJvZ3Jlc3MgcmF0ZUNoYW5nZSByZXNldCByZXNpemUgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdWJtaXQgc3VzcGVuZCB0aW1lVXBkYXRlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoU3RhcnQgdm9sdW1lQ2hhbmdlIHNjcm9sbCBzY3JvbGxFbmQgdG9nZ2xlIHRvdWNoTW92ZSB3YWl0aW5nIHdoZWVsXCIuc3BsaXQoXG4gICAgICBcIiBcIlxuICAgICk7XG5mdW5jdGlvbiByZWdpc3RlclNpbXBsZUV2ZW50KGRvbUV2ZW50TmFtZSwgcmVhY3ROYW1lKSB7XG4gIHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLnNldChkb21FdmVudE5hbWUsIHJlYWN0TmFtZSk7XG4gIHJlZ2lzdGVyVHdvUGhhc2VFdmVudChyZWFjdE5hbWUsIFtkb21FdmVudE5hbWVdKTtcbn1cbnZhciBjb25jdXJyZW50UXVldWVzID0gW10sXG4gIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDAsXG4gIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IDA7XG5mdW5jdGlvbiBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCkge1xuICBmb3IgKFxuICAgIHZhciBlbmRJbmRleCA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleCxcbiAgICAgIGkgPSAoY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMCk7XG4gICAgaSA8IGVuZEluZGV4O1xuXG4gICkge1xuICAgIHZhciBmaWJlciA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgcXVldWUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgbGFuZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICBpZiAobnVsbCAhPT0gcXVldWUgJiYgbnVsbCAhPT0gdXBkYXRlKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG4gICAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICAgID8gKHVwZGF0ZS5uZXh0ID0gdXBkYXRlKVxuICAgICAgICA6ICgodXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQpLCAocGVuZGluZy5uZXh0ID0gdXBkYXRlKSk7XG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cbiAgICAwICE9PSBsYW5lICYmIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBmaWJlcjtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBxdWV1ZTtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSB1cGRhdGU7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gbGFuZTtcbiAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzIHw9IGxhbmU7XG4gIGZpYmVyLmxhbmVzIHw9IGxhbmU7XG4gIGZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICBudWxsICE9PSBmaWJlciAmJiAoZmliZXIubGFuZXMgfD0gbGFuZSk7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKSB7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgbnVsbCwgbnVsbCwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgc291cmNlRmliZXIubGFuZXMgfD0gbGFuZTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gbGFuZSk7XG4gIGZvciAodmFyIGlzSGlkZGVuID0gITEsIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApXG4gICAgKHBhcmVudC5jaGlsZExhbmVzIHw9IGxhbmUpLFxuICAgICAgKGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGUpLFxuICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSBsYW5lKSxcbiAgICAgIDIyID09PSBwYXJlbnQudGFnICYmXG4gICAgICAgICgoc291cmNlRmliZXIgPSBwYXJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXIgfHwgc291cmNlRmliZXIuX3Zpc2liaWxpdHkgJiAxIHx8IChpc0hpZGRlbiA9ICEwKSksXG4gICAgICAoc291cmNlRmliZXIgPSBwYXJlbnQpLFxuICAgICAgKHBhcmVudCA9IHBhcmVudC5yZXR1cm4pO1xuICBpc0hpZGRlbiAmJlxuICAgIG51bGwgIT09IHVwZGF0ZSAmJlxuICAgIDMgPT09IHNvdXJjZUZpYmVyLnRhZyAmJlxuICAgICgocGFyZW50ID0gc291cmNlRmliZXIuc3RhdGVOb2RlKSxcbiAgICAoaXNIaWRkZW4gPSAzMSAtIGNsejMyKGxhbmUpKSxcbiAgICAocGFyZW50ID0gcGFyZW50LmhpZGRlblVwZGF0ZXMpLFxuICAgIChzb3VyY2VGaWJlciA9IHBhcmVudFtpc0hpZGRlbl0pLFxuICAgIG51bGwgPT09IHNvdXJjZUZpYmVyXG4gICAgICA/IChwYXJlbnRbaXNIaWRkZW5dID0gW3VwZGF0ZV0pXG4gICAgICA6IHNvdXJjZUZpYmVyLnB1c2godXBkYXRlKSxcbiAgICAodXBkYXRlLmxhbmUgPSBsYW5lIHwgNTM2ODcwOTEyKSk7XG59XG5mdW5jdGlvbiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKHNvdXJjZUZpYmVyKSB7XG4gIGlmICg1MCA8IG5lc3RlZFVwZGF0ZUNvdW50KVxuICAgIHRocm93IChcbiAgICAgICgobmVzdGVkVXBkYXRlQ291bnQgPSAwKSxcbiAgICAgIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsKSxcbiAgICAgIEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTg1KSkpXG4gICAgKTtcbiAgZm9yICh2YXIgcGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICAoc291cmNlRmliZXIgPSBwYXJlbnQpLCAocGFyZW50ID0gc291cmNlRmliZXIucmV0dXJuKTtcbiAgcmV0dXJuIDMgPT09IHNvdXJjZUZpYmVyLnRhZyA/IHNvdXJjZUZpYmVyLnN0YXRlTm9kZSA6IG51bGw7XG59XG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge30sXG4gIENhcHR1cmVkU3RhY2tzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2UpIHtcbiAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB2YWx1ZSAmJiBudWxsICE9PSB2YWx1ZSkge1xuICAgIHZhciBleGlzdGluZyA9IENhcHR1cmVkU3RhY2tzLmdldCh2YWx1ZSk7XG4gICAgaWYgKHZvaWQgMCAhPT0gZXhpc3RpbmcpIHJldHVybiBleGlzdGluZztcbiAgICBzb3VyY2UgPSB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgIHN0YWNrOiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKVxuICAgIH07XG4gICAgQ2FwdHVyZWRTdGFja3Muc2V0KHZhbHVlLCBzb3VyY2UpO1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG52YXIgZm9ya1N0YWNrID0gW10sXG4gIGZvcmtTdGFja0luZGV4ID0gMCxcbiAgdHJlZUZvcmtQcm92aWRlciA9IG51bGwsXG4gIHRyZWVGb3JrQ291bnQgPSAwLFxuICBpZFN0YWNrID0gW10sXG4gIGlkU3RhY2tJbmRleCA9IDAsXG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsLFxuICB0cmVlQ29udGV4dElkID0gMSxcbiAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IFwiXCI7XG5mdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgdHJlZUZvcmtQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgd29ya0luUHJvZ3Jlc3MgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICB2YXIgYmFzZUxlbmd0aCA9IDMyIC0gY2x6MzIoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgYmFzZUlkV2l0aExlYWRpbmdCaXQgJj0gfigxIDw8IGJhc2VMZW5ndGgpO1xuICBpbmRleCArPSAxO1xuICB2YXIgbGVuZ3RoID0gMzIgLSBjbHozMih0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7XG4gIGlmICgzMCA8IGxlbmd0aCkge1xuICAgIHZhciBudW1iZXJPZk92ZXJmbG93Qml0cyA9IGJhc2VMZW5ndGggLSAoYmFzZUxlbmd0aCAlIDUpO1xuICAgIGxlbmd0aCA9IChcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ICZcbiAgICAgICgoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxKVxuICAgICkudG9TdHJpbmcoMzIpO1xuICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0ID4+PSBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICBiYXNlTGVuZ3RoIC09IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgIHRyZWVDb250ZXh0SWQgPVxuICAgICAgKDEgPDwgKDMyIC0gY2x6MzIodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoKSkgfFxuICAgICAgKGluZGV4IDw8IGJhc2VMZW5ndGgpIHxcbiAgICAgIGJhc2VJZFdpdGhMZWFkaW5nQml0O1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBsZW5ndGggKyB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlXG4gICAgKHRyZWVDb250ZXh0SWQgPVxuICAgICAgKDEgPDwgbGVuZ3RoKSB8IChpbmRleCA8PCBiYXNlTGVuZ3RoKSB8IGJhc2VJZFdpdGhMZWFkaW5nQml0KSxcbiAgICAgICh0cmVlQ29udGV4dE92ZXJmbG93ID0gd29ya0luUHJvZ3Jlc3MpO1xufVxuZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm4gJiZcbiAgICAocHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCAxKSwgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgMSwgMCkpO1xufVxuZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgZm9yICg7IHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyOyApXG4gICAgKHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF0pLFxuICAgICAgKGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsKSxcbiAgICAgICh0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdKSxcbiAgICAgIChmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbCk7XG4gIGZvciAoOyB3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcjsgKVxuICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gaWRTdGFja1stLWlkU3RhY2tJbmRleF0pLFxuICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGwpLFxuICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XSksXG4gICAgICAoaWRTdGFja1tpZFN0YWNrSW5kZXhdID0gbnVsbCksXG4gICAgICAodHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdKSxcbiAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsKTtcbn1cbnZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGwsXG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsLFxuICBpc0h5ZHJhdGluZyA9ICExLFxuICBoeWRyYXRpb25FcnJvcnMgPSBudWxsLFxuICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEsXG4gIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MTkpKTtcbmZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICB2YXIgZXJyb3IgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQxOCwgXCJcIikpO1xuICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBmaWJlcikpO1xuICB0aHJvdyBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbjtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLFxuICAgIHR5cGUgPSBmaWJlci50eXBlLFxuICAgIHByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaWJlcjtcbiAgaW5zdGFuY2VbaW50ZXJuYWxQcm9wc0tleV0gPSBwcm9wcztcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImRpYWxvZ1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImNhbmNlbFwiLCBpbnN0YW5jZSk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2xvc2VcIiwgaW5zdGFuY2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlmcmFtZVwiOlxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ2aWRlb1wiOlxuICAgIGNhc2UgXCJhdWRpb1wiOlxuICAgICAgZm9yICh0eXBlID0gMDsgdHlwZSA8IG1lZGlhRXZlbnRUeXBlcy5sZW5ndGg7IHR5cGUrKylcbiAgICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbdHlwZV0sIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW1nXCI6XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgY2FzZSBcImxpbmtcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJlcnJvclwiLCBpbnN0YW5jZSk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZGV0YWlsc1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBpbnN0YW5jZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5wdXRcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGluc3RhbmNlKTtcbiAgICAgIGluaXRJbnB1dChcbiAgICAgICAgaW5zdGFuY2UsXG4gICAgICAgIHByb3BzLnZhbHVlLFxuICAgICAgICBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgICAgIHByb3BzLmNoZWNrZWQsXG4gICAgICAgIHByb3BzLmRlZmF1bHRDaGVja2VkLFxuICAgICAgICBwcm9wcy50eXBlLFxuICAgICAgICBwcm9wcy5uYW1lLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgICAgIHRyYWNrKGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJpbnZhbGlkXCIsIGluc3RhbmNlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0ZXh0YXJlYVwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImludmFsaWRcIiwgaW5zdGFuY2UpLFxuICAgICAgICBpbml0VGV4dGFyZWEoaW5zdGFuY2UsIHByb3BzLnZhbHVlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHByb3BzLmNoaWxkcmVuKSxcbiAgICAgICAgdHJhY2soaW5zdGFuY2UpO1xuICB9XG4gIHR5cGUgPSBwcm9wcy5jaGlsZHJlbjtcbiAgKFwic3RyaW5nXCIgIT09IHR5cGVvZiB0eXBlICYmXG4gICAgXCJudW1iZXJcIiAhPT0gdHlwZW9mIHR5cGUgJiZcbiAgICBcImJpZ2ludFwiICE9PSB0eXBlb2YgdHlwZSkgfHxcbiAgaW5zdGFuY2UudGV4dENvbnRlbnQgPT09IFwiXCIgKyB0eXBlIHx8XG4gICEwID09PSBwcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgfHxcbiAgY2hlY2tGb3JVbm1hdGNoZWRUZXh0KGluc3RhbmNlLnRleHRDb250ZW50LCB0eXBlKVxuICAgID8gKG51bGwgIT0gcHJvcHMucG9wb3ZlciAmJlxuICAgICAgICAobGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImJlZm9yZXRvZ2dsZVwiLCBpbnN0YW5jZSksXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJ0b2dnbGVcIiwgaW5zdGFuY2UpKSxcbiAgICAgIG51bGwgIT0gcHJvcHMub25TY3JvbGwgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBpbnN0YW5jZSksXG4gICAgICBudWxsICE9IHByb3BzLm9uU2Nyb2xsRW5kICYmXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJzY3JvbGxlbmRcIiwgaW5zdGFuY2UpLFxuICAgICAgbnVsbCAhPSBwcm9wcy5vbkNsaWNrICYmIChpbnN0YW5jZS5vbmNsaWNrID0gbm9vcCQxKSxcbiAgICAgIChpbnN0YW5jZSA9ICEwKSlcbiAgICA6IChpbnN0YW5jZSA9ICExKTtcbiAgaW5zdGFuY2UgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgZm9yIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjsgaHlkcmF0aW9uUGFyZW50RmliZXI7IClcbiAgICBzd2l0Y2ggKGh5ZHJhdGlvblBhcmVudEZpYmVyLnRhZykge1xuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSAyNzpcbiAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICEwO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDU6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHJldHVybiAhMTtcbiAgaWYgKCFpc0h5ZHJhdGluZykgcmV0dXJuIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpLCAoaXNIeWRyYXRpbmcgPSAhMCksICExO1xuICB2YXIgc2hvdWxkQ2xlYXIgPSAhMSxcbiAgICBKU0NvbXBpbGVyX3RlbXA7XG4gIGlmICgoSlNDb21waWxlcl90ZW1wID0gMyAhPT0gZmliZXIudGFnICYmIDI3ICE9PSBmaWJlci50YWcpKSB7XG4gICAgaWYgKChKU0NvbXBpbGVyX3RlbXAgPSA1ID09PSBmaWJlci50YWcpKVxuICAgICAgKEpTQ29tcGlsZXJfdGVtcCA9IGZpYmVyLnR5cGUpLFxuICAgICAgICAoSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAhKFwiZm9ybVwiICE9PSBKU0NvbXBpbGVyX3RlbXAgJiYgXCJidXR0b25cIiAhPT0gSlNDb21waWxlcl90ZW1wKSB8fFxuICAgICAgICAgIHNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKTtcbiAgICBKU0NvbXBpbGVyX3RlbXAgPSAhSlNDb21waWxlcl90ZW1wO1xuICB9XG4gIEpTQ29tcGlsZXJfdGVtcCAmJiAoc2hvdWxkQ2xlYXIgPSAhMCk7XG4gIHNob3VsZENsZWFyICYmIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgJiYgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIGlmICgxMyA9PT0gZmliZXIudGFnKSB7XG4gICAgZmliZXIgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICAgIGZpYmVyID0gbnVsbCAhPT0gZmliZXIgPyBmaWJlci5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICBpZiAoIWZpYmVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxNykpO1xuICAgIGE6IHtcbiAgICAgIGZpYmVyID0gZmliZXIubmV4dFNpYmxpbmc7XG4gICAgICBmb3IgKHNob3VsZENsZWFyID0gMDsgZmliZXI7ICkge1xuICAgICAgICBpZiAoOCA9PT0gZmliZXIubm9kZVR5cGUpXG4gICAgICAgICAgaWYgKCgoSlNDb21waWxlcl90ZW1wID0gZmliZXIuZGF0YSksIFwiLyRcIiA9PT0gSlNDb21waWxlcl90ZW1wKSkge1xuICAgICAgICAgICAgaWYgKDAgPT09IHNob3VsZENsZWFyKSB7XG4gICAgICAgICAgICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShmaWJlci5uZXh0U2libGluZyk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaG91bGRDbGVhci0tO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgKFwiJFwiICE9PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgXCIkIVwiICE9PSBKU0NvbXBpbGVyX3RlbXAgJiZcbiAgICAgICAgICAgICAgXCIkP1wiICE9PSBKU0NvbXBpbGVyX3RlbXApIHx8XG4gICAgICAgICAgICAgIHNob3VsZENsZWFyKys7XG4gICAgICAgIGZpYmVyID0gZmliZXIubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICB9XG4gIH0gZWxzZVxuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlclxuICAgICAgPyBnZXROZXh0SHlkcmF0YWJsZShmaWJlci5zdGF0ZU5vZGUubmV4dFNpYmxpbmcpXG4gICAgICA6IG51bGw7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIGlzSHlkcmF0aW5nID0gITE7XG59XG5mdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gIG51bGwgPT09IGh5ZHJhdGlvbkVycm9yc1xuICAgID8gKGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl0pXG4gICAgOiBoeWRyYXRpb25FcnJvcnMucHVzaChlcnJvcik7XG59XG52YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ2MCkpLFxuICBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24gPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ3NCkpLFxuICBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgPSB7IHRoZW46IGZ1bmN0aW9uICgpIHt9IH07XG5mdW5jdGlvbiBpc1RoZW5hYmxlUmVzb2x2ZWQodGhlbmFibGUpIHtcbiAgdGhlbmFibGUgPSB0aGVuYWJsZS5zdGF0dXM7XG4gIHJldHVybiBcImZ1bGZpbGxlZFwiID09PSB0aGVuYWJsZSB8fCBcInJlamVjdGVkXCIgPT09IHRoZW5hYmxlO1xufVxuZnVuY3Rpb24gbm9vcCQzKCkge31cbmZ1bmN0aW9uIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCkge1xuICBpbmRleCA9IHRoZW5hYmxlU3RhdGVbaW5kZXhdO1xuICB2b2lkIDAgPT09IGluZGV4XG4gICAgPyB0aGVuYWJsZVN0YXRlLnB1c2godGhlbmFibGUpXG4gICAgOiBpbmRleCAhPT0gdGhlbmFibGUgJiYgKHRoZW5hYmxlLnRoZW4obm9vcCQzLCBub29wJDMpLCAodGhlbmFibGUgPSBpbmRleCkpO1xuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICBjYXNlIFwicmVqZWN0ZWRcIjpcbiAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICBpZiAodGhlbmFibGVTdGF0ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24pXG4gICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDgzKSk7XG4gICAgICB0aHJvdyB0aGVuYWJsZVN0YXRlO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1cykgdGhlbmFibGUudGhlbihub29wJDMsIG5vb3AkMyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhlbmFibGVTdGF0ZSA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgICAgaWYgKG51bGwgIT09IHRoZW5hYmxlU3RhdGUgJiYgMTAwIDwgdGhlbmFibGVTdGF0ZS5zaGVsbFN1c3BlbmRDb3VudGVyKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDgyKSk7XG4gICAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZTtcbiAgICAgICAgdGhlbmFibGVTdGF0ZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgICAgICAgdGhlbmFibGVTdGF0ZS50aGVuKFxuICAgICAgICAgIGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlID0gZnVsZmlsbGVkVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChcInBlbmRpbmdcIiA9PT0gdGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJmdWxmaWxsZWRcIjpcbiAgICAgICAgICByZXR1cm4gdGhlbmFibGUudmFsdWU7XG4gICAgICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgICAgIHRoZW5hYmxlU3RhdGUgPSB0aGVuYWJsZS5yZWFzb247XG4gICAgICAgICAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IFN1c3BlbnNlRXhjZXB0aW9uKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0ODMpKTtcbiAgICAgICAgICB0aHJvdyB0aGVuYWJsZVN0YXRlO1xuICAgICAgfVxuICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICB9XG59XG52YXIgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSB7XG4gIGlmIChudWxsID09PSBzdXNwZW5kZWRUaGVuYWJsZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTkpKTtcbiAgdmFyIHRoZW5hYmxlID0gc3VzcGVuZGVkVGhlbmFibGU7XG4gIHN1c3BlbmRlZFRoZW5hYmxlID0gbnVsbDtcbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxudmFyIHRoZW5hYmxlU3RhdGUkMSA9IG51bGwsXG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuICBudWxsID09PSB0aGVuYWJsZVN0YXRlJDEgJiYgKHRoZW5hYmxlU3RhdGUkMSA9IFtdKTtcbiAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUkMSwgdGhlbmFibGUsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGNvZXJjZVJlZih3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCkge1xuICBlbGVtZW50ID0gZWxlbWVudC5wcm9wcy5yZWY7XG4gIHdvcmtJblByb2dyZXNzLnJlZiA9IHZvaWQgMCAhPT0gZWxlbWVudCA/IGVsZW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUpXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjUpKTtcbiAgcmV0dXJuRmliZXIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICB0aHJvdyBFcnJvcihcbiAgICBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKFxuICAgICAgMzEsXG4gICAgICBcIltvYmplY3QgT2JqZWN0XVwiID09PSByZXR1cm5GaWJlclxuICAgICAgICA/IFwib2JqZWN0IHdpdGgga2V5cyB7XCIgKyBPYmplY3Qua2V5cyhuZXdDaGlsZCkuam9pbihcIiwgXCIpICsgXCJ9XCJcbiAgICAgICAgOiByZXR1cm5GaWJlclxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVMYXp5KGxhenlUeXBlKSB7XG4gIHZhciBpbml0ID0gbGF6eVR5cGUuX2luaXQ7XG4gIHJldHVybiBpbml0KGxhenlUeXBlLl9wYXlsb2FkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG4gICAgICBudWxsID09PSBkZWxldGlvbnNcbiAgICAgICAgPyAoKHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXSksIChyZXR1cm5GaWJlci5mbGFncyB8PSAxNikpXG4gICAgICAgIDogZGVsZXRpb25zLnB1c2goY2hpbGRUb0RlbGV0ZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykgcmV0dXJuIG51bGw7XG4gICAgZm9yICg7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpLFxuICAgICAgICAoY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGZvciAodmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7IG51bGwgIT09IGN1cnJlbnRGaXJzdENoaWxkOyApXG4gICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZC5rZXlcbiAgICAgICAgPyBleGlzdGluZ0NoaWxkcmVuLnNldChjdXJyZW50Rmlyc3RDaGlsZC5rZXksIGN1cnJlbnRGaXJzdENoaWxkKVxuICAgICAgICA6IGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGN1cnJlbnRGaXJzdENoaWxkLmluZGV4LCBjdXJyZW50Rmlyc3RDaGlsZCksXG4gICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMpIHtcbiAgICBmaWJlciA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGZpYmVyLmluZGV4ID0gMDtcbiAgICBmaWJlci5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKVxuICAgICAgcmV0dXJuIChuZXdGaWJlci5mbGFncyB8PSAxMDQ4NTc2KSwgbGFzdFBsYWNlZEluZGV4O1xuICAgIG5ld0luZGV4ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChudWxsICE9PSBuZXdJbmRleClcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChuZXdJbmRleCA9IG5ld0luZGV4LmluZGV4KSxcbiAgICAgICAgbmV3SW5kZXggPCBsYXN0UGxhY2VkSW5kZXhcbiAgICAgICAgICA/ICgobmV3RmliZXIuZmxhZ3MgfD0gMzM1NTQ0MzQpLCBsYXN0UGxhY2VkSW5kZXgpXG4gICAgICAgICAgOiBuZXdJbmRleFxuICAgICAgKTtcbiAgICBuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNDtcbiAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICB9XG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICBudWxsID09PSBuZXdGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgIChuZXdGaWJlci5mbGFncyB8PSAzMzU1NDQzNCk7XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCA2ICE9PSBjdXJyZW50LnRhZylcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjdXJyZW50ID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpKSxcbiAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICBjdXJyZW50XG4gICAgICApO1xuICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBsYW5lcykge1xuICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpXG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBlbGVtZW50LnByb3BzLmNoaWxkcmVuLFxuICAgICAgICBsYW5lcyxcbiAgICAgICAgZWxlbWVudC5rZXlcbiAgICAgICk7XG4gICAgaWYgKFxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudFR5cGUgJiZcbiAgICAgICAgICBudWxsICE9PSBlbGVtZW50VHlwZSAmJlxuICAgICAgICAgIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiZcbiAgICAgICAgICByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGN1cnJlbnQudHlwZSkpXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKSksXG4gICAgICAgIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSxcbiAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICBjdXJyZW50XG4gICAgICApO1xuICAgIGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gICAgICBlbGVtZW50LnR5cGUsXG4gICAgICBlbGVtZW50LmtleSxcbiAgICAgIGVsZW1lbnQucHJvcHMsXG4gICAgICBudWxsLFxuICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgIGxhbmVzXG4gICAgKTtcbiAgICBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMpIHtcbiAgICBpZiAoXG4gICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICA0ICE9PSBjdXJyZW50LnRhZyB8fFxuICAgICAgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHxcbiAgICAgIGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgICApXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgIChjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgY3VycmVudFxuICAgICAgKTtcbiAgICBjdXJyZW50ID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICBjdXJyZW50LnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgbGFuZXMsIGtleSkge1xuICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IDcgIT09IGN1cnJlbnQudGFnKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGN1cnJlbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICBmcmFnbWVudCxcbiAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgIGtleVxuICAgICAgICApKSxcbiAgICAgICAgKGN1cnJlbnQucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICBjdXJyZW50XG4gICAgICApO1xuICAgIGN1cnJlbnQgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgY3VycmVudC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgaWYgKFxuICAgICAgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKG5ld0NoaWxkID0gY3JlYXRlRmliZXJGcm9tVGV4dChcbiAgICAgICAgICBcIlwiICsgbmV3Q2hpbGQsXG4gICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApKSxcbiAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgbmV3Q2hpbGRcbiAgICAgICk7XG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBudWxsICE9PSBuZXdDaGlsZCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGxhbmVzID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKFxuICAgICAgICAgICAgICBuZXdDaGlsZC50eXBlLFxuICAgICAgICAgICAgICBuZXdDaGlsZC5rZXksXG4gICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBsYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLm1vZGUsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChuZXdDaGlsZC5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgbmV3Q2hpbGQgPSBpbml0KG5ld0NoaWxkLl9wYXlsb2FkKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIChuZXdDaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgbGFuZXMsXG4gICAgICAgICAgICBudWxsXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKG5ld0NoaWxkLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICBuZXdDaGlsZFxuICAgICAgICApO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLCBsYW5lcyk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNoaWxkKFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIG5ld0NoaWxkKSxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpIHtcbiAgICB2YXIga2V5ID0gbnVsbCAhPT0gb2xkRmliZXIgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuICAgIGlmIChcbiAgICAgIChcInN0cmluZ1wiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgXCJcIiAhPT0gbmV3Q2hpbGQpIHx8XG4gICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgbmV3Q2hpbGQgfHxcbiAgICAgIFwiYmlnaW50XCIgPT09IHR5cGVvZiBuZXdDaGlsZFxuICAgIClcbiAgICAgIHJldHVybiBudWxsICE9PSBrZXlcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKTtcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBuZXdDaGlsZC5rZXkgPT09IGtleVxuICAgICAgICAgICAgPyB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBuZXdDaGlsZC5rZXkgPT09IGtleVxuICAgICAgICAgICAgPyB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoa2V5ID0gbmV3Q2hpbGQuX2luaXQpLFxuICAgICAgICAgICAgKG5ld0NoaWxkID0ga2V5KG5ld0NoaWxkLl9wYXlsb2FkKSksXG4gICAgICAgICAgICB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUltcGwobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKVxuICAgICAgICByZXR1cm4gbnVsbCAhPT0ga2V5XG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgb2xkRmliZXIsXG4gICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChcbiAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgIHJldHVybkZpYmVyLFxuICAgIG5ld0lkeCxcbiAgICBuZXdDaGlsZCxcbiAgICBsYW5lc1xuICApIHtcbiAgICBpZiAoXG4gICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIFwiXCIgIT09IG5ld0NoaWxkKSB8fFxuICAgICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIG5ld0NoaWxkIHx8XG4gICAgICBcImJpZ2ludFwiID09PSB0eXBlb2YgbmV3Q2hpbGRcbiAgICApXG4gICAgICByZXR1cm4gKFxuICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbCksXG4gICAgICAgIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBcIlwiICsgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgKTtcbiAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5ld0NoaWxkICYmIG51bGwgIT09IG5ld0NoaWxkKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZXhpc3RpbmdDaGlsZHJlbiA9XG4gICAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KFxuICAgICAgICAgICAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleVxuICAgICAgICAgICAgICApIHx8IG51bGwpLFxuICAgICAgICAgICAgdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgZXhpc3RpbmdDaGlsZHJlbiwgbmV3Q2hpbGQsIGxhbmVzKVxuICAgICAgICAgICk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChleGlzdGluZ0NoaWxkcmVuID1cbiAgICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5nZXQoXG4gICAgICAgICAgICAgICAgbnVsbCA9PT0gbmV3Q2hpbGQua2V5ID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICkgfHwgbnVsbCksXG4gICAgICAgICAgICB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGV4aXN0aW5nQ2hpbGRyZW4sIG5ld0NoaWxkLCBsYW5lcylcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgIG5ld0NoaWxkID0gaW5pdChuZXdDaGlsZC5fcGF5bG9hZCk7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLFxuICAgICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKGV4aXN0aW5nQ2hpbGRyZW4gPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGwpLFxuICAgICAgICAgIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBleGlzdGluZ0NoaWxkcmVuLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwpXG4gICAgICAgICk7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbmV3Q2hpbGQudGhlbilcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoXG4gICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbixcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBuZXdJZHgsXG4gICAgICAgICAgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgbmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICBuZXdDaGlsZHJlbixcbiAgICBsYW5lc1xuICApIHtcbiAgICBmb3IgKFxuICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbnVsbCxcbiAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgICBudWxsICE9PSBvbGRGaWJlciAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7XG4gICAgICBuZXdJZHgrK1xuICAgICkge1xuICAgICAgb2xkRmliZXIuaW5kZXggPiBuZXdJZHhcbiAgICAgICAgPyAoKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyKSwgKG9sZEZpYmVyID0gbnVsbCkpXG4gICAgICAgIDogKG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmcpO1xuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICBsYW5lc1xuICAgICAgKTtcbiAgICAgIGlmIChudWxsID09PSBuZXdGaWJlcikge1xuICAgICAgICBudWxsID09PSBvbGRGaWJlciAmJiAob2xkRmliZXIgPSBuZXh0T2xkRmliZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiZcbiAgICAgICAgb2xkRmliZXIgJiZcbiAgICAgICAgbnVsbCA9PT0gbmV3RmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdJZHgpO1xuICAgICAgbnVsbCA9PT0gcHJldmlvdXNOZXdGaWJlclxuICAgICAgICA/IChyZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXIpXG4gICAgICAgIDogKHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyKTtcbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpXG4gICAgICByZXR1cm4gKFxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpLFxuICAgICAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCksXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGRcbiAgICAgICk7XG4gICAgaWYgKG51bGwgPT09IG9sZEZpYmVyKSB7XG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKylcbiAgICAgICAgKG9sZEZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzKSksXG4gICAgICAgICAgbnVsbCAhPT0gb2xkRmliZXIgJiZcbiAgICAgICAgICAgICgoY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKFxuICAgICAgICAgICAgICBvbGRGaWJlcixcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBvbGRGaWJlcilcbiAgICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gb2xkRmliZXIpLFxuICAgICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBvbGRGaWJlcikpO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBvbGRGaWJlciA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTtcbiAgICAgIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgIG5ld0lkeCsrXG4gICAgKVxuICAgICAgKG5leHRPbGRGaWJlciA9IHVwZGF0ZUZyb21NYXAoXG4gICAgICAgIG9sZEZpYmVyLFxuICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgbmV3SWR4LFxuICAgICAgICBuZXdDaGlsZHJlbltuZXdJZHhdLFxuICAgICAgICBsYW5lc1xuICAgICAgKSksXG4gICAgICAgIG51bGwgIT09IG5leHRPbGRGaWJlciAmJlxuICAgICAgICAgIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsICE9PSBuZXh0T2xkRmliZXIuYWx0ZXJuYXRlICYmXG4gICAgICAgICAgICBvbGRGaWJlci5kZWxldGUoXG4gICAgICAgICAgICAgIG51bGwgPT09IG5leHRPbGRGaWJlci5rZXkgPyBuZXdJZHggOiBuZXh0T2xkRmliZXIua2V5XG4gICAgICAgICAgICApLFxuICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoXG4gICAgICAgICAgICBuZXh0T2xkRmliZXIsXG4gICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgIG5ld0lkeFxuICAgICAgICAgICkpLFxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXh0T2xkRmliZXIpXG4gICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXh0T2xkRmliZXIpLFxuICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gbmV4dE9sZEZpYmVyKSk7XG4gICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICByZXR1cm5GaWJlcixcbiAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICBuZXdDaGlsZHJlbixcbiAgICBsYW5lc1xuICApIHtcbiAgICBpZiAobnVsbCA9PSBuZXdDaGlsZHJlbikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNTEpKTtcbiAgICBmb3IgKFxuICAgICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsLFxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gbnVsbCxcbiAgICAgICAgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3SWR4ID0gKGN1cnJlbnRGaXJzdENoaWxkID0gMCksXG4gICAgICAgIG5leHRPbGRGaWJlciA9IG51bGwsXG4gICAgICAgIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICBudWxsICE9PSBvbGRGaWJlciAmJiAhc3RlcC5kb25lO1xuICAgICAgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KClcbiAgICApIHtcbiAgICAgIG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4XG4gICAgICAgID8gKChuZXh0T2xkRmliZXIgPSBvbGRGaWJlciksIChvbGRGaWJlciA9IG51bGwpKVxuICAgICAgICA6IChuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nKTtcbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBsYW5lcyk7XG4gICAgICBpZiAobnVsbCA9PT0gbmV3RmliZXIpIHtcbiAgICAgICAgbnVsbCA9PT0gb2xkRmliZXIgJiYgKG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgIG9sZEZpYmVyICYmXG4gICAgICAgIG51bGwgPT09IG5ld0ZpYmVyLmFsdGVybmF0ZSAmJlxuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KTtcbiAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgPyAocmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyKVxuICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcik7XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG4gICAgaWYgKHN0ZXAuZG9uZSlcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlciksXG4gICAgICAgIGlzSHlkcmF0aW5nICYmIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbmV3SWR4KSxcbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZFxuICAgICAgKTtcbiAgICBpZiAobnVsbCA9PT0gb2xkRmliZXIpIHtcbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSlcbiAgICAgICAgKHN0ZXAgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMpKSxcbiAgICAgICAgICBudWxsICE9PSBzdGVwICYmXG4gICAgICAgICAgICAoKGN1cnJlbnRGaXJzdENoaWxkID0gcGxhY2VDaGlsZChzdGVwLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3SWR4KSksXG4gICAgICAgICAgICBudWxsID09PSBwcmV2aW91c05ld0ZpYmVyXG4gICAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBzdGVwKVxuICAgICAgICAgICAgICA6IChwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBzdGVwKSxcbiAgICAgICAgICAgIChwcmV2aW91c05ld0ZpYmVyID0gc3RlcCkpO1xuICAgICAgaXNIeWRyYXRpbmcgJiYgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBuZXdJZHgpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICBvbGRGaWJlciA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTtcbiAgICAgICFzdGVwLmRvbmU7XG4gICAgICBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKVxuICAgIClcbiAgICAgIChzdGVwID0gdXBkYXRlRnJvbU1hcChvbGRGaWJlciwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgbGFuZXMpKSxcbiAgICAgICAgbnVsbCAhPT0gc3RlcCAmJlxuICAgICAgICAgIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmXG4gICAgICAgICAgICBudWxsICE9PSBzdGVwLmFsdGVybmF0ZSAmJlxuICAgICAgICAgICAgb2xkRmliZXIuZGVsZXRlKG51bGwgPT09IHN0ZXAua2V5ID8gbmV3SWR4IDogc3RlcC5rZXkpLFxuICAgICAgICAgIChjdXJyZW50Rmlyc3RDaGlsZCA9IHBsYWNlQ2hpbGQoc3RlcCwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0lkeCkpLFxuICAgICAgICAgIG51bGwgPT09IHByZXZpb3VzTmV3RmliZXJcbiAgICAgICAgICAgID8gKHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBzdGVwKVxuICAgICAgICAgICAgOiAocHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gc3RlcCksXG4gICAgICAgICAgKHByZXZpb3VzTmV3RmliZXIgPSBzdGVwKSk7XG4gICAgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJlxuICAgICAgb2xkRmliZXIuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICBpc0h5ZHJhdGluZyAmJiBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG5ld0lkeCk7XG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKFxuICAgIHJldHVybkZpYmVyLFxuICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgIG5ld0NoaWxkLFxuICAgIGxhbmVzXG4gICkge1xuICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJlxuICAgICAgbnVsbCAhPT0gbmV3Q2hpbGQgJiZcbiAgICAgIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiZcbiAgICAgIG51bGwgPT09IG5ld0NoaWxkLmtleSAmJlxuICAgICAgKG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4pO1xuICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgbmV3Q2hpbGQgJiYgbnVsbCAhPT0gbmV3Q2hpbGQpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5ID0gbmV3Q2hpbGQua2V5OyBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZDsgKSB7XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGtleSA9IG5ld0NoaWxkLnR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgICAgaWYgKDcgPT09IGN1cnJlbnRGaXJzdENoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVzID0gdXNlRmliZXIoXG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLmVsZW1lbnRUeXBlID09PSBrZXkgfHxcbiAgICAgICAgICAgICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2Yga2V5ICYmXG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IGtleSAmJlxuICAgICAgICAgICAgICAgICAgICBrZXkuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlTGF6eShrZXkpID09PSBjdXJyZW50Rmlyc3RDaGlsZC50eXBlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgY29lcmNlUmVmKGxhbmVzLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICAgICAgICBsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyID0gbGFuZXM7XG4gICAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9IGVsc2UgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgobGFuZXMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLFxuICAgICAgICAgICAgICAgICAgcmV0dXJuRmliZXIubW9kZSxcbiAgICAgICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQua2V5XG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgICAgKGxhbmVzLnJldHVybiA9IHJldHVybkZpYmVyKSxcbiAgICAgICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgICAgIDogKChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIG5ld0NoaWxkLnR5cGUsXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZC5rZXksXG4gICAgICAgICAgICAgICAgICBuZXdDaGlsZC5wcm9wcyxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlci5tb2RlLFxuICAgICAgICAgICAgICAgICAgbGFuZXNcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICBjb2VyY2VSZWYobGFuZXMsIG5ld0NoaWxkKSxcbiAgICAgICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgIChyZXR1cm5GaWJlciA9IGxhbmVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJldHVybkZpYmVyKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICBhOiB7XG4gICAgICAgICAgICBmb3IgKGtleSA9IG5ld0NoaWxkLmtleTsgbnVsbCAhPT0gY3VycmVudEZpcnN0Q2hpbGQ7ICkge1xuICAgICAgICAgICAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQua2V5ID09PSBrZXkpXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgNCA9PT0gY3VycmVudEZpcnN0Q2hpbGQudGFnICYmXG4gICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT1cbiAgICAgICAgICAgICAgICAgICAgbmV3Q2hpbGQuY29udGFpbmVySW5mbyAmJlxuICAgICAgICAgICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PVxuICAgICAgICAgICAgICAgICAgICBuZXdDaGlsZC5pbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4oXG4gICAgICAgICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgbGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgICAgICAgbGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm5GaWJlciA9IGxhbmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcik7XG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoa2V5ID0gbmV3Q2hpbGQuX2luaXQpLFxuICAgICAgICAgICAgKG5ld0NoaWxkID0ga2V5KG5ld0NoaWxkLl9wYXlsb2FkKSksXG4gICAgICAgICAgICByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgICAgICAgIGxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5SW1wbChuZXdDaGlsZCkpXG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KFxuICAgICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICAgIGN1cnJlbnRGaXJzdENoaWxkLFxuICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAga2V5ID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBrZXkpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTUwKSk7XG4gICAgICAgIG5ld0NoaWxkID0ga2V5LmNhbGwobmV3Q2hpbGQpO1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICBsYW5lc1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG5ld0NoaWxkLnRoZW4pXG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgICAgY3VycmVudEZpcnN0Q2hpbGQsXG4gICAgICAgICAgdW53cmFwVGhlbmFibGUobmV3Q2hpbGQpLFxuICAgICAgICAgIGxhbmVzXG4gICAgICAgICk7XG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSlcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChcbiAgICAgICAgICByZXR1cm5GaWJlcixcbiAgICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgICByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBuZXdDaGlsZCksXG4gICAgICAgICAgbGFuZXNcbiAgICAgICAgKTtcbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdDaGlsZCAmJiBcIlwiICE9PSBuZXdDaGlsZCkgfHxcbiAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBuZXdDaGlsZCB8fFxuICAgICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIG5ld0NoaWxkXG4gICAgICA/ICgobmV3Q2hpbGQgPSBcIlwiICsgbmV3Q2hpbGQpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50Rmlyc3RDaGlsZCAmJiA2ID09PSBjdXJyZW50Rmlyc3RDaGlsZC50YWdcbiAgICAgICAgICA/IChkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyksXG4gICAgICAgICAgICAobGFuZXMgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQpKSxcbiAgICAgICAgICAgIChsYW5lcy5yZXR1cm4gPSByZXR1cm5GaWJlciksXG4gICAgICAgICAgICAocmV0dXJuRmliZXIgPSBsYW5lcykpXG4gICAgICAgICAgOiAoZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSxcbiAgICAgICAgICAgIChsYW5lcyA9IGNyZWF0ZUZpYmVyRnJvbVRleHQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKSksXG4gICAgICAgICAgICAobGFuZXMucmV0dXJuID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgKHJldHVybkZpYmVyID0gbGFuZXMpKSxcbiAgICAgICAgcGxhY2VTaW5nbGVDaGlsZChyZXR1cm5GaWJlcikpXG4gICAgICA6IGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIHRyeSB7XG4gICAgICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgICAgIHZhciBmaXJzdENoaWxkRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwoXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICBjdXJyZW50Rmlyc3RDaGlsZCxcbiAgICAgICAgbmV3Q2hpbGQsXG4gICAgICAgIGxhbmVzXG4gICAgICApO1xuICAgICAgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbiAgICAgIHJldHVybiBmaXJzdENoaWxkRmliZXI7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgaWYgKHggPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB0aHJvdyB4O1xuICAgICAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMjksIHgsIG51bGwsIHJldHVybkZpYmVyLm1vZGUpO1xuICAgICAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgICAgIGZpYmVyLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH0gZmluYWxseSB7XG4gICAgfVxuICB9O1xufVxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKCEwKSxcbiAgbW91bnRDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcighMSksXG4gIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcigwKTtcbmZ1bmN0aW9uIHB1c2hIaWRkZW5Db250ZXh0KGZpYmVyLCBjb250ZXh0KSB7XG4gIGZpYmVyID0gZW50YW5nbGVkUmVuZGVyTGFuZXM7XG4gIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBmaWJlcik7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCk7XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gZmliZXIgfCBjb250ZXh0LmJhc2VMYW5lcztcbn1cbmZ1bmN0aW9uIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2soKSB7XG4gIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KTtcbn1cbmZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoKSB7XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLmN1cnJlbnQ7XG4gIHBvcChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yKTtcbiAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvcik7XG59XG52YXIgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIHNoZWxsQm91bmRhcnkgPSBudWxsO1xuZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiAxKTtcbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlcik7XG4gIG51bGwgPT09IHNoZWxsQm91bmRhcnkgJiZcbiAgICAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsICE9PSBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnRcbiAgICAgID8gKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKVxuICAgICAgOiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiYgKHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyKSk7XG59XG5mdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIGlmICgyMiA9PT0gZmliZXIudGFnKSB7XG4gICAgaWYgKFxuICAgICAgKHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KSxcbiAgICAgIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGZpYmVyKSxcbiAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnkpXG4gICAgKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgIChzaGVsbEJvdW5kYXJ5ID0gZmliZXIpO1xuICAgIH1cbiAgfSBlbHNlIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG59XG5mdW5jdGlvbiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soKSB7XG4gIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCk7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yKTtcbiAgc2hlbGxCb3VuZGFyeSA9PT0gZmliZXIgJiYgKHNoZWxsQm91bmRhcnkgPSBudWxsKTtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IpO1xufVxudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoMCk7XG5mdW5jdGlvbiBmaW5kRmlyc3RTdXNwZW5kZWQocm93KSB7XG4gIGZvciAodmFyIG5vZGUgPSByb3c7IG51bGwgIT09IG5vZGU7ICkge1xuICAgIGlmICgxMyA9PT0gbm9kZS50YWcpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIGlmIChcbiAgICAgICAgbnVsbCAhPT0gc3RhdGUgJiZcbiAgICAgICAgKChzdGF0ZSA9IHN0YXRlLmRlaHlkcmF0ZWQpLFxuICAgICAgICBudWxsID09PSBzdGF0ZSB8fCBcIiQ/XCIgPT09IHN0YXRlLmRhdGEgfHwgXCIkIVwiID09PSBzdGF0ZS5kYXRhKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKDE5ID09PSBub2RlLnRhZyAmJiB2b2lkIDAgIT09IG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlcikge1xuICAgICAgaWYgKDAgIT09IChub2RlLmZsYWdzICYgMTI4KSkgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChudWxsICE9PSBub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gcm93KSBicmVhaztcbiAgICBmb3IgKDsgbnVsbCA9PT0gbm9kZS5zaWJsaW5nOyApIHtcbiAgICAgIGlmIChudWxsID09PSBub2RlLnJldHVybiB8fCBub2RlLnJldHVybiA9PT0gcm93KSByZXR1cm4gbnVsbDtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgQWJvcnRDb250cm9sbGVyTG9jYWwgPVxuICAgIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBBYm9ydENvbnRyb2xsZXJcbiAgICAgID8gQWJvcnRDb250cm9sbGVyXG4gICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gW10sXG4gICAgICAgICAgICBzaWduYWwgPSAodGhpcy5zaWduYWwgPSB7XG4gICAgICAgICAgICAgIGFib3J0ZWQ6ICExLFxuICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzaWduYWwuYWJvcnRlZCA9ICEwO1xuICAgICAgICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgc2NoZWR1bGVDYWxsYmFjayQyID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gIE5vcm1hbFByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5LFxuICBDYWNoZUNvbnRleHQgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBDb25zdW1lcjogbnVsbCxcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBfY3VycmVudFZhbHVlOiBudWxsLFxuICAgIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICAgIF90aHJlYWRDb3VudDogMFxuICB9O1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG4gIHJldHVybiB7XG4gICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlckxvY2FsKCksXG4gICAgZGF0YTogbmV3IE1hcCgpLFxuICAgIHJlZkNvdW50OiAwXG4gIH07XG59XG5mdW5jdGlvbiByZWxlYXNlQ2FjaGUoY2FjaGUpIHtcbiAgY2FjaGUucmVmQ291bnQtLTtcbiAgMCA9PT0gY2FjaGUucmVmQ291bnQgJiZcbiAgICBzY2hlZHVsZUNhbGxiYWNrJDIoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbn1cbnZhciBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbCxcbiAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDAsXG4gIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gMCxcbiAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgdGhlbmFibGUpIHtcbiAgaWYgKG51bGwgPT09IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMpIHtcbiAgICB2YXIgZW50YW5nbGVkTGlzdGVuZXJzID0gKGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBbXSk7XG4gICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSB7XG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGVudGFuZ2xlZExpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICB0aGVuYWJsZS50aGVuKHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUsIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUpO1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5mdW5jdGlvbiBwaW5nRW5ndGFuZ2xlZEFjdGlvblNjb3BlKCkge1xuICBpZiAoXG4gICAgMCA9PT0gLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ICYmXG4gICAgbnVsbCAhPT0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVyc1xuICApIHtcbiAgICBudWxsICE9PSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgJiZcbiAgICAgIChjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIik7XG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnM7XG4gICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSAwO1xuICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXSxcbiAgICB0aGVuYWJsZVdpdGhPdmVycmlkZSA9IHtcbiAgICAgIHN0YXR1czogXCJwZW5kaW5nXCIsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHJlYXNvbjogbnVsbCxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGxpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH07XG4gIHRoZW5hYmxlLnRoZW4oXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgdGhlbmFibGVXaXRoT3ZlcnJpZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnZhbHVlID0gcmVzdWx0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspICgwLCBsaXN0ZW5lcnNbaV0pKHJlc3VsdCk7XG4gICAgfSxcbiAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgIHRoZW5hYmxlV2l0aE92ZXJyaWRlLnJlYXNvbiA9IGVycm9yO1xuICAgICAgZm9yIChlcnJvciA9IDA7IGVycm9yIDwgbGlzdGVuZXJzLmxlbmd0aDsgZXJyb3IrKylcbiAgICAgICAgKDAsIGxpc3RlbmVyc1tlcnJvcl0pKHZvaWQgMCk7XG4gICAgfVxuICApO1xuICByZXR1cm4gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG59XG52YXIgcHJldk9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcblJlYWN0U2hhcmVkSW50ZXJuYWxzLlMgPSBmdW5jdGlvbiAodHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpIHtcbiAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHJldHVyblZhbHVlICYmXG4gICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gIG51bGwgIT09IHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG59O1xudmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbmZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG4gIHJldHVybiBudWxsICE9PSBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXJcbiAgICA/IGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlclxuICAgIDogd29ya0luUHJvZ3Jlc3NSb290LnBvb2xlZENhY2hlO1xufVxuZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wpIHtcbiAgbnVsbCA9PT0gcHJldkNhY2hlUG9vbFxuICAgID8gcHVzaChyZXN1bWVkQ2FjaGUsIHJlc3VtZWRDYWNoZS5jdXJyZW50KVxuICAgIDogcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCk7XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRDYWNoZSgpIHtcbiAgdmFyIGNhY2hlRnJvbVBvb2wgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuICByZXR1cm4gbnVsbCA9PT0gY2FjaGVGcm9tUG9vbFxuICAgID8gbnVsbFxuICAgIDogeyBwYXJlbnQ6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlLCBwb29sOiBjYWNoZUZyb21Qb29sIH07XG59XG52YXIgcmVuZGVyTGFuZXMgPSAwLFxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbCxcbiAgY3VycmVudEhvb2sgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsLFxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gITEsXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9ICExLFxuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExLFxuICBsb2NhbElkQ291bnRlciA9IDAsXG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMCxcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGwsXG4gIGdsb2JhbENsaWVudElkQ291bnRlciA9IDA7XG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzIxKSk7XG59XG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChudWxsID09PSBwcmV2RGVwcykgcmV0dXJuICExO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspXG4gICAgaWYgKCFvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgcHJvcHMsXG4gIHNlY29uZEFyZyxcbiAgbmV4dFJlbmRlckxhbmVzXG4pIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSAwO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID1cbiAgICBudWxsID09PSBjdXJyZW50IHx8IG51bGwgPT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgPyBIb29rc0Rpc3BhdGNoZXJPbk1vdW50XG4gICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlO1xuICBzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViA9ICExO1xuICBuZXh0UmVuZGVyTGFuZXMgPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gITE7XG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyAmJlxuICAgIChuZXh0UmVuZGVyTGFuZXMgPSByZW5kZXJXaXRoSG9va3NBZ2FpbihcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcHJvcHMsXG4gICAgICBzZWNvbmRBcmdcbiAgICApKTtcbiAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCk7XG4gIHJldHVybiBuZXh0UmVuZGVyTGFuZXM7XG59XG5mdW5jdGlvbiBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50KSB7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IG51bGwgIT09IGN1cnJlbnRIb29rICYmIG51bGwgIT09IGN1cnJlbnRIb29rLm5leHQ7XG4gIHJlbmRlckxhbmVzID0gMDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICBpZiAoZGlkUmVuZGVyVG9vRmV3SG9va3MpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzAwKSk7XG4gIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICBkaWRSZWNlaXZlVXBkYXRlIHx8XG4gICAgKChjdXJyZW50ID0gY3VycmVudC5kZXBlbmRlbmNpZXMpLFxuICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50KSAmJlxuICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xufVxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIGRvIHtcbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgJiYgKHRoZW5hYmxlU3RhdGUgPSBudWxsKTtcbiAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gICAgaWYgKDI1IDw9IG51bWJlck9mUmVSZW5kZXJzKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwMSkpO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBudWxsO1xuICAgIGlmIChudWxsICE9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGNoaWxkcmVuLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgY2hpbGRyZW4uZXZlbnRzID0gbnVsbDtcbiAgICAgIGNoaWxkcmVuLnN0b3JlcyA9IG51bGw7XG4gICAgICBudWxsICE9IGNoaWxkcmVuLm1lbW9DYWNoZSAmJiAoY2hpbGRyZW4ubWVtb0NhY2hlLmluZGV4ID0gMCk7XG4gICAgfVxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgsXG4gICAgbWF5YmVUaGVuYWJsZSA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKVswXTtcbiAgbWF5YmVUaGVuYWJsZSA9XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbWF5YmVUaGVuYWJsZS50aGVuXG4gICAgICA/IHVzZVRoZW5hYmxlKG1heWJlVGhlbmFibGUpXG4gICAgICA6IG1heWJlVGhlbmFibGU7XG4gIGRpc3BhdGNoZXIgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKClbMF07XG4gIChudWxsICE9PSBjdXJyZW50SG9vayA/IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsKSAhPT0gZGlzcGF0Y2hlciAmJlxuICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IDEwMjQpO1xuICByZXR1cm4gbWF5YmVUaGVuYWJsZTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICB2YXIgZGlkUmVuZGVySWRIb29rID0gMCAhPT0gbG9jYWxJZENvdW50ZXI7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjA1MztcbiAgY3VycmVudC5sYW5lcyAmPSB+bGFuZXM7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzT25VbndpbmQod29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpIHtcbiAgICBmb3IgKFxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICApIHtcbiAgICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnF1ZXVlO1xuICAgICAgbnVsbCAhPT0gcXVldWUgJiYgKHF1ZXVlLnBlbmRpbmcgPSBudWxsKTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MubmV4dDtcbiAgICB9XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9ICExO1xuICB9XG4gIHJlbmRlckxhbmVzID0gMDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gY3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gITE7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gbG9jYWxJZENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbn1cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBob29rKVxuICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vayk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmIChudWxsID09PSBjdXJyZW50SG9vaykge1xuICAgIHZhciBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICBuZXh0Q3VycmVudEhvb2sgPVxuICAgICAgbnVsbCAhPT0gbmV4dEN1cnJlbnRIb29rID8gbmV4dEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICB9IGVsc2UgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudEhvb2submV4dDtcbiAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzSG9va1xuICAgICAgPyBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGVcbiAgICAgIDogd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIGlmIChudWxsICE9PSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKVxuICAgICh3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rKSxcbiAgICAgIChjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vayk7XG4gIGVsc2Uge1xuICAgIGlmIChudWxsID09PSBuZXh0Q3VycmVudEhvb2spIHtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NjcpKTtcbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzEwKSk7XG4gICAgfVxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIG5leHRDdXJyZW50SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3NIb29rXG4gICAgICA/IChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sgPVxuICAgICAgICAgIG5leHRDdXJyZW50SG9vaylcbiAgICAgIDogKHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gbmV4dEN1cnJlbnRIb29rKTtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxudmFyIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWU7XG5jcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4geyBsYXN0RWZmZWN0OiBudWxsLCBldmVudHM6IG51bGwsIHN0b3JlczogbnVsbCwgbWVtb0NhY2hlOiBudWxsIH07XG59O1xuZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG4gIG51bGwgPT09IHRoZW5hYmxlU3RhdGUgJiYgKHRoZW5hYmxlU3RhdGUgPSBbXSk7XG4gIHRoZW5hYmxlID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcbiAgaW5kZXggPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICBudWxsID09PVxuICAgIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc0hvb2tcbiAgICAgID8gaW5kZXgubWVtb2l6ZWRTdGF0ZVxuICAgICAgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCkgJiZcbiAgICAoKGluZGV4ID0gaW5kZXguYWx0ZXJuYXRlKSxcbiAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9XG4gICAgICBudWxsID09PSBpbmRleCB8fCBudWxsID09PSBpbmRleC5tZW1vaXplZFN0YXRlXG4gICAgICAgID8gSG9va3NEaXNwYXRjaGVyT25Nb3VudFxuICAgICAgICA6IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlKSk7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cbmZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgaWYgKG51bGwgIT09IHVzYWJsZSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXNhYmxlKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVzYWJsZS50aGVuKSByZXR1cm4gdXNlVGhlbmFibGUodXNhYmxlKTtcbiAgICBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHJldHVybiByZWFkQ29udGV4dCh1c2FibGUpO1xuICB9XG4gIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDM4LCBTdHJpbmcodXNhYmxlKSkpO1xufVxuZnVuY3Rpb24gdXNlTWVtb0NhY2hlKHNpemUpIHtcbiAgdmFyIG1lbW9DYWNoZSA9IG51bGwsXG4gICAgdXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICBudWxsICE9PSB1cGRhdGVRdWV1ZSAmJiAobWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlKTtcbiAgaWYgKG51bGwgPT0gbWVtb0NhY2hlKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAoKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgKChjdXJyZW50ID0gY3VycmVudC5tZW1vQ2FjaGUpLFxuICAgICAgICBudWxsICE9IGN1cnJlbnQgJiZcbiAgICAgICAgICAobWVtb0NhY2hlID0ge1xuICAgICAgICAgICAgZGF0YTogY3VycmVudC5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgfSkpKTtcbiAgfVxuICBudWxsID09IG1lbW9DYWNoZSAmJiAobWVtb0NhY2hlID0geyBkYXRhOiBbXSwgaW5kZXg6IDAgfSk7XG4gIG51bGwgPT09IHVwZGF0ZVF1ZXVlICYmXG4gICAgKCh1cGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZSkpO1xuICB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUgPSBtZW1vQ2FjaGU7XG4gIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XTtcbiAgaWYgKHZvaWQgMCA9PT0gdXBkYXRlUXVldWUpXG4gICAgZm9yIChcbiAgICAgIHVwZGF0ZVF1ZXVlID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XSA9IEFycmF5KHNpemUpLCBjdXJyZW50ID0gMDtcbiAgICAgIGN1cnJlbnQgPCBzaXplO1xuICAgICAgY3VycmVudCsrXG4gICAgKVxuICAgICAgdXBkYXRlUXVldWVbY3VycmVudF0gPSBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMO1xuICBtZW1vQ2FjaGUuaW5kZXgrKztcbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlO1xufVxuZnVuY3Rpb24gYmFzaWNTdGF0ZVJlZHVjZXIoc3RhdGUsIGFjdGlvbikge1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYWN0aW9uID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xufVxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudCwgcmVkdWNlcikge1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICBpZiAobnVsbCA9PT0gcXVldWUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzExKSk7XG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuICB2YXIgYmFzZVF1ZXVlID0gaG9vay5iYXNlUXVldWUsXG4gICAgcGVuZGluZ1F1ZXVlID0gcXVldWUucGVuZGluZztcbiAgaWYgKG51bGwgIT09IHBlbmRpbmdRdWV1ZSkge1xuICAgIGlmIChudWxsICE9PSBiYXNlUXVldWUpIHtcbiAgICAgIHZhciBiYXNlRmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICAgIGJhc2VRdWV1ZS5uZXh0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICB9XG4gICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gIH1cbiAgcGVuZGluZ1F1ZXVlID0gaG9vay5iYXNlU3RhdGU7XG4gIGlmIChudWxsID09PSBiYXNlUXVldWUpIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgZWxzZSB7XG4gICAgY3VycmVudCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IChiYXNlRmlyc3QgPSBudWxsKSxcbiAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsLFxuICAgICAgdXBkYXRlID0gY3VycmVudCxcbiAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24kNTQgPSAhMTtcbiAgICBkbyB7XG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHVwZGF0ZS5sYW5lICYgLTUzNjg3MDkxMztcbiAgICAgIGlmIChcbiAgICAgICAgdXBkYXRlTGFuZSAhPT0gdXBkYXRlLmxhbmVcbiAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIHVwZGF0ZUxhbmUpID09PSB1cGRhdGVMYW5lXG4gICAgICAgICAgOiAocmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgKSB7XG4gICAgICAgIHZhciByZXZlcnRMYW5lID0gdXBkYXRlLnJldmVydExhbmU7XG4gICAgICAgIGlmICgwID09PSByZXZlcnRMYW5lKVxuICAgICAgICAgIG51bGwgIT09IG5ld0Jhc2VRdWV1ZUxhc3QgJiZcbiAgICAgICAgICAgIChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID1cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhbmU6IDAsXG4gICAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogMCxcbiAgICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVwZGF0ZUxhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAgIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uJDU0ID0gITApO1xuICAgICAgICBlbHNlIGlmICgocmVuZGVyTGFuZXMgJiByZXZlcnRMYW5lKSA9PT0gcmV2ZXJ0TGFuZSkge1xuICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgICAgIHJldmVydExhbmUgPT09IGN1cnJlbnRFbnRhbmdsZWRMYW5lICYmXG4gICAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiQ1NCA9ICEwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgKHVwZGF0ZUxhbmUgPSB7XG4gICAgICAgICAgICBsYW5lOiAwLFxuICAgICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbnVsbCA9PT0gbmV3QmFzZVF1ZXVlTGFzdFxuICAgICAgICAgICAgICA/ICgobmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSB1cGRhdGVMYW5lKSxcbiAgICAgICAgICAgIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IHJldmVydExhbmUpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSByZXZlcnRMYW5lKTtcbiAgICAgICAgdXBkYXRlTGFuZSA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWICYmXG4gICAgICAgICAgcmVkdWNlcihwZW5kaW5nUXVldWUsIHVwZGF0ZUxhbmUpO1xuICAgICAgICBwZW5kaW5nUXVldWUgPSB1cGRhdGUuaGFzRWFnZXJTdGF0ZVxuICAgICAgICAgID8gdXBkYXRlLmVhZ2VyU3RhdGVcbiAgICAgICAgICA6IHJlZHVjZXIocGVuZGluZ1F1ZXVlLCB1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAocmV2ZXJ0TGFuZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgICAgICAgID8gKChuZXdCYXNlUXVldWVGaXJzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QgPSByZXZlcnRMYW5lKSxcbiAgICAgICAgICAgICAgKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSkpXG4gICAgICAgICAgICA6IChuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gcmV2ZXJ0TGFuZSksXG4gICAgICAgICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgfD0gdXBkYXRlTGFuZSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSB1cGRhdGVMYW5lKTtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKG51bGwgIT09IHVwZGF0ZSAmJiB1cGRhdGUgIT09IGN1cnJlbnQpO1xuICAgIG51bGwgPT09IG5ld0Jhc2VRdWV1ZUxhc3RcbiAgICAgID8gKGJhc2VGaXJzdCA9IHBlbmRpbmdRdWV1ZSlcbiAgICAgIDogKG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IG5ld0Jhc2VRdWV1ZUZpcnN0KTtcbiAgICBpZiAoXG4gICAgICAhb2JqZWN0SXMocGVuZGluZ1F1ZXVlLCBob29rLm1lbW9pemVkU3RhdGUpICYmXG4gICAgICAoKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCksXG4gICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uJDU0ICYmXG4gICAgICAgICgocmVkdWNlciA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSksIG51bGwgIT09IHJlZHVjZXIpKVxuICAgIClcbiAgICAgIHRocm93IHJlZHVjZXI7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gcGVuZGluZ1F1ZXVlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gYmFzZUZpcnN0O1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgfVxuICBudWxsID09PSBiYXNlUXVldWUgJiYgKHF1ZXVlLmxhbmVzID0gMCk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBxdWV1ZS5kaXNwYXRjaF07XG59XG5mdW5jdGlvbiByZXJlbmRlclJlZHVjZXIocmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIHF1ZXVlID0gaG9vay5xdWV1ZTtcbiAgaWYgKG51bGwgPT09IHF1ZXVlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMxMSkpO1xuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2gsXG4gICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZyxcbiAgICBuZXdTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSAobGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQpO1xuICAgIGRvIChuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIHVwZGF0ZS5hY3Rpb24pKSwgKHVwZGF0ZSA9IHVwZGF0ZS5uZXh0KTtcbiAgICB3aGlsZSAodXBkYXRlICE9PSBsYXN0UmVuZGVyUGhhc2VVcGRhdGUpO1xuICAgIG9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpIHx8IChkaWRSZWNlaXZlVXBkYXRlID0gITApO1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIG51bGwgPT09IGhvb2suYmFzZVF1ZXVlICYmIChob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlKTtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG4gIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIGlzSHlkcmF0aW5nJGpzY29tcCQwID0gaXNIeWRyYXRpbmc7XG4gIGlmIChpc0h5ZHJhdGluZyRqc2NvbXAkMCkge1xuICAgIGlmICh2b2lkIDAgPT09IGdldFNlcnZlclNuYXBzaG90KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQwNykpO1xuICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcbiAgfSBlbHNlIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgdmFyIHNuYXBzaG90Q2hhbmdlZCA9ICFvYmplY3RJcyhcbiAgICAoY3VycmVudEhvb2sgfHwgaG9vaykubWVtb2l6ZWRTdGF0ZSxcbiAgICBnZXRTZXJ2ZXJTbmFwc2hvdFxuICApO1xuICBzbmFwc2hvdENoYW5nZWQgJiZcbiAgICAoKGhvb2subWVtb2l6ZWRTdGF0ZSA9IGdldFNlcnZlclNuYXBzaG90KSwgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCkpO1xuICBob29rID0gaG9vay5xdWV1ZTtcbiAgdXBkYXRlRWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaG9vaywgc3Vic2NyaWJlKSwgW1xuICAgIHN1YnNjcmliZVxuICBdKTtcbiAgaWYgKFxuICAgIGhvb2suZ2V0U25hcHNob3QgIT09IGdldFNuYXBzaG90IHx8XG4gICAgc25hcHNob3RDaGFuZ2VkIHx8XG4gICAgKG51bGwgIT09IHdvcmtJblByb2dyZXNzSG9vayAmJiB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiAxKVxuICApIHtcbiAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgIHB1c2hFZmZlY3QoXG4gICAgICA5LFxuICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBmaWJlcixcbiAgICAgICAgaG9vayxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgIGdldFNuYXBzaG90XG4gICAgICApLFxuICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQ5KSk7XG4gICAgaXNIeWRyYXRpbmckanNjb21wJDAgfHxcbiAgICAgIDAgIT09IChyZW5kZXJMYW5lcyAmIDYwKSB8fFxuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgfVxuICByZXR1cm4gZ2V0U2VydmVyU25hcHNob3Q7XG59XG5mdW5jdGlvbiBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgcmVuZGVyZWRTbmFwc2hvdCkge1xuICBmaWJlci5mbGFncyB8PSAxNjM4NDtcbiAgZmliZXIgPSB7IGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCwgdmFsdWU6IHJlbmRlcmVkU25hcHNob3QgfTtcbiAgZ2V0U25hcHNob3QgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICBudWxsID09PSBnZXRTbmFwc2hvdFxuICAgID8gKChnZXRTbmFwc2hvdCA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgICAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGdldFNuYXBzaG90KSxcbiAgICAgIChnZXRTbmFwc2hvdC5zdG9yZXMgPSBbZmliZXJdKSlcbiAgICA6ICgocmVuZGVyZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90LnN0b3JlcyksXG4gICAgICBudWxsID09PSByZW5kZXJlZFNuYXBzaG90XG4gICAgICAgID8gKGdldFNuYXBzaG90LnN0b3JlcyA9IFtmaWJlcl0pXG4gICAgICAgIDogcmVuZGVyZWRTbmFwc2hvdC5wdXNoKGZpYmVyKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDtcbiAgY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSAmJiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xufVxuZnVuY3Rpb24gc3Vic2NyaWJlVG9TdG9yZShmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSB7XG4gIHJldHVybiBzdWJzY3JpYmUoZnVuY3Rpb24gKCkge1xuICAgIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkgJiYgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgaW5zdCA9IGluc3QudmFsdWU7XG4gIHRyeSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFvYmplY3RJcyhpbnN0LCBuZXh0VmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxuZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpO1xufVxuZnVuY3Rpb24gbW91bnRTdGF0ZUltcGwoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluaXRpYWxTdGF0ZSkge1xuICAgIHZhciBpbml0aWFsU3RhdGVJbml0aWFsaXplciA9IGluaXRpYWxTdGF0ZTtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoITApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIGhvb2sucXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogMCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIHJldHVybiBob29rO1xufVxuZnVuY3Rpb24gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudCwgcGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKFxuICAgIGhvb2ssXG4gICAgY3VycmVudEhvb2ssXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVkdWNlciA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlclxuICApO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShcbiAgZmliZXIsXG4gIGFjdGlvblF1ZXVlLFxuICBzZXRQZW5kaW5nU3RhdGUsXG4gIHNldFN0YXRlLFxuICBwYXlsb2FkXG4pIHtcbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ4NSkpO1xuICBmaWJlciA9IGFjdGlvblF1ZXVlLmFjdGlvbjtcbiAgaWYgKG51bGwgIT09IGZpYmVyKSB7XG4gICAgdmFyIGFjdGlvbk5vZGUgPSB7XG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgYWN0aW9uOiBmaWJlcixcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBpc1RyYW5zaXRpb246ICEwLFxuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgcmVhc29uOiBudWxsLFxuICAgICAgbGlzdGVuZXJzOiBbXSxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICBhY3Rpb25Ob2RlLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG51bGwgIT09IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlRcbiAgICAgID8gc2V0UGVuZGluZ1N0YXRlKCEwKVxuICAgICAgOiAoYWN0aW9uTm9kZS5pc1RyYW5zaXRpb24gPSAhMSk7XG4gICAgc2V0U3RhdGUoYWN0aW9uTm9kZSk7XG4gICAgc2V0UGVuZGluZ1N0YXRlID0gYWN0aW9uUXVldWUucGVuZGluZztcbiAgICBudWxsID09PSBzZXRQZW5kaW5nU3RhdGVcbiAgICAgID8gKChhY3Rpb25Ob2RlLm5leHQgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gYWN0aW9uTm9kZSksXG4gICAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBhY3Rpb25Ob2RlKSlcbiAgICAgIDogKChhY3Rpb25Ob2RlLm5leHQgPSBzZXRQZW5kaW5nU3RhdGUubmV4dCksXG4gICAgICAgIChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gc2V0UGVuZGluZ1N0YXRlLm5leHQgPSBhY3Rpb25Ob2RlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBub2RlKSB7XG4gIHZhciBhY3Rpb24gPSBub2RlLmFjdGlvbixcbiAgICBwYXlsb2FkID0gbm9kZS5wYXlsb2FkLFxuICAgIHByZXZTdGF0ZSA9IGFjdGlvblF1ZXVlLnN0YXRlO1xuICBpZiAobm9kZS5pc1RyYW5zaXRpb24pIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5ULFxuICAgICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGFjdGlvbihwcmV2U3RhdGUsIHBheWxvYWQpLFxuICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgICAgaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gICAgfVxuICB9IGVsc2VcbiAgICB0cnkge1xuICAgICAgKHByZXZUcmFuc2l0aW9uID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCkpLFxuICAgICAgICBoYW5kbGVBY3Rpb25SZXR1cm5WYWx1ZShhY3Rpb25RdWV1ZSwgbm9kZSwgcHJldlRyYW5zaXRpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yJDYwKSB7XG4gICAgICBvbkFjdGlvbkVycm9yKGFjdGlvblF1ZXVlLCBub2RlLCBlcnJvciQ2MCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQWN0aW9uUmV0dXJuVmFsdWUoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKSB7XG4gIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuXG4gICAgPyByZXR1cm5WYWx1ZS50aGVuKFxuICAgICAgICBmdW5jdGlvbiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgb25BY3Rpb25TdWNjZXNzKGFjdGlvblF1ZXVlLCBub2RlLCBuZXh0U3RhdGUpO1xuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgbm9kZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICApXG4gICAgOiBvbkFjdGlvblN1Y2Nlc3MoYWN0aW9uUXVldWUsIG5vZGUsIHJldHVyblZhbHVlKTtcbn1cbmZ1bmN0aW9uIG9uQWN0aW9uU3VjY2VzcyhhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgbmV4dFN0YXRlKSB7XG4gIGFjdGlvbk5vZGUuc3RhdHVzID0gXCJmdWxmaWxsZWRcIjtcbiAgYWN0aW9uTm9kZS52YWx1ZSA9IG5leHRTdGF0ZTtcbiAgbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpO1xuICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgYWN0aW9uTm9kZSA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG4gIG51bGwgIT09IGFjdGlvbk5vZGUgJiZcbiAgICAoKG5leHRTdGF0ZSA9IGFjdGlvbk5vZGUubmV4dCksXG4gICAgbmV4dFN0YXRlID09PSBhY3Rpb25Ob2RlXG4gICAgICA/IChhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbClcbiAgICAgIDogKChuZXh0U3RhdGUgPSBuZXh0U3RhdGUubmV4dCksXG4gICAgICAgIChhY3Rpb25Ob2RlLm5leHQgPSBuZXh0U3RhdGUpLFxuICAgICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgbmV4dFN0YXRlKSkpO1xufVxuZnVuY3Rpb24gb25BY3Rpb25FcnJvcihhY3Rpb25RdWV1ZSwgYWN0aW9uTm9kZSwgZXJyb3IpIHtcbiAgdmFyIGxhc3QgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuICBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgaWYgKG51bGwgIT09IGxhc3QpIHtcbiAgICBsYXN0ID0gbGFzdC5uZXh0O1xuICAgIGRvXG4gICAgICAoYWN0aW9uTm9kZS5zdGF0dXMgPSBcInJlamVjdGVkXCIpLFxuICAgICAgICAoYWN0aW9uTm9kZS5yZWFzb24gPSBlcnJvciksXG4gICAgICAgIG5vdGlmeUFjdGlvbkxpc3RlbmVycyhhY3Rpb25Ob2RlKSxcbiAgICAgICAgKGFjdGlvbk5vZGUgPSBhY3Rpb25Ob2RlLm5leHQpO1xuICAgIHdoaWxlIChhY3Rpb25Ob2RlICE9PSBsYXN0KTtcbiAgfVxuICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBudWxsO1xufVxuZnVuY3Rpb24gbm90aWZ5QWN0aW9uTGlzdGVuZXJzKGFjdGlvbk5vZGUpIHtcbiAgYWN0aW9uTm9kZSA9IGFjdGlvbk5vZGUubGlzdGVuZXJzO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGlvbk5vZGUubGVuZ3RoOyBpKyspICgwLCBhY3Rpb25Ob2RlW2ldKSgpO1xufVxuZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5mdW5jdGlvbiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlUHJvcCkge1xuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICB2YXIgc3NyRm9ybVN0YXRlID0gd29ya0luUHJvZ3Jlc3NSb290LmZvcm1TdGF0ZTtcbiAgICBpZiAobnVsbCAhPT0gc3NyRm9ybVN0YXRlKSB7XG4gICAgICBhOiB7XG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICAgICAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgICAgICBpZiAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICB2YXIgaW5Sb290T3JTaW5nbGV0b24gPSByb290T3JTaW5nbGV0b25Db250ZXh0O1xuICAgICAgICAgICAgICAgIDggIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMC5ub2RlVHlwZTtcblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoIWluUm9vdE9yU2luZ2xldG9uKSB7XG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDApIHtcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpblJvb3RPclNpbmdsZXRvbiA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMC5kYXRhO1xuICAgICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIFwiRiFcIiA9PT0gaW5Sb290T3JTaW5nbGV0b24gfHwgXCJGXCIgPT09IGluUm9vdE9yU2luZ2xldG9uXG4gICAgICAgICAgICAgICAgICA/IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMFxuICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCkge1xuICAgICAgICAgICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwLm5leHRTaWJsaW5nXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgXCJGIVwiID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQkanNjb21wJDAuZGF0YTtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9XG4gICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiYgKGluaXRpYWxTdGF0ZVByb3AgPSBzc3JGb3JtU3RhdGVbMF0pO1xuICAgIH1cbiAgfVxuICBzc3JGb3JtU3RhdGUgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBzc3JGb3JtU3RhdGUubWVtb2l6ZWRTdGF0ZSA9IHNzckZvcm1TdGF0ZS5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGVQcm9wO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogMCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBhY3Rpb25TdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVByb3BcbiAgfTtcbiAgc3NyRm9ybVN0YXRlLnF1ZXVlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQoXG4gICAgbnVsbCxcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICApO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZGlzcGF0Y2ggPSBzc3JGb3JtU3RhdGU7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IG1vdW50U3RhdGVJbXBsKCExKTtcbiAgaW5Sb290T3JTaW5nbGV0b24gPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgIG51bGwsXG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAhMSxcbiAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQucXVldWVcbiAgKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID0ge1xuICAgIHN0YXRlOiBpbml0aWFsU3RhdGVQcm9wLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIHBlbmRpbmc6IG51bGxcbiAgfTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnF1ZXVlID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwO1xuICBzc3JGb3JtU3RhdGUgPSBkaXNwYXRjaEFjdGlvblN0YXRlLmJpbmQoXG4gICAgbnVsbCxcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLFxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCRqc2NvbXAkMCxcbiAgICBpblJvb3RPclNpbmdsZXRvbixcbiAgICBzc3JGb3JtU3RhdGVcbiAgKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwLmRpc3BhdGNoID0gc3NyRm9ybVN0YXRlO1xuICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQubWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgcmV0dXJuIFtpbml0aWFsU3RhdGVQcm9wLCBzc3JGb3JtU3RhdGUsICExXTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbikge1xuICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50SG9vaywgYWN0aW9uKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbikge1xuICBjdXJyZW50U3RhdGVIb29rID0gdXBkYXRlUmVkdWNlckltcGwoXG4gICAgc3RhdGVIb29rLFxuICAgIGN1cnJlbnRTdGF0ZUhvb2ssXG4gICAgYWN0aW9uU3RhdGVSZWR1Y2VyXG4gIClbMF07XG4gIHN0YXRlSG9vayA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdO1xuICBjdXJyZW50U3RhdGVIb29rID1cbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgY3VycmVudFN0YXRlSG9vayAmJlxuICAgIG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2sgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjdXJyZW50U3RhdGVIb29rLnRoZW5cbiAgICAgID8gdXNlVGhlbmFibGUoY3VycmVudFN0YXRlSG9vaylcbiAgICAgIDogY3VycmVudFN0YXRlSG9vaztcbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlLFxuICAgIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7XG4gIGFjdGlvbiAhPT0gYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGUgJiZcbiAgICAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gMjA0OCksXG4gICAgcHVzaEVmZmVjdChcbiAgICAgIDksXG4gICAgICBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLFxuICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgIG51bGxcbiAgICApKTtcbiAgcmV0dXJuIFtjdXJyZW50U3RhdGVIb29rLCBkaXNwYXRjaCwgc3RhdGVIb29rXTtcbn1cbmZ1bmN0aW9uIGFjdGlvblN0YXRlQWN0aW9uRWZmZWN0KGFjdGlvblF1ZXVlLCBhY3Rpb24pIHtcbiAgYWN0aW9uUXVldWUuYWN0aW9uID0gYWN0aW9uO1xufVxuZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pIHtcbiAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpLFxuICAgIGN1cnJlbnRTdGF0ZUhvb2sgPSBjdXJyZW50SG9vaztcbiAgaWYgKG51bGwgIT09IGN1cnJlbnRTdGF0ZUhvb2spXG4gICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICBzdGF0ZUhvb2sgPSBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgY3VycmVudFN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgZGlzcGF0Y2ggPSBjdXJyZW50U3RhdGVIb29rLnF1ZXVlLmRpc3BhdGNoO1xuICBjdXJyZW50U3RhdGVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gIHJldHVybiBbc3RhdGVIb29rLCBkaXNwYXRjaCwgITFdO1xufVxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICB0YWcgPSB7IHRhZzogdGFnLCBjcmVhdGU6IGNyZWF0ZSwgaW5zdDogaW5zdCwgZGVwczogZGVwcywgbmV4dDogbnVsbCB9O1xuICBjcmVhdGUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuICBudWxsID09PSBjcmVhdGUgJiZcbiAgICAoKGNyZWF0ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSksXG4gICAgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjcmVhdGUpKTtcbiAgaW5zdCA9IGNyZWF0ZS5sYXN0RWZmZWN0O1xuICBudWxsID09PSBpbnN0XG4gICAgPyAoY3JlYXRlLmxhc3RFZmZlY3QgPSB0YWcubmV4dCA9IHRhZylcbiAgICA6ICgoZGVwcyA9IGluc3QubmV4dCksXG4gICAgICAoaW5zdC5uZXh0ID0gdGFnKSxcbiAgICAgICh0YWcubmV4dCA9IGRlcHMpLFxuICAgICAgKGNyZWF0ZS5sYXN0RWZmZWN0ID0gdGFnKSk7XG4gIHJldHVybiB0YWc7XG59XG5mdW5jdGlvbiB1cGRhdGVSZWYoKSB7XG4gIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xufVxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KFxuICAgIDEgfCBob29rRmxhZ3MsXG4gICAgY3JlYXRlLFxuICAgIHsgZGVzdHJveTogdm9pZCAwIH0sXG4gICAgdm9pZCAwID09PSBkZXBzID8gbnVsbCA6IGRlcHNcbiAgKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJGbGFncywgaG9va0ZsYWdzLCBjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICB2YXIgaW5zdCA9IGhvb2subWVtb2l6ZWRTdGF0ZS5pbnN0O1xuICBudWxsICE9PSBjdXJyZW50SG9vayAmJlxuICBudWxsICE9PSBkZXBzICYmXG4gIGFyZUhvb2tJbnB1dHNFcXVhbChkZXBzLCBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLmRlcHMpXG4gICAgPyAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgaW5zdCwgZGVwcykpXG4gICAgOiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncyksXG4gICAgICAoaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdCgxIHwgaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIGRlcHMpKSk7XG59XG5mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgbW91bnRFZmZlY3RJbXBsKDgzOTA2NTYsIDgsIGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHVwZGF0ZUVmZmVjdEltcGwoMjA0OCwgOCwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgMiwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoNCwgNCwgY3JlYXRlLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZikge1xuICAgIGNyZWF0ZSA9IGNyZWF0ZSgpO1xuICAgIHZhciByZWZDbGVhbnVwID0gcmVmKGNyZWF0ZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXAgPyByZWZDbGVhbnVwKCkgOiByZWYobnVsbCk7XG4gICAgfTtcbiAgfVxuICBpZiAobnVsbCAhPT0gcmVmICYmIHZvaWQgMCAhPT0gcmVmKVxuICAgIHJldHVybiAoXG4gICAgICAoY3JlYXRlID0gY3JlYXRlKCkpLFxuICAgICAgKHJlZi5jdXJyZW50ID0gY3JlYXRlKSxcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICk7XG59XG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIGRlcHMgPSBudWxsICE9PSBkZXBzICYmIHZvaWQgMCAhPT0gZGVwcyA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHVwZGF0ZUVmZmVjdEltcGwoNCwgNCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZGVwcyk7XG59XG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUoKSB7fVxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIGRlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICBpZiAobnVsbCAhPT0gZGVwcyAmJiBhcmVIb29rSW5wdXRzRXF1YWwoZGVwcywgcHJldlN0YXRlWzFdKSlcbiAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICBwcmV2U3RhdGUgPSBuZXh0Q3JlYXRlKCk7XG4gIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICB0cnkge1xuICAgICAgbmV4dENyZWF0ZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgfVxuICB9XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtwcmV2U3RhdGUsIGRlcHNdO1xuICByZXR1cm4gcHJldlN0YXRlO1xufVxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmICh2b2lkIDAgPT09IGluaXRpYWxWYWx1ZSB8fCAwICE9PSAocmVuZGVyTGFuZXMgJiAxMDczNzQxODI0KSlcbiAgICByZXR1cm4gKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlO1xuICBob29rID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzIHw9IGhvb2s7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyB8PSBob29rO1xuICByZXR1cm4gaW5pdGlhbFZhbHVlO1xufVxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIGlmIChvYmplY3RJcyh2YWx1ZSwgcHJldlZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICBpZiAobnVsbCAhPT0gY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50KVxuICAgIHJldHVybiAoXG4gICAgICAoaG9vayA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkpLFxuICAgICAgb2JqZWN0SXMoaG9vaywgcHJldlZhbHVlKSB8fCAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSxcbiAgICAgIGhvb2tcbiAgICApO1xuICBpZiAoMCA9PT0gKHJlbmRlckxhbmVzICYgNDIpKVxuICAgIHJldHVybiAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwKSwgKGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlKTtcbiAgaG9vayA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyB8PSBob29rO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gaG9vaztcbiAgcmV0dXJuIHByZXZWYWx1ZTtcbn1cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihmaWJlciwgcXVldWUsIHBlbmRpbmdTdGF0ZSwgZmluaXNoZWRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICBSZWFjdERPTVNoYXJlZEludGVybmFscy5wID1cbiAgICAwICE9PSBwcmV2aW91c1ByaW9yaXR5ICYmIDggPiBwcmV2aW91c1ByaW9yaXR5ID8gcHJldmlvdXNQcmlvcml0eSA6IDg7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgITEsIHF1ZXVlLCBwZW5kaW5nU3RhdGUpO1xuICB0cnkge1xuICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCksXG4gICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG4gICAgbnVsbCAhPT0gb25TdGFydFRyYW5zaXRpb25GaW5pc2ggJiZcbiAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgaWYgKFxuICAgICAgbnVsbCAhPT0gcmV0dXJuVmFsdWUgJiZcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZSAmJlxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUudGhlblxuICAgICkge1xuICAgICAgdmFyIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSA9IGNoYWluVGhlbmFibGVWYWx1ZShcbiAgICAgICAgcmV0dXJuVmFsdWUsXG4gICAgICAgIGZpbmlzaGVkU3RhdGVcbiAgICAgICk7XG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlLFxuICAgICAgICByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcilcbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoXG4gICAgICAgIGZpYmVyLFxuICAgICAgICBxdWV1ZSxcbiAgICAgICAgZmluaXNoZWRTdGF0ZSxcbiAgICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpXG4gICAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChcbiAgICAgIGZpYmVyLFxuICAgICAgcXVldWUsXG4gICAgICB7IHRoZW46IGZ1bmN0aW9uICgpIHt9LCBzdGF0dXM6IFwicmVqZWN0ZWRcIiwgcmVhc29uOiBlcnJvciB9LFxuICAgICAgcmVxdWVzdFVwZGF0ZUxhbmUoKVxuICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBub29wJDIoKSB7fVxuZnVuY3Rpb24gc3RhcnRIb3N0VHJhbnNpdGlvbihmb3JtRmliZXIsIHBlbmRpbmdTdGF0ZSwgYWN0aW9uLCBmb3JtRGF0YSkge1xuICBpZiAoNSAhPT0gZm9ybUZpYmVyLnRhZykgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzYpKTtcbiAgdmFyIHF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5xdWV1ZTtcbiAgc3RhcnRUcmFuc2l0aW9uKFxuICAgIGZvcm1GaWJlcixcbiAgICBxdWV1ZSxcbiAgICBwZW5kaW5nU3RhdGUsXG4gICAgc2hhcmVkTm90UGVuZGluZ09iamVjdCxcbiAgICBudWxsID09PSBhY3Rpb25cbiAgICAgID8gbm9vcCQyXG4gICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXF1ZXN0Rm9ybVJlc2V0JDEoZm9ybUZpYmVyKTtcbiAgICAgICAgICByZXR1cm4gYWN0aW9uKGZvcm1EYXRhKTtcbiAgICAgICAgfVxuICApO1xufVxuZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gIHZhciBleGlzdGluZ1N0YXRlSG9vayA9IGZvcm1GaWJlci5tZW1vaXplZFN0YXRlO1xuICBpZiAobnVsbCAhPT0gZXhpc3RpbmdTdGF0ZUhvb2spIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgZXhpc3RpbmdTdGF0ZUhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogc2hhcmVkTm90UGVuZGluZ09iamVjdCxcbiAgICBiYXNlU3RhdGU6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgbGFuZXM6IDAsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgICAgbGFzdFJlbmRlcmVkU3RhdGU6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3RcbiAgICB9LFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGluaXRpYWxSZXNldFN0YXRlID0ge307XG4gIGV4aXN0aW5nU3RhdGVIb29rLm5leHQgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgYmFzZVN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IHtcbiAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICBsYW5lczogMCxcbiAgICAgIGRpc3BhdGNoOiBudWxsLFxuICAgICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgICB9LFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgZm9ybUZpYmVyLm1lbW9pemVkU3RhdGUgPSBleGlzdGluZ1N0YXRlSG9vaztcbiAgZm9ybUZpYmVyID0gZm9ybUZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gZm9ybUZpYmVyICYmIChmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGV4aXN0aW5nU3RhdGVIb29rKTtcbiAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xufVxuZnVuY3Rpb24gcmVxdWVzdEZvcm1SZXNldCQxKGZvcm1GaWJlcikge1xuICB2YXIgcmVzZXRTdGF0ZVF1ZXVlID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKS5uZXh0LnF1ZXVlO1xuICBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZm9ybUZpYmVyLCByZXNldFN0YXRlUXVldWUsIHt9LCByZXF1ZXN0VXBkYXRlTGFuZSgpKTtcbn1cbmZ1bmN0aW9uIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzKCkge1xuICByZXR1cm4gcmVhZENvbnRleHQoSG9zdFRyYW5zaXRpb25Db250ZXh0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUlkKCkge1xuICByZXR1cm4gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlZnJlc2goKSB7XG4gIHJldHVybiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xufVxuZnVuY3Rpb24gcmVmcmVzaENhY2hlKGZpYmVyKSB7XG4gIGZvciAodmFyIHByb3ZpZGVyID0gZmliZXIucmV0dXJuOyBudWxsICE9PSBwcm92aWRlcjsgKSB7XG4gICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgIGNhc2UgMjQ6XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKTtcbiAgICAgICAgZmliZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgIHZhciByb290JDYzID0gZW5xdWV1ZVVwZGF0ZShwcm92aWRlciwgZmliZXIsIGxhbmUpO1xuICAgICAgICBudWxsICE9PSByb290JDYzICYmXG4gICAgICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290JDYzLCBwcm92aWRlciwgbGFuZSksXG4gICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290JDYzLCBwcm92aWRlciwgbGFuZSkpO1xuICAgICAgICBwcm92aWRlciA9IHsgY2FjaGU6IGNyZWF0ZUNhY2hlKCkgfTtcbiAgICAgICAgZmliZXIucGF5bG9hZCA9IHByb3ZpZGVyO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpO1xuICBhY3Rpb24gPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICByZXZlcnRMYW5lOiAwLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKVxuICAgID8gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCBhY3Rpb24pXG4gICAgOiAoKGFjdGlvbiA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSkpLFxuICAgICAgbnVsbCAhPT0gYWN0aW9uICYmXG4gICAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIoYWN0aW9uLCBmaWJlciwgbGFuZSksXG4gICAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShhY3Rpb24sIHF1ZXVlLCBsYW5lKSkpO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCk7XG4gIGRpc3BhdGNoU2V0U3RhdGVJbnRlcm5hbChmaWJlciwgcXVldWUsIGFjdGlvbiwgbGFuZSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlSW50ZXJuYWwoZmliZXIsIHF1ZXVlLCBhY3Rpb24sIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIHJldmVydExhbmU6IDAsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogITEsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICBlbHNlIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChcbiAgICAgIDAgPT09IGZpYmVyLmxhbmVzICYmXG4gICAgICAobnVsbCA9PT0gYWx0ZXJuYXRlIHx8IDAgPT09IGFsdGVybmF0ZS5sYW5lcykgJiZcbiAgICAgICgoYWx0ZXJuYXRlID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlciksIG51bGwgIT09IGFsdGVybmF0ZSlcbiAgICApXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gcXVldWUubGFzdFJlbmRlcmVkU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZSA9IGFsdGVybmF0ZShjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gITA7XG4gICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcbiAgICAgICAgaWYgKG9iamVjdElzKGVhZ2VyU3RhdGUsIGN1cnJlbnRTdGF0ZSkpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgMCksXG4gICAgICAgICAgICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpLFxuICAgICAgICAgICAgITFcbiAgICAgICAgICApO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICB9XG4gICAgYWN0aW9uID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcbiAgICBpZiAobnVsbCAhPT0gYWN0aW9uKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKGFjdGlvbiwgZmliZXIsIGxhbmUpLFxuICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUoYWN0aW9uLCBxdWV1ZSwgbGFuZSksXG4gICAgICAgICEwXG4gICAgICApO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCB0aHJvd0lmRHVyaW5nUmVuZGVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIGFjdGlvbiA9IHtcbiAgICBsYW5lOiAyLFxuICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6ICExLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBpZiAodGhyb3dJZkR1cmluZ1JlbmRlcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzkpKTtcbiAgfSBlbHNlXG4gICAgKHRocm93SWZEdXJpbmdSZW5kZXIgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoXG4gICAgICBmaWJlcixcbiAgICAgIHF1ZXVlLFxuICAgICAgYWN0aW9uLFxuICAgICAgMlxuICAgICkpLFxuICAgICAgbnVsbCAhPT0gdGhyb3dJZkR1cmluZ1JlbmRlciAmJlxuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIodGhyb3dJZkR1cmluZ1JlbmRlciwgZmliZXIsIDIpO1xufVxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gKFxuICAgIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8XG4gICAgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpXG4gICk7XG59XG5mdW5jdGlvbiBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSkge1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID1cbiAgICAhMDtcbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuICBudWxsID09PSBwZW5kaW5nXG4gICAgPyAodXBkYXRlLm5leHQgPSB1cGRhdGUpXG4gICAgOiAoKHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0KSwgKHBlbmRpbmcubmV4dCA9IHVwZGF0ZSkpO1xuICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gIGlmICgwICE9PSAobGFuZSAmIDQxOTQxNzYpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBxdWV1ZS5sYW5lcztcbiAgICBxdWV1ZUxhbmVzICY9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAgIGxhbmUgfD0gcXVldWVMYW5lcztcbiAgICBxdWV1ZS5sYW5lcyA9IGxhbmU7XG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbGFuZSk7XG4gIH1cbn1cbnZhciBDb250ZXh0T25seURpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlOiB1c2UsXG4gIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VNZW1vOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZHVjZXI6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVmOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN0YXRlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlYnVnVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VUcmFuc2l0aW9uOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUlkOiB0aHJvd0ludmFsaWRIb29rRXJyb3Jcbn07XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbkNvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbkNvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlQWN0aW9uU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG5Db250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50ID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlID0gW1xuICAgICAgY2FsbGJhY2ssXG4gICAgICB2b2lkIDAgPT09IGRlcHMgPyBudWxsIDogZGVwc1xuICAgIF07XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LFxuICB1c2VDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlRWZmZWN0OiBtb3VudEVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgZGVwcyA9IG51bGwgIT09IGRlcHMgJiYgdm9pZCAwICE9PSBkZXBzID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgICBtb3VudEVmZmVjdEltcGwoXG4gICAgICA0MTk0MzA4LFxuICAgICAgNCxcbiAgICAgIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksXG4gICAgICBkZXBzXG4gICAgKTtcbiAgfSxcbiAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbCg0MTk0MzA4LCA0LCBjcmVhdGUsIGRlcHMpO1xuICB9LFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICBtb3VudEVmZmVjdEltcGwoNCwgMiwgY3JlYXRlLCBkZXBzKTtcbiAgfSxcbiAgdXNlTWVtbzogZnVuY3Rpb24gKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gICAgZGVwcyA9IHZvaWQgMCA9PT0gZGVwcyA/IG51bGwgOiBkZXBzO1xuICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG4gICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMCk7XG4gICAgICB0cnkge1xuICAgICAgICBuZXh0Q3JlYXRlKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyghMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIGRlcHNdO1xuICAgIHJldHVybiBuZXh0VmFsdWU7XG4gIH0sXG4gIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgIGlmICh2b2lkIDAgIT09IGluaXQpIHtcbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCEwKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbml0KGluaXRpYWxBcmcpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKCExKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHJlZHVjZXIgPSB7XG4gICAgICBwZW5kaW5nOiBudWxsLFxuICAgICAgbGFuZXM6IDAsXG4gICAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IHJlZHVjZXIsXG4gICAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gICAgfTtcbiAgICBob29rLnF1ZXVlID0gcmVkdWNlcjtcbiAgICByZWR1Y2VyID0gcmVkdWNlci5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKFxuICAgICAgbnVsbCxcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsXG4gICAgICByZWR1Y2VyXG4gICAgKTtcbiAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgcmVkdWNlcl07XG4gIH0sXG4gIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICBpbml0aWFsVmFsdWUgPSB7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9O1xuICAgIHJldHVybiAoaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlKTtcbiAgfSxcbiAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpO1xuICAgIHZhciBxdWV1ZSA9IGluaXRpYWxTdGF0ZS5xdWV1ZSxcbiAgICAgIGRpc3BhdGNoID0gZGlzcGF0Y2hTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICAgIHJldHVybiBbaW5pdGlhbFN0YXRlLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogbW91bnREZWJ1Z1ZhbHVlLFxuICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgfSxcbiAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbCghMSk7XG4gICAgc3RhdGVIb29rID0gc3RhcnRUcmFuc2l0aW9uLmJpbmQoXG4gICAgICBudWxsLFxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgIHN0YXRlSG9vay5xdWV1ZSxcbiAgICAgICEwLFxuICAgICAgITFcbiAgICApO1xuICAgIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgICByZXR1cm4gWyExLCBzdGF0ZUhvb2tdO1xuICB9LFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAgIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgaWYgKHZvaWQgMCA9PT0gZ2V0U2VydmVyU25hcHNob3QpXG4gICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDA3KSk7XG4gICAgICBnZXRTZXJ2ZXJTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdldFNlcnZlclNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcbiAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzQ5KSk7XG4gICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA2MCkgfHxcbiAgICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gZ2V0U2VydmVyU25hcHNob3Q7XG4gICAgdmFyIGluc3QgPSB7IHZhbHVlOiBnZXRTZXJ2ZXJTbmFwc2hvdCwgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90IH07XG4gICAgaG9vay5xdWV1ZSA9IGluc3Q7XG4gICAgbW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbXG4gICAgICBzdWJzY3JpYmVcbiAgICBdKTtcbiAgICBmaWJlci5mbGFncyB8PSAyMDQ4O1xuICAgIHB1c2hFZmZlY3QoXG4gICAgICA5LFxuICAgICAgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKFxuICAgICAgICBudWxsLFxuICAgICAgICBmaWJlcixcbiAgICAgICAgaW5zdCxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QsXG4gICAgICAgIGdldFNuYXBzaG90XG4gICAgICApLFxuICAgICAgeyBkZXN0cm95OiB2b2lkIDAgfSxcbiAgICAgIG51bGxcbiAgICApO1xuICAgIHJldHVybiBnZXRTZXJ2ZXJTbmFwc2hvdDtcbiAgfSxcbiAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCksXG4gICAgICBpZGVudGlmaWVyUHJlZml4ID0gd29ya0luUHJvZ3Jlc3NSb290LmlkZW50aWZpZXJQcmVmaXg7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgICAgIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgIChcbiAgICAgICAgICBpZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8ICgzMiAtIGNsejMyKGlkV2l0aExlYWRpbmdCaXQpIC0gMSkpXG4gICAgICAgICkudG9TdHJpbmcoMzIpICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgIFwiOlwiICsgaWRlbnRpZmllclByZWZpeCArIFwiUlwiICsgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0O1xuICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gbG9jYWxJZENvdW50ZXIrKztcbiAgICAgIDAgPCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiZcbiAgICAgICAgKGlkZW50aWZpZXJQcmVmaXggKz0gXCJIXCIgKyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQudG9TdHJpbmcoMzIpKTtcbiAgICAgIGlkZW50aWZpZXJQcmVmaXggKz0gXCI6XCI7XG4gICAgfSBlbHNlXG4gICAgICAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gZ2xvYmFsQ2xpZW50SWRDb3VudGVyKyspLFxuICAgICAgICAoaWRlbnRpZmllclByZWZpeCA9XG4gICAgICAgICAgXCI6XCIgK1xuICAgICAgICAgIGlkZW50aWZpZXJQcmVmaXggK1xuICAgICAgICAgIFwiclwiICtcbiAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQudG9TdHJpbmcoMzIpICtcbiAgICAgICAgICBcIjpcIik7XG4gICAgcmV0dXJuIChob29rLm1lbW9pemVkU3RhdGUgPSBpZGVudGlmaWVyUHJlZml4KTtcbiAgfSxcbiAgdXNlQ2FjaGVSZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChtb3VudFdvcmtJblByb2dyZXNzSG9vaygpLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChcbiAgICAgIG51bGwsXG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxXG4gICAgKSk7XG4gIH1cbn07XG5Ib29rc0Rpc3BhdGNoZXJPbk1vdW50LnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlRm9ybVN0YXRlID0gbW91bnRBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uTW91bnQudXNlQWN0aW9uU3RhdGUgPSBtb3VudEFjdGlvblN0YXRlO1xuSG9va3NEaXNwYXRjaGVyT25Nb3VudC51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IDAsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIGhvb2sgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKFxuICAgIG51bGwsXG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSxcbiAgICAhMCxcbiAgICBxdWV1ZVxuICApO1xuICBxdWV1ZS5kaXNwYXRjaCA9IGhvb2s7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2tdO1xufTtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZSA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ2FsbGJhY2s6IHVwZGF0ZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlRWZmZWN0OiB1cGRhdGVFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZUluc2VydGlvbkVmZmVjdDogdXBkYXRlSW5zZXJ0aW9uRWZmZWN0LFxuICB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0ZUxheW91dEVmZmVjdCxcbiAgdXNlTWVtbzogdXBkYXRlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXBkYXRlUmVkdWNlcixcbiAgdXNlUmVmOiB1cGRhdGVSZWYsXG4gIHVzZVN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICB9LFxuICB1c2VEZWJ1Z1ZhbHVlOiBtb3VudERlYnVnVmFsdWUsXG4gIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoXG4gICAgICBob29rLFxuICAgICAgY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcbiAgICAgIHZhbHVlLFxuICAgICAgaW5pdGlhbFZhbHVlXG4gICAgKTtcbiAgfSxcbiAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBib29sZWFuT3JUaGVuYWJsZSA9IHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgIHJldHVybiBbXG4gICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICBzdGFydFxuICAgIF07XG4gIH0sXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgdXNlSWQ6IHVwZGF0ZUlkXG59O1xuSG9va3NEaXNwYXRjaGVyT25VcGRhdGUudXNlQ2FjaGVSZWZyZXNoID0gdXBkYXRlUmVmcmVzaDtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VGb3JtU3RhdGUgPSB1cGRhdGVBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlLnVzZUFjdGlvblN0YXRlID0gdXBkYXRlQWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPblVwZGF0ZS51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufTtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogdXBkYXRlQ2FsbGJhY2ssXG4gIHVzZUNvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2VFZmZlY3Q6IHVwZGF0ZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB1cGRhdGVJbnNlcnRpb25FZmZlY3QsXG4gIHVzZUxheW91dEVmZmVjdDogdXBkYXRlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vOiB1cGRhdGVNZW1vLFxuICB1c2VSZWR1Y2VyOiByZXJlbmRlclJlZHVjZXIsXG4gIHVzZVJlZjogdXBkYXRlUmVmLFxuICB1c2VTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xuICB9LFxuICB1c2VEZWJ1Z1ZhbHVlOiBtb3VudERlYnVnVmFsdWUsXG4gIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgICByZXR1cm4gbnVsbCA9PT0gY3VycmVudEhvb2tcbiAgICAgID8gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKVxuICAgICAgOiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChcbiAgICAgICAgICBob29rLFxuICAgICAgICAgIGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgaW5pdGlhbFZhbHVlXG4gICAgICAgICk7XG4gIH0sXG4gIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm9vbGVhbk9yVGhlbmFibGUgPSByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpWzBdLFxuICAgICAgc3RhcnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKS5tZW1vaXplZFN0YXRlO1xuICAgIHJldHVybiBbXG4gICAgICBcImJvb2xlYW5cIiA9PT0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlXG4gICAgICAgID8gYm9vbGVhbk9yVGhlbmFibGVcbiAgICAgICAgOiB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSksXG4gICAgICBzdGFydFxuICAgIF07XG4gIH0sXG4gIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSxcbiAgdXNlSWQ6IHVwZGF0ZUlkXG59O1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VDYWNoZVJlZnJlc2ggPSB1cGRhdGVSZWZyZXNoO1xuSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlci51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZUZvcm1TdGF0ZSA9IHJlcmVuZGVyQWN0aW9uU3RhdGU7XG5Ib29rc0Rpc3BhdGNoZXJPblJlcmVuZGVyLnVzZUFjdGlvblN0YXRlID0gcmVyZW5kZXJBY3Rpb25TdGF0ZTtcbkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXIudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIChwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICBpZiAobnVsbCAhPT0gY3VycmVudEhvb2spXG4gICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7XG4gIHJldHVybiBbcGFzc3Rocm91Z2gsIGhvb2sucXVldWUuZGlzcGF0Y2hdO1xufTtcbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgY3RvcixcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLFxuICBuZXh0UHJvcHNcbikge1xuICBjdG9yID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgY3Rvcik7XG4gIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9XG4gICAgbnVsbCA9PT0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIHx8IHZvaWQgMCA9PT0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG4gICAgICA/IGN0b3JcbiAgICAgIDogYXNzaWduKHt9LCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMpO1xufVxudmFyIGNsYXNzQ29tcG9uZW50VXBkYXRlciA9IHtcbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQgPSBjb21wb25lbnQuX3JlYWN0SW50ZXJuYWxzKVxuICAgICAgPyBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGNvbXBvbmVudCkgPT09IGNvbXBvbmVudFxuICAgICAgOiAhMTtcbiAgfSxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAoaW5zdCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpLFxuICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICB2b2lkIDAgIT09IGNhbGxiYWNrICYmIG51bGwgIT09IGNhbGxiYWNrICYmICh1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjayk7XG4gICAgcGF5bG9hZCA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICBudWxsICE9PSBwYXlsb2FkICYmXG4gICAgICAoc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHBheWxvYWQsIGluc3QsIGxhbmUpLFxuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhwYXlsb2FkLCBpbnN0LCBsYW5lKSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIGluc3QgPSBpbnN0Ll9yZWFjdEludGVybmFscztcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCksXG4gICAgICB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IDE7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgJiYgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICBwYXlsb2FkID0gZW5xdWV1ZVVwZGF0ZShpbnN0LCB1cGRhdGUsIGxhbmUpO1xuICAgIG51bGwgIT09IHBheWxvYWQgJiZcbiAgICAgIChzY2hlZHVsZVVwZGF0ZU9uRmliZXIocGF5bG9hZCwgaW5zdCwgbGFuZSksXG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHBheWxvYWQsIGluc3QsIGxhbmUpKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICBpbnN0ID0gaW5zdC5fcmVhY3RJbnRlcm5hbHM7XG4gICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZSgpLFxuICAgICAgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSAyO1xuICAgIHZvaWQgMCAhPT0gY2FsbGJhY2sgJiYgbnVsbCAhPT0gY2FsbGJhY2sgJiYgKHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgICBjYWxsYmFjayA9IGVucXVldWVVcGRhdGUoaW5zdCwgdXBkYXRlLCBsYW5lKTtcbiAgICBudWxsICE9PSBjYWxsYmFjayAmJlxuICAgICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihjYWxsYmFjaywgaW5zdCwgbGFuZSksXG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKGNhbGxiYWNrLCBpbnN0LCBsYW5lKSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGN0b3IsXG4gIG9sZFByb3BzLFxuICBuZXdQcm9wcyxcbiAgb2xkU3RhdGUsXG4gIG5ld1N0YXRlLFxuICBuZXh0Q29udGV4dFxuKSB7XG4gIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICByZXR1cm4gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3Muc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gICAgPyB3b3JrSW5Qcm9ncmVzcy5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dClcbiAgICA6IGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50XG4gICAgICA/ICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSlcbiAgICAgIDogITA7XG59XG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGluc3RhbmNlLFxuICBuZXdQcm9wcyxcbiAgbmV4dENvbnRleHRcbikge1xuICB3b3JrSW5Qcm9ncmVzcyA9IGluc3RhbmNlLnN0YXRlO1xuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAmJlxuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIGluc3RhbmNlLnN0YXRlICE9PSB3b3JrSW5Qcm9ncmVzcyAmJlxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGJhc2VQcm9wcykge1xuICB2YXIgbmV3UHJvcHMgPSBiYXNlUHJvcHM7XG4gIGlmIChcInJlZlwiIGluIGJhc2VQcm9wcykge1xuICAgIG5ld1Byb3BzID0ge307XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gYmFzZVByb3BzKVxuICAgICAgXCJyZWZcIiAhPT0gcHJvcE5hbWUgJiYgKG5ld1Byb3BzW3Byb3BOYW1lXSA9IGJhc2VQcm9wc1twcm9wTmFtZV0pO1xuICB9XG4gIGlmICgoQ29tcG9uZW50ID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcykpIHtcbiAgICBuZXdQcm9wcyA9PT0gYmFzZVByb3BzICYmIChuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMpKTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSQ2NyBpbiBDb21wb25lbnQpXG4gICAgICB2b2lkIDAgPT09IG5ld1Byb3BzW3Byb3BOYW1lJDY3XSAmJlxuICAgICAgICAobmV3UHJvcHNbcHJvcE5hbWUkNjddID0gQ29tcG9uZW50W3Byb3BOYW1lJDY3XSk7XG4gIH1cbiAgcmV0dXJuIG5ld1Byb3BzO1xufVxudmFyIHJlcG9ydEdsb2JhbEVycm9yID1cbiAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcmVwb3J0RXJyb3JcbiAgICA/IHJlcG9ydEVycm9yXG4gICAgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiB3aW5kb3cgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudFxuICAgICAgICApIHtcbiAgICAgICAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoXCJlcnJvclwiLCB7XG4gICAgICAgICAgICBidWJibGVzOiAhMCxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6ICEwLFxuICAgICAgICAgICAgbWVzc2FnZTpcbiAgICAgICAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGVycm9yICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGVycm9yICYmXG4gICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBlcnJvci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgPyBTdHJpbmcoZXJyb3IubWVzc2FnZSlcbiAgICAgICAgICAgICAgICA6IFN0cmluZyhlcnJvciksXG4gICAgICAgICAgICBlcnJvcjogZXJyb3JcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIXdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9jZXNzICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcHJvY2Vzcy5lbWl0XG4gICAgICAgICkge1xuICAgICAgICAgIHByb2Nlc3MuZW1pdChcInVuY2F1Z2h0RXhjZXB0aW9uXCIsIGVycm9yKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9O1xuZnVuY3Rpb24gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG59XG5mdW5jdGlvbiBkZWZhdWx0T25DYXVnaHRFcnJvcihlcnJvcikge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IoZXJyb3IpIHtcbiAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xufVxuZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICB2YXIgb25VbmNhdWdodEVycm9yID0gcm9vdC5vblVuY2F1Z2h0RXJyb3I7XG4gICAgb25VbmNhdWdodEVycm9yKGVycm9ySW5mby52YWx1ZSwgeyBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrIH0pO1xuICB9IGNhdGNoIChlJDY4KSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlJDY4O1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsb2dDYXVnaHRFcnJvcihyb290LCBib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9uQ2F1Z2h0RXJyb3IgPSByb290Lm9uQ2F1Z2h0RXJyb3I7XG4gICAgb25DYXVnaHRFcnJvcihlcnJvckluZm8udmFsdWUsIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2ssXG4gICAgICBlcnJvckJvdW5kYXJ5OiAxID09PSBib3VuZGFyeS50YWcgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUkNjkpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGUkNjk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290LCBlcnJvckluZm8sIGxhbmUpIHtcbiAgbGFuZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgbGFuZS50YWcgPSAzO1xuICBsYW5lLnBheWxvYWQgPSB7IGVsZW1lbnQ6IG51bGwgfTtcbiAgbGFuZS5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGVycm9ySW5mbyk7XG4gIH07XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKSB7XG4gIGxhbmUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIGxhbmUudGFnID0gMztcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pIHtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9IGZpYmVyLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yO1xuICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcik7XG4gICAgfTtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2dDYXVnaHRFcnJvcihyb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICB9O1xuICB9XG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICBudWxsICE9PSBpbnN0ICYmXG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICh1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBsb2dDYXVnaHRFcnJvcihyb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAmJlxuICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWRcbiAgICAgICAgICA/IChsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW3RoaXNdKSlcbiAgICAgICAgICA6IGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZCh0aGlzKSk7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9ySW5mby52YWx1ZSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogbnVsbCAhPT0gc3RhY2sgPyBzdGFjayA6IFwiXCJcbiAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24oXG4gIHJvb3QsXG4gIHJldHVybkZpYmVyLFxuICBzb3VyY2VGaWJlcixcbiAgdmFsdWUsXG4gIHJvb3RSZW5kZXJMYW5lc1xuKSB7XG4gIHNvdXJjZUZpYmVyLmZsYWdzIHw9IDMyNzY4O1xuICBpZiAoXG4gICAgbnVsbCAhPT0gdmFsdWUgJiZcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdmFsdWUgJiZcbiAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB2YWx1ZS50aGVuXG4gICkge1xuICAgIHJldHVybkZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgIG51bGwgIT09IHJldHVybkZpYmVyICYmXG4gICAgICBwcm9wYWdhdGVQYXJlbnRDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgcmV0dXJuRmliZXIsXG4gICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIHNvdXJjZUZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgICBpZiAobnVsbCAhPT0gc291cmNlRmliZXIpIHtcbiAgICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG51bGwgPT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgICAgICAgPyByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKClcbiAgICAgICAgICAgICAgOiBudWxsID09PSBzb3VyY2VGaWJlci5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAzKSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAoc291cmNlRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgdmFsdWUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZVxuICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci5mbGFncyB8PSAxNjM4NClcbiAgICAgICAgICAgICAgOiAoKHJldHVybkZpYmVyID0gc291cmNlRmliZXIudXBkYXRlUXVldWUpLFxuICAgICAgICAgICAgICAgIG51bGwgPT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICA/IChzb3VyY2VGaWJlci51cGRhdGVRdWV1ZSA9IG5ldyBTZXQoW3ZhbHVlXSkpXG4gICAgICAgICAgICAgICAgICA6IHJldHVybkZpYmVyLmFkZCh2YWx1ZSksXG4gICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAgIHZhbHVlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGVcbiAgICAgICAgICAgICAgPyAoc291cmNlRmliZXIuZmxhZ3MgfD0gMTYzODQpXG4gICAgICAgICAgICAgIDogKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgICBudWxsID09PSByZXR1cm5GaWJlclxuICAgICAgICAgICAgICAgICAgPyAoKHJldHVybkZpYmVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt2YWx1ZV0pXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAoc291cmNlRmliZXIudXBkYXRlUXVldWUgPSByZXR1cm5GaWJlcikpXG4gICAgICAgICAgICAgICAgICA6ICgoc291cmNlRmliZXIgPSByZXR1cm5GaWJlci5yZXRyeVF1ZXVlKSxcbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PT0gc291cmNlRmliZXJcbiAgICAgICAgICAgICAgICAgICAgICA/IChyZXR1cm5GaWJlci5yZXRyeVF1ZXVlID0gbmV3IFNldChbdmFsdWVdKSlcbiAgICAgICAgICAgICAgICAgICAgICA6IHNvdXJjZUZpYmVyLmFkZCh2YWx1ZSkpLFxuICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAhMVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzNSwgc291cmNlRmliZXIudGFnKSk7XG4gICAgfVxuICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGlmIChpc0h5ZHJhdGluZylcbiAgICByZXR1cm4gKFxuICAgICAgKHJldHVybkZpYmVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICBudWxsICE9PSByZXR1cm5GaWJlclxuICAgICAgICA/ICgwID09PSAocmV0dXJuRmliZXIuZmxhZ3MgJiA2NTUzNikgJiYgKHJldHVybkZpYmVyLmZsYWdzIHw9IDI1NiksXG4gICAgICAgICAgKHJldHVybkZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAocmV0dXJuRmliZXIubGFuZXMgPSByb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgIHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbiAmJlxuICAgICAgICAgICAgKChyb290ID0gRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MjIpLCB7IGNhdXNlOiB2YWx1ZSB9KSksXG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHJvb3QsIHNvdXJjZUZpYmVyKSkpKVxuICAgICAgICA6ICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gJiZcbiAgICAgICAgICAgICgocmV0dXJuRmliZXIgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQyMyksIHtcbiAgICAgICAgICAgICAgY2F1c2U6IHZhbHVlXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKFxuICAgICAgICAgICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihyZXR1cm5GaWJlciwgc291cmNlRmliZXIpXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAocm9vdCA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGUpLFxuICAgICAgICAgIChyb290LmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgIChyb290LmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgKHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKSksXG4gICAgICAgICAgKHJvb3RSZW5kZXJMYW5lcyA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShcbiAgICAgICAgICAgIHJvb3Quc3RhdGVOb2RlLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICByb290UmVuZGVyTGFuZXNcbiAgICAgICAgICApKSxcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUocm9vdCwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICA0ICE9PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICYmXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDIpKSxcbiAgICAgICExXG4gICAgKTtcbiAgdmFyIHdyYXBwZXJFcnJvciA9IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTIwKSwgeyBjYXVzZTogdmFsdWUgfSk7XG4gIHdyYXBwZXJFcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHdyYXBwZXJFcnJvciwgc291cmNlRmliZXIpO1xuICBudWxsID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzXG4gICAgPyAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IFt3cmFwcGVyRXJyb3JdKVxuICAgIDogd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycy5wdXNoKHdyYXBwZXJFcnJvcik7XG4gIDQgIT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAyKTtcbiAgaWYgKG51bGwgPT09IHJldHVybkZpYmVyKSByZXR1cm4gITA7XG4gIHZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgc291cmNlRmliZXIgPSByZXR1cm5GaWJlcjtcbiAgZG8ge1xuICAgIHN3aXRjaCAoc291cmNlRmliZXIudGFnKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHNvdXJjZUZpYmVyLmZsYWdzIHw9IDY1NTM2KSxcbiAgICAgICAgICAocm9vdCA9IHJvb3RSZW5kZXJMYW5lcyAmIC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgIChzb3VyY2VGaWJlci5sYW5lcyB8PSByb290KSxcbiAgICAgICAgICAocm9vdCA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShzb3VyY2VGaWJlci5zdGF0ZU5vZGUsIHZhbHVlLCByb290KSksXG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHNvdXJjZUZpYmVyLCByb290KSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChyZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnR5cGUpLFxuICAgICAgICAgICh3cmFwcGVyRXJyb3IgPSBzb3VyY2VGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgIDAgPT09IChzb3VyY2VGaWJlci5mbGFncyAmIDEyOCkgJiZcbiAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5GaWJlci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgfHxcbiAgICAgICAgICAgICAgKG51bGwgIT09IHdyYXBwZXJFcnJvciAmJlxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHdyYXBwZXJFcnJvci5jb21wb25lbnREaWRDYXRjaCAmJlxuICAgICAgICAgICAgICAgIChudWxsID09PSBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCB8fFxuICAgICAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyh3cmFwcGVyRXJyb3IpKSkpKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzb3VyY2VGaWJlci5mbGFncyB8PSA2NTUzNiksXG4gICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzICY9IC1yb290UmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgKHNvdXJjZUZpYmVyLmxhbmVzIHw9IHJvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAocm9vdFJlbmRlckxhbmVzID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShyb290UmVuZGVyTGFuZXMpKSxcbiAgICAgICAgICAgIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKFxuICAgICAgICAgICAgICByb290UmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShzb3VyY2VGaWJlciwgcm9vdFJlbmRlckxhbmVzKSxcbiAgICAgICAgICAgICExXG4gICAgICAgICAgKTtcbiAgICB9XG4gICAgc291cmNlRmliZXIgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIH0gd2hpbGUgKG51bGwgIT09IHNvdXJjZUZpYmVyKTtcbiAgcmV0dXJuICExO1xufVxudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiA9IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDYxKSksXG4gIGRpZFJlY2VpdmVVcGRhdGUgPSAhMTtcbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID1cbiAgICBudWxsID09PSBjdXJyZW50XG4gICAgICA/IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpXG4gICAgICA6IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGN1cnJlbnQuY2hpbGQsXG4gICAgICAgICAgbmV4dENoaWxkcmVuLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICk7XG59XG5mdW5jdGlvbiB1cGRhdGVGb3J3YXJkUmVmKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICBuZXh0UHJvcHMsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgQ29tcG9uZW50ID0gQ29tcG9uZW50LnJlbmRlcjtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgaWYgKFwicmVmXCIgaW4gbmV4dFByb3BzKSB7XG4gICAgdmFyIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBuZXh0UHJvcHMpXG4gICAgICBcInJlZlwiICE9PSBrZXkgJiYgKHByb3BzV2l0aG91dFJlZltrZXldID0gbmV4dFByb3BzW2tleV0pO1xuICB9IGVsc2UgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIG5leHRQcm9wcyA9IHJlbmRlcldpdGhIb29rcyhcbiAgICBjdXJyZW50LFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIENvbXBvbmVudCxcbiAgICBwcm9wc1dpdGhvdXRSZWYsXG4gICAgcmVmLFxuICAgIHJlbmRlckxhbmVzXG4gICk7XG4gIGtleSA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgIHJldHVybiAoXG4gICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICk7XG4gIGlzSHlkcmF0aW5nICYmIGtleSAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgQ29tcG9uZW50LFxuICBuZXh0UHJvcHMsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuICAgIGlmIChcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiZcbiAgICAgIHZvaWQgMCA9PT0gdHlwZS5kZWZhdWx0UHJvcHMgJiZcbiAgICAgIG51bGwgPT09IENvbXBvbmVudC5jb21wYXJlXG4gICAgKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnRhZyA9IDE1KSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSB0eXBlKSxcbiAgICAgICAgdXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgY3VycmVudCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhcbiAgICAgIENvbXBvbmVudC50eXBlLFxuICAgICAgbnVsbCxcbiAgICAgIG5leHRQcm9wcyxcbiAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgd29ya0luUHJvZ3Jlc3MubW9kZSxcbiAgICAgIHJlbmRlckxhbmVzXG4gICAgKTtcbiAgICBjdXJyZW50LnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjdXJyZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbiAgfVxuICB0eXBlID0gY3VycmVudC5jaGlsZDtcbiAgaWYgKCFjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykpIHtcbiAgICB2YXIgcHJldlByb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgIENvbXBvbmVudCA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgIENvbXBvbmVudCA9IG51bGwgIT09IENvbXBvbmVudCA/IENvbXBvbmVudCA6IHNoYWxsb3dFcXVhbDtcbiAgICBpZiAoQ29tcG9uZW50KHByZXZQcm9wcywgbmV4dFByb3BzKSAmJiBjdXJyZW50LnJlZiA9PT0gd29ya0luUHJvZ3Jlc3MucmVmKVxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICBjdXJyZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3ModHlwZSwgbmV4dFByb3BzKTtcbiAgY3VycmVudC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGN1cnJlbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICBDb21wb25lbnQsXG4gIG5leHRQcm9wcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKFxuICAgICAgc2hhbGxvd0VxdWFsKHByZXZQcm9wcywgbmV4dFByb3BzKSAmJlxuICAgICAgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZlxuICAgIClcbiAgICAgIGlmIChcbiAgICAgICAgKChkaWRSZWNlaXZlVXBkYXRlID0gITEpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzKSxcbiAgICAgICAgY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKVxuICAgICAgKVxuICAgICAgICAwICE9PSAoY3VycmVudC5mbGFncyAmIDEzMTA3MikgJiYgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMCk7XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcyksXG4gICAgICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgICAgICk7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICByZW5kZXJMYW5lc1xuICApO1xufVxuZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbixcbiAgICBuZXh0SXNEZXRhY2hlZCA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMiksXG4gICAgcHJldlN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICBpZiAoXCJoaWRkZW5cIiA9PT0gbmV4dFByb3BzLm1vZGUgfHwgbmV4dElzRGV0YWNoZWQpIHtcbiAgICBpZiAoMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSkge1xuICAgICAgbmV4dFByb3BzID1cbiAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzIDogcmVuZGVyTGFuZXM7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgICAgIGZvciAobmV4dElzRGV0YWNoZWQgPSAwOyBudWxsICE9PSBuZXh0Q2hpbGRyZW47IClcbiAgICAgICAgICAobmV4dElzRGV0YWNoZWQgPVxuICAgICAgICAgICAgbmV4dElzRGV0YWNoZWQgfCBuZXh0Q2hpbGRyZW4ubGFuZXMgfCBuZXh0Q2hpbGRyZW4uY2hpbGRMYW5lcyksXG4gICAgICAgICAgICAobmV4dENoaWxkcmVuID0gbmV4dENoaWxkcmVuLnNpYmxpbmcpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbmV4dElzRGV0YWNoZWQgJiB+bmV4dFByb3BzO1xuICAgICAgfSBlbHNlICh3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gMCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpO1xuICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKDAgIT09IChyZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpXG4gICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHsgYmFzZUxhbmVzOiAwLCBjYWNoZVBvb2w6IG51bGwgfSksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICBwdXNoVHJhbnNpdGlvbihcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgbnVsbCAhPT0gcHJldlN0YXRlID8gcHJldlN0YXRlLmNhY2hlUG9vbCA6IG51bGxcbiAgICAgICAgICApLFxuICAgICAgICBudWxsICE9PSBwcmV2U3RhdGVcbiAgICAgICAgICA/IHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpXG4gICAgICAgICAgOiByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKCksXG4gICAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSA1MzY4NzA5MTIpLFxuICAgICAgICBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIG51bGwgIT09IHByZXZTdGF0ZSA/IHByZXZTdGF0ZS5iYXNlTGFuZXMgfCByZW5kZXJMYW5lcyA6IHJlbmRlckxhbmVzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gIH0gZWxzZVxuICAgIG51bGwgIT09IHByZXZTdGF0ZVxuICAgICAgPyAocHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZS5jYWNoZVBvb2wpLFxuICAgICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKSxcbiAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsKSlcbiAgICAgIDogKG51bGwgIT09IGN1cnJlbnQgJiYgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpLFxuICAgICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKCksXG4gICAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcykpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cbmZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgbmV4dEJhc2VMYW5lcyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGVla0NhY2hlRnJvbVBvb2woKTtcbiAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICBudWxsID09PSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgID8gbnVsbFxuICAgICAgOiB7IHBhcmVudDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUsIHBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCB9O1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lcyxcbiAgICBjYWNoZVBvb2w6IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICB9O1xuICBudWxsICE9PSBjdXJyZW50ICYmIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjaygpO1xuICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcywgITApO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgaWYgKG51bGwgPT09IHJlZilcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICBudWxsICE9PSBjdXJyZW50LnJlZiAmJlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDIwOTc2NjQpO1xuICBlbHNlIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcmVmICYmIFwib2JqZWN0XCIgIT09IHR5cGVvZiByZWYpXG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI4NCkpO1xuICAgIGlmIChudWxsID09PSBjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDk3NjY0O1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgbmV4dFByb3BzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgQ29tcG9uZW50ID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgIGN1cnJlbnQsXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICB2b2lkIDAsXG4gICAgcmVuZGVyTGFuZXNcbiAgKTtcbiAgbmV4dFByb3BzID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgIWRpZFJlY2VpdmVVcGRhdGUpXG4gICAgcmV0dXJuIChcbiAgICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpLFxuICAgICAgYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpXG4gICAgKTtcbiAgaXNIeWRyYXRpbmcgJiYgbmV4dFByb3BzICYmIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cbmZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgbmV4dFByb3BzLFxuICBDb21wb25lbnQsXG4gIHNlY29uZEFyZyxcbiAgcmVuZGVyTGFuZXNcbikge1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgbmV4dFByb3BzID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4oXG4gICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgQ29tcG9uZW50LFxuICAgIG5leHRQcm9wcyxcbiAgICBzZWNvbmRBcmdcbiAgKTtcbiAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCk7XG4gIENvbXBvbmVudCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gIGlmIChudWxsICE9PSBjdXJyZW50ICYmICFkaWRSZWNlaXZlVXBkYXRlKVxuICAgIHJldHVybiAoXG4gICAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSxcbiAgICAgIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICk7XG4gIGlzSHlkcmF0aW5nICYmIENvbXBvbmVudCAmJiBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIENvbXBvbmVudCxcbiAgbmV4dFByb3BzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgIHZhciBjb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0LFxuICAgICAgY29udGV4dFR5cGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlICYmXG4gICAgICBudWxsICE9PSBjb250ZXh0VHlwZSAmJlxuICAgICAgKGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSkpO1xuICAgIGNvbnRleHQgPSBuZXcgQ29tcG9uZW50KG5leHRQcm9wcywgY29udGV4dCk7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9XG4gICAgICBudWxsICE9PSBjb250ZXh0LnN0YXRlICYmIHZvaWQgMCAhPT0gY29udGV4dC5zdGF0ZSA/IGNvbnRleHQuc3RhdGUgOiBudWxsO1xuICAgIGNvbnRleHQudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjb250ZXh0O1xuICAgIGNvbnRleHQuX3JlYWN0SW50ZXJuYWxzID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBjb250ZXh0LnByb3BzID0gbmV4dFByb3BzO1xuICAgIGNvbnRleHQuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHQucmVmcyA9IHt9O1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgY29udGV4dFR5cGUgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgY29udGV4dC5jb250ZXh0ID1cbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBjb250ZXh0VHlwZSAmJiBudWxsICE9PSBjb250ZXh0VHlwZVxuICAgICAgICA/IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKVxuICAgICAgICA6IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgICBjb250ZXh0LnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBjb250ZXh0VHlwZSA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dFR5cGUgJiZcbiAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgY29udGV4dFR5cGUsXG4gICAgICAgIG5leHRQcm9wc1xuICAgICAgKSxcbiAgICAgIChjb250ZXh0LnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpO1xuICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQpIHx8XG4gICAgICAoKGNvbnRleHRUeXBlID0gY29udGV4dC5zdGF0ZSksXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCAmJlxuICAgICAgICBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpLFxuICAgICAgY29udGV4dFR5cGUgIT09IGNvbnRleHQuc3RhdGUgJiZcbiAgICAgICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoY29udGV4dCwgY29udGV4dC5zdGF0ZSwgbnVsbCksXG4gICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpLFxuICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpLFxuICAgICAgKGNvbnRleHQuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSk7XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQxOTQzMDgpO1xuICAgIG5leHRQcm9wcyA9ICEwO1xuICB9IGVsc2UgaWYgKG51bGwgPT09IGN1cnJlbnQpIHtcbiAgICBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAgICAgb2xkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gICAgY29udGV4dC5wcm9wcyA9IG9sZFByb3BzO1xuICAgIHZhciBvbGRDb250ZXh0ID0gY29udGV4dC5jb250ZXh0LFxuICAgICAgY29udGV4dFR5cGUkanNjb21wJDAgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgY29udGV4dFR5cGUgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIGNvbnRleHRUeXBlJGpzY29tcCQwICYmXG4gICAgICBudWxsICE9PSBjb250ZXh0VHlwZSRqc2NvbXAkMCAmJlxuICAgICAgKGNvbnRleHRUeXBlID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUkanNjb21wJDApKTtcbiAgICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgICBjb250ZXh0VHlwZSRqc2NvbXAkMCA9XG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7XG4gICAgY29udGV4dFR5cGUkanNjb21wJDAgfHxcbiAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICgodW5yZXNvbHZlZE9sZFByb3BzIHx8IG9sZENvbnRleHQgIT09IGNvbnRleHRUeXBlKSAmJlxuICAgICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICBjb250ZXh0VHlwZVxuICAgICAgICApKTtcbiAgICBoYXNGb3JjZVVwZGF0ZSA9ICExO1xuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgY29udGV4dC5zdGF0ZSA9IG9sZFN0YXRlO1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgIG9sZENvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHVucmVzb2x2ZWRPbGRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkQ29udGV4dCB8fCBoYXNGb3JjZVVwZGF0ZVxuICAgICAgPyAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICYmXG4gICAgICAgICAgKGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsXG4gICAgICAgICAgICBuZXh0UHJvcHNcbiAgICAgICAgICApLFxuICAgICAgICAgIChvbGRDb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSkpLFxuICAgICAgICAob2xkUHJvcHMgPVxuICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlIHx8XG4gICAgICAgICAgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIG9sZFByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICBvbGRDb250ZXh0LFxuICAgICAgICAgICAgY29udGV4dFR5cGVcbiAgICAgICAgICApKVxuICAgICAgICAgID8gKGNvbnRleHRUeXBlJGpzY29tcCQwIHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudFdpbGxNb3VudCkgfHxcbiAgICAgICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRXaWxsTW91bnQoKSxcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCkpLFxuICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCkpXG4gICAgICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDE5NDMwOCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG9sZENvbnRleHQpKSxcbiAgICAgICAgKGNvbnRleHQucHJvcHMgPSBuZXh0UHJvcHMpLFxuICAgICAgICAoY29udGV4dC5zdGF0ZSA9IG9sZENvbnRleHQpLFxuICAgICAgICAoY29udGV4dC5jb250ZXh0ID0gY29udGV4dFR5cGUpLFxuICAgICAgICAobmV4dFByb3BzID0gb2xkUHJvcHMpKVxuICAgICAgOiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnREaWRNb3VudCAmJlxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0MTk0MzA4KSxcbiAgICAgICAgKG5leHRQcm9wcyA9ICExKSk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICBjb250ZXh0VHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgY29udGV4dFR5cGUkanNjb21wJDAgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIGNvbnRleHRUeXBlKTtcbiAgICBjb250ZXh0LnByb3BzID0gY29udGV4dFR5cGUkanNjb21wJDA7XG4gICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIG9sZFN0YXRlID0gY29udGV4dC5jb250ZXh0O1xuICAgIG9sZENvbnRleHQgPSBDb21wb25lbnQuY29udGV4dFR5cGU7XG4gICAgb2xkUHJvcHMgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9sZENvbnRleHQgJiZcbiAgICAgIG51bGwgIT09IG9sZENvbnRleHQgJiZcbiAgICAgIChvbGRQcm9wcyA9IHJlYWRDb250ZXh0KG9sZENvbnRleHQpKTtcbiAgICB1bnJlc29sdmVkT2xkUHJvcHMgPSBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICAgIChvbGRDb250ZXh0ID1cbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyB8fFxuICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSkgfHxcbiAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcykgfHxcbiAgICAgICgoY29udGV4dFR5cGUgIT09IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyB8fCBvbGRTdGF0ZSAhPT0gb2xkUHJvcHMpICYmXG4gICAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgIG9sZFByb3BzXG4gICAgICAgICkpO1xuICAgIGhhc0ZvcmNlVXBkYXRlID0gITE7XG4gICAgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHQuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICB2YXIgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIGNvbnRleHRUeXBlICE9PSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgfHxcbiAgICBvbGRTdGF0ZSAhPT0gbmV3U3RhdGUgfHxcbiAgICBoYXNGb3JjZVVwZGF0ZSB8fFxuICAgIChudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICBudWxsICE9PSBjdXJyZW50LmRlcGVuZGVuY2llcyAmJlxuICAgICAgY2hlY2tJZkNvbnRleHRDaGFuZ2VkKGN1cnJlbnQuZGVwZW5kZW5jaWVzKSlcbiAgICAgID8gKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHVucmVzb2x2ZWRPbGRQcm9wcyAmJlxuICAgICAgICAgIChhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyhcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgdW5yZXNvbHZlZE9sZFByb3BzLFxuICAgICAgICAgICAgbmV4dFByb3BzXG4gICAgICAgICAgKSxcbiAgICAgICAgICAobmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlKSksXG4gICAgICAgIChjb250ZXh0VHlwZSRqc2NvbXAkMCA9XG4gICAgICAgICAgaGFzRm9yY2VVcGRhdGUgfHxcbiAgICAgICAgICBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgY29udGV4dFR5cGUkanNjb21wJDAsXG4gICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgb2xkUHJvcHNcbiAgICAgICAgICApIHx8XG4gICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQuZGVwZW5kZW5jaWVzICYmXG4gICAgICAgICAgICBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudC5kZXBlbmRlbmNpZXMpKSlcbiAgICAgICAgICA/IChvbGRDb250ZXh0IHx8XG4gICAgICAgICAgICAgIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsVXBkYXRlKSB8fFxuICAgICAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5jb21wb25lbnRXaWxsVXBkYXRlICYmXG4gICAgICAgICAgICAgICAgY29udGV4dC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV3U3RhdGUsIG9sZFByb3BzKSxcbiAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY29udGV4dC5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgIGNvbnRleHQuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUoXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIG9sZFByb3BzXG4gICAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudERpZFVwZGF0ZSAmJlxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNCksXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250ZXh0LmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICYmXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSlcbiAgICAgICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgICAgICAoY29udGV4dFR5cGUgPT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAmJlxuICAgICAgICAgICAgICAgIG9sZFN0YXRlID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHx8XG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNvbnRleHQuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgfHxcbiAgICAgICAgICAgICAgKGNvbnRleHRUeXBlID09PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgJiZcbiAgICAgICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTAyNCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlKSksXG4gICAgICAgIChjb250ZXh0LnByb3BzID0gbmV4dFByb3BzKSxcbiAgICAgICAgKGNvbnRleHQuc3RhdGUgPSBuZXdTdGF0ZSksXG4gICAgICAgIChjb250ZXh0LmNvbnRleHQgPSBvbGRQcm9wcyksXG4gICAgICAgIChuZXh0UHJvcHMgPSBjb250ZXh0VHlwZSRqc2NvbXAkMCkpXG4gICAgICA6IChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBjb250ZXh0LmNvbXBvbmVudERpZFVwZGF0ZSB8fFxuICAgICAgICAgIChjb250ZXh0VHlwZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KSxcbiAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgY29udGV4dC5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSB8fFxuICAgICAgICAgIChjb250ZXh0VHlwZSA9PT0gY3VycmVudC5tZW1vaXplZFByb3BzICYmXG4gICAgICAgICAgICBvbGRTdGF0ZSA9PT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB8fFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgKG5leHRQcm9wcyA9ICExKSk7XG4gIH1cbiAgY29udGV4dCA9IG5leHRQcm9wcztcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIG5leHRQcm9wcyA9IDAgIT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOCk7XG4gIGNvbnRleHQgfHwgbmV4dFByb3BzXG4gICAgPyAoKGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpLFxuICAgICAgKENvbXBvbmVudCA9XG4gICAgICAgIG5leHRQcm9wcyAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiBjb250ZXh0LnJlbmRlcigpKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxKSxcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgbmV4dFByb3BzXG4gICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBjdXJyZW50LmNoaWxkLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICkpKVxuICAgICAgICA6IHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckxhbmVzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY29udGV4dC5zdGF0ZSksXG4gICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSlcbiAgICA6IChjdXJyZW50ID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApKTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgY3VycmVudCxcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIG5leHRDaGlsZHJlbixcbiAgcmVuZGVyTGFuZXNcbikge1xuICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI1NjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG52YXIgU1VTUEVOREVEX01BUktFUiA9IHsgZGVoeWRyYXRlZDogbnVsbCwgdHJlZUNvbnRleHQ6IG51bGwsIHJldHJ5TGFuZTogMCB9O1xuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7IGJhc2VMYW5lczogcmVuZGVyTGFuZXMsIGNhY2hlUG9vbDogZ2V0U3VzcGVuZGVkQ2FjaGUoKSB9O1xufVxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gIGN1cnJlbnQsXG4gIHByaW1hcnlUcmVlRGlkRGVmZXIsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgY3VycmVudCA9IG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LmNoaWxkTGFuZXMgJiB+cmVuZGVyTGFuZXMgOiAwO1xuICBwcmltYXJ5VHJlZURpZERlZmVyICYmIChjdXJyZW50IHw9IHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICBzaG93RmFsbGJhY2sgPSAhMSxcbiAgICBkaWRTdXNwZW5kID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSxcbiAgICBKU0NvbXBpbGVyX3RlbXA7XG4gIChKU0NvbXBpbGVyX3RlbXAgPSBkaWRTdXNwZW5kKSB8fFxuICAgIChKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBjdXJyZW50Lm1lbW9pemVkU3RhdGVcbiAgICAgICAgPyAhMVxuICAgICAgICA6IDAgIT09IChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiAyKSk7XG4gIEpTQ29tcGlsZXJfdGVtcCAmJiAoKHNob3dGYWxsYmFjayA9ICEwKSwgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xMjkpKTtcbiAgSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMzIpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMzM7XG4gIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBzaG93RmFsbGJhY2tcbiAgICAgICAgPyBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgIDogcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmIChpc0h5ZHJhdGluZykge1xuICAgICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgIGlmICgoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gbmV4dEluc3RhbmNlKSkge1xuICAgICAgICAgIGM6IHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IG5leHRJbnN0YW5jZTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5leHRJbnN0YW5jZSA9IHJvb3RPclNpbmdsZXRvbkNvbnRleHQ7XG4gICAgICAgICAgICAgIDggIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5ub2RlVHlwZTtcblxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5uZXh0U2libGluZ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwKSB7XG4gICAgICAgICAgICAgICAgbmV4dEluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhayBjO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0SW5zdGFuY2UgPSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZVxuICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZGVoeWRyYXRlZDogbmV4dEluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHRyZWVDb250ZXh0OlxuICAgICAgICAgICAgICAgICAgbnVsbCAhPT0gdHJlZUNvbnRleHRQcm92aWRlclxuICAgICAgICAgICAgICAgICAgICA/IHsgaWQ6IHRyZWVDb250ZXh0SWQsIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93IH1cbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJldHJ5TGFuZTogNTM2ODcwOTEyXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoXG4gICAgICAgICAgICAgICAgMTgsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAuc3RhdGVOb2RlID0gbmV4dEluc3RhbmNlKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCksXG4gICAgICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsKSxcbiAgICAgICAgICAgICAgKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICEwKSlcbiAgICAgICAgICAgIDogKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9ICExKTtcbiAgICAgICAgfVxuICAgICAgICBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSAmJlxuICAgICAgICAoKG5leHRJbnN0YW5jZSA9IG5leHRJbnN0YW5jZS5kZWh5ZHJhdGVkKSwgbnVsbCAhPT0gbmV4dEluc3RhbmNlKVxuICAgICAgKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIFwiJCFcIiA9PT0gbmV4dEluc3RhbmNlLmRhdGFcbiAgICAgICAgICAgID8gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gMTYpXG4gICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDUzNjg3MDkxMiksXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgbmV4dEluc3RhbmNlID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgIG5leHRQcm9wcyA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAobmV4dEluc3RhbmNlID0gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKFxuICAgICAgICAgIHsgbW9kZTogXCJoaWRkZW5cIiwgY2hpbGRyZW46IG5leHRJbnN0YW5jZSB9LFxuICAgICAgICAgIHNob3dGYWxsYmFja1xuICAgICAgICApKSxcbiAgICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApKSxcbiAgICAgICAgKG5leHRJbnN0YW5jZS5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAobmV4dEluc3RhbmNlLnNpYmxpbmcgPSBuZXh0UHJvcHMpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgICAoc2hvd0ZhbGxiYWNrID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpKSxcbiAgICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSksXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUiksXG4gICAgICAgIG5leHRQcm9wc1xuICAgICAgKTtcbiAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0SW5zdGFuY2UpO1xuICB9XG4gIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKFxuICAgIG51bGwgIT09IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCAmJlxuICAgICgobmV4dEluc3RhbmNlID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLmRlaHlkcmF0ZWQpLFxuICAgIG51bGwgIT09IG5leHRJbnN0YW5jZSlcbiAgKSB7XG4gICAgaWYgKGRpZFN1c3BlbmQpXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDI1NlxuICAgICAgICA/IChwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSAtMjU3KSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKSkpXG4gICAgICAgIDogbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gKHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkKSxcbiAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMjgpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gbnVsbCkpXG4gICAgICAgICAgOiAocmV1c2VTdXNwZW5zZUhhbmRsZXJPblN0YWNrKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIChzaG93RmFsbGJhY2sgPSBuZXh0UHJvcHMuZmFsbGJhY2spLFxuICAgICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLm1vZGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICAgICAgICAgICAgeyBtb2RlOiBcInZpc2libGVcIiwgY2hpbGRyZW46IG5leHRQcm9wcy5jaGlsZHJlbiB9LFxuICAgICAgICAgICAgICBuZXh0SW5zdGFuY2VcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjayA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KFxuICAgICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICAgIG5leHRJbnN0YW5jZSxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5mbGFncyB8PSAyKSxcbiAgICAgICAgICAgIChuZXh0UHJvcHMucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHNob3dGYWxsYmFjay5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgICAgICAgIHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgY3VycmVudC5jaGlsZCxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICAobmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpLFxuICAgICAgICAgICAgKG5leHRQcm9wcy5tZW1vaXplZFN0YXRlID1cbiAgICAgICAgICAgICAgbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAobmV4dFByb3BzLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVIpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gc2hvd0ZhbGxiYWNrKSk7XG4gICAgZWxzZSBpZiAoXG4gICAgICAocHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSxcbiAgICAgIFwiJCFcIiA9PT0gbmV4dEluc3RhbmNlLmRhdGEpXG4gICAgKSB7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPVxuICAgICAgICBuZXh0SW5zdGFuY2UubmV4dFNpYmxpbmcgJiYgbmV4dEluc3RhbmNlLm5leHRTaWJsaW5nLmRhdGFzZXQ7XG4gICAgICBpZiAoSlNDb21waWxlcl90ZW1wKSB2YXIgZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wLmRnc3Q7XG4gICAgICBKU0NvbXBpbGVyX3RlbXAgPSBkaWdlc3Q7XG4gICAgICBuZXh0UHJvcHMgPSBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQxOSkpO1xuICAgICAgbmV4dFByb3BzLnN0YWNrID0gXCJcIjtcbiAgICAgIG5leHRQcm9wcy5kaWdlc3QgPSBKU0NvbXBpbGVyX3RlbXA7XG4gICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHsgdmFsdWU6IG5leHRQcm9wcywgc291cmNlOiBudWxsLCBzdGFjazogbnVsbCB9KTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKGRpZFJlY2VpdmVVcGRhdGUgfHxcbiAgICAgICAgcHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzLCAhMSksXG4gICAgICAoSlNDb21waWxlcl90ZW1wID0gMCAhPT0gKHJlbmRlckxhbmVzICYgY3VycmVudC5jaGlsZExhbmVzKSksXG4gICAgICBkaWRSZWNlaXZlVXBkYXRlIHx8IEpTQ29tcGlsZXJfdGVtcClcbiAgICApIHtcbiAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzUm9vdDtcbiAgICAgIGlmIChudWxsICE9PSBKU0NvbXBpbGVyX3RlbXApIHtcbiAgICAgICAgbmV4dFByb3BzID0gcmVuZGVyTGFuZXMgJiAtcmVuZGVyTGFuZXM7XG4gICAgICAgIGlmICgwICE9PSAobmV4dFByb3BzICYgNDIpKSBuZXh0UHJvcHMgPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3dpdGNoIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAgICBjYXNlIDI1NjpcbiAgICAgICAgICAgIGNhc2UgNTEyOlxuICAgICAgICAgICAgY2FzZSAxMDI0OlxuICAgICAgICAgICAgY2FzZSAyMDQ4OlxuICAgICAgICAgICAgY2FzZSA0MDk2OlxuICAgICAgICAgICAgY2FzZSA4MTkyOlxuICAgICAgICAgICAgY2FzZSAxNjM4NDpcbiAgICAgICAgICAgIGNhc2UgMzI3Njg6XG4gICAgICAgICAgICBjYXNlIDY1NTM2OlxuICAgICAgICAgICAgY2FzZSAxMzEwNzI6XG4gICAgICAgICAgICBjYXNlIDI2MjE0NDpcbiAgICAgICAgICAgIGNhc2UgNTI0Mjg4OlxuICAgICAgICAgICAgY2FzZSAxMDQ4NTc2OlxuICAgICAgICAgICAgY2FzZSAyMDk3MTUyOlxuICAgICAgICAgICAgY2FzZSA0MTk0MzA0OlxuICAgICAgICAgICAgY2FzZSA4Mzg4NjA4OlxuICAgICAgICAgICAgY2FzZSAxNjc3NzIxNjpcbiAgICAgICAgICAgIGNhc2UgMzM1NTQ0MzI6XG4gICAgICAgICAgICAgIG5leHRQcm9wcyA9IDY0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICAgICAgICBuZXh0UHJvcHMgPSAxMzQyMTc3Mjg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbmV4dFByb3BzID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIG5leHRQcm9wcyA9XG4gICAgICAgICAgMCAhPT0gKG5leHRQcm9wcyAmIChKU0NvbXBpbGVyX3RlbXAuc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpXG4gICAgICAgICAgICA/IDBcbiAgICAgICAgICAgIDogbmV4dFByb3BzO1xuICAgICAgICBpZiAoMCAhPT0gbmV4dFByb3BzICYmIG5leHRQcm9wcyAhPT0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnJldHJ5TGFuZSlcbiAgICAgICAgICB0aHJvdyAoXG4gICAgICAgICAgICAoKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5yZXRyeUxhbmUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGN1cnJlbnQsIG5leHRQcm9wcyksXG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoSlNDb21waWxlcl90ZW1wLCBjdXJyZW50LCBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uKVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICBcIiQ/XCIgPT09IG5leHRJbnN0YW5jZS5kYXRhIHx8IHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICB9IGVsc2VcbiAgICAgIFwiJD9cIiA9PT0gbmV4dEluc3RhbmNlLmRhdGFcbiAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZCksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgICApKSxcbiAgICAgICAgICAobmV4dEluc3RhbmNlLl9yZWFjdFJldHJ5ID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpKVxuICAgICAgICA6ICgoY3VycmVudCA9IEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC50cmVlQ29udGV4dCksXG4gICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgIG5leHRJbnN0YW5jZS5uZXh0U2libGluZ1xuICAgICAgICAgICkpLFxuICAgICAgICAgIChoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAoaXNIeWRyYXRpbmcgPSAhMCksXG4gICAgICAgICAgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpLFxuICAgICAgICAgIChyb290T3JTaW5nbGV0b25Db250ZXh0ID0gITEpLFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAgICAgICAgICgoaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkKSxcbiAgICAgICAgICAgIChpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3cpLFxuICAgICAgICAgICAgKGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlciksXG4gICAgICAgICAgICAodHJlZUNvbnRleHRJZCA9IGN1cnJlbnQuaWQpLFxuICAgICAgICAgICAgKHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBjdXJyZW50Lm92ZXJmbG93KSxcbiAgICAgICAgICAgICh0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3MpKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICBuZXh0UHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICApKSxcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDA5NikpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBpZiAoc2hvd0ZhbGxiYWNrKVxuICAgIHJldHVybiAoXG4gICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgKHNob3dGYWxsYmFjayA9IG5leHRQcm9wcy5mYWxsYmFjayksXG4gICAgICAobmV4dEluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3MubW9kZSksXG4gICAgICAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gY3VycmVudC5jaGlsZCksXG4gICAgICAoZGlnZXN0ID0gSlNDb21waWxlcl90ZW1wJGpzY29tcCQwLnNpYmxpbmcpLFxuICAgICAgKG5leHRQcm9wcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMCwge1xuICAgICAgICBtb2RlOiBcImhpZGRlblwiLFxuICAgICAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gICAgICB9KSksXG4gICAgICAobmV4dFByb3BzLnN1YnRyZWVGbGFncyA9XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5zdWJ0cmVlRmxhZ3MgJiAzMTQ1NzI4MCksXG4gICAgICBudWxsICE9PSBkaWdlc3RcbiAgICAgICAgPyAoc2hvd0ZhbGxiYWNrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZGlnZXN0LCBzaG93RmFsbGJhY2spKVxuICAgICAgICA6ICgoc2hvd0ZhbGxiYWNrID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoXG4gICAgICAgICAgICBzaG93RmFsbGJhY2ssXG4gICAgICAgICAgICBuZXh0SW5zdGFuY2UsXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApKSxcbiAgICAgICAgICAoc2hvd0ZhbGxiYWNrLmZsYWdzIHw9IDIpKSxcbiAgICAgIChzaG93RmFsbGJhY2sucmV0dXJuID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgKG5leHRQcm9wcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAobmV4dFByb3BzLnNpYmxpbmcgPSBzaG93RmFsbGJhY2spLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV4dFByb3BzKSxcbiAgICAgIChuZXh0UHJvcHMgPSBzaG93RmFsbGJhY2spLFxuICAgICAgKHNob3dGYWxsYmFjayA9IHdvcmtJblByb2dyZXNzLmNoaWxkKSxcbiAgICAgIChuZXh0SW5zdGFuY2UgPSBjdXJyZW50LmNoaWxkLm1lbW9pemVkU3RhdGUpLFxuICAgICAgbnVsbCA9PT0gbmV4dEluc3RhbmNlXG4gICAgICAgID8gKG5leHRJbnN0YW5jZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykpXG4gICAgICAgIDogKChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPSBuZXh0SW5zdGFuY2UuY2FjaGVQb29sKSxcbiAgICAgICAgICBudWxsICE9PSBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICAgID8gKChkaWdlc3QgPSBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX3RlbXAkanNjb21wJDAgPVxuICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCRqc2NvbXAkMC5wYXJlbnQgIT09IGRpZ2VzdFxuICAgICAgICAgICAgICAgICAgPyB7IHBhcmVudDogZGlnZXN0LCBwb29sOiBkaWdlc3QgfVxuICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDApKVxuICAgICAgICAgICAgOiAoSlNDb21waWxlcl90ZW1wJGpzY29tcCQwID0gZ2V0U3VzcGVuZGVkQ2FjaGUoKSksXG4gICAgICAgICAgKG5leHRJbnN0YW5jZSA9IHtcbiAgICAgICAgICAgIGJhc2VMYW5lczogbmV4dEluc3RhbmNlLmJhc2VMYW5lcyB8IHJlbmRlckxhbmVzLFxuICAgICAgICAgICAgY2FjaGVQb29sOiBKU0NvbXBpbGVyX3RlbXAkanNjb21wJDBcbiAgICAgICAgICB9KSksXG4gICAgICAoc2hvd0ZhbGxiYWNrLm1lbW9pemVkU3RhdGUgPSBuZXh0SW5zdGFuY2UpLFxuICAgICAgKHNob3dGYWxsYmFjay5jaGlsZExhbmVzID0gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICkpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBTVVNQRU5ERURfTUFSS0VSKSxcbiAgICAgIG5leHRQcm9wc1xuICAgICk7XG4gIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlbmRlckxhbmVzID0gY3VycmVudC5jaGlsZDtcbiAgY3VycmVudCA9IHJlbmRlckxhbmVzLnNpYmxpbmc7XG4gIHJlbmRlckxhbmVzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIHtcbiAgICBtb2RlOiBcInZpc2libGVcIixcbiAgICBjaGlsZHJlbjogbmV4dFByb3BzLmNoaWxkcmVuXG4gIH0pO1xuICByZW5kZXJMYW5lcy5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcmVuZGVyTGFuZXMuc2libGluZyA9IG51bGw7XG4gIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICAoKEpTQ29tcGlsZXJfdGVtcCA9IHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyksXG4gICAgbnVsbCA9PT0gSlNDb21waWxlcl90ZW1wXG4gICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRdKSwgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2KSlcbiAgICAgIDogSlNDb21waWxlcl90ZW1wLnB1c2goY3VycmVudCkpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlckxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHJlbmRlckxhbmVzO1xufVxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKSB7XG4gIHByaW1hcnlDaGlsZHJlbiA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihcbiAgICB7IG1vZGU6IFwidmlzaWJsZVwiLCBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuIH0sXG4gICAgd29ya0luUHJvZ3Jlc3MubW9kZVxuICApO1xuICBwcmltYXJ5Q2hpbGRyZW4ucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlKSB7XG4gIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ob2Zmc2NyZWVuUHJvcHMsIG1vZGUsIDAsIG51bGwpO1xufVxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gIGN1cnJlbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKFxuICAgIHdvcmtJblByb2dyZXNzLFxuICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlblxuICApO1xuICBjdXJyZW50LmZsYWdzIHw9IDI7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUubGFuZXMgfD0gcmVuZGVyTGFuZXMpO1xuICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCk7XG59XG5mdW5jdGlvbiBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gIHdvcmtJblByb2dyZXNzLFxuICBpc0JhY2t3YXJkcyxcbiAgdGFpbCxcbiAgbGFzdENvbnRlbnRSb3csXG4gIHRhaWxNb2RlXG4pIHtcbiAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgbnVsbCA9PT0gcmVuZGVyU3RhdGVcbiAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0ge1xuICAgICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgICAgcmVuZGVyaW5nU3RhcnRUaW1lOiAwLFxuICAgICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgICAgdGFpbDogdGFpbCxcbiAgICAgICAgdGFpbE1vZGU6IHRhaWxNb2RlXG4gICAgICB9KVxuICAgIDogKChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzKSxcbiAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsKSxcbiAgICAgIChyZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwKSxcbiAgICAgIChyZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3cpLFxuICAgICAgKHJlbmRlclN0YXRlLnRhaWwgPSB0YWlsKSxcbiAgICAgIChyZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgcmV2ZWFsT3JkZXIgPSBuZXh0UHJvcHMucmV2ZWFsT3JkZXIsXG4gICAgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcy5jaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICBuZXh0UHJvcHMgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIGlmICgwICE9PSAobmV4dFByb3BzICYgMikpXG4gICAgKG5leHRQcm9wcyA9IChuZXh0UHJvcHMgJiAxKSB8IDIpLCAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KTtcbiAgZWxzZSB7XG4gICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgMCAhPT0gKGN1cnJlbnQuZmxhZ3MgJiAxMjgpKVxuICAgICAgYTogZm9yIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7IG51bGwgIT09IGN1cnJlbnQ7ICkge1xuICAgICAgICBpZiAoMTMgPT09IGN1cnJlbnQudGFnKVxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKGN1cnJlbnQsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGVsc2UgaWYgKDE5ID09PSBjdXJyZW50LnRhZylcbiAgICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoY3VycmVudCwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgZWxzZSBpZiAobnVsbCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgICAgIGN1cnJlbnQuY2hpbGQucmV0dXJuID0gY3VycmVudDtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudCA9PT0gd29ya0luUHJvZ3Jlc3MpIGJyZWFrIGE7XG4gICAgICAgIGZvciAoOyBudWxsID09PSBjdXJyZW50LnNpYmxpbmc7ICkge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50LnJldHVybiB8fCBjdXJyZW50LnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LnNpYmxpbmcucmV0dXJuID0gY3VycmVudC5yZXR1cm47XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnNpYmxpbmc7XG4gICAgICB9XG4gICAgbmV4dFByb3BzICY9IDE7XG4gIH1cbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXh0UHJvcHMpO1xuICBzd2l0Y2ggKHJldmVhbE9yZGVyKSB7XG4gICAgY2FzZSBcImZvcndhcmRzXCI6XG4gICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgZm9yIChyZXZlYWxPcmRlciA9IG51bGw7IG51bGwgIT09IHJlbmRlckxhbmVzOyApXG4gICAgICAgIChjdXJyZW50ID0gcmVuZGVyTGFuZXMuYWx0ZXJuYXRlKSxcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgICBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkgJiZcbiAgICAgICAgICAgIChyZXZlYWxPcmRlciA9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICBudWxsID09PSByZW5kZXJMYW5lc1xuICAgICAgICA/ICgocmV2ZWFsT3JkZXIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpKVxuICAgICAgICA6ICgocmV2ZWFsT3JkZXIgPSByZW5kZXJMYW5lcy5zaWJsaW5nKSwgKHJlbmRlckxhbmVzLnNpYmxpbmcgPSBudWxsKSk7XG4gICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAhMSxcbiAgICAgICAgcmV2ZWFsT3JkZXIsXG4gICAgICAgIHJlbmRlckxhbmVzLFxuICAgICAgICB0YWlsTW9kZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJiYWNrd2FyZHNcIjpcbiAgICAgIHJlbmRlckxhbmVzID0gbnVsbDtcbiAgICAgIHJldmVhbE9yZGVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBmb3IgKHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDsgbnVsbCAhPT0gcmV2ZWFsT3JkZXI7ICkge1xuICAgICAgICBjdXJyZW50ID0gcmV2ZWFsT3JkZXIuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsID09PSBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudCkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJldmVhbE9yZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSByZXZlYWxPcmRlci5zaWJsaW5nO1xuICAgICAgICByZXZlYWxPcmRlci5zaWJsaW5nID0gcmVuZGVyTGFuZXM7XG4gICAgICAgIHJlbmRlckxhbmVzID0gcmV2ZWFsT3JkZXI7XG4gICAgICAgIHJldmVhbE9yZGVyID0gY3VycmVudDtcbiAgICAgIH1cbiAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZShcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICEwLFxuICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgdGFpbE1vZGVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidG9nZXRoZXJcIjpcbiAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgITEsIG51bGwsIG51bGwsIHZvaWQgMCk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgbnVsbCAhPT0gY3VycmVudCAmJiAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgfD0gd29ya0luUHJvZ3Jlc3MubGFuZXM7XG4gIGlmICgwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICBpZiAobnVsbCAhPT0gY3VycmVudCkge1xuICAgICAgaWYgKFxuICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAhMVxuICAgICAgICApLFxuICAgICAgICAwID09PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSlcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHJldHVybiBudWxsO1xuICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZClcbiAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1MykpO1xuICBpZiAobnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgcmVuZGVyTGFuZXMgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBjdXJyZW50LnBlbmRpbmdQcm9wcyk7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZW5kZXJMYW5lcztcbiAgICBmb3IgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzOyBudWxsICE9PSBjdXJyZW50LnNpYmxpbmc7IClcbiAgICAgIChjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nKSxcbiAgICAgICAgKHJlbmRlckxhbmVzID0gcmVuZGVyTGFuZXMuc2libGluZyA9XG4gICAgICAgICAgY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgY3VycmVudC5wZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgKHJlbmRlckxhbmVzLnJldHVybiA9IHdvcmtJblByb2dyZXNzKTtcbiAgICByZW5kZXJMYW5lcy5zaWJsaW5nID0gbnVsbDtcbiAgfVxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5mdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICBpZiAoMCAhPT0gKGN1cnJlbnQubGFuZXMgJiByZW5kZXJMYW5lcykpIHJldHVybiAhMDtcbiAgY3VycmVudCA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICByZXR1cm4gbnVsbCAhPT0gY3VycmVudCAmJiBjaGVja0lmQ29udGV4dENoYW5nZWQoY3VycmVudCkgPyAhMCA6ICExO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoXG4gIGN1cnJlbnQsXG4gIHdvcmtJblByb2dyZXNzLFxuICByZW5kZXJMYW5lc1xuKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSAzOlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgICBwdXNoUHJvdmlkZXIoXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLnZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCAhPT0gc3RhdGUpIHtcbiAgICAgICAgaWYgKG51bGwgIT09IHN0YXRlLmRlaHlkcmF0ZWQpXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGRMYW5lcykpXG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGN1cnJlbnQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LnNpYmxpbmcgOiBudWxsO1xuICAgICAgfVxuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTk6XG4gICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KTtcbiAgICAgIHN0YXRlID0gMCAhPT0gKHJlbmRlckxhbmVzICYgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG4gICAgICBzdGF0ZSB8fFxuICAgICAgICAocHJvcGFnYXRlUGFyZW50Q29udGV4dENoYW5nZXMoXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAhMVxuICAgICAgICApLFxuICAgICAgICAoc3RhdGUgPSAwICE9PSAocmVuZGVyTGFuZXMgJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkpO1xuICAgICAgaWYgKGRpZFN1c3BlbmRCZWZvcmUpIHtcbiAgICAgICAgaWYgKHN0YXRlKVxuICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoXG4gICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgIH1cbiAgICAgIGRpZFN1c3BlbmRCZWZvcmUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgbnVsbCAhPT0gZGlkU3VzcGVuZEJlZm9yZSAmJlxuICAgICAgICAoKGRpZFN1c3BlbmRCZWZvcmUucmVuZGVyaW5nID0gbnVsbCksXG4gICAgICAgIChkaWRTdXNwZW5kQmVmb3JlLnRhaWwgPSBudWxsKSxcbiAgICAgICAgKGRpZFN1c3BlbmRCZWZvcmUubGFzdEVmZmVjdCA9IG51bGwpKTtcbiAgICAgIHB1c2goc3VzcGVuc2VTdGFja0N1cnNvciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICAgIGlmIChzdGF0ZSkgYnJlYWs7XG4gICAgICBlbHNlIHJldHVybiBudWxsO1xuICAgIGNhc2UgMjI6XG4gICAgY2FzZSAyMzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IDApLFxuICAgICAgICB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKVxuICAgICAgKTtcbiAgICBjYXNlIDI0OlxuICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gIH1cbiAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbn1cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKG51bGwgIT09IGN1cnJlbnQpXG4gICAgaWYgKGN1cnJlbnQubWVtb2l6ZWRQcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKVxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9ICEwO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKFxuICAgICAgICAhY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpICYmXG4gICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDEyOClcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoZGlkUmVjZWl2ZVVwZGF0ZSA9ICExKSxcbiAgICAgICAgICBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShcbiAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IDAgIT09IChjdXJyZW50LmZsYWdzICYgMTMxMDcyKSA/ICEwIDogITE7XG4gICAgfVxuICBlbHNlXG4gICAgKGRpZFJlY2VpdmVVcGRhdGUgPSAhMSksXG4gICAgICBpc0h5ZHJhdGluZyAmJlxuICAgICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMDQ4NTc2KSAmJlxuICAgICAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCB0cmVlRm9ya0NvdW50LCB3b3JrSW5Qcm9ncmVzcy5pbmRleCk7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gMDtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIDE2OlxuICAgICAgYToge1xuICAgICAgICBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlLFxuICAgICAgICAgIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICBsYXp5Q29tcG9uZW50ID0gaW5pdChsYXp5Q29tcG9uZW50Ll9wYXlsb2FkKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGxhenlDb21wb25lbnQ7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBsYXp5Q29tcG9uZW50KVxuICAgICAgICAgIHNob3VsZENvbnN0cnVjdChsYXp5Q29tcG9uZW50KVxuICAgICAgICAgICAgPyAoKGN1cnJlbnQgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhsYXp5Q29tcG9uZW50LCBjdXJyZW50KSksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy50YWcgPSAxKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzID0gdXBkYXRlQ2xhc3NDb21wb25lbnQoXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgKSkpXG4gICAgICAgICAgICA6ICgod29ya0luUHJvZ3Jlc3MudGFnID0gMCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICkpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gbGF6eUNvbXBvbmVudCAmJiBudWxsICE9PSBsYXp5Q29tcG9uZW50KVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKGluaXQgPSBsYXp5Q29tcG9uZW50LiQkdHlwZW9mKSwgaW5pdCA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxMTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVGb3J3YXJkUmVmKFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluaXQgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSAxNDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGVNZW1vQ29tcG9uZW50KFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgICAgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGxhenlDb21wb25lbnQpIHx8IGxhenlDb21wb25lbnQ7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMDYsIHdvcmtJblByb2dyZXNzLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZSksXG4gICAgICAgIChpbml0ID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHNcbiAgICAgICAgKSksXG4gICAgICAgIHVwZGF0ZUNsYXNzQ29tcG9uZW50KFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICBpbml0LFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgY2FzZSAzOlxuICAgICAgYToge1xuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICApO1xuICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzODcpKTtcbiAgICAgICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgaW5pdCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGxhenlDb21wb25lbnQgPSBpbml0LmVsZW1lbnQ7XG4gICAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmNhY2hlO1xuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgbmV4dFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzICE9PSBpbml0LmNhY2hlICYmXG4gICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgcmVuZGVyTGFuZXMsXG4gICAgICAgICAgICAhMFxuICAgICAgICAgICk7XG4gICAgICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICAgICAgbmV4dFByb3BzID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gICAgICAgIGlmIChpbml0LmlzRGVoeWRyYXRlZClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGluaXQgPSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgaXNEZWh5ZHJhdGVkOiAhMSxcbiAgICAgICAgICAgICAgY2FjaGU6IG5leHRTdGF0ZS5jYWNoZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuYmFzZVN0YXRlID0gaW5pdCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluaXQpLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0UHJvcHMgIT09IGxhenlDb21wb25lbnQpIHtcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihcbiAgICAgICAgICAgICAgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0MjQpKSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGxhenlDb21wb25lbnQpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgICAgICAgIGlzSHlkcmF0aW5nID0gITAsXG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbCxcbiAgICAgICAgICAgICAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gITAsXG4gICAgICAgICAgICAgICAgcmVuZGVyTGFuZXMgPSBtb3VudENoaWxkRmliZXJzKFxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzO1xuXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIChyZW5kZXJMYW5lcy5mbGFncyA9IChyZW5kZXJMYW5lcy5mbGFncyAmIC0zKSB8IDQwOTYpLFxuICAgICAgICAgICAgICAgIChyZW5kZXJMYW5lcyA9IHJlbmRlckxhbmVzLnNpYmxpbmcpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbGF6eUNvbXBvbmVudCkge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKFxuICAgICAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICBjYXNlIDI2OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/IChyZW5kZXJMYW5lcyA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gcmVuZGVyTGFuZXMpXG4gICAgICAgICAgICA6IGlzSHlkcmF0aW5nIHx8XG4gICAgICAgICAgICAgICgocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy50eXBlKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICAgICAgICAobGF6eUNvbXBvbmVudCA9IGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihcbiAgICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICAgICkuY3JlYXRlRWxlbWVudChyZW5kZXJMYW5lcykpLFxuICAgICAgICAgICAgICAobGF6eUNvbXBvbmVudFtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKGxhenlDb21wb25lbnRbaW50ZXJuYWxQcm9wc0tleV0gPSBjdXJyZW50KSxcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMobGF6eUNvbXBvbmVudCwgcmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGxhenlDb21wb25lbnQpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbGF6eUNvbXBvbmVudCkpXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldFJlc291cmNlKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgICApKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI3OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgIGlzSHlkcmF0aW5nICYmXG4gICAgICAgICAgKChsYXp5Q29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID1cbiAgICAgICAgICAgIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAoaHlkcmF0aW9uUGFyZW50RmliZXIgPSB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgKHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSAhMCksXG4gICAgICAgICAgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZShcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQuZmlyc3RDaGlsZFxuICAgICAgICAgICkpKSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50IHx8IGlzSHlkcmF0aW5nXG4gICAgICAgICAgPyByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyhcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgNTpcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50ICYmIGlzSHlkcmF0aW5nKSB7XG4gICAgICAgIGlmICgoaW5pdCA9IGxhenlDb21wb25lbnQgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKSlcbiAgICAgICAgICAobGF6eUNvbXBvbmVudCA9IGNhbkh5ZHJhdGVJbnN0YW5jZShcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dFxuICAgICAgICAgICkpLFxuICAgICAgICAgICAgbnVsbCAhPT0gbGF6eUNvbXBvbmVudFxuICAgICAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbGF6eUNvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGUoXG4gICAgICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50LmZpcnN0Q2hpbGRcbiAgICAgICAgICAgICAgICApKSxcbiAgICAgICAgICAgICAgICAocm9vdE9yU2luZ2xldG9uQ29udGV4dCA9ICExKSxcbiAgICAgICAgICAgICAgICAoaW5pdCA9ICEwKSlcbiAgICAgICAgICAgICAgOiAoaW5pdCA9ICExKTtcbiAgICAgICAgaW5pdCB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGluaXQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgbmV4dFN0YXRlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG4gICAgICBsYXp5Q29tcG9uZW50ID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgc2hvdWxkU2V0VGV4dENvbnRlbnQoaW5pdCwgbmV4dFByb3BzKVxuICAgICAgICA/IChsYXp5Q29tcG9uZW50ID0gbnVsbClcbiAgICAgICAgOiBudWxsICE9PSBuZXh0U3RhdGUgJiZcbiAgICAgICAgICBzaG91bGRTZXRUZXh0Q29udGVudChpbml0LCBuZXh0U3RhdGUpICYmXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDMyKTtcbiAgICAgIG51bGwgIT09IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgKChpbml0ID0gcmVuZGVyV2l0aEhvb2tzKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSksXG4gICAgICAgIChIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IGluaXQpKTtcbiAgICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhenlDb21wb25lbnQsIHJlbmRlckxhbmVzKTtcbiAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICBjYXNlIDY6XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCAmJiBpc0h5ZHJhdGluZykge1xuICAgICAgICBpZiAoKGN1cnJlbnQgPSByZW5kZXJMYW5lcyA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpKVxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UoXG4gICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHRcbiAgICAgICAgICApKSxcbiAgICAgICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSByZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgICAgKGh5ZHJhdGlvblBhcmVudEZpYmVyID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICAgIChuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbCksXG4gICAgICAgICAgICAgICAgKGN1cnJlbnQgPSAhMCkpXG4gICAgICAgICAgICAgIDogKGN1cnJlbnQgPSAhMSk7XG4gICAgICAgIGN1cnJlbnQgfHwgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgMTM6XG4gICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcihcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mb1xuICAgICAgICApLFxuICAgICAgICAobGF6eUNvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyksXG4gICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICA/ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgICAgICkpXG4gICAgICAgICAgOiByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgIGxhenlDb21wb25lbnQsXG4gICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICApLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDExOlxuICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsXG4gICAgICAgIHJlbmRlckxhbmVzXG4gICAgICApO1xuICAgIGNhc2UgNzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgODpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuLFxuICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgMTI6XG4gICAgICByZXR1cm4gKFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbixcbiAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICApLFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZFxuICAgICAgKTtcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpLFxuICAgICAgICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIGxhenlDb21wb25lbnQudmFsdWUpLFxuICAgICAgICByZWNvbmNpbGVDaGlsZHJlbihcbiAgICAgICAgICBjdXJyZW50LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIGxhenlDb21wb25lbnQuY2hpbGRyZW4sXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICk7XG4gICAgY2FzZSA5OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGluaXQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlLl9jb250ZXh0KSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4pLFxuICAgICAgICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIChpbml0ID0gcmVhZENvbnRleHQoaW5pdCkpLFxuICAgICAgICAobGF6eUNvbXBvbmVudCA9IGxhenlDb21wb25lbnQoaW5pdCkpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMSksXG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBsYXp5Q29tcG9uZW50LCByZW5kZXJMYW5lcyksXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkXG4gICAgICApO1xuICAgIGNhc2UgMTQ6XG4gICAgICByZXR1cm4gdXBkYXRlTWVtb0NvbXBvbmVudChcbiAgICAgICAgY3VycmVudCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUsXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyxcbiAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgY2FzZSAxNTpcbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLFxuICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgKTtcbiAgICBjYXNlIDE5OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIGNhc2UgMjI6XG4gICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgY2FzZSAyNDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKGxhenlDb21wb25lbnQgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudFxuICAgICAgICAgID8gKChpbml0ID0gcGVla0NhY2hlRnJvbVBvb2woKSksXG4gICAgICAgICAgICBudWxsID09PSBpbml0ICYmXG4gICAgICAgICAgICAgICgoaW5pdCA9IHdvcmtJblByb2dyZXNzUm9vdCksXG4gICAgICAgICAgICAgIChuZXh0UHJvcHMgPSBjcmVhdGVDYWNoZSgpKSxcbiAgICAgICAgICAgICAgKGluaXQucG9vbGVkQ2FjaGUgPSBuZXh0UHJvcHMpLFxuICAgICAgICAgICAgICBuZXh0UHJvcHMucmVmQ291bnQrKyxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gbmV4dFByb3BzICYmIChpbml0LnBvb2xlZENhY2hlTGFuZXMgfD0gcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICAoaW5pdCA9IG5leHRQcm9wcykpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICAgICAgICAgIHBhcmVudDogbGF6eUNvbXBvbmVudCxcbiAgICAgICAgICAgICAgY2FjaGU6IGluaXRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBpbml0KSlcbiAgICAgICAgICA6ICgwICE9PSAoY3VycmVudC5sYW5lcyAmIHJlbmRlckxhbmVzKSAmJlxuICAgICAgICAgICAgICAoY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpLFxuICAgICAgICAgICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkpLFxuICAgICAgICAgICAgKGluaXQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgKG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICAgICAgaW5pdC5wYXJlbnQgIT09IGxhenlDb21wb25lbnRcbiAgICAgICAgICAgICAgPyAoKGluaXQgPSB7IHBhcmVudDogbGF6eUNvbXBvbmVudCwgY2FjaGU6IGxhenlDb21wb25lbnQgfSksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbml0KSxcbiAgICAgICAgICAgICAgICAwID09PSB3b3JrSW5Qcm9ncmVzcy5sYW5lcyAmJlxuICAgICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPVxuICAgICAgICAgICAgICAgICAgICAgIGluaXQpLFxuICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBsYXp5Q29tcG9uZW50KSlcbiAgICAgICAgICAgICAgOiAoKGxhenlDb21wb25lbnQgPSBuZXh0UHJvcHMuY2FjaGUpLFxuICAgICAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCBsYXp5Q29tcG9uZW50KSxcbiAgICAgICAgICAgICAgICBsYXp5Q29tcG9uZW50ICE9PSBpbml0LmNhY2hlICYmXG4gICAgICAgICAgICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICAgICAgICAgIFtDYWNoZUNvbnRleHRdLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgICAgICAgICkpKSxcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgcmVuZGVyTGFuZXNcbiAgICAgICAgKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRcbiAgICAgICk7XG4gICAgY2FzZSAyOTpcbiAgICAgIHRocm93IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgfVxuICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1Niwgd29ya0luUHJvZ3Jlc3MudGFnKSk7XG59XG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCksXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbCxcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlKTtcbiAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCkge1xuICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSB2YWx1ZUN1cnNvci5jdXJyZW50O1xuICBwb3AodmFsdWVDdXJzb3IpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgZm9yICg7IG51bGwgIT09IHBhcmVudDsgKSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG4gICAgKHBhcmVudC5jaGlsZExhbmVzICYgcmVuZGVyTGFuZXMpICE9PSByZW5kZXJMYW5lc1xuICAgICAgPyAoKHBhcmVudC5jaGlsZExhbmVzIHw9IHJlbmRlckxhbmVzKSxcbiAgICAgICAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcykpXG4gICAgICA6IG51bGwgIT09IGFsdGVybmF0ZSAmJlxuICAgICAgICAoYWx0ZXJuYXRlLmNoaWxkTGFuZXMgJiByZW5kZXJMYW5lcykgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgIChhbHRlcm5hdGUuY2hpbGRMYW5lcyB8PSByZW5kZXJMYW5lcyk7XG4gICAgaWYgKHBhcmVudCA9PT0gcHJvcGFnYXRpb25Sb290KSBicmVhaztcbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlcyhcbiAgd29ya0luUHJvZ3Jlc3MsXG4gIGNvbnRleHRzLFxuICByZW5kZXJMYW5lcyxcbiAgZm9yY2VQcm9wYWdhdGVFbnRpcmVUcmVlXG4pIHtcbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIG51bGwgIT09IGZpYmVyICYmIChmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcyk7XG4gIGZvciAoOyBudWxsICE9PSBmaWJlcjsgKSB7XG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG4gICAgaWYgKG51bGwgIT09IGxpc3QpIHtcbiAgICAgIHZhciBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICAgIGxpc3QgPSBsaXN0LmZpcnN0Q29udGV4dDtcbiAgICAgIGE6IGZvciAoOyBudWxsICE9PSBsaXN0OyApIHtcbiAgICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0O1xuICAgICAgICBsaXN0ID0gZmliZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dHNbaV0pIHtcbiAgICAgICAgICAgIGxpc3QubGFuZXMgfD0gcmVuZGVyTGFuZXM7XG4gICAgICAgICAgICBkZXBlbmRlbmN5ID0gbGlzdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBudWxsICE9PSBkZXBlbmRlbmN5ICYmIChkZXBlbmRlbmN5LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoXG4gICAgICAgICAgICAgIGxpc3QucmV0dXJuLFxuICAgICAgICAgICAgICByZW5kZXJMYW5lcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3JjZVByb3BhZ2F0ZUVudGlyZVRyZWUgfHwgKG5leHRGaWJlciA9IG51bGwpO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgIGxpc3QgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgxOCA9PT0gZmliZXIudGFnKSB7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgICBpZiAobnVsbCA9PT0gbmV4dEZpYmVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0MSkpO1xuICAgICAgbmV4dEZpYmVyLmxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICAgICAgbGlzdCA9IG5leHRGaWJlci5hbHRlcm5hdGU7XG4gICAgICBudWxsICE9PSBsaXN0ICYmIChsaXN0LmxhbmVzIHw9IHJlbmRlckxhbmVzKTtcbiAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgobmV4dEZpYmVyLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICB9IGVsc2UgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgaWYgKG51bGwgIT09IG5leHRGaWJlcikgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIGVsc2VcbiAgICAgIGZvciAobmV4dEZpYmVyID0gZmliZXI7IG51bGwgIT09IG5leHRGaWJlcjsgKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmaWJlciA9IG5leHRGaWJlci5zaWJsaW5nO1xuICAgICAgICBpZiAobnVsbCAhPT0gZmliZXIpIHtcbiAgICAgICAgICBmaWJlci5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRGaWJlciA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICB9XG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZVBhcmVudENvbnRleHRDaGFuZ2VzKFxuICBjdXJyZW50LFxuICB3b3JrSW5Qcm9ncmVzcyxcbiAgcmVuZGVyTGFuZXMsXG4gIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuKSB7XG4gIGN1cnJlbnQgPSBudWxsO1xuICBmb3IgKFxuICAgIHZhciBwYXJlbnQgPSB3b3JrSW5Qcm9ncmVzcywgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMTtcbiAgICBudWxsICE9PSBwYXJlbnQ7XG5cbiAgKSB7XG4gICAgaWYgKCFpc0luc2lkZVByb3BhZ2F0aW9uQmFpbG91dClcbiAgICAgIGlmICgwICE9PSAocGFyZW50LmZsYWdzICYgNTI0Mjg4KSkgaXNJbnNpZGVQcm9wYWdhdGlvbkJhaWxvdXQgPSAhMDtcbiAgICAgIGVsc2UgaWYgKDAgIT09IChwYXJlbnQuZmxhZ3MgJiAyNjIxNDQpKSBicmVhaztcbiAgICBpZiAoMTAgPT09IHBhcmVudC50YWcpIHtcbiAgICAgIHZhciBjdXJyZW50UGFyZW50ID0gcGFyZW50LmFsdGVybmF0ZTtcbiAgICAgIGlmIChudWxsID09PSBjdXJyZW50UGFyZW50KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM4NykpO1xuICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRQYXJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gcGFyZW50LnR5cGU7XG4gICAgICAgIG9iamVjdElzKHBhcmVudC5wZW5kaW5nUHJvcHMudmFsdWUsIGN1cnJlbnRQYXJlbnQudmFsdWUpIHx8XG4gICAgICAgICAgKG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50LnB1c2goY29udGV4dCkgOiAoY3VycmVudCA9IFtjb250ZXh0XSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyZW50ID09PSBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuICAgICAgaWYgKG51bGwgPT09IGN1cnJlbnRQYXJlbnQpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzg3KSk7XG4gICAgICBjdXJyZW50UGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAhPT1cbiAgICAgICAgcGFyZW50Lm1lbW9pemVkU3RhdGUubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAobnVsbCAhPT0gY3VycmVudFxuICAgICAgICAgID8gY3VycmVudC5wdXNoKEhvc3RUcmFuc2l0aW9uQ29udGV4dClcbiAgICAgICAgICA6IChjdXJyZW50ID0gW0hvc3RUcmFuc2l0aW9uQ29udGV4dF0pKTtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZXMoXG4gICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIGN1cnJlbnQsXG4gICAgICByZW5kZXJMYW5lcyxcbiAgICAgIGZvcmNlUHJvcGFnYXRlRW50aXJlVHJlZVxuICAgICk7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDI2MjE0NDtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZDb250ZXh0Q2hhbmdlZChjdXJyZW50RGVwZW5kZW5jaWVzKSB7XG4gIGZvciAoXG4gICAgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuICAgIG51bGwgIT09IGN1cnJlbnREZXBlbmRlbmNpZXM7XG5cbiAgKSB7XG4gICAgaWYgKFxuICAgICAgIW9iamVjdElzKFxuICAgICAgICBjdXJyZW50RGVwZW5kZW5jaWVzLmNvbnRleHQuX2N1cnJlbnRWYWx1ZSxcbiAgICAgICAgY3VycmVudERlcGVuZGVuY2llcy5tZW1vaXplZFZhbHVlXG4gICAgICApXG4gICAgKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzLm5leHQ7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG4gIG51bGwgIT09IHdvcmtJblByb2dyZXNzICYmICh3b3JrSW5Qcm9ncmVzcy5maXJzdENvbnRleHQgPSBudWxsKTtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0KGNvbnRleHQpIHtcbiAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihjb25zdW1lciwgY29udGV4dCkge1xuICBudWxsID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciAmJiBwcmVwYXJlVG9SZWFkQ29udGV4dChjb25zdW1lcik7XG4gIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpIHtcbiAgdmFyIHZhbHVlID0gY29udGV4dC5fY3VycmVudFZhbHVlO1xuICBjb250ZXh0ID0geyBjb250ZXh0OiBjb250ZXh0LCBtZW1vaXplZFZhbHVlOiB2YWx1ZSwgbmV4dDogbnVsbCB9O1xuICBpZiAobnVsbCA9PT0gbGFzdENvbnRleHREZXBlbmRlbmN5KSB7XG4gICAgaWYgKG51bGwgPT09IGNvbnN1bWVyKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMwOCkpO1xuICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGNvbnRleHQ7XG4gICAgY29uc3VtZXIuZGVwZW5kZW5jaWVzID0geyBsYW5lczogMCwgZmlyc3RDb250ZXh0OiBjb250ZXh0IH07XG4gICAgY29uc3VtZXIuZmxhZ3MgfD0gNTI0Mjg4O1xuICB9IGVsc2UgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0O1xuICByZXR1cm4gdmFsdWU7XG59XG52YXIgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICBmaWJlci51cGRhdGVRdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDogeyBwZW5kaW5nOiBudWxsLCBsYW5lczogMCwgaGlkZGVuQ2FsbGJhY2tzOiBudWxsIH0sXG4gICAgY2FsbGJhY2tzOiBudWxsXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9PT0gY3VycmVudCAmJlxuICAgICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudC5iYXNlU3RhdGUsXG4gICAgICBmaXJzdEJhc2VVcGRhdGU6IGN1cnJlbnQuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnQubGFzdEJhc2VVcGRhdGUsXG4gICAgICBzaGFyZWQ6IGN1cnJlbnQuc2hhcmVkLFxuICAgICAgY2FsbGJhY2tzOiBudWxsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUobGFuZSkge1xuICByZXR1cm4geyBsYW5lOiBsYW5lLCB0YWc6IDAsIHBheWxvYWQ6IG51bGwsIGNhbGxiYWNrOiBudWxsLCBuZXh0OiBudWxsIH07XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChudWxsID09PSB1cGRhdGVRdWV1ZSkgcmV0dXJuIG51bGw7XG4gIHVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiAyKSkge1xuICAgIHZhciBwZW5kaW5nID0gdXBkYXRlUXVldWUucGVuZGluZztcbiAgICBudWxsID09PSBwZW5kaW5nXG4gICAgICA/ICh1cGRhdGUubmV4dCA9IHVwZGF0ZSlcbiAgICAgIDogKCh1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dCksIChwZW5kaW5nLm5leHQgPSB1cGRhdGUpKTtcbiAgICB1cGRhdGVRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIHVwZGF0ZSA9IGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xuICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBudWxsLCBsYW5lKTtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgdXBkYXRlUXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgZmliZXIgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKG51bGwgIT09IGZpYmVyICYmICgoZmliZXIgPSBmaWJlci5zaGFyZWQpLCAwICE9PSAobGFuZSAmIDQxOTQxNzYpKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gZmliZXIubGFuZXM7XG4gICAgcXVldWVMYW5lcyAmPSByb290LnBlbmRpbmdMYW5lcztcbiAgICBsYW5lIHw9IHF1ZXVlTGFuZXM7XG4gICAgZmliZXIubGFuZXMgPSBsYW5lO1xuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLFxuICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gIGlmIChcbiAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksIHF1ZXVlID09PSBjdXJyZW50KVxuICApIHtcbiAgICB2YXIgbmV3Rmlyc3QgPSBudWxsLFxuICAgICAgbmV3TGFzdCA9IG51bGw7XG4gICAgcXVldWUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gICAgaWYgKG51bGwgIT09IHF1ZXVlKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiBxdWV1ZS5sYW5lLFxuICAgICAgICAgIHRhZzogcXVldWUudGFnLFxuICAgICAgICAgIHBheWxvYWQ6IHF1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBudWxsID09PSBuZXdMYXN0XG4gICAgICAgICAgPyAobmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2xvbmUpXG4gICAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNsb25lKTtcbiAgICAgICAgcXVldWUgPSBxdWV1ZS5uZXh0O1xuICAgICAgfSB3aGlsZSAobnVsbCAhPT0gcXVldWUpO1xuICAgICAgbnVsbCA9PT0gbmV3TGFzdFxuICAgICAgICA/IChuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZSlcbiAgICAgICAgOiAobmV3TGFzdCA9IG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgICB9IGVsc2UgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgcXVldWUgPSB7XG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnQuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBuZXdGaXJzdCxcbiAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgc2hhcmVkOiBjdXJyZW50LnNoYXJlZCxcbiAgICAgIGNhbGxiYWNrczogY3VycmVudC5jYWxsYmFja3NcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdvcmtJblByb2dyZXNzID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgPyAocXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGUpXG4gICAgOiAod29ya0luUHJvZ3Jlc3MubmV4dCA9IGNhcHR1cmVkVXBkYXRlKTtcbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cbnZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gITE7XG5mdW5jdGlvbiBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkge1xuICBpZiAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbikge1xuICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICBpZiAobnVsbCAhPT0gZW50YW5nbGVkQWN0aW9uVGhlbmFibGUpIHRocm93IGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIHdvcmtJblByb2dyZXNzJGpzY29tcCQwLFxuICBwcm9wcyxcbiAgaW5zdGFuY2UkanNjb21wJDAsXG4gIHJlbmRlckxhbmVzXG4pIHtcbiAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICExO1xuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMC51cGRhdGVRdWV1ZTtcbiAgaGFzRm9yY2VVcGRhdGUgPSAhMTtcbiAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSxcbiAgICBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlLFxuICAgIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZC5wZW5kaW5nO1xuICBpZiAobnVsbCAhPT0gcGVuZGluZ1F1ZXVlKSB7XG4gICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZSxcbiAgICAgIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7XG4gICAgbnVsbCA9PT0gbGFzdEJhc2VVcGRhdGVcbiAgICAgID8gKGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgIDogKGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGUpO1xuICAgIGxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcyRqc2NvbXAkMC5hbHRlcm5hdGU7XG4gICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgKChjdXJyZW50ID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAocGVuZGluZ1F1ZXVlID0gY3VycmVudC5sYXN0QmFzZVVwZGF0ZSksXG4gICAgICBwZW5kaW5nUXVldWUgIT09IGxhc3RCYXNlVXBkYXRlICYmXG4gICAgICAgIChudWxsID09PSBwZW5kaW5nUXVldWVcbiAgICAgICAgICA/IChjdXJyZW50LmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZSlcbiAgICAgICAgICA6IChwZW5kaW5nUXVldWUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSksXG4gICAgICAgIChjdXJyZW50Lmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUpKSk7XG4gIH1cbiAgaWYgKG51bGwgIT09IGZpcnN0QmFzZVVwZGF0ZSkge1xuICAgIHZhciBuZXdTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgICBsYXN0QmFzZVVwZGF0ZSA9IDA7XG4gICAgY3VycmVudCA9IGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlID0gbnVsbDtcbiAgICBwZW5kaW5nUXVldWUgPSBmaXJzdEJhc2VVcGRhdGU7XG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUubGFuZSAmIC01MzY4NzA5MTMsXG4gICAgICAgIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gcGVuZGluZ1F1ZXVlLmxhbmU7XG4gICAgICBpZiAoXG4gICAgICAgIGlzSGlkZGVuVXBkYXRlXG4gICAgICAgICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiB1cGRhdGVMYW5lKSA9PT0gdXBkYXRlTGFuZVxuICAgICAgICAgIDogKHJlbmRlckxhbmVzICYgdXBkYXRlTGFuZSkgPT09IHVwZGF0ZUxhbmVcbiAgICAgICkge1xuICAgICAgICAwICE9PSB1cGRhdGVMYW5lICYmXG4gICAgICAgICAgdXBkYXRlTGFuZSA9PT0gY3VycmVudEVudGFuZ2xlZExhbmUgJiZcbiAgICAgICAgICAoZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9ICEwKTtcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5uZXh0ID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGFuZTogMCxcbiAgICAgICAgICAgICAgdGFnOiBwZW5kaW5nUXVldWUudGFnLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwZW5kaW5nUXVldWUucGF5bG9hZCxcbiAgICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBhOiB7XG4gICAgICAgICAgdmFyIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MkanNjb21wJDAsXG4gICAgICAgICAgICB1cGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgICAgICAgdXBkYXRlTGFuZSA9IHByb3BzO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlJGpzY29tcCQwO1xuICAgICAgICAgIHN3aXRjaCAodXBkYXRlLnRhZykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLmNhbGwoaW5zdGFuY2UsIG5ld1N0YXRlLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgLTY1NTM3KSB8IDEyODtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgICAgICAgdXBkYXRlTGFuZSA9XG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd29ya0luUHJvZ3Jlc3NcbiAgICAgICAgICAgICAgICAgID8gd29ya0luUHJvZ3Jlc3MuY2FsbChpbnN0YW5jZSwgbmV3U3RhdGUsIHVwZGF0ZUxhbmUpXG4gICAgICAgICAgICAgICAgICA6IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdXBkYXRlTGFuZSB8fCB2b2lkIDAgPT09IHVwZGF0ZUxhbmUpIGJyZWFrIGE7XG4gICAgICAgICAgICAgIG5ld1N0YXRlID0gYXNzaWduKHt9LCBuZXdTdGF0ZSwgdXBkYXRlTGFuZSk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gITA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUxhbmUgPSBwZW5kaW5nUXVldWUuY2FsbGJhY2s7XG4gICAgICAgIG51bGwgIT09IHVwZGF0ZUxhbmUgJiZcbiAgICAgICAgICAoKHdvcmtJblByb2dyZXNzJGpzY29tcCQwLmZsYWdzIHw9IDY0KSxcbiAgICAgICAgICBpc0hpZGRlblVwZGF0ZSAmJiAod29ya0luUHJvZ3Jlc3MkanNjb21wJDAuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcXVldWUuY2FsbGJhY2tzKSxcbiAgICAgICAgICBudWxsID09PSBpc0hpZGRlblVwZGF0ZVxuICAgICAgICAgICAgPyAocXVldWUuY2FsbGJhY2tzID0gW3VwZGF0ZUxhbmVdKVxuICAgICAgICAgICAgOiBpc0hpZGRlblVwZGF0ZS5wdXNoKHVwZGF0ZUxhbmUpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAoaXNIaWRkZW5VcGRhdGUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHBlbmRpbmdRdWV1ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogcGVuZGluZ1F1ZXVlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHBlbmRpbmdRdWV1ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnRcbiAgICAgICAgICAgID8gKChmaXJzdFBlbmRpbmdVcGRhdGUgPSBjdXJyZW50ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgICAgICAobGFzdFBlbmRpbmdVcGRhdGUgPSBuZXdTdGF0ZSkpXG4gICAgICAgICAgICA6IChjdXJyZW50ID0gY3VycmVudC5uZXh0ID0gaXNIaWRkZW5VcGRhdGUpLFxuICAgICAgICAgIChsYXN0QmFzZVVwZGF0ZSB8PSB1cGRhdGVMYW5lKTtcbiAgICAgIHBlbmRpbmdRdWV1ZSA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgaWYgKG51bGwgPT09IHBlbmRpbmdRdWV1ZSlcbiAgICAgICAgaWYgKCgocGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmcpLCBudWxsID09PSBwZW5kaW5nUXVldWUpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgKGlzSGlkZGVuVXBkYXRlID0gcGVuZGluZ1F1ZXVlKSxcbiAgICAgICAgICAgIChwZW5kaW5nUXVldWUgPSBpc0hpZGRlblVwZGF0ZS5uZXh0KSxcbiAgICAgICAgICAgIChpc0hpZGRlblVwZGF0ZS5uZXh0ID0gbnVsbCksXG4gICAgICAgICAgICAocXVldWUubGFzdEJhc2VVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSksXG4gICAgICAgICAgICAocXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsKTtcbiAgICB9IHdoaWxlICgxKTtcbiAgICBudWxsID09PSBjdXJyZW50ICYmIChsYXN0UGVuZGluZ1VwZGF0ZSA9IG5ld1N0YXRlKTtcbiAgICBxdWV1ZS5iYXNlU3RhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50O1xuICAgIG51bGwgPT09IGZpcnN0QmFzZVVwZGF0ZSAmJiAocXVldWUuc2hhcmVkLmxhbmVzID0gMCk7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzIHw9IGxhc3RCYXNlVXBkYXRlO1xuICAgIHdvcmtJblByb2dyZXNzJGpzY29tcCQwLmxhbmVzID0gbGFzdEJhc2VVcGRhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MkanNjb21wJDAubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG59XG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGNhbGxiYWNrKVxuICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTkxLCBjYWxsYmFjaykpO1xuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuZnVuY3Rpb24gY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gIHZhciBjYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5jYWxsYmFja3M7XG4gIGlmIChudWxsICE9PSBjYWxsYmFja3MpXG4gICAgZm9yIChcbiAgICAgIHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcyA9IG51bGwsIHVwZGF0ZVF1ZXVlID0gMDtcbiAgICAgIHVwZGF0ZVF1ZXVlIDwgY2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgIHVwZGF0ZVF1ZXVlKytcbiAgICApXG4gICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2tzW3VwZGF0ZVF1ZXVlXSwgY29udGV4dCk7XG59XG5mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmspIHtcbiAgdHJ5IHtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUsXG4gICAgICBsYXN0RWZmZWN0ID0gbnVsbCAhPT0gdXBkYXRlUXVldWUgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgICBpZiAobnVsbCAhPT0gbGFzdEVmZmVjdCkge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgdXBkYXRlUXVldWUgPSBmaXJzdEVmZmVjdDtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCh1cGRhdGVRdWV1ZS50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgICAgbGFzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICAgICAgICB2YXIgY3JlYXRlID0gdXBkYXRlUXVldWUuY3JlYXRlLFxuICAgICAgICAgICAgaW5zdCA9IHVwZGF0ZVF1ZXVlLmluc3Q7XG4gICAgICAgICAgbGFzdEVmZmVjdCA9IGNyZWF0ZSgpO1xuICAgICAgICAgIGluc3QuZGVzdHJveSA9IGxhc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZS5uZXh0O1xuICAgICAgfSB3aGlsZSAodXBkYXRlUXVldWUgIT09IGZpcnN0RWZmZWN0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChcbiAgZmxhZ3MsXG4gIGZpbmlzaGVkV29yayxcbiAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciRqc2NvbXAkMFxuKSB7XG4gIHRyeSB7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlLFxuICAgICAgbGFzdEVmZmVjdCA9IG51bGwgIT09IHVwZGF0ZVF1ZXVlID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG4gICAgaWYgKG51bGwgIT09IGxhc3RFZmZlY3QpIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIHVwZGF0ZVF1ZXVlID0gZmlyc3RFZmZlY3Q7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgodXBkYXRlUXVldWUudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAgIHZhciBpbnN0ID0gdXBkYXRlUXVldWUuaW5zdCxcbiAgICAgICAgICAgIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gZGVzdHJveSkge1xuICAgICAgICAgICAgaW5zdC5kZXN0cm95ID0gdm9pZCAwO1xuICAgICAgICAgICAgbGFzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICAgIHZhciBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3RvciRqc2NvbXAkMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgIGxhc3RFZmZlY3QsXG4gICAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVRdWV1ZSA9IHVwZGF0ZVF1ZXVlLm5leHQ7XG4gICAgICB9IHdoaWxlICh1cGRhdGVRdWV1ZSAhPT0gZmlyc3RFZmZlY3QpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgaWYgKG51bGwgIT09IHVwZGF0ZVF1ZXVlKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB0cnkge1xuICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICBjdXJyZW50LFxuICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICBpbnN0YW5jZVxuKSB7XG4gIGluc3RhbmNlLnByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoXG4gICAgY3VycmVudC50eXBlLFxuICAgIGN1cnJlbnQubWVtb2l6ZWRQcm9wc1xuICApO1xuICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgdHJ5IHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKG51bGwgIT09IHJlZikge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICAgIGNhc2UgMjY6XG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICB2YXIgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZlxuICAgICAgICA/IChjdXJyZW50LnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSkpXG4gICAgICAgIDogKHJlZi5jdXJyZW50ID0gaW5zdGFuY2VUb1VzZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQucmVmLFxuICAgIHJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG4gIGlmIChudWxsICE9PSByZWYpXG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlZkNsZWFudXApXG4gICAgICB0cnkge1xuICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAoY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbCksXG4gICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LmFsdGVybmF0ZSksXG4gICAgICAgICAgbnVsbCAhPSBjdXJyZW50ICYmIChjdXJyZW50LnJlZkNsZWFudXAgPSBudWxsKTtcbiAgICAgIH1cbiAgICBlbHNlIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZWYpXG4gICAgICB0cnkge1xuICAgICAgICByZWYobnVsbCk7XG4gICAgICB9IGNhdGNoIChlcnJvciQxMTIpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkMTEyKTtcbiAgICAgIH1cbiAgICBlbHNlIHJlZi5jdXJyZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdEhvc3RNb3VudChmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZSxcbiAgICBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgdHJ5IHtcbiAgICBhOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIHByb3BzLmF1dG9Gb2N1cyAmJiBpbnN0YW5jZS5mb2N1cygpO1xuICAgICAgICBicmVhayBhO1xuICAgICAgY2FzZSBcImltZ1wiOlxuICAgICAgICBwcm9wcy5zcmNcbiAgICAgICAgICA/IChpbnN0YW5jZS5zcmMgPSBwcm9wcy5zcmMpXG4gICAgICAgICAgOiBwcm9wcy5zcmNTZXQgJiYgKGluc3RhbmNlLnNyY3NldCA9IHByb3BzLnNyY1NldCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRIb3N0VXBkYXRlKGZpbmlzaGVkV29yaywgbmV3UHJvcHMsIG9sZFByb3BzKSB7XG4gIHRyeSB7XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgZmluaXNoZWRXb3JrLnR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgZG9tRWxlbWVudFtpbnRlcm5hbFByb3BzS2V5XSA9IG5ld1Byb3BzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIChcbiAgICA1ID09PSBmaWJlci50YWcgfHxcbiAgICAzID09PSBmaWJlci50YWcgfHxcbiAgICAyNiA9PT0gZmliZXIudGFnIHx8XG4gICAgMjcgPT09IGZpYmVyLnRhZyB8fFxuICAgIDQgPT09IGZpYmVyLnRhZ1xuICApO1xufVxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgYTogZm9yICg7Oykge1xuICAgIGZvciAoOyBudWxsID09PSBmaWJlci5zaWJsaW5nOyApIHtcbiAgICAgIGlmIChudWxsID09PSBmaWJlci5yZXR1cm4gfHwgaXNIb3N0UGFyZW50KGZpYmVyLnJldHVybikpIHJldHVybiBudWxsO1xuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLnNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgIGZvciAoXG4gICAgICBmaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgICA1ICE9PSBmaWJlci50YWcgJiZcbiAgICAgIDYgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgMjcgIT09IGZpYmVyLnRhZyAmJlxuICAgICAgMTggIT09IGZpYmVyLnRhZztcblxuICAgICkge1xuICAgICAgaWYgKGZpYmVyLmZsYWdzICYgMikgY29udGludWUgYTtcbiAgICAgIGlmIChudWxsID09PSBmaWJlci5jaGlsZCB8fCA0ID09PSBmaWJlci50YWcpIGNvbnRpbnVlIGE7XG4gICAgICBlbHNlIChmaWJlci5jaGlsZC5yZXR1cm4gPSBmaWJlciksIChmaWJlciA9IGZpYmVyLmNoaWxkKTtcbiAgICB9XG4gICAgaWYgKCEoZmliZXIuZmxhZ3MgJiAyKSkgcmV0dXJuIGZpYmVyLnN0YXRlTm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIGlmICg1ID09PSB0YWcgfHwgNiA9PT0gdGFnKVxuICAgIChub2RlID0gbm9kZS5zdGF0ZU5vZGUpLFxuICAgICAgYmVmb3JlXG4gICAgICAgID8gOCA9PT0gcGFyZW50Lm5vZGVUeXBlXG4gICAgICAgICAgPyBwYXJlbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgYmVmb3JlKVxuICAgICAgICAgIDogcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBiZWZvcmUpXG4gICAgICAgIDogKDggPT09IHBhcmVudC5ub2RlVHlwZVxuICAgICAgICAgICAgPyAoKGJlZm9yZSA9IHBhcmVudC5wYXJlbnROb2RlKSwgYmVmb3JlLmluc2VydEJlZm9yZShub2RlLCBwYXJlbnQpKVxuICAgICAgICAgICAgOiAoKGJlZm9yZSA9IHBhcmVudCksIGJlZm9yZS5hcHBlbmRDaGlsZChub2RlKSksXG4gICAgICAgICAgKHBhcmVudCA9IHBhcmVudC5fcmVhY3RSb290Q29udGFpbmVyKSxcbiAgICAgICAgICAobnVsbCAhPT0gcGFyZW50ICYmIHZvaWQgMCAhPT0gcGFyZW50KSB8fFxuICAgICAgICAgICAgbnVsbCAhPT0gYmVmb3JlLm9uY2xpY2sgfHxcbiAgICAgICAgICAgIChiZWZvcmUub25jbGljayA9IG5vb3AkMSkpO1xuICBlbHNlIGlmICg0ICE9PSB0YWcgJiYgMjcgIT09IHRhZyAmJiAoKG5vZGUgPSBub2RlLmNoaWxkKSwgbnVsbCAhPT0gbm9kZSkpXG4gICAgZm9yIChcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgIClcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpLFxuICAgICAgICAobm9kZSA9IG5vZGUuc2libGluZyk7XG59XG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICBpZiAoNSA9PT0gdGFnIHx8IDYgPT09IHRhZylcbiAgICAobm9kZSA9IG5vZGUuc3RhdGVOb2RlKSxcbiAgICAgIGJlZm9yZSA/IHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgYmVmb3JlKSA6IHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgZWxzZSBpZiAoNCAhPT0gdGFnICYmIDI3ICE9PSB0YWcgJiYgKChub2RlID0gbm9kZS5jaGlsZCksIG51bGwgIT09IG5vZGUpKVxuICAgIGZvciAoXG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpLCBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgbnVsbCAhPT0gbm9kZTtcblxuICAgIClcbiAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShub2RlLCBiZWZvcmUsIHBhcmVudCksIChub2RlID0gbm9kZS5zaWJsaW5nKTtcbn1cbnZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSAhMSxcbiAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9ICExLFxuICBuZWVkc0Zvcm1SZXNldCA9ICExLFxuICBQb3NzaWJseVdlYWtTZXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrU2V0ID8gV2Vha1NldCA6IFNldCxcbiAgbmV4dEVmZmVjdCA9IG51bGwsXG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExO1xuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgcm9vdCA9IHJvb3QuY29udGFpbmVySW5mbztcbiAgZXZlbnRzRW5hYmxlZCA9IF9lbmFibGVkO1xuICByb290ID0gZ2V0QWN0aXZlRWxlbWVudERlZXAocm9vdCk7XG4gIGlmIChoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocm9vdCkpIHtcbiAgICBpZiAoXCJzZWxlY3Rpb25TdGFydFwiIGluIHJvb3QpXG4gICAgICB2YXIgSlNDb21waWxlcl90ZW1wID0ge1xuICAgICAgICBzdGFydDogcm9vdC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiByb290LnNlbGVjdGlvbkVuZFxuICAgICAgfTtcbiAgICBlbHNlXG4gICAgICBhOiB7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9XG4gICAgICAgICAgKChKU0NvbXBpbGVyX3RlbXAgPSByb290Lm93bmVyRG9jdW1lbnQpICYmXG4gICAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuZGVmYXVsdFZpZXcpIHx8XG4gICAgICAgICAgd2luZG93O1xuICAgICAgICB2YXIgc2VsZWN0aW9uID1cbiAgICAgICAgICBKU0NvbXBpbGVyX3RlbXAuZ2V0U2VsZWN0aW9uICYmIEpTQ29tcGlsZXJfdGVtcC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAmJiAwICE9PSBzZWxlY3Rpb24ucmFuZ2VDb3VudCkge1xuICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IHNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgICAgICAgIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICAgICAgICBzZWxlY3Rpb24gPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcC5ub2RlVHlwZSwgZm9jdXNOb2RlLm5vZGVUeXBlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUkMjApIHtcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IG51bGw7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gMCxcbiAgICAgICAgICAgIHN0YXJ0ID0gLTEsXG4gICAgICAgICAgICBlbmQgPSAtMSxcbiAgICAgICAgICAgIGluZGV4V2l0aGluQW5jaG9yID0gMCxcbiAgICAgICAgICAgIGluZGV4V2l0aGluRm9jdXMgPSAwLFxuICAgICAgICAgICAgbm9kZSA9IHJvb3QsXG4gICAgICAgICAgICBwYXJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgICBiOiBmb3IgKDs7KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuZXh0OyA7ICkge1xuICAgICAgICAgICAgICBub2RlICE9PSBKU0NvbXBpbGVyX3RlbXAgfHxcbiAgICAgICAgICAgICAgICAoMCAhPT0gYW5jaG9yT2Zmc2V0ICYmIDMgIT09IG5vZGUubm9kZVR5cGUpIHx8XG4gICAgICAgICAgICAgICAgKHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgbm9kZSAhPT0gZm9jdXNOb2RlIHx8XG4gICAgICAgICAgICAgICAgKDAgIT09IHNlbGVjdGlvbiAmJiAzICE9PSBub2RlLm5vZGVUeXBlKSB8fFxuICAgICAgICAgICAgICAgIChlbmQgPSBsZW5ndGggKyBzZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAzID09PSBub2RlLm5vZGVUeXBlICYmIChsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgPT09IChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSkgYnJlYWs7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIGJyZWFrIGI7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPT09IEpTQ29tcGlsZXJfdGVtcCAmJlxuICAgICAgICAgICAgICAgICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCAmJlxuICAgICAgICAgICAgICAgIChzdGFydCA9IGxlbmd0aCk7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSAmJlxuICAgICAgICAgICAgICAgICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gc2VsZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgKGVuZCA9IGxlbmd0aCk7XG4gICAgICAgICAgICAgIGlmIChudWxsICE9PSAobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpKSBicmVhaztcbiAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgSlNDb21waWxlcl90ZW1wID1cbiAgICAgICAgICAgIC0xID09PSBzdGFydCB8fCAtMSA9PT0gZW5kID8gbnVsbCA6IHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgICAgICB9IGVsc2UgSlNDb21waWxlcl90ZW1wID0gbnVsbDtcbiAgICAgIH1cbiAgICBKU0NvbXBpbGVyX3RlbXAgPSBKU0NvbXBpbGVyX3RlbXAgfHwgeyBzdGFydDogMCwgZW5kOiAwIH07XG4gIH0gZWxzZSBKU0NvbXBpbGVyX3RlbXAgPSBudWxsO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IHsgZm9jdXNlZEVsZW06IHJvb3QsIHNlbGVjdGlvblJhbmdlOiBKU0NvbXBpbGVyX3RlbXAgfTtcbiAgX2VuYWJsZWQgPSAhMTtcbiAgZm9yIChuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKVxuICAgIGlmIChcbiAgICAgICgoZmlyc3RDaGlsZCA9IG5leHRFZmZlY3QpLFxuICAgICAgKHJvb3QgPSBmaXJzdENoaWxkLmNoaWxkKSxcbiAgICAgIDAgIT09IChmaXJzdENoaWxkLnN1YnRyZWVGbGFncyAmIDEwMjgpICYmIG51bGwgIT09IHJvb3QpXG4gICAgKVxuICAgICAgKHJvb3QucmV0dXJuID0gZmlyc3RDaGlsZCksIChuZXh0RWZmZWN0ID0gcm9vdCk7XG4gICAgZWxzZVxuICAgICAgZm9yICg7IG51bGwgIT09IG5leHRFZmZlY3Q7ICkge1xuICAgICAgICBmaXJzdENoaWxkID0gbmV4dEVmZmVjdDtcbiAgICAgICAgZm9jdXNOb2RlID0gZmlyc3RDaGlsZC5hbHRlcm5hdGU7XG4gICAgICAgIHJvb3QgPSBmaXJzdENoaWxkLmZsYWdzO1xuICAgICAgICBzd2l0Y2ggKGZpcnN0Q2hpbGQudGFnKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKDAgIT09IChyb290ICYgMTAyNCkgJiYgbnVsbCAhPT0gZm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgIHJvb3QgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcCA9IGZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgIGFuY2hvck9mZnNldCA9IGZvY3VzTm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBmb2N1c05vZGUgPSBmb2N1c05vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uID0gSlNDb21waWxlcl90ZW1wLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWRQcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgICAgICAgIEpTQ29tcGlsZXJfdGVtcC50eXBlLFxuICAgICAgICAgICAgICAgICAgYW5jaG9yT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLmVsZW1lbnRUeXBlID09PSBKU0NvbXBpbGVyX3RlbXAudHlwZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHNlbGVjdGlvbi5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkUHJldlByb3BzLFxuICAgICAgICAgICAgICAgICAgZm9jdXNOb2RlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSByb290O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLFxuICAgICAgICAgICAgICAgICAgSlNDb21waWxlcl90ZW1wLnJldHVybixcbiAgICAgICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYgKDAgIT09IChyb290ICYgMTAyNCkpXG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoKHJvb3QgPSBmaXJzdENoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgICAgICAgICAoSlNDb21waWxlcl90ZW1wID0gcm9vdC5ub2RlVHlwZSksXG4gICAgICAgICAgICAgICAgOSA9PT0gSlNDb21waWxlcl90ZW1wKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkocm9vdCk7XG4gICAgICAgICAgICAgIGVsc2UgaWYgKDEgPT09IEpTQ29tcGlsZXJfdGVtcClcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJvb3Qubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiSFRNTFwiOlxuICAgICAgICAgICAgICAgICAgY2FzZSBcIkJPRFlcIjpcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJDb250YWluZXJTcGFyaW5nbHkocm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcm9vdC50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKDAgIT09IChyb290ICYgMTAyNCkpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTYzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcm9vdCA9IGZpcnN0Q2hpbGQuc2libGluZztcbiAgICAgICAgaWYgKG51bGwgIT09IHJvb3QpIHtcbiAgICAgICAgICByb290LnJldHVybiA9IGZpcnN0Q2hpbGQucmV0dXJuO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSByb290O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5leHRFZmZlY3QgPSBmaXJzdENoaWxkLnJldHVybjtcbiAgICAgIH1cbiAgcmVzb2x2ZWRQcmV2UHJvcHMgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9ICExO1xuICByZXR1cm4gcmVzb2x2ZWRQcmV2UHJvcHM7XG59XG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNCAmJiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KDUsIGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBpZiAoZmxhZ3MgJiA0KVxuICAgICAgICBpZiAoKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSwgbnVsbCA9PT0gY3VycmVudCkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuY29tcG9uZW50RGlkVXBkYXRlKFxuICAgICAgICAgICAgICBwcmV2UHJvcHMsXG4gICAgICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdC5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvciQxMTEpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGZpbmlzaGVkV29yay5yZXR1cm4sXG4gICAgICAgICAgICAgIGVycm9yJDExMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGZsYWdzICYgNjQgJiYgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgaWYgKGZsYWdzICYgNjQgJiYgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksIG51bGwgIT09IGZsYWdzKSkge1xuICAgICAgICBmaW5pc2hlZFJvb3QgPSBudWxsO1xuICAgICAgICBpZiAobnVsbCAhPT0gZmluaXNoZWRXb3JrLmNoaWxkKVxuICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhmbGFncywgZmluaXNoZWRSb290KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBudWxsID09PSBjdXJyZW50ICYmIGZsYWdzICYgNCAmJiBjb21taXRIb3N0TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDQgJiYgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIHByZXZQcm9wcyA9XG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgIGlmICghcHJldlByb3BzKSB7XG4gICAgICAgIGN1cnJlbnQgPVxuICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgfHxcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbixcbiAgICAgICAgICBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZQcm9wcztcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBjdXJyZW50KSAmJiAhcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW5cbiAgICAgICAgICA/IHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICAwICE9PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgICAgICAgICApXG4gICAgICAgICAgOiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgIH1cbiAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgIChcIm1hbnVhbFwiID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlXG4gICAgICAgICAgPyBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKVxuICAgICAgICAgIDogc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgbnVsbCAhPT0gYWx0ZXJuYXRlICYmXG4gICAgKChmaWJlci5hbHRlcm5hdGUgPSBudWxsKSwgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKSk7XG4gIGZpYmVyLmNoaWxkID0gbnVsbDtcbiAgZmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgZmliZXIuc2libGluZyA9IG51bGw7XG4gIDUgPT09IGZpYmVyLnRhZyAmJlxuICAgICgoYWx0ZXJuYXRlID0gZmliZXIuc3RhdGVOb2RlKSxcbiAgICBudWxsICE9PSBhbHRlcm5hdGUgJiYgZGV0YWNoRGVsZXRlZEluc3RhbmNlKGFsdGVybmF0ZSkpO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuICBmaWJlci5yZXR1cm4gPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbn1cbnZhciBob3N0UGFyZW50ID0gbnVsbCxcbiAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITE7XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICBmaW5pc2hlZFJvb3QsXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gIHBhcmVudFxuKSB7XG4gIGZvciAocGFyZW50ID0gcGFyZW50LmNoaWxkOyBudWxsICE9PSBwYXJlbnQ7IClcbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgcGFyZW50KSxcbiAgICAgIChwYXJlbnQgPSBwYXJlbnQuc2libGluZyk7XG59XG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKFxuICBmaW5pc2hlZFJvb3QsXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gIGRlbGV0ZWRGaWJlclxuKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50KVxuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZGVsZXRlZEZpYmVyKTtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgIGNhc2UgMjY6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZVxuICAgICAgICA/IGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlLmNvdW50LS1cbiAgICAgICAgOiBkZWxldGVkRmliZXIuc3RhdGVOb2RlICYmXG4gICAgICAgICAgKChkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlKSxcbiAgICAgICAgICBkZWxldGVkRmliZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkZWxldGVkRmliZXIpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjc6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudCxcbiAgICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgIGhvc3RQYXJlbnQgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBkZWxldGVkRmliZXIgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuICAgICAgZm9yIChcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IGRlbGV0ZWRGaWJlci5hdHRyaWJ1dGVzO1xuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLmxlbmd0aDtcblxuICAgICAgKVxuICAgICAgICBkZWxldGVkRmliZXIucmVtb3ZlQXR0cmlidXRlTm9kZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yWzBdKTtcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZShkZWxldGVkRmliZXIpO1xuICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgY2FzZSA2OlxuICAgICAgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnQ7XG4gICAgICB2YXIgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciQxMTkgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyJDExOTtcbiAgICAgIGlmIChudWxsICE9PSBob3N0UGFyZW50KVxuICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAoZmluaXNoZWRSb290ID0gaG9zdFBhcmVudCksXG4gICAgICAgICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgICA4ID09PSBmaW5pc2hlZFJvb3Qubm9kZVR5cGVcbiAgICAgICAgICAgICAgICA/IGZpbmlzaGVkUm9vdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHByZXZIb3N0UGFyZW50KVxuICAgICAgICAgICAgICAgIDogZmluaXNoZWRSb290LnJlbW92ZUNoaWxkKHByZXZIb3N0UGFyZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoXG4gICAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQucmVtb3ZlQ2hpbGQoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKFxuICAgICAgICAgICAgICBkZWxldGVkRmliZXIsXG4gICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTg6XG4gICAgICBudWxsICE9PSBob3N0UGFyZW50ICYmXG4gICAgICAgIChob3N0UGFyZW50SXNDb250YWluZXJcbiAgICAgICAgICA/ICgobmVhcmVzdE1vdW50ZWRBbmNlc3RvciA9IGhvc3RQYXJlbnQpLFxuICAgICAgICAgICAgKGRlbGV0ZWRGaWJlciA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICAgICAgOCA9PT0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5ub2RlVHlwZVxuICAgICAgICAgICAgICA/IGNsZWFyU3VzcGVuc2VCb3VuZGFyeShcbiAgICAgICAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IucGFyZW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgOiAxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLm5vZGVUeXBlICYmXG4gICAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlciksXG4gICAgICAgICAgICByZXRyeUlmQmxvY2tlZE9uKG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpKVxuICAgICAgICAgIDogY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgIGRlbGV0ZWRGaWJlclxuICAgICAgKTtcbiAgICAgIGhvc3RQYXJlbnQgPSBwcmV2SG9zdFBhcmVudDtcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE0OlxuICAgIGNhc2UgMTU6XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCgyLCBkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoNCwgZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAoc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciksXG4gICAgICAgIChwcmV2SG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpLFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2SG9zdFBhcmVudC5jb21wb25lbnRXaWxsVW5tb3VudCAmJlxuICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChcbiAgICAgICAgICAgIGRlbGV0ZWRGaWJlcixcbiAgICAgICAgICAgIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsXG4gICAgICAgICAgICBwcmV2SG9zdFBhcmVudFxuICAgICAgICAgICkpO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIxOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICBkZWxldGVkRmliZXJcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPVxuICAgICAgICAocHJldkhvc3RQYXJlbnQgPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB8fFxuICAgICAgICBudWxsICE9PSBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoXG4gICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgbmVhcmVzdE1vdW50ZWRBbmNlc3RvcixcbiAgICAgICAgZGVsZXRlZEZpYmVyXG4gICAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoXG4gICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICAoKGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUpLFxuICAgIG51bGwgIT09IGZpbmlzaGVkUm9vdCAmJlxuICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QubWVtb2l6ZWRTdGF0ZSksXG4gICAgICBudWxsICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgKChmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QuZGVoeWRyYXRlZCksIG51bGwgIT09IGZpbmlzaGVkUm9vdCkpKVxuICApXG4gICAgdHJ5IHtcbiAgICAgIHJldHJ5SWZCbG9ja2VkT24oZmluaXNoZWRSb290KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAxMzpcbiAgICBjYXNlIDE5OlxuICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgbnVsbCA9PT0gcmV0cnlDYWNoZSAmJlxuICAgICAgICAocmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpO1xuICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgY2FzZSAyMjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSxcbiAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUpLFxuICAgICAgICBudWxsID09PSByZXRyeUNhY2hlICYmXG4gICAgICAgICAgKHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCkpLFxuICAgICAgICByZXRyeUNhY2hlXG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQzNSwgZmluaXNoZWRXb3JrLnRhZykpO1xuICB9XG59XG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgd2FrZWFibGVzKSB7XG4gIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICB2YXIgcmV0cnkgPSByZXNvbHZlUmV0cnlXYWtlYWJsZS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgd2FrZWFibGUpO1xuICAgIHJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSB8fFxuICAgICAgKHJldHJ5Q2FjaGUuYWRkKHdha2VhYmxlKSwgd2FrZWFibGUudGhlbihyZXRyeSwgcmV0cnkpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QkanNjb21wJDAsIHBhcmVudEZpYmVyKSB7XG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gIGlmIChudWxsICE9PSBkZWxldGlvbnMpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldLFxuICAgICAgICByb290ID0gcm9vdCRqc2NvbXAkMCxcbiAgICAgICAgcmV0dXJuRmliZXIgPSBwYXJlbnRGaWJlcixcbiAgICAgICAgcGFyZW50ID0gcmV0dXJuRmliZXI7XG4gICAgICBhOiBmb3IgKDsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBob3N0UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gITA7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChudWxsID09PSBob3N0UGFyZW50KSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2MCkpO1xuICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9ICExO1xuICAgICAgcm9vdCA9IGNoaWxkVG9EZWxldGUuYWx0ZXJuYXRlO1xuICAgICAgbnVsbCAhPT0gcm9vdCAmJiAocm9vdC5yZXR1cm4gPSBudWxsKTtcbiAgICAgIGNoaWxkVG9EZWxldGUucmV0dXJuID0gbnVsbDtcbiAgICB9XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMzg3OClcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApXG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKHBhcmVudEZpYmVyLCByb290JGpzY29tcCQwKSxcbiAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG59XG52YXIgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsO1xuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE0OlxuICAgIGNhc2UgMTU6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAoY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KDMsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiksXG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoMywgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KDUsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybikpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDUxMiAmJlxuICAgICAgICAob2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pKTtcbiAgICAgIGZsYWdzICYgNjQgJiZcbiAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuICYmXG4gICAgICAgICgoZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrICYmXG4gICAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay5jYWxsYmFja3MpLFxuICAgICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgICAoKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyksXG4gICAgICAgICAgICAoZmluaXNoZWRXb3JrLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPVxuICAgICAgICAgICAgICBudWxsID09PSBjdXJyZW50ID8gZmxhZ3MgOiBjdXJyZW50LmNvbmNhdChmbGFncykpKSkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNjpcbiAgICAgIHZhciBob2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGZsYWdzICYgNTEyICYmXG4gICAgICAgIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8XG4gICAgICAgICAgbnVsbCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybikpO1xuICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICB2YXIgY3VycmVudFJlc291cmNlID0gbnVsbCAhPT0gY3VycmVudCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gICAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KVxuICAgICAgICAgIGlmIChudWxsID09PSBmbGFncylcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKSB7XG4gICAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgICAgICAgYjogc3dpdGNoIChmbGFncykge1xuICAgICAgICAgICAgICAgICAgY2FzZSBcInRpdGxlXCI6XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgIWN1cnJlbnRSZXNvdXJjZSB8fFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2VbaW50ZXJuYWxJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgICAgICAgICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UubmFtZXNwYWNlVVJJIHx8XG4gICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFJlc291cmNlID0gaG9pc3RhYmxlUm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290LmhlYWQuaW5zZXJ0QmVmb3JlKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QucXVlcnlTZWxlY3RvcihcImhlYWQgPiB0aXRsZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoY3VycmVudFJlc291cmNlLCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBmbGFncyA9IGN1cnJlbnRSZXNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZU5vZGVzID0gZ2V0SHlkcmF0YWJsZUhvaXN0YWJsZUNhY2hlKFxuICAgICAgICAgICAgICAgICAgICAgIFwibGlua1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwiaHJlZlwiLFxuICAgICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3RcbiAgICAgICAgICAgICAgICAgICAgKS5nZXQoZmxhZ3MgKyAoY3VycmVudC5ocmVmIHx8IFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlTm9kZXMpXG4gICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGN1cnJlbnRSZXNvdXJjZSA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmhyZWYgPyBudWxsIDogY3VycmVudC5ocmVmKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnJlbCA/IG51bGwgOiBjdXJyZW50LnJlbCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwidGl0bGVcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnRpdGxlID8gbnVsbCA6IGN1cnJlbnQudGl0bGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5jcm9zc09yaWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmNyb3NzT3JpZ2luKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXliZU5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlID0gaG9pc3RhYmxlUm9vdC5jcmVhdGVFbGVtZW50KGZsYWdzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoY3VycmVudFJlc291cmNlLCBmbGFncywgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QuaGVhZC5hcHBlbmRDaGlsZChjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAobWF5YmVOb2RlcyA9IGdldEh5ZHJhdGFibGVIb2lzdGFibGVDYWNoZShcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWV0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250ZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBob2lzdGFibGVSb290XG4gICAgICAgICAgICAgICAgICAgICAgKS5nZXQoZmxhZ3MgKyAoY3VycmVudC5jb250ZW50IHx8IFwiXCIpKSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXliZU5vZGVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGN1cnJlbnRSZXNvdXJjZSA9IG1heWJlTm9kZXNbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBcIlwiICsgY3VycmVudC5jb250ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG51bGwgPT0gY3VycmVudC5uYW1lID8gbnVsbCA6IGN1cnJlbnQubmFtZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwicHJvcGVydHlcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50LnByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGN1cnJlbnQucHJvcGVydHkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFJlc291cmNlLmdldEF0dHJpYnV0ZShcImh0dHAtZXF1aXZcIikgPT09XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobnVsbCA9PSBjdXJyZW50Lmh0dHBFcXVpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50Lmh0dHBFcXVpdikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UuZ2V0QXR0cmlidXRlKFwiY2hhcnNldFwiKSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChudWxsID09IGN1cnJlbnQuY2hhclNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjdXJyZW50LmNoYXJTZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1heWJlTm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgPSBob2lzdGFibGVSb290LmNyZWF0ZUVsZW1lbnQoZmxhZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhjdXJyZW50UmVzb3VyY2UsIGZsYWdzLCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5oZWFkLmFwcGVuZENoaWxkKGN1cnJlbnRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NjgsIGZsYWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZVtpbnRlcm5hbEluc3RhbmNlS2V5XSA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGN1cnJlbnRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgZmxhZ3MgPSBjdXJyZW50UmVzb3VyY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGZsYWdzO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIG1vdW50SG9pc3RhYmxlKFxuICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnR5cGUsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSAhPT0gZmxhZ3NcbiAgICAgICAgICAgID8gKG51bGwgPT09IGN1cnJlbnRSZXNvdXJjZVxuICAgICAgICAgICAgICAgID8gbnVsbCAhPT0gY3VycmVudC5zdGF0ZU5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICgoY3VycmVudCA9IGN1cnJlbnQuc3RhdGVOb2RlKSxcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjdXJyZW50KSlcbiAgICAgICAgICAgICAgICA6IGN1cnJlbnRSZXNvdXJjZS5jb3VudC0tLFxuICAgICAgICAgICAgICBudWxsID09PSBmbGFnc1xuICAgICAgICAgICAgICAgID8gbW91bnRIb2lzdGFibGUoXG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay50eXBlLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgOiBhY3F1aXJlUmVzb3VyY2UoXG4gICAgICAgICAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wc1xuICAgICAgICAgICAgICAgICAgKSlcbiAgICAgICAgICAgIDogbnVsbCA9PT0gZmxhZ3MgJiZcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHNcbiAgICAgICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjc6XG4gICAgICBpZiAoZmxhZ3MgJiA0ICYmIG51bGwgPT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUpIHtcbiAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIGN1cnJlbnRSZXNvdXJjZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIG5vZGUgPSBob2lzdGFibGVSb290LmZpcnN0Q2hpbGQ7IG5vZGU7ICkge1xuICAgICAgICAgICAgdmFyIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZyxcbiAgICAgICAgICAgICAgbm9kZU5hbWUgPSBub2RlLm5vZGVOYW1lO1xuICAgICAgICAgICAgbm9kZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0gfHxcbiAgICAgICAgICAgICAgXCJIRUFEXCIgPT09IG5vZGVOYW1lIHx8XG4gICAgICAgICAgICAgIFwiQk9EWVwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICBcIlNDUklQVFwiID09PSBub2RlTmFtZSB8fFxuICAgICAgICAgICAgICBcIlNUWUxFXCIgPT09IG5vZGVOYW1lIHx8XG4gICAgICAgICAgICAgIChcIkxJTktcIiA9PT0gbm9kZU5hbWUgJiZcbiAgICAgICAgICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gbm9kZS5yZWwudG9Mb3dlckNhc2UoKSkgfHxcbiAgICAgICAgICAgICAgaG9pc3RhYmxlUm9vdC5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGUsIGF0dHJpYnV0ZXMgPSBob2lzdGFibGVSb290LmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmxlbmd0aDtcblxuICAgICAgICAgIClcbiAgICAgICAgICAgIGhvaXN0YWJsZVJvb3QucmVtb3ZlQXR0cmlidXRlTm9kZShhdHRyaWJ1dGVzWzBdKTtcbiAgICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhob2lzdGFibGVSb290LCB0eXBlLCBjdXJyZW50UmVzb3VyY2UpO1xuICAgICAgICAgIGhvaXN0YWJsZVJvb3RbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBmaW5pc2hlZFdvcms7XG4gICAgICAgICAgaG9pc3RhYmxlUm9vdFtpbnRlcm5hbFByb3BzS2V5XSA9IGN1cnJlbnRSZXNvdXJjZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNhc2UgNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgMzIpIHtcbiAgICAgICAgaG9pc3RhYmxlUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoaG9pc3RhYmxlUm9vdCwgXCJcIik7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICBudWxsICE9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgJiZcbiAgICAgICAgKChob2lzdGFibGVSb290ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICBjb21taXRIb3N0VXBkYXRlKFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBob2lzdGFibGVSb290LFxuICAgICAgICAgIG51bGwgIT09IGN1cnJlbnQgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBob2lzdGFibGVSb290XG4gICAgICAgICkpO1xuICAgICAgZmxhZ3MgJiAxMDI0ICYmIChuZWVkc0Zvcm1SZXNldCA9ICEwKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgaWYgKGZsYWdzICYgNCkge1xuICAgICAgICBpZiAobnVsbCA9PT0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE2MikpO1xuICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICBjdXJyZW50ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjdXJyZW50Lm5vZGVWYWx1ZSA9IGZsYWdzO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICB0YWdDYWNoZXMgPSBudWxsO1xuICAgICAgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGhvaXN0YWJsZVJvb3Q7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGlmIChmbGFncyAmIDQgJiYgbnVsbCAhPT0gY3VycmVudCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHJ5SWZCbG9ja2VkT24ocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgbmVlZHNGb3JtUmVzZXQgJiZcbiAgICAgICAgKChuZWVkc0Zvcm1SZXNldCA9ICExKSwgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yaykpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgZmxhZ3MgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChcbiAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICApO1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGZsYWdzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMjpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmluaXNoZWRXb3JrLmNoaWxkLmZsYWdzICYgODE5MiAmJlxuICAgICAgICAobnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpICE9PVxuICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkgJiZcbiAgICAgICAgKGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSBub3coKSk7XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgZmxhZ3MgJiA1MTIgJiZcbiAgICAgICAgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHxcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKSk7XG4gICAgICBub2RlID0gbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICBuZXh0Tm9kZSA9IG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgbm9kZU5hbWUgPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICB0eXBlID0gb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG5vZGVOYW1lIHx8IG5vZGU7XG4gICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gdHlwZSB8fCBuZXh0Tm9kZTtcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSB0eXBlO1xuICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gbm9kZU5hbWU7XG4gICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgcm9vdC5fY3VycmVudCA9IGZpbmlzaGVkV29yaztcbiAgICAgIHJvb3QuX3Zpc2liaWxpdHkgJj0gLTM7XG4gICAgICByb290Ll92aXNpYmlsaXR5IHw9IHJvb3QuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMjtcbiAgICAgIGlmIChcbiAgICAgICAgZmxhZ3MgJiA4MTkyICYmXG4gICAgICAgICgocm9vdC5fdmlzaWJpbGl0eSA9IG5vZGVcbiAgICAgICAgICA/IHJvb3QuX3Zpc2liaWxpdHkgJiAtMlxuICAgICAgICAgIDogcm9vdC5fdmlzaWJpbGl0eSB8IDEpLFxuICAgICAgICBub2RlICYmXG4gICAgICAgICAgKChyb290ID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pLFxuICAgICAgICAgIG51bGwgPT09IGN1cnJlbnQgfHxcbiAgICAgICAgICAgIG5leHROb2RlIHx8XG4gICAgICAgICAgICByb290IHx8XG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspKSxcbiAgICAgICAgbnVsbCA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMgfHxcbiAgICAgICAgICBcIm1hbnVhbFwiICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5tb2RlKVxuICAgICAgKVxuICAgICAgICBhOiBmb3IgKGN1cnJlbnQgPSBudWxsLCByb290ID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgICAgICAgIGlmICg1ID09PSByb290LnRhZyB8fCAyNiA9PT0gcm9vdC50YWcgfHwgMjcgPT09IHJvb3QudGFnKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gY3VycmVudCkge1xuICAgICAgICAgICAgICBuZXh0Tm9kZSA9IGN1cnJlbnQgPSByb290O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICgoKGhvaXN0YWJsZVJvb3QgPSBuZXh0Tm9kZS5zdGF0ZU5vZGUpLCBub2RlKSlcbiAgICAgICAgICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBob2lzdGFibGVSb290LnN0eWxlKSxcbiAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY3VycmVudFJlc291cmNlLnNldFByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50UmVzb3VyY2Uuc2V0UHJvcGVydHkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGlzcGxheVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbXBvcnRhbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIDogKGN1cnJlbnRSZXNvdXJjZS5kaXNwbGF5ID0gXCJub25lXCIpO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbWF5YmVOb2RlcyA9IG5leHROb2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIGkgPSBuZXh0Tm9kZS5tZW1vaXplZFByb3BzLnN0eWxlO1xuICAgICAgICAgICAgICAgICAgdmFyIGRpc3BsYXkgPVxuICAgICAgICAgICAgICAgICAgICB2b2lkIDAgIT09IGkgJiYgbnVsbCAhPT0gaSAmJiBpLmhhc093blByb3BlcnR5KFwiZGlzcGxheVwiKVxuICAgICAgICAgICAgICAgICAgICAgID8gaS5kaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgbWF5YmVOb2Rlcy5zdHlsZS5kaXNwbGF5ID1cbiAgICAgICAgICAgICAgICAgICAgbnVsbCA9PSBkaXNwbGF5IHx8IFwiYm9vbGVhblwiID09PSB0eXBlb2YgZGlzcGxheVxuICAgICAgICAgICAgICAgICAgICAgID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgIDogKFwiXCIgKyBkaXNwbGF5KS50cmltKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHROb2RlLCBuZXh0Tm9kZS5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoNiA9PT0gcm9vdC50YWcpIHtcbiAgICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICAgIG5leHROb2RlID0gcm9vdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuZXh0Tm9kZS5zdGF0ZU5vZGUubm9kZVZhbHVlID0gbm9kZVxuICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICA6IG5leHROb2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IobmV4dE5vZGUsIG5leHROb2RlLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICgoMjIgIT09IHJvb3QudGFnICYmIDIzICE9PSByb290LnRhZykgfHxcbiAgICAgICAgICAgICAgbnVsbCA9PT0gcm9vdC5tZW1vaXplZFN0YXRlIHx8XG4gICAgICAgICAgICAgIHJvb3QgPT09IGZpbmlzaGVkV29yaykgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHJvb3QuY2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJvb3QuY2hpbGQucmV0dXJuID0gcm9vdDtcbiAgICAgICAgICAgIHJvb3QgPSByb290LmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290ID09PSBmaW5pc2hlZFdvcmspIGJyZWFrIGE7XG4gICAgICAgICAgZm9yICg7IG51bGwgPT09IHJvb3Quc2libGluZzsgKSB7XG4gICAgICAgICAgICBpZiAobnVsbCA9PT0gcm9vdC5yZXR1cm4gfHwgcm9vdC5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgYnJlYWsgYTtcbiAgICAgICAgICAgIGN1cnJlbnQgPT09IHJvb3QgJiYgKGN1cnJlbnQgPSBudWxsKTtcbiAgICAgICAgICAgIHJvb3QgPSByb290LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudCA9PT0gcm9vdCAmJiAoY3VycmVudCA9IG51bGwpO1xuICAgICAgICAgIHJvb3Quc2libGluZy5yZXR1cm4gPSByb290LnJldHVybjtcbiAgICAgICAgICByb290ID0gcm9vdC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgKChjdXJyZW50ID0gZmxhZ3MucmV0cnlRdWV1ZSksXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJlxuICAgICAgICAgICAgKChmbGFncy5yZXRyeVF1ZXVlID0gbnVsbCksXG4gICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgY3VycmVudCkpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE5OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBmbGFncyAmIDQgJiZcbiAgICAgICAgKChmbGFncyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IGZsYWdzICYmXG4gICAgICAgICAgKChmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgZmxhZ3MpKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIxOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKSxcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICgyNyAhPT0gZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBhOiB7XG4gICAgICAgICAgZm9yICh2YXIgcGFyZW50ID0gZmluaXNoZWRXb3JrLnJldHVybjsgbnVsbCAhPT0gcGFyZW50OyApIHtcbiAgICAgICAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcGFyZW50O1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjApKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC50YWcpIHtcbiAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgdmFyIHBhcmVudCRqc2NvbXAkMCA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGF0ZU5vZGUsXG4gICAgICAgICAgICAgIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUsIHBhcmVudCRqc2NvbXAkMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB2YXIgcGFyZW50JDExMyA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZmxhZ3MgJiAzMiAmJlxuICAgICAgICAgICAgICAoc2V0VGV4dENvbnRlbnQocGFyZW50JDExMywgXCJcIiksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQuZmxhZ3MgJj0gLTMzKSk7XG4gICAgICAgICAgICB2YXIgYmVmb3JlJDExNCA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBiZWZvcmUkMTE0LCBwYXJlbnQkMTEzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB2YXIgcGFyZW50JDExNSA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgYmVmb3JlJDExNiA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGJlZm9yZSQxMTYsXG4gICAgICAgICAgICAgIHBhcmVudCQxMTVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IC0zO1xuICB9XG4gIGZsYWdzICYgNDA5NiAmJiAoZmluaXNoZWRXb3JrLmZsYWdzICY9IC00MDk3KTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgMTAyNClcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgIHZhciBmaWJlciA9IHBhcmVudEZpYmVyO1xuICAgICAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpYmVyKTtcbiAgICAgIDUgPT09IGZpYmVyLnRhZyAmJiBmaWJlci5mbGFncyAmIDEwMjQgJiYgZmliZXIuc3RhdGVOb2RlLnJlc2V0KCk7XG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDg3NzIpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBwYXJlbnRGaWJlci5hbHRlcm5hdGUsIHBhcmVudEZpYmVyKSxcbiAgICAgICAgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZyk7XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICB2YXIgZmluaXNoZWRXb3JrID0gcGFyZW50RmliZXI7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICBjYXNlIDExOlxuICAgICAgY2FzZSAxNDpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ICYmXG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybixcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgKTtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI2OlxuICAgICAgY2FzZSAyNzpcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMjpcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIG51bGwgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgIH1cbiAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgcGFyZW50RmliZXIsXG4gIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbikge1xuICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID1cbiAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIDAgIT09IChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiA4NzcyKTtcbiAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGUsXG4gICAgICBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICBmaW5pc2hlZFdvcmsgPSBwYXJlbnRGaWJlcixcbiAgICAgIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoNCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpbmlzaGVkUm9vdCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgZmluaXNoZWRSb290LmNvbXBvbmVudERpZE1vdW50KVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgY3VycmVudC5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGZpbmlzaGVkUm9vdCA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICAgIGlmIChudWxsICE9PSBmaW5pc2hlZFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IGZpbmlzaGVkUm9vdC5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzO1xuICAgICAgICAgICAgaWYgKG51bGwgIT09IGhpZGRlbkNhbGxiYWNrcylcbiAgICAgICAgICAgICAgZm9yIChcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3Quc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGwsIGZpbmlzaGVkUm9vdCA9IDA7XG4gICAgICAgICAgICAgICAgZmluaXNoZWRSb290IDwgaGlkZGVuQ2FsbGJhY2tzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QrK1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgY2FsbENhbGxiYWNrKGhpZGRlbkNhbGxiYWNrc1tmaW5pc2hlZFJvb3RdLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICBmbGFncyAmIDY0ICYmXG4gICAgICAgICAgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNjpcbiAgICAgIGNhc2UgMjc6XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiZcbiAgICAgICAgICBudWxsID09PSBjdXJyZW50ICYmXG4gICAgICAgICAgZmxhZ3MgJiA0ICYmXG4gICAgICAgICAgY29tbWl0SG9zdE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgIGZsYWdzICYgNCAmJlxuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIyOlxuICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoXG4gICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICAgKTtcbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICB9XG4gICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG4gIG51bGwgIT09IGN1cnJlbnQgJiZcbiAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgKHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2wpO1xuICBjdXJyZW50ID0gbnVsbDtcbiAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgJiZcbiAgICBudWxsICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAoY3VycmVudCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKTtcbiAgY3VycmVudCAhPT0gcHJldmlvdXNDYWNoZSAmJlxuICAgIChudWxsICE9IGN1cnJlbnQgJiYgY3VycmVudC5yZWZDb3VudCsrLFxuICAgIG51bGwgIT0gcHJldmlvdXNDYWNoZSAmJiByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSkpO1xufVxuZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIGN1cnJlbnQgPSBudWxsO1xuICBudWxsICE9PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgKGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGUpO1xuICBmaW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgZmluaXNoZWRXb3JrICE9PSBjdXJyZW50ICYmXG4gICAgKGZpbmlzaGVkV29yay5yZWZDb3VudCsrLCBudWxsICE9IGN1cnJlbnQgJiYgcmVsZWFzZUNhY2hlKGN1cnJlbnQpKTtcbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICByb290LFxuICBwYXJlbnRGaWJlcixcbiAgY29tbWl0dGVkTGFuZXMsXG4gIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4pIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHBhcmVudEZpYmVyLFxuICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICksXG4gICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihcbiAgZmluaXNoZWRSb290LFxuICBmaW5pc2hlZFdvcmssXG4gIGNvbW1pdHRlZExhbmVzLFxuICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuKSB7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgMTE6XG4gICAgY2FzZSAxNTpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApO1xuICAgICAgZmxhZ3MgJiAyMDQ4ICYmIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoOSwgZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApO1xuICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICgoZmluaXNoZWRSb290ID0gbnVsbCksXG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAoZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgKGZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgZmluaXNoZWRXb3JrICE9PSBmaW5pc2hlZFJvb3QgJiZcbiAgICAgICAgICAoZmluaXNoZWRXb3JrLnJlZkNvdW50KyssXG4gICAgICAgICAgbnVsbCAhPSBmaW5pc2hlZFJvb3QgJiYgcmVsZWFzZUNhY2hlKGZpbmlzaGVkUm9vdCkpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICBpZiAoZmxhZ3MgJiAyMDQ4KSB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgZmluaXNoZWRSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgX2ZpbmlzaGVkV29yayRtZW1vaXplMiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgaWQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLmlkLFxuICAgICAgICAgICAgb25Qb3N0Q29tbWl0ID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblBvc3RDb21taXQ7XG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb25Qb3N0Q29tbWl0ICYmXG4gICAgICAgICAgICBvblBvc3RDb21taXQoXG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBudWxsID09PSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlID8gXCJtb3VudFwiIDogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgICAgLTBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIzOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMjpcbiAgICAgIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgbnVsbCAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGVcbiAgICAgICAgPyBfZmluaXNoZWRXb3JrJG1lbW9pemUyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaylcbiAgICAgICAgOiBfZmluaXNoZWRXb3JrJG1lbW9pemUyLl92aXNpYmlsaXR5ICYgNFxuICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnNcbiAgICAgICAgICAgIClcbiAgICAgICAgICA6ICgoX2ZpbmlzaGVkV29yayRtZW1vaXplMi5fdmlzaWJpbGl0eSB8PSA0KSxcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICAgICAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICAgICAgICAgICkpO1xuICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSxcbiAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjQ6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9uc1xuICAgICAgKTtcbiAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLCBmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zXG4gICAgICApO1xuICB9XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gIGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgcGFyZW50RmliZXIsXG4gIGNvbW1pdHRlZExhbmVzJGpzY29tcCQwLFxuICBjb21taXR0ZWRUcmFuc2l0aW9ucyRqc2NvbXAkMCxcbiAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuKSB7XG4gIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPVxuICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgMCAhPT0gKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KTtcbiAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKSB7XG4gICAgdmFyIGZpbmlzaGVkUm9vdCA9IGZpbmlzaGVkUm9vdCRqc2NvbXAkMCxcbiAgICAgIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyLFxuICAgICAgY29tbWl0dGVkTGFuZXMgPSBjb21taXR0ZWRMYW5lcyRqc2NvbXAkMCxcbiAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zID0gY29tbWl0dGVkVHJhbnNpdGlvbnMkanNjb21wJDAsXG4gICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgZmluaXNoZWRSb290LFxuICAgICAgICAgIGZpbmlzaGVkV29yayxcbiAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICBjb21taXR0ZWRUcmFuc2l0aW9ucyxcbiAgICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzXG4gICAgICAgICk7XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoOCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIzOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlXG4gICAgICAgICAgPyBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDRcbiAgICAgICAgICAgID8gcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICA6ICgoaW5zdGFuY2UuX3Zpc2liaWxpdHkgfD0gNCksXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoXG4gICAgICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgICAgICBjb21taXR0ZWRMYW5lcyxcbiAgICAgICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgICAgICkpO1xuICAgICAgICBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmXG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay5hbHRlcm5hdGUsXG4gICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjQ6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhcbiAgICAgICAgICBmaW5pc2hlZFJvb3QsXG4gICAgICAgICAgZmluaXNoZWRXb3JrLFxuICAgICAgICAgIGNvbW1pdHRlZExhbmVzLFxuICAgICAgICAgIGNvbW1pdHRlZFRyYW5zaXRpb25zLFxuICAgICAgICAgIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHNcbiAgICAgICAgKTtcbiAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJlxuICAgICAgICAgIGZsYWdzICYgMjA0OCAmJlxuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKFxuICAgICAgICAgIGZpbmlzaGVkUm9vdCxcbiAgICAgICAgICBmaW5pc2hlZFdvcmssXG4gICAgICAgICAgY29tbWl0dGVkTGFuZXMsXG4gICAgICAgICAgY29tbWl0dGVkVHJhbnNpdGlvbnMsXG4gICAgICAgICAgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0c1xuICAgICAgICApO1xuICAgIH1cbiAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhcbiAgZmluaXNoZWRSb290JGpzY29tcCQwLFxuICBwYXJlbnRGaWJlclxuKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAxMDI1NilcbiAgICBmb3IgKHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuY2hpbGQ7IG51bGwgIT09IHBhcmVudEZpYmVyOyApIHtcbiAgICAgIHZhciBmaW5pc2hlZFJvb3QgPSBmaW5pc2hlZFJvb3QkanNjb21wJDAsXG4gICAgICAgIGZpbmlzaGVkV29yayA9IHBhcmVudEZpYmVyLFxuICAgICAgICBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgZmxhZ3MgJiAyMDQ4ICYmXG4gICAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLFxuICAgICAgICAgICAgICBmaW5pc2hlZFdvcmtcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBmbGFncyAmIDIwNDggJiZcbiAgICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGZpbmlzaGVkV29yay5hbHRlcm5hdGUsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIuc2libGluZztcbiAgICB9XG59XG52YXIgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IDgxOTI7XG5mdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpXG4gICAgZm9yIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLmNoaWxkOyBudWxsICE9PSBwYXJlbnRGaWJlcjsgKVxuICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIocGFyZW50RmliZXIpLFxuICAgICAgICAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nKTtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICBmaWJlci5mbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcgJiZcbiAgICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICBzdXNwZW5kUmVzb3VyY2UoXG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QsXG4gICAgICAgICAgZmliZXIubWVtb2l6ZWRTdGF0ZSxcbiAgICAgICAgICBmaWJlci5tZW1vaXplZFByb3BzXG4gICAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDU6XG4gICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgIGNhc2UgNDpcbiAgICAgIHZhciBwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgbnVsbCA9PT0gZmliZXIubWVtb2l6ZWRTdGF0ZSAmJlxuICAgICAgICAoKHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGZpYmVyLmFsdGVybmF0ZSksXG4gICAgICAgIG51bGwgIT09IHByZXZpb3VzSG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICBudWxsICE9PSBwcmV2aW91c0hvaXN0YWJsZVJvb3QubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgID8gKChwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBzdXNwZW5zZXlDb21taXRGbGFnKSxcbiAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gMTY3NzcyMTYpLFxuICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKSxcbiAgICAgICAgICAgIChzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldmlvdXNIb2lzdGFibGVSb290KSlcbiAgICAgICAgICA6IHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcikpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKSB7XG4gIHZhciBwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoXG4gICAgbnVsbCAhPT0gcHJldmlvdXNGaWJlciAmJlxuICAgICgocGFyZW50RmliZXIgPSBwcmV2aW91c0ZpYmVyLmNoaWxkKSwgbnVsbCAhPT0gcGFyZW50RmliZXIpXG4gICkge1xuICAgIHByZXZpb3VzRmliZXIuY2hpbGQgPSBudWxsO1xuICAgIGRvXG4gICAgICAocHJldmlvdXNGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpLFxuICAgICAgICAocGFyZW50RmliZXIuc2libGluZyA9IG51bGwpLFxuICAgICAgICAocGFyZW50RmliZXIgPSBwcmV2aW91c0ZpYmVyKTtcbiAgICB3aGlsZSAobnVsbCAhPT0gcGFyZW50RmliZXIpO1xuICB9XG59XG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKHBhcmVudEZpYmVyKSB7XG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG4gIGlmICgwICE9PSAocGFyZW50RmliZXIuZmxhZ3MgJiAxNikpIHtcbiAgICBpZiAobnVsbCAhPT0gZGVsZXRpb25zKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG4gICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICAgICAgICAgIGNoaWxkVG9EZWxldGUsXG4gICAgICAgICAgcGFyZW50RmliZXJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gIH1cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIDEwMjU2KVxuICAgIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7IClcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihwYXJlbnRGaWJlciksXG4gICAgICAgIChwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnNpYmxpbmcpO1xufVxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIDA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE1OlxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgZmluaXNoZWRXb3JrLmZsYWdzICYgMjA0OCAmJlxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoOSwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTI6XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIG51bGwgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICYmXG4gICAgICBpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIDQgJiZcbiAgICAgIChudWxsID09PSBmaW5pc2hlZFdvcmsucmV0dXJuIHx8IDEzICE9PSBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZylcbiAgICAgICAgPyAoKGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IC01KSxcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yaykpXG4gICAgICAgIDogcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuICBpZiAoMCAhPT0gKHBhcmVudEZpYmVyLmZsYWdzICYgMTYpKSB7XG4gICAgaWYgKG51bGwgIT09IGRlbGV0aW9ucylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldO1xuICAgICAgICBuZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihcbiAgICAgICAgICBjaGlsZFRvRGVsZXRlLFxuICAgICAgICAgIHBhcmVudEZpYmVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpO1xuICB9XG4gIGZvciAocGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5jaGlsZDsgbnVsbCAhPT0gcGFyZW50RmliZXI7ICkge1xuICAgIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyO1xuICAgIHN3aXRjaCAoZGVsZXRpb25zLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg4LCBkZWxldGlvbnMsIGRlbGV0aW9ucy5yZXR1cm4pO1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGRlbGV0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMjpcbiAgICAgICAgaSA9IGRlbGV0aW9ucy5zdGF0ZU5vZGU7XG4gICAgICAgIGkuX3Zpc2liaWxpdHkgJiA0ICYmXG4gICAgICAgICAgKChpLl92aXNpYmlsaXR5ICY9IC01KSxcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGRlbGV0aW9ucykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZGVsZXRpb25zKTtcbiAgICB9XG4gICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5zaWJsaW5nO1xuICB9XG59XG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKFxuICBkZWxldGVkU3VidHJlZVJvb3QsXG4gIG5lYXJlc3RNb3VudGVkQW5jZXN0b3Jcbikge1xuICBmb3IgKDsgbnVsbCAhPT0gbmV4dEVmZmVjdDsgKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSAwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCg4LCBmaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyMzpcbiAgICAgIGNhc2UgMjI6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBudWxsICE9PSBmaWJlci5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gZmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2xcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGNhY2hlID0gZmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICBudWxsICE9IGNhY2hlICYmIGNhY2hlLnJlZkNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZWxlYXNlQ2FjaGUoZmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgfVxuICAgIGNhY2hlID0gZmliZXIuY2hpbGQ7XG4gICAgaWYgKG51bGwgIT09IGNhY2hlKSAoY2FjaGUucmV0dXJuID0gZmliZXIpLCAobmV4dEVmZmVjdCA9IGNhY2hlKTtcbiAgICBlbHNlXG4gICAgICBhOiBmb3IgKGZpYmVyID0gZGVsZXRlZFN1YnRyZWVSb290OyBudWxsICE9PSBuZXh0RWZmZWN0OyApIHtcbiAgICAgICAgY2FjaGUgPSBuZXh0RWZmZWN0O1xuICAgICAgICB2YXIgc2libGluZyA9IGNhY2hlLnNpYmxpbmcsXG4gICAgICAgICAgcmV0dXJuRmliZXIgPSBjYWNoZS5yZXR1cm47XG4gICAgICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGNhY2hlKTtcbiAgICAgICAgaWYgKGNhY2hlID09PSBmaWJlcikge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT09IHNpYmxpbmcpIHtcbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dEVmZmVjdCA9IHJldHVybkZpYmVyO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuc2libGluZyA9XG4gICAgdGhpcy5jaGlsZCA9XG4gICAgdGhpcy5yZXR1cm4gPVxuICAgIHRoaXMuc3RhdGVOb2RlID1cbiAgICB0aGlzLnR5cGUgPVxuICAgIHRoaXMuZWxlbWVudFR5cGUgPVxuICAgICAgbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMucmVmQ2xlYW51cCA9IHRoaXMucmVmID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID1cbiAgICB0aGlzLm1lbW9pemVkU3RhdGUgPVxuICAgIHRoaXMudXBkYXRlUXVldWUgPVxuICAgIHRoaXMubWVtb2l6ZWRQcm9wcyA9XG4gICAgICBudWxsO1xuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLnN1YnRyZWVGbGFncyA9IHRoaXMuZmxhZ3MgPSAwO1xuICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gIHRoaXMuY2hpbGRMYW5lcyA9IHRoaXMubGFuZXMgPSAwO1xuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckltcGxDbGFzcyh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xufVxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICBDb21wb25lbnQgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISghQ29tcG9uZW50IHx8ICFDb21wb25lbnQuaXNSZWFjdENvbXBvbmVudCk7XG59XG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMpIHtcbiAgdmFyIHdvcmtJblByb2dyZXNzID0gY3VycmVudC5hbHRlcm5hdGU7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzXG4gICAgPyAoKHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoXG4gICAgICAgIGN1cnJlbnQudGFnLFxuICAgICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICAgIGN1cnJlbnQua2V5LFxuICAgICAgICBjdXJyZW50Lm1vZGVcbiAgICAgICkpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZSksXG4gICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQpLFxuICAgICAgKGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3MpKVxuICAgIDogKCh3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHMpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzID0gMCksXG4gICAgICAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gMCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbCkpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiAzMTQ1NzI4MDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgcGVuZGluZ1Byb3BzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9XG4gICAgbnVsbCA9PT0gcGVuZGluZ1Byb3BzXG4gICAgICA/IG51bGxcbiAgICAgIDogeyBsYW5lczogcGVuZGluZ1Byb3BzLmxhbmVzLCBmaXJzdENvbnRleHQ6IHBlbmRpbmdQcm9wcy5maXJzdENvbnRleHQgfTtcbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcbiAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuZnVuY3Rpb24gcmVzZXRXb3JrSW5Qcm9ncmVzcyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gMzE0NTcyODI7XG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICBudWxsID09PSBjdXJyZW50XG4gICAgPyAoKHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSAwKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBudWxsKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsKSlcbiAgICA6ICgod29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzKSxcbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDApLFxuICAgICAgKHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHMpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpLFxuICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZSksXG4gICAgICAod29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZSksXG4gICAgICAocmVuZGVyTGFuZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcyksXG4gICAgICAod29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID1cbiAgICAgICAgbnVsbCA9PT0gcmVuZGVyTGFuZXNcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgbGFuZXM6IHJlbmRlckxhbmVzLmxhbmVzLFxuICAgICAgICAgICAgICBmaXJzdENvbnRleHQ6IHJlbmRlckxhbmVzLmZpcnN0Q29udGV4dFxuICAgICAgICAgICAgfSkpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMoXG4gIHR5cGUsXG4gIGtleSxcbiAgcGVuZGluZ1Byb3BzLFxuICBvd25lcixcbiAgbW9kZSxcbiAgbGFuZXNcbikge1xuICB2YXIgZmliZXJUYWcgPSAwO1xuICBvd25lciA9IHR5cGU7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgKGZpYmVyVGFnID0gMSk7XG4gIGVsc2UgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKVxuICAgIGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZShcbiAgICAgIHR5cGUsXG4gICAgICBwZW5kaW5nUHJvcHMsXG4gICAgICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudFxuICAgIClcbiAgICAgID8gMjZcbiAgICAgIDogXCJodG1sXCIgPT09IHR5cGUgfHwgXCJoZWFkXCIgPT09IHR5cGUgfHwgXCJib2R5XCIgPT09IHR5cGVcbiAgICAgICAgPyAyN1xuICAgICAgICA6IDU7XG4gIGVsc2VcbiAgICBhOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gODtcbiAgICAgICAgbW9kZSB8PSAyNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHR5cGUgPSBjcmVhdGVGaWJlckltcGxDbGFzcygxMiwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUgfCAyKSksXG4gICAgICAgICAgKHR5cGUuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFKSxcbiAgICAgICAgICAodHlwZS5sYW5lcyA9IGxhbmVzKSxcbiAgICAgICAgICB0eXBlXG4gICAgICAgICk7XG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgKHR5cGUgPSBjcmVhdGVGaWJlckltcGxDbGFzcygxMywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpKSxcbiAgICAgICAgICAodHlwZS5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEUpLFxuICAgICAgICAgICh0eXBlLmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh0eXBlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoMTksIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSksXG4gICAgICAgICAgKHR5cGUuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUpLFxuICAgICAgICAgICh0eXBlLmxhbmVzID0gbGFuZXMpLFxuICAgICAgICAgIHR5cGVcbiAgICAgICAgKTtcbiAgICAgIGNhc2UgUkVBQ1RfT0ZGU0NSRUVOX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJiBudWxsICE9PSB0eXBlKVxuICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gMTA7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gOTtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgZmliZXJUYWcgPSAxMTtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBmaWJlclRhZyA9IDE0O1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGZpYmVyVGFnID0gMTY7XG4gICAgICAgICAgICAgIG93bmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyVGFnID0gMjk7XG4gICAgICAgIHBlbmRpbmdQcm9wcyA9IEVycm9yKFxuICAgICAgICAgIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTMwLCBudWxsID09PSB0eXBlID8gXCJudWxsXCIgOiB0eXBlb2YgdHlwZSwgXCJcIilcbiAgICAgICAgKTtcbiAgICAgICAgb3duZXIgPSBudWxsO1xuICAgIH1cbiAga2V5ID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAga2V5LmVsZW1lbnRUeXBlID0gdHlwZTtcbiAga2V5LnR5cGUgPSBvd25lcjtcbiAga2V5LmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICBlbGVtZW50cyA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDcsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBlbGVtZW50cy5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZWxlbWVudHM7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHBlbmRpbmdQcm9wcyA9IGNyZWF0ZUZpYmVySW1wbENsYXNzKDIyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIHBlbmRpbmdQcm9wcy5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICBwZW5kaW5nUHJvcHMubGFuZXMgPSBsYW5lcztcbiAgdmFyIHByaW1hcnlDaGlsZEluc3RhbmNlID0ge1xuICAgIF92aXNpYmlsaXR5OiAxLFxuICAgIF9wZW5kaW5nVmlzaWJpbGl0eTogMSxcbiAgICBfcGVuZGluZ01hcmtlcnM6IG51bGwsXG4gICAgX3JldHJ5Q2FjaGU6IG51bGwsXG4gICAgX3RyYW5zaXRpb25zOiBudWxsLFxuICAgIF9jdXJyZW50OiBudWxsLFxuICAgIGRldGFjaDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGZpYmVyID0gcHJpbWFyeUNoaWxkSW5zdGFuY2UuX2N1cnJlbnQ7XG4gICAgICBpZiAobnVsbCA9PT0gZmliZXIpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDU2KSk7XG4gICAgICBpZiAoMCA9PT0gKHByaW1hcnlDaGlsZEluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIDIpKSB7XG4gICAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKTtcbiAgICAgICAgbnVsbCAhPT0gcm9vdCAmJlxuICAgICAgICAgICgocHJpbWFyeUNoaWxkSW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5IHw9IDIpLFxuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXR0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZmliZXIgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZS5fY3VycmVudDtcbiAgICAgIGlmIChudWxsID09PSBmaWJlcikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NTYpKTtcbiAgICAgIGlmICgwICE9PSAocHJpbWFyeUNoaWxkSW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgMikpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIDIpO1xuICAgICAgICBudWxsICE9PSByb290ICYmXG4gICAgICAgICAgKChwcmltYXJ5Q2hpbGRJbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJj0gLTMpLFxuICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgMikpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcGVuZGluZ1Byb3BzLnN0YXRlTm9kZSA9IHByaW1hcnlDaGlsZEluc3RhbmNlO1xuICByZXR1cm4gcGVuZGluZ1Byb3BzO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICBjb250ZW50ID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoNiwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGNvbnRlbnQubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICBtb2RlID0gY3JlYXRlRmliZXJJbXBsQ2xhc3MoXG4gICAgNCxcbiAgICBudWxsICE9PSBwb3J0YWwuY2hpbGRyZW4gPyBwb3J0YWwuY2hpbGRyZW4gOiBbXSxcbiAgICBwb3J0YWwua2V5LFxuICAgIG1vZGVcbiAgKTtcbiAgbW9kZS5sYW5lcyA9IGxhbmVzO1xuICBtb2RlLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gbW9kZTtcbn1cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gNDtcbn1cbmZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UpIHtcbiAgaWYgKFwic3R5bGVzaGVldFwiICE9PSByZXNvdXJjZS50eXBlIHx8IDAgIT09IChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgNCkpXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gLTE2Nzc3MjE3O1xuICBlbHNlIGlmICgoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDE2Nzc3MjE2KSwgIXByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkpKSB7XG4gICAgcmVzb3VyY2UgPSBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xuICAgIGlmIChcbiAgICAgIG51bGwgIT09IHJlc291cmNlICYmXG4gICAgICAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNDE5NDE3NikgPT09XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lc1xuICAgICAgICA/IG51bGwgIT09IHNoZWxsQm91bmRhcnlcbiAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNjI5MTQ1NjApICE9PVxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAgIDAgPT09ICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDUzNjg3MDkxMikpIHx8XG4gICAgICAgICAgcmVzb3VyY2UgIT09IHNoZWxsQm91bmRhcnkpXG4gICAgKVxuICAgICAgdGhyb3cgKFxuICAgICAgICAoKHN1c3BlbmRlZFRoZW5hYmxlID0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlKSxcbiAgICAgICAgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uKVxuICAgICAgKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyO1xuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCByZXRyeVF1ZXVlKSB7XG4gIG51bGwgIT09IHJldHJ5UXVldWUgJiYgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDQpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIDE2Mzg0ICYmXG4gICAgKChyZXRyeVF1ZXVlID1cbiAgICAgIDIyICE9PSB3b3JrSW5Qcm9ncmVzcy50YWcgPyBjbGFpbU5leHRSZXRyeUxhbmUoKSA6IDUzNjg3MDkxMiksXG4gICAgKHdvcmtJblByb2dyZXNzLmxhbmVzIHw9IHJldHJ5UXVldWUpLFxuICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgfD0gcmV0cnlRdWV1ZSkpO1xufVxuZnVuY3Rpb24gY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spIHtcbiAgaWYgKCFpc0h5ZHJhdGluZylcbiAgICBzd2l0Y2ggKHJlbmRlclN0YXRlLnRhaWxNb2RlKSB7XG4gICAgICBjYXNlIFwiaGlkZGVuXCI6XG4gICAgICAgIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7IG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjazsgKVxuICAgICAgICAgIG51bGwgIT09IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2spLFxuICAgICAgICAgICAgKGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayA9IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjay5zaWJsaW5nKTtcbiAgICAgICAgbnVsbCA9PT0gbGFzdFRhaWxOb2RlXG4gICAgICAgICAgPyAocmVuZGVyU3RhdGUudGFpbCA9IG51bGwpXG4gICAgICAgICAgOiAobGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiY29sbGFwc2VkXCI6XG4gICAgICAgIGxhc3RUYWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIGZvciAodmFyIGxhc3RUYWlsTm9kZSQxMzEgPSBudWxsOyBudWxsICE9PSBsYXN0VGFpbE5vZGU7IClcbiAgICAgICAgICBudWxsICE9PSBsYXN0VGFpbE5vZGUuYWx0ZXJuYXRlICYmIChsYXN0VGFpbE5vZGUkMTMxID0gbGFzdFRhaWxOb2RlKSxcbiAgICAgICAgICAgIChsYXN0VGFpbE5vZGUgPSBsYXN0VGFpbE5vZGUuc2libGluZyk7XG4gICAgICAgIG51bGwgPT09IGxhc3RUYWlsTm9kZSQxMzFcbiAgICAgICAgICA/IGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayB8fCBudWxsID09PSByZW5kZXJTdGF0ZS50YWlsXG4gICAgICAgICAgICA/IChyZW5kZXJTdGF0ZS50YWlsID0gbnVsbClcbiAgICAgICAgICAgIDogKHJlbmRlclN0YXRlLnRhaWwuc2libGluZyA9IG51bGwpXG4gICAgICAgICAgOiAobGFzdFRhaWxOb2RlJDEzMS5zaWJsaW5nID0gbnVsbCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnViYmxlUHJvcGVydGllcyhjb21wbGV0ZWRXb3JrKSB7XG4gIHZhciBkaWRCYWlsb3V0ID1cbiAgICAgIG51bGwgIT09IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICYmXG4gICAgICBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZCxcbiAgICBuZXdDaGlsZExhbmVzID0gMCxcbiAgICBzdWJ0cmVlRmxhZ3MgPSAwO1xuICBpZiAoZGlkQmFpbG91dClcbiAgICBmb3IgKHZhciBjaGlsZCQxMzIgPSBjb21wbGV0ZWRXb3JrLmNoaWxkOyBudWxsICE9PSBjaGlsZCQxMzI7IClcbiAgICAgIChuZXdDaGlsZExhbmVzIHw9IGNoaWxkJDEzMi5sYW5lcyB8IGNoaWxkJDEzMi5jaGlsZExhbmVzKSxcbiAgICAgICAgKHN1YnRyZWVGbGFncyB8PSBjaGlsZCQxMzIuc3VidHJlZUZsYWdzICYgMzE0NTcyODApLFxuICAgICAgICAoc3VidHJlZUZsYWdzIHw9IGNoaWxkJDEzMi5mbGFncyAmIDMxNDU3MjgwKSxcbiAgICAgICAgKGNoaWxkJDEzMi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgKGNoaWxkJDEzMiA9IGNoaWxkJDEzMi5zaWJsaW5nKTtcbiAgZWxzZVxuICAgIGZvciAoY2hpbGQkMTMyID0gY29tcGxldGVkV29yay5jaGlsZDsgbnVsbCAhPT0gY2hpbGQkMTMyOyApXG4gICAgICAobmV3Q2hpbGRMYW5lcyB8PSBjaGlsZCQxMzIubGFuZXMgfCBjaGlsZCQxMzIuY2hpbGRMYW5lcyksXG4gICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQkMTMyLnN1YnRyZWVGbGFncyksXG4gICAgICAgIChzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQkMTMyLmZsYWdzKSxcbiAgICAgICAgKGNoaWxkJDEzMi5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrKSxcbiAgICAgICAgKGNoaWxkJDEzMiA9IGNoaWxkJDEzMi5zaWJsaW5nKTtcbiAgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3MgfD0gc3VidHJlZUZsYWdzO1xuICBjb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXMgPSBuZXdDaGlsZExhbmVzO1xuICByZXR1cm4gZGlkQmFpbG91dDtcbn1cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSAxNjpcbiAgICBjYXNlIDE1OlxuICAgIGNhc2UgMDpcbiAgICBjYXNlIDExOlxuICAgIGNhc2UgNzpcbiAgICBjYXNlIDg6XG4gICAgY2FzZSAxMjpcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxNDpcbiAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksIG51bGw7XG4gICAgY2FzZSAzOlxuICAgICAgcmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBuZXdQcm9wcyA9IG51bGw7XG4gICAgICBudWxsICE9PSBjdXJyZW50ICYmIChuZXdQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZSk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCk7XG4gICAgICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQpO1xuICAgICAgcG9wSG9zdENvbnRhaW5lcigpO1xuICAgICAgcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgJiZcbiAgICAgICAgKChyZW5kZXJMYW5lcy5jb250ZXh0ID0gcmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQpLFxuICAgICAgICAocmVuZGVyTGFuZXMucGVuZGluZ0NvbnRleHQgPSBudWxsKSk7XG4gICAgICBpZiAobnVsbCA9PT0gY3VycmVudCB8fCBudWxsID09PSBjdXJyZW50LmNoaWxkKVxuICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA/IG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgOiBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudC5tZW1vaXplZFN0YXRlLmlzRGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpKSB8fFxuICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAxMDI0KSxcbiAgICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgICAocXVldWVSZWNvdmVyYWJsZUVycm9ycyhoeWRyYXRpb25FcnJvcnMpLFxuICAgICAgICAgICAgICAoaHlkcmF0aW9uRXJyb3JzID0gbnVsbCkpKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAyNjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChyZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUpLFxuICAgICAgICBudWxsID09PSBjdXJyZW50XG4gICAgICAgICAgPyAobWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICBudWxsICE9PSByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICA/IChidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpKVxuICAgICAgICAgIDogcmVuZGVyTGFuZXNcbiAgICAgICAgICAgID8gcmVuZGVyTGFuZXMgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZVxuICAgICAgICAgICAgICA/IChtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpXG4gICAgICAgICAgICA6IChjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNykpLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMjc6XG4gICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZW5kZXJMYW5lcyA9IHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICBpZiAobnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgY3VycmVudC5tZW1vaXplZFByb3BzICE9PSBuZXdQcm9wcyAmJiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgaWYgKG51bGwgPT09IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTY2KSk7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA/IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpXG4gICAgICAgICAgOiAoKGN1cnJlbnQgPSByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudCksXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNTpcbiAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJlbmRlckxhbmVzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgIGlmIChudWxsICE9PSBjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICBpZiAobnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNjYpKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gICAgICAgIGlmIChwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpXG4gICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIoXG4gICAgICAgICAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgICBzd2l0Y2ggKGN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgY3VycmVudCA9IHR5cGUuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgY3VycmVudCA9IHR5cGUuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICAgICAgICAgICAgICAgIHJlbmRlckxhbmVzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3dpdGNoIChyZW5kZXJMYW5lcykge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdmdcIjpcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0eXBlLmNyZWF0ZUVsZW1lbnROUyhcbiAgICAgICAgICAgICAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXRoXCI6XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdHlwZS5jcmVhdGVFbGVtZW50TlMoXG4gICAgICAgICAgICAgICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJMYW5lc1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSB0eXBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50LmlubmVySFRNTCA9IFwiPHNjcmlwdD5cXHgzYy9zY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yZW1vdmVDaGlsZChjdXJyZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgID8gdHlwZS5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgaXM6IG5ld1Byb3BzLmlzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgOiB0eXBlLmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIik7XG4gICAgICAgICAgICAgICAgICBuZXdQcm9wcy5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICA/IChjdXJyZW50Lm11bHRpcGxlID0gITApXG4gICAgICAgICAgICAgICAgICAgIDogbmV3UHJvcHMuc2l6ZSAmJiAoY3VycmVudC5zaXplID0gbmV3UHJvcHMuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgY3VycmVudCA9XG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBuZXdQcm9wcy5pc1xuICAgICAgICAgICAgICAgICAgICAgID8gdHlwZS5jcmVhdGVFbGVtZW50KHJlbmRlckxhbmVzLCB7IGlzOiBuZXdQcm9wcy5pcyB9KVxuICAgICAgICAgICAgICAgICAgICAgIDogdHlwZS5jcmVhdGVFbGVtZW50KHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgY3VycmVudFtpbnRlcm5hbFByb3BzS2V5XSA9IG5ld1Byb3BzO1xuICAgICAgICAgIGE6IGZvciAodHlwZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkOyBudWxsICE9PSB0eXBlOyApIHtcbiAgICAgICAgICAgIGlmICg1ID09PSB0eXBlLnRhZyB8fCA2ID09PSB0eXBlLnRhZylcbiAgICAgICAgICAgICAgY3VycmVudC5hcHBlbmRDaGlsZCh0eXBlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICBlbHNlIGlmICg0ICE9PSB0eXBlLnRhZyAmJiAyNyAhPT0gdHlwZS50YWcgJiYgbnVsbCAhPT0gdHlwZS5jaGlsZCkge1xuICAgICAgICAgICAgICB0eXBlLmNoaWxkLnJldHVybiA9IHR5cGU7XG4gICAgICAgICAgICAgIHR5cGUgPSB0eXBlLmNoaWxkO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSB3b3JrSW5Qcm9ncmVzcykgYnJlYWsgYTtcbiAgICAgICAgICAgIGZvciAoOyBudWxsID09PSB0eXBlLnNpYmxpbmc7ICkge1xuICAgICAgICAgICAgICBpZiAobnVsbCA9PT0gdHlwZS5yZXR1cm4gfHwgdHlwZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIHR5cGUgPSB0eXBlLnJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUuc2libGluZy5yZXR1cm4gPSB0eXBlLnJldHVybjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLnNpYmxpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgICAgYTogc3dpdGNoIChcbiAgICAgICAgICAgIChzZXRJbml0aWFsUHJvcGVydGllcyhjdXJyZW50LCByZW5kZXJMYW5lcywgbmV3UHJvcHMpLCByZW5kZXJMYW5lcylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNhc2UgXCJidXR0b25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSAhIW5ld1Byb3BzLmF1dG9Gb2N1cztcbiAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgIGNhc2UgXCJpbWdcIjpcbiAgICAgICAgICAgICAgY3VycmVudCA9ICEwO1xuICAgICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY3VycmVudCA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50ICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IC0xNjc3NzIxNztcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNjpcbiAgICAgIGlmIChjdXJyZW50ICYmIG51bGwgIT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICBjdXJyZW50Lm1lbW9pemVkUHJvcHMgIT09IG5ld1Byb3BzICYmIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChcInN0cmluZ1wiICE9PSB0eXBlb2YgbmV3UHJvcHMgJiYgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMTY2KSk7XG4gICAgICAgIGN1cnJlbnQgPSByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50O1xuICAgICAgICBpZiAocG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICByZW5kZXJMYW5lcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgbmV3UHJvcHMgPSBudWxsO1xuICAgICAgICAgIHR5cGUgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgICBpZiAobnVsbCAhPT0gdHlwZSlcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIG5ld1Byb3BzID0gdHlwZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICBjdXJyZW50ID1cbiAgICAgICAgICAgIGN1cnJlbnQubm9kZVZhbHVlID09PSByZW5kZXJMYW5lcyB8fFxuICAgICAgICAgICAgKG51bGwgIT09IG5ld1Byb3BzICYmICEwID09PSBuZXdQcm9wcy5zdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHx8XG4gICAgICAgICAgICBjaGVja0ZvclVubWF0Y2hlZFRleHQoY3VycmVudC5ub2RlVmFsdWUsIHJlbmRlckxhbmVzKVxuICAgICAgICAgICAgICA/ICEwXG4gICAgICAgICAgICAgIDogITE7XG4gICAgICAgICAgY3VycmVudCB8fCB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2god29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAoY3VycmVudCA9XG4gICAgICAgICAgICBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIoY3VycmVudCkuY3JlYXRlVGV4dE5vZGUoXG4gICAgICAgICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgICApKSxcbiAgICAgICAgICAgIChjdXJyZW50W2ludGVybmFsSW5zdGFuY2VLZXldID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlIDEzOlxuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKFxuICAgICAgICBudWxsID09PSBjdXJyZW50IHx8XG4gICAgICAgIChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgJiZcbiAgICAgICAgICBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZGVoeWRyYXRlZClcbiAgICAgICkge1xuICAgICAgICB0eXBlID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAobnVsbCAhPT0gbmV3UHJvcHMgJiYgbnVsbCAhPT0gbmV3UHJvcHMuZGVoeWRyYXRlZCkge1xuICAgICAgICAgIGlmIChudWxsID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzE4KSk7XG4gICAgICAgICAgICB0eXBlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHR5cGUgPSBudWxsICE9PSB0eXBlID8gdHlwZS5kZWh5ZHJhdGVkIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghdHlwZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMTcpKTtcbiAgICAgICAgICAgIHR5cGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSxcbiAgICAgICAgICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgMTI4KSAmJlxuICAgICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA0KTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB0eXBlID0gITE7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIG51bGwgIT09IGh5ZHJhdGlvbkVycm9ycyAmJlxuICAgICAgICAgICAgKHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKSwgKGh5ZHJhdGlvbkVycm9ycyA9IG51bGwpKSxcbiAgICAgICAgICAgICh0eXBlID0gITApO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAyNTYpXG4gICAgICAgICAgICByZXR1cm4gcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKSwgd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGlmICgwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpKVxuICAgICAgICByZXR1cm4gKHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXMpLCB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHJlbmRlckxhbmVzID0gbnVsbCAhPT0gbmV3UHJvcHM7XG4gICAgICBjdXJyZW50ID0gbnVsbCAhPT0gY3VycmVudCAmJiBudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAocmVuZGVyTGFuZXMpIHtcbiAgICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgdHlwZSA9IG51bGw7XG4gICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZSAmJlxuICAgICAgICAgIG51bGwgIT09IG5ld1Byb3BzLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICYmXG4gICAgICAgICAgKHR5cGUgPSBuZXdQcm9wcy5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICAgIHZhciBjYWNoZSQxNDQgPSBudWxsO1xuICAgICAgICBudWxsICE9PSBuZXdQcm9wcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAoY2FjaGUkMTQ0ID0gbmV3UHJvcHMubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCk7XG4gICAgICAgIGNhY2hlJDE0NCAhPT0gdHlwZSAmJiAobmV3UHJvcHMuZmxhZ3MgfD0gMjA0OCk7XG4gICAgICB9XG4gICAgICByZW5kZXJMYW5lcyAhPT0gY3VycmVudCAmJlxuICAgICAgICByZW5kZXJMYW5lcyAmJlxuICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQuZmxhZ3MgfD0gODE5Mik7XG4gICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoKSxcbiAgICAgICAgbnVsbCA9PT0gY3VycmVudCAmJlxuICAgICAgICAgIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKSxcbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLnR5cGUpLCBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDE5OlxuICAgICAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IpO1xuICAgICAgdHlwZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICBpZiAobnVsbCA9PT0gdHlwZSkgcmV0dXJuIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLCBudWxsO1xuICAgICAgbmV3UHJvcHMgPSAwICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpO1xuICAgICAgY2FjaGUkMTQ0ID0gdHlwZS5yZW5kZXJpbmc7XG4gICAgICBpZiAobnVsbCA9PT0gY2FjaGUkMTQ0KVxuICAgICAgICBpZiAobmV3UHJvcHMpIGN1dE9mZlRhaWxJZk5lZWRlZCh0eXBlLCAhMSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDAgIT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgfHxcbiAgICAgICAgICAgIChudWxsICE9PSBjdXJyZW50ICYmIDAgIT09IChjdXJyZW50LmZsYWdzICYgMTI4KSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBmb3IgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gY3VycmVudDsgKSB7XG4gICAgICAgICAgICAgIGNhY2hlJDE0NCA9IGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50KTtcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT09IGNhY2hlJDE0NCkge1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyODtcbiAgICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjYWNoZSQxNDQudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IDA7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IHJlbmRlckxhbmVzO1xuICAgICAgICAgICAgICAgIGZvciAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDsgbnVsbCAhPT0gcmVuZGVyTGFuZXM7IClcbiAgICAgICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MocmVuZGVyTGFuZXMsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICAgICAgICAocmVuZGVyTGFuZXMgPSByZW5kZXJMYW5lcy5zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICBwdXNoKFxuICAgICAgICAgICAgICAgICAgc3VzcGVuc2VTdGFja0N1cnNvcixcbiAgICAgICAgICAgICAgICAgIChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQgJiAxKSB8IDJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5zaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIG51bGwgIT09IHR5cGUudGFpbCAmJlxuICAgICAgICAgICAgbm93KCkgPiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lICYmXG4gICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAobmV3UHJvcHMgPSAhMCksXG4gICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpLFxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmxhbmVzID0gNDE5NDMwNCkpO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFuZXdQcm9wcylcbiAgICAgICAgICBpZiAoKChjdXJyZW50ID0gZmluZEZpcnN0U3VzcGVuZGVkKGNhY2hlJDE0NCkpLCBudWxsICE9PSBjdXJyZW50KSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDEyOCksXG4gICAgICAgICAgICAgIChuZXdQcm9wcyA9ICEwKSxcbiAgICAgICAgICAgICAgKGN1cnJlbnQgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudCksXG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpLFxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITApLFxuICAgICAgICAgICAgICBudWxsID09PSB0eXBlLnRhaWwgJiZcbiAgICAgICAgICAgICAgICBcImhpZGRlblwiID09PSB0eXBlLnRhaWxNb2RlICYmXG4gICAgICAgICAgICAgICAgIWNhY2hlJDE0NC5hbHRlcm5hdGUgJiZcbiAgICAgICAgICAgICAgICAhaXNIeWRyYXRpbmcpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHJldHVybiBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIDIgKiBub3coKSAtIHR5cGUucmVuZGVyaW5nU3RhcnRUaW1lID5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSAmJlxuICAgICAgICAgICAgICA1MzY4NzA5MTIgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgICAgICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMTI4KSxcbiAgICAgICAgICAgICAgKG5ld1Byb3BzID0gITApLFxuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQodHlwZSwgITEpLFxuICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MubGFuZXMgPSA0MTk0MzA0KSk7XG4gICAgICAgIHR5cGUuaXNCYWNrd2FyZHNcbiAgICAgICAgICA/ICgoY2FjaGUkMTQ0LnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCksXG4gICAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjYWNoZSQxNDQpKVxuICAgICAgICAgIDogKChjdXJyZW50ID0gdHlwZS5sYXN0KSxcbiAgICAgICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICAgICAgPyAoY3VycmVudC5zaWJsaW5nID0gY2FjaGUkMTQ0KVxuICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNhY2hlJDE0NCksXG4gICAgICAgICAgICAodHlwZS5sYXN0ID0gY2FjaGUkMTQ0KSk7XG4gICAgICB9XG4gICAgICBpZiAobnVsbCAhPT0gdHlwZS50YWlsKVxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcyA9IHR5cGUudGFpbCksXG4gICAgICAgICAgKHR5cGUucmVuZGVyaW5nID0gd29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAgICh0eXBlLnRhaWwgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nKSxcbiAgICAgICAgICAodHlwZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3coKSksXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBudWxsKSxcbiAgICAgICAgICAoY3VycmVudCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCksXG4gICAgICAgICAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdQcm9wcyA/IChjdXJyZW50ICYgMSkgfCAyIDogY3VycmVudCAmIDEpLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzXG4gICAgICAgICk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgMjI6XG4gICAgY2FzZSAyMzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgIHBvcEhpZGRlbkNvbnRleHQoKSxcbiAgICAgICAgKG5ld1Byb3BzID0gbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnRcbiAgICAgICAgICA/IChudWxsICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpICE9PSBuZXdQcm9wcyAmJlxuICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IDgxOTIpXG4gICAgICAgICAgOiBuZXdQcm9wcyAmJiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gODE5MiksXG4gICAgICAgIG5ld1Byb3BzXG4gICAgICAgICAgPyAwICE9PSAocmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpICYmXG4gICAgICAgICAgICAwID09PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiAxMjgpICYmXG4gICAgICAgICAgICAoYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyksXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiA2ICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSA4MTkyKSlcbiAgICAgICAgICA6IGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICAocmVuZGVyTGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSksXG4gICAgICAgIG51bGwgIT09IHJlbmRlckxhbmVzICYmXG4gICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMucmV0cnlRdWV1ZSksXG4gICAgICAgIChyZW5kZXJMYW5lcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSBjdXJyZW50ICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAmJlxuICAgICAgICAgIChyZW5kZXJMYW5lcyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbCksXG4gICAgICAgIChuZXdQcm9wcyA9IG51bGwpLFxuICAgICAgICBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICYmXG4gICAgICAgICAgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgJiZcbiAgICAgICAgICAobmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sKSxcbiAgICAgICAgbmV3UHJvcHMgIT09IHJlbmRlckxhbmVzICYmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSAyMDQ4KSxcbiAgICAgICAgbnVsbCAhPT0gY3VycmVudCAmJiBwb3AocmVzdW1lZENhY2hlKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI0OlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHJlbmRlckxhbmVzID0gbnVsbCksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgKHJlbmRlckxhbmVzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlKSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZSAhPT0gcmVuZGVyTGFuZXMgJiZcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gMjA0OCksXG4gICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCksXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMjU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE1Niwgd29ya0luUHJvZ3Jlc3MudGFnKSk7XG59XG5mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gKFxuICAgICAgICAoY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzKSxcbiAgICAgICAgY3VycmVudCAmIDY1NTM2XG4gICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzLmZsYWdzID0gKGN1cnJlbnQgJiAtNjU1MzcpIHwgMTI4KSwgd29ya0luUHJvZ3Jlc3MpXG4gICAgICAgICAgOiBudWxsXG4gICAgICApO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBvcFByb3ZpZGVyKENhY2hlQ29udGV4dCksXG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoKSxcbiAgICAgICAgKGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncyksXG4gICAgICAgIDAgIT09IChjdXJyZW50ICYgNjU1MzYpICYmIDAgPT09IChjdXJyZW50ICYgMTI4KVxuICAgICAgICAgID8gKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IChjdXJyZW50ICYgLTY1NTM3KSB8IDEyOCksIHdvcmtJblByb2dyZXNzKVxuICAgICAgICAgIDogbnVsbFxuICAgICAgKTtcbiAgICBjYXNlIDI2OlxuICAgIGNhc2UgMjc6XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSwgbnVsbDtcbiAgICBjYXNlIDEzOlxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgaWYgKG51bGwgIT09IGN1cnJlbnQgJiYgbnVsbCAhPT0gY3VycmVudC5kZWh5ZHJhdGVkKSB7XG4gICAgICAgIGlmIChudWxsID09PSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDApKTtcbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuICAgICAgcmV0dXJuIGN1cnJlbnQgJiA2NTUzNlxuICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgOiBudWxsO1xuICAgIGNhc2UgMTk6XG4gICAgICByZXR1cm4gcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IpLCBudWxsO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiBwb3BIb3N0Q29udGFpbmVyKCksIG51bGw7XG4gICAgY2FzZSAxMDpcbiAgICAgIHJldHVybiBwb3BQcm92aWRlcih3b3JrSW5Qcm9ncmVzcy50eXBlKSwgbnVsbDtcbiAgICBjYXNlIDIyOlxuICAgIGNhc2UgMjM6XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpLFxuICAgICAgICBwb3BIaWRkZW5Db250ZXh0KCksXG4gICAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSksXG4gICAgICAgIChjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MpLFxuICAgICAgICBjdXJyZW50ICYgNjU1MzZcbiAgICAgICAgICA/ICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSAoY3VycmVudCAmIC02NTUzNykgfCAxMjgpLCB3b3JrSW5Qcm9ncmVzcylcbiAgICAgICAgICA6IG51bGxcbiAgICAgICk7XG4gICAgY2FzZSAyNDpcbiAgICAgIHJldHVybiBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQpLCBudWxsO1xuICAgIGNhc2UgMjU6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspIHtcbiAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSAzOlxuICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0KTtcbiAgICAgIHBvcEhvc3RDb250YWluZXIoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjY6XG4gICAgY2FzZSAyNzpcbiAgICBjYXNlIDU6XG4gICAgICBwb3BIb3N0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgcG9wSG9zdENvbnRhaW5lcigpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMzpcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOTpcbiAgICAgIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmsudHlwZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgIGNhc2UgMjM6XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHBvcEhpZGRlbkNvbnRleHQoKTtcbiAgICAgIG51bGwgIT09IGN1cnJlbnQgJiYgcG9wKHJlc3VtZWRDYWNoZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI0OlxuICAgICAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0KTtcbiAgfVxufVxudmFyIERlZmF1bHRBc3luY0Rpc3BhdGNoZXIgPSB7XG4gICAgZ2V0Q2FjaGVGb3JUeXBlOiBmdW5jdGlvbiAocmVzb3VyY2VUeXBlKSB7XG4gICAgICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpLFxuICAgICAgICBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuICAgICAgdm9pZCAwID09PSBjYWNoZUZvclR5cGUgJiZcbiAgICAgICAgKChjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKSksXG4gICAgICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKSk7XG4gICAgICByZXR1cm4gY2FjaGVGb3JUeXBlO1xuICAgIH1cbiAgfSxcbiAgUG9zc2libHlXZWFrTWFwID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgV2Vha01hcCA/IFdlYWtNYXAgOiBNYXAsXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGwsXG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzID0gITEsXG4gIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITEsXG4gIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9ICExLFxuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IDAsXG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyA9IDAsXG4gIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gMCxcbiAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbCxcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITEsXG4gIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwLFxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHksXG4gIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsLFxuICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGwsXG4gIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITEsXG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbCxcbiAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwLFxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IDAsXG4gIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsLFxuICBuZXN0ZWRVcGRhdGVDb3VudCA9IDAsXG4gIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZSgpIHtcbiAgaWYgKDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgMikgJiYgMCAhPT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgLXdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICBpZiAobnVsbCAhPT0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCkge1xuICAgIHZhciBhY3Rpb25TY29wZUxhbmUgPSBjdXJyZW50RW50YW5nbGVkTGFuZTtcbiAgICByZXR1cm4gMCAhPT0gYWN0aW9uU2NvcGVMYW5lID8gYWN0aW9uU2NvcGVMYW5lIDogcmVxdWVzdFRyYW5zaXRpb25MYW5lKCk7XG4gIH1cbiAgcmV0dXJuIHJlc29sdmVVcGRhdGVQcmlvcml0eSgpO1xufVxuZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgMCA9PT0gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgJiZcbiAgICAod29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPVxuICAgICAgMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgNTM2ODcwOTEyKSB8fCBpc0h5ZHJhdGluZ1xuICAgICAgICA/IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKClcbiAgICAgICAgOiA1MzY4NzA5MTIpO1xuICB2YXIgc3VzcGVuc2VIYW5kbGVyID0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgbnVsbCAhPT0gc3VzcGVuc2VIYW5kbGVyICYmIChzdXNwZW5zZUhhbmRsZXIuZmxhZ3MgfD0gMzIpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgaWYgKFxuICAgIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgMiA9PT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHx8XG4gICAgbnVsbCAhPT0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0XG4gIClcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKSxcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICByb290LFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUsXG4gICAgICAgICExXG4gICAgICApO1xuICBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCBsYW5lKTtcbiAgaWYgKDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgMikgfHwgcm9vdCAhPT0gd29ya0luUHJvZ3Jlc3NSb290KVxuICAgIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICAgKDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgMikgJiZcbiAgICAgICAgKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9IGxhbmUpLFxuICAgICAgNCA9PT0gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAmJlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICExXG4gICAgICAgICkpLFxuICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xufVxuZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCRqc2NvbXAkMCwgbGFuZXMsIGZvcmNlU3luYykge1xuICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiA2KSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMjcpKTtcbiAgdmFyIHNob3VsZFRpbWVTbGljZSA9XG4gICAgICAoIWZvcmNlU3luYyAmJlxuICAgICAgICAwID09PSAobGFuZXMgJiA2MCkgJiZcbiAgICAgICAgMCA9PT0gKGxhbmVzICYgcm9vdCRqc2NvbXAkMC5leHBpcmVkTGFuZXMpKSB8fFxuICAgICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290JGpzY29tcCQwLCBsYW5lcyksXG4gICAgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZVxuICAgICAgPyByZW5kZXJSb290Q29uY3VycmVudChyb290JGpzY29tcCQwLCBsYW5lcylcbiAgICAgIDogcmVuZGVyUm9vdFN5bmMocm9vdCRqc2NvbXAkMCwgbGFuZXMsICEwKSxcbiAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gc2hvdWxkVGltZVNsaWNlO1xuICBkbyB7XG4gICAgaWYgKDAgPT09IGV4aXRTdGF0dXMpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICFzaG91bGRUaW1lU2xpY2UgJiZcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCRqc2NvbXAkMCwgbGFuZXMsIDAsICExKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoNiA9PT0gZXhpdFN0YXR1cylcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICByb290JGpzY29tcCQwLFxuICAgICAgICBsYW5lcyxcbiAgICAgICAgMCxcbiAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgKTtcbiAgICBlbHNlIHtcbiAgICAgIGZvcmNlU3luYyA9IHJvb3QkanNjb21wJDAuY3VycmVudC5hbHRlcm5hdGU7XG4gICAgICBpZiAoXG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgJiZcbiAgICAgICAgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3Jlcyhmb3JjZVN5bmMpXG4gICAgICApIHtcbiAgICAgICAgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QkanNjb21wJDAsIGxhbmVzLCAhMSk7XG4gICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSAhMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoMiA9PT0gZXhpdFN0YXR1cykge1xuICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gbGFuZXM7XG4gICAgICAgIGlmIChyb290JGpzY29tcCQwLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gMDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSByb290JGpzY29tcCQwLnBlbmRpbmdMYW5lcyAmIC01MzY4NzA5MTMpLFxuICAgICAgICAgICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgIDAgIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICAgICAgID8gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiA1MzY4NzA5MTJcbiAgICAgICAgICAgICAgICAgID8gNTM2ODcwOTEyXG4gICAgICAgICAgICAgICAgICA6IDApO1xuICAgICAgICBpZiAoMCAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgICAgbGFuZXMgPSBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQ7XG4gICAgICAgICAgYToge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSByb290JGpzY29tcCQwO1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG4gICAgICAgICAgICB2YXIgd2FzUm9vdERlaHlkcmF0ZWQgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG4gICAgICAgICAgICB3YXNSb290RGVoeWRyYXRlZCAmJlxuICAgICAgICAgICAgICAocHJlcGFyZUZyZXNoU3RhY2socm9vdCwgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KS5mbGFncyB8PSAyNTYpO1xuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gcmVuZGVyUm9vdFN5bmMoXG4gICAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoMiAhPT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiZcbiAgICAgICAgICAgICAgICAhd2FzUm9vdERlaHlkcmF0ZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyB8PSByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9XG4gICAgICAgICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50O1xuICAgICAgICAgICAgICAgIGV4aXRTdGF0dXMgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGV4aXRTdGF0dXM7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJlbmRlcldhc0NvbmN1cnJlbnQgJiZcbiAgICAgICAgICAgICAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKHJlbmRlcldhc0NvbmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVuZGVyV2FzQ29uY3VycmVudCA9ICExO1xuICAgICAgICAgIGlmICgyICE9PSBleGl0U3RhdHVzKSBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKDEgPT09IGV4aXRTdGF0dXMpIHtcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCRqc2NvbXAkMCwgMCk7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QkanNjb21wJDAsIGxhbmVzLCAwLCAhMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICBzaG91bGRUaW1lU2xpY2UgPSByb290JGpzY29tcCQwO1xuICAgICAgICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzNDUpKTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBpZiAoKGxhbmVzICYgNDE5NDE3NikgPT09IGxhbmVzKSB7XG4gICAgICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgICAgICAgICAgIHNob3VsZFRpbWVTbGljZSxcbiAgICAgICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgICAhd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzI5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkV29yayA9IGZvcmNlU3luYztcbiAgICAgICAgc2hvdWxkVGltZVNsaWNlLmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIChsYW5lcyAmIDYyOTE0NTYwKSA9PT0gbGFuZXMgJiZcbiAgICAgICAgICAoKHJlbmRlcldhc0NvbmN1cnJlbnQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgMzAwIC0gbm93KCkpLFxuICAgICAgICAgIDEwIDwgcmVuZGVyV2FzQ29uY3VycmVudClcbiAgICAgICAgKSB7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQoXG4gICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lLFxuICAgICAgICAgICAgIXdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKDAgIT09IGdldE5leHRMYW5lcyhzaG91bGRUaW1lU2xpY2UsIDApKSBicmVhayBhO1xuICAgICAgICAgIHNob3VsZFRpbWVTbGljZS50aW1lb3V0SGFuZGxlID0gc2NoZWR1bGVUaW1lb3V0KFxuICAgICAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeS5iaW5kKFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgICAgIGZvcmNlU3luYyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsXG4gICAgICAgICAgICAgIGxhbmVzLFxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMsXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgICAgICAyLFxuICAgICAgICAgICAgICAtMCxcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgICAgICAgICBzaG91bGRUaW1lU2xpY2UsXG4gICAgICAgICAgZm9yY2VTeW5jLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSxcbiAgICAgICAgICBsYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMsXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzLFxuICAgICAgICAgIDAsXG4gICAgICAgICAgLTAsXG4gICAgICAgICAgMFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgfSB3aGlsZSAoMSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290JGpzY29tcCQwKTtcbn1cbmZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKSB7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzXG4gICAgPyAod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnMpXG4gICAgOiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KFxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyxcbiAgICAgICAgZXJyb3JzXG4gICAgICApO1xufVxuZnVuY3Rpb24gY29tbWl0Um9vdFdoZW5SZWFkeShcbiAgcm9vdCxcbiAgZmluaXNoZWRXb3JrLFxuICByZWNvdmVyYWJsZUVycm9ycyxcbiAgdHJhbnNpdGlvbnMsXG4gIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSxcbiAgbGFuZXMsXG4gIHNwYXduZWRMYW5lLFxuICB1cGRhdGVkTGFuZXMsXG4gIHN1c3BlbmRlZFJldHJ5TGFuZXMsXG4gIGRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyxcbiAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbikge1xuICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcbiAgaWYgKHN1YnRyZWVGbGFncyAmIDgxOTIgfHwgMTY3ODU0MDggPT09IChzdWJ0cmVlRmxhZ3MgJiAxNjc4NTQwOCkpXG4gICAgaWYgKFxuICAgICAgKChzdXNwZW5kZWRTdGF0ZSA9IHsgc3R5bGVzaGVldHM6IG51bGwsIGNvdW50OiAwLCB1bnN1c3BlbmQ6IG5vb3AgfSksXG4gICAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmspLFxuICAgICAgKGZpbmlzaGVkV29yayA9IHdhaXRGb3JDb21taXRUb0JlUmVhZHkoKSksXG4gICAgICBudWxsICE9PSBmaW5pc2hlZFdvcmspXG4gICAgKSB7XG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBmaW5pc2hlZFdvcmsoXG4gICAgICAgIGNvbW1pdFJvb3QuYmluZChcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgICAgICAgdHJhbnNpdGlvbnMsXG4gICAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICAgIHNwYXduZWRMYW5lLFxuICAgICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgY29tcGxldGVkUmVuZGVyU3RhcnRUaW1lLFxuICAgICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBzcGF3bmVkTGFuZSwgIWRpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICBjb21taXRSb290KFxuICAgIHJvb3QsXG4gICAgcmVjb3ZlcmFibGVFcnJvcnMsXG4gICAgdHJhbnNpdGlvbnMsXG4gICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgIHNwYXduZWRMYW5lLFxuICAgIHVwZGF0ZWRMYW5lcyxcbiAgICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICAgIHN1c3BlbmRlZENvbW1pdFJlYXNvbixcbiAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuICApO1xufVxuZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICBmb3IgKHZhciBub2RlID0gZmluaXNoZWRXb3JrOyA7ICkge1xuICAgIHZhciB0YWcgPSBub2RlLnRhZztcbiAgICBpZiAoXG4gICAgICAoMCA9PT0gdGFnIHx8IDExID09PSB0YWcgfHwgMTUgPT09IHRhZykgJiZcbiAgICAgIG5vZGUuZmxhZ3MgJiAxNjM4NCAmJlxuICAgICAgKCh0YWcgPSBub2RlLnVwZGF0ZVF1ZXVlKSxcbiAgICAgIG51bGwgIT09IHRhZyAmJiAoKHRhZyA9IHRhZy5zdG9yZXMpLCBudWxsICE9PSB0YWcpKVxuICAgIClcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFnLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVjayA9IHRhZ1tpXSxcbiAgICAgICAgICBnZXRTbmFwc2hvdCA9IGNoZWNrLmdldFNuYXBzaG90O1xuICAgICAgICBjaGVjayA9IGNoZWNrLnZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghb2JqZWN0SXMoZ2V0U25hcHNob3QoKSwgY2hlY2spKSByZXR1cm4gITE7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgdGFnID0gbm9kZS5jaGlsZDtcbiAgICBpZiAobm9kZS5zdWJ0cmVlRmxhZ3MgJiAxNjM4NCAmJiBudWxsICE9PSB0YWcpXG4gICAgICAodGFnLnJldHVybiA9IG5vZGUpLCAobm9kZSA9IHRhZyk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSBicmVhaztcbiAgICAgIGZvciAoOyBudWxsID09PSBub2RlLnNpYmxpbmc7ICkge1xuICAgICAgICBpZiAobnVsbCA9PT0gbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykgcmV0dXJuICEwO1xuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChcbiAgcm9vdCxcbiAgc3VzcGVuZGVkTGFuZXMsXG4gIHNwYXduZWRMYW5lLFxuICBkaWRBdHRlbXB0RW50aXJlVHJlZVxuKSB7XG4gIHN1c3BlbmRlZExhbmVzICY9IH53b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcztcbiAgc3VzcGVuZGVkTGFuZXMgJj0gfndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzO1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lcztcbiAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgJiYgKHJvb3Qud2FybUxhbmVzIHw9IHN1c3BlbmRlZExhbmVzKTtcbiAgZGlkQXR0ZW1wdEVudGlyZVRyZWUgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgZm9yICh2YXIgbGFuZXMgPSBzdXNwZW5kZWRMYW5lczsgMCA8IGxhbmVzOyApIHtcbiAgICB2YXIgaW5kZXgkNiA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNjtcbiAgICBkaWRBdHRlbXB0RW50aXJlVHJlZVtpbmRleCQ2XSA9IC0xO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG4gIDAgIT09IHNwYXduZWRMYW5lICYmXG4gICAgbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIHN1c3BlbmRlZExhbmVzKTtcbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmskMSgpIHtcbiAgcmV0dXJuIDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgNilcbiAgICA/IChmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSksICExKVxuICAgIDogITA7XG59XG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKSB7XG4gIGlmIChudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGlmICgwID09PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbilcbiAgICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgZWxzZVxuICAgICAgKGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzKSxcbiAgICAgICAgKGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbCksXG4gICAgICAgIHJlc2V0SG9va3NPblVud2luZChpbnRlcnJ1cHRlZFdvcmspLFxuICAgICAgICAodGhlbmFibGVTdGF0ZSQxID0gbnVsbCksXG4gICAgICAgICh0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMCksXG4gICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgZm9yICg7IG51bGwgIT09IGludGVycnVwdGVkV29yazsgKVxuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yay5hbHRlcm5hdGUsIGludGVycnVwdGVkV29yayksXG4gICAgICAgIChpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuKTtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gMDtcbiAgdmFyIHRpbWVvdXRIYW5kbGUgPSByb290LnRpbWVvdXRIYW5kbGU7XG4gIC0xICE9PSB0aW1lb3V0SGFuZGxlICYmXG4gICAgKChyb290LnRpbWVvdXRIYW5kbGUgPSAtMSksIGNhbmNlbFRpbWVvdXQodGltZW91dEhhbmRsZSkpO1xuICB0aW1lb3V0SGFuZGxlID0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0O1xuICBudWxsICE9PSB0aW1lb3V0SGFuZGxlICYmXG4gICAgKChyb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsKSwgdGltZW91dEhhbmRsZSgpKTtcbiAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIHdvcmtJblByb2dyZXNzID0gdGltZW91dEhhbmRsZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMDtcbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5ncyA9ICExO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RJc1ByZXJlbmRlcmluZyA9IGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCwgbGFuZXMpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSAhMTtcbiAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZXRyeUxhbmVzID1cbiAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPVxuICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID1cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPVxuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPVxuICAgICAgMDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID1cbiAgICBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gITE7XG4gIDAgIT09IChsYW5lcyAmIDgpICYmIChsYW5lcyB8PSBsYW5lcyAmIDMyKTtcbiAgdmFyIGFsbEVudGFuZ2xlZExhbmVzID0gcm9vdC5lbnRhbmdsZWRMYW5lcztcbiAgaWYgKDAgIT09IGFsbEVudGFuZ2xlZExhbmVzKVxuICAgIGZvciAoXG4gICAgICByb290ID0gcm9vdC5lbnRhbmdsZW1lbnRzLCBhbGxFbnRhbmdsZWRMYW5lcyAmPSBsYW5lcztcbiAgICAgIDAgPCBhbGxFbnRhbmdsZWRMYW5lcztcblxuICAgICkge1xuICAgICAgdmFyIGluZGV4JDQgPSAzMSAtIGNsejMyKGFsbEVudGFuZ2xlZExhbmVzKSxcbiAgICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNDtcbiAgICAgIGxhbmVzIHw9IHJvb3RbaW5kZXgkNF07XG4gICAgICBhbGxFbnRhbmdsZWRMYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gbGFuZXM7XG4gIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgcmV0dXJuIHRpbWVvdXRIYW5kbGU7XG59XG5mdW5jdGlvbiBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgdGhyb3duVmFsdWUgPT09IFN1c3BlbnNlRXhjZXB0aW9uXG4gICAgPyAoKHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKSksXG4gICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAzKSlcbiAgICA6IHRocm93blZhbHVlID09PSBTdXNwZW5zZXlDb21taXRFeGNlcHRpb25cbiAgICAgID8gKCh0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCkpLFxuICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA0KSlcbiAgICAgIDogKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID1cbiAgICAgICAgICB0aHJvd25WYWx1ZSA9PT0gU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uXG4gICAgICAgICAgICA/IDhcbiAgICAgICAgICAgIDogbnVsbCAhPT0gdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgdGhyb3duVmFsdWUgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuXG4gICAgICAgICAgICAgID8gNlxuICAgICAgICAgICAgICA6IDEpO1xuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gdGhyb3duVmFsdWU7XG4gIG51bGwgPT09IHdvcmtJblByb2dyZXNzICYmXG4gICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gMSksXG4gICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgIHJvb3QsXG4gICAgICBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KVxuICAgICkpO1xufVxuZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG4gIHJldHVybiBudWxsID09PSBwcmV2RGlzcGF0Y2hlciA/IENvbnRleHRPbmx5RGlzcGF0Y2hlciA6IHByZXZEaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5BO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gNDtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkU2tpcFN1c3BlbmRlZFNpYmxpbmdzIHx8XG4gICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDQxOTQxNzYpICE9PVxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpIHx8XG4gICAgKHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nID0gITApO1xuICAoMCA9PT0gKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyAmIDEzNDIxNzcyNykgJiZcbiAgICAwID09PSAod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgJiAxMzQyMTc3MjcpKSB8fFxuICAgIG51bGwgPT09IHdvcmtJblByb2dyZXNzUm9vdCB8fFxuICAgIG1hcmtSb290U3VzcGVuZGVkKFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290LFxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSxcbiAgICAgICExXG4gICAgKTtcbn1cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzLCBzaG91bGRZaWVsZEZvclByZXJlbmRlcmluZykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IDI7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCksXG4gICAgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpXG4gICAgKHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsKSwgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICBsYW5lcyA9ICExO1xuICB2YXIgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gIGE6IGRvXG4gICAgdHJ5IHtcbiAgICAgIGlmICgwICE9PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAmJiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzLFxuICAgICAgICAgIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcbiAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgZXhpdFN0YXR1cyA9IDY7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgbnVsbCA9PT0gc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IuY3VycmVudCAmJiAobGFuZXMgPSAhMCk7XG4gICAgICAgICAgICB2YXIgcmVhc29uID0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb247XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIHNob3VsZFlpZWxkRm9yUHJlcmVuZGVyaW5nICYmXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZXhpdFN0YXR1cyA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgKHJlYXNvbiA9IHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSxcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCksXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbCksXG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgZXhpdFN0YXR1cyA9IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSQxNjQpIHtcbiAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlJDE2NCk7XG4gICAgfVxuICB3aGlsZSAoMSk7XG4gIGxhbmVzICYmIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlcisrO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgbnVsbCA9PT0gd29ya0luUHJvZ3Jlc3MgJiZcbiAgICAoKHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGwpLFxuICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IDApLFxuICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSk7XG4gIHJldHVybiBleGl0U3RhdHVzO1xufVxuZnVuY3Rpb24gd29ya0xvb3BTeW5jKCkge1xuICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3M7ICkgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xufVxuZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSAyO1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpLFxuICAgIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7XG4gIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXNcbiAgICA/ICgod29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IG51bGwpLFxuICAgICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWUgPSBub3coKSArIDUwMCksXG4gICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykpXG4gICAgOiAod29ya0luUHJvZ3Jlc3NSb290SXNQcmVyZW5kZXJpbmcgPSBjaGVja0lmUm9vdElzUHJlcmVuZGVyaW5nKFxuICAgICAgICByb290LFxuICAgICAgICBsYW5lc1xuICAgICAgKSk7XG4gIGE6IGRvXG4gICAgdHJ5IHtcbiAgICAgIGlmICgwICE9PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAmJiBudWxsICE9PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICBsYW5lcyA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB2YXIgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuICAgICAgICBiOiBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSAwO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIGxhbmVzLCB0aHJvd25WYWx1ZSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKHRocm93blZhbHVlKSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKGxhbmVzKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYW5lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgMiA9PT0gd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gJiZcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA3KTtcbiAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRocm93blZhbHVlLnRoZW4obGFuZXMsIGxhbmVzKTtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSA3O1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDU7XG4gICAgICAgICAgICBicmVhayBhO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGlzVGhlbmFibGVSZXNvbHZlZCh0aHJvd25WYWx1ZSlcbiAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKGxhbmVzKSlcbiAgICAgICAgICAgICAgOiAoKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMCksXG4gICAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsKSxcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIGxhbmVzLCB0aHJvd25WYWx1ZSwgNykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdmFyIHJlc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgdmFyIGhvc3RGaWJlciA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZSA/IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkgOiAxKSB7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICBpZiAobnVsbCAhPT0gc2libGluZykgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5GaWJlciA9IGhvc3RGaWJlci5yZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIG51bGwgIT09IHJldHVybkZpYmVyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoKHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKSlcbiAgICAgICAgICAgICAgICAgICAgICA6ICh3b3JrSW5Qcm9ncmVzcyA9IG51bGwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IDA7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgbGFuZXMsIHRocm93blZhbHVlLCA1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gMDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCBsYW5lcywgdGhyb3duVmFsdWUsIDYpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gNjtcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDYyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUkMTY2KSB7XG4gICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSQxNjYpO1xuICAgIH1cbiAgd2hpbGUgKDEpO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgaWYgKG51bGwgIT09IHdvcmtJblByb2dyZXNzKSByZXR1cm4gMDtcbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwO1xuICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xufVxuZnVuY3Rpb24gd29ya0xvb3BDb25jdXJyZW50KCkge1xuICBmb3IgKDsgbnVsbCAhPT0gd29ya0luUHJvZ3Jlc3MgJiYgIXNob3VsZFlpZWxkKCk7IClcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG59XG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIHZhciBuZXh0ID0gYmVnaW5Xb3JrKHVuaXRPZldvcmsuYWx0ZXJuYXRlLCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICBudWxsID09PSBuZXh0ID8gY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspIDogKHdvcmtJblByb2dyZXNzID0gbmV4dCk7XG59XG5mdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgdmFyIG5leHQgPSB1bml0T2ZXb3JrO1xuICB2YXIgY3VycmVudCA9IG5leHQuYWx0ZXJuYXRlO1xuICBzd2l0Y2ggKG5leHQudGFnKSB7XG4gICAgY2FzZSAxNTpcbiAgICBjYXNlIDA6XG4gICAgICBuZXh0ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoXG4gICAgICAgIGN1cnJlbnQsXG4gICAgICAgIG5leHQsXG4gICAgICAgIG5leHQucGVuZGluZ1Byb3BzLFxuICAgICAgICBuZXh0LnR5cGUsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDExOlxuICAgICAgbmV4dCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBuZXh0LFxuICAgICAgICBuZXh0LnBlbmRpbmdQcm9wcyxcbiAgICAgICAgbmV4dC50eXBlLnJlbmRlcixcbiAgICAgICAgbmV4dC5yZWYsXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgcmVzZXRIb29rc09uVW53aW5kKG5leHQpO1xuICAgIGRlZmF1bHQ6XG4gICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgbmV4dCksXG4gICAgICAgIChuZXh0ID0gd29ya0luUHJvZ3Jlc3MgPVxuICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MobmV4dCwgZW50YW5nbGVkUmVuZGVyTGFuZXMpKSxcbiAgICAgICAgKG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgbmV4dCwgZW50YW5nbGVkUmVuZGVyTGFuZXMpKTtcbiAgfVxuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgbnVsbCA9PT0gbmV4dCA/IGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSA6ICh3b3JrSW5Qcm9ncmVzcyA9IG5leHQpO1xufVxuZnVuY3Rpb24gdGhyb3dBbmRVbndpbmRXb3JrTG9vcChcbiAgcm9vdCxcbiAgdW5pdE9mV29yayxcbiAgdGhyb3duVmFsdWUsXG4gIHN1c3BlbmRlZFJlYXNvblxuKSB7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gbnVsbDtcbiAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspO1xuICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbiAgdmFyIHJldHVybkZpYmVyID0gdW5pdE9mV29yay5yZXR1cm47XG4gIHRyeSB7XG4gICAgaWYgKFxuICAgICAgdGhyb3dFeGNlcHRpb24oXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJldHVybkZpYmVyLFxuICAgICAgICB1bml0T2ZXb3JrLFxuICAgICAgICB0aHJvd25WYWx1ZSxcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXNcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAxO1xuICAgICAgbG9nVW5jYXVnaHRFcnJvcihcbiAgICAgICAgcm9vdCxcbiAgICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICAgICk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChudWxsICE9PSByZXR1cm5GaWJlcikgdGhyb3cgKCh3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyKSwgZXJyb3IpO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSAxO1xuICAgIGxvZ1VuY2F1Z2h0RXJyb3IoXG4gICAgICByb290LFxuICAgICAgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIodGhyb3duVmFsdWUsIHJvb3QuY3VycmVudClcbiAgICApO1xuICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHVuaXRPZldvcmsuZmxhZ3MgJiAzMjc2OCkge1xuICAgIGlmIChpc0h5ZHJhdGluZyB8fCAxID09PSBzdXNwZW5kZWRSZWFzb24pIHJvb3QgPSAhMDtcbiAgICBlbHNlIGlmIChcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdElzUHJlcmVuZGVyaW5nIHx8XG4gICAgICAwICE9PSAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiA1MzY4NzA5MTIpXG4gICAgKVxuICAgICAgcm9vdCA9ICExO1xuICAgIGVsc2UgaWYgKFxuICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRTa2lwU3VzcGVuZGVkU2libGluZ3MgPSByb290ID0gITApLFxuICAgICAgMiA9PT0gc3VzcGVuZGVkUmVhc29uIHx8IDMgPT09IHN1c3BlbmRlZFJlYXNvbiB8fCA2ID09PSBzdXNwZW5kZWRSZWFzb24pXG4gICAgKVxuICAgICAgKHN1c3BlbmRlZFJlYXNvbiA9IHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQpLFxuICAgICAgICBudWxsICE9PSBzdXNwZW5kZWRSZWFzb24gJiZcbiAgICAgICAgICAxMyA9PT0gc3VzcGVuZGVkUmVhc29uLnRhZyAmJlxuICAgICAgICAgIChzdXNwZW5kZWRSZWFzb24uZmxhZ3MgfD0gMTYzODQpO1xuICAgIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgcm9vdCk7XG4gIH0gZWxzZSBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG59XG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG4gIGRvIHtcbiAgICBpZiAoMCAhPT0gKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiAzMjc2OCkpIHtcbiAgICAgIHVud2luZFVuaXRPZldvcmsoXG4gICAgICAgIGNvbXBsZXRlZFdvcmssXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZFNraXBTdXNwZW5kZWRTaWJsaW5nc1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdW5pdE9mV29yayA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKFxuICAgICAgY29tcGxldGVkV29yay5hbHRlcm5hdGUsXG4gICAgICBjb21wbGV0ZWRXb3JrLFxuICAgICAgZW50YW5nbGVkUmVuZGVyTGFuZXNcbiAgICApO1xuICAgIGlmIChudWxsICE9PSBuZXh0KSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbXBsZXRlZFdvcmsgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG4gICAgaWYgKG51bGwgIT09IGNvbXBsZXRlZFdvcmspIHtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gY29tcGxldGVkV29yaztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrID0gdW5pdE9mV29yaztcbiAgfSB3aGlsZSAobnVsbCAhPT0gY29tcGxldGVkV29yayk7XG4gIDAgPT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSA1KTtcbn1cbmZ1bmN0aW9uIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaywgc2tpcFNpYmxpbmdzKSB7XG4gIGRvIHtcbiAgICB2YXIgbmV4dCA9IHVud2luZFdvcmsodW5pdE9mV29yay5hbHRlcm5hdGUsIHVuaXRPZldvcmspO1xuICAgIGlmIChudWxsICE9PSBuZXh0KSB7XG4gICAgICBuZXh0LmZsYWdzICY9IDMyNzY3O1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBuZXh0ID0gdW5pdE9mV29yay5yZXR1cm47XG4gICAgbnVsbCAhPT0gbmV4dCAmJlxuICAgICAgKChuZXh0LmZsYWdzIHw9IDMyNzY4KSwgKG5leHQuc3VidHJlZUZsYWdzID0gMCksIChuZXh0LmRlbGV0aW9ucyA9IG51bGwpKTtcbiAgICBpZiAoXG4gICAgICAhc2tpcFNpYmxpbmdzICYmXG4gICAgICAoKHVuaXRPZldvcmsgPSB1bml0T2ZXb3JrLnNpYmxpbmcpLCBudWxsICE9PSB1bml0T2ZXb3JrKVxuICAgICkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSB1bml0T2ZXb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IHVuaXRPZldvcmsgPSBuZXh0O1xuICB9IHdoaWxlIChudWxsICE9PSB1bml0T2ZXb3JrKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IDY7XG4gIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbW1pdFJvb3QoXG4gIHJvb3QsXG4gIHJlY292ZXJhYmxlRXJyb3JzLFxuICB0cmFuc2l0aW9ucyxcbiAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICBzcGF3bmVkTGFuZSxcbiAgdXBkYXRlZExhbmVzLFxuICBzdXNwZW5kZWRSZXRyeUxhbmVzLFxuICBzdXNwZW5kZWRDb21taXRSZWFzb24sXG4gIGNvbXBsZXRlZFJlbmRlclN0YXJ0VGltZSxcbiAgY29tcGxldGVkUmVuZGVyRW5kVGltZVxuKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gMiksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGwpLFxuICAgICAgY29tbWl0Um9vdEltcGwoXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJlY292ZXJhYmxlRXJyb3JzLFxuICAgICAgICB0cmFuc2l0aW9ucyxcbiAgICAgICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgICAgICBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSxcbiAgICAgICAgc3Bhd25lZExhbmUsXG4gICAgICAgIHVwZGF0ZWRMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlMYW5lcyxcbiAgICAgICAgc3VzcGVuZGVkQ29tbWl0UmVhc29uLFxuICAgICAgICBjb21wbGV0ZWRSZW5kZXJTdGFydFRpbWUsXG4gICAgICAgIGNvbXBsZXRlZFJlbmRlckVuZFRpbWVcbiAgICAgICk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5KTtcbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwoXG4gIHJvb3QsXG4gIHJlY292ZXJhYmxlRXJyb3JzLFxuICB0cmFuc2l0aW9ucyxcbiAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICByZW5kZXJQcmlvcml0eUxldmVsLFxuICBzcGF3bmVkTGFuZSxcbiAgdXBkYXRlZExhbmVzLFxuICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4pIHtcbiAgZG8gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB3aGlsZSAobnVsbCAhPT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpO1xuICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiA2KSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMjcpKTtcbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgPSByb290LmZpbmlzaGVkTGFuZXM7XG4gIGlmIChudWxsID09PSBmaW5pc2hlZFdvcmspIHJldHVybiBudWxsO1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IDA7XG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxNzcpKTtcbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBmaW5pc2hlZFdvcmsubGFuZXMgfCBmaW5pc2hlZFdvcmsuY2hpbGRMYW5lcztcbiAgcmVtYWluaW5nTGFuZXMgfD0gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xuICBtYXJrUm9vdEZpbmlzaGVkKFxuICAgIHJvb3QsXG4gICAgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLFxuICAgIHJlbWFpbmluZ0xhbmVzLFxuICAgIHNwYXduZWRMYW5lLFxuICAgIHVwZGF0ZWRMYW5lcyxcbiAgICBzdXNwZW5kZWRSZXRyeUxhbmVzXG4gICk7XG4gIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCAmJlxuICAgICgod29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsKSxcbiAgICAod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSAwKSk7XG4gICgwID09PSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIDEwMjU2KSAmJlxuICAgIDAgPT09IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAxMDI1NikpIHx8XG4gICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgfHxcbiAgICAoKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gITApLFxuICAgIChwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzKSxcbiAgICAocGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zKSxcbiAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cyghMCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KSk7XG4gIHRyYW5zaXRpb25zID0gMCAhPT0gKGZpbmlzaGVkV29yay5mbGFncyAmIDE1OTkwKTtcbiAgMCAhPT0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAxNTk5MCkgfHwgdHJhbnNpdGlvbnNcbiAgICA/ICgodHJhbnNpdGlvbnMgPSBSZWFjdFNoYXJlZEludGVybmFscy5UKSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbCksXG4gICAgICAoc3Bhd25lZExhbmUgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wKSxcbiAgICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gMiksXG4gICAgICAodXBkYXRlZExhbmVzID0gZXhlY3V0aW9uQ29udGV4dCksXG4gICAgICAoZXhlY3V0aW9uQ29udGV4dCB8PSA0KSxcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspLFxuICAgICAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpLFxuICAgICAgcmVzdG9yZVNlbGVjdGlvbihzZWxlY3Rpb25JbmZvcm1hdGlvbiwgcm9vdC5jb250YWluZXJJbmZvKSxcbiAgICAgIChfZW5hYmxlZCA9ICEhZXZlbnRzRW5hYmxlZCksXG4gICAgICAoc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBldmVudHNFbmFibGVkID0gbnVsbCksXG4gICAgICAocm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrKSxcbiAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgZmluaXNoZWRXb3JrLmFsdGVybmF0ZSwgZmluaXNoZWRXb3JrKSxcbiAgICAgIHJlcXVlc3RQYWludCgpLFxuICAgICAgKGV4ZWN1dGlvbkNvbnRleHQgPSB1cGRhdGVkTGFuZXMpLFxuICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBzcGF3bmVkTGFuZSksXG4gICAgICAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHRyYW5zaXRpb25zKSlcbiAgICA6IChyb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcmspO1xuICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0c1xuICAgID8gKChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9ICExKSxcbiAgICAgIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IHJvb3QpLFxuICAgICAgKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSlcbiAgICA6IHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAwID09PSByZW1haW5pbmdMYW5lcyAmJiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsKTtcbiAgb25Db21taXRSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIGlmIChudWxsICE9PSByZWNvdmVyYWJsZUVycm9ycylcbiAgICBmb3IgKFxuICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbCA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yLCBmaW5pc2hlZFdvcmsgPSAwO1xuICAgICAgZmluaXNoZWRXb3JrIDwgcmVjb3ZlcmFibGVFcnJvcnMubGVuZ3RoO1xuICAgICAgZmluaXNoZWRXb3JrKytcbiAgICApXG4gICAgICAocmVtYWluaW5nTGFuZXMgPSByZWNvdmVyYWJsZUVycm9yc1tmaW5pc2hlZFdvcmtdKSxcbiAgICAgICAgcmVuZGVyUHJpb3JpdHlMZXZlbChyZW1haW5pbmdMYW5lcy52YWx1ZSwge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiByZW1haW5pbmdMYW5lcy5zdGFja1xuICAgICAgICB9KTtcbiAgMCAhPT0gKHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzICYgMykgJiYgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICAwICE9PSAoZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlICYgNDE5NDIxOCkgJiYgMCAhPT0gKHJlbWFpbmluZ0xhbmVzICYgNDIpXG4gICAgPyByb290ID09PSByb290V2l0aE5lc3RlZFVwZGF0ZXNcbiAgICAgID8gbmVzdGVkVXBkYXRlQ291bnQrK1xuICAgICAgOiAoKG5lc3RlZFVwZGF0ZUNvdW50ID0gMCksIChyb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290KSlcbiAgICA6IChuZXN0ZWRVcGRhdGVDb3VudCA9IDApO1xuICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcykge1xuICAwID09PSAocm9vdC5wb29sZWRDYWNoZUxhbmVzICY9IHJlbWFpbmluZ0xhbmVzKSAmJlxuICAgICgocmVtYWluaW5nTGFuZXMgPSByb290LnBvb2xlZENhY2hlKSxcbiAgICBudWxsICE9IHJlbWFpbmluZ0xhbmVzICYmXG4gICAgICAoKHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsKSwgcmVsZWFzZUNhY2hlKHJlbWFpbmluZ0xhbmVzKSkpO1xufVxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0cygpIHtcbiAgaWYgKG51bGwgIT09IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgdmFyIHJvb3QkMTcwID0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMsXG4gICAgICByZW1haW5pbmdMYW5lcyA9IHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzO1xuICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gMDtcbiAgICB2YXIgcmVuZGVyUHJpb3JpdHkgPSBsYW5lc1RvRXZlbnRQcmlvcml0eShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyksXG4gICAgICBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgICBwcmV2aW91c1ByaW9yaXR5ID0gUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucDtcbiAgICB0cnkge1xuICAgICAgUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IDMyID4gcmVuZGVyUHJpb3JpdHkgPyAzMiA6IHJlbmRlclByaW9yaXR5O1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICBpZiAobnVsbCA9PT0gcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMpXG4gICAgICAgIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAhMTtcbiAgICAgIGVsc2Uge1xuICAgICAgICByZW5kZXJQcmlvcml0eSA9IHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7XG4gICAgICAgIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLFxuICAgICAgICAgIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gICAgICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDtcbiAgICAgICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSAwO1xuICAgICAgICBpZiAoMCAhPT0gKGV4ZWN1dGlvbkNvbnRleHQgJiA2KSlcbiAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDMzMSkpO1xuICAgICAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgICAgICBleGVjdXRpb25Db250ZXh0IHw9IDQ7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihyb290LmN1cnJlbnQpO1xuICAgICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKHJvb3QsIHJvb3QuY3VycmVudCwgbGFuZXMsIHJlbmRlclByaW9yaXR5KTtcbiAgICAgICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBpbmplY3RlZEhvb2sgJiZcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290XG4gICAgICAgIClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbiksXG4gICAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCQxNzAsIHJlbWFpbmluZ0xhbmVzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgc291cmNlRmliZXIgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgc291cmNlRmliZXIpO1xuICBzb3VyY2VGaWJlciA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBzb3VyY2VGaWJlciwgMik7XG4gIHJvb3RGaWJlciA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgMik7XG4gIG51bGwgIT09IHJvb3RGaWJlciAmJlxuICAgIChtYXJrUm9vdFVwZGF0ZWQkMShyb290RmliZXIsIDIpLCBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdEZpYmVyKSk7XG59XG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpIHtcbiAgaWYgKDMgPT09IHNvdXJjZUZpYmVyLnRhZylcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yKTtcbiAgZWxzZVxuICAgIGZvciAoOyBudWxsICE9PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yOyApIHtcbiAgICAgIGlmICgzID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChcbiAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgIHNvdXJjZUZpYmVyLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICgxID09PSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnRhZykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT1cbiAgICAgICAgICAgIHR5cGVvZiBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLnR5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIHx8XG4gICAgICAgICAgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoICYmXG4gICAgICAgICAgICAobnVsbCA9PT0gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgfHxcbiAgICAgICAgICAgICAgIWxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmhhcyhpbnN0YW5jZSkpKVxuICAgICAgICApIHtcbiAgICAgICAgICBzb3VyY2VGaWJlciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gICAgICAgICAgZXJyb3IgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKDIpO1xuICAgICAgICAgIGluc3RhbmNlID0gZW5xdWV1ZVVwZGF0ZShuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvciwgMik7XG4gICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2UgJiZcbiAgICAgICAgICAgIChpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIGluc3RhbmNlLFxuICAgICAgICAgICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLFxuICAgICAgICAgICAgICBzb3VyY2VGaWJlclxuICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIG1hcmtSb290VXBkYXRlZCQxKGluc3RhbmNlLCAyKSxcbiAgICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZWFyZXN0TW91bnRlZEFuY2VzdG9yID0gbmVhcmVzdE1vdW50ZWRBbmNlc3Rvci5yZXR1cm47XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIGlmIChudWxsID09PSBwaW5nQ2FjaGUpIHtcbiAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICB2YXIgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZVxuICAgICh0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHdha2VhYmxlKSksXG4gICAgICB2b2lkIDAgPT09IHRocmVhZElEcyAmJlxuICAgICAgICAoKHRocmVhZElEcyA9IG5ldyBTZXQoKSksIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcykpO1xuICB0aHJlYWRJRHMuaGFzKGxhbmVzKSB8fFxuICAgICgod29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gITApLFxuICAgIHRocmVhZElEcy5hZGQobGFuZXMpLFxuICAgIChyb290ID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB3YWtlYWJsZSwgbGFuZXMpKSxcbiAgICB3YWtlYWJsZS50aGVuKHJvb3QsIHJvb3QpKTtcbn1cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHdha2VhYmxlLCBwaW5nZWRMYW5lcykge1xuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIG51bGwgIT09IHBpbmdDYWNoZSAmJiBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgcm9vdC5waW5nZWRMYW5lcyB8PSByb290LnN1c3BlbmRlZExhbmVzICYgcGluZ2VkTGFuZXM7XG4gIHJvb3Qud2FybUxhbmVzICY9IH5waW5nZWRMYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmXG4gICAgKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICYgcGluZ2VkTGFuZXMpID09PSBwaW5nZWRMYW5lcyAmJlxuICAgICg0ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzIHx8XG4gICAgKDMgPT09IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgJiZcbiAgICAgICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAmIDYyOTE0NTYwKSA9PT1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgIDMwMCA+IG5vdygpIC0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSlcbiAgICAgID8gMCA9PT0gKGV4ZWN1dGlvbkNvbnRleHQgJiAyKSAmJiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCAwKVxuICAgICAgOiAod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgfD0gcGluZ2VkTGFuZXMpLFxuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmV0cnlMYW5lcyA9PT0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgJiZcbiAgICAgICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJldHJ5TGFuZXMgPSAwKSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbn1cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgMCA9PT0gcmV0cnlMYW5lICYmIChyZXRyeUxhbmUgPSBjbGFpbU5leHRSZXRyeUxhbmUoKSk7XG4gIGJvdW5kYXJ5RmliZXIgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbiAgbnVsbCAhPT0gYm91bmRhcnlGaWJlciAmJlxuICAgIChtYXJrUm9vdFVwZGF0ZWQkMShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpLFxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChib3VuZGFyeUZpYmVyKSk7XG59XG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgcmV0cnlMYW5lID0gMDtcbiAgbnVsbCAhPT0gc3VzcGVuc2VTdGF0ZSAmJiAocmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUpO1xuICByZXRyeVRpbWVkT3V0Qm91bmRhcnkoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXRyeVdha2VhYmxlKGJvdW5kYXJ5RmliZXIsIHdha2VhYmxlKSB7XG4gIHZhciByZXRyeUxhbmUgPSAwO1xuICBzd2l0Y2ggKGJvdW5kYXJ5RmliZXIudGFnKSB7XG4gICAgY2FzZSAxMzpcbiAgICAgIHZhciByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIG51bGwgIT09IHN1c3BlbnNlU3RhdGUgJiYgKHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTk6XG4gICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlLl9yZXRyeUNhY2hlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMzE0KSk7XG4gIH1cbiAgbnVsbCAhPT0gcmV0cnlDYWNoZSAmJiByZXRyeUNhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayQxKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xufVxudmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGwsXG4gIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbCxcbiAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMSxcbiAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gITEsXG4gIGlzRmx1c2hpbmdXb3JrID0gITEsXG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gMDtcbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gIHJvb3QgIT09IGxhc3RTY2hlZHVsZWRSb290ICYmXG4gICAgbnVsbCA9PT0gcm9vdC5uZXh0ICYmXG4gICAgKG51bGwgPT09IGxhc3RTY2hlZHVsZWRSb290XG4gICAgICA/IChmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3QpXG4gICAgICA6IChsYXN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290KSk7XG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICBkaWRTY2hlZHVsZU1pY3JvdGFzayB8fFxuICAgICgoZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSAhMCksXG4gICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzaykpO1xufVxuZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoc3luY1RyYW5zaXRpb25MYW5lcywgb25seUxlZ2FjeSkge1xuICBpZiAoIWlzRmx1c2hpbmdXb3JrICYmIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yaykge1xuICAgIGlzRmx1c2hpbmdXb3JrID0gITA7XG4gICAgZG8ge1xuICAgICAgdmFyIGRpZFBlcmZvcm1Tb21lV29yayA9ICExO1xuICAgICAgZm9yICh2YXIgcm9vdCQxNzIgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7IG51bGwgIT09IHJvb3QkMTcyOyApIHtcbiAgICAgICAgaWYgKCFvbmx5TGVnYWN5KVxuICAgICAgICAgIGlmICgwICE9PSBzeW5jVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdCQxNzIucGVuZGluZ0xhbmVzO1xuICAgICAgICAgICAgaWYgKDAgPT09IHBlbmRpbmdMYW5lcykgdmFyIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IDA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdCQxNzIuc3VzcGVuZGVkTGFuZXMsXG4gICAgICAgICAgICAgICAgcGluZ2VkTGFuZXMgPSByb290JDE3Mi5waW5nZWRMYW5lcztcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICAgICAgICAgICAgICAoMSA8PCAoMzEgLSBjbHozMig0MiB8IHN5bmNUcmFuc2l0aW9uTGFuZXMpICsgMSkpIC0gMTtcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICY9XG4gICAgICAgICAgICAgICAgcGVuZGluZ0xhbmVzICYgfihzdXNwZW5kZWRMYW5lcyAmIH5waW5nZWRMYW5lcyk7XG4gICAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYgMjAxMzI2Njc3XG4gICAgICAgICAgICAgICAgICA/IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiAyMDEzMjY2NzcpIHwgMVxuICAgICAgICAgICAgICAgICAgOiBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgPyBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgfCAyXG4gICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDAgIT09IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCAmJlxuICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QkMTcyLCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyksXG4gICAgICAgICAgICAgIChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBnZXROZXh0TGFuZXMoXG4gICAgICAgICAgICAgICAgcm9vdCQxNzIsXG4gICAgICAgICAgICAgICAgcm9vdCQxNzIgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA6IDBcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIDAgPT09IChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgJiAzKSB8fFxuICAgICAgICAgICAgICAgIGNoZWNrSWZSb290SXNQcmVyZW5kZXJpbmcocm9vdCQxNzIsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgfHxcbiAgICAgICAgICAgICAgICAoKGRpZFBlcmZvcm1Tb21lV29yayA9ICEwKSxcbiAgICAgICAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCQxNzIsIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkpO1xuICAgICAgICByb290JDE3MiA9IHJvb3QkMTcyLm5leHQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoZGlkUGVyZm9ybVNvbWVXb3JrKTtcbiAgICBpc0ZsdXNoaW5nV29yayA9ICExO1xuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKSB7XG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IGRpZFNjaGVkdWxlTWljcm90YXNrID0gITE7XG4gIHZhciBzeW5jVHJhbnNpdGlvbkxhbmVzID0gMDtcbiAgMCAhPT0gY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgJiZcbiAgICAoc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpICYmXG4gICAgICAoc3luY1RyYW5zaXRpb25MYW5lcyA9IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSxcbiAgICAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSAwKSk7XG4gIGZvciAoXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbm93KCksIHByZXYgPSBudWxsLCByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIG51bGwgIT09IHJvb3Q7XG5cbiAgKSB7XG4gICAgdmFyIG5leHQgPSByb290Lm5leHQsXG4gICAgICBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcbiAgICBpZiAoMCA9PT0gbmV4dExhbmVzKVxuICAgICAgKHJvb3QubmV4dCA9IG51bGwpLFxuICAgICAgICBudWxsID09PSBwcmV2ID8gKGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQpIDogKHByZXYubmV4dCA9IG5leHQpLFxuICAgICAgICBudWxsID09PSBuZXh0ICYmIChsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXYpO1xuICAgIGVsc2UgaWYgKFxuICAgICAgKChwcmV2ID0gcm9vdCksIDAgIT09IHN5bmNUcmFuc2l0aW9uTGFuZXMgfHwgMCAhPT0gKG5leHRMYW5lcyAmIDMpKVxuICAgIClcbiAgICAgIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9ICEwO1xuICAgIHJvb3QgPSBuZXh0O1xuICB9XG4gIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKHN5bmNUcmFuc2l0aW9uTGFuZXMsICExKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgZm9yIChcbiAgICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzLFxuICAgICAgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzLFxuICAgICAgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXMsXG4gICAgICBsYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzICYgLTYyOTE0NTYxO1xuICAgIDAgPCBsYW5lcztcblxuICApIHtcbiAgICB2YXIgaW5kZXgkNSA9IDMxIC0gY2x6MzIobGFuZXMpLFxuICAgICAgbGFuZSA9IDEgPDwgaW5kZXgkNSxcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4JDVdO1xuICAgIGlmICgtMSA9PT0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGlmICgwID09PSAobGFuZSAmIHN1c3BlbmRlZExhbmVzKSB8fCAwICE9PSAobGFuZSAmIHBpbmdlZExhbmVzKSlcbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4JDVdID0gY29tcHV0ZUV4cGlyYXRpb25UaW1lKGxhbmUsIGN1cnJlbnRUaW1lKTtcbiAgICB9IGVsc2UgZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUgJiYgKHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmUpO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG4gIGN1cnJlbnRUaW1lID0gd29ya0luUHJvZ3Jlc3NSb290O1xuICBzdXNwZW5kZWRMYW5lcyA9IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xuICBzdXNwZW5kZWRMYW5lcyA9IGdldE5leHRMYW5lcyhcbiAgICByb290LFxuICAgIHJvb3QgPT09IGN1cnJlbnRUaW1lID8gc3VzcGVuZGVkTGFuZXMgOiAwXG4gICk7XG4gIHBpbmdlZExhbmVzID0gcm9vdC5jYWxsYmFja05vZGU7XG4gIGlmIChcbiAgICAwID09PSBzdXNwZW5kZWRMYW5lcyB8fFxuICAgIChyb290ID09PSBjdXJyZW50VGltZSAmJiAyID09PSB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikgfHxcbiAgICBudWxsICE9PSByb290LmNhbmNlbFBlbmRpbmdDb21taXRcbiAgKVxuICAgIHJldHVybiAoXG4gICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJlxuICAgICAgICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJlxuICAgICAgICBjYW5jZWxDYWxsYmFjayQxKHBpbmdlZExhbmVzKSxcbiAgICAgIChyb290LmNhbGxiYWNrTm9kZSA9IG51bGwpLFxuICAgICAgKHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IDApXG4gICAgKTtcbiAgaWYgKFxuICAgIDAgPT09IChzdXNwZW5kZWRMYW5lcyAmIDMpIHx8XG4gICAgY2hlY2tJZlJvb3RJc1ByZXJlbmRlcmluZyhyb290LCBzdXNwZW5kZWRMYW5lcylcbiAgKSB7XG4gICAgY3VycmVudFRpbWUgPSBzdXNwZW5kZWRMYW5lcyAmIC1zdXNwZW5kZWRMYW5lcztcbiAgICBpZiAoY3VycmVudFRpbWUgPT09IHJvb3QuY2FsbGJhY2tQcmlvcml0eSkgcmV0dXJuIGN1cnJlbnRUaW1lO1xuICAgIG51bGwgIT09IHBpbmdlZExhbmVzICYmIGNhbmNlbENhbGxiYWNrJDEocGluZ2VkTGFuZXMpO1xuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkoc3VzcGVuZGVkTGFuZXMpKSB7XG4gICAgICBjYXNlIDI6XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHN1c3BlbmRlZExhbmVzID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzMjpcbiAgICAgICAgc3VzcGVuZGVkTGFuZXMgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjY4NDM1NDU2OlxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBzdXNwZW5kZWRMYW5lcyA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgfVxuICAgIHBpbmdlZExhbmVzID0gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdCk7XG4gICAgc3VzcGVuZGVkTGFuZXMgPSBzY2hlZHVsZUNhbGxiYWNrJDMoc3VzcGVuZGVkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBjdXJyZW50VGltZTtcbiAgICByb290LmNhbGxiYWNrTm9kZSA9IHN1c3BlbmRlZExhbmVzO1xuICAgIHJldHVybiBjdXJyZW50VGltZTtcbiAgfVxuICBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBudWxsICE9PSBwaW5nZWRMYW5lcyAmJiBjYW5jZWxDYWxsYmFjayQxKHBpbmdlZExhbmVzKTtcbiAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gMjtcbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290VmlhU2NoZWR1bGVyVGFzayhyb290LCBkaWRUaW1lb3V0KSB7XG4gIHZhciBvcmlnaW5hbENhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuICBpZiAoZmx1c2hQYXNzaXZlRWZmZWN0cygpICYmIHJvb3QuY2FsbGJhY2tOb2RlICE9PSBvcmlnaW5hbENhbGxiYWNrTm9kZSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwID0gZ2V0TmV4dExhbmVzKFxuICAgIHJvb3QsXG4gICAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMkanNjb21wJDAgOiAwXG4gICk7XG4gIGlmICgwID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyRqc2NvbXAkMCkgcmV0dXJuIG51bGw7XG4gIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzJGpzY29tcCQwLCBkaWRUaW1lb3V0KTtcbiAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3coKSk7XG4gIHJldHVybiBudWxsICE9IHJvb3QuY2FsbGJhY2tOb2RlICYmIHJvb3QuY2FsbGJhY2tOb2RlID09PSBvcmlnaW5hbENhbGxiYWNrTm9kZVxuICAgID8gcGVyZm9ybVdvcmtPblJvb3RWaWFTY2hlZHVsZXJUYXNrLmJpbmQobnVsbCwgcm9vdClcbiAgICA6IG51bGw7XG59XG5mdW5jdGlvbiBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgaWYgKGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSkgcmV0dXJuIG51bGw7XG4gIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGxhbmVzLCAhMCk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUltbWVkaWF0ZVRhc2soY2IpIHtcbiAgc2NoZWR1bGVNaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIDAgIT09IChleGVjdXRpb25Db250ZXh0ICYgNilcbiAgICAgID8gc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYilcbiAgICAgIDogY2IoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSB7XG4gIDAgPT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICYmXG4gICAgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKSk7XG4gIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbn1cbmZ1bmN0aW9uIGNvZXJjZUZvcm1BY3Rpb25Qcm9wKGFjdGlvblByb3ApIHtcbiAgcmV0dXJuIG51bGwgPT0gYWN0aW9uUHJvcCB8fFxuICAgIFwic3ltYm9sXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wIHx8XG4gICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wXG4gICAgPyBudWxsXG4gICAgOiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb25Qcm9wXG4gICAgICA/IGFjdGlvblByb3BcbiAgICAgIDogc2FuaXRpemVVUkwoXCJcIiArIGFjdGlvblByb3ApO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybURhdGFXaXRoU3VibWl0dGVyKGZvcm0sIHN1Ym1pdHRlcikge1xuICB2YXIgdGVtcCA9IHN1Ym1pdHRlci5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgdGVtcC5uYW1lID0gc3VibWl0dGVyLm5hbWU7XG4gIHRlbXAudmFsdWUgPSBzdWJtaXR0ZXIudmFsdWU7XG4gIGZvcm0uaWQgJiYgdGVtcC5zZXRBdHRyaWJ1dGUoXCJmb3JtXCIsIGZvcm0uaWQpO1xuICBzdWJtaXR0ZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGVtcCwgc3VibWl0dGVyKTtcbiAgZm9ybSA9IG5ldyBGb3JtRGF0YShmb3JtKTtcbiAgdGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRlbXApO1xuICByZXR1cm4gZm9ybTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHMkMShcbiAgZGlzcGF0Y2hRdWV1ZSxcbiAgZG9tRXZlbnROYW1lLFxuICBtYXliZVRhcmdldEluc3QsXG4gIG5hdGl2ZUV2ZW50LFxuICBuYXRpdmVFdmVudFRhcmdldFxuKSB7XG4gIGlmIChcbiAgICBcInN1Ym1pdFwiID09PSBkb21FdmVudE5hbWUgJiZcbiAgICBtYXliZVRhcmdldEluc3QgJiZcbiAgICBtYXliZVRhcmdldEluc3Quc3RhdGVOb2RlID09PSBuYXRpdmVFdmVudFRhcmdldFxuICApIHtcbiAgICB2YXIgYWN0aW9uID0gY29lcmNlRm9ybUFjdGlvblByb3AoXG4gICAgICAgIChuYXRpdmVFdmVudFRhcmdldFtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsKS5hY3Rpb25cbiAgICAgICksXG4gICAgICBzdWJtaXR0ZXIgPSBuYXRpdmVFdmVudC5zdWJtaXR0ZXI7XG4gICAgc3VibWl0dGVyICYmXG4gICAgICAoKGRvbUV2ZW50TmFtZSA9IChkb21FdmVudE5hbWUgPSBzdWJtaXR0ZXJbaW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbClcbiAgICAgICAgPyBjb2VyY2VGb3JtQWN0aW9uUHJvcChkb21FdmVudE5hbWUuZm9ybUFjdGlvbilcbiAgICAgICAgOiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKSksXG4gICAgICBudWxsICE9PSBkb21FdmVudE5hbWUgJiYgKChhY3Rpb24gPSBkb21FdmVudE5hbWUpLCAoc3VibWl0dGVyID0gbnVsbCkpKTtcbiAgICB2YXIgZXZlbnQgPSBuZXcgU3ludGhldGljRXZlbnQoXG4gICAgICBcImFjdGlvblwiLFxuICAgICAgXCJhY3Rpb25cIixcbiAgICAgIG51bGwsXG4gICAgICBuYXRpdmVFdmVudCxcbiAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgKTtcbiAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgbGlzdGVuZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICBsaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKDAgIT09IGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZvcm1EYXRhID0gc3VibWl0dGVyXG4gICAgICAgICAgICAgICAgICA/IGNyZWF0ZUZvcm1EYXRhV2l0aFN1Ym1pdHRlcihuYXRpdmVFdmVudFRhcmdldCwgc3VibWl0dGVyKVxuICAgICAgICAgICAgICAgICAgOiBuZXcgRm9ybURhdGEobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIHN0YXJ0SG9zdFRyYW5zaXRpb24oXG4gICAgICAgICAgICAgICAgICBtYXliZVRhcmdldEluc3QsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBuYXRpdmVFdmVudFRhcmdldC5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgIGZvcm1EYXRhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGFjdGlvbiAmJlxuICAgICAgICAgICAgICAgIChldmVudC5wcmV2ZW50RGVmYXVsdCgpLFxuICAgICAgICAgICAgICAgIChmb3JtRGF0YSA9IHN1Ym1pdHRlclxuICAgICAgICAgICAgICAgICAgPyBjcmVhdGVGb3JtRGF0YVdpdGhTdWJtaXR0ZXIobmF0aXZlRXZlbnRUYXJnZXQsIHN1Ym1pdHRlcilcbiAgICAgICAgICAgICAgICAgIDogbmV3IEZvcm1EYXRhKG5hdGl2ZUV2ZW50VGFyZ2V0KSksXG4gICAgICAgICAgICAgICAgc3RhcnRIb3N0VHJhbnNpdGlvbihcbiAgICAgICAgICAgICAgICAgIG1heWJlVGFyZ2V0SW5zdCxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZzogITAsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBmb3JtRGF0YVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY3VycmVudFRhcmdldDogbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG59XG5mb3IgKFxuICB2YXIgaSRqc2NvbXAkaW5saW5lXzE0MzkgPSAwO1xuICBpJGpzY29tcCRpbmxpbmVfMTQzOSA8IHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzLmxlbmd0aDtcbiAgaSRqc2NvbXAkaW5saW5lXzE0MzkrK1xuKSB7XG4gIHZhciBldmVudE5hbWUkanNjb21wJGlubGluZV8xNDQwID1cbiAgICAgIHNpbXBsZUV2ZW50UGx1Z2luRXZlbnRzW2kkanNjb21wJGlubGluZV8xNDM5XSxcbiAgICBkb21FdmVudE5hbWUkanNjb21wJGlubGluZV8xNDQxID1cbiAgICAgIGV2ZW50TmFtZSRqc2NvbXAkaW5saW5lXzE0NDAudG9Mb3dlckNhc2UoKSxcbiAgICBjYXBpdGFsaXplZEV2ZW50JGpzY29tcCRpbmxpbmVfMTQ0MiA9XG4gICAgICBldmVudE5hbWUkanNjb21wJGlubGluZV8xNDQwWzBdLnRvVXBwZXJDYXNlKCkgK1xuICAgICAgZXZlbnROYW1lJGpzY29tcCRpbmxpbmVfMTQ0MC5zbGljZSgxKTtcbiAgcmVnaXN0ZXJTaW1wbGVFdmVudChcbiAgICBkb21FdmVudE5hbWUkanNjb21wJGlubGluZV8xNDQxLFxuICAgIFwib25cIiArIGNhcGl0YWxpemVkRXZlbnQkanNjb21wJGlubGluZV8xNDQyXG4gICk7XG59XG5yZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9FTkQsIFwib25BbmltYXRpb25FbmRcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9JVEVSQVRJT04sIFwib25BbmltYXRpb25JdGVyYXRpb25cIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KEFOSU1BVElPTl9TVEFSVCwgXCJvbkFuaW1hdGlvblN0YXJ0XCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChcImRibGNsaWNrXCIsIFwib25Eb3VibGVDbGlja1wiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJmb2N1c2luXCIsIFwib25Gb2N1c1wiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoXCJmb2N1c291dFwiLCBcIm9uQmx1clwiKTtcbnJlZ2lzdGVyU2ltcGxlRXZlbnQoVFJBTlNJVElPTl9SVU4sIFwib25UcmFuc2l0aW9uUnVuXCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX1NUQVJULCBcIm9uVHJhbnNpdGlvblN0YXJ0XCIpO1xucmVnaXN0ZXJTaW1wbGVFdmVudChUUkFOU0lUSU9OX0NBTkNFTCwgXCJvblRyYW5zaXRpb25DYW5jZWxcIik7XG5yZWdpc3RlclNpbXBsZUV2ZW50KFRSQU5TSVRJT05fRU5ELCBcIm9uVHJhbnNpdGlvbkVuZFwiKTtcbnJlZ2lzdGVyRGlyZWN0RXZlbnQoXCJvbk1vdXNlRW50ZXJcIiwgW1wibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIl0pO1xucmVnaXN0ZXJEaXJlY3RFdmVudChcIm9uTW91c2VMZWF2ZVwiLCBbXCJtb3VzZW91dFwiLCBcIm1vdXNlb3ZlclwiXSk7XG5yZWdpc3RlckRpcmVjdEV2ZW50KFwib25Qb2ludGVyRW50ZXJcIiwgW1wicG9pbnRlcm91dFwiLCBcInBvaW50ZXJvdmVyXCJdKTtcbnJlZ2lzdGVyRGlyZWN0RXZlbnQoXCJvblBvaW50ZXJMZWF2ZVwiLCBbXCJwb2ludGVyb3V0XCIsIFwicG9pbnRlcm92ZXJcIl0pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uQ2hhbmdlXCIsXG4gIFwiY2hhbmdlIGNsaWNrIGZvY3VzaW4gZm9jdXNvdXQgaW5wdXQga2V5ZG93biBrZXl1cCBzZWxlY3Rpb25jaGFuZ2VcIi5zcGxpdChcIiBcIilcbik7XG5yZWdpc3RlclR3b1BoYXNlRXZlbnQoXG4gIFwib25TZWxlY3RcIixcbiAgXCJmb2N1c291dCBjb250ZXh0bWVudSBkcmFnZW5kIGZvY3VzaW4ga2V5ZG93biBrZXl1cCBtb3VzZWRvd24gbW91c2V1cCBzZWxlY3Rpb25jaGFuZ2VcIi5zcGxpdChcbiAgICBcIiBcIlxuICApXG4pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFwib25CZWZvcmVJbnB1dFwiLCBbXG4gIFwiY29tcG9zaXRpb25lbmRcIixcbiAgXCJrZXlwcmVzc1wiLFxuICBcInRleHRJbnB1dFwiLFxuICBcInBhc3RlXCJcbl0pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uQ29tcG9zaXRpb25FbmRcIixcbiAgXCJjb21wb3NpdGlvbmVuZCBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKVxuKTtcbnJlZ2lzdGVyVHdvUGhhc2VFdmVudChcbiAgXCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbiAgXCJjb21wb3NpdGlvbnN0YXJ0IGZvY3Vzb3V0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgbW91c2Vkb3duXCIuc3BsaXQoXCIgXCIpXG4pO1xucmVnaXN0ZXJUd29QaGFzZUV2ZW50KFxuICBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixcbiAgXCJjb21wb3NpdGlvbnVwZGF0ZSBmb2N1c291dCBrZXlkb3duIGtleXByZXNzIGtleXVwIG1vdXNlZG93blwiLnNwbGl0KFwiIFwiKVxuKTtcbnZhciBtZWRpYUV2ZW50VHlwZXMgPVxuICAgIFwiYWJvcnQgY2FucGxheSBjYW5wbGF5dGhyb3VnaCBkdXJhdGlvbmNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBsb2FkZWRkYXRhIGxvYWRlZG1ldGFkYXRhIGxvYWRzdGFydCBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZWNoYW5nZSByZXNpemUgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdXNwZW5kIHRpbWV1cGRhdGUgdm9sdW1lY2hhbmdlIHdhaXRpbmdcIi5zcGxpdChcbiAgICAgIFwiIFwiXG4gICAgKSxcbiAgbm9uRGVsZWdhdGVkRXZlbnRzID0gbmV3IFNldChcbiAgICBcImJlZm9yZXRvZ2dsZSBjYW5jZWwgY2xvc2UgaW52YWxpZCBsb2FkIHNjcm9sbCBzY3JvbGxlbmQgdG9nZ2xlXCJcbiAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgIC5jb25jYXQobWVkaWFFdmVudFR5cGVzKVxuICApO1xuZnVuY3Rpb24gcHJvY2Vzc0Rpc3BhdGNoUXVldWUoZGlzcGF0Y2hRdWV1ZSwgZXZlbnRTeXN0ZW1GbGFncykge1xuICBldmVudFN5c3RlbUZsYWdzID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaFF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9kaXNwYXRjaFF1ZXVlJGkgPSBkaXNwYXRjaFF1ZXVlW2ldLFxuICAgICAgZXZlbnQgPSBfZGlzcGF0Y2hRdWV1ZSRpLmV2ZW50O1xuICAgIF9kaXNwYXRjaFF1ZXVlJGkgPSBfZGlzcGF0Y2hRdWV1ZSRpLmxpc3RlbmVycztcbiAgICBhOiB7XG4gICAgICB2YXIgcHJldmlvdXNJbnN0YW5jZSA9IHZvaWQgMDtcbiAgICAgIGlmIChldmVudFN5c3RlbUZsYWdzKVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIHZhciBpJGpzY29tcCQwID0gX2Rpc3BhdGNoUXVldWUkaS5sZW5ndGggLSAxO1xuICAgICAgICAgIDAgPD0gaSRqc2NvbXAkMDtcbiAgICAgICAgICBpJGpzY29tcCQwLS1cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIF9kaXNwYXRjaExpc3RlbmVycyRpID0gX2Rpc3BhdGNoUXVldWUkaVtpJGpzY29tcCQwXSxcbiAgICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2UsXG4gICAgICAgICAgICBjdXJyZW50VGFyZ2V0ID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuY3VycmVudFRhcmdldDtcbiAgICAgICAgICBfZGlzcGF0Y2hMaXN0ZW5lcnMkaSA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmxpc3RlbmVyO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPT0gcHJldmlvdXNJbnN0YW5jZSAmJiBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKVxuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICBwcmV2aW91c0luc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGk7XG4gICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IGN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UoZXZlbnQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAgIHByZXZpb3VzSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBmb3IgKFxuICAgICAgICAgIGkkanNjb21wJDAgPSAwO1xuICAgICAgICAgIGkkanNjb21wJDAgPCBfZGlzcGF0Y2hRdWV1ZSRpLmxlbmd0aDtcbiAgICAgICAgICBpJGpzY29tcCQwKytcbiAgICAgICAgKSB7XG4gICAgICAgICAgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hRdWV1ZSRpW2kkanNjb21wJDBdO1xuICAgICAgICAgIGluc3RhbmNlID0gX2Rpc3BhdGNoTGlzdGVuZXJzJGkuaW5zdGFuY2U7XG4gICAgICAgICAgY3VycmVudFRhcmdldCA9IF9kaXNwYXRjaExpc3RlbmVycyRpLmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgX2Rpc3BhdGNoTGlzdGVuZXJzJGkgPSBfZGlzcGF0Y2hMaXN0ZW5lcnMkaS5saXN0ZW5lcjtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT09IHByZXZpb3VzSW5zdGFuY2UgJiYgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSlcbiAgICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgICAgcHJldmlvdXNJbnN0YW5jZSA9IF9kaXNwYXRjaExpc3RlbmVycyRpO1xuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBjdXJyZW50VGFyZ2V0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcmV2aW91c0luc3RhbmNlKGV2ZW50KTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICBwcmV2aW91c0luc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoZG9tRXZlbnROYW1lLCB0YXJnZXRFbGVtZW50KSB7XG4gIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSB0YXJnZXRFbGVtZW50W2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV07XG4gIHZvaWQgMCA9PT0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ICYmXG4gICAgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9IHRhcmdldEVsZW1lbnRbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9XG4gICAgICBuZXcgU2V0KCkpO1xuICB2YXIgbGlzdGVuZXJTZXRLZXkgPSBkb21FdmVudE5hbWUgKyBcIl9fYnViYmxlXCI7XG4gIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5oYXMobGlzdGVuZXJTZXRLZXkpIHx8XG4gICAgKGFkZFRyYXBwZWRFdmVudExpc3RlbmVyKHRhcmdldEVsZW1lbnQsIGRvbUV2ZW50TmFtZSwgMiwgITEpLFxuICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdC5hZGQobGlzdGVuZXJTZXRLZXkpKTtcbn1cbmZ1bmN0aW9uIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyLCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50U3lzdGVtRmxhZ3MgPSAwO1xuICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyICYmIChldmVudFN5c3RlbUZsYWdzIHw9IDQpO1xuICBhZGRUcmFwcGVkRXZlbnRMaXN0ZW5lcihcbiAgICB0YXJnZXQsXG4gICAgZG9tRXZlbnROYW1lLFxuICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgaXNDYXB0dXJlUGhhc2VMaXN0ZW5lclxuICApO1xufVxudmFyIGxpc3RlbmluZ01hcmtlciA9IFwiX3JlYWN0TGlzdGVuaW5nXCIgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbmZ1bmN0aW9uIGxpc3RlblRvQWxsU3VwcG9ydGVkRXZlbnRzKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIGlmICghcm9vdENvbnRhaW5lckVsZW1lbnRbbGlzdGVuaW5nTWFya2VyXSkge1xuICAgIHJvb3RDb250YWluZXJFbGVtZW50W2xpc3RlbmluZ01hcmtlcl0gPSAhMDtcbiAgICBhbGxOYXRpdmVFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAoZG9tRXZlbnROYW1lKSB7XG4gICAgICBcInNlbGVjdGlvbmNoYW5nZVwiICE9PSBkb21FdmVudE5hbWUgJiZcbiAgICAgICAgKG5vbkRlbGVnYXRlZEV2ZW50cy5oYXMoZG9tRXZlbnROYW1lKSB8fFxuICAgICAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoZG9tRXZlbnROYW1lLCAhMSwgcm9vdENvbnRhaW5lckVsZW1lbnQpLFxuICAgICAgICBsaXN0ZW5Ub05hdGl2ZUV2ZW50KGRvbUV2ZW50TmFtZSwgITAsIHJvb3RDb250YWluZXJFbGVtZW50KSk7XG4gICAgfSk7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPVxuICAgICAgOSA9PT0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGVcbiAgICAgICAgPyByb290Q29udGFpbmVyRWxlbWVudFxuICAgICAgICA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gICAgbnVsbCA9PT0gb3duZXJEb2N1bWVudCB8fFxuICAgICAgb3duZXJEb2N1bWVudFtsaXN0ZW5pbmdNYXJrZXJdIHx8XG4gICAgICAoKG93bmVyRG9jdW1lbnRbbGlzdGVuaW5nTWFya2VyXSA9ICEwKSxcbiAgICAgIGxpc3RlblRvTmF0aXZlRXZlbnQoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgITEsIG93bmVyRG9jdW1lbnQpKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkVHJhcHBlZEV2ZW50TGlzdGVuZXIoXG4gIHRhcmdldENvbnRhaW5lcixcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4pIHtcbiAgc3dpdGNoIChnZXRFdmVudFByaW9yaXR5KGRvbUV2ZW50TmFtZSkpIHtcbiAgICBjYXNlIDI6XG4gICAgICB2YXIgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hEaXNjcmV0ZUV2ZW50O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hDb250aW51b3VzRXZlbnQ7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGlzdGVuZXJXcmFwcGVyID0gZGlzcGF0Y2hFdmVudDtcbiAgfVxuICBldmVudFN5c3RlbUZsYWdzID0gbGlzdGVuZXJXcmFwcGVyLmJpbmQoXG4gICAgbnVsbCxcbiAgICBkb21FdmVudE5hbWUsXG4gICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICB0YXJnZXRDb250YWluZXJcbiAgKTtcbiAgbGlzdGVuZXJXcmFwcGVyID0gdm9pZCAwO1xuICAhcGFzc2l2ZUJyb3dzZXJFdmVudHNTdXBwb3J0ZWQgfHxcbiAgICAoXCJ0b3VjaHN0YXJ0XCIgIT09IGRvbUV2ZW50TmFtZSAmJlxuICAgICAgXCJ0b3VjaG1vdmVcIiAhPT0gZG9tRXZlbnROYW1lICYmXG4gICAgICBcIndoZWVsXCIgIT09IGRvbUV2ZW50TmFtZSkgfHxcbiAgICAobGlzdGVuZXJXcmFwcGVyID0gITApO1xuICBpc0NhcHR1cmVQaGFzZUxpc3RlbmVyXG4gICAgPyB2b2lkIDAgIT09IGxpc3RlbmVyV3JhcHBlclxuICAgICAgPyB0YXJnZXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsIHtcbiAgICAgICAgICBjYXB0dXJlOiAhMCxcbiAgICAgICAgICBwYXNzaXZlOiBsaXN0ZW5lcldyYXBwZXJcbiAgICAgICAgfSlcbiAgICAgIDogdGFyZ2V0Q29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCAhMClcbiAgICA6IHZvaWQgMCAhPT0gbGlzdGVuZXJXcmFwcGVyXG4gICAgICA/IHRhcmdldENvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywge1xuICAgICAgICAgIHBhc3NpdmU6IGxpc3RlbmVyV3JhcHBlclxuICAgICAgICB9KVxuICAgICAgOiB0YXJnZXRDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihkb21FdmVudE5hbWUsIGV2ZW50U3lzdGVtRmxhZ3MsICExKTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICBuYXRpdmVFdmVudCxcbiAgdGFyZ2V0SW5zdCRqc2NvbXAkMCxcbiAgdGFyZ2V0Q29udGFpbmVyXG4pIHtcbiAgdmFyIGFuY2VzdG9ySW5zdCA9IHRhcmdldEluc3QkanNjb21wJDA7XG4gIGlmIChcbiAgICAwID09PSAoZXZlbnRTeXN0ZW1GbGFncyAmIDEpICYmXG4gICAgMCA9PT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiAyKSAmJlxuICAgIG51bGwgIT09IHRhcmdldEluc3QkanNjb21wJDBcbiAgKVxuICAgIGE6IGZvciAoOzspIHtcbiAgICAgIGlmIChudWxsID09PSB0YXJnZXRJbnN0JGpzY29tcCQwKSByZXR1cm47XG4gICAgICB2YXIgbm9kZVRhZyA9IHRhcmdldEluc3QkanNjb21wJDAudGFnO1xuICAgICAgaWYgKDMgPT09IG5vZGVUYWcgfHwgNCA9PT0gbm9kZVRhZykge1xuICAgICAgICB2YXIgY29udGFpbmVyID0gdGFyZ2V0SW5zdCRqc2NvbXAkMC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGNvbnRhaW5lciA9PT0gdGFyZ2V0Q29udGFpbmVyIHx8XG4gICAgICAgICAgKDggPT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJiBjb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGFyZ2V0Q29udGFpbmVyKVxuICAgICAgICApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICg0ID09PSBub2RlVGFnKVxuICAgICAgICAgIGZvciAobm9kZVRhZyA9IHRhcmdldEluc3QkanNjb21wJDAucmV0dXJuOyBudWxsICE9PSBub2RlVGFnOyApIHtcbiAgICAgICAgICAgIHZhciBncmFuZFRhZyA9IG5vZGVUYWcudGFnO1xuICAgICAgICAgICAgaWYgKDMgPT09IGdyYW5kVGFnIHx8IDQgPT09IGdyYW5kVGFnKVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKChncmFuZFRhZyA9IG5vZGVUYWcuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pLFxuICAgICAgICAgICAgICAgIGdyYW5kVGFnID09PSB0YXJnZXRDb250YWluZXIgfHxcbiAgICAgICAgICAgICAgICAgICg4ID09PSBncmFuZFRhZy5ub2RlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICBncmFuZFRhZy5wYXJlbnROb2RlID09PSB0YXJnZXRDb250YWluZXIpKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZVRhZyA9IG5vZGVUYWcucmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgZm9yICg7IG51bGwgIT09IGNvbnRhaW5lcjsgKSB7XG4gICAgICAgICAgbm9kZVRhZyA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKG51bGwgPT09IG5vZGVUYWcpIHJldHVybjtcbiAgICAgICAgICBncmFuZFRhZyA9IG5vZGVUYWcudGFnO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIDUgPT09IGdyYW5kVGFnIHx8XG4gICAgICAgICAgICA2ID09PSBncmFuZFRhZyB8fFxuICAgICAgICAgICAgMjYgPT09IGdyYW5kVGFnIHx8XG4gICAgICAgICAgICAyNyA9PT0gZ3JhbmRUYWdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHRhcmdldEluc3QkanNjb21wJDAgPSBhbmNlc3Rvckluc3QgPSBub2RlVGFnO1xuICAgICAgICAgICAgY29udGludWUgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRhcmdldEluc3QkanNjb21wJDAgPSB0YXJnZXRJbnN0JGpzY29tcCQwLnJldHVybjtcbiAgICB9XG4gIGJhdGNoZWRVcGRhdGVzJDEoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gYW5jZXN0b3JJbnN0LFxuICAgICAgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCksXG4gICAgICBkaXNwYXRjaFF1ZXVlID0gW107XG4gICAgYToge1xuICAgICAgdmFyIHJlYWN0TmFtZSA9IHRvcExldmVsRXZlbnRzVG9SZWFjdE5hbWVzLmdldChkb21FdmVudE5hbWUpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gcmVhY3ROYW1lKSB7XG4gICAgICAgIHZhciBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNFdmVudCxcbiAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IGRvbUV2ZW50TmFtZTtcbiAgICAgICAgc3dpdGNoIChkb21FdmVudE5hbWUpIHtcbiAgICAgICAgICBjYXNlIFwia2V5cHJlc3NcIjpcbiAgICAgICAgICAgIGlmICgwID09PSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSkgYnJlYWsgYTtcbiAgICAgICAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgICAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICAgICAgICByZWFjdEV2ZW50VHlwZSA9IFwiZm9jdXNcIjtcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgICAgIHJlYWN0RXZlbnRUeXBlID0gXCJibHVyXCI7XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJlZm9yZWJsdXJcIjpcbiAgICAgICAgICBjYXNlIFwiYWZ0ZXJibHVyXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImNsaWNrXCI6XG4gICAgICAgICAgICBpZiAoMiA9PT0gbmF0aXZlRXZlbnQuYnV0dG9uKSBicmVhayBhO1xuICAgICAgICAgIGNhc2UgXCJhdXhjbGlja1wiOlxuICAgICAgICAgIGNhc2UgXCJkYmxjbGlja1wiOlxuICAgICAgICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICAgICAgICBjYXNlIFwibW91c2Vtb3ZlXCI6XG4gICAgICAgICAgY2FzZSBcIm1vdXNldXBcIjpcbiAgICAgICAgICBjYXNlIFwibW91c2VvdXRcIjpcbiAgICAgICAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgICAgICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImRyYWdcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2V4aXRcIjpcbiAgICAgICAgICBjYXNlIFwiZHJhZ2xlYXZlXCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdvdmVyXCI6XG4gICAgICAgICAgY2FzZSBcImRyYWdzdGFydFwiOlxuICAgICAgICAgIGNhc2UgXCJkcm9wXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG91Y2hjYW5jZWxcIjpcbiAgICAgICAgICBjYXNlIFwidG91Y2hlbmRcIjpcbiAgICAgICAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgICAgICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEFOSU1BVElPTl9FTkQ6XG4gICAgICAgICAgY2FzZSBBTklNQVRJT05fSVRFUkFUSU9OOlxuICAgICAgICAgIGNhc2UgQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFRSQU5TSVRJT05fRU5EOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgIGNhc2UgXCJzY3JvbGxlbmRcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1VJRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwid2hlZWxcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiY29weVwiOlxuICAgICAgICAgIGNhc2UgXCJjdXRcIjpcbiAgICAgICAgICBjYXNlIFwicGFzdGVcIjpcbiAgICAgICAgICAgIFN5bnRoZXRpY0V2ZW50Q3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImdvdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICAgICAgY2FzZSBcImxvc3Rwb2ludGVyY2FwdHVyZVwiOlxuICAgICAgICAgIGNhc2UgXCJwb2ludGVyY2FuY2VsXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJkb3duXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJtb3ZlXCI6XG4gICAgICAgICAgY2FzZSBcInBvaW50ZXJvdXRcIjpcbiAgICAgICAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICAgICAgICBjYXNlIFwicG9pbnRlcnVwXCI6XG4gICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwidG9nZ2xlXCI6XG4gICAgICAgICAgY2FzZSBcImJlZm9yZXRvZ2dsZVwiOlxuICAgICAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID0gU3ludGhldGljVG9nZ2xlRXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluQ2FwdHVyZVBoYXNlID0gMCAhPT0gKGV2ZW50U3lzdGVtRmxhZ3MgJiA0KSxcbiAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAhaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgIChcInNjcm9sbFwiID09PSBkb21FdmVudE5hbWUgfHwgXCJzY3JvbGxlbmRcIiA9PT0gZG9tRXZlbnROYW1lKSxcbiAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IGluQ2FwdHVyZVBoYXNlXG4gICAgICAgICAgICA/IG51bGwgIT09IHJlYWN0TmFtZVxuICAgICAgICAgICAgICA/IHJlYWN0TmFtZSArIFwiQ2FwdHVyZVwiXG4gICAgICAgICAgICAgIDogbnVsbFxuICAgICAgICAgICAgOiByZWFjdE5hbWU7XG4gICAgICAgIGluQ2FwdHVyZVBoYXNlID0gW107XG4gICAgICAgIGZvciAoXG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gdGFyZ2V0SW5zdCwgbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgbnVsbCAhPT0gaW5zdGFuY2U7XG5cbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID0gX2luc3RhbmNlLnN0YXRlTm9kZTtcbiAgICAgICAgICBfaW5zdGFuY2UgPSBfaW5zdGFuY2UudGFnO1xuICAgICAgICAgICg1ICE9PSBfaW5zdGFuY2UgJiYgMjYgIT09IF9pbnN0YW5jZSAmJiAyNyAhPT0gX2luc3RhbmNlKSB8fFxuICAgICAgICAgICAgbnVsbCA9PT0gbGFzdEhvc3RDb21wb25lbnQgfHxcbiAgICAgICAgICAgIG51bGwgPT09IHJlYWN0RXZlbnROYW1lIHx8XG4gICAgICAgICAgICAoKF9pbnN0YW5jZSA9IGdldExpc3RlbmVyKGluc3RhbmNlLCByZWFjdEV2ZW50TmFtZSkpLFxuICAgICAgICAgICAgbnVsbCAhPSBfaW5zdGFuY2UgJiZcbiAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UucHVzaChcbiAgICAgICAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKGluc3RhbmNlLCBfaW5zdGFuY2UsIGxhc3RIb3N0Q29tcG9uZW50KVxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgICBpZiAoYWNjdW11bGF0ZVRhcmdldE9ubHkpIGJyZWFrO1xuICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIDAgPCBpbkNhcHR1cmVQaGFzZS5sZW5ndGggJiZcbiAgICAgICAgICAoKHJlYWN0TmFtZSA9IG5ldyBTeW50aGV0aWNFdmVudEN0b3IoXG4gICAgICAgICAgICByZWFjdE5hbWUsXG4gICAgICAgICAgICByZWFjdEV2ZW50VHlwZSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgKSksXG4gICAgICAgICAgZGlzcGF0Y2hRdWV1ZS5wdXNoKHsgZXZlbnQ6IHJlYWN0TmFtZSwgbGlzdGVuZXJzOiBpbkNhcHR1cmVQaGFzZSB9KSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgwID09PSAoZXZlbnRTeXN0ZW1GbGFncyAmIDcpKSB7XG4gICAgICBhOiB7XG4gICAgICAgIHJlYWN0TmFtZSA9XG4gICAgICAgICAgXCJtb3VzZW92ZXJcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwicG9pbnRlcm92ZXJcIiA9PT0gZG9tRXZlbnROYW1lO1xuICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IgPVxuICAgICAgICAgIFwibW91c2VvdXRcIiA9PT0gZG9tRXZlbnROYW1lIHx8IFwicG9pbnRlcm91dFwiID09PSBkb21FdmVudE5hbWU7XG4gICAgICAgIGlmIChcbiAgICAgICAgICByZWFjdE5hbWUgJiZcbiAgICAgICAgICBuYXRpdmVFdmVudCAhPT0gY3VycmVudFJlcGxheWluZ0V2ZW50ICYmXG4gICAgICAgICAgKHJlYWN0RXZlbnRUeXBlID1cbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpICYmXG4gICAgICAgICAgKGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlYWN0RXZlbnRUeXBlKSB8fFxuICAgICAgICAgICAgcmVhY3RFdmVudFR5cGVbaW50ZXJuYWxDb250YWluZXJJbnN0YW5jZUtleV0pXG4gICAgICAgIClcbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICBpZiAoU3ludGhldGljRXZlbnRDdG9yIHx8IHJlYWN0TmFtZSkge1xuICAgICAgICAgIHJlYWN0TmFtZSA9XG4gICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgID8gbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgOiAocmVhY3ROYW1lID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudClcbiAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZS5kZWZhdWx0VmlldyB8fCByZWFjdE5hbWUucGFyZW50V2luZG93XG4gICAgICAgICAgICAgICAgOiB3aW5kb3c7XG4gICAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3Rvcikge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAoKHJlYWN0RXZlbnRUeXBlID1cbiAgICAgICAgICAgICAgICBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudCksXG4gICAgICAgICAgICAgIChTeW50aGV0aWNFdmVudEN0b3IgPSB0YXJnZXRJbnN0KSxcbiAgICAgICAgICAgICAgKHJlYWN0RXZlbnRUeXBlID0gcmVhY3RFdmVudFR5cGVcbiAgICAgICAgICAgICAgICA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlYWN0RXZlbnRUeXBlKVxuICAgICAgICAgICAgICAgIDogbnVsbCksXG4gICAgICAgICAgICAgIG51bGwgIT09IHJlYWN0RXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgICAgKChhY2N1bXVsYXRlVGFyZ2V0T25seSA9XG4gICAgICAgICAgICAgICAgICBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHJlYWN0RXZlbnRUeXBlKSksXG4gICAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlID0gcmVhY3RFdmVudFR5cGUudGFnKSxcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSAhPT0gYWNjdW11bGF0ZVRhcmdldE9ubHkgfHxcbiAgICAgICAgICAgICAgICAgICg1ICE9PSBpbkNhcHR1cmVQaGFzZSAmJlxuICAgICAgICAgICAgICAgICAgICAyNyAhPT0gaW5DYXB0dXJlUGhhc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgNiAhPT0gaW5DYXB0dXJlUGhhc2UpKSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSAoU3ludGhldGljRXZlbnRDdG9yID0gbnVsbCksIChyZWFjdEV2ZW50VHlwZSA9IHRhcmdldEluc3QpO1xuICAgICAgICAgIGlmIChTeW50aGV0aWNFdmVudEN0b3IgIT09IHJlYWN0RXZlbnRUeXBlKSB7XG4gICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBcIm9uTW91c2VMZWF2ZVwiO1xuICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUgPSBcIm9uTW91c2VFbnRlclwiO1xuICAgICAgICAgICAgaW5zdGFuY2UgPSBcIm1vdXNlXCI7XG4gICAgICAgICAgICBpZiAoXCJwb2ludGVyb3V0XCIgPT09IGRvbUV2ZW50TmFtZSB8fCBcInBvaW50ZXJvdmVyXCIgPT09IGRvbUV2ZW50TmFtZSlcbiAgICAgICAgICAgICAgKGluQ2FwdHVyZVBoYXNlID0gU3ludGhldGljUG9pbnRlckV2ZW50KSxcbiAgICAgICAgICAgICAgICAoX2luc3RhbmNlID0gXCJvblBvaW50ZXJMZWF2ZVwiKSxcbiAgICAgICAgICAgICAgICAocmVhY3RFdmVudE5hbWUgPSBcIm9uUG9pbnRlckVudGVyXCIpLFxuICAgICAgICAgICAgICAgIChpbnN0YW5jZSA9IFwicG9pbnRlclwiKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID1cbiAgICAgICAgICAgICAgbnVsbCA9PSBTeW50aGV0aWNFdmVudEN0b3JcbiAgICAgICAgICAgICAgICA/IHJlYWN0TmFtZVxuICAgICAgICAgICAgICAgIDogZ2V0Tm9kZUZyb21JbnN0YW5jZShTeW50aGV0aWNFdmVudEN0b3IpO1xuICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQgPVxuICAgICAgICAgICAgICBudWxsID09IHJlYWN0RXZlbnRUeXBlXG4gICAgICAgICAgICAgICAgPyByZWFjdE5hbWVcbiAgICAgICAgICAgICAgICA6IGdldE5vZGVGcm9tSW5zdGFuY2UocmVhY3RFdmVudFR5cGUpO1xuICAgICAgICAgICAgcmVhY3ROYW1lID0gbmV3IGluQ2FwdHVyZVBoYXNlKFxuICAgICAgICAgICAgICBfaW5zdGFuY2UsXG4gICAgICAgICAgICAgIGluc3RhbmNlICsgXCJsZWF2ZVwiLFxuICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJlYWN0TmFtZS50YXJnZXQgPSBhY2N1bXVsYXRlVGFyZ2V0T25seTtcbiAgICAgICAgICAgIHJlYWN0TmFtZS5yZWxhdGVkVGFyZ2V0ID0gbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpID09PSB0YXJnZXRJbnN0ICYmXG4gICAgICAgICAgICAgICgoaW5DYXB0dXJlUGhhc2UgPSBuZXcgaW5DYXB0dXJlUGhhc2UoXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudE5hbWUsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgKyBcImVudGVyXCIsXG4gICAgICAgICAgICAgICAgcmVhY3RFdmVudFR5cGUsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAgKSksXG4gICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZS50YXJnZXQgPSBsYXN0SG9zdENvbXBvbmVudCksXG4gICAgICAgICAgICAgIChpbkNhcHR1cmVQaGFzZS5yZWxhdGVkVGFyZ2V0ID0gYWNjdW11bGF0ZVRhcmdldE9ubHkpLFxuICAgICAgICAgICAgICAoX2luc3RhbmNlID0gaW5DYXB0dXJlUGhhc2UpKTtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVUYXJnZXRPbmx5ID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgaWYgKFN5bnRoZXRpY0V2ZW50Q3RvciAmJiByZWFjdEV2ZW50VHlwZSlcbiAgICAgICAgICAgICAgYjoge1xuICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gU3ludGhldGljRXZlbnRDdG9yO1xuICAgICAgICAgICAgICAgIHJlYWN0RXZlbnROYW1lID0gcmVhY3RFdmVudFR5cGU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IGluQ2FwdHVyZVBoYXNlO1xuICAgICAgICAgICAgICAgICAgbGFzdEhvc3RDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudCA9IGdldFBhcmVudChsYXN0SG9zdENvbXBvbmVudClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSsrO1xuICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50ID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgICAgX2luc3RhbmNlID0gcmVhY3RFdmVudE5hbWU7XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICBfaW5zdGFuY2UgPSBnZXRQYXJlbnQoX2luc3RhbmNlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIGxhc3RIb3N0Q29tcG9uZW50Kys7XG4gICAgICAgICAgICAgICAgZm9yICg7IDAgPCBpbnN0YW5jZSAtIGxhc3RIb3N0Q29tcG9uZW50OyApXG4gICAgICAgICAgICAgICAgICAoaW5DYXB0dXJlUGhhc2UgPSBnZXRQYXJlbnQoaW5DYXB0dXJlUGhhc2UpKSwgaW5zdGFuY2UtLTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgMCA8IGxhc3RIb3N0Q29tcG9uZW50IC0gaW5zdGFuY2U7IClcbiAgICAgICAgICAgICAgICAgIChyZWFjdEV2ZW50TmFtZSA9IGdldFBhcmVudChyZWFjdEV2ZW50TmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICBsYXN0SG9zdENvbXBvbmVudC0tO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpbnN0YW5jZS0tOyApIHtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UgPT09IHJlYWN0RXZlbnROYW1lIHx8XG4gICAgICAgICAgICAgICAgICAgIChudWxsICE9PSByZWFjdEV2ZW50TmFtZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID09PSByZWFjdEV2ZW50TmFtZS5hbHRlcm5hdGUpXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSA9IGdldFBhcmVudChpbkNhcHR1cmVQaGFzZSk7XG4gICAgICAgICAgICAgICAgICByZWFjdEV2ZW50TmFtZSA9IGdldFBhcmVudChyZWFjdEV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluQ2FwdHVyZVBoYXNlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpbkNhcHR1cmVQaGFzZSA9IG51bGw7XG4gICAgICAgICAgICBudWxsICE9PSBTeW50aGV0aWNFdmVudEN0b3IgJiZcbiAgICAgICAgICAgICAgYWNjdW11bGF0ZUVudGVyTGVhdmVMaXN0ZW5lcnNGb3JFdmVudChcbiAgICAgICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLFxuICAgICAgICAgICAgICAgIHJlYWN0TmFtZSxcbiAgICAgICAgICAgICAgICBTeW50aGV0aWNFdmVudEN0b3IsXG4gICAgICAgICAgICAgICAgaW5DYXB0dXJlUGhhc2UsXG4gICAgICAgICAgICAgICAgITFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG51bGwgIT09IHJlYWN0RXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IGFjY3VtdWxhdGVUYXJnZXRPbmx5ICYmXG4gICAgICAgICAgICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlVGFyZ2V0T25seSxcbiAgICAgICAgICAgICAgICByZWFjdEV2ZW50VHlwZSxcbiAgICAgICAgICAgICAgICBpbkNhcHR1cmVQaGFzZSxcbiAgICAgICAgICAgICAgICAhMFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICByZWFjdE5hbWUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcbiAgICAgICAgU3ludGhldGljRXZlbnRDdG9yID1cbiAgICAgICAgICByZWFjdE5hbWUubm9kZU5hbWUgJiYgcmVhY3ROYW1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcInNlbGVjdFwiID09PSBTeW50aGV0aWNFdmVudEN0b3IgfHxcbiAgICAgICAgICAoXCJpbnB1dFwiID09PSBTeW50aGV0aWNFdmVudEN0b3IgJiYgXCJmaWxlXCIgPT09IHJlYWN0TmFtZS50eXBlKVxuICAgICAgICApXG4gICAgICAgICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgICAgICBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQocmVhY3ROYW1lKSlcbiAgICAgICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKVxuICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICAgICAgdmFyIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAoU3ludGhldGljRXZlbnRDdG9yID0gcmVhY3ROYW1lLm5vZGVOYW1lKSxcbiAgICAgICAgICAgICFTeW50aGV0aWNFdmVudEN0b3IgfHxcbiAgICAgICAgICAgIFwiaW5wdXRcIiAhPT0gU3ludGhldGljRXZlbnRDdG9yLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgICAgIChcImNoZWNrYm94XCIgIT09IHJlYWN0TmFtZS50eXBlICYmIFwicmFkaW9cIiAhPT0gcmVhY3ROYW1lLnR5cGUpXG4gICAgICAgICAgICAgID8gdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCh0YXJnZXRJbnN0LmVsZW1lbnRUeXBlKSAmJlxuICAgICAgICAgICAgICAgIChnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudClcbiAgICAgICAgICAgICAgOiAoZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyAmJlxuICAgICAgICAgIChnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGdW5jKGRvbUV2ZW50TmFtZSwgdGFyZ2V0SW5zdCkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChcbiAgICAgICAgICAgIGRpc3BhdGNoUXVldWUsXG4gICAgICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrIGE7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jICYmIGhhbmRsZUV2ZW50RnVuYyhkb21FdmVudE5hbWUsIHJlYWN0TmFtZSwgdGFyZ2V0SW5zdCk7XG4gICAgICAgIFwiZm9jdXNvdXRcIiA9PT0gZG9tRXZlbnROYW1lICYmXG4gICAgICAgICAgdGFyZ2V0SW5zdCAmJlxuICAgICAgICAgIFwibnVtYmVyXCIgPT09IHJlYWN0TmFtZS50eXBlICYmXG4gICAgICAgICAgbnVsbCAhPSB0YXJnZXRJbnN0Lm1lbW9pemVkUHJvcHMudmFsdWUgJiZcbiAgICAgICAgICBzZXREZWZhdWx0VmFsdWUocmVhY3ROYW1lLCBcIm51bWJlclwiLCByZWFjdE5hbWUudmFsdWUpO1xuICAgICAgfVxuICAgICAgaGFuZGxlRXZlbnRGdW5jID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG4gICAgICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgICAgICBjYXNlIFwiZm9jdXNpblwiOlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzVGV4dElucHV0RWxlbWVudChoYW5kbGVFdmVudEZ1bmMpIHx8XG4gICAgICAgICAgICBcInRydWVcIiA9PT0gaGFuZGxlRXZlbnRGdW5jLmNvbnRlbnRFZGl0YWJsZVxuICAgICAgICAgIClcbiAgICAgICAgICAgIChhY3RpdmVFbGVtZW50ID0gaGFuZGxlRXZlbnRGdW5jKSxcbiAgICAgICAgICAgICAgKGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdCksXG4gICAgICAgICAgICAgIChsYXN0U2VsZWN0aW9uID0gbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmb2N1c291dFwiOlxuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBhY3RpdmVFbGVtZW50SW5zdCA9IGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgICAgbW91c2VEb3duID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJjb250ZXh0bWVudVwiOlxuICAgICAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgICAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgICAgICAgIG1vdXNlRG93biA9ICExO1xuICAgICAgICAgIGNvbnN0cnVjdFNlbGVjdEV2ZW50KGRpc3BhdGNoUXVldWUsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjpcbiAgICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSBicmVhaztcbiAgICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgICAgY2FzZSBcImtleXVwXCI6XG4gICAgICAgICAgY29uc3RydWN0U2VsZWN0RXZlbnQoZGlzcGF0Y2hRdWV1ZSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIH1cbiAgICAgIHZhciBmYWxsYmFja0RhdGE7XG4gICAgICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudClcbiAgICAgICAgYjoge1xuICAgICAgICAgIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29tcG9zaXRpb25zdGFydFwiOlxuICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlID0gXCJvbkNvbXBvc2l0aW9uU3RhcnRcIjtcbiAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbmVuZFwiOlxuICAgICAgICAgICAgICBldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25FbmRcIjtcbiAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICAgIGNhc2UgXCJjb21wb3NpdGlvbnVwZGF0ZVwiOlxuICAgICAgICAgICAgICBldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25VcGRhdGVcIjtcbiAgICAgICAgICAgICAgYnJlYWsgYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnRUeXBlID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGlzQ29tcG9zaW5nXG4gICAgICAgICAgPyBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkgJiZcbiAgICAgICAgICAgIChldmVudFR5cGUgPSBcIm9uQ29tcG9zaXRpb25FbmRcIilcbiAgICAgICAgICA6IFwia2V5ZG93blwiID09PSBkb21FdmVudE5hbWUgJiZcbiAgICAgICAgICAgIDIyOSA9PT0gbmF0aXZlRXZlbnQua2V5Q29kZSAmJlxuICAgICAgICAgICAgKGV2ZW50VHlwZSA9IFwib25Db21wb3NpdGlvblN0YXJ0XCIpO1xuICAgICAgZXZlbnRUeXBlICYmXG4gICAgICAgICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSAmJlxuICAgICAgICAgIFwia29cIiAhPT0gbmF0aXZlRXZlbnQubG9jYWxlICYmXG4gICAgICAgICAgKGlzQ29tcG9zaW5nIHx8IFwib25Db21wb3NpdGlvblN0YXJ0XCIgIT09IGV2ZW50VHlwZVxuICAgICAgICAgICAgPyBcIm9uQ29tcG9zaXRpb25FbmRcIiA9PT0gZXZlbnRUeXBlICYmXG4gICAgICAgICAgICAgIGlzQ29tcG9zaW5nICYmXG4gICAgICAgICAgICAgIChmYWxsYmFja0RhdGEgPSBnZXREYXRhKCkpXG4gICAgICAgICAgICA6ICgocm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0KSxcbiAgICAgICAgICAgICAgKHN0YXJ0VGV4dCA9IFwidmFsdWVcIiBpbiByb290ID8gcm9vdC52YWx1ZSA6IHJvb3QudGV4dENvbnRlbnQpLFxuICAgICAgICAgICAgICAoaXNDb21wb3NpbmcgPSAhMCkpKSxcbiAgICAgICAgKGhhbmRsZUV2ZW50RnVuYyA9IGFjY3VtdWxhdGVUd29QaGFzZUxpc3RlbmVycyh0YXJnZXRJbnN0LCBldmVudFR5cGUpKSxcbiAgICAgICAgMCA8IGhhbmRsZUV2ZW50RnVuYy5sZW5ndGggJiZcbiAgICAgICAgICAoKGV2ZW50VHlwZSA9IG5ldyBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KFxuICAgICAgICAgICAgZXZlbnRUeXBlLFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICAgICApKSxcbiAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goeyBldmVudDogZXZlbnRUeXBlLCBsaXN0ZW5lcnM6IGhhbmRsZUV2ZW50RnVuYyB9KSxcbiAgICAgICAgICBmYWxsYmFja0RhdGFcbiAgICAgICAgICAgID8gKGV2ZW50VHlwZS5kYXRhID0gZmFsbGJhY2tEYXRhKVxuICAgICAgICAgICAgOiAoKGZhbGxiYWNrRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpKSxcbiAgICAgICAgICAgICAgbnVsbCAhPT0gZmFsbGJhY2tEYXRhICYmIChldmVudFR5cGUuZGF0YSA9IGZhbGxiYWNrRGF0YSkpKSk7XG4gICAgICBpZiAoXG4gICAgICAgIChmYWxsYmFja0RhdGEgPSBjYW5Vc2VUZXh0SW5wdXRFdmVudFxuICAgICAgICAgID8gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyhkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KVxuICAgICAgICAgIDogZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKGRvbUV2ZW50TmFtZSwgbmF0aXZlRXZlbnQpKVxuICAgICAgKVxuICAgICAgICAoZXZlbnRUeXBlID0gYWNjdW11bGF0ZVR3b1BoYXNlTGlzdGVuZXJzKHRhcmdldEluc3QsIFwib25CZWZvcmVJbnB1dFwiKSksXG4gICAgICAgICAgMCA8IGV2ZW50VHlwZS5sZW5ndGggJiZcbiAgICAgICAgICAgICgoaGFuZGxlRXZlbnRGdW5jID0gbmV3IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoXG4gICAgICAgICAgICAgIFwib25CZWZvcmVJbnB1dFwiLFxuICAgICAgICAgICAgICBcImJlZm9yZWlucHV0XCIsXG4gICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgICBuYXRpdmVFdmVudFRhcmdldFxuICAgICAgICAgICAgKSksXG4gICAgICAgICAgICBkaXNwYXRjaFF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICBldmVudDogaGFuZGxlRXZlbnRGdW5jLFxuICAgICAgICAgICAgICBsaXN0ZW5lcnM6IGV2ZW50VHlwZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAoaGFuZGxlRXZlbnRGdW5jLmRhdGEgPSBmYWxsYmFja0RhdGEpKTtcbiAgICAgIGV4dHJhY3RFdmVudHMkMShcbiAgICAgICAgZGlzcGF0Y2hRdWV1ZSxcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICB0YXJnZXRJbnN0LFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgbmF0aXZlRXZlbnRUYXJnZXRcbiAgICAgICk7XG4gICAgfVxuICAgIHByb2Nlc3NEaXNwYXRjaFF1ZXVlKGRpc3BhdGNoUXVldWUsIGV2ZW50U3lzdGVtRmxhZ3MpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIoaW5zdGFuY2UsIGxpc3RlbmVyLCBjdXJyZW50VGFyZ2V0KSB7XG4gIHJldHVybiB7XG4gICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICBjdXJyZW50VGFyZ2V0OiBjdXJyZW50VGFyZ2V0XG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VMaXN0ZW5lcnModGFyZ2V0RmliZXIsIHJlYWN0TmFtZSkge1xuICBmb3IgKFxuICAgIHZhciBjYXB0dXJlTmFtZSA9IHJlYWN0TmFtZSArIFwiQ2FwdHVyZVwiLCBsaXN0ZW5lcnMgPSBbXTtcbiAgICBudWxsICE9PSB0YXJnZXRGaWJlcjtcblxuICApIHtcbiAgICB2YXIgX2luc3RhbmNlMiA9IHRhcmdldEZpYmVyLFxuICAgICAgc3RhdGVOb2RlID0gX2luc3RhbmNlMi5zdGF0ZU5vZGU7XG4gICAgX2luc3RhbmNlMiA9IF9pbnN0YW5jZTIudGFnO1xuICAgICg1ICE9PSBfaW5zdGFuY2UyICYmIDI2ICE9PSBfaW5zdGFuY2UyICYmIDI3ICE9PSBfaW5zdGFuY2UyKSB8fFxuICAgICAgbnVsbCA9PT0gc3RhdGVOb2RlIHx8XG4gICAgICAoKF9pbnN0YW5jZTIgPSBnZXRMaXN0ZW5lcih0YXJnZXRGaWJlciwgY2FwdHVyZU5hbWUpKSxcbiAgICAgIG51bGwgIT0gX2luc3RhbmNlMiAmJlxuICAgICAgICBsaXN0ZW5lcnMudW5zaGlmdChcbiAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKHRhcmdldEZpYmVyLCBfaW5zdGFuY2UyLCBzdGF0ZU5vZGUpXG4gICAgICAgICksXG4gICAgICAoX2luc3RhbmNlMiA9IGdldExpc3RlbmVyKHRhcmdldEZpYmVyLCByZWFjdE5hbWUpKSxcbiAgICAgIG51bGwgIT0gX2luc3RhbmNlMiAmJlxuICAgICAgICBsaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICBjcmVhdGVEaXNwYXRjaExpc3RlbmVyKHRhcmdldEZpYmVyLCBfaW5zdGFuY2UyLCBzdGF0ZU5vZGUpXG4gICAgICAgICkpO1xuICAgIHRhcmdldEZpYmVyID0gdGFyZ2V0RmliZXIucmV0dXJuO1xuICB9XG4gIHJldHVybiBsaXN0ZW5lcnM7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBpZiAobnVsbCA9PT0gaW5zdCkgcmV0dXJuIG51bGw7XG4gIGRvIGluc3QgPSBpbnN0LnJldHVybjtcbiAgd2hpbGUgKGluc3QgJiYgNSAhPT0gaW5zdC50YWcgJiYgMjcgIT09IGluc3QudGFnKTtcbiAgcmV0dXJuIGluc3QgPyBpbnN0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlTGlzdGVuZXJzRm9yRXZlbnQoXG4gIGRpc3BhdGNoUXVldWUsXG4gIGV2ZW50LFxuICB0YXJnZXQsXG4gIGNvbW1vbixcbiAgaW5DYXB0dXJlUGhhc2Vcbikge1xuICBmb3IgKFxuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuX3JlYWN0TmFtZSwgbGlzdGVuZXJzID0gW107XG4gICAgbnVsbCAhPT0gdGFyZ2V0ICYmIHRhcmdldCAhPT0gY29tbW9uO1xuXG4gICkge1xuICAgIHZhciBfaW5zdGFuY2UzID0gdGFyZ2V0LFxuICAgICAgYWx0ZXJuYXRlID0gX2luc3RhbmNlMy5hbHRlcm5hdGUsXG4gICAgICBzdGF0ZU5vZGUgPSBfaW5zdGFuY2UzLnN0YXRlTm9kZTtcbiAgICBfaW5zdGFuY2UzID0gX2luc3RhbmNlMy50YWc7XG4gICAgaWYgKG51bGwgIT09IGFsdGVybmF0ZSAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikgYnJlYWs7XG4gICAgKDUgIT09IF9pbnN0YW5jZTMgJiYgMjYgIT09IF9pbnN0YW5jZTMgJiYgMjcgIT09IF9pbnN0YW5jZTMpIHx8XG4gICAgICBudWxsID09PSBzdGF0ZU5vZGUgfHxcbiAgICAgICgoYWx0ZXJuYXRlID0gc3RhdGVOb2RlKSxcbiAgICAgIGluQ2FwdHVyZVBoYXNlXG4gICAgICAgID8gKChzdGF0ZU5vZGUgPSBnZXRMaXN0ZW5lcih0YXJnZXQsIHJlZ2lzdHJhdGlvbk5hbWUpKSxcbiAgICAgICAgICBudWxsICE9IHN0YXRlTm9kZSAmJlxuICAgICAgICAgICAgbGlzdGVuZXJzLnVuc2hpZnQoXG4gICAgICAgICAgICAgIGNyZWF0ZURpc3BhdGNoTGlzdGVuZXIodGFyZ2V0LCBzdGF0ZU5vZGUsIGFsdGVybmF0ZSlcbiAgICAgICAgICAgICkpXG4gICAgICAgIDogaW5DYXB0dXJlUGhhc2UgfHxcbiAgICAgICAgICAoKHN0YXRlTm9kZSA9IGdldExpc3RlbmVyKHRhcmdldCwgcmVnaXN0cmF0aW9uTmFtZSkpLFxuICAgICAgICAgIG51bGwgIT0gc3RhdGVOb2RlICYmXG4gICAgICAgICAgICBsaXN0ZW5lcnMucHVzaChcbiAgICAgICAgICAgICAgY3JlYXRlRGlzcGF0Y2hMaXN0ZW5lcih0YXJnZXQsIHN0YXRlTm9kZSwgYWx0ZXJuYXRlKVxuICAgICAgICAgICAgKSkpO1xuICAgIHRhcmdldCA9IHRhcmdldC5yZXR1cm47XG4gIH1cbiAgMCAhPT0gbGlzdGVuZXJzLmxlbmd0aCAmJlxuICAgIGRpc3BhdGNoUXVldWUucHVzaCh7IGV2ZW50OiBldmVudCwgbGlzdGVuZXJzOiBsaXN0ZW5lcnMgfSk7XG59XG52YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZyxcbiAgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuZnVuY3Rpb24gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKG1hcmt1cCkge1xuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHR5cGVvZiBtYXJrdXAgPyBtYXJrdXAgOiBcIlwiICsgbWFya3VwKVxuICAgIC5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgXCJcXG5cIilcbiAgICAucmVwbGFjZShOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgsIFwiXCIpO1xufVxuZnVuY3Rpb24gY2hlY2tGb3JVbm1hdGNoZWRUZXh0KHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgY2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgcmV0dXJuIG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KSA9PT0gY2xpZW50VGV4dCA/ICEwIDogITE7XG59XG5mdW5jdGlvbiBub29wJDEoKSB7fVxuZnVuY3Rpb24gc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIGtleSwgdmFsdWUsIHByb3BzLCBwcmV2VmFsdWUpIHtcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICA/IFwiYm9keVwiID09PSB0YWcgfHxcbiAgICAgICAgICAoXCJ0ZXh0YXJlYVwiID09PSB0YWcgJiYgXCJcIiA9PT0gdmFsdWUpIHx8XG4gICAgICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgdmFsdWUpXG4gICAgICAgIDogKFwibnVtYmVyXCIgPT09IHR5cGVvZiB2YWx1ZSB8fCBcImJpZ2ludFwiID09PSB0eXBlb2YgdmFsdWUpICYmXG4gICAgICAgICAgXCJib2R5XCIgIT09IHRhZyAmJlxuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2xhc3NOYW1lXCI6XG4gICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwiY2xhc3NcIiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInRhYkluZGV4XCI6XG4gICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwidGFiaW5kZXhcIiwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRpclwiOlxuICAgIGNhc2UgXCJyb2xlXCI6XG4gICAgY2FzZSBcInZpZXdCb3hcIjpcbiAgICBjYXNlIFwid2lkdGhcIjpcbiAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICBzZXRWYWx1ZUZvcktub3duQXR0cmlidXRlKGRvbUVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdGFnKSB7XG4gICAgICAgIHNldFZhbHVlRm9yS25vd25BdHRyaWJ1dGUoZG9tRWxlbWVudCwgXCJkYXRhXCIsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBcInNyY1wiOlxuICAgIGNhc2UgXCJocmVmXCI6XG4gICAgICBpZiAoXCJcIiA9PT0gdmFsdWUgJiYgKFwiYVwiICE9PSB0YWcgfHwgXCJocmVmXCIgIT09IGtleSkpIHtcbiAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFjdGlvblwiOlxuICAgIGNhc2UgXCJmb3JtQWN0aW9uXCI6XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIFwiamF2YXNjcmlwdDp0aHJvdyBuZXcgRXJyb3IoJ0EgUmVhY3QgZm9ybSB3YXMgdW5leHBlY3RlZGx5IHN1Ym1pdHRlZC4gSWYgeW91IGNhbGxlZCBmb3JtLnN1Ym1pdCgpIG1hbnVhbGx5LCBjb25zaWRlciB1c2luZyBmb3JtLnJlcXVlc3RTdWJtaXQoKSBpbnN0ZWFkLiBJZiB5b3VcXFxcJ3JlIHRyeWluZyB0byB1c2UgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkgaW4gYSBzdWJtaXQgZXZlbnQgaGFuZGxlciwgY29uc2lkZXIgYWxzbyBjYWxsaW5nIGV2ZW50LnByZXZlbnREZWZhdWx0KCkuJylcIlxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZVxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBwcmV2VmFsdWUgJiZcbiAgICAgICAgICAoXCJmb3JtQWN0aW9uXCIgPT09IGtleVxuICAgICAgICAgICAgPyAoXCJpbnB1dFwiICE9PSB0YWcgJiZcbiAgICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJuYW1lXCIsIHByb3BzLm5hbWUsIHByb3BzLCBudWxsKSxcbiAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhZyxcbiAgICAgICAgICAgICAgICBcImZvcm1FbmNUeXBlXCIsXG4gICAgICAgICAgICAgICAgcHJvcHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIFwiZm9ybU1ldGhvZFwiLFxuICAgICAgICAgICAgICAgIHByb3BzLmZvcm1NZXRob2QsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIFwiZm9ybVRhcmdldFwiLFxuICAgICAgICAgICAgICAgIHByb3BzLmZvcm1UYXJnZXQsXG4gICAgICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICApKVxuICAgICAgICAgICAgOiAoc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwiZW5jVHlwZVwiLCBwcm9wcy5lbmNUeXBlLCBwcm9wcywgbnVsbCksXG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcIm1ldGhvZFwiLCBwcm9wcy5tZXRob2QsIHByb3BzLCBudWxsKSxcbiAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIFwidGFyZ2V0XCIsIHByb3BzLnRhcmdldCwgcHJvcHMsIG51bGwpKSk7XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgXCJzeW1ib2xcIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICAgIFwiYm9vbGVhblwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9uQ2xpY2tcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgKGRvbUVsZW1lbnQub25jbGljayA9IG5vb3AkMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvblNjcm9sbEVuZFwiOlxuICAgICAgbnVsbCAhPSB2YWx1ZSAmJiBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICBpZiAobnVsbCAhPSB2YWx1ZSkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPT0gdHlwZW9mIHZhbHVlIHx8ICEoXCJfX2h0bWxcIiBpbiB2YWx1ZSkpXG4gICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MSkpO1xuICAgICAgICBrZXkgPSB2YWx1ZS5fX2h0bWw7XG4gICAgICAgIGlmIChudWxsICE9IGtleSkge1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BzLmNoaWxkcmVuKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDYwKSk7XG4gICAgICAgICAgZG9tRWxlbWVudC5pbm5lckhUTUwgPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgZG9tRWxlbWVudC5tdWx0aXBsZSA9XG4gICAgICAgIHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJtdXRlZFwiOlxuICAgICAgZG9tRWxlbWVudC5tdXRlZCA9XG4gICAgICAgIHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIjpcbiAgICBjYXNlIFwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCI6XG4gICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgIGNhc2UgXCJkZWZhdWx0Q2hlY2tlZFwiOlxuICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICBjYXNlIFwicmVmXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYXV0b0ZvY3VzXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtIcmVmXCI6XG4gICAgICBpZiAoXG4gICAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgICAgXCJib29sZWFuXCIgPT09IHR5cGVvZiB2YWx1ZSB8fFxuICAgICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWVcbiAgICAgICkge1xuICAgICAgICBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInhsaW5rOmhyZWZcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAga2V5ID0gc2FuaXRpemVVUkwoXCJcIiArIHZhbHVlKTtcbiAgICAgIGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlTlMoXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOmhyZWZcIixcbiAgICAgICAga2V5XG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImNvbnRlbnRFZGl0YWJsZVwiOlxuICAgIGNhc2UgXCJzcGVsbENoZWNrXCI6XG4gICAgY2FzZSBcImRyYWdnYWJsZVwiOlxuICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgIGNhc2UgXCJhdXRvUmV2ZXJzZVwiOlxuICAgIGNhc2UgXCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCI6XG4gICAgY2FzZSBcImZvY3VzYWJsZVwiOlxuICAgIGNhc2UgXCJwcmVzZXJ2ZUFscGhhXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIHZhbHVlICYmIFwic3ltYm9sXCIgIT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICA/IGRvbUVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgXCJcIiArIHZhbHVlKVxuICAgICAgICA6IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5lcnRcIjpcbiAgICBjYXNlIFwiYWxsb3dGdWxsU2NyZWVuXCI6XG4gICAgY2FzZSBcImFzeW5jXCI6XG4gICAgY2FzZSBcImF1dG9QbGF5XCI6XG4gICAgY2FzZSBcImNvbnRyb2xzXCI6XG4gICAgY2FzZSBcImRlZmF1bHRcIjpcbiAgICBjYXNlIFwiZGVmZXJcIjpcbiAgICBjYXNlIFwiZGlzYWJsZWRcIjpcbiAgICBjYXNlIFwiZGlzYWJsZVBpY3R1cmVJblBpY3R1cmVcIjpcbiAgICBjYXNlIFwiZGlzYWJsZVJlbW90ZVBsYXliYWNrXCI6XG4gICAgY2FzZSBcImZvcm1Ob1ZhbGlkYXRlXCI6XG4gICAgY2FzZSBcImhpZGRlblwiOlxuICAgIGNhc2UgXCJsb29wXCI6XG4gICAgY2FzZSBcIm5vTW9kdWxlXCI6XG4gICAgY2FzZSBcIm5vVmFsaWRhdGVcIjpcbiAgICBjYXNlIFwib3BlblwiOlxuICAgIGNhc2UgXCJwbGF5c0lubGluZVwiOlxuICAgIGNhc2UgXCJyZWFkT25seVwiOlxuICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgIGNhc2UgXCJyZXZlcnNlZFwiOlxuICAgIGNhc2UgXCJzY29wZWRcIjpcbiAgICBjYXNlIFwic2VhbWxlc3NcIjpcbiAgICBjYXNlIFwiaXRlbVNjb3BlXCI6XG4gICAgICB2YWx1ZSAmJiBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJiBcInN5bWJvbFwiICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjYXB0dXJlXCI6XG4gICAgY2FzZSBcImRvd25sb2FkXCI6XG4gICAgICAhMCA9PT0gdmFsdWVcbiAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgIDogITEgIT09IHZhbHVlICYmXG4gICAgICAgICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgICAgICAgIDogZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJjb2xzXCI6XG4gICAgY2FzZSBcInJvd3NcIjpcbiAgICBjYXNlIFwic2l6ZVwiOlxuICAgIGNhc2UgXCJzcGFuXCI6XG4gICAgICBudWxsICE9IHZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiB2YWx1ZSAmJlxuICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIHZhbHVlICYmXG4gICAgICAhaXNOYU4odmFsdWUpICYmXG4gICAgICAxIDw9IHZhbHVlXG4gICAgICAgID8gZG9tRWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgICAgOiBkb21FbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJvd1NwYW5cIjpcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIG51bGwgPT0gdmFsdWUgfHxcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlIHx8XG4gICAgICBcInN5bWJvbFwiID09PSB0eXBlb2YgdmFsdWUgfHxcbiAgICAgIGlzTmFOKHZhbHVlKVxuICAgICAgICA/IGRvbUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGtleSlcbiAgICAgICAgOiBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJwb3BvdmVyXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiYmVmb3JldG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInRvZ2dsZVwiLCBkb21FbGVtZW50KTtcbiAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIFwicG9wb3ZlclwiLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtBY3R1YXRlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOmFjdHVhdGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtBcmNyb2xlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOmFyY3JvbGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtSb2xlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOnJvbGVcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtTaG93XCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICAgICAgICBcInhsaW5rOnNob3dcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieGxpbmtUaXRsZVwiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICAgICAgXCJ4bGluazp0aXRsZVwiLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ4bGlua1R5cGVcIjpcbiAgICAgIHNldFZhbHVlRm9yTmFtZXNwYWNlZEF0dHJpYnV0ZShcbiAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXG4gICAgICAgIFwieGxpbms6dHlwZVwiLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ4bWxCYXNlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgICAgIFwieG1sOmJhc2VcIixcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwieG1sTGFuZ1wiOlxuICAgICAgc2V0VmFsdWVGb3JOYW1lc3BhY2VkQXR0cmlidXRlKFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiLFxuICAgICAgICBcInhtbDpsYW5nXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInhtbFNwYWNlXCI6XG4gICAgICBzZXRWYWx1ZUZvck5hbWVzcGFjZWRBdHRyaWJ1dGUoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCIsXG4gICAgICAgIFwieG1sOnNwYWNlXCIsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImlzXCI6XG4gICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBcImlzXCIsIHZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbm5lclRleHRcIjpcbiAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoXG4gICAgICAgICEoMiA8IGtleS5sZW5ndGgpIHx8XG4gICAgICAgIChcIm9cIiAhPT0ga2V5WzBdICYmIFwiT1wiICE9PSBrZXlbMF0pIHx8XG4gICAgICAgIChcIm5cIiAhPT0ga2V5WzFdICYmIFwiTlwiICE9PSBrZXlbMV0pXG4gICAgICApXG4gICAgICAgIChrZXkgPSBhbGlhc2VzLmdldChrZXkpIHx8IGtleSksXG4gICAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFByb3BPbkN1c3RvbUVsZW1lbnQoZG9tRWxlbWVudCwgdGFnLCBrZXksIHZhbHVlLCBwcm9wcywgcHJldlZhbHVlKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCB2YWx1ZSwgcHJldlZhbHVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgaWYgKG51bGwgIT0gdmFsdWUpIHtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgIT09IHR5cGVvZiB2YWx1ZSB8fCAhKFwiX19odG1sXCIgaW4gdmFsdWUpKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNjEpKTtcbiAgICAgICAga2V5ID0gdmFsdWUuX19odG1sO1xuICAgICAgICBpZiAobnVsbCAhPSBrZXkpIHtcbiAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wcy5jaGlsZHJlbikgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg2MCkpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuaW5uZXJIVE1MID0ga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiB2YWx1ZVxuICAgICAgICA/IHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHZhbHVlKVxuICAgICAgICA6IChcIm51bWJlclwiID09PSB0eXBlb2YgdmFsdWUgfHwgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHZhbHVlKSAmJlxuICAgICAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIFwiXCIgKyB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib25TY3JvbGxcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcInNjcm9sbFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJvblNjcm9sbEVuZFwiOlxuICAgICAgbnVsbCAhPSB2YWx1ZSAmJiBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwic2Nyb2xsZW5kXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm9uQ2xpY2tcIjpcbiAgICAgIG51bGwgIT0gdmFsdWUgJiYgKGRvbUVsZW1lbnQub25jbGljayA9IG5vb3AkMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCI6XG4gICAgY2FzZSBcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiOlxuICAgIGNhc2UgXCJpbm5lckhUTUxcIjpcbiAgICBjYXNlIFwicmVmXCI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaW5uZXJUZXh0XCI6XG4gICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKCFyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgIGE6IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBcIm9cIiA9PT0ga2V5WzBdICYmXG4gICAgICAgICAgICBcIm5cIiA9PT0ga2V5WzFdICYmXG4gICAgICAgICAgICAoKHByb3BzID0ga2V5LmVuZHNXaXRoKFwiQ2FwdHVyZVwiKSksXG4gICAgICAgICAgICAodGFnID0ga2V5LnNsaWNlKDIsIHByb3BzID8ga2V5Lmxlbmd0aCAtIDcgOiB2b2lkIDApKSxcbiAgICAgICAgICAgIChwcmV2VmFsdWUgPSBkb21FbGVtZW50W2ludGVybmFsUHJvcHNLZXldIHx8IG51bGwpLFxuICAgICAgICAgICAgKHByZXZWYWx1ZSA9IG51bGwgIT0gcHJldlZhbHVlID8gcHJldlZhbHVlW2tleV0gOiBudWxsKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICBkb21FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodGFnLCBwcmV2VmFsdWUsIHByb3BzKSxcbiAgICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHZhbHVlKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgcHJldlZhbHVlICYmXG4gICAgICAgICAgICAgIG51bGwgIT09IHByZXZWYWx1ZSAmJlxuICAgICAgICAgICAgICAoa2V5IGluIGRvbUVsZW1lbnRcbiAgICAgICAgICAgICAgICA/IChkb21FbGVtZW50W2tleV0gPSBudWxsKVxuICAgICAgICAgICAgICAgIDogZG9tRWxlbWVudC5oYXNBdHRyaWJ1dGUoa2V5KSAmJlxuICAgICAgICAgICAgICAgICAgZG9tRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KSk7XG4gICAgICAgICAgICBkb21FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGFnLCB2YWx1ZSwgcHJvcHMpO1xuICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICB9XG4gICAgICAgICAga2V5IGluIGRvbUVsZW1lbnRcbiAgICAgICAgICAgID8gKGRvbUVsZW1lbnRba2V5XSA9IHZhbHVlKVxuICAgICAgICAgICAgOiAhMCA9PT0gdmFsdWVcbiAgICAgICAgICAgICAgPyBkb21FbGVtZW50LnNldEF0dHJpYnV0ZShrZXksIFwiXCIpXG4gICAgICAgICAgICAgIDogc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgXCJkaXZcIjpcbiAgICBjYXNlIFwic3BhblwiOlxuICAgIGNhc2UgXCJzdmdcIjpcbiAgICBjYXNlIFwicGF0aFwiOlxuICAgIGNhc2UgXCJhXCI6XG4gICAgY2FzZSBcImdcIjpcbiAgICBjYXNlIFwicFwiOlxuICAgIGNhc2UgXCJsaVwiOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImltZ1wiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImVycm9yXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICB2YXIgaGFzU3JjID0gITEsXG4gICAgICAgIGhhc1NyY1NldCA9ICExLFxuICAgICAgICBwcm9wS2V5O1xuICAgICAgZm9yIChwcm9wS2V5IGluIHByb3BzKVxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcEtleV07XG4gICAgICAgICAgaWYgKG51bGwgIT0gcHJvcFZhbHVlKVxuICAgICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgICAgICAgICBoYXNTcmMgPSAhMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInNyY1NldFwiOlxuICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9ICEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBwcm9wS2V5LCBwcm9wVmFsdWUsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaGFzU3JjU2V0ICYmXG4gICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBcInNyY1NldFwiLCBwcm9wcy5zcmNTZXQsIHByb3BzLCBudWxsKTtcbiAgICAgIGhhc1NyYyAmJiBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgXCJzcmNcIiwgcHJvcHMuc3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcImlucHV0XCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSAocHJvcEtleSA9IHByb3BWYWx1ZSA9IGhhc1NyY1NldCA9IG51bGwpLFxuICAgICAgICBjaGVja2VkID0gbnVsbCxcbiAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBudWxsO1xuICAgICAgZm9yIChoYXNTcmMgaW4gcHJvcHMpXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShoYXNTcmMpKSB7XG4gICAgICAgICAgdmFyIHByb3BWYWx1ZSQxODYgPSBwcm9wc1toYXNTcmNdO1xuICAgICAgICAgIGlmIChudWxsICE9IHByb3BWYWx1ZSQxODYpXG4gICAgICAgICAgICBzd2l0Y2ggKGhhc1NyYykge1xuICAgICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgIGhhc1NyY1NldCA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImNoZWNrZWRcIjpcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRDaGVja2VkXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBwcm9wVmFsdWUkMTg2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICAgICAgICBwcm9wS2V5ID0gcHJvcFZhbHVlJDE4NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZSA9IHByb3BWYWx1ZSQxODY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgICBpZiAobnVsbCAhPSBwcm9wVmFsdWUkMTg2KVxuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBoYXNTcmMsIHByb3BWYWx1ZSQxODYsIHByb3BzLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaW5pdElucHV0KFxuICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICBwcm9wS2V5LFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICBwcm9wVmFsdWUsXG4gICAgICAgIGhhc1NyY1NldCxcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGhhc1NyYyA9IHByb3BWYWx1ZSA9IHByb3BLZXkgPSBudWxsO1xuICAgICAgZm9yIChoYXNTcmNTZXQgaW4gcHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShoYXNTcmNTZXQpICYmXG4gICAgICAgICAgKChkZWZhdWx0VmFsdWUgPSBwcm9wc1toYXNTcmNTZXRdKSwgbnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKGhhc1NyY1NldCkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm11bHRpcGxlXCI6XG4gICAgICAgICAgICAgIGhhc1NyYyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBoYXNTcmNTZXQsIGRlZmF1bHRWYWx1ZSwgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIHRhZyA9IHByb3BLZXk7XG4gICAgICBwcm9wcyA9IHByb3BWYWx1ZTtcbiAgICAgIGRvbUVsZW1lbnQubXVsdGlwbGUgPSAhIWhhc1NyYztcbiAgICAgIG51bGwgIT0gdGFnXG4gICAgICAgID8gdXBkYXRlT3B0aW9ucyhkb21FbGVtZW50LCAhIWhhc1NyYywgdGFnLCAhMSlcbiAgICAgICAgOiBudWxsICE9IHByb3BzICYmIHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFoYXNTcmMsIHByb3BzLCAhMCk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiaW52YWxpZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BLZXkgPSBoYXNTcmNTZXQgPSBoYXNTcmMgPSBudWxsO1xuICAgICAgZm9yIChwcm9wVmFsdWUgaW4gcHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wVmFsdWUpICYmXG4gICAgICAgICAgKChkZWZhdWx0VmFsdWUgPSBwcm9wc1twcm9wVmFsdWVdKSwgbnVsbCAhPSBkZWZhdWx0VmFsdWUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHByb3BWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgIGhhc1NyYyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgIGhhc1NyY1NldCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgICAgcHJvcEtleSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gZGVmYXVsdFZhbHVlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkxKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BWYWx1ZSwgZGVmYXVsdFZhbHVlLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgaW5pdFRleHRhcmVhKGRvbUVsZW1lbnQsIGhhc1NyYywgaGFzU3JjU2V0LCBwcm9wS2V5KTtcbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgIGZvciAoY2hlY2tlZCBpbiBwcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgKChoYXNTcmMgPSBwcm9wc1tjaGVja2VkXSksIG51bGwgIT0gaGFzU3JjKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChjaGVja2VkKSB7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgaGFzU3JjICYmXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgaGFzU3JjICYmXG4gICAgICAgICAgICAgICAgXCJzeW1ib2xcIiAhPT0gdHlwZW9mIGhhc1NyYztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgY2hlY2tlZCwgaGFzU3JjLCBwcm9wcywgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJkaWFsb2dcIjpcbiAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJjYW5jZWxcIiwgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiY2xvc2VcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiaWZyYW1lXCI6XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgbGlzdGVuVG9Ob25EZWxlZ2F0ZWRFdmVudChcImxvYWRcIiwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwidmlkZW9cIjpcbiAgICBjYXNlIFwiYXVkaW9cIjpcbiAgICAgIGZvciAoaGFzU3JjID0gMDsgaGFzU3JjIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaGFzU3JjKyspXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2hhc1NyY10sIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgZG9tRWxlbWVudCk7XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwibG9hZFwiLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJkZXRhaWxzXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwidG9nZ2xlXCIsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVtYmVkXCI6XG4gICAgY2FzZSBcInNvdXJjZVwiOlxuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBsaXN0ZW5Ub05vbkRlbGVnYXRlZEV2ZW50KFwiZXJyb3JcIiwgZG9tRWxlbWVudCksXG4gICAgICAgIGxpc3RlblRvTm9uRGVsZWdhdGVkRXZlbnQoXCJsb2FkXCIsIGRvbUVsZW1lbnQpO1xuICAgIGNhc2UgXCJhcmVhXCI6XG4gICAgY2FzZSBcImJhc2VcIjpcbiAgICBjYXNlIFwiYnJcIjpcbiAgICBjYXNlIFwiY29sXCI6XG4gICAgY2FzZSBcImhyXCI6XG4gICAgY2FzZSBcImtleWdlblwiOlxuICAgIGNhc2UgXCJtZXRhXCI6XG4gICAgY2FzZSBcInBhcmFtXCI6XG4gICAgY2FzZSBcInRyYWNrXCI6XG4gICAgY2FzZSBcIndiclwiOlxuICAgIGNhc2UgXCJtZW51aXRlbVwiOlxuICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBwcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByb3BzLmhhc093blByb3BlcnR5KGRlZmF1bHRDaGVja2VkKSAmJlxuICAgICAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdENoZWNrZWRdKSwgbnVsbCAhPSBoYXNTcmMpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKGRlZmF1bHRDaGVja2VkKSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hpbGRyZW5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDEzNywgdGFnKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgZGVmYXVsdENoZWNrZWQsIGhhc1NyYywgcHJvcHMsIG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgIGZvciAocHJvcFZhbHVlJDE4NiBpbiBwcm9wcylcbiAgICAgICAgICBwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wVmFsdWUkMTg2KSAmJlxuICAgICAgICAgICAgKChoYXNTcmMgPSBwcm9wc1twcm9wVmFsdWUkMTg2XSksXG4gICAgICAgICAgICB2b2lkIDAgIT09IGhhc1NyYyAmJlxuICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHByb3BWYWx1ZSQxODYsXG4gICAgICAgICAgICAgICAgaGFzU3JjLFxuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIHZvaWQgMFxuICAgICAgICAgICAgICApKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG4gIGZvciAoZGVmYXVsdFZhbHVlIGluIHByb3BzKVxuICAgIHByb3BzLmhhc093blByb3BlcnR5KGRlZmF1bHRWYWx1ZSkgJiZcbiAgICAgICgoaGFzU3JjID0gcHJvcHNbZGVmYXVsdFZhbHVlXSksXG4gICAgICBudWxsICE9IGhhc1NyYyAmJlxuICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgZGVmYXVsdFZhbHVlLCBoYXNTcmMsIHByb3BzLCBudWxsKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHRhZywgbGFzdFByb3BzLCBuZXh0UHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIFwiZGl2XCI6XG4gICAgY2FzZSBcInNwYW5cIjpcbiAgICBjYXNlIFwic3ZnXCI6XG4gICAgY2FzZSBcInBhdGhcIjpcbiAgICBjYXNlIFwiYVwiOlxuICAgIGNhc2UgXCJnXCI6XG4gICAgY2FzZSBcInBcIjpcbiAgICBjYXNlIFwibGlcIjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJpbnB1dFwiOlxuICAgICAgdmFyIG5hbWUgPSBudWxsLFxuICAgICAgICB0eXBlID0gbnVsbCxcbiAgICAgICAgdmFsdWUgPSBudWxsLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBudWxsLFxuICAgICAgICBsYXN0RGVmYXVsdFZhbHVlID0gbnVsbCxcbiAgICAgICAgY2hlY2tlZCA9IG51bGwsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkID0gbnVsbDtcbiAgICAgIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICAgICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgICBpZiAobGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpICYmIG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgICAgc3dpdGNoIChwcm9wS2V5KSB7XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZhdWx0VmFsdWVcIjpcbiAgICAgICAgICAgICAgbGFzdERlZmF1bHRWYWx1ZSA9IGxhc3RQcm9wO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8XG4gICAgICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXksIG51bGwsIG5leHRQcm9wcywgbGFzdFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAodmFyIHByb3BLZXkkMjAzIGluIG5leHRQcm9wcykge1xuICAgICAgICB2YXIgcHJvcEtleSA9IG5leHRQcm9wc1twcm9wS2V5JDIwM107XG4gICAgICAgIGxhc3RQcm9wID0gbGFzdFByb3BzW3Byb3BLZXkkMjAzXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIwMykgJiZcbiAgICAgICAgICAobnVsbCAhPSBwcm9wS2V5IHx8IG51bGwgIT0gbGFzdFByb3ApXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHByb3BLZXkkMjAzKSB7XG4gICAgICAgICAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgICAgICAgICB0eXBlID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICBuYW1lID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tlZFwiOlxuICAgICAgICAgICAgICBjaGVja2VkID0gcHJvcEtleTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdENoZWNrZWRcIjpcbiAgICAgICAgICAgICAgZGVmYXVsdENoZWNrZWQgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICB2YWx1ZSA9IHByb3BLZXk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBwcm9wS2V5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgY2FzZSBcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI6XG4gICAgICAgICAgICAgIGlmIChudWxsICE9IHByb3BLZXkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHByb3BLZXkgIT09IGxhc3RQcm9wICYmXG4gICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICBwcm9wS2V5JDIwMyxcbiAgICAgICAgICAgICAgICAgIHByb3BLZXksXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBsYXN0UHJvcFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlSW5wdXQoXG4gICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkZWZhdWx0VmFsdWUsXG4gICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgIGNoZWNrZWQsXG4gICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICB0eXBlLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgIHByb3BLZXkgPSB2YWx1ZSA9IGRlZmF1bHRWYWx1ZSA9IHByb3BLZXkkMjAzID0gbnVsbDtcbiAgICAgIGZvciAodHlwZSBpbiBsYXN0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKGxhc3REZWZhdWx0VmFsdWUgPSBsYXN0UHJvcHNbdHlwZV0pLFxuICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSAmJiBudWxsICE9IGxhc3REZWZhdWx0VmFsdWUpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5ID0gbGFzdERlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSB8fFxuICAgICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgICBkb21FbGVtZW50LFxuICAgICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgICBsYXN0RGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKCh0eXBlID0gbmV4dFByb3BzW25hbWVdKSxcbiAgICAgICAgICAobGFzdERlZmF1bHRWYWx1ZSA9IGxhc3RQcm9wc1tuYW1lXSksXG4gICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KG5hbWUpICYmXG4gICAgICAgICAgICAobnVsbCAhPSB0eXBlIHx8IG51bGwgIT0gbGFzdERlZmF1bHRWYWx1ZSkpXG4gICAgICAgIClcbiAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBwcm9wS2V5JDIwMyA9IHR5cGU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmF1bHRWYWx1ZVwiOlxuICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSB0eXBlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtdWx0aXBsZVwiOlxuICAgICAgICAgICAgICB2YWx1ZSA9IHR5cGU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0eXBlICE9PSBsYXN0RGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgICAgICAgc2V0UHJvcChcbiAgICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIHRhZyA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGxhc3RQcm9wcyA9IHZhbHVlO1xuICAgICAgbmV4dFByb3BzID0gcHJvcEtleTtcbiAgICAgIG51bGwgIT0gcHJvcEtleSQyMDNcbiAgICAgICAgPyB1cGRhdGVPcHRpb25zKGRvbUVsZW1lbnQsICEhbGFzdFByb3BzLCBwcm9wS2V5JDIwMywgITEpXG4gICAgICAgIDogISFuZXh0UHJvcHMgIT09ICEhbGFzdFByb3BzICYmXG4gICAgICAgICAgKG51bGwgIT0gdGFnXG4gICAgICAgICAgICA/IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFsYXN0UHJvcHMsIHRhZywgITApXG4gICAgICAgICAgICA6IHVwZGF0ZU9wdGlvbnMoZG9tRWxlbWVudCwgISFsYXN0UHJvcHMsIGxhc3RQcm9wcyA/IFtdIDogXCJcIiwgITEpKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlIFwidGV4dGFyZWFcIjpcbiAgICAgIHByb3BLZXkgPSBwcm9wS2V5JDIwMyA9IG51bGw7XG4gICAgICBmb3IgKGRlZmF1bHRWYWx1ZSBpbiBsYXN0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKG5hbWUgPSBsYXN0UHJvcHNbZGVmYXVsdFZhbHVlXSksXG4gICAgICAgICAgbGFzdFByb3BzLmhhc093blByb3BlcnR5KGRlZmF1bHRWYWx1ZSkgJiZcbiAgICAgICAgICAgIG51bGwgIT0gbmFtZSAmJlxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0VmFsdWUpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ2YWx1ZVwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCBkZWZhdWx0VmFsdWUsIG51bGwsIG5leHRQcm9wcywgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgZm9yICh2YWx1ZSBpbiBuZXh0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKG5hbWUgPSBuZXh0UHJvcHNbdmFsdWVdKSxcbiAgICAgICAgICAodHlwZSA9IGxhc3RQcm9wc1t2YWx1ZV0pLFxuICAgICAgICAgIG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgKG51bGwgIT0gbmFtZSB8fCBudWxsICE9IHR5cGUpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgY2FzZSBcInZhbHVlXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkkMjAzID0gbmFtZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGVmYXVsdFZhbHVlXCI6XG4gICAgICAgICAgICAgIHByb3BLZXkgPSBuYW1lO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJjaGlsZHJlblwiOlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiOlxuICAgICAgICAgICAgICBpZiAobnVsbCAhPSBuYW1lKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDkxKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgbmFtZSAhPT0gdHlwZSAmJlxuICAgICAgICAgICAgICAgIHNldFByb3AoZG9tRWxlbWVudCwgdGFnLCB2YWx1ZSwgbmFtZSwgbmV4dFByb3BzLCB0eXBlKTtcbiAgICAgICAgICB9XG4gICAgICB1cGRhdGVUZXh0YXJlYShkb21FbGVtZW50LCBwcm9wS2V5JDIwMywgcHJvcEtleSk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgZm9yICh2YXIgcHJvcEtleSQyMTkgaW4gbGFzdFByb3BzKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKChwcm9wS2V5JDIwMyA9IGxhc3RQcm9wc1twcm9wS2V5JDIxOV0pLFxuICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIxOSkgJiZcbiAgICAgICAgICAgIG51bGwgIT0gcHJvcEtleSQyMDMgJiZcbiAgICAgICAgICAgICFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMTkpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChwcm9wS2V5JDIxOSkge1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdGVkXCI6XG4gICAgICAgICAgICAgIGRvbUVsZW1lbnQuc2VsZWN0ZWQgPSAhMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjE5LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgZm9yIChsYXN0RGVmYXVsdFZhbHVlIGluIG5leHRQcm9wcylcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgocHJvcEtleSQyMDMgPSBuZXh0UHJvcHNbbGFzdERlZmF1bHRWYWx1ZV0pLFxuICAgICAgICAgIChwcm9wS2V5ID0gbGFzdFByb3BzW2xhc3REZWZhdWx0VmFsdWVdKSxcbiAgICAgICAgICBuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkobGFzdERlZmF1bHRWYWx1ZSkgJiZcbiAgICAgICAgICAgIHByb3BLZXkkMjAzICE9PSBwcm9wS2V5ICYmXG4gICAgICAgICAgICAobnVsbCAhPSBwcm9wS2V5JDIwMyB8fCBudWxsICE9IHByb3BLZXkpKVxuICAgICAgICApXG4gICAgICAgICAgc3dpdGNoIChsYXN0RGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRcIjpcbiAgICAgICAgICAgICAgZG9tRWxlbWVudC5zZWxlY3RlZCA9XG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDMgJiZcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wS2V5JDIwMyAmJlxuICAgICAgICAgICAgICAgIFwic3ltYm9sXCIgIT09IHR5cGVvZiBwcm9wS2V5JDIwMztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBzZXRQcm9wKFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIGxhc3REZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDMsXG4gICAgICAgICAgICAgICAgbmV4dFByb3BzLFxuICAgICAgICAgICAgICAgIHByb3BLZXlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICByZXR1cm47XG4gICAgY2FzZSBcImltZ1wiOlxuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgY2FzZSBcImFyZWFcIjpcbiAgICBjYXNlIFwiYmFzZVwiOlxuICAgIGNhc2UgXCJiclwiOlxuICAgIGNhc2UgXCJjb2xcIjpcbiAgICBjYXNlIFwiZW1iZWRcIjpcbiAgICBjYXNlIFwiaHJcIjpcbiAgICBjYXNlIFwia2V5Z2VuXCI6XG4gICAgY2FzZSBcIm1ldGFcIjpcbiAgICBjYXNlIFwicGFyYW1cIjpcbiAgICBjYXNlIFwic291cmNlXCI6XG4gICAgY2FzZSBcInRyYWNrXCI6XG4gICAgY2FzZSBcIndiclwiOlxuICAgIGNhc2UgXCJtZW51aXRlbVwiOlxuICAgICAgZm9yICh2YXIgcHJvcEtleSQyMjQgaW4gbGFzdFByb3BzKVxuICAgICAgICAocHJvcEtleSQyMDMgPSBsYXN0UHJvcHNbcHJvcEtleSQyMjRdKSxcbiAgICAgICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMjQpICYmXG4gICAgICAgICAgICBudWxsICE9IHByb3BLZXkkMjAzICYmXG4gICAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjI0KSAmJlxuICAgICAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXkkMjI0LCBudWxsLCBuZXh0UHJvcHMsIHByb3BLZXkkMjAzKTtcbiAgICAgIGZvciAoY2hlY2tlZCBpbiBuZXh0UHJvcHMpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2NoZWNrZWRdKSxcbiAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tjaGVja2VkXSksXG4gICAgICAgICAgbmV4dFByb3BzLmhhc093blByb3BlcnR5KGNoZWNrZWQpICYmXG4gICAgICAgICAgICBwcm9wS2V5JDIwMyAhPT0gcHJvcEtleSAmJlxuICAgICAgICAgICAgKG51bGwgIT0gcHJvcEtleSQyMDMgfHwgbnVsbCAhPSBwcm9wS2V5KSlcbiAgICAgICAgKVxuICAgICAgICAgIHN3aXRjaCAoY2hlY2tlZCkge1xuICAgICAgICAgICAgY2FzZSBcImNoaWxkcmVuXCI6XG4gICAgICAgICAgICBjYXNlIFwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIjpcbiAgICAgICAgICAgICAgaWYgKG51bGwgIT0gcHJvcEtleSQyMDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgxMzcsIHRhZykpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHNldFByb3AoXG4gICAgICAgICAgICAgICAgZG9tRWxlbWVudCxcbiAgICAgICAgICAgICAgICB0YWcsXG4gICAgICAgICAgICAgICAgY2hlY2tlZCxcbiAgICAgICAgICAgICAgICBwcm9wS2V5JDIwMyxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcHJvcEtleVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKGlzQ3VzdG9tRWxlbWVudCh0YWcpKSB7XG4gICAgICAgIGZvciAodmFyIHByb3BLZXkkMjI5IGluIGxhc3RQcm9wcylcbiAgICAgICAgICAocHJvcEtleSQyMDMgPSBsYXN0UHJvcHNbcHJvcEtleSQyMjldKSxcbiAgICAgICAgICAgIGxhc3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIyOSkgJiZcbiAgICAgICAgICAgICAgdm9pZCAwICE9PSBwcm9wS2V5JDIwMyAmJlxuICAgICAgICAgICAgICAhbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkkMjI5KSAmJlxuICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjI5LFxuICAgICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgICBuZXh0UHJvcHMsXG4gICAgICAgICAgICAgICAgcHJvcEtleSQyMDNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgZm9yIChkZWZhdWx0Q2hlY2tlZCBpbiBuZXh0UHJvcHMpXG4gICAgICAgICAgKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2RlZmF1bHRDaGVja2VkXSksXG4gICAgICAgICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tkZWZhdWx0Q2hlY2tlZF0pLFxuICAgICAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShkZWZhdWx0Q2hlY2tlZCkgfHxcbiAgICAgICAgICAgICAgcHJvcEtleSQyMDMgPT09IHByb3BLZXkgfHxcbiAgICAgICAgICAgICAgKHZvaWQgMCA9PT0gcHJvcEtleSQyMDMgJiYgdm9pZCAwID09PSBwcm9wS2V5KSB8fFxuICAgICAgICAgICAgICBzZXRQcm9wT25DdXN0b21FbGVtZW50KFxuICAgICAgICAgICAgICAgIGRvbUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgdGFnLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRDaGVja2VkLFxuICAgICAgICAgICAgICAgIHByb3BLZXkkMjAzLFxuICAgICAgICAgICAgICAgIG5leHRQcm9wcyxcbiAgICAgICAgICAgICAgICBwcm9wS2V5XG4gICAgICAgICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICBmb3IgKHZhciBwcm9wS2V5JDIzNCBpbiBsYXN0UHJvcHMpXG4gICAgKHByb3BLZXkkMjAzID0gbGFzdFByb3BzW3Byb3BLZXkkMjM0XSksXG4gICAgICBsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSQyMzQpICYmXG4gICAgICAgIG51bGwgIT0gcHJvcEtleSQyMDMgJiZcbiAgICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5JDIzNCkgJiZcbiAgICAgICAgc2V0UHJvcChkb21FbGVtZW50LCB0YWcsIHByb3BLZXkkMjM0LCBudWxsLCBuZXh0UHJvcHMsIHByb3BLZXkkMjAzKTtcbiAgZm9yIChsYXN0UHJvcCBpbiBuZXh0UHJvcHMpXG4gICAgKHByb3BLZXkkMjAzID0gbmV4dFByb3BzW2xhc3RQcm9wXSksXG4gICAgICAocHJvcEtleSA9IGxhc3RQcm9wc1tsYXN0UHJvcF0pLFxuICAgICAgIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShsYXN0UHJvcCkgfHxcbiAgICAgICAgcHJvcEtleSQyMDMgPT09IHByb3BLZXkgfHxcbiAgICAgICAgKG51bGwgPT0gcHJvcEtleSQyMDMgJiYgbnVsbCA9PSBwcm9wS2V5KSB8fFxuICAgICAgICBzZXRQcm9wKGRvbUVsZW1lbnQsIHRhZywgbGFzdFByb3AsIHByb3BLZXkkMjAzLCBuZXh0UHJvcHMsIHByb3BLZXkpO1xufVxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsLFxuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIDkgPT09IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlXG4gICAgPyByb290Q29udGFpbmVyRWxlbWVudFxuICAgIDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldE93bkhvc3RDb250ZXh0KG5hbWVzcGFjZVVSSSkge1xuICBzd2l0Y2ggKG5hbWVzcGFjZVVSSSkge1xuICAgIGNhc2UgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiOlxuICAgICAgcmV0dXJuIDE7XG4gICAgY2FzZSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjpcbiAgICAgIHJldHVybiAyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hpbGRIb3N0Q29udGV4dFByb2QocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmICgwID09PSBwYXJlbnROYW1lc3BhY2UpXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwic3ZnXCI6XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgY2FzZSBcIm1hdGhcIjpcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gIHJldHVybiAxID09PSBwYXJlbnROYW1lc3BhY2UgJiYgXCJmb3JlaWduT2JqZWN0XCIgPT09IHR5cGVcbiAgICA/IDBcbiAgICA6IHBhcmVudE5hbWVzcGFjZTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByb3BzKSB7XG4gIHJldHVybiAoXG4gICAgXCJ0ZXh0YXJlYVwiID09PSB0eXBlIHx8XG4gICAgXCJub3NjcmlwdFwiID09PSB0eXBlIHx8XG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgXCJudW1iZXJcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgXCJiaWdpbnRcIiA9PT0gdHlwZW9mIHByb3BzLmNoaWxkcmVuIHx8XG4gICAgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAmJlxuICAgICAgbnVsbCAhPT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiZcbiAgICAgIG51bGwgIT0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sKVxuICApO1xufVxudmFyIGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCA9IG51bGw7XG5mdW5jdGlvbiBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgZXZlbnQgPSB3aW5kb3cuZXZlbnQ7XG4gIGlmIChldmVudCAmJiBcInBvcHN0YXRlXCIgPT09IGV2ZW50LnR5cGUpIHtcbiAgICBpZiAoZXZlbnQgPT09IGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCkgcmV0dXJuICExO1xuICAgIGN1cnJlbnRQb3BzdGF0ZVRyYW5zaXRpb25FdmVudCA9IGV2ZW50O1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBjdXJyZW50UG9wc3RhdGVUcmFuc2l0aW9uRXZlbnQgPSBudWxsO1xuICByZXR1cm4gITE7XG59XG52YXIgc2NoZWR1bGVUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiB2b2lkIDAsXG4gIGNhbmNlbFRpbWVvdXQgPSBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjbGVhclRpbWVvdXQgPyBjbGVhclRpbWVvdXQgOiB2b2lkIDAsXG4gIGxvY2FsUHJvbWlzZSA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFByb21pc2UgPyBQcm9taXNlIDogdm9pZCAwLFxuICBzY2hlZHVsZU1pY3JvdGFzayA9XG4gICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgcXVldWVNaWNyb3Rhc2tcbiAgICAgID8gcXVldWVNaWNyb3Rhc2tcbiAgICAgIDogXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGxvY2FsUHJvbWlzZVxuICAgICAgICA/IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsUHJvbWlzZVxuICAgICAgICAgICAgICAucmVzb2x2ZShudWxsKVxuICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgLmNhdGNoKGhhbmRsZUVycm9ySW5OZXh0VGljayk7XG4gICAgICAgICAgfVxuICAgICAgICA6IHNjaGVkdWxlVGltZW91dDtcbmZ1bmN0aW9uIGhhbmRsZUVycm9ySW5OZXh0VGljayhlcnJvcikge1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnkocGFyZW50SW5zdGFuY2UsIHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBzdXNwZW5zZUluc3RhbmNlLFxuICAgIGRlcHRoID0gMDtcbiAgZG8ge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgaWYgKG5leHROb2RlICYmIDggPT09IG5leHROb2RlLm5vZGVUeXBlKVxuICAgICAgaWYgKCgobm9kZSA9IG5leHROb2RlLmRhdGEpLCBcIi8kXCIgPT09IG5vZGUpKSB7XG4gICAgICAgIGlmICgwID09PSBkZXB0aCkge1xuICAgICAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKG5leHROb2RlKTtcbiAgICAgICAgICByZXRyeUlmQmxvY2tlZE9uKHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aC0tO1xuICAgICAgfSBlbHNlIChcIiRcIiAhPT0gbm9kZSAmJiBcIiQ/XCIgIT09IG5vZGUgJiYgXCIkIVwiICE9PSBub2RlKSB8fCBkZXB0aCsrO1xuICAgIG5vZGUgPSBuZXh0Tm9kZTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHJ5SWZCbG9ja2VkT24oc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5mdW5jdGlvbiBjbGVhckNvbnRhaW5lclNwYXJpbmdseShjb250YWluZXIpIHtcbiAgdmFyIG5leHROb2RlID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIG5leHROb2RlICYmIDEwID09PSBuZXh0Tm9kZS5ub2RlVHlwZSAmJiAobmV4dE5vZGUgPSBuZXh0Tm9kZS5uZXh0U2libGluZyk7XG4gIGZvciAoOyBuZXh0Tm9kZTsgKSB7XG4gICAgdmFyIG5vZGUgPSBuZXh0Tm9kZTtcbiAgICBuZXh0Tm9kZSA9IG5leHROb2RlLm5leHRTaWJsaW5nO1xuICAgIHN3aXRjaCAobm9kZS5ub2RlTmFtZSkge1xuICAgICAgY2FzZSBcIkhUTUxcIjpcbiAgICAgIGNhc2UgXCJIRUFEXCI6XG4gICAgICBjYXNlIFwiQk9EWVwiOlxuICAgICAgICBjbGVhckNvbnRhaW5lclNwYXJpbmdseShub2RlKTtcbiAgICAgICAgZGV0YWNoRGVsZXRlZEluc3RhbmNlKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgXCJTQ1JJUFRcIjpcbiAgICAgIGNhc2UgXCJTVFlMRVwiOlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgXCJMSU5LXCI6XG4gICAgICAgIGlmIChcInN0eWxlc2hlZXRcIiA9PT0gbm9kZS5yZWwudG9Mb3dlckNhc2UoKSkgY29udGludWU7XG4gICAgfVxuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FuSHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgZm9yICg7IDEgPT09IGluc3RhbmNlLm5vZGVUeXBlOyApIHtcbiAgICB2YXIgYW55UHJvcHMgPSBwcm9wcztcbiAgICBpZiAoaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gdHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFpblJvb3RPclNpbmdsZXRvbiAmJlxuICAgICAgICAoXCJJTlBVVFwiICE9PSBpbnN0YW5jZS5ub2RlTmFtZSB8fCBcImhpZGRlblwiICE9PSBpbnN0YW5jZS50eXBlKVxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKCFpblJvb3RPclNpbmdsZXRvbilcbiAgICAgIGlmIChcImlucHV0XCIgPT09IHR5cGUgJiYgXCJoaWRkZW5cIiA9PT0gaW5zdGFuY2UudHlwZSkge1xuICAgICAgICB2YXIgbmFtZSA9IG51bGwgPT0gYW55UHJvcHMubmFtZSA/IG51bGwgOiBcIlwiICsgYW55UHJvcHMubmFtZTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIFwiaGlkZGVuXCIgPT09IGFueVByb3BzLnR5cGUgJiZcbiAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09PSBuYW1lXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICB9IGVsc2UgcmV0dXJuIGluc3RhbmNlO1xuICAgIGVsc2UgaWYgKCFpbnN0YW5jZVtpbnRlcm5hbEhvaXN0YWJsZU1hcmtlcl0pXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICBpZiAoIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpKSBicmVhaztcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICAgICAgbmFtZSA9IGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInJlbFwiKTtcbiAgICAgICAgICBpZiAoXCJzdHlsZXNoZWV0XCIgPT09IG5hbWUgJiYgaW5zdGFuY2UuaGFzQXR0cmlidXRlKFwiZGF0YS1wcmVjZWRlbmNlXCIpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZWxzZSBpZiAoXG4gICAgICAgICAgICBuYW1lICE9PSBhbnlQcm9wcy5yZWwgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikgIT09XG4gICAgICAgICAgICAgIChudWxsID09IGFueVByb3BzLmhyZWYgPyBudWxsIDogYW55UHJvcHMuaHJlZikgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpICE9PVxuICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy5jcm9zc09yaWdpbiA/IG51bGwgOiBhbnlQcm9wcy5jcm9zc09yaWdpbikgfHxcbiAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInRpdGxlXCIpICE9PVxuICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy50aXRsZSA/IG51bGwgOiBhbnlQcm9wcy50aXRsZSlcbiAgICAgICAgICApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIGlmIChpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIikpIGJyZWFrO1xuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIG5hbWUgPSBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKG5hbWUgIT09IChudWxsID09IGFueVByb3BzLnNyYyA/IG51bGwgOiBhbnlQcm9wcy5zcmMpIHx8XG4gICAgICAgICAgICAgIGluc3RhbmNlLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09XG4gICAgICAgICAgICAgICAgKG51bGwgPT0gYW55UHJvcHMudHlwZSA/IG51bGwgOiBhbnlQcm9wcy50eXBlKSB8fFxuICAgICAgICAgICAgICBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoXCJjcm9zc29yaWdpblwiKSAhPT1cbiAgICAgICAgICAgICAgICAobnVsbCA9PSBhbnlQcm9wcy5jcm9zc09yaWdpbiA/IG51bGwgOiBhbnlQcm9wcy5jcm9zc09yaWdpbikpICYmXG4gICAgICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICBpbnN0YW5jZS5oYXNBdHRyaWJ1dGUoXCJhc3luY1wiKSAmJlxuICAgICAgICAgICAgIWluc3RhbmNlLmhhc0F0dHJpYnV0ZShcIml0ZW1wcm9wXCIpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH1cbiAgICBpbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbiAgICBpZiAobnVsbCA9PT0gaW5zdGFuY2UpIGJyZWFrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCwgaW5Sb290T3JTaW5nbGV0b24pIHtcbiAgaWYgKFwiXCIgPT09IHRleHQpIHJldHVybiBudWxsO1xuICBmb3IgKDsgMyAhPT0gaW5zdGFuY2Uubm9kZVR5cGU7ICkge1xuICAgIGlmIChcbiAgICAgICgxICE9PSBpbnN0YW5jZS5ub2RlVHlwZSB8fFxuICAgICAgICBcIklOUFVUXCIgIT09IGluc3RhbmNlLm5vZGVOYW1lIHx8XG4gICAgICAgIFwiaGlkZGVuXCIgIT09IGluc3RhbmNlLnR5cGUpICYmXG4gICAgICAhaW5Sb290T3JTaW5nbGV0b25cbiAgICApXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlKGluc3RhbmNlLm5leHRTaWJsaW5nKTtcbiAgICBpZiAobnVsbCA9PT0gaW5zdGFuY2UpIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlKG5vZGUpIHtcbiAgZm9yICg7IG51bGwgIT0gbm9kZTsgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgIGlmICgxID09PSBub2RlVHlwZSB8fCAzID09PSBub2RlVHlwZSkgYnJlYWs7XG4gICAgaWYgKDggPT09IG5vZGVUeXBlKSB7XG4gICAgICBub2RlVHlwZSA9IG5vZGUuZGF0YTtcbiAgICAgIGlmIChcbiAgICAgICAgXCIkXCIgPT09IG5vZGVUeXBlIHx8XG4gICAgICAgIFwiJCFcIiA9PT0gbm9kZVR5cGUgfHxcbiAgICAgICAgXCIkP1wiID09PSBub2RlVHlwZSB8fFxuICAgICAgICBcIkYhXCIgPT09IG5vZGVUeXBlIHx8XG4gICAgICAgIFwiRlwiID09PSBub2RlVHlwZVxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChcIi8kXCIgPT09IG5vZGVUeXBlKSByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRTdXNwZW5zZUluc3RhbmNlKHRhcmdldEluc3RhbmNlKSB7XG4gIHRhcmdldEluc3RhbmNlID0gdGFyZ2V0SW5zdGFuY2UucHJldmlvdXNTaWJsaW5nO1xuICBmb3IgKHZhciBkZXB0aCA9IDA7IHRhcmdldEluc3RhbmNlOyApIHtcbiAgICBpZiAoOCA9PT0gdGFyZ2V0SW5zdGFuY2Uubm9kZVR5cGUpIHtcbiAgICAgIHZhciBkYXRhID0gdGFyZ2V0SW5zdGFuY2UuZGF0YTtcbiAgICAgIGlmIChcIiRcIiA9PT0gZGF0YSB8fCBcIiQhXCIgPT09IGRhdGEgfHwgXCIkP1wiID09PSBkYXRhKSB7XG4gICAgICAgIGlmICgwID09PSBkZXB0aCkgcmV0dXJuIHRhcmdldEluc3RhbmNlO1xuICAgICAgICBkZXB0aC0tO1xuICAgICAgfSBlbHNlIFwiLyRcIiA9PT0gZGF0YSAmJiBkZXB0aCsrO1xuICAgIH1cbiAgICB0YXJnZXRJbnN0YW5jZSA9IHRhcmdldEluc3RhbmNlLnByZXZpb3VzU2libGluZztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gIHByb3BzID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJodG1sXCI6XG4gICAgICB0eXBlID0gcHJvcHMuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1MikpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgY2FzZSBcImhlYWRcIjpcbiAgICAgIHR5cGUgPSBwcm9wcy5oZWFkO1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1MykpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIHR5cGUgPSBwcm9wcy5ib2R5O1xuICAgICAgaWYgKCF0eXBlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ1NCkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDUxKSk7XG4gIH1cbn1cbnZhciBwcmVsb2FkUHJvcHNNYXAgPSBuZXcgTWFwKCksXG4gIHByZWNvbm5lY3RzU2V0ID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gZ2V0SG9pc3RhYmxlUm9vdChjb250YWluZXIpIHtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbnRhaW5lci5nZXRSb290Tm9kZVxuICAgID8gY29udGFpbmVyLmdldFJvb3ROb2RlKClcbiAgICA6IGNvbnRhaW5lci5vd25lckRvY3VtZW50O1xufVxudmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLmQ7XG5SZWFjdERPTVNoYXJlZEludGVybmFscy5kID0ge1xuICBmOiBmbHVzaFN5bmNXb3JrLFxuICByOiByZXF1ZXN0Rm9ybVJlc2V0LFxuICBEOiBwcmVmZXRjaEROUyxcbiAgQzogcHJlY29ubmVjdCxcbiAgTDogcHJlbG9hZCxcbiAgbTogcHJlbG9hZE1vZHVsZSxcbiAgWDogcHJlaW5pdFNjcmlwdCxcbiAgUzogcHJlaW5pdFN0eWxlLFxuICBNOiBwcmVpbml0TW9kdWxlU2NyaXB0XG59O1xuZnVuY3Rpb24gZmx1c2hTeW5jV29yaygpIHtcbiAgdmFyIHByZXZpb3VzV2FzUmVuZGVyaW5nID0gcHJldmlvdXNEaXNwYXRjaGVyLmYoKSxcbiAgICB3YXNSZW5kZXJpbmcgPSBmbHVzaFN5bmNXb3JrJDEoKTtcbiAgcmV0dXJuIHByZXZpb3VzV2FzUmVuZGVyaW5nIHx8IHdhc1JlbmRlcmluZztcbn1cbmZ1bmN0aW9uIHJlcXVlc3RGb3JtUmVzZXQoZm9ybSkge1xuICB2YXIgZm9ybUluc3QgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGZvcm0pO1xuICBudWxsICE9PSBmb3JtSW5zdCAmJiA1ID09PSBmb3JtSW5zdC50YWcgJiYgXCJmb3JtXCIgPT09IGZvcm1JbnN0LnR5cGVcbiAgICA/IHJlcXVlc3RGb3JtUmVzZXQkMShmb3JtSW5zdClcbiAgICA6IHByZXZpb3VzRGlzcGF0Y2hlci5yKGZvcm0pO1xufVxudmFyIGdsb2JhbERvY3VtZW50ID0gXCJ1bmRlZmluZWRcIiA9PT0gdHlwZW9mIGRvY3VtZW50ID8gbnVsbCA6IGRvY3VtZW50O1xuZnVuY3Rpb24gcHJlY29ubmVjdEFzKHJlbCwgaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYgJiYgaHJlZikge1xuICAgIHZhciBsaW1pdGVkRXNjYXBlZEhyZWYgPVxuICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKTtcbiAgICBsaW1pdGVkRXNjYXBlZEhyZWYgPVxuICAgICAgJ2xpbmtbcmVsPVwiJyArIHJlbCArICdcIl1baHJlZj1cIicgKyBsaW1pdGVkRXNjYXBlZEhyZWYgKyAnXCJdJztcbiAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgY3Jvc3NPcmlnaW4gJiZcbiAgICAgIChsaW1pdGVkRXNjYXBlZEhyZWYgKz0gJ1tjcm9zc29yaWdpbj1cIicgKyBjcm9zc09yaWdpbiArICdcIl0nKTtcbiAgICBwcmVjb25uZWN0c1NldC5oYXMobGltaXRlZEVzY2FwZWRIcmVmKSB8fFxuICAgICAgKHByZWNvbm5lY3RzU2V0LmFkZChsaW1pdGVkRXNjYXBlZEhyZWYpLFxuICAgICAgKHJlbCA9IHsgcmVsOiByZWwsIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbiwgaHJlZjogaHJlZiB9KSxcbiAgICAgIG51bGwgPT09IG93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihsaW1pdGVkRXNjYXBlZEhyZWYpICYmXG4gICAgICAgICgoaHJlZiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpLFxuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhocmVmLCBcImxpbmtcIiwgcmVsKSxcbiAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShocmVmKSxcbiAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGhyZWYpKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWZldGNoRE5TKGhyZWYpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLkQoaHJlZik7XG4gIHByZWNvbm5lY3RBcyhcImRucy1wcmVmZXRjaFwiLCBocmVmLCBudWxsKTtcbn1cbmZ1bmN0aW9uIHByZWNvbm5lY3QoaHJlZiwgY3Jvc3NPcmlnaW4pIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLkMoaHJlZiwgY3Jvc3NPcmlnaW4pO1xuICBwcmVjb25uZWN0QXMoXCJwcmVjb25uZWN0XCIsIGhyZWYsIGNyb3NzT3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHByZWxvYWQoaHJlZiwgYXMsIG9wdGlvbnMpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLkwoaHJlZiwgYXMsIG9wdGlvbnMpO1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmICYmIGFzKSB7XG4gICAgdmFyIHByZWxvYWRTZWxlY3RvciA9XG4gICAgICAnbGlua1tyZWw9XCJwcmVsb2FkXCJdW2FzPVwiJyArXG4gICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGFzKSArXG4gICAgICAnXCJdJztcbiAgICBcImltYWdlXCIgPT09IGFzXG4gICAgICA/IG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVNyY1NldFxuICAgICAgICA/ICgocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAnW2ltYWdlc3Jjc2V0PVwiJyArXG4gICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICBvcHRpb25zLmltYWdlU3JjU2V0XG4gICAgICAgICAgICApICtcbiAgICAgICAgICAgICdcIl0nKSxcbiAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzICYmXG4gICAgICAgICAgICAocHJlbG9hZFNlbGVjdG9yICs9XG4gICAgICAgICAgICAgICdbaW1hZ2VzaXplcz1cIicgK1xuICAgICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKFxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW1hZ2VTaXplc1xuICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgJ1wiXScpKVxuICAgICAgICA6IChwcmVsb2FkU2VsZWN0b3IgKz1cbiAgICAgICAgICAgICdbaHJlZj1cIicgK1xuICAgICAgICAgICAgZXNjYXBlU2VsZWN0b3JBdHRyaWJ1dGVWYWx1ZUluc2lkZURvdWJsZVF1b3RlcyhocmVmKSArXG4gICAgICAgICAgICAnXCJdJylcbiAgICAgIDogKHByZWxvYWRTZWxlY3RvciArPVxuICAgICAgICAgICdbaHJlZj1cIicgK1xuICAgICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgK1xuICAgICAgICAgICdcIl0nKTtcbiAgICB2YXIga2V5ID0gcHJlbG9hZFNlbGVjdG9yO1xuICAgIHN3aXRjaCAoYXMpIHtcbiAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICBrZXkgPSBnZXRTdHlsZUtleShocmVmKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgIGtleSA9IGdldFNjcmlwdEtleShocmVmKTtcbiAgICB9XG4gICAgcHJlbG9hZFByb3BzTWFwLmhhcyhrZXkpIHx8XG4gICAgICAoKGhyZWYgPSBhc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgIGhyZWY6XG4gICAgICAgICAgICBcImltYWdlXCIgPT09IGFzICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5pbWFnZVNyY1NldCA/IHZvaWQgMCA6IGhyZWYsXG4gICAgICAgICAgYXM6IGFzXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICkpLFxuICAgICAgcHJlbG9hZFByb3BzTWFwLnNldChrZXksIGhyZWYpLFxuICAgICAgbnVsbCAhPT0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHByZWxvYWRTZWxlY3RvcikgfHxcbiAgICAgICAgKFwic3R5bGVcIiA9PT0gYXMgJiZcbiAgICAgICAgICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U3R5bGVzaGVldFNlbGVjdG9yRnJvbUtleShrZXkpKSkgfHxcbiAgICAgICAgKFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgICAgb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSkgfHxcbiAgICAgICAgKChhcyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpLFxuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhhcywgXCJsaW5rXCIsIGhyZWYpLFxuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGFzKSxcbiAgICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGFzKSkpO1xuICB9XG59XG5mdW5jdGlvbiBwcmVsb2FkTW9kdWxlKGhyZWYsIG9wdGlvbnMpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLm0oaHJlZiwgb3B0aW9ucyk7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIGhyZWYpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zICYmIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzID8gb3B0aW9ucy5hcyA6IFwic2NyaXB0XCIsXG4gICAgICBwcmVsb2FkU2VsZWN0b3IgPVxuICAgICAgICAnbGlua1tyZWw9XCJtb2R1bGVwcmVsb2FkXCJdW2FzPVwiJyArXG4gICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoYXMpICtcbiAgICAgICAgJ1wiXVtocmVmPVwiJyArXG4gICAgICAgIGVzY2FwZVNlbGVjdG9yQXR0cmlidXRlVmFsdWVJbnNpZGVEb3VibGVRdW90ZXMoaHJlZikgK1xuICAgICAgICAnXCJdJyxcbiAgICAgIGtleSA9IHByZWxvYWRTZWxlY3RvcjtcbiAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICBjYXNlIFwiYXVkaW93b3JrbGV0XCI6XG4gICAgICBjYXNlIFwicGFpbnR3b3JrbGV0XCI6XG4gICAgICBjYXNlIFwic2VydmljZXdvcmtlclwiOlxuICAgICAgY2FzZSBcInNoYXJlZHdvcmtlclwiOlxuICAgICAgY2FzZSBcIndvcmtlclwiOlxuICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICBrZXkgPSBnZXRTY3JpcHRLZXkoaHJlZik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgICFwcmVsb2FkUHJvcHNNYXAuaGFzKGtleSkgJiZcbiAgICAgICgoaHJlZiA9IGFzc2lnbih7IHJlbDogXCJtb2R1bGVwcmVsb2FkXCIsIGhyZWY6IGhyZWYgfSwgb3B0aW9ucykpLFxuICAgICAgcHJlbG9hZFByb3BzTWFwLnNldChrZXksIGhyZWYpLFxuICAgICAgbnVsbCA9PT0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKHByZWxvYWRTZWxlY3RvcikpXG4gICAgKSB7XG4gICAgICBzd2l0Y2ggKGFzKSB7XG4gICAgICAgIGNhc2UgXCJhdWRpb3dvcmtsZXRcIjpcbiAgICAgICAgY2FzZSBcInBhaW50d29ya2xldFwiOlxuICAgICAgICBjYXNlIFwic2VydmljZXdvcmtlclwiOlxuICAgICAgICBjYXNlIFwic2hhcmVkd29ya2VyXCI6XG4gICAgICAgIGNhc2UgXCJ3b3JrZXJcIjpcbiAgICAgICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgICAgIGlmIChvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpO1xuICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoYXMsIFwibGlua1wiLCBocmVmKTtcbiAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoYXMpO1xuICAgICAgb3duZXJEb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGFzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWluaXRTdHlsZShocmVmLCBwcmVjZWRlbmNlLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5TKGhyZWYsIHByZWNlZGVuY2UsIG9wdGlvbnMpO1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGdsb2JhbERvY3VtZW50O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBocmVmKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFJlc291cmNlc0Zyb21Sb290KG93bmVyRG9jdW1lbnQpLmhvaXN0YWJsZVN0eWxlcyxcbiAgICAgIGtleSA9IGdldFN0eWxlS2V5KGhyZWYpO1xuICAgIHByZWNlZGVuY2UgPSBwcmVjZWRlbmNlIHx8IFwiZGVmYXVsdFwiO1xuICAgIHZhciByZXNvdXJjZSA9IHN0eWxlcy5nZXQoa2V5KTtcbiAgICBpZiAoIXJlc291cmNlKSB7XG4gICAgICB2YXIgc3RhdGUgPSB7IGxvYWRpbmc6IDAsIHByZWxvYWQ6IG51bGwgfTtcbiAgICAgIGlmIChcbiAgICAgICAgKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KVxuICAgICAgICApKVxuICAgICAgKVxuICAgICAgICBzdGF0ZS5sb2FkaW5nID0gNTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBocmVmID0gYXNzaWduKFxuICAgICAgICAgIHsgcmVsOiBcInN0eWxlc2hlZXRcIiwgaHJlZjogaHJlZiwgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJlY2VkZW5jZSB9LFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgICAgKG9wdGlvbnMgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGhyZWYsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgbGluayA9IChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIikpO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGxpbmspO1xuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhsaW5rLCBcImxpbmtcIiwgaHJlZik7XG4gICAgICAgIGxpbmsuX3AgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgbGluay5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICAgIGxpbmsub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlLmxvYWRpbmcgfD0gMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzdGF0ZS5sb2FkaW5nIHw9IDI7XG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5sb2FkaW5nIHw9IDQ7XG4gICAgICAgIGluc2VydFN0eWxlc2hlZXQocmVzb3VyY2UsIHByZWNlZGVuY2UsIG93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgcmVzb3VyY2UgPSB7XG4gICAgICAgIHR5cGU6IFwic3R5bGVzaGVldFwiLFxuICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgIH07XG4gICAgICBzdHlsZXMuc2V0KGtleSwgcmVzb3VyY2UpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJlaW5pdFNjcmlwdChzcmMsIG9wdGlvbnMpIHtcbiAgcHJldmlvdXNEaXNwYXRjaGVyLlgoc3JjLCBvcHRpb25zKTtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgc3JjKSB7XG4gICAgdmFyIHNjcmlwdHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChvd25lckRvY3VtZW50KS5ob2lzdGFibGVTY3JpcHRzLFxuICAgICAga2V5ID0gZ2V0U2NyaXB0S2V5KHNyYyksXG4gICAgICByZXNvdXJjZSA9IHNjcmlwdHMuZ2V0KGtleSk7XG4gICAgcmVzb3VyY2UgfHxcbiAgICAgICgocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZ2V0U2NyaXB0U2VsZWN0b3JGcm9tS2V5KGtleSkpKSxcbiAgICAgIHJlc291cmNlIHx8XG4gICAgICAgICgoc3JjID0gYXNzaWduKHsgc3JjOiBzcmMsIGFzeW5jOiAhMCB9LCBvcHRpb25zKSksXG4gICAgICAgIChvcHRpb25zID0gcHJlbG9hZFByb3BzTWFwLmdldChrZXkpKSAmJlxuICAgICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU2NyaXB0KHNyYywgb3B0aW9ucyksXG4gICAgICAgIChyZXNvdXJjZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSksXG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUocmVzb3VyY2UpLFxuICAgICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhyZXNvdXJjZSwgXCJsaW5rXCIsIHNyYyksXG4gICAgICAgIG93bmVyRG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChyZXNvdXJjZSkpLFxuICAgICAgKHJlc291cmNlID0ge1xuICAgICAgICB0eXBlOiBcInNjcmlwdFwiLFxuICAgICAgICBpbnN0YW5jZTogcmVzb3VyY2UsXG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgfSksXG4gICAgICBzY3JpcHRzLnNldChrZXksIHJlc291cmNlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByZWluaXRNb2R1bGVTY3JpcHQoc3JjLCBvcHRpb25zKSB7XG4gIHByZXZpb3VzRGlzcGF0Y2hlci5NKHNyYywgb3B0aW9ucyk7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2xvYmFsRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIHNyYykge1xuICAgIHZhciBzY3JpcHRzID0gZ2V0UmVzb3VyY2VzRnJvbVJvb3Qob3duZXJEb2N1bWVudCkuaG9pc3RhYmxlU2NyaXB0cyxcbiAgICAgIGtleSA9IGdldFNjcmlwdEtleShzcmMpLFxuICAgICAgcmVzb3VyY2UgPSBzY3JpcHRzLmdldChrZXkpO1xuICAgIHJlc291cmNlIHx8XG4gICAgICAoKHJlc291cmNlID0gb3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpKSksXG4gICAgICByZXNvdXJjZSB8fFxuICAgICAgICAoKHNyYyA9IGFzc2lnbih7IHNyYzogc3JjLCBhc3luYzogITAsIHR5cGU6IFwibW9kdWxlXCIgfSwgb3B0aW9ucykpLFxuICAgICAgICAob3B0aW9ucyA9IHByZWxvYWRQcm9wc01hcC5nZXQoa2V5KSkgJiZcbiAgICAgICAgICBhZG9wdFByZWxvYWRQcm9wc0ZvclNjcmlwdChzcmMsIG9wdGlvbnMpLFxuICAgICAgICAocmVzb3VyY2UgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpLFxuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHJlc291cmNlKSxcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMocmVzb3VyY2UsIFwibGlua1wiLCBzcmMpLFxuICAgICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQocmVzb3VyY2UpKSxcbiAgICAgIChyZXNvdXJjZSA9IHtcbiAgICAgICAgdHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgaW5zdGFuY2U6IHJlc291cmNlLFxuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgc3RhdGU6IG51bGxcbiAgICAgIH0pLFxuICAgICAgc2NyaXB0cy5zZXQoa2V5LCByZXNvdXJjZSkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvdXJjZSh0eXBlLCBjdXJyZW50UHJvcHMsIHBlbmRpbmdQcm9wcywgY3VycmVudFJlc291cmNlKSB7XG4gIHZhciBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSAoSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID1cbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KVxuICAgID8gZ2V0SG9pc3RhYmxlUm9vdChKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpXG4gICAgOiBudWxsO1xuICBpZiAoIUpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NDYpKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIm1ldGFcIjpcbiAgICBjYXNlIFwidGl0bGVcIjpcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgcmV0dXJuIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMucHJlY2VkZW5jZSAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLmhyZWZcbiAgICAgICAgPyAoKGN1cnJlbnRQcm9wcyA9IGdldFN0eWxlS2V5KHBlbmRpbmdQcm9wcy5ocmVmKSksXG4gICAgICAgICAgKHBlbmRpbmdQcm9wcyA9IGdldFJlc291cmNlc0Zyb21Sb290KFxuICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgKS5ob2lzdGFibGVTdHlsZXMpLFxuICAgICAgICAgIChjdXJyZW50UmVzb3VyY2UgPSBwZW5kaW5nUHJvcHMuZ2V0KGN1cnJlbnRQcm9wcykpLFxuICAgICAgICAgIGN1cnJlbnRSZXNvdXJjZSB8fFxuICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3R5bGVcIixcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwZW5kaW5nUHJvcHMuc2V0KGN1cnJlbnRQcm9wcywgY3VycmVudFJlc291cmNlKSksXG4gICAgICAgICAgY3VycmVudFJlc291cmNlKVxuICAgICAgICA6IHsgdHlwZTogXCJ2b2lkXCIsIGluc3RhbmNlOiBudWxsLCBjb3VudDogMCwgc3RhdGU6IG51bGwgfTtcbiAgICBjYXNlIFwibGlua1wiOlxuICAgICAgaWYgKFxuICAgICAgICBcInN0eWxlc2hlZXRcIiA9PT0gcGVuZGluZ1Byb3BzLnJlbCAmJlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgcGVuZGluZ1Byb3BzLmhyZWYgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHBlbmRpbmdQcm9wcy5wcmVjZWRlbmNlXG4gICAgICApIHtcbiAgICAgICAgdHlwZSA9IGdldFN0eWxlS2V5KHBlbmRpbmdQcm9wcy5ocmVmKTtcbiAgICAgICAgdmFyIHN0eWxlcyQyNDIgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChcbiAgICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdFxuICAgICAgICAgICkuaG9pc3RhYmxlU3R5bGVzLFxuICAgICAgICAgIHJlc291cmNlJDI0MyA9IHN0eWxlcyQyNDIuZ2V0KHR5cGUpO1xuICAgICAgICByZXNvdXJjZSQyNDMgfHxcbiAgICAgICAgICAoKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9XG4gICAgICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQub3duZXJEb2N1bWVudCB8fCBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQpLFxuICAgICAgICAgIChyZXNvdXJjZSQyNDMgPSB7XG4gICAgICAgICAgICB0eXBlOiBcInN0eWxlc2hlZXRcIixcbiAgICAgICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICBzdGF0ZTogeyBsb2FkaW5nOiAwLCBwcmVsb2FkOiBudWxsIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBzdHlsZXMkMjQyLnNldCh0eXBlLCByZXNvdXJjZSQyNDMpLFxuICAgICAgICAgIChzdHlsZXMkMjQyID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBnZXRTdHlsZXNoZWV0U2VsZWN0b3JGcm9tS2V5KHR5cGUpXG4gICAgICAgICAgKSkgJiZcbiAgICAgICAgICAgICFzdHlsZXMkMjQyLl9wICYmXG4gICAgICAgICAgICAoKHJlc291cmNlJDI0My5pbnN0YW5jZSA9IHN0eWxlcyQyNDIpLFxuICAgICAgICAgICAgKHJlc291cmNlJDI0My5zdGF0ZS5sb2FkaW5nID0gNSkpLFxuICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5oYXModHlwZSkgfHxcbiAgICAgICAgICAgICgocGVuZGluZ1Byb3BzID0ge1xuICAgICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgICBhczogXCJzdHlsZVwiLFxuICAgICAgICAgICAgICBocmVmOiBwZW5kaW5nUHJvcHMuaHJlZixcbiAgICAgICAgICAgICAgY3Jvc3NPcmlnaW46IHBlbmRpbmdQcm9wcy5jcm9zc09yaWdpbixcbiAgICAgICAgICAgICAgaW50ZWdyaXR5OiBwZW5kaW5nUHJvcHMuaW50ZWdyaXR5LFxuICAgICAgICAgICAgICBtZWRpYTogcGVuZGluZ1Byb3BzLm1lZGlhLFxuICAgICAgICAgICAgICBocmVmTGFuZzogcGVuZGluZ1Byb3BzLmhyZWZMYW5nLFxuICAgICAgICAgICAgICByZWZlcnJlclBvbGljeTogcGVuZGluZ1Byb3BzLnJlZmVycmVyUG9saWN5XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByZWxvYWRQcm9wc01hcC5zZXQodHlwZSwgcGVuZGluZ1Byb3BzKSxcbiAgICAgICAgICAgIHN0eWxlcyQyNDIgfHxcbiAgICAgICAgICAgICAgcHJlbG9hZFN0eWxlc2hlZXQoXG4gICAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLFxuICAgICAgICAgICAgICAgIHJlc291cmNlJDI0My5zdGF0ZVxuICAgICAgICAgICAgICApKSk7XG4gICAgICAgIGlmIChjdXJyZW50UHJvcHMgJiYgbnVsbCA9PT0gY3VycmVudFJlc291cmNlKVxuICAgICAgICAgIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNTI4LCBcIlwiKSk7XG4gICAgICAgIHJldHVybiByZXNvdXJjZSQyNDM7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFByb3BzICYmIG51bGwgIT09IGN1cnJlbnRSZXNvdXJjZSlcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjksIFwiXCIpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgXCJzY3JpcHRcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChjdXJyZW50UHJvcHMgPSBwZW5kaW5nUHJvcHMuYXN5bmMpLFxuICAgICAgICAocGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzLnNyYyksXG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBwZW5kaW5nUHJvcHMgJiZcbiAgICAgICAgY3VycmVudFByb3BzICYmXG4gICAgICAgIFwiZnVuY3Rpb25cIiAhPT0gdHlwZW9mIGN1cnJlbnRQcm9wcyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgY3VycmVudFByb3BzXG4gICAgICAgICAgPyAoKGN1cnJlbnRQcm9wcyA9IGdldFNjcmlwdEtleShwZW5kaW5nUHJvcHMpKSxcbiAgICAgICAgICAgIChwZW5kaW5nUHJvcHMgPSBnZXRSZXNvdXJjZXNGcm9tUm9vdChcbiAgICAgICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0XG4gICAgICAgICAgICApLmhvaXN0YWJsZVNjcmlwdHMpLFxuICAgICAgICAgICAgKGN1cnJlbnRSZXNvdXJjZSA9IHBlbmRpbmdQcm9wcy5nZXQoY3VycmVudFByb3BzKSksXG4gICAgICAgICAgICBjdXJyZW50UmVzb3VyY2UgfHxcbiAgICAgICAgICAgICAgKChjdXJyZW50UmVzb3VyY2UgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzY3JpcHRcIixcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgICAgICBzdGF0ZTogbnVsbFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcGVuZGluZ1Byb3BzLnNldChjdXJyZW50UHJvcHMsIGN1cnJlbnRSZXNvdXJjZSkpLFxuICAgICAgICAgICAgY3VycmVudFJlc291cmNlKVxuICAgICAgICAgIDogeyB0eXBlOiBcInZvaWRcIiwgaW5zdGFuY2U6IG51bGwsIGNvdW50OiAwLCBzdGF0ZTogbnVsbCB9XG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ0NCwgdHlwZSkpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdHlsZUtleShocmVmKSB7XG4gIHJldHVybiAnaHJlZj1cIicgKyBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKGhyZWYpICsgJ1wiJztcbn1cbmZ1bmN0aW9uIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KSB7XG4gIHJldHVybiAnbGlua1tyZWw9XCJzdHlsZXNoZWV0XCJdWycgKyBrZXkgKyBcIl1cIjtcbn1cbmZ1bmN0aW9uIHN0eWxlc2hlZXRQcm9wc0Zyb21SYXdQcm9wcyhyYXdQcm9wcykge1xuICByZXR1cm4gYXNzaWduKHt9LCByYXdQcm9wcywge1xuICAgIFwiZGF0YS1wcmVjZWRlbmNlXCI6IHJhd1Byb3BzLnByZWNlZGVuY2UsXG4gICAgcHJlY2VkZW5jZTogbnVsbFxuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWxvYWRTdHlsZXNoZWV0KG93bmVyRG9jdW1lbnQsIGtleSwgcHJlbG9hZFByb3BzLCBzdGF0ZSkge1xuICBvd25lckRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbcmVsPVwicHJlbG9hZFwiXVthcz1cInN0eWxlXCJdWycgKyBrZXkgKyBcIl1cIilcbiAgICA/IChzdGF0ZS5sb2FkaW5nID0gMSlcbiAgICA6ICgoa2V5ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSksXG4gICAgICAoc3RhdGUucHJlbG9hZCA9IGtleSksXG4gICAgICBrZXkuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLmxvYWRpbmcgfD0gMSk7XG4gICAgICB9KSxcbiAgICAgIGtleS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHN0YXRlLmxvYWRpbmcgfD0gMik7XG4gICAgICB9KSxcbiAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKGtleSwgXCJsaW5rXCIsIHByZWxvYWRQcm9wcyksXG4gICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGtleSksXG4gICAgICBvd25lckRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoa2V5KSk7XG59XG5mdW5jdGlvbiBnZXRTY3JpcHRLZXkoc3JjKSB7XG4gIHJldHVybiAnW3NyYz1cIicgKyBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKHNyYykgKyAnXCJdJztcbn1cbmZ1bmN0aW9uIGdldFNjcmlwdFNlbGVjdG9yRnJvbUtleShrZXkpIHtcbiAgcmV0dXJuIFwic2NyaXB0W2FzeW5jXVwiICsga2V5O1xufVxuZnVuY3Rpb24gYWNxdWlyZVJlc291cmNlKGhvaXN0YWJsZVJvb3QsIHJlc291cmNlLCBwcm9wcykge1xuICByZXNvdXJjZS5jb3VudCsrO1xuICBpZiAobnVsbCA9PT0gcmVzb3VyY2UuaW5zdGFuY2UpXG4gICAgc3dpdGNoIChyZXNvdXJjZS50eXBlKSB7XG4gICAgICBjYXNlIFwic3R5bGVcIjpcbiAgICAgICAgdmFyIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICdzdHlsZVtkYXRhLWhyZWZ+PVwiJyArXG4gICAgICAgICAgICBlc2NhcGVTZWxlY3RvckF0dHJpYnV0ZVZhbHVlSW5zaWRlRG91YmxlUXVvdGVzKHByb3BzLmhyZWYpICtcbiAgICAgICAgICAgICdcIl0nXG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbnN0YW5jZSlcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2UpLFxuICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSksXG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICk7XG4gICAgICAgIHZhciBzdHlsZVByb3BzID0gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIFwiZGF0YS1ocmVmXCI6IHByb3BzLmhyZWYsXG4gICAgICAgICAgXCJkYXRhLXByZWNlZGVuY2VcIjogcHJvcHMucHJlY2VkZW5jZSxcbiAgICAgICAgICBocmVmOiBudWxsLFxuICAgICAgICAgIHByZWNlZGVuY2U6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICAgIGluc3RhbmNlID0gKGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290KS5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIFwic3R5bGVcIlxuICAgICAgICApO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UsIFwic3R5bGVcIiwgc3R5bGVQcm9wcyk7XG4gICAgICAgIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UsIHByb3BzLnByZWNlZGVuY2UsIGhvaXN0YWJsZVJvb3QpO1xuICAgICAgICByZXR1cm4gKHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2UpO1xuICAgICAgY2FzZSBcInN0eWxlc2hlZXRcIjpcbiAgICAgICAgc3R5bGVQcm9wcyA9IGdldFN0eWxlS2V5KHByb3BzLmhyZWYpO1xuICAgICAgICB2YXIgaW5zdGFuY2UkMjQ4ID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoc3R5bGVQcm9wcylcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKGluc3RhbmNlJDI0OClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gNCksXG4gICAgICAgICAgICAocmVzb3VyY2UuaW5zdGFuY2UgPSBpbnN0YW5jZSQyNDgpLFxuICAgICAgICAgICAgbWFya05vZGVBc0hvaXN0YWJsZShpbnN0YW5jZSQyNDgpLFxuICAgICAgICAgICAgaW5zdGFuY2UkMjQ4XG4gICAgICAgICAgKTtcbiAgICAgICAgaW5zdGFuY2UgPSBzdHlsZXNoZWV0UHJvcHNGcm9tUmF3UHJvcHMocHJvcHMpO1xuICAgICAgICAoc3R5bGVQcm9wcyA9IHByZWxvYWRQcm9wc01hcC5nZXQoc3R5bGVQcm9wcykpICYmXG4gICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KGluc3RhbmNlLCBzdHlsZVByb3BzKTtcbiAgICAgICAgaW5zdGFuY2UkMjQ4ID0gKFxuICAgICAgICAgIGhvaXN0YWJsZVJvb3Qub3duZXJEb2N1bWVudCB8fCBob2lzdGFibGVSb290XG4gICAgICAgICkuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoaW5zdGFuY2UkMjQ4KTtcbiAgICAgICAgdmFyIGxpbmtJbnN0YW5jZSA9IGluc3RhbmNlJDI0ODtcbiAgICAgICAgbGlua0luc3RhbmNlLl9wID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGxpbmtJbnN0YW5jZS5vbmxvYWQgPSByZXNvbHZlO1xuICAgICAgICAgIGxpbmtJbnN0YW5jZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoaW5zdGFuY2UkMjQ4LCBcImxpbmtcIiwgaW5zdGFuY2UpO1xuICAgICAgICByZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IDQ7XG4gICAgICAgIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UkMjQ4LCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KTtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlJDI0OCk7XG4gICAgICBjYXNlIFwic2NyaXB0XCI6XG4gICAgICAgIGluc3RhbmNlJDI0OCA9IGdldFNjcmlwdEtleShwcm9wcy5zcmMpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgKHN0eWxlUHJvcHMgPSBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBnZXRTY3JpcHRTZWxlY3RvckZyb21LZXkoaW5zdGFuY2UkMjQ4KVxuICAgICAgICAgICkpXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHJlc291cmNlLmluc3RhbmNlID0gc3R5bGVQcm9wcyksXG4gICAgICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKHN0eWxlUHJvcHMpLFxuICAgICAgICAgICAgc3R5bGVQcm9wc1xuICAgICAgICAgICk7XG4gICAgICAgIGluc3RhbmNlID0gcHJvcHM7XG4gICAgICAgIGlmICgoc3R5bGVQcm9wcyA9IHByZWxvYWRQcm9wc01hcC5nZXQoaW5zdGFuY2UkMjQ4KSkpXG4gICAgICAgICAgKGluc3RhbmNlID0gYXNzaWduKHt9LCBwcm9wcykpLFxuICAgICAgICAgICAgYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoaW5zdGFuY2UsIHN0eWxlUHJvcHMpO1xuICAgICAgICBob2lzdGFibGVSb290ID0gaG9pc3RhYmxlUm9vdC5vd25lckRvY3VtZW50IHx8IGhvaXN0YWJsZVJvb3Q7XG4gICAgICAgIHN0eWxlUHJvcHMgPSBob2lzdGFibGVSb290LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgIG1hcmtOb2RlQXNIb2lzdGFibGUoc3R5bGVQcm9wcyk7XG4gICAgICAgIHNldEluaXRpYWxQcm9wZXJ0aWVzKHN0eWxlUHJvcHMsIFwibGlua1wiLCBpbnN0YW5jZSk7XG4gICAgICAgIGhvaXN0YWJsZVJvb3QuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVByb3BzKTtcbiAgICAgICAgcmV0dXJuIChyZXNvdXJjZS5pbnN0YW5jZSA9IHN0eWxlUHJvcHMpO1xuICAgICAgY2FzZSBcInZvaWRcIjpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ0MywgcmVzb3VyY2UudHlwZSkpO1xuICAgIH1cbiAgZWxzZVxuICAgIFwic3R5bGVzaGVldFwiID09PSByZXNvdXJjZS50eXBlICYmXG4gICAgICAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDQpICYmXG4gICAgICAoKGluc3RhbmNlID0gcmVzb3VyY2UuaW5zdGFuY2UpLFxuICAgICAgKHJlc291cmNlLnN0YXRlLmxvYWRpbmcgfD0gNCksXG4gICAgICBpbnNlcnRTdHlsZXNoZWV0KGluc3RhbmNlLCBwcm9wcy5wcmVjZWRlbmNlLCBob2lzdGFibGVSb290KSk7XG4gIHJldHVybiByZXNvdXJjZS5pbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGluc2VydFN0eWxlc2hlZXQoaW5zdGFuY2UsIHByZWNlZGVuY2UsIHJvb3QpIHtcbiAgZm9yIChcbiAgICB2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICdsaW5rW3JlbD1cInN0eWxlc2hlZXRcIl1bZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdJ1xuICAgICAgKSxcbiAgICAgIGxhc3QgPSBub2Rlcy5sZW5ndGggPyBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXSA6IG51bGwsXG4gICAgICBwcmlvciA9IGxhc3QsXG4gICAgICBpID0gMDtcbiAgICBpIDwgbm9kZXMubGVuZ3RoO1xuICAgIGkrK1xuICApIHtcbiAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmIChub2RlLmRhdGFzZXQucHJlY2VkZW5jZSA9PT0gcHJlY2VkZW5jZSkgcHJpb3IgPSBub2RlO1xuICAgIGVsc2UgaWYgKHByaW9yICE9PSBsYXN0KSBicmVhaztcbiAgfVxuICBwcmlvclxuICAgID8gcHJpb3IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIHByaW9yLm5leHRTaWJsaW5nKVxuICAgIDogKChwcmVjZWRlbmNlID0gOSA9PT0gcm9vdC5ub2RlVHlwZSA/IHJvb3QuaGVhZCA6IHJvb3QpLFxuICAgICAgcHJlY2VkZW5jZS5pbnNlcnRCZWZvcmUoaW5zdGFuY2UsIHByZWNlZGVuY2UuZmlyc3RDaGlsZCkpO1xufVxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkUHJvcHNGb3JTdHlsZXNoZWV0KHN0eWxlc2hlZXRQcm9wcywgcHJlbG9hZFByb3BzKSB7XG4gIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLmNyb3NzT3JpZ2luICYmXG4gICAgKHN0eWxlc2hlZXRQcm9wcy5jcm9zc09yaWdpbiA9IHByZWxvYWRQcm9wcy5jcm9zc09yaWdpbik7XG4gIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLnJlZmVycmVyUG9saWN5ICYmXG4gICAgKHN0eWxlc2hlZXRQcm9wcy5yZWZlcnJlclBvbGljeSA9IHByZWxvYWRQcm9wcy5yZWZlcnJlclBvbGljeSk7XG4gIG51bGwgPT0gc3R5bGVzaGVldFByb3BzLnRpdGxlICYmIChzdHlsZXNoZWV0UHJvcHMudGl0bGUgPSBwcmVsb2FkUHJvcHMudGl0bGUpO1xufVxuZnVuY3Rpb24gYWRvcHRQcmVsb2FkUHJvcHNGb3JTY3JpcHQoc2NyaXB0UHJvcHMsIHByZWxvYWRQcm9wcykge1xuICBudWxsID09IHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luICYmXG4gICAgKHNjcmlwdFByb3BzLmNyb3NzT3JpZ2luID0gcHJlbG9hZFByb3BzLmNyb3NzT3JpZ2luKTtcbiAgbnVsbCA9PSBzY3JpcHRQcm9wcy5yZWZlcnJlclBvbGljeSAmJlxuICAgIChzY3JpcHRQcm9wcy5yZWZlcnJlclBvbGljeSA9IHByZWxvYWRQcm9wcy5yZWZlcnJlclBvbGljeSk7XG4gIG51bGwgPT0gc2NyaXB0UHJvcHMuaW50ZWdyaXR5ICYmXG4gICAgKHNjcmlwdFByb3BzLmludGVncml0eSA9IHByZWxvYWRQcm9wcy5pbnRlZ3JpdHkpO1xufVxudmFyIHRhZ0NhY2hlcyA9IG51bGw7XG5mdW5jdGlvbiBnZXRIeWRyYXRhYmxlSG9pc3RhYmxlQ2FjaGUodHlwZSwga2V5QXR0cmlidXRlLCBvd25lckRvY3VtZW50KSB7XG4gIGlmIChudWxsID09PSB0YWdDYWNoZXMpIHtcbiAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdmFyIGNhY2hlcyA9ICh0YWdDYWNoZXMgPSBuZXcgTWFwKCkpO1xuICAgIGNhY2hlcy5zZXQob3duZXJEb2N1bWVudCwgY2FjaGUpO1xuICB9IGVsc2VcbiAgICAoY2FjaGVzID0gdGFnQ2FjaGVzKSxcbiAgICAgIChjYWNoZSA9IGNhY2hlcy5nZXQob3duZXJEb2N1bWVudCkpLFxuICAgICAgY2FjaGUgfHwgKChjYWNoZSA9IG5ldyBNYXAoKSksIGNhY2hlcy5zZXQob3duZXJEb2N1bWVudCwgY2FjaGUpKTtcbiAgaWYgKGNhY2hlLmhhcyh0eXBlKSkgcmV0dXJuIGNhY2hlO1xuICBjYWNoZS5zZXQodHlwZSwgbnVsbCk7XG4gIG93bmVyRG9jdW1lbnQgPSBvd25lckRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHR5cGUpO1xuICBmb3IgKGNhY2hlcyA9IDA7IGNhY2hlcyA8IG93bmVyRG9jdW1lbnQubGVuZ3RoOyBjYWNoZXMrKykge1xuICAgIHZhciBub2RlID0gb3duZXJEb2N1bWVudFtjYWNoZXNdO1xuICAgIGlmIChcbiAgICAgICEoXG4gICAgICAgIG5vZGVbaW50ZXJuYWxIb2lzdGFibGVNYXJrZXJdIHx8XG4gICAgICAgIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gfHxcbiAgICAgICAgKFwibGlua1wiID09PSB0eXBlICYmIFwic3R5bGVzaGVldFwiID09PSBub2RlLmdldEF0dHJpYnV0ZShcInJlbFwiKSlcbiAgICAgICkgJiZcbiAgICAgIFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiAhPT0gbm9kZS5uYW1lc3BhY2VVUklcbiAgICApIHtcbiAgICAgIHZhciBub2RlS2V5ID0gbm9kZS5nZXRBdHRyaWJ1dGUoa2V5QXR0cmlidXRlKSB8fCBcIlwiO1xuICAgICAgbm9kZUtleSA9IHR5cGUgKyBub2RlS2V5O1xuICAgICAgdmFyIGV4aXN0aW5nID0gY2FjaGUuZ2V0KG5vZGVLZXkpO1xuICAgICAgZXhpc3RpbmcgPyBleGlzdGluZy5wdXNoKG5vZGUpIDogY2FjaGUuc2V0KG5vZGVLZXksIFtub2RlXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjYWNoZTtcbn1cbmZ1bmN0aW9uIG1vdW50SG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIHR5cGUsIGluc3RhbmNlKSB7XG4gIGhvaXN0YWJsZVJvb3QgPSBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdDtcbiAgaG9pc3RhYmxlUm9vdC5oZWFkLmluc2VydEJlZm9yZShcbiAgICBpbnN0YW5jZSxcbiAgICBcInRpdGxlXCIgPT09IHR5cGUgPyBob2lzdGFibGVSb290LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkID4gdGl0bGVcIikgOiBudWxsXG4gICk7XG59XG5mdW5jdGlvbiBpc0hvc3RIb2lzdGFibGVUeXBlKHR5cGUsIHByb3BzLCBob3N0Q29udGV4dCkge1xuICBpZiAoMSA9PT0gaG9zdENvbnRleHQgfHwgbnVsbCAhPSBwcm9wcy5pdGVtUHJvcCkgcmV0dXJuICExO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwibWV0YVwiOlxuICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMucHJlY2VkZW5jZSB8fFxuICAgICAgICBcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMuaHJlZiB8fFxuICAgICAgICBcIlwiID09PSBwcm9wcy5ocmVmXG4gICAgICApXG4gICAgICAgIGJyZWFrO1xuICAgICAgcmV0dXJuICEwO1xuICAgIGNhc2UgXCJsaW5rXCI6XG4gICAgICBpZiAoXG4gICAgICAgIFwic3RyaW5nXCIgIT09IHR5cGVvZiBwcm9wcy5yZWwgfHxcbiAgICAgICAgXCJzdHJpbmdcIiAhPT0gdHlwZW9mIHByb3BzLmhyZWYgfHxcbiAgICAgICAgXCJcIiA9PT0gcHJvcHMuaHJlZiB8fFxuICAgICAgICBwcm9wcy5vbkxvYWQgfHxcbiAgICAgICAgcHJvcHMub25FcnJvclxuICAgICAgKVxuICAgICAgICBicmVhaztcbiAgICAgIHN3aXRjaCAocHJvcHMucmVsKSB7XG4gICAgICAgIGNhc2UgXCJzdHlsZXNoZWV0XCI6XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlID0gcHJvcHMuZGlzYWJsZWQpLFxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnByZWNlZGVuY2UgJiYgbnVsbCA9PSB0eXBlXG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgY2FzZSBcInNjcmlwdFwiOlxuICAgICAgaWYgKFxuICAgICAgICBwcm9wcy5hc3luYyAmJlxuICAgICAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwcm9wcy5hc3luYyAmJlxuICAgICAgICBcInN5bWJvbFwiICE9PSB0eXBlb2YgcHJvcHMuYXN5bmMgJiZcbiAgICAgICAgIXByb3BzLm9uTG9hZCAmJlxuICAgICAgICAhcHJvcHMub25FcnJvciAmJlxuICAgICAgICBwcm9wcy5zcmMgJiZcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHByb3BzLnNyY1xuICAgICAgKVxuICAgICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gcHJlbG9hZFJlc291cmNlKHJlc291cmNlKSB7XG4gIHJldHVybiBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJiAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDMpXG4gICAgPyAhMVxuICAgIDogITA7XG59XG52YXIgc3VzcGVuZGVkU3RhdGUgPSBudWxsO1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5mdW5jdGlvbiBzdXNwZW5kUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgcmVzb3VyY2UsIHByb3BzKSB7XG4gIGlmIChudWxsID09PSBzdXNwZW5kZWRTdGF0ZSkgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg0NzUpKTtcbiAgdmFyIHN0YXRlID0gc3VzcGVuZGVkU3RhdGU7XG4gIGlmIChcbiAgICBcInN0eWxlc2hlZXRcIiA9PT0gcmVzb3VyY2UudHlwZSAmJlxuICAgIChcInN0cmluZ1wiICE9PSB0eXBlb2YgcHJvcHMubWVkaWEgfHxcbiAgICAgICExICE9PSBtYXRjaE1lZGlhKHByb3BzLm1lZGlhKS5tYXRjaGVzKSAmJlxuICAgIDAgPT09IChyZXNvdXJjZS5zdGF0ZS5sb2FkaW5nICYgNClcbiAgKSB7XG4gICAgaWYgKG51bGwgPT09IHJlc291cmNlLmluc3RhbmNlKSB7XG4gICAgICB2YXIga2V5ID0gZ2V0U3R5bGVLZXkocHJvcHMuaHJlZiksXG4gICAgICAgIGluc3RhbmNlID0gaG9pc3RhYmxlUm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGdldFN0eWxlc2hlZXRTZWxlY3RvckZyb21LZXkoa2V5KVxuICAgICAgICApO1xuICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgIGhvaXN0YWJsZVJvb3QgPSBpbnN0YW5jZS5fcDtcbiAgICAgICAgbnVsbCAhPT0gaG9pc3RhYmxlUm9vdCAmJlxuICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBob2lzdGFibGVSb290ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaG9pc3RhYmxlUm9vdC50aGVuICYmXG4gICAgICAgICAgKHN0YXRlLmNvdW50KyssXG4gICAgICAgICAgKHN0YXRlID0gb25VbnN1c3BlbmQuYmluZChzdGF0ZSkpLFxuICAgICAgICAgIGhvaXN0YWJsZVJvb3QudGhlbihzdGF0ZSwgc3RhdGUpKTtcbiAgICAgICAgcmVzb3VyY2Uuc3RhdGUubG9hZGluZyB8PSA0O1xuICAgICAgICByZXNvdXJjZS5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaW5zdGFuY2UgPSBob2lzdGFibGVSb290Lm93bmVyRG9jdW1lbnQgfHwgaG9pc3RhYmxlUm9vdDtcbiAgICAgIHByb3BzID0gc3R5bGVzaGVldFByb3BzRnJvbVJhd1Byb3BzKHByb3BzKTtcbiAgICAgIChrZXkgPSBwcmVsb2FkUHJvcHNNYXAuZ2V0KGtleSkpICYmXG4gICAgICAgIGFkb3B0UHJlbG9hZFByb3BzRm9yU3R5bGVzaGVldChwcm9wcywga2V5KTtcbiAgICAgIGluc3RhbmNlID0gaW5zdGFuY2UuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gICAgICBtYXJrTm9kZUFzSG9pc3RhYmxlKGluc3RhbmNlKTtcbiAgICAgIHZhciBsaW5rSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgIGxpbmtJbnN0YW5jZS5fcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgbGlua0luc3RhbmNlLm9ubG9hZCA9IHJlc29sdmU7XG4gICAgICAgIGxpbmtJbnN0YW5jZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgfSk7XG4gICAgICBzZXRJbml0aWFsUHJvcGVydGllcyhpbnN0YW5jZSwgXCJsaW5rXCIsIHByb3BzKTtcbiAgICAgIHJlc291cmNlLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgfVxuICAgIG51bGwgPT09IHN0YXRlLnN0eWxlc2hlZXRzICYmIChzdGF0ZS5zdHlsZXNoZWV0cyA9IG5ldyBNYXAoKSk7XG4gICAgc3RhdGUuc3R5bGVzaGVldHMuc2V0KHJlc291cmNlLCBob2lzdGFibGVSb290KTtcbiAgICAoaG9pc3RhYmxlUm9vdCA9IHJlc291cmNlLnN0YXRlLnByZWxvYWQpICYmXG4gICAgICAwID09PSAocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDMpICYmXG4gICAgICAoc3RhdGUuY291bnQrKyxcbiAgICAgIChyZXNvdXJjZSA9IG9uVW5zdXNwZW5kLmJpbmQoc3RhdGUpKSxcbiAgICAgIGhvaXN0YWJsZVJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgcmVzb3VyY2UpLFxuICAgICAgaG9pc3RhYmxlUm9vdC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgcmVzb3VyY2UpKTtcbiAgfVxufVxuZnVuY3Rpb24gd2FpdEZvckNvbW1pdFRvQmVSZWFkeSgpIHtcbiAgaWYgKG51bGwgPT09IHN1c3BlbmRlZFN0YXRlKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDQ3NSkpO1xuICB2YXIgc3RhdGUgPSBzdXNwZW5kZWRTdGF0ZTtcbiAgc3RhdGUuc3R5bGVzaGVldHMgJiZcbiAgICAwID09PSBzdGF0ZS5jb3VudCAmJlxuICAgIGluc2VydFN1c3BlbmRlZFN0eWxlc2hlZXRzKHN0YXRlLCBzdGF0ZS5zdHlsZXNoZWV0cyk7XG4gIHJldHVybiAwIDwgc3RhdGUuY291bnRcbiAgICA/IGZ1bmN0aW9uIChjb21taXQpIHtcbiAgICAgICAgdmFyIHN0eWxlc2hlZXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHN0YXRlLnN0eWxlc2hlZXRzICYmXG4gICAgICAgICAgICBpbnNlcnRTdXNwZW5kZWRTdHlsZXNoZWV0cyhzdGF0ZSwgc3RhdGUuc3R5bGVzaGVldHMpO1xuICAgICAgICAgIGlmIChzdGF0ZS51bnN1c3BlbmQpIHtcbiAgICAgICAgICAgIHZhciB1bnN1c3BlbmQgPSBzdGF0ZS51bnN1c3BlbmQ7XG4gICAgICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBudWxsO1xuICAgICAgICAgICAgdW5zdXNwZW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCA2ZTQpO1xuICAgICAgICBzdGF0ZS51bnN1c3BlbmQgPSBjb21taXQ7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGUudW5zdXNwZW5kID0gbnVsbDtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoc3R5bGVzaGVldFRpbWVyKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICA6IG51bGw7XG59XG5mdW5jdGlvbiBvblVuc3VzcGVuZCgpIHtcbiAgdGhpcy5jb3VudC0tO1xuICBpZiAoMCA9PT0gdGhpcy5jb3VudClcbiAgICBpZiAodGhpcy5zdHlsZXNoZWV0cykgaW5zZXJ0U3VzcGVuZGVkU3R5bGVzaGVldHModGhpcywgdGhpcy5zdHlsZXNoZWV0cyk7XG4gICAgZWxzZSBpZiAodGhpcy51bnN1c3BlbmQpIHtcbiAgICAgIHZhciB1bnN1c3BlbmQgPSB0aGlzLnVuc3VzcGVuZDtcbiAgICAgIHRoaXMudW5zdXNwZW5kID0gbnVsbDtcbiAgICAgIHVuc3VzcGVuZCgpO1xuICAgIH1cbn1cbnZhciBwcmVjZWRlbmNlc0J5Um9vdCA9IG51bGw7XG5mdW5jdGlvbiBpbnNlcnRTdXNwZW5kZWRTdHlsZXNoZWV0cyhzdGF0ZSwgcmVzb3VyY2VzKSB7XG4gIHN0YXRlLnN0eWxlc2hlZXRzID0gbnVsbDtcbiAgbnVsbCAhPT0gc3RhdGUudW5zdXNwZW5kICYmXG4gICAgKHN0YXRlLmNvdW50KyssXG4gICAgKHByZWNlZGVuY2VzQnlSb290ID0gbmV3IE1hcCgpKSxcbiAgICByZXNvdXJjZXMuZm9yRWFjaChpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3QsIHN0YXRlKSxcbiAgICAocHJlY2VkZW5jZXNCeVJvb3QgPSBudWxsKSxcbiAgICBvblVuc3VzcGVuZC5jYWxsKHN0YXRlKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRTdHlsZXNoZWV0SW50b1Jvb3Qocm9vdCwgcmVzb3VyY2UpIHtcbiAgaWYgKCEocmVzb3VyY2Uuc3RhdGUubG9hZGluZyAmIDQpKSB7XG4gICAgdmFyIHByZWNlZGVuY2VzID0gcHJlY2VkZW5jZXNCeVJvb3QuZ2V0KHJvb3QpO1xuICAgIGlmIChwcmVjZWRlbmNlcykgdmFyIGxhc3QgPSBwcmVjZWRlbmNlcy5nZXQobnVsbCk7XG4gICAgZWxzZSB7XG4gICAgICBwcmVjZWRlbmNlcyA9IG5ldyBNYXAoKTtcbiAgICAgIHByZWNlZGVuY2VzQnlSb290LnNldChyb290LCBwcmVjZWRlbmNlcyk7XG4gICAgICBmb3IgKFxuICAgICAgICB2YXIgbm9kZXMgPSByb290LnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICBcImxpbmtbZGF0YS1wcmVjZWRlbmNlXSxzdHlsZVtkYXRhLXByZWNlZGVuY2VdXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgICBpIDwgbm9kZXMubGVuZ3RoO1xuICAgICAgICBpKytcbiAgICAgICkge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgXCJMSU5LXCIgPT09IG5vZGUubm9kZU5hbWUgfHxcbiAgICAgICAgICBcIm5vdCBhbGxcIiAhPT0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJtZWRpYVwiKVxuICAgICAgICApXG4gICAgICAgICAgcHJlY2VkZW5jZXMuc2V0KG5vZGUuZGF0YXNldC5wcmVjZWRlbmNlLCBub2RlKSwgKGxhc3QgPSBub2RlKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgJiYgcHJlY2VkZW5jZXMuc2V0KG51bGwsIGxhc3QpO1xuICAgIH1cbiAgICBub2RlcyA9IHJlc291cmNlLmluc3RhbmNlO1xuICAgIG5vZGUgPSBub2Rlcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXByZWNlZGVuY2VcIik7XG4gICAgaSA9IHByZWNlZGVuY2VzLmdldChub2RlKSB8fCBsYXN0O1xuICAgIGkgPT09IGxhc3QgJiYgcHJlY2VkZW5jZXMuc2V0KG51bGwsIG5vZGVzKTtcbiAgICBwcmVjZWRlbmNlcy5zZXQobm9kZSwgbm9kZXMpO1xuICAgIHRoaXMuY291bnQrKztcbiAgICBsYXN0ID0gb25VbnN1c3BlbmQuYmluZCh0aGlzKTtcbiAgICBub2Rlcy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBsYXN0KTtcbiAgICBub2Rlcy5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgbGFzdCk7XG4gICAgaVxuICAgICAgPyBpLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGVzLCBpLm5leHRTaWJsaW5nKVxuICAgICAgOiAoKHJvb3QgPSA5ID09PSByb290Lm5vZGVUeXBlID8gcm9vdC5oZWFkIDogcm9vdCksXG4gICAgICAgIHJvb3QuaW5zZXJ0QmVmb3JlKG5vZGVzLCByb290LmZpcnN0Q2hpbGQpKTtcbiAgICByZXNvdXJjZS5zdGF0ZS5sb2FkaW5nIHw9IDQ7XG4gIH1cbn1cbnZhciBIb3N0VHJhbnNpdGlvbkNvbnRleHQgPSB7XG4gICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gIFByb3ZpZGVyOiBudWxsLFxuICBDb25zdW1lcjogbnVsbCxcbiAgX2N1cnJlbnRWYWx1ZTogc2hhcmVkTm90UGVuZGluZ09iamVjdCxcbiAgX2N1cnJlbnRWYWx1ZTI6IHNoYXJlZE5vdFBlbmRpbmdPYmplY3QsXG4gIF90aHJlYWRDb3VudDogMFxufTtcbmZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoXG4gIGNvbnRhaW5lckluZm8sXG4gIHRhZyxcbiAgaHlkcmF0ZSxcbiAgaWRlbnRpZmllclByZWZpeCxcbiAgb25VbmNhdWdodEVycm9yLFxuICBvbkNhdWdodEVycm9yLFxuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIGZvcm1TdGF0ZVxuKSB7XG4gIHRoaXMudGFnID0gMTtcbiAgdGhpcy5jb250YWluZXJJbmZvID0gY29udGFpbmVySW5mbztcbiAgdGhpcy5maW5pc2hlZFdvcmsgPVxuICAgIHRoaXMucGluZ0NhY2hlID1cbiAgICB0aGlzLmN1cnJlbnQgPVxuICAgIHRoaXMucGVuZGluZ0NoaWxkcmVuID1cbiAgICAgIG51bGw7XG4gIHRoaXMudGltZW91dEhhbmRsZSA9IC0xO1xuICB0aGlzLmNhbGxiYWNrTm9kZSA9XG4gICAgdGhpcy5uZXh0ID1cbiAgICB0aGlzLnBlbmRpbmdDb250ZXh0ID1cbiAgICB0aGlzLmNvbnRleHQgPVxuICAgIHRoaXMuY2FuY2VsUGVuZGluZ0NvbW1pdCA9XG4gICAgICBudWxsO1xuICB0aGlzLmNhbGxiYWNrUHJpb3JpdHkgPSAwO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoLTEpO1xuICB0aGlzLmVudGFuZ2xlZExhbmVzID1cbiAgICB0aGlzLnNoZWxsU3VzcGVuZENvdW50ZXIgPVxuICAgIHRoaXMuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgPVxuICAgIHRoaXMuZmluaXNoZWRMYW5lcyA9XG4gICAgdGhpcy5leHBpcmVkTGFuZXMgPVxuICAgIHRoaXMud2FybUxhbmVzID1cbiAgICB0aGlzLnBpbmdlZExhbmVzID1cbiAgICB0aGlzLnN1c3BlbmRlZExhbmVzID1cbiAgICB0aGlzLnBlbmRpbmdMYW5lcyA9XG4gICAgICAwO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKDApO1xuICB0aGlzLmhpZGRlblVwZGF0ZXMgPSBjcmVhdGVMYW5lTWFwKG51bGwpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgdGhpcy5vbkNhdWdodEVycm9yID0gb25DYXVnaHRFcnJvcjtcbiAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG4gIHRoaXMucG9vbGVkQ2FjaGUgPSBudWxsO1xuICB0aGlzLnBvb2xlZENhY2hlTGFuZXMgPSAwO1xuICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgdGhpcy5pbmNvbXBsZXRlVHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoXG4gIGNvbnRhaW5lckluZm8sXG4gIHRhZyxcbiAgaHlkcmF0ZSxcbiAgaW5pdGlhbENoaWxkcmVuLFxuICBoeWRyYXRpb25DYWxsYmFja3MsXG4gIGlzU3RyaWN0TW9kZSxcbiAgaWRlbnRpZmllclByZWZpeCxcbiAgb25VbmNhdWdodEVycm9yLFxuICBvbkNhdWdodEVycm9yLFxuICBvblJlY292ZXJhYmxlRXJyb3IsXG4gIHRyYW5zaXRpb25DYWxsYmFja3MsXG4gIGZvcm1TdGF0ZVxuKSB7XG4gIGNvbnRhaW5lckluZm8gPSBuZXcgRmliZXJSb290Tm9kZShcbiAgICBjb250YWluZXJJbmZvLFxuICAgIHRhZyxcbiAgICBoeWRyYXRlLFxuICAgIGlkZW50aWZpZXJQcmVmaXgsXG4gICAgb25VbmNhdWdodEVycm9yLFxuICAgIG9uQ2F1Z2h0RXJyb3IsXG4gICAgb25SZWNvdmVyYWJsZUVycm9yLFxuICAgIGZvcm1TdGF0ZVxuICApO1xuICB0YWcgPSAxO1xuICAhMCA9PT0gaXNTdHJpY3RNb2RlICYmICh0YWcgfD0gMjQpO1xuICBpc1N0cmljdE1vZGUgPSBjcmVhdGVGaWJlckltcGxDbGFzcygzLCBudWxsLCBudWxsLCB0YWcpO1xuICBjb250YWluZXJJbmZvLmN1cnJlbnQgPSBpc1N0cmljdE1vZGU7XG4gIGlzU3RyaWN0TW9kZS5zdGF0ZU5vZGUgPSBjb250YWluZXJJbmZvO1xuICB0YWcgPSBjcmVhdGVDYWNoZSgpO1xuICB0YWcucmVmQ291bnQrKztcbiAgY29udGFpbmVySW5mby5wb29sZWRDYWNoZSA9IHRhZztcbiAgdGFnLnJlZkNvdW50Kys7XG4gIGlzU3RyaWN0TW9kZS5tZW1vaXplZFN0YXRlID0ge1xuICAgIGVsZW1lbnQ6IGluaXRpYWxDaGlsZHJlbixcbiAgICBpc0RlaHlkcmF0ZWQ6IGh5ZHJhdGUsXG4gICAgY2FjaGU6IHRhZ1xuICB9O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUoaXNTdHJpY3RNb2RlKTtcbiAgcmV0dXJuIGNvbnRhaW5lckluZm87XG59XG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHBhcmVudENvbXBvbmVudCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgcmV0dXJuIHBhcmVudENvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckltcGwoXG4gIHJvb3RGaWJlcixcbiAgbGFuZSxcbiAgZWxlbWVudCxcbiAgY29udGFpbmVyLFxuICBwYXJlbnRDb21wb25lbnQsXG4gIGNhbGxiYWNrXG4pIHtcbiAgcGFyZW50Q29tcG9uZW50ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcbiAgbnVsbCA9PT0gY29udGFpbmVyLmNvbnRleHRcbiAgICA/IChjb250YWluZXIuY29udGV4dCA9IHBhcmVudENvbXBvbmVudClcbiAgICA6IChjb250YWluZXIucGVuZGluZ0NvbnRleHQgPSBwYXJlbnRDb21wb25lbnQpO1xuICBjb250YWluZXIgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIGNvbnRhaW5lci5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG4gIGNhbGxiYWNrID0gdm9pZCAwID09PSBjYWxsYmFjayA/IG51bGwgOiBjYWxsYmFjaztcbiAgbnVsbCAhPT0gY2FsbGJhY2sgJiYgKGNvbnRhaW5lci5jYWxsYmFjayA9IGNhbGxiYWNrKTtcbiAgZWxlbWVudCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBjb250YWluZXIsIGxhbmUpO1xuICBudWxsICE9PSBlbGVtZW50ICYmXG4gICAgKHNjaGVkdWxlVXBkYXRlT25GaWJlcihlbGVtZW50LCByb290RmliZXIsIGxhbmUpLFxuICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMoZWxlbWVudCwgcm9vdEZpYmVyLCBsYW5lKSk7XG59XG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIGZpYmVyID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKG51bGwgIT09IGZpYmVyICYmIG51bGwgIT09IGZpYmVyLmRlaHlkcmF0ZWQpIHtcbiAgICB2YXIgYSA9IGZpYmVyLnJldHJ5TGFuZTtcbiAgICBmaWJlci5yZXRyeUxhbmUgPSAwICE9PSBhICYmIGEgPCByZXRyeUxhbmUgPyBhIDogcmV0cnlMYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKSB7XG4gIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xuICAoZmliZXIgPSBmaWJlci5hbHRlcm5hdGUpICYmIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgaWYgKDEzID09PSBmaWJlci50YWcpIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgNjcxMDg4NjQpO1xuICAgIG51bGwgIT09IHJvb3QgJiYgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCA2NzEwODg2NCk7XG4gICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIDY3MTA4ODY0KTtcbiAgfVxufVxudmFyIF9lbmFibGVkID0gITA7XG5mdW5jdGlvbiBkaXNwYXRjaERpc2NyZXRlRXZlbnQoXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgY29udGFpbmVyLFxuICBuYXRpdmVFdmVudFxuKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnA7XG4gIHRyeSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSAyKSxcbiAgICAgIGRpc3BhdGNoRXZlbnQoZG9tRXZlbnROYW1lLCBldmVudFN5c3RlbUZsYWdzLCBjb250YWluZXIsIG5hdGl2ZUV2ZW50KTtcbiAgfSBmaW5hbGx5IHtcbiAgICAoUmVhY3RET01TaGFyZWRJbnRlcm5hbHMucCA9IHByZXZpb3VzUHJpb3JpdHkpLFxuICAgICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc3BhdGNoQ29udGludW91c0V2ZW50KFxuICBkb21FdmVudE5hbWUsXG4gIGV2ZW50U3lzdGVtRmxhZ3MsXG4gIGNvbnRhaW5lcixcbiAgbmF0aXZlRXZlbnRcbikge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBSZWFjdERPTVNoYXJlZEludGVybmFscy5wO1xuICB0cnkge1xuICAgIChSZWFjdERPTVNoYXJlZEludGVybmFscy5wID0gOCksXG4gICAgICBkaXNwYXRjaEV2ZW50KGRvbUV2ZW50TmFtZSwgZXZlbnRTeXN0ZW1GbGFncywgY29udGFpbmVyLCBuYXRpdmVFdmVudCk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0RE9NU2hhcmVkSW50ZXJuYWxzLnAgPSBwcmV2aW91c1ByaW9yaXR5KSxcbiAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb24pO1xuICB9XG59XG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KFxuICBkb21FdmVudE5hbWUsXG4gIGV2ZW50U3lzdGVtRmxhZ3MsXG4gIHRhcmdldENvbnRhaW5lcixcbiAgbmF0aXZlRXZlbnRcbikge1xuICBpZiAoX2VuYWJsZWQpIHtcbiAgICB2YXIgYmxvY2tlZE9uID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKG51bGwgPT09IGJsb2NrZWRPbilcbiAgICAgIGRpc3BhdGNoRXZlbnRGb3JQbHVnaW5FdmVudFN5c3RlbShcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICBuYXRpdmVFdmVudCxcbiAgICAgICAgcmV0dXJuX3RhcmdldEluc3QsXG4gICAgICAgIHRhcmdldENvbnRhaW5lclxuICAgICAgKSxcbiAgICAgICAgY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KTtcbiAgICBlbHNlIGlmIChcbiAgICAgIHF1ZXVlSWZDb250aW51b3VzRXZlbnQoXG4gICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICApXG4gICAgKVxuICAgICAgbmF0aXZlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgZWxzZSBpZiAoXG4gICAgICAoY2xlYXJJZkNvbnRpbnVvdXNFdmVudChkb21FdmVudE5hbWUsIG5hdGl2ZUV2ZW50KSxcbiAgICAgIGV2ZW50U3lzdGVtRmxhZ3MgJiA0ICYmXG4gICAgICAgIC0xIDwgZGlzY3JldGVSZXBsYXlhYmxlRXZlbnRzLmluZGV4T2YoZG9tRXZlbnROYW1lKSlcbiAgICApIHtcbiAgICAgIGZvciAoOyBudWxsICE9PSBibG9ja2VkT247ICkge1xuICAgICAgICB2YXIgZmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGJsb2NrZWRPbik7XG4gICAgICAgIGlmIChudWxsICE9PSBmaWJlcilcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBmaWJlciA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgaWYgKGZpYmVyLmN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhmaWJlci5wZW5kaW5nTGFuZXMpO1xuICAgICAgICAgICAgICAgIGlmICgwICE9PSBsYW5lcykge1xuICAgICAgICAgICAgICAgICAgdmFyIHJvb3QgPSBmaWJlcjtcbiAgICAgICAgICAgICAgICAgIHJvb3QucGVuZGluZ0xhbmVzIHw9IDI7XG4gICAgICAgICAgICAgICAgICBmb3IgKHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gMjsgbGFuZXM7ICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IDEgPDwgKDMxIC0gY2x6MzIobGFuZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdC5lbnRhbmdsZW1lbnRzWzFdIHw9IGxhbmU7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVzICY9IH5sYW5lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGZpYmVyKTtcbiAgICAgICAgICAgICAgICAgIDAgPT09IChleGVjdXRpb25Db250ZXh0ICYgNikgJiZcbiAgICAgICAgICAgICAgICAgICAgKCh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93KCkgKyA1MDApLFxuICAgICAgICAgICAgICAgICAgICBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCgwLCAhMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIChyb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCAyKSksXG4gICAgICAgICAgICAgICAgbnVsbCAhPT0gcm9vdCAmJiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIDIpLFxuICAgICAgICAgICAgICAgIGZsdXNoU3luY1dvcmskMSgpLFxuICAgICAgICAgICAgICAgIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIGZpYmVyID0gZmluZEluc3RhbmNlQmxvY2tpbmdFdmVudChuYXRpdmVFdmVudCk7XG4gICAgICAgIG51bGwgPT09IGZpYmVyICYmXG4gICAgICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICAgICAgcmV0dXJuX3RhcmdldEluc3QsXG4gICAgICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICAgICApO1xuICAgICAgICBpZiAoZmliZXIgPT09IGJsb2NrZWRPbikgYnJlYWs7XG4gICAgICAgIGJsb2NrZWRPbiA9IGZpYmVyO1xuICAgICAgfVxuICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmIG5hdGl2ZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZVxuICAgICAgZGlzcGF0Y2hFdmVudEZvclBsdWdpbkV2ZW50U3lzdGVtKFxuICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgIG5hdGl2ZUV2ZW50LFxuICAgICAgICBudWxsLFxuICAgICAgICB0YXJnZXRDb250YWluZXJcbiAgICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZpbmRJbnN0YW5jZUJsb2NraW5nRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgbmF0aXZlRXZlbnQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHJldHVybiBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChuYXRpdmVFdmVudCk7XG59XG52YXIgcmV0dXJuX3RhcmdldEluc3QgPSBudWxsO1xuZnVuY3Rpb24gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQodGFyZ2V0Tm9kZSkge1xuICByZXR1cm5fdGFyZ2V0SW5zdCA9IG51bGw7XG4gIHRhcmdldE5vZGUgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXROb2RlKTtcbiAgaWYgKG51bGwgIT09IHRhcmdldE5vZGUpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldE5vZGUpO1xuICAgIGlmIChudWxsID09PSBuZWFyZXN0TW91bnRlZCkgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgdGFnID0gbmVhcmVzdE1vdW50ZWQudGFnO1xuICAgICAgaWYgKDEzID09PSB0YWcpIHtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpO1xuICAgICAgICBpZiAobnVsbCAhPT0gdGFyZ2V0Tm9kZSkgcmV0dXJuIHRhcmdldE5vZGU7XG4gICAgICAgIHRhcmdldE5vZGUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICgzID09PSB0YWcpIHtcbiAgICAgICAgaWYgKG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkKVxuICAgICAgICAgIHJldHVybiAzID09PSBuZWFyZXN0TW91bnRlZC50YWdcbiAgICAgICAgICAgID8gbmVhcmVzdE1vdW50ZWQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm9cbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgICB9IGVsc2UgbmVhcmVzdE1vdW50ZWQgIT09IHRhcmdldE5vZGUgJiYgKHRhcmdldE5vZGUgPSBudWxsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuX3RhcmdldEluc3QgPSB0YXJnZXROb2RlO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50UHJpb3JpdHkoZG9tRXZlbnROYW1lKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImJlZm9yZXRvZ2dsZVwiOlxuICAgIGNhc2UgXCJjYW5jZWxcIjpcbiAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICBjYXNlIFwiY29udGV4dG1lbnVcIjpcbiAgICBjYXNlIFwiY29weVwiOlxuICAgIGNhc2UgXCJjdXRcIjpcbiAgICBjYXNlIFwiYXV4Y2xpY2tcIjpcbiAgICBjYXNlIFwiZGJsY2xpY2tcIjpcbiAgICBjYXNlIFwiZHJhZ2VuZFwiOlxuICAgIGNhc2UgXCJkcmFnc3RhcnRcIjpcbiAgICBjYXNlIFwiZHJvcFwiOlxuICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgY2FzZSBcImlucHV0XCI6XG4gICAgY2FzZSBcImludmFsaWRcIjpcbiAgICBjYXNlIFwia2V5ZG93blwiOlxuICAgIGNhc2UgXCJrZXlwcmVzc1wiOlxuICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgIGNhc2UgXCJtb3VzZWRvd25cIjpcbiAgICBjYXNlIFwibW91c2V1cFwiOlxuICAgIGNhc2UgXCJwYXN0ZVwiOlxuICAgIGNhc2UgXCJwYXVzZVwiOlxuICAgIGNhc2UgXCJwbGF5XCI6XG4gICAgY2FzZSBcInBvaW50ZXJjYW5jZWxcIjpcbiAgICBjYXNlIFwicG9pbnRlcmRvd25cIjpcbiAgICBjYXNlIFwicG9pbnRlcnVwXCI6XG4gICAgY2FzZSBcInJhdGVjaGFuZ2VcIjpcbiAgICBjYXNlIFwicmVzZXRcIjpcbiAgICBjYXNlIFwicmVzaXplXCI6XG4gICAgY2FzZSBcInNlZWtlZFwiOlxuICAgIGNhc2UgXCJzdWJtaXRcIjpcbiAgICBjYXNlIFwidG9nZ2xlXCI6XG4gICAgY2FzZSBcInRvdWNoY2FuY2VsXCI6XG4gICAgY2FzZSBcInRvdWNoZW5kXCI6XG4gICAgY2FzZSBcInRvdWNoc3RhcnRcIjpcbiAgICBjYXNlIFwidm9sdW1lY2hhbmdlXCI6XG4gICAgY2FzZSBcImNoYW5nZVwiOlxuICAgIGNhc2UgXCJzZWxlY3Rpb25jaGFuZ2VcIjpcbiAgICBjYXNlIFwidGV4dElucHV0XCI6XG4gICAgY2FzZSBcImNvbXBvc2l0aW9uc3RhcnRcIjpcbiAgICBjYXNlIFwiY29tcG9zaXRpb25lbmRcIjpcbiAgICBjYXNlIFwiY29tcG9zaXRpb251cGRhdGVcIjpcbiAgICBjYXNlIFwiYmVmb3JlYmx1clwiOlxuICAgIGNhc2UgXCJhZnRlcmJsdXJcIjpcbiAgICBjYXNlIFwiYmVmb3JlaW5wdXRcIjpcbiAgICBjYXNlIFwiYmx1clwiOlxuICAgIGNhc2UgXCJmdWxsc2NyZWVuY2hhbmdlXCI6XG4gICAgY2FzZSBcImZvY3VzXCI6XG4gICAgY2FzZSBcImhhc2hjaGFuZ2VcIjpcbiAgICBjYXNlIFwicG9wc3RhdGVcIjpcbiAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgY2FzZSBcInNlbGVjdHN0YXJ0XCI6XG4gICAgICByZXR1cm4gMjtcbiAgICBjYXNlIFwiZHJhZ1wiOlxuICAgIGNhc2UgXCJkcmFnZW50ZXJcIjpcbiAgICBjYXNlIFwiZHJhZ2V4aXRcIjpcbiAgICBjYXNlIFwiZHJhZ2xlYXZlXCI6XG4gICAgY2FzZSBcImRyYWdvdmVyXCI6XG4gICAgY2FzZSBcIm1vdXNlbW92ZVwiOlxuICAgIGNhc2UgXCJtb3VzZW91dFwiOlxuICAgIGNhc2UgXCJtb3VzZW92ZXJcIjpcbiAgICBjYXNlIFwicG9pbnRlcm1vdmVcIjpcbiAgICBjYXNlIFwicG9pbnRlcm91dFwiOlxuICAgIGNhc2UgXCJwb2ludGVyb3ZlclwiOlxuICAgIGNhc2UgXCJzY3JvbGxcIjpcbiAgICBjYXNlIFwidG91Y2htb3ZlXCI6XG4gICAgY2FzZSBcIndoZWVsXCI6XG4gICAgY2FzZSBcIm1vdXNlZW50ZXJcIjpcbiAgICBjYXNlIFwibW91c2VsZWF2ZVwiOlxuICAgIGNhc2UgXCJwb2ludGVyZW50ZXJcIjpcbiAgICBjYXNlIFwicG9pbnRlcmxlYXZlXCI6XG4gICAgICByZXR1cm4gODtcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgc3dpdGNoIChnZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpKSB7XG4gICAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgTm9ybWFsUHJpb3JpdHkkMTpcbiAgICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgICByZXR1cm4gMzI7XG4gICAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICAgIHJldHVybiAyNjg0MzU0NTY7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIDMyO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMzI7XG4gIH1cbn1cbnZhciBoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gITEsXG4gIHF1ZXVlZEZvY3VzID0gbnVsbCxcbiAgcXVldWVkRHJhZyA9IG51bGwsXG4gIHF1ZXVlZE1vdXNlID0gbnVsbCxcbiAgcXVldWVkUG9pbnRlcnMgPSBuZXcgTWFwKCksXG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcyA9IG5ldyBNYXAoKSxcbiAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzID0gW10sXG4gIGRpc2NyZXRlUmVwbGF5YWJsZUV2ZW50cyA9XG4gICAgXCJtb3VzZWRvd24gbW91c2V1cCB0b3VjaGNhbmNlbCB0b3VjaGVuZCB0b3VjaHN0YXJ0IGF1eGNsaWNrIGRibGNsaWNrIHBvaW50ZXJjYW5jZWwgcG9pbnRlcmRvd24gcG9pbnRlcnVwIGRyYWdlbmQgZHJhZ3N0YXJ0IGRyb3AgY29tcG9zaXRpb25lbmQgY29tcG9zaXRpb25zdGFydCBrZXlkb3duIGtleXByZXNzIGtleXVwIGlucHV0IHRleHRJbnB1dCBjb3B5IGN1dCBwYXN0ZSBjbGljayBjaGFuZ2UgY29udGV4dG1lbnUgcmVzZXRcIi5zcGxpdChcbiAgICAgIFwiIFwiXG4gICAgKTtcbmZ1bmN0aW9uIGNsZWFySWZDb250aW51b3VzRXZlbnQoZG9tRXZlbnROYW1lLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKGRvbUV2ZW50TmFtZSkge1xuICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgY2FzZSBcImZvY3Vzb3V0XCI6XG4gICAgICBxdWV1ZWRGb2N1cyA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZHJhZ2VudGVyXCI6XG4gICAgY2FzZSBcImRyYWdsZWF2ZVwiOlxuICAgICAgcXVldWVkRHJhZyA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibW91c2VvdmVyXCI6XG4gICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICBxdWV1ZWRNb3VzZSA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICBjYXNlIFwicG9pbnRlcm91dFwiOlxuICAgICAgcXVldWVkUG9pbnRlcnMuZGVsZXRlKG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpcbiAgICBjYXNlIFwibG9zdHBvaW50ZXJjYXB0dXJlXCI6XG4gICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuZGVsZXRlKG5hdGl2ZUV2ZW50LnBvaW50ZXJJZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gIGV4aXN0aW5nUXVldWVkRXZlbnQsXG4gIGJsb2NrZWRPbixcbiAgZG9tRXZlbnROYW1lLFxuICBldmVudFN5c3RlbUZsYWdzLFxuICB0YXJnZXRDb250YWluZXIsXG4gIG5hdGl2ZUV2ZW50XG4pIHtcbiAgaWYgKFxuICAgIG51bGwgPT09IGV4aXN0aW5nUXVldWVkRXZlbnQgfHxcbiAgICBleGlzdGluZ1F1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50ICE9PSBuYXRpdmVFdmVudFxuICApXG4gICAgcmV0dXJuIChcbiAgICAgIChleGlzdGluZ1F1ZXVlZEV2ZW50ID0ge1xuICAgICAgICBibG9ja2VkT246IGJsb2NrZWRPbixcbiAgICAgICAgZG9tRXZlbnROYW1lOiBkb21FdmVudE5hbWUsXG4gICAgICAgIGV2ZW50U3lzdGVtRmxhZ3M6IGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICAgICAgdGFyZ2V0Q29udGFpbmVyczogW3RhcmdldENvbnRhaW5lcl1cbiAgICAgIH0pLFxuICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmXG4gICAgICAgICgoYmxvY2tlZE9uID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShibG9ja2VkT24pKSxcbiAgICAgICAgbnVsbCAhPT0gYmxvY2tlZE9uICYmIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGJsb2NrZWRPbikpLFxuICAgICAgZXhpc3RpbmdRdWV1ZWRFdmVudFxuICAgICk7XG4gIGV4aXN0aW5nUXVldWVkRXZlbnQuZXZlbnRTeXN0ZW1GbGFncyB8PSBldmVudFN5c3RlbUZsYWdzO1xuICBibG9ja2VkT24gPSBleGlzdGluZ1F1ZXVlZEV2ZW50LnRhcmdldENvbnRhaW5lcnM7XG4gIG51bGwgIT09IHRhcmdldENvbnRhaW5lciAmJlxuICAgIC0xID09PSBibG9ja2VkT24uaW5kZXhPZih0YXJnZXRDb250YWluZXIpICYmXG4gICAgYmxvY2tlZE9uLnB1c2godGFyZ2V0Q29udGFpbmVyKTtcbiAgcmV0dXJuIGV4aXN0aW5nUXVldWVkRXZlbnQ7XG59XG5mdW5jdGlvbiBxdWV1ZUlmQ29udGludW91c0V2ZW50KFxuICBibG9ja2VkT24sXG4gIGRvbUV2ZW50TmFtZSxcbiAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgdGFyZ2V0Q29udGFpbmVyLFxuICBuYXRpdmVFdmVudFxuKSB7XG4gIHN3aXRjaCAoZG9tRXZlbnROYW1lKSB7XG4gICAgY2FzZSBcImZvY3VzaW5cIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChxdWV1ZWRGb2N1cyA9IGFjY3VtdWxhdGVPckNyZWF0ZUNvbnRpbnVvdXNRdWV1ZWRSZXBsYXlhYmxlRXZlbnQoXG4gICAgICAgICAgcXVldWVkRm9jdXMsXG4gICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApKSxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgY2FzZSBcImRyYWdlbnRlclwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHF1ZXVlZERyYWcgPSBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgIHF1ZXVlZERyYWcsXG4gICAgICAgICAgYmxvY2tlZE9uLFxuICAgICAgICAgIGRvbUV2ZW50TmFtZSxcbiAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgIHRhcmdldENvbnRhaW5lcixcbiAgICAgICAgICBuYXRpdmVFdmVudFxuICAgICAgICApKSxcbiAgICAgICAgITBcbiAgICAgICk7XG4gICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHF1ZXVlZE1vdXNlID0gYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICBxdWV1ZWRNb3VzZSxcbiAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgZG9tRXZlbnROYW1lLFxuICAgICAgICAgIGV2ZW50U3lzdGVtRmxhZ3MsXG4gICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgIG5hdGl2ZUV2ZW50XG4gICAgICAgICkpLFxuICAgICAgICAhMFxuICAgICAgKTtcbiAgICBjYXNlIFwicG9pbnRlcm92ZXJcIjpcbiAgICAgIHZhciBwb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQ7XG4gICAgICBxdWV1ZWRQb2ludGVycy5zZXQoXG4gICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgYWNjdW11bGF0ZU9yQ3JlYXRlQ29udGludW91c1F1ZXVlZFJlcGxheWFibGVFdmVudChcbiAgICAgICAgICBxdWV1ZWRQb2ludGVycy5nZXQocG9pbnRlcklkKSB8fCBudWxsLFxuICAgICAgICAgIGJsb2NrZWRPbixcbiAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgZXZlbnRTeXN0ZW1GbGFncyxcbiAgICAgICAgICB0YXJnZXRDb250YWluZXIsXG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiAhMDtcbiAgICBjYXNlIFwiZ290cG9pbnRlcmNhcHR1cmVcIjpcbiAgICAgIHJldHVybiAoXG4gICAgICAgIChwb2ludGVySWQgPSBuYXRpdmVFdmVudC5wb2ludGVySWQpLFxuICAgICAgICBxdWV1ZWRQb2ludGVyQ2FwdHVyZXMuc2V0KFxuICAgICAgICAgIHBvaW50ZXJJZCxcbiAgICAgICAgICBhY2N1bXVsYXRlT3JDcmVhdGVDb250aW51b3VzUXVldWVkUmVwbGF5YWJsZUV2ZW50KFxuICAgICAgICAgICAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmdldChwb2ludGVySWQpIHx8IG51bGwsXG4gICAgICAgICAgICBibG9ja2VkT24sXG4gICAgICAgICAgICBkb21FdmVudE5hbWUsXG4gICAgICAgICAgICBldmVudFN5c3RlbUZsYWdzLFxuICAgICAgICAgICAgdGFyZ2V0Q29udGFpbmVyLFxuICAgICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgICApXG4gICAgICAgICksXG4gICAgICAgICEwXG4gICAgICApO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRFeHBsaWNpdEh5ZHJhdGlvblRhcmdldChxdWV1ZWRUYXJnZXQpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShxdWV1ZWRUYXJnZXQudGFyZ2V0KTtcbiAgaWYgKG51bGwgIT09IHRhcmdldEluc3QpIHtcbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKHRhcmdldEluc3QpO1xuICAgIGlmIChudWxsICE9PSBuZWFyZXN0TW91bnRlZClcbiAgICAgIGlmICgoKHRhcmdldEluc3QgPSBuZWFyZXN0TW91bnRlZC50YWcpLCAxMyA9PT0gdGFyZ2V0SW5zdCkpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICgodGFyZ2V0SW5zdCA9IGdldFN1c3BlbnNlSW5zdGFuY2VGcm9tRmliZXIobmVhcmVzdE1vdW50ZWQpKSxcbiAgICAgICAgICBudWxsICE9PSB0YXJnZXRJbnN0KVxuICAgICAgICApIHtcbiAgICAgICAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBydW5XaXRoUHJpb3JpdHkocXVldWVkVGFyZ2V0LnByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoMTMgPT09IG5lYXJlc3RNb3VudGVkLnRhZykge1xuICAgICAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCksXG4gICAgICAgICAgICAgICAgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShuZWFyZXN0TW91bnRlZCwgbGFuZSk7XG4gICAgICAgICAgICAgIG51bGwgIT09IHJvb3QgJiZcbiAgICAgICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgbmVhcmVzdE1vdW50ZWQsIGxhbmUpO1xuICAgICAgICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChuZWFyZXN0TW91bnRlZCwgbGFuZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAzID09PSB0YXJnZXRJbnN0ICYmXG4gICAgICAgIG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jdXJyZW50Lm1lbW9pemVkU3RhdGUuaXNEZWh5ZHJhdGVkXG4gICAgICApIHtcbiAgICAgICAgcXVldWVkVGFyZ2V0LmJsb2NrZWRPbiA9XG4gICAgICAgICAgMyA9PT0gbmVhcmVzdE1vdW50ZWQudGFnXG4gICAgICAgICAgICA/IG5lYXJlc3RNb3VudGVkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxuICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID0gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpIHtcbiAgaWYgKG51bGwgIT09IHF1ZXVlZEV2ZW50LmJsb2NrZWRPbikgcmV0dXJuICExO1xuICBmb3IgKFxuICAgIHZhciB0YXJnZXRDb250YWluZXJzID0gcXVldWVkRXZlbnQudGFyZ2V0Q29udGFpbmVycztcbiAgICAwIDwgdGFyZ2V0Q29udGFpbmVycy5sZW5ndGg7XG5cbiAgKSB7XG4gICAgdmFyIG5leHRCbG9ja2VkT24gPSBmaW5kSW5zdGFuY2VCbG9ja2luZ0V2ZW50KHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICBpZiAobnVsbCA9PT0gbmV4dEJsb2NrZWRPbikge1xuICAgICAgbmV4dEJsb2NrZWRPbiA9IHF1ZXVlZEV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgICAgdmFyIG5hdGl2ZUV2ZW50Q2xvbmUgPSBuZXcgbmV4dEJsb2NrZWRPbi5jb25zdHJ1Y3RvcihcbiAgICAgICAgbmV4dEJsb2NrZWRPbi50eXBlLFxuICAgICAgICBuZXh0QmxvY2tlZE9uXG4gICAgICApO1xuICAgICAgY3VycmVudFJlcGxheWluZ0V2ZW50ID0gbmF0aXZlRXZlbnRDbG9uZTtcbiAgICAgIG5leHRCbG9ja2VkT24udGFyZ2V0LmRpc3BhdGNoRXZlbnQobmF0aXZlRXZlbnRDbG9uZSk7XG4gICAgICBjdXJyZW50UmVwbGF5aW5nRXZlbnQgPSBudWxsO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHRhcmdldENvbnRhaW5lcnMgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKG5leHRCbG9ja2VkT24pKSxcbiAgICAgICAgbnVsbCAhPT0gdGFyZ2V0Q29udGFpbmVycyAmJlxuICAgICAgICAgIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKHRhcmdldENvbnRhaW5lcnMpLFxuICAgICAgICAocXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbmV4dEJsb2NrZWRPbiksXG4gICAgICAgICExXG4gICAgICApO1xuICAgIHRhcmdldENvbnRhaW5lcnMuc2hpZnQoKTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50SW5NYXAocXVldWVkRXZlbnQsIGtleSwgbWFwKSB7XG4gIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRXZlbnQpICYmIG1hcC5kZWxldGUoa2V5KTtcbn1cbmZ1bmN0aW9uIHJlcGxheVVuYmxvY2tlZEV2ZW50cygpIHtcbiAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCA9ICExO1xuICBudWxsICE9PSBxdWV1ZWRGb2N1cyAmJlxuICAgIGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnQocXVldWVkRm9jdXMpICYmXG4gICAgKHF1ZXVlZEZvY3VzID0gbnVsbCk7XG4gIG51bGwgIT09IHF1ZXVlZERyYWcgJiZcbiAgICBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZERyYWcpICYmXG4gICAgKHF1ZXVlZERyYWcgPSBudWxsKTtcbiAgbnVsbCAhPT0gcXVldWVkTW91c2UgJiZcbiAgICBhdHRlbXB0UmVwbGF5Q29udGludW91c1F1ZXVlZEV2ZW50KHF1ZXVlZE1vdXNlKSAmJlxuICAgIChxdWV1ZWRNb3VzZSA9IG51bGwpO1xuICBxdWV1ZWRQb2ludGVycy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG4gIHF1ZXVlZFBvaW50ZXJDYXB0dXJlcy5mb3JFYWNoKGF0dGVtcHRSZXBsYXlDb250aW51b3VzUXVldWVkRXZlbnRJbk1hcCk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRXZlbnQsIHVuYmxvY2tlZCkge1xuICBxdWV1ZWRFdmVudC5ibG9ja2VkT24gPT09IHVuYmxvY2tlZCAmJlxuICAgICgocXVldWVkRXZlbnQuYmxvY2tlZE9uID0gbnVsbCksXG4gICAgaGFzU2NoZWR1bGVkUmVwbGF5QXR0ZW1wdCB8fFxuICAgICAgKChoYXNTY2hlZHVsZWRSZXBsYXlBdHRlbXB0ID0gITApLFxuICAgICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICAgIFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSxcbiAgICAgICAgcmVwbGF5VW5ibG9ja2VkRXZlbnRzXG4gICAgICApKSk7XG59XG52YXIgbGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlID0gbnVsbDtcbmZ1bmN0aW9uIHNjaGVkdWxlUmVwbGF5UXVldWVJZk5lZWRlZChmb3JtUmVwbGF5aW5nUXVldWUpIHtcbiAgbGFzdFNjaGVkdWxlZFJlcGxheVF1ZXVlICE9PSBmb3JtUmVwbGF5aW5nUXVldWUgJiZcbiAgICAoKGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9IGZvcm1SZXBsYXlpbmdRdWV1ZSksXG4gICAgU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soXG4gICAgICBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9PT0gZm9ybVJlcGxheWluZ1F1ZXVlICYmXG4gICAgICAgICAgKGxhc3RTY2hlZHVsZWRSZXBsYXlRdWV1ZSA9IG51bGwpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZvcm1SZXBsYXlpbmdRdWV1ZS5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgIHZhciBmb3JtID0gZm9ybVJlcGxheWluZ1F1ZXVlW2ldLFxuICAgICAgICAgICAgc3VibWl0dGVyT3JBY3Rpb24gPSBmb3JtUmVwbGF5aW5nUXVldWVbaSArIDFdLFxuICAgICAgICAgICAgZm9ybURhdGEgPSBmb3JtUmVwbGF5aW5nUXVldWVbaSArIDJdO1xuICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBzdWJtaXR0ZXJPckFjdGlvbilcbiAgICAgICAgICAgIGlmIChudWxsID09PSBmaW5kSW5zdGFuY2VCbG9ja2luZ1RhcmdldChzdWJtaXR0ZXJPckFjdGlvbiB8fCBmb3JtKSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICAgIHZhciBmb3JtSW5zdCA9IGdldEluc3RhbmNlRnJvbU5vZGUoZm9ybSk7XG4gICAgICAgICAgbnVsbCAhPT0gZm9ybUluc3QgJiZcbiAgICAgICAgICAgIChmb3JtUmVwbGF5aW5nUXVldWUuc3BsaWNlKGksIDMpLFxuICAgICAgICAgICAgKGkgLT0gMyksXG4gICAgICAgICAgICBzdGFydEhvc3RUcmFuc2l0aW9uKFxuICAgICAgICAgICAgICBmb3JtSW5zdCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBlbmRpbmc6ICEwLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogZm9ybS5tZXRob2QsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBzdWJtaXR0ZXJPckFjdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdWJtaXR0ZXJPckFjdGlvbixcbiAgICAgICAgICAgICAgZm9ybURhdGFcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgKSk7XG59XG5mdW5jdGlvbiByZXRyeUlmQmxvY2tlZE9uKHVuYmxvY2tlZCkge1xuICBmdW5jdGlvbiB1bmJsb2NrKHF1ZXVlZEV2ZW50KSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRFdmVudCwgdW5ibG9ja2VkKTtcbiAgfVxuICBudWxsICE9PSBxdWV1ZWRGb2N1cyAmJiBzY2hlZHVsZUNhbGxiYWNrSWZVbmJsb2NrZWQocXVldWVkRm9jdXMsIHVuYmxvY2tlZCk7XG4gIG51bGwgIT09IHF1ZXVlZERyYWcgJiYgc2NoZWR1bGVDYWxsYmFja0lmVW5ibG9ja2VkKHF1ZXVlZERyYWcsIHVuYmxvY2tlZCk7XG4gIG51bGwgIT09IHF1ZXVlZE1vdXNlICYmIHNjaGVkdWxlQ2FsbGJhY2tJZlVuYmxvY2tlZChxdWV1ZWRNb3VzZSwgdW5ibG9ja2VkKTtcbiAgcXVldWVkUG9pbnRlcnMuZm9yRWFjaCh1bmJsb2NrKTtcbiAgcXVldWVkUG9pbnRlckNhcHR1cmVzLmZvckVhY2godW5ibG9jayk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHF1ZXVlZFRhcmdldCA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXTtcbiAgICBxdWV1ZWRUYXJnZXQuYmxvY2tlZE9uID09PSB1bmJsb2NrZWQgJiYgKHF1ZXVlZFRhcmdldC5ibG9ja2VkT24gPSBudWxsKTtcbiAgfVxuICBmb3IgKFxuICAgIDtcbiAgICAwIDwgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLmxlbmd0aCAmJlxuICAgICgoaSA9IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1swXSksIG51bGwgPT09IGkuYmxvY2tlZE9uKTtcblxuICApXG4gICAgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KGkpLFxuICAgICAgbnVsbCA9PT0gaS5ibG9ja2VkT24gJiYgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNoaWZ0KCk7XG4gIGkgPSAodW5ibG9ja2VkLm93bmVyRG9jdW1lbnQgfHwgdW5ibG9ja2VkKS4kJHJlYWN0Rm9ybVJlcGxheTtcbiAgaWYgKG51bGwgIT0gaSlcbiAgICBmb3IgKHF1ZXVlZFRhcmdldCA9IDA7IHF1ZXVlZFRhcmdldCA8IGkubGVuZ3RoOyBxdWV1ZWRUYXJnZXQgKz0gMykge1xuICAgICAgdmFyIGZvcm0gPSBpW3F1ZXVlZFRhcmdldF0sXG4gICAgICAgIHN1Ym1pdHRlck9yQWN0aW9uID0gaVtxdWV1ZWRUYXJnZXQgKyAxXSxcbiAgICAgICAgZm9ybVByb3BzID0gZm9ybVtpbnRlcm5hbFByb3BzS2V5XSB8fCBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHN1Ym1pdHRlck9yQWN0aW9uKVxuICAgICAgICBmb3JtUHJvcHMgfHwgc2NoZWR1bGVSZXBsYXlRdWV1ZUlmTmVlZGVkKGkpO1xuICAgICAgZWxzZSBpZiAoZm9ybVByb3BzKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBudWxsO1xuICAgICAgICBpZiAoc3VibWl0dGVyT3JBY3Rpb24gJiYgc3VibWl0dGVyT3JBY3Rpb24uaGFzQXR0cmlidXRlKFwiZm9ybUFjdGlvblwiKSlcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAoKGZvcm0gPSBzdWJtaXR0ZXJPckFjdGlvbiksXG4gICAgICAgICAgICAoZm9ybVByb3BzID0gc3VibWl0dGVyT3JBY3Rpb25baW50ZXJuYWxQcm9wc0tleV0gfHwgbnVsbCkpXG4gICAgICAgICAgKVxuICAgICAgICAgICAgYWN0aW9uID0gZm9ybVByb3BzLmZvcm1BY3Rpb247XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gZmluZEluc3RhbmNlQmxvY2tpbmdUYXJnZXQoZm9ybSkpIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZSBhY3Rpb24gPSBmb3JtUHJvcHMuYWN0aW9uO1xuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBhY3Rpb25cbiAgICAgICAgICA/IChpW3F1ZXVlZFRhcmdldCArIDFdID0gYWN0aW9uKVxuICAgICAgICAgIDogKGkuc3BsaWNlKHF1ZXVlZFRhcmdldCwgMyksIChxdWV1ZWRUYXJnZXQgLT0gMykpO1xuICAgICAgICBzY2hlZHVsZVJlcGxheVF1ZXVlSWZOZWVkZWQoaSk7XG4gICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gUmVhY3RET01Sb290KGludGVybmFsUm9vdCkge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBpbnRlcm5hbFJvb3Q7XG59XG5SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnJlbmRlciA9IFJlYWN0RE9NUm9vdC5wcm90b3R5cGUucmVuZGVyID1cbiAgZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLl9pbnRlcm5hbFJvb3Q7XG4gICAgaWYgKG51bGwgPT09IHJvb3QpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoNDA5KSk7XG4gICAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQsXG4gICAgICBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoKTtcbiAgICB1cGRhdGVDb250YWluZXJJbXBsKGN1cnJlbnQsIGxhbmUsIGNoaWxkcmVuLCByb290LCBudWxsLCBudWxsKTtcbiAgfTtcblJlYWN0RE9NSHlkcmF0aW9uUm9vdC5wcm90b3R5cGUudW5tb3VudCA9IFJlYWN0RE9NUm9vdC5wcm90b3R5cGUudW5tb3VudCA9XG4gIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgICBpZiAobnVsbCAhPT0gcm9vdCkge1xuICAgICAgdGhpcy5faW50ZXJuYWxSb290ID0gbnVsbDtcbiAgICAgIHZhciBjb250YWluZXIgPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAwID09PSByb290LnRhZyAmJiBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICB1cGRhdGVDb250YWluZXJJbXBsKHJvb3QuY3VycmVudCwgMiwgbnVsbCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgICBmbHVzaFN5bmNXb3JrJDEoKTtcbiAgICAgIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IG51bGw7XG4gICAgfVxuICB9O1xuZnVuY3Rpb24gUmVhY3RET01IeWRyYXRpb25Sb290KGludGVybmFsUm9vdCkge1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSBpbnRlcm5hbFJvb3Q7XG59XG5SZWFjdERPTUh5ZHJhdGlvblJvb3QucHJvdG90eXBlLnVuc3RhYmxlX3NjaGVkdWxlSHlkcmF0aW9uID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBpZiAodGFyZ2V0KSB7XG4gICAgdmFyIHVwZGF0ZVByaW9yaXR5ID0gcmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCk7XG4gICAgdGFyZ2V0ID0geyBibG9ja2VkT246IG51bGwsIHRhcmdldDogdGFyZ2V0LCBwcmlvcml0eTogdXBkYXRlUHJpb3JpdHkgfTtcbiAgICBmb3IgKFxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgaSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0cy5sZW5ndGggJiZcbiAgICAgIDAgIT09IHVwZGF0ZVByaW9yaXR5ICYmXG4gICAgICB1cGRhdGVQcmlvcml0eSA8IHF1ZXVlZEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0c1tpXS5wcmlvcml0eTtcbiAgICAgIGkrK1xuICAgICk7XG4gICAgcXVldWVkRXhwbGljaXRIeWRyYXRpb25UYXJnZXRzLnNwbGljZShpLCAwLCB0YXJnZXQpO1xuICAgIDAgPT09IGkgJiYgYXR0ZW1wdEV4cGxpY2l0SHlkcmF0aW9uVGFyZ2V0KHRhcmdldCk7XG4gIH1cbn07XG52YXIgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24kanNjb21wJGlubGluZV8xNjg2ID0gUmVhY3QudmVyc2lvbjtcbmlmIChcbiAgXCIxOS4wLjBcIiAhPT1cbiAgaXNvbW9ycGhpY1JlYWN0UGFja2FnZVZlcnNpb24kanNjb21wJGlubGluZV8xNjg2XG4pXG4gIHRocm93IEVycm9yKFxuICAgIGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoXG4gICAgICA1MjcsXG4gICAgICBpc29tb3JwaGljUmVhY3RQYWNrYWdlVmVyc2lvbiRqc2NvbXAkaW5saW5lXzE2ODYsXG4gICAgICBcIjE5LjAuMFwiXG4gICAgKVxuICApO1xuUmVhY3RET01TaGFyZWRJbnRlcm5hbHMuZmluZERPTU5vZGUgPSBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIHZhciBmaWJlciA9IGNvbXBvbmVudE9yRWxlbWVudC5fcmVhY3RJbnRlcm5hbHM7XG4gIGlmICh2b2lkIDAgPT09IGZpYmVyKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIpXG4gICAgICB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDE4OCkpO1xuICAgIGNvbXBvbmVudE9yRWxlbWVudCA9IE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkuam9pbihcIixcIik7XG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyNjgsIGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICB9XG4gIGNvbXBvbmVudE9yRWxlbWVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKTtcbiAgY29tcG9uZW50T3JFbGVtZW50ID1cbiAgICBudWxsICE9PSBjb21wb25lbnRPckVsZW1lbnRcbiAgICAgID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGNvbXBvbmVudE9yRWxlbWVudClcbiAgICAgIDogbnVsbDtcbiAgY29tcG9uZW50T3JFbGVtZW50ID1cbiAgICBudWxsID09PSBjb21wb25lbnRPckVsZW1lbnQgPyBudWxsIDogY29tcG9uZW50T3JFbGVtZW50LnN0YXRlTm9kZTtcbiAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbn07XG52YXIgaW50ZXJuYWxzJGpzY29tcCRpbmxpbmVfMjE2NSA9IHtcbiAgYnVuZGxlVHlwZTogMCxcbiAgdmVyc2lvbjogXCIxOS4wLjBcIixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogXCJyZWFjdC1kb21cIixcbiAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIHJlY29uY2lsZXJWZXJzaW9uOiBcIjE5LjAuMFwiXG59O1xuaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pIHtcbiAgdmFyIGhvb2skanNjb21wJGlubGluZV8yMTY2ID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoXG4gICAgIWhvb2skanNjb21wJGlubGluZV8yMTY2LmlzRGlzYWJsZWQgJiZcbiAgICBob29rJGpzY29tcCRpbmxpbmVfMjE2Ni5zdXBwb3J0c0ZpYmVyXG4gIClcbiAgICB0cnkge1xuICAgICAgKHJlbmRlcmVySUQgPSBob29rJGpzY29tcCRpbmxpbmVfMjE2Ni5pbmplY3QoXG4gICAgICAgIGludGVybmFscyRqc2NvbXAkaW5saW5lXzIxNjVcbiAgICAgICkpLFxuICAgICAgICAoaW5qZWN0ZWRIb29rID0gaG9vayRqc2NvbXAkaW5saW5lXzIxNjYpO1xuICAgIH0gY2F0Y2ggKGVycikge31cbn1cbmV4cG9ydHMuY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIChjb250YWluZXIsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikpIHRocm93IEVycm9yKGZvcm1hdFByb2RFcnJvck1lc3NhZ2UoMjk5KSk7XG4gIHZhciBpc1N0cmljdE1vZGUgPSAhMSxcbiAgICBpZGVudGlmaWVyUHJlZml4ID0gXCJcIixcbiAgICBvblVuY2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25VbmNhdWdodEVycm9yLFxuICAgIG9uQ2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25DYXVnaHRFcnJvcixcbiAgICBvblJlY292ZXJhYmxlRXJyb3IgPSBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yLFxuICAgIHRyYW5zaXRpb25DYWxsYmFja3MgPSBudWxsO1xuICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgdm9pZCAwICE9PSBvcHRpb25zICYmXG4gICAgKCEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCAmJlxuICAgICAgKGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXgpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgIChvblVuY2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uVW5jYXVnaHRFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IgJiYgKG9uQ2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IgJiZcbiAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MgJiZcbiAgICAgICh0cmFuc2l0aW9uQ2FsbGJhY2tzID0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzKSk7XG4gIG9wdGlvbnMgPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgY29udGFpbmVyLFxuICAgIDEsXG4gICAgITEsXG4gICAgbnVsbCxcbiAgICBudWxsLFxuICAgIGlzU3RyaWN0TW9kZSxcbiAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yLFxuICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgIG51bGxcbiAgKTtcbiAgY29udGFpbmVyW2ludGVybmFsQ29udGFpbmVySW5zdGFuY2VLZXldID0gb3B0aW9ucy5jdXJyZW50O1xuICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhcbiAgICA4ID09PSBjb250YWluZXIubm9kZVR5cGUgPyBjb250YWluZXIucGFyZW50Tm9kZSA6IGNvbnRhaW5lclxuICApO1xuICByZXR1cm4gbmV3IFJlYWN0RE9NUm9vdChvcHRpb25zKTtcbn07XG5leHBvcnRzLmh5ZHJhdGVSb290ID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgaW5pdGlhbENoaWxkcmVuLCBvcHRpb25zKSB7XG4gIGlmICghaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpKSB0aHJvdyBFcnJvcihmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5OSkpO1xuICB2YXIgaXNTdHJpY3RNb2RlID0gITEsXG4gICAgaWRlbnRpZmllclByZWZpeCA9IFwiXCIsXG4gICAgb25VbmNhdWdodEVycm9yID0gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yID0gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IsXG4gICAgb25SZWNvdmVyYWJsZUVycm9yID0gZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzID0gbnVsbCxcbiAgICBmb3JtU3RhdGUgPSBudWxsO1xuICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgdm9pZCAwICE9PSBvcHRpb25zICYmXG4gICAgKCEwID09PSBvcHRpb25zLnVuc3RhYmxlX3N0cmljdE1vZGUgJiYgKGlzU3RyaWN0TW9kZSA9ICEwKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMuaWRlbnRpZmllclByZWZpeCAmJlxuICAgICAgKGlkZW50aWZpZXJQcmVmaXggPSBvcHRpb25zLmlkZW50aWZpZXJQcmVmaXgpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblVuY2F1Z2h0RXJyb3IgJiZcbiAgICAgIChvblVuY2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uVW5jYXVnaHRFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IgJiYgKG9uQ2F1Z2h0RXJyb3IgPSBvcHRpb25zLm9uQ2F1Z2h0RXJyb3IpLFxuICAgIHZvaWQgMCAhPT0gb3B0aW9ucy5vblJlY292ZXJhYmxlRXJyb3IgJiZcbiAgICAgIChvblJlY292ZXJhYmxlRXJyb3IgPSBvcHRpb25zLm9uUmVjb3ZlcmFibGVFcnJvciksXG4gICAgdm9pZCAwICE9PSBvcHRpb25zLnVuc3RhYmxlX3RyYW5zaXRpb25DYWxsYmFja3MgJiZcbiAgICAgICh0cmFuc2l0aW9uQ2FsbGJhY2tzID0gb3B0aW9ucy51bnN0YWJsZV90cmFuc2l0aW9uQ2FsbGJhY2tzKSxcbiAgICB2b2lkIDAgIT09IG9wdGlvbnMuZm9ybVN0YXRlICYmIChmb3JtU3RhdGUgPSBvcHRpb25zLmZvcm1TdGF0ZSkpO1xuICBpbml0aWFsQ2hpbGRyZW4gPSBjcmVhdGVGaWJlclJvb3QoXG4gICAgY29udGFpbmVyLFxuICAgIDEsXG4gICAgITAsXG4gICAgaW5pdGlhbENoaWxkcmVuLFxuICAgIG51bGwgIT0gb3B0aW9ucyA/IG9wdGlvbnMgOiBudWxsLFxuICAgIGlzU3RyaWN0TW9kZSxcbiAgICBpZGVudGlmaWVyUHJlZml4LFxuICAgIG9uVW5jYXVnaHRFcnJvcixcbiAgICBvbkNhdWdodEVycm9yLFxuICAgIG9uUmVjb3ZlcmFibGVFcnJvcixcbiAgICB0cmFuc2l0aW9uQ2FsbGJhY2tzLFxuICAgIGZvcm1TdGF0ZVxuICApO1xuICBpbml0aWFsQ2hpbGRyZW4uY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKG51bGwpO1xuICBvcHRpb25zID0gaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQ7XG4gIGlzU3RyaWN0TW9kZSA9IHJlcXVlc3RVcGRhdGVMYW5lKCk7XG4gIGlkZW50aWZpZXJQcmVmaXggPSBjcmVhdGVVcGRhdGUoaXNTdHJpY3RNb2RlKTtcbiAgaWRlbnRpZmllclByZWZpeC5jYWxsYmFjayA9IG51bGw7XG4gIGVucXVldWVVcGRhdGUob3B0aW9ucywgaWRlbnRpZmllclByZWZpeCwgaXNTdHJpY3RNb2RlKTtcbiAgaW5pdGlhbENoaWxkcmVuLmN1cnJlbnQubGFuZXMgPSBpc1N0cmljdE1vZGU7XG4gIG1hcmtSb290VXBkYXRlZCQxKGluaXRpYWxDaGlsZHJlbiwgaXNTdHJpY3RNb2RlKTtcbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKGluaXRpYWxDaGlsZHJlbik7XG4gIGNvbnRhaW5lcltpbnRlcm5hbENvbnRhaW5lckluc3RhbmNlS2V5XSA9IGluaXRpYWxDaGlsZHJlbi5jdXJyZW50O1xuICBsaXN0ZW5Ub0FsbFN1cHBvcnRlZEV2ZW50cyhjb250YWluZXIpO1xuICByZXR1cm4gbmV3IFJlYWN0RE9NSHlkcmF0aW9uUm9vdChpbml0aWFsQ2hpbGRyZW4pO1xufTtcbmV4cG9ydHMudmVyc2lvbiA9IFwiMTkuMC4wXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///247\n')},221:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/**\n * @license React\n * react-dom.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar React = __webpack_require__(540);\nfunction formatProdErrorMessage(code) {\n  var url = "https://react.dev/errors/" + code;\n  if (1 < arguments.length) {\n    url += "?args[]=" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += "&args[]=" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    "Minified React error #" +\n    code +\n    "; visit " +\n    url +\n    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."\n  );\n}\nfunction noop() {}\nvar Internals = {\n    d: {\n      f: noop,\n      r: function () {\n        throw Error(formatProdErrorMessage(522));\n      },\n      D: noop,\n      C: noop,\n      L: noop,\n      m: noop,\n      X: noop,\n      S: noop,\n      M: noop\n    },\n    p: 0,\n    findDOMNode: null\n  },\n  REACT_PORTAL_TYPE = Symbol.for("react.portal");\nfunction createPortal$1(children, containerInfo, implementation) {\n  var key =\n    3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;\n  return {\n    $$typeof: REACT_PORTAL_TYPE,\n    key: null == key ? null : "" + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\nvar ReactSharedInternals =\n  React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\nfunction getCrossOriginStringAs(as, input) {\n  if ("font" === as) return "";\n  if ("string" === typeof input)\n    return "use-credentials" === input ? input : "";\n}\nexports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  Internals;\nexports.createPortal = function (children, container) {\n  var key =\n    2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;\n  if (\n    !container ||\n    (1 !== container.nodeType &&\n      9 !== container.nodeType &&\n      11 !== container.nodeType)\n  )\n    throw Error(formatProdErrorMessage(299));\n  return createPortal$1(children, container, null, key);\n};\nexports.flushSync = function (fn) {\n  var previousTransition = ReactSharedInternals.T,\n    previousUpdatePriority = Internals.p;\n  try {\n    if (((ReactSharedInternals.T = null), (Internals.p = 2), fn)) return fn();\n  } finally {\n    (ReactSharedInternals.T = previousTransition),\n      (Internals.p = previousUpdatePriority),\n      Internals.d.f();\n  }\n};\nexports.preconnect = function (href, options) {\n  "string" === typeof href &&\n    (options\n      ? ((options = options.crossOrigin),\n        (options =\n          "string" === typeof options\n            ? "use-credentials" === options\n              ? options\n              : ""\n            : void 0))\n      : (options = null),\n    Internals.d.C(href, options));\n};\nexports.prefetchDNS = function (href) {\n  "string" === typeof href && Internals.d.D(href);\n};\nexports.preinit = function (href, options) {\n  if ("string" === typeof href && options && "string" === typeof options.as) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin),\n      integrity =\n        "string" === typeof options.integrity ? options.integrity : void 0,\n      fetchPriority =\n        "string" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0;\n    "style" === as\n      ? Internals.d.S(\n          href,\n          "string" === typeof options.precedence ? options.precedence : void 0,\n          {\n            crossOrigin: crossOrigin,\n            integrity: integrity,\n            fetchPriority: fetchPriority\n          }\n        )\n      : "script" === as &&\n        Internals.d.X(href, {\n          crossOrigin: crossOrigin,\n          integrity: integrity,\n          fetchPriority: fetchPriority,\n          nonce: "string" === typeof options.nonce ? options.nonce : void 0\n        });\n  }\n};\nexports.preinitModule = function (href, options) {\n  if ("string" === typeof href)\n    if ("object" === typeof options && null !== options) {\n      if (null == options.as || "script" === options.as) {\n        var crossOrigin = getCrossOriginStringAs(\n          options.as,\n          options.crossOrigin\n        );\n        Internals.d.M(href, {\n          crossOrigin: crossOrigin,\n          integrity:\n            "string" === typeof options.integrity ? options.integrity : void 0,\n          nonce: "string" === typeof options.nonce ? options.nonce : void 0\n        });\n      }\n    } else null == options && Internals.d.M(href);\n};\nexports.preload = function (href, options) {\n  if (\n    "string" === typeof href &&\n    "object" === typeof options &&\n    null !== options &&\n    "string" === typeof options.as\n  ) {\n    var as = options.as,\n      crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);\n    Internals.d.L(href, as, {\n      crossOrigin: crossOrigin,\n      integrity:\n        "string" === typeof options.integrity ? options.integrity : void 0,\n      nonce: "string" === typeof options.nonce ? options.nonce : void 0,\n      type: "string" === typeof options.type ? options.type : void 0,\n      fetchPriority:\n        "string" === typeof options.fetchPriority\n          ? options.fetchPriority\n          : void 0,\n      referrerPolicy:\n        "string" === typeof options.referrerPolicy\n          ? options.referrerPolicy\n          : void 0,\n      imageSrcSet:\n        "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,\n      imageSizes:\n        "string" === typeof options.imageSizes ? options.imageSizes : void 0,\n      media: "string" === typeof options.media ? options.media : void 0\n    });\n  }\n};\nexports.preloadModule = function (href, options) {\n  if ("string" === typeof href)\n    if (options) {\n      var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);\n      Internals.d.m(href, {\n        as:\n          "string" === typeof options.as && "script" !== options.as\n            ? options.as\n            : void 0,\n        crossOrigin: crossOrigin,\n        integrity:\n          "string" === typeof options.integrity ? options.integrity : void 0\n      });\n    } else Internals.d.m(href);\n};\nexports.requestFormReset = function (form) {\n  Internals.d.r(form);\n};\nexports.unstable_batchedUpdates = function (fn, a) {\n  return fn(a);\n};\nexports.useFormState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useFormState(action, initialState, permalink);\n};\nexports.useFormStatus = function () {\n  return ReactSharedInternals.H.useHostTransitionStatus();\n};\nexports.version = "19.0.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIxLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyxHQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLmpzPzczZGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gZm9ybWF0UHJvZEVycm9yTWVzc2FnZShjb2RlKSB7XG4gIHZhciB1cmwgPSBcImh0dHBzOi8vcmVhY3QuZGV2L2Vycm9ycy9cIiArIGNvZGU7XG4gIGlmICgxIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHVybCArPSBcIj9hcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzWzFdKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgIHVybCArPSBcIiZhcmdzW109XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICtcbiAgICBjb2RlICtcbiAgICBcIjsgdmlzaXQgXCIgK1xuICAgIHVybCArXG4gICAgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiXG4gICk7XG59XG5mdW5jdGlvbiBub29wKCkge31cbnZhciBJbnRlcm5hbHMgPSB7XG4gICAgZDoge1xuICAgICAgZjogbm9vcCxcbiAgICAgIHI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSg1MjIpKTtcbiAgICAgIH0sXG4gICAgICBEOiBub29wLFxuICAgICAgQzogbm9vcCxcbiAgICAgIEw6IG5vb3AsXG4gICAgICBtOiBub29wLFxuICAgICAgWDogbm9vcCxcbiAgICAgIFM6IG5vb3AsXG4gICAgICBNOiBub29wXG4gICAgfSxcbiAgICBwOiAwLFxuICAgIGZpbmRET01Ob2RlOiBudWxsXG4gIH0sXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCBpbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID1cbiAgICAzIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1szXSA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleTogbnVsbCA9PSBrZXkgPyBudWxsIDogXCJcIiArIGtleSxcbiAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICBpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb25cbiAgfTtcbn1cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcbmZ1bmN0aW9uIGdldENyb3NzT3JpZ2luU3RyaW5nQXMoYXMsIGlucHV0KSB7XG4gIGlmIChcImZvbnRcIiA9PT0gYXMpIHJldHVybiBcIlwiO1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGlucHV0KVxuICAgIHJldHVybiBcInVzZS1jcmVkZW50aWFsc1wiID09PSBpbnB1dCA/IGlucHV0IDogXCJcIjtcbn1cbmV4cG9ydHMuX19ET01fSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgSW50ZXJuYWxzO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNvbnRhaW5lcikge1xuICB2YXIga2V5ID1cbiAgICAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gIGlmIChcbiAgICAhY29udGFpbmVyIHx8XG4gICAgKDEgIT09IGNvbnRhaW5lci5ub2RlVHlwZSAmJlxuICAgICAgOSAhPT0gY29udGFpbmVyLm5vZGVUeXBlICYmXG4gICAgICAxMSAhPT0gY29udGFpbmVyLm5vZGVUeXBlKVxuICApXG4gICAgdGhyb3cgRXJyb3IoZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgyOTkpKTtcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59O1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHByZXZpb3VzVHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQsXG4gICAgcHJldmlvdXNVcGRhdGVQcmlvcml0eSA9IEludGVybmFscy5wO1xuICB0cnkge1xuICAgIGlmICgoKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsKSwgKEludGVybmFscy5wID0gMiksIGZuKSkgcmV0dXJuIGZuKCk7XG4gIH0gZmluYWxseSB7XG4gICAgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2aW91c1RyYW5zaXRpb24pLFxuICAgICAgKEludGVybmFscy5wID0gcHJldmlvdXNVcGRhdGVQcmlvcml0eSksXG4gICAgICBJbnRlcm5hbHMuZC5mKCk7XG4gIH1cbn07XG5leHBvcnRzLnByZWNvbm5lY3QgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBcInN0cmluZ1wiID09PSB0eXBlb2YgaHJlZiAmJlxuICAgIChvcHRpb25zXG4gICAgICA/ICgob3B0aW9ucyA9IG9wdGlvbnMuY3Jvc3NPcmlnaW4pLFxuICAgICAgICAob3B0aW9ucyA9XG4gICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnNcbiAgICAgICAgICAgID8gXCJ1c2UtY3JlZGVudGlhbHNcIiA9PT0gb3B0aW9uc1xuICAgICAgICAgICAgICA/IG9wdGlvbnNcbiAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgICAgICA6IHZvaWQgMCkpXG4gICAgICA6IChvcHRpb25zID0gbnVsbCksXG4gICAgSW50ZXJuYWxzLmQuQyhocmVmLCBvcHRpb25zKSk7XG59O1xuZXhwb3J0cy5wcmVmZXRjaEROUyA9IGZ1bmN0aW9uIChocmVmKSB7XG4gIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIEludGVybmFscy5kLkQoaHJlZik7XG59O1xuZXhwb3J0cy5wcmVpbml0ID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmIG9wdGlvbnMgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXMpIHtcbiAgICB2YXIgYXMgPSBvcHRpb25zLmFzLFxuICAgICAgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKGFzLCBvcHRpb25zLmNyb3NzT3JpZ2luKSxcbiAgICAgIGludGVncml0eSA9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwLFxuICAgICAgZmV0Y2hQcmlvcml0eSA9XG4gICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmZldGNoUHJpb3JpdHlcbiAgICAgICAgICA/IG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgIDogdm9pZCAwO1xuICAgIFwic3R5bGVcIiA9PT0gYXNcbiAgICAgID8gSW50ZXJuYWxzLmQuUyhcbiAgICAgICAgICBocmVmLFxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLnByZWNlZGVuY2UgPyBvcHRpb25zLnByZWNlZGVuY2UgOiB2b2lkIDAsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgICAgICAgaW50ZWdyaXR5OiBpbnRlZ3JpdHksXG4gICAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICA6IFwic2NyaXB0XCIgPT09IGFzICYmXG4gICAgICAgIEludGVybmFscy5kLlgoaHJlZiwge1xuICAgICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgICBpbnRlZ3JpdHk6IGludGVncml0eSxcbiAgICAgICAgICBmZXRjaFByaW9yaXR5OiBmZXRjaFByaW9yaXR5LFxuICAgICAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gIH1cbn07XG5leHBvcnRzLnByZWluaXRNb2R1bGUgPSBmdW5jdGlvbiAoaHJlZiwgb3B0aW9ucykge1xuICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGhyZWYpXG4gICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBvcHRpb25zICYmIG51bGwgIT09IG9wdGlvbnMpIHtcbiAgICAgIGlmIChudWxsID09IG9wdGlvbnMuYXMgfHwgXCJzY3JpcHRcIiA9PT0gb3B0aW9ucy5hcykge1xuICAgICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKFxuICAgICAgICAgIG9wdGlvbnMuYXMsXG4gICAgICAgICAgb3B0aW9ucy5jcm9zc09yaWdpblxuICAgICAgICApO1xuICAgICAgICBJbnRlcm5hbHMuZC5NKGhyZWYsIHtcbiAgICAgICAgICBjcm9zc09yaWdpbjogY3Jvc3NPcmlnaW4sXG4gICAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuaW50ZWdyaXR5ID8gb3B0aW9ucy5pbnRlZ3JpdHkgOiB2b2lkIDAsXG4gICAgICAgICAgbm9uY2U6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm5vbmNlID8gb3B0aW9ucy5ub25jZSA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgbnVsbCA9PSBvcHRpb25zICYmIEludGVybmFscy5kLk0oaHJlZik7XG59O1xuZXhwb3J0cy5wcmVsb2FkID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFxuICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmICYmXG4gICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiZcbiAgICBudWxsICE9PSBvcHRpb25zICYmXG4gICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuYXNcbiAgKSB7XG4gICAgdmFyIGFzID0gb3B0aW9ucy5hcyxcbiAgICAgIGNyb3NzT3JpZ2luID0gZ2V0Q3Jvc3NPcmlnaW5TdHJpbmdBcyhhcywgb3B0aW9ucy5jcm9zc09yaWdpbik7XG4gICAgSW50ZXJuYWxzLmQuTChocmVmLCBhcywge1xuICAgICAgY3Jvc3NPcmlnaW46IGNyb3NzT3JpZ2luLFxuICAgICAgaW50ZWdyaXR5OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbnRlZ3JpdHkgPyBvcHRpb25zLmludGVncml0eSA6IHZvaWQgMCxcbiAgICAgIG5vbmNlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5ub25jZSA/IG9wdGlvbnMubm9uY2UgOiB2b2lkIDAsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy50eXBlID8gb3B0aW9ucy50eXBlIDogdm9pZCAwLFxuICAgICAgZmV0Y2hQcmlvcml0eTpcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMuZmV0Y2hQcmlvcml0eVxuICAgICAgICAgID8gb3B0aW9ucy5mZXRjaFByaW9yaXR5XG4gICAgICAgICAgOiB2b2lkIDAsXG4gICAgICByZWZlcnJlclBvbGljeTpcbiAgICAgICAgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICA/IG9wdGlvbnMucmVmZXJyZXJQb2xpY3lcbiAgICAgICAgICA6IHZvaWQgMCxcbiAgICAgIGltYWdlU3JjU2V0OlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNyY1NldCA/IG9wdGlvbnMuaW1hZ2VTcmNTZXQgOiB2b2lkIDAsXG4gICAgICBpbWFnZVNpemVzOlxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2Ygb3B0aW9ucy5pbWFnZVNpemVzID8gb3B0aW9ucy5pbWFnZVNpemVzIDogdm9pZCAwLFxuICAgICAgbWVkaWE6IFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLm1lZGlhID8gb3B0aW9ucy5tZWRpYSA6IHZvaWQgMFxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0cy5wcmVsb2FkTW9kdWxlID0gZnVuY3Rpb24gKGhyZWYsIG9wdGlvbnMpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiBocmVmKVxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICB2YXIgY3Jvc3NPcmlnaW4gPSBnZXRDcm9zc09yaWdpblN0cmluZ0FzKG9wdGlvbnMuYXMsIG9wdGlvbnMuY3Jvc3NPcmlnaW4pO1xuICAgICAgSW50ZXJuYWxzLmQubShocmVmLCB7XG4gICAgICAgIGFzOlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmFzICYmIFwic2NyaXB0XCIgIT09IG9wdGlvbnMuYXNcbiAgICAgICAgICAgID8gb3B0aW9ucy5hc1xuICAgICAgICAgICAgOiB2b2lkIDAsXG4gICAgICAgIGNyb3NzT3JpZ2luOiBjcm9zc09yaWdpbixcbiAgICAgICAgaW50ZWdyaXR5OlxuICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBvcHRpb25zLmludGVncml0eSA/IG9wdGlvbnMuaW50ZWdyaXR5IDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2UgSW50ZXJuYWxzLmQubShocmVmKTtcbn07XG5leHBvcnRzLnJlcXVlc3RGb3JtUmVzZXQgPSBmdW5jdGlvbiAoZm9ybSkge1xuICBJbnRlcm5hbHMuZC5yKGZvcm0pO1xufTtcbmV4cG9ydHMudW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGEpIHtcbiAgcmV0dXJuIGZuKGEpO1xufTtcbmV4cG9ydHMudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspO1xufTtcbmV4cG9ydHMudXNlRm9ybVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKTtcbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///221\n')},338:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(247);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzM4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQWdFO0FBQ2xFLEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2xpZW50LmpzPzExYjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLWNsaWVudC5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1jbGllbnQuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///338\n")},961:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nfunction checkDCE() {\n  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n  if (\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'\n  ) {\n    return;\n  }\n  if (false) {}\n  try {\n    // Verify that the code above has been dead code eliminated (DCE'd).\n    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);\n  } catch (err) {\n    // DevTools shouldn't crash React, no matter what.\n    // We should still report in case we break this code.\n    console.error(err);\n  }\n}\n\nif (true) {\n  // DCE check should happen before ReactDOM bundle executes so that\n  // DevTools can report bad minification during injection.\n  checkDCE();\n  module.exports = __webpack_require__(221);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYxLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLEVBQUUsRUFTMUM7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUseUNBQXlEO0FBQzNELEVBQUUsS0FBSyxFQUVOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanM/OGJjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///961\n")},698:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");\nfunction jsxProd(type, config, maybeKey) {\n  var key = null;\n  void 0 !== maybeKey && (key = "" + maybeKey);\n  void 0 !== config.key && (key = "" + config.key);\n  if ("key" in config) {\n    maybeKey = {};\n    for (var propName in config)\n      "key" !== propName && (maybeKey[propName] = config[propName]);\n  } else maybeKey = config;\n  config = maybeKey.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== config ? config : null,\n    props: maybeKey\n  };\n}\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsxProd;\nexports.jsxs = jsxProd;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjk4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixXQUFXO0FBQ1gsWUFBWSIsInNvdXJjZXMiOlsid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanM/Y2Q0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIik7XG5mdW5jdGlvbiBqc3hQcm9kKHR5cGUsIGNvbmZpZywgbWF5YmVLZXkpIHtcbiAgdmFyIGtleSA9IG51bGw7XG4gIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiYgKGtleSA9IFwiXCIgKyBtYXliZUtleSk7XG4gIHZvaWQgMCAhPT0gY29uZmlnLmtleSAmJiAoa2V5ID0gXCJcIiArIGNvbmZpZy5rZXkpO1xuICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICBtYXliZUtleSA9IHt9O1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgfSBlbHNlIG1heWJlS2V5ID0gY29uZmlnO1xuICBjb25maWcgPSBtYXliZUtleS5yZWY7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogdm9pZCAwICE9PSBjb25maWcgPyBjb25maWcgOiBudWxsLFxuICAgIHByb3BzOiBtYXliZUtleVxuICB9O1xufVxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeFByb2Q7XG5leHBvcnRzLmpzeHMgPSBqc3hQcm9kO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///698\n')},869:(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('/* provided dependency */ var process = __webpack_require__(606);\n/**\n * @license React\n * react.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"),\n  REACT_PORTAL_TYPE = Symbol.for("react.portal"),\n  REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"),\n  REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"),\n  REACT_PROFILER_TYPE = Symbol.for("react.profiler"),\n  REACT_CONSUMER_TYPE = Symbol.for("react.consumer"),\n  REACT_CONTEXT_TYPE = Symbol.for("react.context"),\n  REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"),\n  REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"),\n  REACT_MEMO_TYPE = Symbol.for("react.memo"),\n  REACT_LAZY_TYPE = Symbol.for("react.lazy"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || "object" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable["@@iterator"];\n  return "function" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ReactNoopUpdateQueue = {\n    isMounted: function () {\n      return !1;\n    },\n    enqueueForceUpdate: function () {},\n    enqueueReplaceState: function () {},\n    enqueueSetState: function () {}\n  },\n  assign = Object.assign,\n  emptyObject = {};\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nComponent.prototype.isReactComponent = {};\nComponent.prototype.setState = function (partialState, callback) {\n  if (\n    "object" !== typeof partialState &&\n    "function" !== typeof partialState &&\n    null != partialState\n  )\n    throw Error(\n      "takes an object of state variables to update or a function which returns an object of state variables."\n    );\n  this.updater.enqueueSetState(this, partialState, callback, "setState");\n};\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, "forceUpdate");\n};\nfunction ComponentDummy() {}\nComponentDummy.prototype = Component.prototype;\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context;\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\nvar pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());\npureComponentPrototype.constructor = PureComponent;\nassign(pureComponentPrototype, Component.prototype);\npureComponentPrototype.isPureReactComponent = !0;\nvar isArrayImpl = Array.isArray,\n  ReactSharedInternals = { H: null, A: null, T: null, S: null },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction ReactElement(type, key, self, source, owner, props) {\n  self = props.ref;\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key,\n    ref: void 0 !== self ? self : null,\n    props: props\n  };\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  return ReactElement(\n    oldElement.type,\n    newKey,\n    void 0,\n    void 0,\n    void 0,\n    oldElement.props\n  );\n}\nfunction isValidElement(object) {\n  return (\n    "object" === typeof object &&\n    null !== object &&\n    object.$$typeof === REACT_ELEMENT_TYPE\n  );\n}\nfunction escape(key) {\n  var escaperLookup = { "=": "=0", ":": "=2" };\n  return (\n    "$" +\n    key.replace(/[=:]/g, function (match) {\n      return escaperLookup[match];\n    })\n  );\n}\nvar userProvidedKeyEscapeRegex = /\\/+/g;\nfunction getElementKey(element, index) {\n  return "object" === typeof element && null !== element && null != element.key\n    ? escape("" + element.key)\n    : index.toString(36);\n}\nfunction noop$1() {}\nfunction resolveThenable(thenable) {\n  switch (thenable.status) {\n    case "fulfilled":\n      return thenable.value;\n    case "rejected":\n      throw thenable.reason;\n    default:\n      switch (\n        ("string" === typeof thenable.status\n          ? thenable.then(noop$1, noop$1)\n          : ((thenable.status = "pending"),\n            thenable.then(\n              function (fulfilledValue) {\n                "pending" === thenable.status &&\n                  ((thenable.status = "fulfilled"),\n                  (thenable.value = fulfilledValue));\n              },\n              function (error) {\n                "pending" === thenable.status &&\n                  ((thenable.status = "rejected"), (thenable.reason = error));\n              }\n            )),\n        thenable.status)\n      ) {\n        case "fulfilled":\n          return thenable.value;\n        case "rejected":\n          throw thenable.reason;\n      }\n  }\n  throw thenable;\n}\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n  if ("undefined" === type || "boolean" === type) children = null;\n  var invokeCallback = !1;\n  if (null === children) invokeCallback = !0;\n  else\n    switch (type) {\n      case "bigint":\n      case "string":\n      case "number":\n        invokeCallback = !0;\n        break;\n      case "object":\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = !0;\n            break;\n          case REACT_LAZY_TYPE:\n            return (\n              (invokeCallback = children._init),\n              mapIntoArray(\n                invokeCallback(children._payload),\n                array,\n                escapedPrefix,\n                nameSoFar,\n                callback\n              )\n            );\n        }\n    }\n  if (invokeCallback)\n    return (\n      (callback = callback(children)),\n      (invokeCallback =\n        "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar),\n      isArrayImpl(callback)\n        ? ((escapedPrefix = ""),\n          null != invokeCallback &&\n            (escapedPrefix =\n              invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"),\n          mapIntoArray(callback, array, escapedPrefix, "", function (c) {\n            return c;\n          }))\n        : null != callback &&\n          (isValidElement(callback) &&\n            (callback = cloneAndReplaceKey(\n              callback,\n              escapedPrefix +\n                (null == callback.key ||\n                (children && children.key === callback.key)\n                  ? ""\n                  : ("" + callback.key).replace(\n                      userProvidedKeyEscapeRegex,\n                      "$&/"\n                    ) + "/") +\n                invokeCallback\n            )),\n          array.push(callback)),\n      1\n    );\n  invokeCallback = 0;\n  var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";\n  if (isArrayImpl(children))\n    for (var i = 0; i < children.length; i++)\n      (nameSoFar = children[i]),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if (((i = getIteratorFn(children)), "function" === typeof i))\n    for (\n      children = i.call(children), i = 0;\n      !(nameSoFar = children.next()).done;\n\n    )\n      (nameSoFar = nameSoFar.value),\n        (type = nextNamePrefix + getElementKey(nameSoFar, i++)),\n        (invokeCallback += mapIntoArray(\n          nameSoFar,\n          array,\n          escapedPrefix,\n          type,\n          callback\n        ));\n  else if ("object" === type) {\n    if ("function" === typeof children.then)\n      return mapIntoArray(\n        resolveThenable(children),\n        array,\n        escapedPrefix,\n        nameSoFar,\n        callback\n      );\n    array = String(children);\n    throw Error(\n      "Objects are not valid as a React child (found: " +\n        ("[object Object]" === array\n          ? "object with keys {" + Object.keys(children).join(", ") + "}"\n          : array) +\n        "). If you meant to render a collection of children, use an array instead."\n    );\n  }\n  return invokeCallback;\n}\nfunction mapChildren(children, func, context) {\n  if (null == children) return children;\n  var result = [],\n    count = 0;\n  mapIntoArray(children, result, "", "", function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\nfunction lazyInitializer(payload) {\n  if (-1 === payload._status) {\n    var ctor = payload._result;\n    ctor = ctor();\n    ctor.then(\n      function (moduleObject) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 1), (payload._result = moduleObject);\n      },\n      function (error) {\n        if (0 === payload._status || -1 === payload._status)\n          (payload._status = 2), (payload._result = error);\n      }\n    );\n    -1 === payload._status && ((payload._status = 0), (payload._result = ctor));\n  }\n  if (1 === payload._status) return payload._result.default;\n  throw payload._result;\n}\nvar reportGlobalError =\n  "function" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          "object" === typeof window &&\n          "function" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent("error", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              "object" === typeof error &&\n              null !== error &&\n              "string" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          "object" === typeof process &&\n          "function" === typeof process.emit\n        ) {\n          process.emit("uncaughtException", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction noop() {}\nexports.Children = {\n  map: mapChildren,\n  forEach: function (children, forEachFunc, forEachContext) {\n    mapChildren(\n      children,\n      function () {\n        forEachFunc.apply(this, arguments);\n      },\n      forEachContext\n    );\n  },\n  count: function (children) {\n    var n = 0;\n    mapChildren(children, function () {\n      n++;\n    });\n    return n;\n  },\n  toArray: function (children) {\n    return (\n      mapChildren(children, function (child) {\n        return child;\n      }) || []\n    );\n  },\n  only: function (children) {\n    if (!isValidElement(children))\n      throw Error(\n        "React.Children.only expected to receive a single React element child."\n      );\n    return children;\n  }\n};\nexports.Component = Component;\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.Profiler = REACT_PROFILER_TYPE;\nexports.PureComponent = PureComponent;\nexports.StrictMode = REACT_STRICT_MODE_TYPE;\nexports.Suspense = REACT_SUSPENSE_TYPE;\nexports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE =\n  ReactSharedInternals;\nexports.act = function () {\n  throw Error("act(...) is not supported in production builds of React.");\n};\nexports.cache = function (fn) {\n  return function () {\n    return fn.apply(null, arguments);\n  };\n};\nexports.cloneElement = function (element, config, children) {\n  if (null === element || void 0 === element)\n    throw Error(\n      "The argument must be a React element, but you passed " + element + "."\n    );\n  var props = assign({}, element.props),\n    key = element.key,\n    owner = void 0;\n  if (null != config)\n    for (propName in (void 0 !== config.ref && (owner = void 0),\n    void 0 !== config.key && (key = "" + config.key),\n    config))\n      !hasOwnProperty.call(config, propName) ||\n        "key" === propName ||\n        "__self" === propName ||\n        "__source" === propName ||\n        ("ref" === propName && void 0 === config.ref) ||\n        (props[propName] = config[propName]);\n  var propName = arguments.length - 2;\n  if (1 === propName) props.children = children;\n  else if (1 < propName) {\n    for (var childArray = Array(propName), i = 0; i < propName; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  return ReactElement(element.type, key, void 0, void 0, owner, props);\n};\nexports.createContext = function (defaultValue) {\n  defaultValue = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    _threadCount: 0,\n    Provider: null,\n    Consumer: null\n  };\n  defaultValue.Provider = defaultValue;\n  defaultValue.Consumer = {\n    $$typeof: REACT_CONSUMER_TYPE,\n    _context: defaultValue\n  };\n  return defaultValue;\n};\nexports.createElement = function (type, config, children) {\n  var propName,\n    props = {},\n    key = null;\n  if (null != config)\n    for (propName in (void 0 !== config.key && (key = "" + config.key), config))\n      hasOwnProperty.call(config, propName) &&\n        "key" !== propName &&\n        "__self" !== propName &&\n        "__source" !== propName &&\n        (props[propName] = config[propName]);\n  var childrenLength = arguments.length - 2;\n  if (1 === childrenLength) props.children = children;\n  else if (1 < childrenLength) {\n    for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)\n      childArray[i] = arguments[i + 2];\n    props.children = childArray;\n  }\n  if (type && type.defaultProps)\n    for (propName in ((childrenLength = type.defaultProps), childrenLength))\n      void 0 === props[propName] &&\n        (props[propName] = childrenLength[propName]);\n  return ReactElement(type, key, void 0, void 0, null, props);\n};\nexports.createRef = function () {\n  return { current: null };\n};\nexports.forwardRef = function (render) {\n  return { $$typeof: REACT_FORWARD_REF_TYPE, render: render };\n};\nexports.isValidElement = isValidElement;\nexports.lazy = function (ctor) {\n  return {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: { _status: -1, _result: ctor },\n    _init: lazyInitializer\n  };\n};\nexports.memo = function (type, compare) {\n  return {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: void 0 === compare ? null : compare\n  };\n};\nexports.startTransition = function (scope) {\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  try {\n    var returnValue = scope(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    "object" === typeof returnValue &&\n      null !== returnValue &&\n      "function" === typeof returnValue.then &&\n      returnValue.then(noop, reportGlobalError);\n  } catch (error) {\n    reportGlobalError(error);\n  } finally {\n    ReactSharedInternals.T = prevTransition;\n  }\n};\nexports.unstable_useCacheRefresh = function () {\n  return ReactSharedInternals.H.useCacheRefresh();\n};\nexports.use = function (usable) {\n  return ReactSharedInternals.H.use(usable);\n};\nexports.useActionState = function (action, initialState, permalink) {\n  return ReactSharedInternals.H.useActionState(action, initialState, permalink);\n};\nexports.useCallback = function (callback, deps) {\n  return ReactSharedInternals.H.useCallback(callback, deps);\n};\nexports.useContext = function (Context) {\n  return ReactSharedInternals.H.useContext(Context);\n};\nexports.useDebugValue = function () {};\nexports.useDeferredValue = function (value, initialValue) {\n  return ReactSharedInternals.H.useDeferredValue(value, initialValue);\n};\nexports.useEffect = function (create, deps) {\n  return ReactSharedInternals.H.useEffect(create, deps);\n};\nexports.useId = function () {\n  return ReactSharedInternals.H.useId();\n};\nexports.useImperativeHandle = function (ref, create, deps) {\n  return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);\n};\nexports.useInsertionEffect = function (create, deps) {\n  return ReactSharedInternals.H.useInsertionEffect(create, deps);\n};\nexports.useLayoutEffect = function (create, deps) {\n  return ReactSharedInternals.H.useLayoutEffect(create, deps);\n};\nexports.useMemo = function (create, deps) {\n  return ReactSharedInternals.H.useMemo(create, deps);\n};\nexports.useOptimistic = function (passthrough, reducer) {\n  return ReactSharedInternals.H.useOptimistic(passthrough, reducer);\n};\nexports.useReducer = function (reducer, initialArg, init) {\n  return ReactSharedInternals.H.useReducer(reducer, initialArg, init);\n};\nexports.useRef = function (initialValue) {\n  return ReactSharedInternals.H.useRef(initialValue);\n};\nexports.useState = function (initialState) {\n  return ReactSharedInternals.H.useState(initialState);\n};\nexports.useSyncExternalStore = function (\n  subscribe,\n  getSnapshot,\n  getServerSnapshot\n) {\n  return ReactSharedInternals.H.useSyncExternalStore(\n    subscribe,\n    getSnapshot,\n    getServerSnapshot\n  );\n};\nexports.useTransition = function () {\n  return ReactSharedInternals.H.useTransition();\n};\nexports.version = "19.0.0";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24uanM/NmY0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC5wcm9kdWN0aW9uLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnRcIiksXG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSxcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSxcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSxcbiAgUkVBQ1RfQ09OU1VNRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb25zdW1lclwiKSxcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksXG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksXG4gIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLFxuICBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSxcbiAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChudWxsID09PSBtYXliZUl0ZXJhYmxlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlKSByZXR1cm4gbnVsbDtcbiAgbWF5YmVJdGVyYWJsZSA9XG4gICAgKE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0pIHx8XG4gICAgbWF5YmVJdGVyYWJsZVtcIkBAaXRlcmF0b3JcIl07XG4gIHJldHVybiBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBtYXliZUl0ZXJhYmxlID8gbWF5YmVJdGVyYWJsZSA6IG51bGw7XG59XG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfSxcbiAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKCkge31cbiAgfSxcbiAgYXNzaWduID0gT2JqZWN0LmFzc2lnbixcbiAgZW1wdHlPYmplY3QgPSB7fTtcbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKFxuICAgIFwib2JqZWN0XCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICBcImZ1bmN0aW9uXCIgIT09IHR5cGVvZiBwYXJ0aWFsU3RhdGUgJiZcbiAgICBudWxsICE9IHBhcnRpYWxTdGF0ZVxuICApXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcInRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLlwiXG4gICAgKTtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBcInNldFN0YXRlXCIpO1xufTtcbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgXCJmb3JjZVVwZGF0ZVwiKTtcbn07XG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSAoUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbmFzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXksXG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0geyBIOiBudWxsLCBBOiBudWxsLCBUOiBudWxsLCBTOiBudWxsIH0sXG4gIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHNlbGYgPSBwcm9wcy5yZWY7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogdm9pZCAwICE9PSBzZWxmID8gc2VsZiA6IG51bGwsXG4gICAgcHJvcHM6IHByb3BzXG4gIH07XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgb2xkRWxlbWVudC50eXBlLFxuICAgIG5ld0tleSxcbiAgICB2b2lkIDAsXG4gICAgdm9pZCAwLFxuICAgIHZvaWQgMCxcbiAgICBvbGRFbGVtZW50LnByb3BzXG4gICk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIChcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgbnVsbCAhPT0gb2JqZWN0ICYmXG4gICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEVcbiAgKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7IFwiPVwiOiBcIj0wXCIsIFwiOlwiOiBcIj0yXCIgfTtcbiAgcmV0dXJuIChcbiAgICBcIiRcIiArXG4gICAga2V5LnJlcGxhY2UoL1s9Ol0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gICAgfSlcbiAgKTtcbn1cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIHJldHVybiBcIm9iamVjdFwiID09PSB0eXBlb2YgZWxlbWVudCAmJiBudWxsICE9PSBlbGVtZW50ICYmIG51bGwgIT0gZWxlbWVudC5rZXlcbiAgICA/IGVzY2FwZShcIlwiICsgZWxlbWVudC5rZXkpXG4gICAgOiBpbmRleC50b1N0cmluZygzNik7XG59XG5mdW5jdGlvbiBub29wJDEoKSB7fVxuZnVuY3Rpb24gcmVzb2x2ZVRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHN3aXRjaCAodGhlbmFibGUuc3RhdHVzKSB7XG4gICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgcmV0dXJuIHRoZW5hYmxlLnZhbHVlO1xuICAgIGNhc2UgXCJyZWplY3RlZFwiOlxuICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzd2l0Y2ggKFxuICAgICAgICAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHRoZW5hYmxlLnN0YXR1c1xuICAgICAgICAgID8gdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSlcbiAgICAgICAgICA6ICgodGhlbmFibGUuc3RhdHVzID0gXCJwZW5kaW5nXCIpLFxuICAgICAgICAgICAgdGhlbmFibGUudGhlbihcbiAgICAgICAgICAgICAgZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgXCJwZW5kaW5nXCIgPT09IHRoZW5hYmxlLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgICAgKCh0aGVuYWJsZS5zdGF0dXMgPSBcImZ1bGZpbGxlZFwiKSxcbiAgICAgICAgICAgICAgICAgICh0aGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgIFwicGVuZGluZ1wiID09PSB0aGVuYWJsZS5zdGF0dXMgJiZcbiAgICAgICAgICAgICAgICAgICgodGhlbmFibGUuc3RhdHVzID0gXCJyZWplY3RlZFwiKSwgKHRoZW5hYmxlLnJlYXNvbiA9IGVycm9yKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICkpLFxuICAgICAgICB0aGVuYWJsZS5zdGF0dXMpXG4gICAgICApIHtcbiAgICAgICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgICAgIHJldHVybiB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICAgICAgdGhyb3cgdGhlbmFibGUucmVhc29uO1xuICAgICAgfVxuICB9XG4gIHRocm93IHRoZW5hYmxlO1xufVxuZnVuY3Rpb24gbWFwSW50b0FycmF5KGNoaWxkcmVuLCBhcnJheSwgZXNjYXBlZFByZWZpeCwgbmFtZVNvRmFyLCBjYWxsYmFjaykge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcbiAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGUgfHwgXCJib29sZWFuXCIgPT09IHR5cGUpIGNoaWxkcmVuID0gbnVsbDtcbiAgdmFyIGludm9rZUNhbGxiYWNrID0gITE7XG4gIGlmIChudWxsID09PSBjaGlsZHJlbikgaW52b2tlQ2FsbGJhY2sgPSAhMDtcbiAgZWxzZVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgc3dpdGNoIChjaGlsZHJlbi4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9ICEwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAoaW52b2tlQ2FsbGJhY2sgPSBjaGlsZHJlbi5faW5pdCksXG4gICAgICAgICAgICAgIG1hcEludG9BcnJheShcbiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjaGlsZHJlbi5fcGF5bG9hZCksXG4gICAgICAgICAgICAgICAgYXJyYXksXG4gICAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCxcbiAgICAgICAgICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgaWYgKGludm9rZUNhbGxiYWNrKVxuICAgIHJldHVybiAoXG4gICAgICAoY2FsbGJhY2sgPSBjYWxsYmFjayhjaGlsZHJlbikpLFxuICAgICAgKGludm9rZUNhbGxiYWNrID1cbiAgICAgICAgXCJcIiA9PT0gbmFtZVNvRmFyID8gXCIuXCIgKyBnZXRFbGVtZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0ZhciksXG4gICAgICBpc0FycmF5SW1wbChjYWxsYmFjaylcbiAgICAgICAgPyAoKGVzY2FwZWRQcmVmaXggPSBcIlwiKSxcbiAgICAgICAgICBudWxsICE9IGludm9rZUNhbGxiYWNrICYmXG4gICAgICAgICAgICAoZXNjYXBlZFByZWZpeCA9XG4gICAgICAgICAgICAgIGludm9rZUNhbGxiYWNrLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsIFwiJCYvXCIpICsgXCIvXCIpLFxuICAgICAgICAgIG1hcEludG9BcnJheShjYWxsYmFjaywgYXJyYXksIGVzY2FwZWRQcmVmaXgsIFwiXCIsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICB9KSlcbiAgICAgICAgOiBudWxsICE9IGNhbGxiYWNrICYmXG4gICAgICAgICAgKGlzVmFsaWRFbGVtZW50KGNhbGxiYWNrKSAmJlxuICAgICAgICAgICAgKGNhbGxiYWNrID0gY2xvbmVBbmRSZXBsYWNlS2V5KFxuICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgZXNjYXBlZFByZWZpeCArXG4gICAgICAgICAgICAgICAgKG51bGwgPT0gY2FsbGJhY2sua2V5IHx8XG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmtleSA9PT0gY2FsbGJhY2sua2V5KVxuICAgICAgICAgICAgICAgICAgPyBcIlwiXG4gICAgICAgICAgICAgICAgICA6IChcIlwiICsgY2FsbGJhY2sua2V5KS5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgICAgIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgIFwiJCYvXCJcbiAgICAgICAgICAgICAgICAgICAgKSArIFwiL1wiKSArXG4gICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2tcbiAgICAgICAgICAgICkpLFxuICAgICAgICAgIGFycmF5LnB1c2goY2FsbGJhY2spKSxcbiAgICAgIDFcbiAgICApO1xuICBpbnZva2VDYWxsYmFjayA9IDA7XG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IFwiXCIgPT09IG5hbWVTb0ZhciA/IFwiLlwiIDogbmFtZVNvRmFyICsgXCI6XCI7XG4gIGlmIChpc0FycmF5SW1wbChjaGlsZHJlbikpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgIChuYW1lU29GYXIgPSBjaGlsZHJlbltpXSksXG4gICAgICAgICh0eXBlID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KG5hbWVTb0ZhciwgaSkpLFxuICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICBhcnJheSxcbiAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKSk7XG4gIGVsc2UgaWYgKCgoaSA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pKSwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSkpXG4gICAgZm9yIChcbiAgICAgIGNoaWxkcmVuID0gaS5jYWxsKGNoaWxkcmVuKSwgaSA9IDA7XG4gICAgICAhKG5hbWVTb0ZhciA9IGNoaWxkcmVuLm5leHQoKSkuZG9uZTtcblxuICAgIClcbiAgICAgIChuYW1lU29GYXIgPSBuYW1lU29GYXIudmFsdWUpLFxuICAgICAgICAodHlwZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShuYW1lU29GYXIsIGkrKykpLFxuICAgICAgICAoaW52b2tlQ2FsbGJhY2sgKz0gbWFwSW50b0FycmF5KFxuICAgICAgICAgIG5hbWVTb0ZhcixcbiAgICAgICAgICBhcnJheSxcbiAgICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKSk7XG4gIGVsc2UgaWYgKFwib2JqZWN0XCIgPT09IHR5cGUpIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgY2hpbGRyZW4udGhlbilcbiAgICAgIHJldHVybiBtYXBJbnRvQXJyYXkoXG4gICAgICAgIHJlc29sdmVUaGVuYWJsZShjaGlsZHJlbiksXG4gICAgICAgIGFycmF5LFxuICAgICAgICBlc2NhcGVkUHJlZml4LFxuICAgICAgICBuYW1lU29GYXIsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIGFycmF5ID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICB0aHJvdyBFcnJvcihcbiAgICAgIFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArXG4gICAgICAgIChcIltvYmplY3QgT2JqZWN0XVwiID09PSBhcnJheVxuICAgICAgICAgID8gXCJvYmplY3Qgd2l0aCBrZXlzIHtcIiArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKFwiLCBcIikgKyBcIn1cIlxuICAgICAgICAgIDogYXJyYXkpICtcbiAgICAgICAgXCIpLiBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5IGluc3RlYWQuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBpbnZva2VDYWxsYmFjaztcbn1cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChudWxsID09IGNoaWxkcmVuKSByZXR1cm4gY2hpbGRyZW47XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICBjb3VudCA9IDA7XG4gIG1hcEludG9BcnJheShjaGlsZHJlbiwgcmVzdWx0LCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBjb3VudCsrKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBsYXp5SW5pdGlhbGl6ZXIocGF5bG9hZCkge1xuICBpZiAoLTEgPT09IHBheWxvYWQuX3N0YXR1cykge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIGN0b3IgPSBjdG9yKCk7XG4gICAgY3Rvci50aGVuKFxuICAgICAgZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgICBpZiAoMCA9PT0gcGF5bG9hZC5fc3RhdHVzIHx8IC0xID09PSBwYXlsb2FkLl9zdGF0dXMpXG4gICAgICAgICAgKHBheWxvYWQuX3N0YXR1cyA9IDEpLCAocGF5bG9hZC5fcmVzdWx0ID0gbW9kdWxlT2JqZWN0KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKDAgPT09IHBheWxvYWQuX3N0YXR1cyB8fCAtMSA9PT0gcGF5bG9hZC5fc3RhdHVzKVxuICAgICAgICAgIChwYXlsb2FkLl9zdGF0dXMgPSAyKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGVycm9yKTtcbiAgICAgIH1cbiAgICApO1xuICAgIC0xID09PSBwYXlsb2FkLl9zdGF0dXMgJiYgKChwYXlsb2FkLl9zdGF0dXMgPSAwKSwgKHBheWxvYWQuX3Jlc3VsdCA9IGN0b3IpKTtcbiAgfVxuICBpZiAoMSA9PT0gcGF5bG9hZC5fc3RhdHVzKSByZXR1cm4gcGF5bG9hZC5fcmVzdWx0LmRlZmF1bHQ7XG4gIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbn1cbnZhciByZXBvcnRHbG9iYWxFcnJvciA9XG4gIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHJlcG9ydEVycm9yXG4gICAgPyByZXBvcnRFcnJvclxuICAgIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygd2luZG93ICYmXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgICAgYnViYmxlczogITAsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiAhMCxcbiAgICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBlcnJvciAmJlxuICAgICAgICAgICAgICBudWxsICE9PSBlcnJvciAmJlxuICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZXJyb3IubWVzc2FnZVxuICAgICAgICAgICAgICAgID8gU3RyaW5nKGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgOiBTdHJpbmcoZXJyb3IpLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCkpIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcHJvY2VzcyAmJlxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHByb2Nlc3MuZW1pdFxuICAgICAgICApIHtcbiAgICAgICAgICBwcm9jZXNzLmVtaXQoXCJ1bmNhdWdodEV4Y2VwdGlvblwiLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfTtcbmZ1bmN0aW9uIG5vb3AoKSB7fVxuZXhwb3J0cy5DaGlsZHJlbiA9IHtcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgZm9yRWFjaDogZnVuY3Rpb24gKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgICBtYXBDaGlsZHJlbihcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JFYWNoRnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSxcbiAgICAgIGZvckVhY2hDb250ZXh0XG4gICAgKTtcbiAgfSxcbiAgY291bnQ6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIHZhciBuID0gMDtcbiAgICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgbisrO1xuICAgIH0pO1xuICAgIHJldHVybiBuO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbiAoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4gKFxuICAgICAgbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9KSB8fCBbXVxuICAgICk7XG4gIH0sXG4gIG9ubHk6IGZ1bmN0aW9uIChjaGlsZHJlbikge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKVxuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG59O1xuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnQ7XG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG5leHBvcnRzLlN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbmV4cG9ydHMuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFID1cbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHM7XG5leHBvcnRzLmFjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgRXJyb3IoXCJhY3QoLi4uKSBpcyBub3Qgc3VwcG9ydGVkIGluIHByb2R1Y3Rpb24gYnVpbGRzIG9mIFJlYWN0LlwiKTtcbn07XG5leHBvcnRzLmNhY2hlID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICBpZiAobnVsbCA9PT0gZWxlbWVudCB8fCB2b2lkIDAgPT09IGVsZW1lbnQpXG4gICAgdGhyb3cgRXJyb3IoXG4gICAgICBcIlRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgXCIgKyBlbGVtZW50ICsgXCIuXCJcbiAgICApO1xuICB2YXIgcHJvcHMgPSBhc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpLFxuICAgIGtleSA9IGVsZW1lbnQua2V5LFxuICAgIG93bmVyID0gdm9pZCAwO1xuICBpZiAobnVsbCAhPSBjb25maWcpXG4gICAgZm9yIChwcm9wTmFtZSBpbiAodm9pZCAwICE9PSBjb25maWcucmVmICYmIChvd25lciA9IHZvaWQgMCksXG4gICAgdm9pZCAwICE9PSBjb25maWcua2V5ICYmIChrZXkgPSBcIlwiICsgY29uZmlnLmtleSksXG4gICAgY29uZmlnKSlcbiAgICAgICFoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpIHx8XG4gICAgICAgIFwia2V5XCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgIFwiX19zZWxmXCIgPT09IHByb3BOYW1lIHx8XG4gICAgICAgIFwiX19zb3VyY2VcIiA9PT0gcHJvcE5hbWUgfHxcbiAgICAgICAgKFwicmVmXCIgPT09IHByb3BOYW1lICYmIHZvaWQgMCA9PT0gY29uZmlnLnJlZikgfHxcbiAgICAgICAgKHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV0pO1xuICB2YXIgcHJvcE5hbWUgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKDEgPT09IHByb3BOYW1lKSBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICBlbHNlIGlmICgxIDwgcHJvcE5hbWUpIHtcbiAgICBmb3IgKHZhciBjaGlsZEFycmF5ID0gQXJyYXkocHJvcE5hbWUpLCBpID0gMDsgaSA8IHByb3BOYW1lOyBpKyspXG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgdm9pZCAwLCB2b2lkIDAsIG93bmVyLCBwcm9wcyk7XG59O1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGRlZmF1bHRWYWx1ZSkge1xuICBkZWZhdWx0VmFsdWUgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlRFWFRfVFlQRSxcbiAgICBfY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgX2N1cnJlbnRWYWx1ZTI6IGRlZmF1bHRWYWx1ZSxcbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgZGVmYXVsdFZhbHVlLlByb3ZpZGVyID0gZGVmYXVsdFZhbHVlO1xuICBkZWZhdWx0VmFsdWUuQ29uc3VtZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0NPTlNVTUVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufTtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZSxcbiAgICBwcm9wcyA9IHt9LFxuICAgIGtleSA9IG51bGw7XG4gIGlmIChudWxsICE9IGNvbmZpZylcbiAgICBmb3IgKHByb3BOYW1lIGluICh2b2lkIDAgIT09IGNvbmZpZy5rZXkgJiYgKGtleSA9IFwiXCIgKyBjb25maWcua2V5KSwgY29uZmlnKSlcbiAgICAgIGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiZcbiAgICAgICAgXCJrZXlcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgXCJfX3NlbGZcIiAhPT0gcHJvcE5hbWUgJiZcbiAgICAgICAgXCJfX3NvdXJjZVwiICE9PSBwcm9wTmFtZSAmJlxuICAgICAgICAocHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoMSA9PT0gY2hpbGRyZW5MZW5ndGgpIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIGVsc2UgaWYgKDEgPCBjaGlsZHJlbkxlbmd0aCkge1xuICAgIGZvciAodmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCksIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKylcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcylcbiAgICBmb3IgKHByb3BOYW1lIGluICgoY2hpbGRyZW5MZW5ndGggPSB0eXBlLmRlZmF1bHRQcm9wcyksIGNoaWxkcmVuTGVuZ3RoKSlcbiAgICAgIHZvaWQgMCA9PT0gcHJvcHNbcHJvcE5hbWVdICYmXG4gICAgICAgIChwcm9wc1twcm9wTmFtZV0gPSBjaGlsZHJlbkxlbmd0aFtwcm9wTmFtZV0pO1xuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgdm9pZCAwLCB2b2lkIDAsIG51bGwsIHByb3BzKTtcbn07XG5leHBvcnRzLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufTtcbmV4cG9ydHMuZm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChyZW5kZXIpIHtcbiAgcmV0dXJuIHsgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsIHJlbmRlcjogcmVuZGVyIH07XG59O1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IGlzVmFsaWRFbGVtZW50O1xuZXhwb3J0cy5sYXp5ID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9wYXlsb2FkOiB7IF9zdGF0dXM6IC0xLCBfcmVzdWx0OiBjdG9yIH0sXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xufTtcbmV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uICh0eXBlLCBjb21wYXJlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX01FTU9fVFlQRSxcbiAgICB0eXBlOiB0eXBlLFxuICAgIGNvbXBhcmU6IHZvaWQgMCA9PT0gY29tcGFyZSA/IG51bGwgOiBjb21wYXJlXG4gIH07XG59O1xuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCxcbiAgICBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG4gIHRyeSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gc2NvcGUoKSxcbiAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcbiAgICBudWxsICE9PSBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAmJlxuICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICBcIm9iamVjdFwiID09PSB0eXBlb2YgcmV0dXJuVmFsdWUgJiZcbiAgICAgIG51bGwgIT09IHJldHVyblZhbHVlICYmXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuICYmXG4gICAgICByZXR1cm5WYWx1ZS50aGVuKG5vb3AsIHJlcG9ydEdsb2JhbEVycm9yKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICB9XG59O1xuZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUNhY2hlUmVmcmVzaCgpO1xufTtcbmV4cG9ydHMudXNlID0gZnVuY3Rpb24gKHVzYWJsZSkge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2UodXNhYmxlKTtcbn07XG5leHBvcnRzLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluayk7XG59O1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VDb250ZXh0ID0gZnVuY3Rpb24gKENvbnRleHQpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlQ29udGV4dChDb250ZXh0KTtcbn07XG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMudXNlRGVmZXJyZWRWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG59O1xuZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xufTtcbmV4cG9ydHMudXNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUlkKCk7XG59O1xuZXhwb3J0cy51c2VJbXBlcmF0aXZlSGFuZGxlID0gZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufTtcbmV4cG9ydHMudXNlSW5zZXJ0aW9uRWZmZWN0ID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbn07XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkgudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VNZW1vID0gZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VNZW1vKGNyZWF0ZSwgZGVwcyk7XG59O1xuZXhwb3J0cy51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufTtcbmV4cG9ydHMudXNlUmVkdWNlciA9IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59O1xuZXhwb3J0cy51c2VSZWYgPSBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVJlZihpbml0aWFsVmFsdWUpO1xufTtcbmV4cG9ydHMudXNlU3RhdGUgPSBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG59O1xuZXhwb3J0cy51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IGZ1bmN0aW9uIChcbiAgc3Vic2NyaWJlLFxuICBnZXRTbmFwc2hvdCxcbiAgZ2V0U2VydmVyU25hcHNob3Rcbikge1xuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSC51c2VTeW5jRXh0ZXJuYWxTdG9yZShcbiAgICBzdWJzY3JpYmUsXG4gICAgZ2V0U25hcHNob3QsXG4gICAgZ2V0U2VydmVyU25hcHNob3RcbiAgKTtcbn07XG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5ILnVzZVRyYW5zaXRpb24oKTtcbn07XG5leHBvcnRzLnZlcnNpb24gPSBcIjE5LjAuMFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///869\n')},540:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(869);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQwLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBcUQ7QUFDdkQsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzP2FiNWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///540\n")},848:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(698);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBaUU7QUFDbkUsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzPzljYTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///848\n")},477:(__unused_webpack_module,exports)=>{"use strict";eval('/**\n * @license React\n * scheduler.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  a: for (; 0 < index; ) {\n    var parentIndex = (index - 1) >>> 1,\n      parent = heap[parentIndex];\n    if (0 < compare(parent, node))\n      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);\n    else break a;\n  }\n}\nfunction peek(heap) {\n  return 0 === heap.length ? null : heap[0];\n}\nfunction pop(heap) {\n  if (0 === heap.length) return null;\n  var first = heap[0],\n    last = heap.pop();\n  if (last !== first) {\n    heap[0] = last;\n    a: for (\n      var index = 0, length = heap.length, halfLength = length >>> 1;\n      index < halfLength;\n\n    ) {\n      var leftIndex = 2 * (index + 1) - 1,\n        left = heap[leftIndex],\n        rightIndex = leftIndex + 1,\n        right = heap[rightIndex];\n      if (0 > compare(left, last))\n        rightIndex < length && 0 > compare(right, left)\n          ? ((heap[index] = right),\n            (heap[rightIndex] = last),\n            (index = rightIndex))\n          : ((heap[index] = left),\n            (heap[leftIndex] = last),\n            (index = leftIndex));\n      else if (rightIndex < length && 0 > compare(right, last))\n        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);\n      else break a;\n    }\n  }\n  return first;\n}\nfunction compare(a, b) {\n  var diff = a.sortIndex - b.sortIndex;\n  return 0 !== diff ? diff : a.id - b.id;\n}\nexports.unstable_now = void 0;\nif ("object" === typeof performance && "function" === typeof performance.now) {\n  var localPerformance = performance;\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date,\n    initialTime = localDate.now();\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n}\nvar taskQueue = [],\n  timerQueue = [],\n  taskIdCounter = 1,\n  currentTask = null,\n  currentPriorityLevel = 3,\n  isPerformingWork = !1,\n  isHostCallbackScheduled = !1,\n  isHostTimeoutScheduled = !1,\n  localSetTimeout = "function" === typeof setTimeout ? setTimeout : null,\n  localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null,\n  localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;\nfunction advanceTimers(currentTime) {\n  for (var timer = peek(timerQueue); null !== timer; ) {\n    if (null === timer.callback) pop(timerQueue);\n    else if (timer.startTime <= currentTime)\n      pop(timerQueue),\n        (timer.sortIndex = timer.expirationTime),\n        push(taskQueue, timer);\n    else break;\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = !1;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled)\n    if (null !== peek(taskQueue))\n      (isHostCallbackScheduled = !0), requestHostCallback();\n    else {\n      var firstTimer = peek(timerQueue);\n      null !== firstTimer &&\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n}\nvar isMessageLoopRunning = !1,\n  taskTimeoutID = -1,\n  frameInterval = 5,\n  startTime = -1;\nfunction shouldYieldToHost() {\n  return exports.unstable_now() - startTime < frameInterval ? !1 : !0;\n}\nfunction performWorkUntilDeadline() {\n  if (isMessageLoopRunning) {\n    var currentTime = exports.unstable_now();\n    startTime = currentTime;\n    var hasMoreWork = !0;\n    try {\n      a: {\n        isHostCallbackScheduled = !1;\n        isHostTimeoutScheduled &&\n          ((isHostTimeoutScheduled = !1),\n          localClearTimeout(taskTimeoutID),\n          (taskTimeoutID = -1));\n        isPerformingWork = !0;\n        var previousPriorityLevel = currentPriorityLevel;\n        try {\n          b: {\n            advanceTimers(currentTime);\n            for (\n              currentTask = peek(taskQueue);\n              null !== currentTask &&\n              !(\n                currentTask.expirationTime > currentTime && shouldYieldToHost()\n              );\n\n            ) {\n              var callback = currentTask.callback;\n              if ("function" === typeof callback) {\n                currentTask.callback = null;\n                currentPriorityLevel = currentTask.priorityLevel;\n                var continuationCallback = callback(\n                  currentTask.expirationTime <= currentTime\n                );\n                currentTime = exports.unstable_now();\n                if ("function" === typeof continuationCallback) {\n                  currentTask.callback = continuationCallback;\n                  advanceTimers(currentTime);\n                  hasMoreWork = !0;\n                  break b;\n                }\n                currentTask === peek(taskQueue) && pop(taskQueue);\n                advanceTimers(currentTime);\n              } else pop(taskQueue);\n              currentTask = peek(taskQueue);\n            }\n            if (null !== currentTask) hasMoreWork = !0;\n            else {\n              var firstTimer = peek(timerQueue);\n              null !== firstTimer &&\n                requestHostTimeout(\n                  handleTimeout,\n                  firstTimer.startTime - currentTime\n                );\n              hasMoreWork = !1;\n            }\n          }\n          break a;\n        } finally {\n          (currentTask = null),\n            (currentPriorityLevel = previousPriorityLevel),\n            (isPerformingWork = !1);\n        }\n        hasMoreWork = void 0;\n      }\n    } finally {\n      hasMoreWork\n        ? schedulePerformWorkUntilDeadline()\n        : (isMessageLoopRunning = !1);\n    }\n  }\n}\nvar schedulePerformWorkUntilDeadline;\nif ("function" === typeof localSetImmediate)\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\nelse if ("undefined" !== typeof MessageChannel) {\n  var channel = new MessageChannel(),\n    port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\nfunction requestHostCallback() {\n  isMessageLoopRunning ||\n    ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n}\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\nexports.unstable_IdlePriority = 5;\nexports.unstable_ImmediatePriority = 1;\nexports.unstable_LowPriority = 4;\nexports.unstable_NormalPriority = 3;\nexports.unstable_Profiling = null;\nexports.unstable_UserBlockingPriority = 2;\nexports.unstable_cancelCallback = function (task) {\n  task.callback = null;\n};\nexports.unstable_continueExecution = function () {\n  isHostCallbackScheduled ||\n    isPerformingWork ||\n    ((isHostCallbackScheduled = !0), requestHostCallback());\n};\nexports.unstable_forceFrameRate = function (fps) {\n  0 > fps || 125 < fps\n    ? console.error(\n        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"\n      )\n    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n};\nexports.unstable_getCurrentPriorityLevel = function () {\n  return currentPriorityLevel;\n};\nexports.unstable_getFirstCallbackNode = function () {\n  return peek(taskQueue);\n};\nexports.unstable_next = function (eventHandler) {\n  switch (currentPriorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n      var priorityLevel = 3;\n      break;\n    default:\n      priorityLevel = currentPriorityLevel;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_pauseExecution = function () {};\nexports.unstable_requestPaint = function () {};\nexports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      break;\n    default:\n      priorityLevel = 3;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_scheduleCallback = function (\n  priorityLevel,\n  callback,\n  options\n) {\n  var currentTime = exports.unstable_now();\n  "object" === typeof options && null !== options\n    ? ((options = options.delay),\n      (options =\n        "number" === typeof options && 0 < options\n          ? currentTime + options\n          : currentTime))\n    : (options = currentTime);\n  switch (priorityLevel) {\n    case 1:\n      var timeout = -1;\n      break;\n    case 2:\n      timeout = 250;\n      break;\n    case 5:\n      timeout = 1073741823;\n      break;\n    case 4:\n      timeout = 1e4;\n      break;\n    default:\n      timeout = 5e3;\n  }\n  timeout = options + timeout;\n  priorityLevel = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: options,\n    expirationTime: timeout,\n    sortIndex: -1\n  };\n  options > currentTime\n    ? ((priorityLevel.sortIndex = options),\n      push(timerQueue, priorityLevel),\n      null === peek(taskQueue) &&\n        priorityLevel === peek(timerQueue) &&\n        (isHostTimeoutScheduled\n          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n          : (isHostTimeoutScheduled = !0),\n        requestHostTimeout(handleTimeout, options - currentTime)))\n    : ((priorityLevel.sortIndex = timeout),\n      push(taskQueue, priorityLevel),\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0), requestHostCallback()));\n  return priorityLevel;\n};\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = function (callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLnByb2R1Y3Rpb24uanM/MDU3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBwdXNoKGhlYXAsIG5vZGUpIHtcbiAgdmFyIGluZGV4ID0gaGVhcC5sZW5ndGg7XG4gIGhlYXAucHVzaChub2RlKTtcbiAgYTogZm9yICg7IDAgPCBpbmRleDsgKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gKGluZGV4IC0gMSkgPj4+IDEsXG4gICAgICBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcbiAgICBpZiAoMCA8IGNvbXBhcmUocGFyZW50LCBub2RlKSlcbiAgICAgIChoZWFwW3BhcmVudEluZGV4XSA9IG5vZGUpLCAoaGVhcFtpbmRleF0gPSBwYXJlbnQpLCAoaW5kZXggPSBwYXJlbnRJbmRleCk7XG4gICAgZWxzZSBicmVhayBhO1xuICB9XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIDAgPT09IGhlYXAubGVuZ3RoID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoMCA9PT0gaGVhcC5sZW5ndGgpIHJldHVybiBudWxsO1xuICB2YXIgZmlyc3QgPSBoZWFwWzBdLFxuICAgIGxhc3QgPSBoZWFwLnBvcCgpO1xuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBhOiBmb3IgKFxuICAgICAgdmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gaGVhcC5sZW5ndGgsIGhhbGZMZW5ndGggPSBsZW5ndGggPj4+IDE7XG4gICAgICBpbmRleCA8IGhhbGZMZW5ndGg7XG5cbiAgICApIHtcbiAgICAgIHZhciBsZWZ0SW5kZXggPSAyICogKGluZGV4ICsgMSkgLSAxLFxuICAgICAgICBsZWZ0ID0gaGVhcFtsZWZ0SW5kZXhdLFxuICAgICAgICByaWdodEluZGV4ID0gbGVmdEluZGV4ICsgMSxcbiAgICAgICAgcmlnaHQgPSBoZWFwW3JpZ2h0SW5kZXhdO1xuICAgICAgaWYgKDAgPiBjb21wYXJlKGxlZnQsIGxhc3QpKVxuICAgICAgICByaWdodEluZGV4IDwgbGVuZ3RoICYmIDAgPiBjb21wYXJlKHJpZ2h0LCBsZWZ0KVxuICAgICAgICAgID8gKChoZWFwW2luZGV4XSA9IHJpZ2h0KSxcbiAgICAgICAgICAgIChoZWFwW3JpZ2h0SW5kZXhdID0gbGFzdCksXG4gICAgICAgICAgICAoaW5kZXggPSByaWdodEluZGV4KSlcbiAgICAgICAgICA6ICgoaGVhcFtpbmRleF0gPSBsZWZ0KSxcbiAgICAgICAgICAgIChoZWFwW2xlZnRJbmRleF0gPSBsYXN0KSxcbiAgICAgICAgICAgIChpbmRleCA9IGxlZnRJbmRleCkpO1xuICAgICAgZWxzZSBpZiAocmlnaHRJbmRleCA8IGxlbmd0aCAmJiAwID4gY29tcGFyZShyaWdodCwgbGFzdCkpXG4gICAgICAgIChoZWFwW2luZGV4XSA9IHJpZ2h0KSwgKGhlYXBbcmlnaHRJbmRleF0gPSBsYXN0KSwgKGluZGV4ID0gcmlnaHRJbmRleCk7XG4gICAgICBlbHNlIGJyZWFrIGE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmaXJzdDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiAwICE9PSBkaWZmID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuZXhwb3J0cy51bnN0YWJsZV9ub3cgPSB2b2lkIDA7XG5pZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlICYmIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHBlcmZvcm1hbmNlLm5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBsb2NhbERhdGUgPSBEYXRlLFxuICAgIGluaXRpYWxUaW1lID0gbG9jYWxEYXRlLm5vdygpO1xuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59XG52YXIgdGFza1F1ZXVlID0gW10sXG4gIHRpbWVyUXVldWUgPSBbXSxcbiAgdGFza0lkQ291bnRlciA9IDEsXG4gIGN1cnJlbnRUYXNrID0gbnVsbCxcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSAzLFxuICBpc1BlcmZvcm1pbmdXb3JrID0gITEsXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITEsXG4gIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSxcbiAgbG9jYWxTZXRUaW1lb3V0ID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiBudWxsLFxuICBsb2NhbENsZWFyVGltZW91dCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGNsZWFyVGltZW91dCA/IGNsZWFyVGltZW91dCA6IG51bGwsXG4gIGxvY2FsU2V0SW1tZWRpYXRlID0gXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIHNldEltbWVkaWF0ZSA/IHNldEltbWVkaWF0ZSA6IG51bGw7XG5mdW5jdGlvbiBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKSB7XG4gIGZvciAodmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTsgbnVsbCAhPT0gdGltZXI7ICkge1xuICAgIGlmIChudWxsID09PSB0aW1lci5jYWxsYmFjaykgcG9wKHRpbWVyUXVldWUpO1xuICAgIGVsc2UgaWYgKHRpbWVyLnN0YXJ0VGltZSA8PSBjdXJyZW50VGltZSlcbiAgICAgIHBvcCh0aW1lclF1ZXVlKSxcbiAgICAgICAgKHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lKSxcbiAgICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICBlbHNlIGJyZWFrO1xuICAgIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gITE7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKVxuICAgIGlmIChudWxsICE9PSBwZWVrKHRhc2tRdWV1ZSkpXG4gICAgICAoaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSAhMCksIHJlcXVlc3RIb3N0Q2FsbGJhY2soKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcbiAgICAgIG51bGwgIT09IGZpcnN0VGltZXIgJiZcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cbn1cbnZhciBpc01lc3NhZ2VMb29wUnVubmluZyA9ICExLFxuICB0YXNrVGltZW91dElEID0gLTEsXG4gIGZyYW1lSW50ZXJ2YWwgPSA1LFxuICBzdGFydFRpbWUgPSAtMTtcbmZ1bmN0aW9uIHNob3VsZFlpZWxkVG9Ib3N0KCkge1xuICByZXR1cm4gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZSA8IGZyYW1lSW50ZXJ2YWwgPyAhMSA6ICEwO1xufVxuZnVuY3Rpb24gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkge1xuICBpZiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgIHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHZhciBoYXNNb3JlV29yayA9ICEwO1xuICAgIHRyeSB7XG4gICAgICBhOiB7XG4gICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gITE7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgJiZcbiAgICAgICAgICAoKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMSksXG4gICAgICAgICAgbG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksXG4gICAgICAgICAgKHRhc2tUaW1lb3V0SUQgPSAtMSkpO1xuICAgICAgICBpc1BlcmZvcm1pbmdXb3JrID0gITA7XG4gICAgICAgIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiOiB7XG4gICAgICAgICAgICBhZHZhbmNlVGltZXJzKGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICAgICAgICAgICAgICBudWxsICE9PSBjdXJyZW50VGFzayAmJlxuICAgICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgc2hvdWxkWWllbGRUb0hvc3QoKVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gY3VycmVudFRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRUYXNrLnByaW9yaXR5TGV2ZWw7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRpbnVhdGlvbkNhbGxiYWNrID0gY2FsbGJhY2soXG4gICAgICAgICAgICAgICAgICBjdXJyZW50VGFzay5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBjb250aW51YXRpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgY3VycmVudFRhc2suY2FsbGJhY2sgPSBjb250aW51YXRpb25DYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuICAgICAgICAgICAgICAgICAgaGFzTW9yZVdvcmsgPSAhMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRUYXNrID09PSBwZWVrKHRhc2tRdWV1ZSkgJiYgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBwb3AodGFza1F1ZXVlKTtcbiAgICAgICAgICAgICAgY3VycmVudFRhc2sgPSBwZWVrKHRhc2tRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobnVsbCAhPT0gY3VycmVudFRhc2spIGhhc01vcmVXb3JrID0gITA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0VGltZXIgPSBwZWVrKHRpbWVyUXVldWUpO1xuICAgICAgICAgICAgICBudWxsICE9PSBmaXJzdFRpbWVyICYmXG4gICAgICAgICAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KFxuICAgICAgICAgICAgICAgICAgaGFuZGxlVGltZW91dCxcbiAgICAgICAgICAgICAgICAgIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBoYXNNb3JlV29yayA9ICExO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhayBhO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIChjdXJyZW50VGFzayA9IG51bGwpLFxuICAgICAgICAgICAgKGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsKSxcbiAgICAgICAgICAgIChpc1BlcmZvcm1pbmdXb3JrID0gITEpO1xuICAgICAgICB9XG4gICAgICAgIGhhc01vcmVXb3JrID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBoYXNNb3JlV29ya1xuICAgICAgICA/IHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKClcbiAgICAgICAgOiAoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMSk7XG4gICAgfVxuICB9XG59XG52YXIgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG5pZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgbG9jYWxTZXRJbW1lZGlhdGUpXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIGxvY2FsU2V0SW1tZWRpYXRlKHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSk7XG4gIH07XG5lbHNlIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgTWVzc2FnZUNoYW5uZWwpIHtcbiAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKSxcbiAgICBwb3J0ID0gY2hhbm5lbC5wb3J0MjtcbiAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmU7XG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2VcbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG5mdW5jdGlvbiByZXF1ZXN0SG9zdENhbGxiYWNrKCkge1xuICBpc01lc3NhZ2VMb29wUnVubmluZyB8fFxuICAgICgoaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSAhMCksIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lKCkpO1xufVxuZnVuY3Rpb24gcmVxdWVzdEhvc3RUaW1lb3V0KGNhbGxiYWNrLCBtcykge1xuICB0YXNrVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLnVuc3RhYmxlX25vdygpKTtcbiAgfSwgbXMpO1xufVxuZXhwb3J0cy51bnN0YWJsZV9JZGxlUHJpb3JpdHkgPSA1O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IDE7XG5leHBvcnRzLnVuc3RhYmxlX0xvd1ByaW9yaXR5ID0gNDtcbmV4cG9ydHMudW5zdGFibGVfTm9ybWFsUHJpb3JpdHkgPSAzO1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSBudWxsO1xuZXhwb3J0cy51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgdGFzay5jYWxsYmFjayA9IG51bGw7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgfHxcbiAgICBpc1BlcmZvcm1pbmdXb3JrIHx8XG4gICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKTtcbn07XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZnVuY3Rpb24gKGZwcykge1xuICAwID4gZnBzIHx8IDEyNSA8IGZwc1xuICAgID8gY29uc29sZS5lcnJvcihcbiAgICAgICAgXCJmb3JjZUZyYW1lUmF0ZSB0YWtlcyBhIHBvc2l0aXZlIGludCBiZXR3ZWVuIDAgYW5kIDEyNSwgZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWRcIlxuICAgICAgKVxuICAgIDogKGZyYW1lSW50ZXJ2YWwgPSAwIDwgZnBzID8gTWF0aC5mbG9vcigxZTMgLyBmcHMpIDogNSk7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGN1cnJlbnRQcmlvcml0eUxldmVsO1xufTtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZWVrKHRhc2tRdWV1ZSk7XG59O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gZnVuY3Rpb24gKGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgICB2YXIgcHJpb3JpdHlMZXZlbCA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICB9XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmlvcml0eUxldmVsO1xuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufTtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcbmV4cG9ydHMudW5zdGFibGVfcmVxdWVzdFBhaW50ID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IGZ1bmN0aW9uIChwcmlvcml0eUxldmVsLCBldmVudEhhbmRsZXIpIHtcbiAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgY2FzZSA0OlxuICAgIGNhc2UgNTpcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gMztcbiAgfVxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn07XG5leHBvcnRzLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoXG4gIHByaW9yaXR5TGV2ZWwsXG4gIGNhbGxiYWNrLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG9wdGlvbnMgJiYgbnVsbCAhPT0gb3B0aW9uc1xuICAgID8gKChvcHRpb25zID0gb3B0aW9ucy5kZWxheSksXG4gICAgICAob3B0aW9ucyA9XG4gICAgICAgIFwibnVtYmVyXCIgPT09IHR5cGVvZiBvcHRpb25zICYmIDAgPCBvcHRpb25zXG4gICAgICAgICAgPyBjdXJyZW50VGltZSArIG9wdGlvbnNcbiAgICAgICAgICA6IGN1cnJlbnRUaW1lKSlcbiAgICA6IChvcHRpb25zID0gY3VycmVudFRpbWUpO1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIDE6XG4gICAgICB2YXIgdGltZW91dCA9IC0xO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgdGltZW91dCA9IDI1MDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIHRpbWVvdXQgPSAxMDczNzQxODIzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0OlxuICAgICAgdGltZW91dCA9IDFlNDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gNWUzO1xuICB9XG4gIHRpbWVvdXQgPSBvcHRpb25zICsgdGltZW91dDtcbiAgcHJpb3JpdHlMZXZlbCA9IHtcbiAgICBpZDogdGFza0lkQ291bnRlcisrLFxuICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgIHN0YXJ0VGltZTogb3B0aW9ucyxcbiAgICBleHBpcmF0aW9uVGltZTogdGltZW91dCxcbiAgICBzb3J0SW5kZXg6IC0xXG4gIH07XG4gIG9wdGlvbnMgPiBjdXJyZW50VGltZVxuICAgID8gKChwcmlvcml0eUxldmVsLnNvcnRJbmRleCA9IG9wdGlvbnMpLFxuICAgICAgcHVzaCh0aW1lclF1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgIG51bGwgPT09IHBlZWsodGFza1F1ZXVlKSAmJlxuICAgICAgICBwcmlvcml0eUxldmVsID09PSBwZWVrKHRpbWVyUXVldWUpICYmXG4gICAgICAgIChpc0hvc3RUaW1lb3V0U2NoZWR1bGVkXG4gICAgICAgICAgPyAobG9jYWxDbGVhclRpbWVvdXQodGFza1RpbWVvdXRJRCksICh0YXNrVGltZW91dElEID0gLTEpKVxuICAgICAgICAgIDogKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSAhMCksXG4gICAgICAgIHJlcXVlc3RIb3N0VGltZW91dChoYW5kbGVUaW1lb3V0LCBvcHRpb25zIC0gY3VycmVudFRpbWUpKSlcbiAgICA6ICgocHJpb3JpdHlMZXZlbC5zb3J0SW5kZXggPSB0aW1lb3V0KSxcbiAgICAgIHB1c2godGFza1F1ZXVlLCBwcmlvcml0eUxldmVsKSxcbiAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIHx8XG4gICAgICAgIGlzUGVyZm9ybWluZ1dvcmsgfHxcbiAgICAgICAgKChpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9ICEwKSwgcmVxdWVzdEhvc3RDYWxsYmFjaygpKSk7XG4gIHJldHVybiBwcmlvcml0eUxldmVsO1xufTtcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSBzaG91bGRZaWVsZFRvSG9zdDtcbmV4cG9ydHMudW5zdGFibGVfd3JhcENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIH1cbiAgfTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///477\n')},982:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("\n\nif (true) {\n  module.exports = __webpack_require__(477);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTgyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksSUFBcUM7QUFDekMsRUFBRSx5Q0FBeUQ7QUFDM0QsRUFBRSxLQUFLLEVBRU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz80MDI5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///982\n")},72:module=>{"use strict";eval('\n\nvar stylesInDOM = [];\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n  for (var i = 0; i < stylesInDOM.length; i++) {\n    if (stylesInDOM[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n  return result;\n}\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = "".concat(id, " ").concat(count);\n    idCountMap[id] = count + 1;\n    var indexByIdentifier = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3],\n      supports: item[4],\n      layer: item[5]\n    };\n    if (indexByIdentifier !== -1) {\n      stylesInDOM[indexByIdentifier].references++;\n      stylesInDOM[indexByIdentifier].updater(obj);\n    } else {\n      var updater = addElementStyle(obj, options);\n      options.byIndex = i;\n      stylesInDOM.splice(i, 0, {\n        identifier: identifier,\n        updater: updater,\n        references: 1\n      });\n    }\n    identifiers.push(identifier);\n  }\n  return identifiers;\n}\nfunction addElementStyle(obj, options) {\n  var api = options.domAPI(options);\n  api.update(obj);\n  var updater = function updater(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {\n        return;\n      }\n      api.update(obj = newObj);\n    } else {\n      api.remove();\n    }\n  };\n  return updater;\n}\nmodule.exports = function (list, options) {\n  options = options || {};\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDOM[index].references--;\n    }\n    var newLastIdentifiers = modulesToDom(newList, options);\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n      var _index = getIndexByIdentifier(_identifier);\n      if (stylesInDOM[_index].references === 0) {\n        stylesInDOM[_index].updater();\n        stylesInDOM.splice(_index, 1);\n      }\n    }\n    lastIdentifiers = newLastIdentifiers;\n  };\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2QkFBNkI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzJkYmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzdHlsZXNJbkRPTSA9IFtdO1xuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzSW5ET00ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3R5bGVzSW5ET01baV0uaWRlbnRpZmllciA9PT0gaWRlbnRpZmllcikge1xuICAgICAgcmVzdWx0ID0gaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXTtcbiAgICB2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICB2YXIgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgIHZhciBpZGVudGlmaWVyID0gXCJcIi5jb25jYXQoaWQsIFwiIFwiKS5jb25jYXQoY291bnQpO1xuICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgIHZhciBpbmRleEJ5SWRlbnRpZmllciA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgIHZhciBvYmogPSB7XG4gICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgIHNvdXJjZU1hcDogaXRlbVszXSxcbiAgICAgIHN1cHBvcnRzOiBpdGVtWzRdLFxuICAgICAgbGF5ZXI6IGl0ZW1bNV1cbiAgICB9O1xuICAgIGlmIChpbmRleEJ5SWRlbnRpZmllciAhPT0gLTEpIHtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS5yZWZlcmVuY2VzKys7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0udXBkYXRlcihvYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdXBkYXRlciA9IGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpO1xuICAgICAgb3B0aW9ucy5ieUluZGV4ID0gaTtcbiAgICAgIHN0eWxlc0luRE9NLnNwbGljZShpLCAwLCB7XG4gICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgIHVwZGF0ZXI6IHVwZGF0ZXIsXG4gICAgICAgIHJlZmVyZW5jZXM6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG4gIHJldHVybiBpZGVudGlmaWVycztcbn1cbmZ1bmN0aW9uIGFkZEVsZW1lbnRTdHlsZShvYmosIG9wdGlvbnMpIHtcbiAgdmFyIGFwaSA9IG9wdGlvbnMuZG9tQVBJKG9wdGlvbnMpO1xuICBhcGkudXBkYXRlKG9iaik7XG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGFwaS51cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbW92ZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHVwZGF0ZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZGVudGlmaWVyID0gbGFzdElkZW50aWZpZXJzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleF0ucmVmZXJlbmNlcy0tO1xuICAgIH1cbiAgICB2YXIgbmV3TGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKG5ld0xpc3QsIG9wdGlvbnMpO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuICAgICAgdmFyIF9pbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKF9pZGVudGlmaWVyKTtcbiAgICAgIGlmIChzdHlsZXNJbkRPTVtfaW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgc3R5bGVzSW5ET01bX2luZGV4XS51cGRhdGVyKCk7XG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXN0SWRlbnRpZmllcnMgPSBuZXdMYXN0SWRlbnRpZmllcnM7XG4gIH07XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n')},659:module=>{"use strict";eval('\n\nvar memo = {};\n\n/* istanbul ignore next  */\nfunction getTarget(target) {\n  if (typeof memo[target] === "undefined") {\n    var styleTarget = document.querySelector(target);\n\n    // Special case to return head of iframe instead of iframe itself\n    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n      try {\n        // This will throw an exception if access to iframe is blocked\n        // due to cross-origin restrictions\n        styleTarget = styleTarget.contentDocument.head;\n      } catch (e) {\n        // istanbul ignore next\n        styleTarget = null;\n      }\n    }\n    memo[target] = styleTarget;\n  }\n  return memo[target];\n}\n\n/* istanbul ignore next  */\nfunction insertBySelector(insert, style) {\n  var target = getTarget(insert);\n  if (!target) {\n    throw new Error("Couldn\'t find a style target. This probably means that the value for the \'insert\' parameter is invalid.");\n  }\n  target.appendChild(style);\n}\nmodule.exports = insertBySelector;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL29ubHktb24tY2hhaW4vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzP2IyMTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///659\n')},159:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction insertStyleElement(options) {\n  var element = document.createElement("style");\n  options.setAttributes(element, options.attributes);\n  options.insert(element, options.options);\n  return element;\n}\nmodule.exports = insertStyleElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzP2RlNmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIG9wdGlvbnMuc2V0QXR0cmlidXRlcyhlbGVtZW50LCBvcHRpb25zLmF0dHJpYnV0ZXMpO1xuICBvcHRpb25zLmluc2VydChlbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xuICByZXR1cm4gZWxlbWVudDtcbn1cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0U3R5bGVFbGVtZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///159\n')},56:(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction setAttributesWithoutAttributes(styleElement) {\n  var nonce =  true ? __webpack_require__.nc : 0;\n  if (nonce) {\n    styleElement.setAttribute("nonce", nonce);\n  }\n}\nmodule.exports = setAttributesWithoutAttributes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBLGNBQWMsS0FBd0MsR0FBRyxzQkFBaUIsR0FBRyxDQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vbmx5LW9uLWNoYWluLy4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzLmpzP2RkY2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzKHN0eWxlRWxlbWVudCkge1xuICB2YXIgbm9uY2UgPSB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gIGlmIChub25jZSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n')},825:module=>{"use strict";eval('\n\n/* istanbul ignore next  */\nfunction apply(styleElement, options, obj) {\n  var css = "";\n  if (obj.supports) {\n    css += "@supports (".concat(obj.supports, ") {");\n  }\n  if (obj.media) {\n    css += "@media ".concat(obj.media, " {");\n  }\n  var needLayer = typeof obj.layer !== "undefined";\n  if (needLayer) {\n    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");\n  }\n  css += obj.css;\n  if (needLayer) {\n    css += "}";\n  }\n  if (obj.media) {\n    css += "}";\n  }\n  if (obj.supports) {\n    css += "}";\n  }\n  var sourceMap = obj.sourceMap;\n  if (sourceMap && typeof btoa !== "undefined") {\n    css += "\\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");\n  }\n\n  // For old IE\n  /* istanbul ignore if  */\n  options.styleTagTransform(css, styleElement, options.options);\n}\nfunction removeStyleElement(styleElement) {\n  // istanbul ignore if\n  if (styleElement.parentNode === null) {\n    return false;\n  }\n  styleElement.parentNode.removeChild(styleElement);\n}\n\n/* istanbul ignore next  */\nfunction domAPI(options) {\n  if (typeof document === "undefined") {\n    return {\n      update: function update() {},\n      remove: function remove() {}\n    };\n  }\n  var styleElement = options.insertStyleElement(options);\n  return {\n    update: function update(obj) {\n      apply(styleElement, options, obj);\n    },\n    remove: function remove() {\n      removeStyleElement(styleElement);\n    }\n  };\n}\nmodule.exports = domAPI;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI1LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzP2U0NzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///825\n')},113:module=>{"use strict";eval("\n\n/* istanbul ignore next  */\nfunction styleTagTransform(css, styleElement) {\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css;\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild);\n    }\n    styleElement.appendChild(document.createTextNode(css));\n  }\n}\nmodule.exports = styleTagTransform;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb25seS1vbi1jaGFpbi8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzPzFkZGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gc3R5bGVUYWdUcmFuc2Zvcm0oY3NzLCBzdHlsZUVsZW1lbnQpIHtcbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///113\n")}},__webpack_module_cache__={};function __webpack_require__(I){var n=__webpack_module_cache__[I];if(void 0!==n)return n.exports;var g=__webpack_module_cache__[I]={id:I,exports:{}};return __webpack_modules__[I](g,g.exports,__webpack_require__),g.exports}__webpack_require__.n=I=>{var n=I&&I.__esModule?()=>I.default:()=>I;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(I,n)=>{for(var g in n)__webpack_require__.o(n,g)&&!__webpack_require__.o(I,g)&&Object.defineProperty(I,g,{enumerable:!0,get:n[g]})},__webpack_require__.o=(I,n)=>Object.prototype.hasOwnProperty.call(I,n),__webpack_require__.nc=void 0;var __webpack_exports__=__webpack_require__(270)})();